<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d3 20150301//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 39.96?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">PLoS One</journal-id>
    <journal-id journal-id-type="iso-abbrev">PLoS ONE</journal-id>
    <journal-id journal-id-type="publisher-id">plos</journal-id>
    <journal-id journal-id-type="pmc">plosone</journal-id>
    <journal-title-group>
      <journal-title>PLoS ONE</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1932-6203</issn>
    <publisher>
      <publisher-name>Public Library of Science</publisher-name>
      <publisher-loc>San Francisco, CA USA</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6287880</article-id>
    <article-id pub-id-type="publisher-id">PONE-D-18-18737</article-id>
    <article-id pub-id-type="doi">10.1371/journal.pone.0208510</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Computer and Information Sciences</subject>
        <subj-group>
          <subject>Data Visualization</subject>
          <subj-group>
            <subject>Infographics</subject>
            <subj-group>
              <subject>Graphs</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Computer and Information Sciences</subject>
        <subj-group>
          <subject>Computing Systems</subject>
          <subj-group>
            <subject>Quantum Computing</subject>
            <subj-group>
              <subject>Qubits</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Computer and Information Sciences</subject>
        <subj-group>
          <subject>Computing Systems</subject>
          <subj-group>
            <subject>Quantum Computing</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Simulation and Modeling</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Physical Sciences</subject>
        <subj-group>
          <subject>Mathematics</subject>
          <subj-group>
            <subject>Applied Mathematics</subject>
            <subj-group>
              <subject>Algorithms</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Simulation and Modeling</subject>
          <subj-group>
            <subject>Algorithms</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Computer and Information Sciences</subject>
        <subj-group>
          <subject>Computerized Simulations</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Physical Sciences</subject>
        <subj-group>
          <subject>Mathematics</subject>
          <subj-group>
            <subject>Optimization</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Computer and Information Sciences</subject>
        <subj-group>
          <subject>Computer Architecture</subject>
          <subj-group>
            <subject>Computer Hardware</subject>
          </subj-group>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>qTorch: The quantum tensor contraction handler</article-title>
      <alt-title alt-title-type="running-head">qTorch: The quantum tensor contraction handler</alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" equal-contrib="yes">
        <name>
          <surname>Fried</surname>
          <given-names>E. Schuyler</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Conceptualization</role>
        <role content-type="http://credit.casrai.org/">Methodology</role>
        <role content-type="http://credit.casrai.org/">Project administration</role>
        <role content-type="http://credit.casrai.org/">Software</role>
        <role content-type="http://credit.casrai.org/">Validation</role>
        <role content-type="http://credit.casrai.org/">Writing – original draft</role>
        <role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff001">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author" equal-contrib="yes">
        <contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0001-8510-8480</contrib-id>
        <name>
          <surname>Sawaya</surname>
          <given-names>Nicolas P. D.</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Conceptualization</role>
        <role content-type="http://credit.casrai.org/">Data curation</role>
        <role content-type="http://credit.casrai.org/">Formal analysis</role>
        <role content-type="http://credit.casrai.org/">Funding acquisition</role>
        <role content-type="http://credit.casrai.org/">Methodology</role>
        <role content-type="http://credit.casrai.org/">Project administration</role>
        <role content-type="http://credit.casrai.org/">Software</role>
        <role content-type="http://credit.casrai.org/">Visualization</role>
        <role content-type="http://credit.casrai.org/">Writing – original draft</role>
        <role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff001">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="aff002">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Cao</surname>
          <given-names>Yudong</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Conceptualization</role>
        <role content-type="http://credit.casrai.org/">Data curation</role>
        <role content-type="http://credit.casrai.org/">Formal analysis</role>
        <role content-type="http://credit.casrai.org/">Methodology</role>
        <role content-type="http://credit.casrai.org/">Software</role>
        <role content-type="http://credit.casrai.org/">Validation</role>
        <role content-type="http://credit.casrai.org/">Writing – original draft</role>
        <role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff001">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0003-2719-2500</contrib-id>
        <name>
          <surname>Kivlichan</surname>
          <given-names>Ian D.</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Conceptualization</role>
        <role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff001">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Romero</surname>
          <given-names>Jhonathan</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Methodology</role>
        <role content-type="http://credit.casrai.org/">Software</role>
        <role content-type="http://credit.casrai.org/">Writing – original draft</role>
        <role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff001">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Aspuru-Guzik</surname>
          <given-names>Alán</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Conceptualization</role>
        <role content-type="http://credit.casrai.org/">Funding acquisition</role>
        <role content-type="http://credit.casrai.org/">Project administration</role>
        <role content-type="http://credit.casrai.org/">Resources</role>
        <role content-type="http://credit.casrai.org/">Supervision</role>
        <role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff001">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="aff003">
          <sup>3</sup>
        </xref>
        <xref ref-type="corresp" rid="cor001">*</xref>
      </contrib>
    </contrib-group>
    <aff id="aff001">
      <label>1</label>
      <addr-line>Department of Chemistry and Chemical Biology, Harvard University, Cambridge, MA, United States of America</addr-line>
    </aff>
    <aff id="aff002">
      <label>2</label>
      <addr-line>Intel Labs, Intel Corporation, Santa Clara, CA, United States of America</addr-line>
    </aff>
    <aff id="aff003">
      <label>3</label>
      <addr-line>Canadian Institute for Advanced Research, Toronto, Ontario, Canada</addr-line>
    </aff>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Hen</surname>
          <given-names>Itay</given-names>
        </name>
        <role>Editor</role>
        <xref ref-type="aff" rid="edit1"/>
      </contrib>
    </contrib-group>
    <aff id="edit1">
      <addr-line>University of Southern California, UNITED STATES</addr-line>
    </aff>
    <author-notes>
      <corresp id="cor001">* E-mail: <email>alan@aspuru.com</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <year>2018</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>10</day>
      <month>12</month>
      <year>2018</year>
    </pub-date>
    <volume>13</volume>
    <issue>12</issue>
    <elocation-id>e0208510</elocation-id>
    <history>
      <date date-type="received">
        <day>22</day>
        <month>6</month>
        <year>2018</year>
      </date>
      <date date-type="accepted">
        <day>18</day>
        <month>11</month>
        <year>2018</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2018 Fried et al</copyright-statement>
      <copyright-year>2018</copyright-year>
      <copyright-holder>Fried et al</copyright-holder>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
      </license>
    </permissions>
    <self-uri content-type="pdf" xlink:href="pone.0208510.pdf"/>
    <abstract>
      <p>Classical simulation of quantum computation is necessary for studying the numerical behavior of quantum algorithms, as there does not yet exist a large viable quantum computer on which to perform numerical tests. Tensor network (TN) contraction is an algorithmic method that can efficiently simulate some quantum circuits, often greatly reducing the computational cost over methods that simulate the full Hilbert space. In this study we implement a tensor network contraction program for simulating quantum circuits using multi-core compute nodes. We show simulation results for the Max-Cut problem on 3- through 7-regular graphs using the quantum approximate optimization algorithm (QAOA), successfully simulating up to 100 qubits. We test two different methods for generating the ordering of tensor index contractions: one is based on the tree decomposition of the line graph, while the other generates ordering using a straight-forward stochastic scheme. Through studying instances of QAOA circuits, we show the expected result that as the treewidth of the quantum circuit’s line graph decreases, TN contraction becomes significantly more efficient than simulating the whole Hilbert space. The results in this work suggest that tensor contraction methods are superior only when simulating Max-Cut/QAOA with graphs of regularities approximately five and below. Insight into this point of equal computational cost helps one determine which simulation method will be more efficient for a given quantum circuit. The stochastic contraction method outperforms the line graph based method only when the time to calculate a reasonable tree decomposition is prohibitively expensive. Finally, we release our software package, qTorch (Quantum TensOR Contraction Handler), intended for general quantum circuit simulation. For a nontrivial subset of these quantum circuits, 50 to 100 qubits can easily be simulated on a single compute node.</p>
    </abstract>
    <funding-group>
      <award-group id="award001">
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100002418</institution-id>
            <institution>Intel Corporation</institution>
          </institution-wrap>
        </funding-source>
        <principal-award-recipient>
          <contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0001-8510-8480</contrib-id>
          <name>
            <surname>Sawaya</surname>
            <given-names>Nicolas P. D.</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
      <award-group id="award002">
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100006132</institution-id>
            <institution>Office of Science</institution>
          </institution-wrap>
        </funding-source>
        <award-id>DE-AC02-05CH11231</award-id>
        <principal-award-recipient>
          <contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0001-8510-8480</contrib-id>
          <name>
            <surname>Sawaya</surname>
            <given-names>Nicolas P. D.</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
      <award-group id="award003">
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100000006</institution-id>
            <institution>Office of Naval Research</institution>
          </institution-wrap>
        </funding-source>
        <award-id>N00014-16-1-2008</award-id>
        <principal-award-recipient>
          <name>
            <surname>Aspuru-Guzik</surname>
            <given-names>Alán</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
      <award-group id="award004">
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100000001</institution-id>
            <institution>National Science Foundation</institution>
          </institution-wrap>
        </funding-source>
        <award-id>CHE-1655187</award-id>
        <principal-award-recipient>
          <name>
            <surname>Aspuru-Guzik</surname>
            <given-names>Alán</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
      <funding-statement>N.S. acknowledges the use of resources of the National Energy Research Scientific Computing Center, a DOE Office of Science User Facility supported by the Office of Science of the U.S. Department of Energy under Contract No. DE-AC02-05CH11231 (<ext-link ext-link-type="uri" xlink:href="http://www.nersc.gov">http://www.nersc.gov</ext-link>). A.A.-G. and E.F. were supported by the Office of Naval Research under grant N00014-16-1-2008 (Vannevar Bush Faculty Fellowship) (<ext-link ext-link-type="uri" xlink:href="https://www.onr.navy.mil">https://www.onr.navy.mil</ext-link>). A. A.-G. and Y.C. were supported by NSF grant CHE-1655187 (<ext-link ext-link-type="uri" xlink:href="https://www.nsf.gov">https://www.nsf.gov</ext-link>). The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript. Intel Corporation provided support in the form of salary for N.S., but did not have any additional role in the study design, data collection and analysis, decision to publish, or preparation of the manuscript. The specific roles of the authors are articulated in the ‘author contributions’ section.</funding-statement>
    </funding-group>
    <counts>
      <fig-count count="8"/>
      <table-count count="0"/>
      <page-count count="20"/>
    </counts>
    <custom-meta-group>
      <custom-meta id="data-availability">
        <meta-name>Data Availability</meta-name>
        <meta-value>All files will be available from the following URL: <ext-link ext-link-type="uri" xlink:href="https://github.com/aspuru-guzik-group/qtorch">https://github.com/aspuru-guzik-group/qtorch</ext-link>.</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
  <notes>
    <title>Data Availability</title>
    <p>All files will be available from the following URL: <ext-link ext-link-type="uri" xlink:href="https://github.com/aspuru-guzik-group/qtorch">https://github.com/aspuru-guzik-group/qtorch</ext-link>.</p>
  </notes>
</front>
<body>
  <sec id="sec001">
    <title>1 Introduction</title>
    <p>Experimental hardware for quantum computing has been steadily improving in the past twenty years, indicating that a useful quantum computer that outperforms a classical computer may eventually be built. However, until a large-scale and viable quantum computer has been realized, numerically simulating quantum circuits on a classical computer will be necessary for predicting the behavior of quantum computers.</p>
    <p>Such simulations can play an important role in the development of quantum computing by (1) numerically verifying the correctness and characterizing the performance of quantum algorithms [<xref rid="pone.0208510.ref001" ref-type="bibr">1</xref>–<xref rid="pone.0208510.ref005" ref-type="bibr">5</xref>], (2) simulating error and decoherence due to the interaction between the quantum computer and its environment [<xref rid="pone.0208510.ref006" ref-type="bibr">6</xref>–<xref rid="pone.0208510.ref009" ref-type="bibr">9</xref>], and (3) improving our understanding of the boundary between classical and quantum computing in terms of computational power, for which recent efforts for characterizing the advantage of quantum computers over classical computers [<xref rid="pone.0208510.ref010" ref-type="bibr">10</xref>–<xref rid="pone.0208510.ref017" ref-type="bibr">17</xref>] serve as an example of this direction.</p>
    <p>In this work, we consider the problem of quantum circuit simulation as one where we are given a quantum circuit and an initial state, with the goal of determining the probability of a given output state. Several approaches are possible for such simulation tasks. The most general method is to represent the state vector of an <italic>N</italic>-qubit state by a complex unit vector of dimension 2<sup><italic>N</italic></sup> and apply the quantum gates by performing matrix-vector multiplications. This is essentially the approach adopted in, for example, [<xref rid="pone.0208510.ref001" ref-type="bibr">1</xref>–<xref rid="pone.0208510.ref003" ref-type="bibr">3</xref>, <xref rid="pone.0208510.ref018" ref-type="bibr">18</xref>, <xref rid="pone.0208510.ref019" ref-type="bibr">19</xref>]. This method has the advantage that full information of the quantum state is represented at any point during the circuit propagation. However, the exponential cost of storing and updating the state vector renders it prohibitive for simulating circuits larger than ∼45 qubits. On the other hand, for a wide class of circuits with restricted gate sets and input states [<xref rid="pone.0208510.ref020" ref-type="bibr">20</xref>–<xref rid="pone.0208510.ref024" ref-type="bibr">24</xref>], efficient classical simulation algorithms are available. For example, the numerical package Quipu [<xref rid="pone.0208510.ref025" ref-type="bibr">25</xref>, <xref rid="pone.0208510.ref026" ref-type="bibr">26</xref>] has been developed for taking advantage of prior results [<xref rid="pone.0208510.ref020" ref-type="bibr">20</xref>, <xref rid="pone.0208510.ref021" ref-type="bibr">21</xref>, <xref rid="pone.0208510.ref024" ref-type="bibr">24</xref>] on the stabilizer formalism to speed up general quantum circuit simulation. Finally, path integral-based methods [<xref rid="pone.0208510.ref027" ref-type="bibr">27</xref>] have also been proposed—though they do not improve the simulation cost, they lead to reduced memory storage requirements.</p>
    <p>Other than considering the gate sets involved, an alternative perspective of viewing a quantum circuit is through its geometry or topology [<xref rid="pone.0208510.ref028" ref-type="bibr">28</xref>, <xref rid="pone.0208510.ref029" ref-type="bibr">29</xref>]. Under this view, a quantum circuit is simulated via tensor network contractions. An advantage of viewing quantum circuits as tensor networks is that one can afford to ignore the particular kinds of quantum gates used in a circuit, and instead only focus on the graph theoretic properties. While general quantum circuits involving universal sets of elementary gates are likely hard to simulate on a classical computer [<xref rid="pone.0208510.ref030" ref-type="bibr">30</xref>], this geometric perspective sometimes allows for the efficient simulation of a quantum circuit with a universal gate set, provided that it satisfies certain graph theoretic properties. We note that at least one open source implementation of tensor network simulation for quantum circuits already exists, called TNQVM [<xref rid="pone.0208510.ref031" ref-type="bibr">31</xref>], which can simulate tensor networks but also focuses on integrating algorithms with real quantum hardware. Aside from the field of quantum computation, tensor networks and related methods are an important and active area of research in the simulation of quantum mechanical problems in theoretical physics [<xref rid="pone.0208510.ref032" ref-type="bibr">32</xref>–<xref rid="pone.0208510.ref034" ref-type="bibr">34</xref>].</p>
    <p>Among others, <italic>treewidth</italic> is an important graph theoretic parameter that determines the efficiency of contracting a tensor network of quantum gates. A property of graphs that is actively studied in the graph theory literature [<xref rid="pone.0208510.ref035" ref-type="bibr">35</xref>–<xref rid="pone.0208510.ref038" ref-type="bibr">38</xref>], the treewidth provides important structural information about a quantum circuit. Namely, if the circuit’s underlying tensor network has treewidth <italic>T</italic>, it is shown in [<xref rid="pone.0208510.ref029" ref-type="bibr">29</xref>] that the cost of simulating the circuit is <italic>O</italic>(exp(<italic>T</italic>)). In [<xref rid="pone.0208510.ref010" ref-type="bibr">10</xref>] treewidth is also used for estimating the classical resource needed for simulating certain quantum circuits.</p>
    <p>Motivated by the importance of tensor networks in quantum circuit simulation in general (and for example quantum computational supremacy tests in particular), it is useful to have a circuit simulation platform singularly dedicated to tensor network contraction. One immediate challenge in contracting tensor networks is to find an efficient contraction ordering, which relies on explicitly or implicitly finding a reasonable <italic>tree decomposition</italic> of the underlying graph (definitions are further discussed in Section 2). However, finding the optimal contraction ordering (or equivalently finding the minimum-size tree decomposition, or finding the treewidth of a graph) is NP-complete [<xref rid="pone.0208510.ref039" ref-type="bibr">39</xref>]. Therefore one must typically resort to heuristic methods when finding this decomposition [<xref rid="pone.0208510.ref040" ref-type="bibr">40</xref>].</p>
    <p>For this study, we implemented a plug-and-play tensor network (TN) contraction code with two contraction schemes. Other schemes were attempted, but were significantly inferior to those that became part of the software package. However, there are likely other heuristic schemes that outperform our stochastic algorithm, and this is an avenue worth pursuing. For a large set of quantum circuits, our tensor network based methods are shown to be less costly than simulation of the full Hilbert space, by comparing to simulations using the LIQ<italic>Ui</italic>|&gt; software package [<xref rid="pone.0208510.ref001" ref-type="bibr">1</xref>]. We emphasize again that the tests in this report give timing data for finding the expectation value of a measurement performed after implementing a quantum circuit, not for fully characterizing a circuit’s final state.</p>
    <p>The remainder of the paper is organized as the follows. Section 2 sets up the definitions and notations used in the paper. Section 3 describes the heuristic methods used for contracting the quantum circuit tensor networks, along with other relevant details of the code implementation. Section 4 presents the example quantum circuits used as benchmarks for demonstrating the performance of our contraction algorithms. Section 5 gives results of comparisons between the qTorch contraction methods, and between qTorch simulations and LIQ<italic>Ui</italic>|&gt;’s Hilbert space simulations.</p>
  </sec>
  <sec id="sec002">
    <title>2 Preliminaries</title>
    <p>In this section, we provide an overview of relevant concepts and definitions. All graphs that we consider in this paper are undirected. We denote a graph as <italic>G</italic>(<italic>V</italic>, <italic>E</italic>), consisting of the set of nodes <italic>V</italic> = {<italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>, ⋯, <italic>v</italic><sub><italic>n</italic></sub>} and edges <italic>E</italic> ⊆ <italic>V</italic> × <italic>V</italic>.</p>
    <p>Two relevant concepts are a graph’s tree decomposition and treewidth [<xref rid="pone.0208510.ref035" ref-type="bibr">35</xref>, <xref rid="pone.0208510.ref040" ref-type="bibr">40</xref>]. A <italic>tree decomposition</italic> of a graph <italic>G</italic>(<italic>V</italic>, <italic>E</italic>) is a pair (<italic>S</italic>, <italic>T</italic>(<italic>I</italic>, <italic>F</italic>)), where <italic>S</italic> = {<italic>X</italic><sub><italic>i</italic></sub>|<italic>i</italic> ∈ <italic>I</italic>} is a collection of subsets <italic>X</italic><sub><italic>i</italic></sub> ⊆ <italic>V</italic> and <italic>T</italic> is a tree (with edge set <italic>F</italic> and node set <italic>I</italic>), such that ∪<sub><italic>i</italic>∈<italic>I</italic></sub><italic>X</italic><sub><italic>i</italic></sub> = <italic>V</italic>. Two nodes <italic>X</italic><sub><italic>i</italic></sub> and <italic>X</italic><sub><italic>j</italic></sub> are connected by an edge only if the intersection between <italic>X</italic><sub><italic>i</italic></sub> and <italic>X</italic><sub><italic>j</italic></sub> is not null. The <italic>width</italic> of a tree decomposition (<italic>S</italic>, <italic>T</italic>) is max<sub><italic>i</italic>∈<italic>I</italic></sub>|<italic>X</italic><sub><italic>i</italic></sub>| − 1. The <italic>treewidth</italic> of a graph <italic>G</italic> is the minimum width among all tree decompositions of <italic>G</italic>.</p>
    <p>Another important concept in tensor network methods is the <italic>linegraph</italic> of graph <italic>G</italic>, denoted by <italic>L</italic>(<italic>G</italic>). <italic>L</italic>(<italic>G</italic>) is itself an undirected graph, with each edge in <italic>G</italic> corresponding to a node in <italic>L</italic>(<italic>G</italic>). Two nodes in <italic>L</italic>(<italic>G</italic>) are connected if and only if these two nodes’ corresponding edges in <italic>G</italic> are connected to the same node in <italic>G</italic>. There exists an optimal tree decomposition of <italic>L</italic>(<italic>G</italic>) that provides the optimal contraction ordering of <italic>G</italic> [<xref rid="pone.0208510.ref029" ref-type="bibr">29</xref>].</p>
    <p>In the context of this work, a <italic>tensor</italic> is defined as a data structure with rank <italic>k</italic> and dimension <italic>m</italic>. More specifically, each tensor is a multidimensional array with <italic>m</italic><sup><italic>k</italic></sup> complex entries. Each index may have a different dimension, though in this work each index has the same dimension <italic>m</italic> = 4. A tensor <inline-formula id="pone.0208510.e001"><alternatives><graphic xlink:href="pone.0208510.e001.jpg" id="pone.0208510.e001g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M1"><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> has <italic>k</italic> indices, which take values from 0 to <italic>m</italic> − 1.</p>
    <p>A <italic>tensor contraction</italic> is a generalized tensor-tensor multiplication. Here a rank (<italic>x</italic> + <italic>y</italic>) dimension <italic>m</italic> tensor <italic>A</italic> and a rank (<italic>y</italic> + <italic>z</italic>) dimension <italic>m</italic> tensor <italic>B</italic> are contracted into <italic>C</italic>, a rank (<italic>x</italic> + <italic>z</italic>) dimension <italic>m</italic> tensor.
<disp-formula id="pone.0208510.e002"><alternatives><graphic xlink:href="pone.0208510.e002.jpg" id="pone.0208510.e002g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M2"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>k</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>k</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>k</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mi>B</mml:mi><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>k</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>k</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(1)</label></disp-formula></p>
    <p>Note that the number of floating point operations performed is <italic>m</italic><sup><italic>x</italic>+<italic>y</italic>+<italic>z</italic></sup>, exponential in the number of indices contracted on <italic>y</italic> and the rank of the resulting tensor (<italic>x</italic> + <italic>z</italic>). It is important to point out that pairwise contractions are always optimal [<xref rid="pone.0208510.ref041" ref-type="bibr">41</xref>]. In other words, a function that contracts three or more nodes at a time will not achieve an improvement in scaling.</p>
    <p>A <italic>tensor network</italic> is a graph <italic>G</italic> = (<italic>V</italic>, <italic>E</italic>) with tensors as vertices, and edges labeled by a set of indices. The rank of each tensor is given by the number of edges connected to it. An edge from one tensor to another indicates a contraction between the two tensors, and multiple connected edges indicate a contraction on multiple indices. <xref ref-type="fig" rid="pone.0208510.g001">Fig 1</xref> shows an example of a tensor network. Note that a tensor may have open edges, <italic>i.e</italic>. edges that do not connect to any other tensor, though this possibility is not allowed in the current version of qTorch.</p>
    <fig id="pone.0208510.g001" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.1371/journal.pone.0208510.g001</object-id>
      <label>Fig 1</label>
      <caption>
        <title>An example of a tensor network.</title>
        <p>The number of edges (or wires) connecting to a tensor is equal to that tensor’s rank. When an index (edge) is contracted by combining two tensors according to <xref ref-type="disp-formula" rid="pone.0208510.e002">Eq 1</xref>, the two tensor are replaced by a new one. The number of scalar entries in the tensor scales exponentially in the number of edges to which it connects. In general it is not trivial to choose an efficient contraction ordering that minimizes the total number of floating point operations.</p>
      </caption>
      <graphic xlink:href="pone.0208510.g001"/>
    </fig>
    <p>A contraction ordering or contraction scheme determines the order in which the tensor network is contracted. The ordering chosen for the contraction will greatly affect the computation and memory requirements, because some contraction orderings can result in much larger intermediate tensors than others. Although in this work we focus on contracting the tensor network to a scalar that equals the expectation value of the quantum circuit’s measurement, the goal of a tensor network algorithm is often <italic>not</italic> to contract it to a scalar [<xref rid="pone.0208510.ref032" ref-type="bibr">32</xref>, <xref rid="pone.0208510.ref034" ref-type="bibr">34</xref>]. An example of this is the infinite tensor networks used to study periodic systems in condensed matter physics.</p>
    <p>An important goal is to avoid tensors of large intermediate rank when contracting the network, as floating point operations grow exponentially with tensor rank. However, it is often the case that increasing the tensor rank is unavoidable. A simple example of this issue is a tetrahedral graph of rank 3 tensors (<xref ref-type="fig" rid="pone.0208510.g002">Fig 2</xref>), which cannot be contracted without forming intermediate tensors of rank greater than 3. The larger the treewidth of <italic>L</italic>(<italic>G</italic>) is, the more one will be forced to create new tensors of higher rank as the network is contracted, greatly increasing the computational cost [<xref rid="pone.0208510.ref029" ref-type="bibr">29</xref>].</p>
    <fig id="pone.0208510.g002" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.1371/journal.pone.0208510.g002</object-id>
      <label>Fig 2</label>
      <caption>
        <title>A tetrahedral graph illustrates why it is often unavoidable to form tensors of higher rank while contracting a tensor network.</title>
        <p>In this example, contracting any of the six edges produces a tensor of rank 4, even though all of the original tensors were of rank 3.</p>
      </caption>
      <graphic xlink:href="pone.0208510.g002"/>
    </fig>
    <p>We note that tensor network methods are commonly used to efficiently find approximate solutions—indeed this is often the main source of a TN’s utility. In approximate TN methods, the space of the smaller values of the eigenspectrum are removed, after e.g. performing a singular value decomposition on the tensor [<xref rid="pone.0208510.ref032" ref-type="bibr">32</xref>, <xref rid="pone.0208510.ref034" ref-type="bibr">34</xref>]. This allows one to contract to form a larger tensor, then renormalize its size before continuing to contract the network. Though this strategy is useful in the context of quantum circuits as well, the current version of qTorch is limited to numerically exact contractions of the tensor network.</p>
    <p>Before contracting, the tensor network graph must first be created from a quantum circuit, a procedure that has been summarized in previous work [<xref rid="pone.0208510.ref029" ref-type="bibr">29</xref>]. Each node on the graph represents one of the following: An initial state of the qubit (usually |0〉〈0|), a gate operation, or a measurement. The initial density matrix is represented as a rank 1 dimension 4 tensor (i.e. a vector), [<italic>ρ</italic><sub>|0〉〈0|</sub>;<italic>ρ</italic><sub>|0〉〈1|</sub>;<italic>ρ</italic><sub>|1〉〈0|</sub>;<italic>ρ</italic><sub>|1〉〈1|</sub>]. Measurement nodes are rank 1 as well. All indices in the graph are dimension 4, regardless of rank. Nodes corresponding to quantum gates are represented in superoperator form. Hence a gate <italic>U</italic> which acts on the quantum state as <italic>ρ</italic> → <italic>UρU</italic><sup>†</sup> is represented by the superoperator <inline-formula id="pone.0208510.e003"><alternatives><graphic xlink:href="pone.0208510.e003.jpg" id="pone.0208510.e003g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M3"><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:math></alternatives></inline-formula>. The same operation can be expressed as <inline-formula id="pone.0208510.e004"><alternatives><graphic xlink:href="pone.0208510.e004.jpg" id="pone.0208510.e004g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M4"><mml:mrow><mml:mover accent="true"><mml:mi>ρ</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>→</mml:mo><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mover accent="true"><mml:mi>ρ</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></alternatives></inline-formula>, where <inline-formula id="pone.0208510.e005"><alternatives><graphic xlink:href="pone.0208510.e005.jpg" id="pone.0208510.e005g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M5"><mml:mover accent="true"><mml:mi>ρ</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:math></alternatives></inline-formula> is the Lindblad representation of the density operator. Single qubit gates correspond to rank 2 tensors and two-qubit gates correspond to rank 4 tensors. The graph’s connectivity is identical to the connectivity of the original quantum circuit.</p>
    <p>We end this section with explicit examples of tensors for standard quantum circuit components. Tensors for other circuit components can be viewed in the source code for qTorch.</p>
    <p>The initial state |0〉〈0| corresponds to the tensor
<disp-formula id="pone.0208510.e006"><alternatives><graphic xlink:href="pone.0208510.e006.jpg" id="pone.0208510.e006g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M6"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>ρ</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(2)</label></disp-formula></p>
    <p>Superoperator tensors for the Pauli matrices are
<disp-formula id="pone.0208510.e007"><alternatives><graphic xlink:href="pone.0208510.e007.jpg" id="pone.0208510.e007g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M7"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mo>[</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>]</mml:mo><mml:mo>;</mml:mo><mml:mover accent="true"><mml:mi>Y</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mo>[</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>]</mml:mo><mml:mo>;</mml:mo><mml:mover accent="true"><mml:mi>Z</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mo>[</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>]</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(3)</label></disp-formula></p>
    <p>The CNOT gate is represented as a sparse rank 4 tensor for which only the following entries are nonzero:
<disp-formula id="pone.0208510.e008"><alternatives><graphic xlink:href="pone.0208510.e008.jpg" id="pone.0208510.e008g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M8"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mrow><mml:mi>C</mml:mi><mml:mi>N</mml:mi><mml:mi>O</mml:mi><mml:mi>T</mml:mi></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mn>0000</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mn>0101</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mn>0202</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mn>0303</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mn>1011</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mn>1110</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mn>1213</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mn>1312</mml:mn></mml:msub><mml:mo>=</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mn>2022</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mn>2123</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mn>2220</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mn>2321</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mn>3033</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mn>3132</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mn>3231</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mn>3330</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(4)</label></disp-formula></p>
    <p>Finally, the nodes for measurement are rank 1 tensors. <inline-formula id="pone.0208510.e009"><alternatives><graphic xlink:href="pone.0208510.e009.jpg" id="pone.0208510.e009g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M9"><mml:msub><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mi>X</mml:mi></mml:msub></mml:math></alternatives></inline-formula>, <inline-formula id="pone.0208510.e010"><alternatives><graphic xlink:href="pone.0208510.e010.jpg" id="pone.0208510.e010g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M10"><mml:msub><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mi>Y</mml:mi></mml:msub></mml:math></alternatives></inline-formula>, and <inline-formula id="pone.0208510.e011"><alternatives><graphic xlink:href="pone.0208510.e011.jpg" id="pone.0208510.e011g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M11"><mml:msub><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mi>Z</mml:mi></mml:msub></mml:math></alternatives></inline-formula> correspond respectively to determining expectation values for measurements in the <italic>X</italic>, <italic>Y</italic>, and <italic>Z</italic> bases. Note that using <inline-formula id="pone.0208510.e012"><alternatives><graphic xlink:href="pone.0208510.e012.jpg" id="pone.0208510.e012g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M12"><mml:msub><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mi>X</mml:mi></mml:msub></mml:math></alternatives></inline-formula>, <inline-formula id="pone.0208510.e013"><alternatives><graphic xlink:href="pone.0208510.e013.jpg" id="pone.0208510.e013g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M13"><mml:msub><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mi>Y</mml:mi></mml:msub></mml:math></alternatives></inline-formula>, or <inline-formula id="pone.0208510.e014"><alternatives><graphic xlink:href="pone.0208510.e014.jpg" id="pone.0208510.e014g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M14"><mml:msub><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mi>Z</mml:mi></mml:msub></mml:math></alternatives></inline-formula> is equivalent to inserting a Pauli gate at the end of the circuit before implementing <inline-formula id="pone.0208510.e015"><alternatives><graphic xlink:href="pone.0208510.e015.jpg" id="pone.0208510.e015g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M15"><mml:msub><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mrow><mml:mi>T</mml:mi><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>.
<disp-formula id="pone.0208510.e016"><alternatives><graphic xlink:href="pone.0208510.e016.jpg" id="pone.0208510.e016g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M16"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mrow><mml:mi>T</mml:mi><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>[</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>]</mml:mo><mml:mo>;</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mi>X</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>[</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>]</mml:mo><mml:mo>;</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mi>Y</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>[</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>i</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>-</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>]</mml:mo><mml:mo>;</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mi>Z</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>[</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mo>]</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(5)</label></disp-formula></p>
  </sec>
  <sec id="sec003">
    <title>3 Contraction schemes and implementation details</title>
    <p>For many problems in quantum physics to which matrix product states (MPS) or other tensor network methods have been applied, an efficient contraction scheme is often obvious from the underlying structure of the Hamiltonian [<xref rid="pone.0208510.ref033" ref-type="bibr">33</xref>]. However, efficient contraction schemes are not available for arbitrary tensor networks. A general heuristic contraction scheme is important for the simulation of general quantum circuits, when one does not know a priori the topological properties of the underlying tensor network problem.</p>
    <sec id="sec004">
      <title>3.1 Contraction schemes</title>
      <p>qTorch implements two algorithms for determining the contraction ordering. For what we call the line graph (<italic>LG</italic>) method, outlined in Algorithm 1, we first create the line graph of the quantum circuit’s graph. Then, the software package QuickBB [<xref rid="pone.0208510.ref038" ref-type="bibr">38</xref>] is used to determine an approximately optimal tree decomposition of this linegraph. The resulting tree decomposition is used to define the order of contraction. This linegraph-based approach was first described by Markov and Shi [<xref rid="pone.0208510.ref029" ref-type="bibr">29</xref>].</p>
      <p>QuickBB uses a so-called anytime algorithm, meaning that it can be run for an arbitrary amount of time, such that when the program is stopped it provides the best solution found thus far. The algorithm is based on the branch and bound (B&amp;B) method, though the authors use several techniques based on modern graph theory to improve efficiency in the pruning and propagation steps, making QuickBB faster at finding low-width tree decompositions than vanilla B&amp;B.</p>
      <p>The second contraction scheme is a simple stochastic procedure we refer to as <italic>Stoch</italic> (Algorithm 2). First, a wire is randomly chosen. If the rank of the contracted tensor is higher than the highest rank of the two nodes, plus a given threshold, the contraction is rejected. After a fixed number of rejected contraction attempts, the threshold is relaxed.</p>
      <p><bold>Algorithm 1</bold> Contraction via TD of L(G)</p>
      <p specific-use="line">1: Create line graph L(G) of graph G</p>
      <p specific-use="line">2: <italic>π</italic> ← (Calculate approx. optimal elimination ordering of L(G))</p>
      <p specific-use="line">3: Eliminate wires of G in order <italic>π</italic></p>
      <p><bold>Algorithm 2</bold> Simple stochastic contraction</p>
      <p specific-use="line">1: Define <italic>G</italic> ← The tensor network Graph</p>
      <p specific-use="line">2: <italic>Threshold</italic> ← −1</p>
      <p specific-use="line">3: Define <italic>MaxRejections</italic> ← Maximum Number of Rejections</p>
      <p specific-use="line">4: <bold>repeat</bold></p>
      <p specific-use="line">5:  Choose a random wire <italic>w</italic></p>
      <p specific-use="line">6:  (<italic>A</italic>, <italic>B</italic>) ← (Nodes of <italic>w</italic>)</p>
      <p specific-use="line">7:  Cost ← rank(<italic>C</italic>) − max(rank(<italic>A</italic>), rank(<italic>B</italic>))</p>
      <p specific-use="line">8:  <bold>if</bold> Cost ≤ Threshold <bold>then</bold></p>
      <p specific-use="line">9:   Contract <italic>w</italic> to form node <italic>C</italic></p>
      <p specific-use="line">10:   <italic>Rejections</italic> ← 0</p>
      <p specific-use="line">11:   <italic>Threshold</italic> ← -1</p>
      <p specific-use="line">12:   Update <italic>G</italic></p>
      <p specific-use="line">13:  <bold>else</bold></p>
      <p specific-use="line">14:   <italic>Rejections</italic> ← <italic>Rejections</italic> + 1</p>
      <p specific-use="line">15:   <bold>if</bold>
<italic>Rejections</italic> &gt; <italic>MaxRejections</italic>
<bold>then</bold></p>
      <p specific-use="line">16:    <italic>Threshold</italic> ← <italic>Threshold</italic> + 1</p>
      <p specific-use="line">17:    <italic>Rejections</italic> ← 0</p>
      <p specific-use="line">18:    Continue</p>
      <p specific-use="line">19: <bold>until</bold> Graph completely contracted</p>
    </sec>
    <sec id="sec005">
      <title>3.2 Threading</title>
      <p>The tensor contractions are parallelized using the C++ standard library’s <monospace>std::thread</monospace> class. A particular tensor-tensor contraction is parallelized if the cost of contracting a pair is higher than a provided threshold. We implement other parallelization schemes at the network level, i.e. splitting up the nodes into separate groups to compute on different threads, but the vast majority of the parallelization speedup comes from threading the tensor–tensor contractions. Currently, qTorch does not support parallelization across multiple compute nodes within a cluster, but it allows the user to specify the number of threads (default of 8).</p>
    </sec>
    <sec id="sec006">
      <title>3.3 Estimating the answer string</title>
      <p>qTorch computes expectation values of the form 〈<italic>ψ</italic>|<italic>M</italic>|<italic>ψ</italic>〉, where <italic>M</italic> is a measurement operator such as a Pauli string, and |<italic>ψ</italic>〉 is the quantum state produced by the circuit. If instead one wishes to capture all the information of this final state of <italic>n</italic> qubits, it generally requires <italic>O</italic>(2<sup><italic>n</italic></sup>) repetitions of the algorithm. However, many quantities of interest may be calculated efficiently. For instance, the probability that one measurement operator (e.g. a Pauli string) will provide a particular outcome can be estimated in just one contraction of the tensor network, a result essential to simulating the variational quantum eigensolver (VQE) [<xref rid="pone.0208510.ref042" ref-type="bibr">42</xref>–<xref rid="pone.0208510.ref045" ref-type="bibr">45</xref>].</p>
      <p>qTorch provides a heuristic scheme to output a high-probability answer string from the circuit, which we summarize here. Though this scheme is not used for the results presented in Section 5, it may be useful in the future for simulating algorithms (like QAOA) where the goal is to estimate a most likely bit string.</p>
      <p>The scheme is implemented as follows. First we run one simulation, and measure in the computational basis to project the first qubit into 0 or 1. Based on the resulting expectation value from the simulation, we choose the value for the first qubit that has the greater probability. If the 0 and 1 are equally likely, one is chosen randomly. In the next full contraction, we set the resulting binary value as the measurement outcome for the first qubit in the next simulation, and repeat with a projective measurement on the second qubit. We continue this process for the rest of the qubits. As we show below, this method often gives a good approximation of the most likely final computational basis state. In original tests on 3-regular graphs of 30 vertices, the scheme (used on Quantum Approximate Optimization Algorithm [QAOA] circuits) gave bit strings that provided good estimates to the solution of the Max-Cut problem (average approximation ratio of 94% compared to the exact brute force solution).</p>
      <p>As a way to test the general applicability of this scheme, we performed some tests on more general circuits than the QAOA problem. These tests are meant to provide some early insight into how useful this heuristic would be for estimating the most likely bit string of a quantum algorithm, for the users who are interested in running this string estimation subroutine. We note that it is abundantly clear that in many cases this scheme does not produce a string closest to the most likely string—indeed, if it was a generally accurate scheme then we would have no need for a quantum computer.</p>
      <p>In the remainder of this section, we consider the most likely bit string of the final state |<italic>ψ</italic>〉 = ∑<sub><italic>i</italic></sub>
<italic>ψ</italic><sub><italic>i</italic></sub>|<italic>i</italic>〉, which we define as argmax<sub><italic>i</italic></sub>|<italic>ψ</italic><sub><italic>i</italic></sub>|<sup>2</sup>, where the vectors {|<italic>i</italic>〉} are in the computational basis. We apply a unitary of the form
<disp-formula id="pone.0208510.e017"><alternatives><graphic xlink:href="pone.0208510.e017.jpg" id="pone.0208510.e017g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M17"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>U</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">β</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">γ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>p</mml:mi></mml:munderover><mml:mtext>exp</mml:mtext><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:msub><mml:mi>β</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>)</mml:mo><mml:mtext>exp</mml:mtext><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:msub><mml:mi>γ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mi>D</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(6)</label></disp-formula>
where the matrix <italic>D</italic><sub><italic>j</italic></sub> is a diagonal matrix with entries chosen randomly from the integers {1, ⋯, <italic>nm</italic>}. Here <italic>m</italic> is a parameter that could be interpreted as the number of clauses, if this were a QAOA problem. The elements of the <italic>p</italic>-dimensional vectors <italic><bold>β</bold></italic> and <italic><bold>γ</bold></italic> are drawn uniformly from [0, <italic>π</italic>] and [0, 2<italic>π</italic>] respectively. We use the construction of <italic>U</italic><sub><italic>p</italic></sub>(<italic><bold>β</bold></italic>, <italic><bold>γ</bold></italic>) to emulate the form of parametrized unitary operations used in QAOA with the same <italic>p</italic>. Starting from the uniform superposition over all 2<sup><italic>n</italic></sup> bit strings |<italic>s</italic>〉, we apply <italic>U</italic><sub><italic>p</italic></sub> to compute the final state <inline-formula id="pone.0208510.e018"><alternatives><graphic xlink:href="pone.0208510.e018.jpg" id="pone.0208510.e018g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M18"><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mo>Ψ</mml:mo><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>U</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mrow><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>. Let <italic>p</italic><sub><italic>i</italic></sub> = |<italic>ψ</italic><sub><italic>i</italic></sub>|<sup>2</sup> denote the probability distribution associated to the QAOA-like output state |Ψ〉. We ran 10,000 trials (with n = 6, m = 10, and p = 2) using <xref ref-type="disp-formula" rid="pone.0208510.e017">Eq 6</xref>, and ranked the result by how many bit strings in the true state were more likely than our outputted bit string.</p>
      <p>Conceptually, our likely string estimation algorithm can be thought of as falsely assuming that the output state is a product state. Suppose we apply our algorithm to the state |Ψ〉. The product state then reads
<disp-formula id="pone.0208510.e019"><alternatives><graphic xlink:href="pone.0208510.e019.jpg" id="pone.0208510.e019g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M19"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:msup><mml:mo>Ψ</mml:mo><mml:mo>′</mml:mo></mml:msup><mml:mrow><mml:mo>⟩</mml:mo><mml:mo>=</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:mn>0</mml:mn><mml:mo>⟩</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mi>β</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>|</mml:mo><mml:mn>1</mml:mn><mml:mo>⟩</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mo>⊗</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:mn>0</mml:mn><mml:mo>⟩</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mi>β</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mrow><mml:mo>|</mml:mo><mml:mn>1</mml:mn><mml:mo>⟩</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mo>⊗</mml:mo><mml:mo>⋯</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mn>0</mml:mn><mml:mo>⟩</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mi>β</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mrow><mml:mo>|</mml:mo><mml:mn>1</mml:mn><mml:mo>⟩</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(7)</label></disp-formula>
where |<italic>α</italic><sub><italic>k</italic></sub>|<sup>2</sup> is the probability of |0〉 that the algorithm obtains at the <italic>k</italic><sup>th</sup> step, with an analogous definition for <italic>β</italic><sub><italic>k</italic></sub>. With this conceptual framing, we also numerically study the 1-norm distance ∥<bold>p</bold>′ − <bold>p</bold>∥<sub>1</sub> between the approximate distribution <bold>p</bold>′ which the algorithm effectively assumes and the actual distribution <bold>p</bold>.</p>
      <p>The results are shown in <xref ref-type="fig" rid="pone.0208510.g003">Fig 3</xref>. Here we use the number of qubits <italic>n</italic> = 6, with parameters <italic>m</italic> = 10 and <italic>p</italic> = 2. <xref ref-type="fig" rid="pone.0208510.g003">Fig 3(a)</xref> shows that most of the time our algorithm produces a high ranking bit string—roughly 90% of the time the output of the algorithm is among the top 10% most likely bit strings. <xref ref-type="fig" rid="pone.0208510.g003">Fig 3(b)</xref> shows that the 1-norm distance between the approximate and exact distributions is less than 0.1 for nearly all of the data points. These results suggest that our heuristic for estimating an output bit string will produce acceptable estimates for some circumstances—in QAOA for instance, where one might be interested in a good approximate (as opposed to exact) solution to the constraint satisfaction problem.</p>
      <fig id="pone.0208510.g003" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0208510.g003</object-id>
        <label>Fig 3</label>
        <caption>
          <title>Results from implementing 10,000 trials of <xref ref-type="disp-formula" rid="pone.0208510.e017">Eq 6</xref>.</title>
          <p>We use <italic>n</italic> = 6 qubits, <italic>m</italic> = 10, and <italic>p</italic> = 2. <bold>(a)</bold> The histogram plots how close the method’s output string is to the actual most likely string. qTorch’s procedure for the “estimate” is given in the text. The horizontal axis <italic>Ranking</italic> is the number of computational basis states in |Ψ〉 with higher probability than the estimated string—a lower number ranking indicates a better estimate. <bold>(b)</bold> Distribution of the 1-norm distance between the approximate distribution <bold>p</bold>′ arising from the product state approximation |Ψ′〉 in and the distribution <bold>p</bold> arising from the exact state |Ψ〉.</p>
        </caption>
        <graphic xlink:href="pone.0208510.g003"/>
      </fig>
    </sec>
    <sec id="sec007">
      <title>3.4 A note on noise</title>
      <p>It is possible to simulate noise within the quantum circuit model, by mapping a noise model onto a set of one-qubit or multi-qubit operators [<xref rid="pone.0208510.ref030" ref-type="bibr">30</xref>, <xref rid="pone.0208510.ref046" ref-type="bibr">46</xref>].</p>
      <p>Note that any quantum operation can be expressed in terms of Kraus operators {<italic>E</italic><sub><italic>j</italic></sub>}
<disp-formula id="pone.0208510.e020"><alternatives><graphic xlink:href="pone.0208510.e020.jpg" id="pone.0208510.e020g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M20"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>→</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mi>j</mml:mi></mml:munder><mml:msub><mml:mi>E</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mi>ρ</mml:mi><mml:msubsup><mml:mi>E</mml:mi><mml:mi>j</mml:mi><mml:mo>†</mml:mo></mml:msubsup></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(8)</label></disp-formula>
where {<italic>E</italic><sub><italic>j</italic></sub>} are called Kraus operators [<xref rid="pone.0208510.ref046" ref-type="bibr">46</xref>], and <inline-formula id="pone.0208510.e021"><alternatives><graphic xlink:href="pone.0208510.e021.jpg" id="pone.0208510.e021g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M21"><mml:mrow><mml:msub><mml:mo>∑</mml:mo><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mi>E</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:msubsup><mml:mi>E</mml:mi><mml:mi>j</mml:mi><mml:mo>†</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></alternatives></inline-formula> because for our purposes the noise process is assumed to be trace-preserving. A noise model can be expressed in terms of such Kraus operators, which can in turn be expressed as superoperators for insertion into the quantum circuit’s tensor network.</p>
      <p>The most commonly used approximations assume that noise on different qubits is uncorrelated, which allows for single-qubit “noise gates” to be used. In this case, because rank 2 tensors can always be contracted without increasing the rank of the resulting tensors, the cost of simulating the resulting “noisy” quantum circuit would not substantially increase. One common and easily implementable approximation is the Pauli twirl approximation, which approximates a noise process purely in terms of Pauli rotations [<xref rid="pone.0208510.ref006" ref-type="bibr">6</xref>–<xref rid="pone.0208510.ref009" ref-type="bibr">9</xref>], and therefore can be implemented with the built-in quantum gates of qTorch.</p>
      <p>A more physically realistic noise model would assume correlated noise [<xref rid="pone.0208510.ref047" ref-type="bibr">47</xref>, <xref rid="pone.0208510.ref048" ref-type="bibr">48</xref>], which necessitates the insertion of noise gates that operate on at least two qubits. In this case, the tree width of the circuit’s underlying line graph, and hence the complexity of the problem, would increase in all but the most trivial cases.</p>
      <p>qTorch does not incorporate built-in noise gates. Instead, we include functionality that allows for user-defined gates.</p>
    </sec>
  </sec>
  <sec id="sec008">
    <title>4 Circuit simulations</title>
    <p>Here we describe the classes of quantum circuits that were simulated for this work.</p>
    <sec id="sec009">
      <title>4.1 QAOA / Max-Cut</title>
      <p>The quantum approximate optimization algorithm (QAOA) was recently developed [<xref rid="pone.0208510.ref049" ref-type="bibr">49</xref>], for the purpose of demonstrating quantum speedup for combinatorial problems on low-depth quantum circuits. Given a constraint satisfaction problem (CSP), a QAOA quantum circuit produces an output that provides approximate solutions. Several aspects of QAOA have been studied since its introduction, including its application to different classes of CSP, implementations of different classical optimization routines, and numerical and analytical comparisons to classical algorithms [<xref rid="pone.0208510.ref011" ref-type="bibr">11</xref>, <xref rid="pone.0208510.ref049" ref-type="bibr">49</xref>–<xref rid="pone.0208510.ref053" ref-type="bibr">53</xref>].</p>
      <p>We use qTorch to simulate QAOA for the Max-Cut problem, a combinatorial problem that has been a focus of QAOA [<xref rid="pone.0208510.ref049" ref-type="bibr">49</xref>]. Given an arbitrary undirected graph, the goal of Max-Cut is to assign one of two colors to each node, so as to maximize the number of cuts. A cut is any edge that connects two nodes of different color. A more detailed explanation of QAOA is given in the Appendix, though we summarize important aspects of the algorithm here.</p>
      <p>In QAOA, a set of constraints is mapped to a an objective function represented by a set of operators. Specifically for the Max-Cut problem, the object function is
<disp-formula id="pone.0208510.e022"><alternatives><graphic xlink:href="pone.0208510.e022.jpg" id="pone.0208510.e022g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M22"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo>⟨</mml:mo><mml:mi>i</mml:mi><mml:mi>j</mml:mi><mml:mo>⟩</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mo>⟨</mml:mo><mml:mi>i</mml:mi><mml:mi>j</mml:mi><mml:mo>⟩</mml:mo></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(9)</label></disp-formula>
with
<disp-formula id="pone.0208510.e023"><alternatives><graphic xlink:href="pone.0208510.e023.jpg" id="pone.0208510.e023g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M23"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mo>〈</mml:mo><mml:mi>i</mml:mi><mml:mi>j</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>i</mml:mi><mml:mi>z</mml:mi></mml:msubsup><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>j</mml:mi><mml:mi>z</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives><label>(10)</label></disp-formula>
where 〈<italic>ij</italic>〉 represents the edge between nodes <italic>i</italic> and <italic>j</italic>, <inline-formula id="pone.0208510.e024"><alternatives><graphic xlink:href="pone.0208510.e024.jpg" id="pone.0208510.e024g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M24"><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>k</mml:mi><mml:mi>z</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> is the Pauli-Z operator on qubit <italic>k</italic>, and each node in the underlying Max-Cut graph (which is related to but not the same as the quantum circuit’s graph) corresponds to one qubit in the quantum circuit.</p>
      <p>Define two operators <italic>U</italic>(<italic>C</italic>, <italic>γ</italic>) and <italic>U</italic>(<italic>B</italic>, <italic>β</italic>) as
<disp-formula id="pone.0208510.e025"><alternatives><graphic xlink:href="pone.0208510.e025.jpg" id="pone.0208510.e025g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M25"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>U</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>γ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>-</mml:mo><mml:mi>i</mml:mi><mml:mi>γ</mml:mi><mml:mi>C</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>-</mml:mo><mml:mi>i</mml:mi><mml:mi>γ</mml:mi><mml:msub><mml:mi>C</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(11)</label></disp-formula>
and
<disp-formula id="pone.0208510.e026"><alternatives><graphic xlink:href="pone.0208510.e026.jpg" id="pone.0208510.e026g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M26"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>U</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>β</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>-</mml:mo><mml:mi>i</mml:mi><mml:mi>β</mml:mi><mml:mi>B</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>q</mml:mi></mml:munderover><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>-</mml:mo><mml:mi>i</mml:mi><mml:mi>β</mml:mi><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>k</mml:mi><mml:mi>x</mml:mi></mml:msubsup></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(12)</label></disp-formula>
where <inline-formula id="pone.0208510.e027"><alternatives><graphic xlink:href="pone.0208510.e027.jpg" id="pone.0208510.e027g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M27"><mml:mrow><mml:mi>B</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>q</mml:mi></mml:msubsup><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>k</mml:mi><mml:mi>x</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>, <italic>σ</italic><sub><italic>x</italic></sub> is the Pauli-X operator, <italic>q</italic> is the number of qubits, and <italic>n</italic> is the number of clauses (for Max-Cut this is the number of edges). These two operators are applied <italic>p</italic> times (with different <italic>γ</italic> and <italic>β</italic> allowed for each step), with a larger <italic>p</italic> providing a better approximation. The <italic>γ</italic> and <italic>β</italic> parameters are modified with a classical optimization routine to maximize the cost function. The cost function is evaluated after each measurement, with the bit string that resulted from the measurement.</p>
      <p>To generate the graphs for the underlying Max-Cut problem, we made random <italic>k</italic>-regular graphs by placing edges randomly throughout a given vertex set to satisfy a given regularity, before ensuring that disconnected graphs are rejected. QAOA/Max-Cut Quantum circuits based on these graphs are then constructed.</p>
      <p>In the numerical results of this paper, we report only the timing for a single contraction of each quantum circuit. A full analysis of QAOA is beyond the scope of this work. However, we note that once the graphs have been created, qTorch currently has the functionality to optimize the QAOA angles using the classical optimization library NLopt [<xref rid="pone.0208510.ref054" ref-type="bibr">54</xref>]. Finally, one can use qTorch to estimate a Max-Cut for the randomly-generated graph, using the most-likely bit string estimation method described above.</p>
    </sec>
    <sec id="sec010">
      <title>4.2 Hubbard model</title>
      <p>Quantum simulation of fermionic systems is one of the most relevant applications of quantum computers, with direct impact on chemistry and materials science, including for the design of new drugs and materials. Among all the algorithms proposed for quantum simulation of fermions, the quantum variational algorithm (VQE) and related approaches [<xref rid="pone.0208510.ref042" ref-type="bibr">42</xref>–<xref rid="pone.0208510.ref045" ref-type="bibr">45</xref>] are arguably the most promising for near-term hardware because they have lower circuit depth requirements [<xref rid="pone.0208510.ref055" ref-type="bibr">55</xref>, <xref rid="pone.0208510.ref056" ref-type="bibr">56</xref>]. We note that many types of chemistry-related circuits can be prepared with the software package OpenFermion [<xref rid="pone.0208510.ref057" ref-type="bibr">57</xref>].</p>
      <p>In the VQE algorithm, a quantum computer is employed to prepare and measure the energy of quantum states associated with a parameterized quantum circuit. The approximate ground state of a Hamiltonian is obtained by variationally minimizing the cost function (corresponding to e.g. the molecular energy) with respect to the circuit parameters using a classical optimization routine. This hybrid quantum-classical approach offers a good compromise between classical and quantum resources. Classical simulations of the VQE algorithm for tens of qubits could provide insights into the complexity of the circuits used for state preparation and help design better ansatzes for the quantum simulation of fermions.</p>
      <p>As an example of a VQE simulation, we used qTorch to classically simulate variational circuits employed for the quantum simulation of 1D Hubbard lattices. We consider half-filled Hubbard models on <italic>N</italic> sites, with periodic boundary conditions.</p>
      <p>To construct variational circuits for these systems, we considered the variational ansatz introduced by Wecker et al [<xref rid="pone.0208510.ref043" ref-type="bibr">43</xref>]. In this case, the Hubbard Hamiltonian is divided as <italic>H</italic> = <italic>h</italic><sub><italic>h</italic></sub> + <italic>h</italic><sub><italic>U</italic></sub>, where <italic>h</italic><sub><italic>h</italic></sub> is the sum of hopping terms in the horizontal dimension and <italic>h</italic><sub><italic>U</italic></sub> is the repulsion term. The variational circuit is constructed as a sequence of unitary rotations by terms in the Hamiltonian with different variational parameters, with the sequence being repeated <italic>S</italic> times. In each step, there are two variational parameters, <inline-formula id="pone.0208510.e028"><alternatives><graphic xlink:href="pone.0208510.e028.jpg" id="pone.0208510.e028g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M28"><mml:msubsup><mml:mi>θ</mml:mi><mml:mi>U</mml:mi><mml:mi>b</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0208510.e029"><alternatives><graphic xlink:href="pone.0208510.e029.jpg" id="pone.0208510.e029g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M29"><mml:msubsup><mml:mi>θ</mml:mi><mml:mi>h</mml:mi><mml:mi>b</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula>, where <italic>b</italic> = 1, ⋯, <italic>N</italic> such that
<disp-formula id="pone.0208510.e030"><alternatives><graphic xlink:href="pone.0208510.e030.jpg" id="pone.0208510.e030g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M30"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>U</mml:mi><mml:mo>=</mml:mo><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>S</mml:mi></mml:munderover><mml:mo>[</mml:mo><mml:msub><mml:mi>U</mml:mi><mml:mi>U</mml:mi></mml:msub><mml:mo>(</mml:mo><mml:mfrac><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>U</mml:mi><mml:mi>b</mml:mi></mml:msubsup><mml:mn>2</mml:mn></mml:mfrac><mml:mo>)</mml:mo><mml:msub><mml:mi>U</mml:mi><mml:mi>h</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:msubsup><mml:mi>θ</mml:mi><mml:mi>h</mml:mi><mml:mi>b</mml:mi></mml:msubsup><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>U</mml:mi><mml:mi>U</mml:mi></mml:msub><mml:mo>(</mml:mo><mml:mfrac><mml:msubsup><mml:mi>θ</mml:mi><mml:mi>U</mml:mi><mml:mi>b</mml:mi></mml:msubsup><mml:mn>2</mml:mn></mml:mfrac><mml:mo>)</mml:mo><mml:mo>]</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(13)</label></disp-formula>
where <italic>U</italic><sub><italic>X</italic></sub>(<italic>θ</italic><sub><italic>X</italic></sub>) denotes a Trotter approximation to exp(<italic>iθ</italic><sub><italic>X</italic></sub>
<italic>h</italic><sub><italic>X</italic></sub>), and <italic>X</italic> can be <italic>U</italic> or <italic>h</italic>. For our numerical simulations, we employed the variational circuit of <xref ref-type="disp-formula" rid="pone.0208510.e030">Eq 13</xref> with <italic>S</italic> = 1 using a 1-step Trotter formula for all the <italic>U</italic><sub><italic>X</italic></sub>(<italic>θ</italic><sub><italic>X</italic></sub>) terms. Notice that this is approximate for the <italic>h</italic><sub><italic>h</italic></sub> term, which comprises a sum of non-commuting terms. We also assigned the value of 1 to all variational amplitudes. The corresponding unitary was mapped to a quantum circuit using the Jordan-Wigner transformation and the circuit was generated using a decomposition into CNOT gates and single-qubit rotations [<xref rid="pone.0208510.ref030" ref-type="bibr">30</xref>, <xref rid="pone.0208510.ref058" ref-type="bibr">58</xref>].</p>
    </sec>
  </sec>
  <sec id="sec011">
    <title>5 Results</title>
    <p>Simulations were performed on the NERSC Cori supercomputer, using one “Knights Landing” (KNL) node per simulation, each of which contains 68 cores and 96 GB of memory. Each LIQ<italic>Ui</italic>|&gt; simulation was run on a full node as well, using Docker [<xref rid="pone.0208510.ref059" ref-type="bibr">59</xref>] (computational details in the Appendix). The free version of LIQ<italic>Ui</italic>|&gt; allows for the simulation of 24 qubits. Because full Hilbert space simulation scales exponentially regardless of the quantum algorithm’s complexity, we would not have been able to simulate more than ∼31 qubits on one of these compute nodes. For each set of parameters (regularity and number of vertices/qubits) 50 instances of Max-Cut/QAOA circuit were created. For higher qubit counts and higher regularities, only a subset of these circuits were completed, since many simulations exceeded memory capacity. In this section, <italic>LG</italic> or <italic>qTorch-LG</italic> refer to the use of qTorch with the linegraph-based contraction, <italic>Stoch</italic> or <italic>qTorch-Stoch</italic> refer to qTorch with stochastic contraction. To determine a qTorch-LG contraction ordering, QuickBB simulations were run for an arbitrary time of 3000 seconds for each quantum circuit. The plotted qTorch results do not include the QuickBB run time.</p>
    <p>We note that LIQ<italic>Ui</italic>|&gt; implements a thorough set of important optimizations, which makes it a fair benchmark against which to compare qTorch. For example, LIQ<italic>Ui</italic>|&gt; fuses many gates together before acting on the state vector, and uses sparse operations. qTorch, on the other hand, does not yet use sparsity at all (even when the circuit consists primarily of sparse CNOT gates), which is one of several optimizations that we expect would further improve performance.</p>
    <p>LIQ<italic>Ui</italic>|&gt; is the fastest simulation method to use for the Hubbard simulations, as shown in <xref ref-type="fig" rid="pone.0208510.g004">Fig 4</xref>. This is because the treewidth of the circuit’s graph increases substantially with the number of qubits, even for these short-depth circuits. The result is not surprising—if the algorithm were easy to simulate with a tensor network on a classical computer, then it would not have been worth proposing as a candidate for a quantum computer.</p>
    <fig id="pone.0208510.g004" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.1371/journal.pone.0208510.g004</object-id>
      <label>Fig 4</label>
      <caption>
        <title>Time results for simulating quantum circuits of the Hubbard model.</title>
        <p>LG, Stoch, and LIQ<italic>Ui</italic>|&gt; denote linegraph-based tensor contraction, stochastic tensor contraction, and LIQ<italic>Ui</italic>|&gt;, respectively. LIQ<italic>Ui</italic>|&gt;’s full Hilbert simulation method is substantially faster than either tensor contraction method. Missing data points resulted from exceeding memory capacity.</p>
      </caption>
      <graphic xlink:href="pone.0208510.g004"/>
    </fig>
    <p>Simulation timing results for 3-, 4-, and 5-regular Max-Cut/QAOA circuits are shown using Tukey boxplots in Figs <xref ref-type="fig" rid="pone.0208510.g005">5</xref> and <xref ref-type="fig" rid="pone.0208510.g006">6</xref>. Stoch and LG simulation times are of similar order of magnitude for these circuits, though LG is generally faster. The exception is the 3-regular graph problems, where Stoch often appears to find a more efficient contraction than the 3000-second run of QuickBB does. We note that if the QuickBB algorithm were run for infinite time before beginning the contraction, then qTorch-LG should always (except in very simple graphs) contract the circuit faster than qTorch-Stoch. This is because, while the Stoch search is purely local (considering only individual wires), the tree decomposition approach of QuickBB implicitly considers the effects of multiple contraction steps. Note that actual search time of Stoch is negligible compared to the tensor contraction time. Note that LIQ<italic>Ui</italic>|&gt; begins to outperform tensor contraction methods once the algorithm is run on 5-regular graphs, because the increased circuit complexity leads to larger intermediate tensors in qTorch.</p>
    <fig id="pone.0208510.g005" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.1371/journal.pone.0208510.g005</object-id>
      <label>Fig 5</label>
      <caption>
        <title>Simulation time plotted against number of qubits for Max-Cut/QAOA circuits.</title>
        <p>LG, Stoch, and LIQ<italic>Ui</italic>|&gt; denote linegraph-based tensor contraction, stochastic tensor contraction, and the LIQ<italic>Ui</italic>|&gt; software package, respectively. Tree decompositions for the LG method were determined by running the QuickBB simulation for 3000 seconds. For lower regularities, the tensor contraction methods outperform LIQ<italic>Ui</italic>|&gt;, since LIQ<italic>Ui</italic>|&gt; simulates the full Hilbert space. However, as the regularity of the Max-Cut graphs (and hence the treewidth of the quantum circuits’ line graphs) increase, full Hilbert space simulation using LIQ<italic>Ui</italic>|&gt; becomes more efficient.</p>
      </caption>
      <graphic xlink:href="pone.0208510.g005"/>
    </fig>
    <fig id="pone.0208510.g006" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.1371/journal.pone.0208510.g006</object-id>
      <label>Fig 6</label>
      <caption>
        <title>Simulation time plotted against number of qubits for 3-regular Max-Cut/QAOA circuits.</title>
        <p>LG and Stoch denote linegraph-based tensor contraction and stochastic tensor contraction respectively. For 3-regular Max-Cut/QAOA circuits, we were able to simulate a small subset of the 100-qubit circuits we created, not shown here.</p>
      </caption>
      <graphic xlink:href="pone.0208510.g006"/>
    </fig>
    <p>Note that in principle, Hilbert space simulation can be considered a subset of TN contraction, where the state vector is simply a large tensor. Hence one might expect that there would not be a crossover point at all, <italic>i.e</italic>. that in the worst case TN contraction would not ever be slower than Hilbert space simulation. However, because our implementation considers density matrices instead of state vectors, one would in fact expect this crossover point to exist. The largest tensor in qTorch would have 4<sup><italic>N</italic></sup> entries, while the state vector has just 2<sup><italic>N</italic></sup> entries. The various choices made in software implementations for qTorch and LIQ<italic>Ui</italic>|&gt; would also affect the position of this crossover point.</p>
    <p>Using a single Cori NERSC node, we were able to contract quantum circuits of 90 qubits for a very small subset of the simulated graphs, though not on enough graphs to report statistics. Full Hilbert space methods would be limited to ∼30 qubits on these nodes, and indeed previous simulation packages have not yet surpassed 46 qubits [<xref rid="pone.0208510.ref002" ref-type="bibr">2</xref>, <xref rid="pone.0208510.ref019" ref-type="bibr">19</xref>], using thousands of nodes.</p>
    <p>Interesting trends appear when the simulation time is plotted against regularity of the Max-Cut problem’s graph (<xref ref-type="fig" rid="pone.0208510.g007">Fig 7</xref>). It is notable that the LG method runs out of memory before the Stoch method does. As previously mentioned, the LG method contracts more efficiently the longer QuickBB has been run, and we chose 3000 seconds as an arbitrary QuickBB limit for all circuits. There is a trade-off between running a longer QuickBB simulation and instead immediately using the Stoch method. Even with few qubits, at higher regularities the full Hilbert space simulation (using LIQ<italic>Ui</italic>|&gt;) performs better. This is expected, since as the complexity of the quantum circuit increases, higher-rank intermediate tensors appear.</p>
    <fig id="pone.0208510.g007" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.1371/journal.pone.0208510.g007</object-id>
      <label>Fig 7</label>
      <caption>
        <title>Simulation time plotted against the regularity of the underlying Max-Cut graph, for Max-Cut/QAOA circuits.</title>
        <p>LG, Stoch, and LIQ<italic>Ui</italic>|&gt; denote linegraph-based tensor contraction, stochastic tensor contraction, and LIQ<italic>Ui</italic>|&gt;, respectively. As regularity increases, full Hilbert space simulation (using LIQ<italic>Ui</italic>| &gt;) becomes a more competitive simulation method. Missing data points resulted from running out of memory.</p>
      </caption>
      <graphic xlink:href="pone.0208510.g007"/>
    </fig>
    <p><xref ref-type="fig" rid="pone.0208510.g008">Fig 8</xref> shows simulation time as the estimated upper bound for the treewidth increases, for Max-Cut/QAOA circuits of 18 qubits. These include 3- through 7-regular graphs. This treewidth upper bound is simply the treewidth of the tree decomposition that defines the contraction ordering. The plot shows the expected general trend of an increase simulation time with increased treewidth, regardless of contraction scheme.</p>
    <fig id="pone.0208510.g008" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.1371/journal.pone.0208510.g008</object-id>
      <label>Fig 8</label>
      <caption>
        <title>Simulation time plotted against approximate treewidth, for all simulated Max-Cut/QAOA quantum circuits of 18 qubits.</title>
        <p>The plot demonstrates the general trend of increased simulation time with the quantum circuit’s line graphs’s treewidth, despite a constant number of qubits.</p>
      </caption>
      <graphic xlink:href="pone.0208510.g008"/>
    </fig>
    <p>Finally, we note that we were easily able to perform simulations of 100 qubits for less complex graphs. To report one such example, we produced a random 3-regular graph with a slightly different procedure from that given in of Section 4.1. Beginning with a 2-regular graph (i.e. a ring) of 100 vertices, we added edges between random pairs of vertices until all vertices were of 3 degrees. Contracting this graph’s Max-Cut/QAOA circuit took ∼150 seconds.</p>
  </sec>
  <sec id="sec012">
    <title>6 Conclusions</title>
    <p>We have implemented a tensor contraction code for the efficient simulation of quantum circuits. We compared a stochastic contraction scheme to one based on the line graph of the quantum circuit’s graph, showing that the latter is more efficient in most circuits simulated herein. However, there is a subset of cases for which calculating an efficient approximate optimal tree decomposition of the line graph takes longer than contracting the circuit stochastically, in which case the stochastic scheme is superior. For the circuits studied in this work, our simulations suggest that the point at which qTorch is no longer faster than LIQ<italic>Ui</italic>| &gt; occurs in QAOA/Max-Cut approximately when the Max-Cut graph has a regularity of five. In the future, qTorch may be used to estimate these points of equivalent computational cost in other classes of circuits, which may help to determine which simulation method to use in simulations.</p>
    <p>Several immediate algorithmic improvements are possible for this software. The use of sparse tensors would reduce the number of floating point operations for some relevant circuits. Tensor decompositions (such as the singular value decomposition) along with trimming can be added as intermediate steps, as has been done in tensor network based simulations of physical systems [<xref rid="pone.0208510.ref032" ref-type="bibr">32</xref>, <xref rid="pone.0208510.ref034" ref-type="bibr">34</xref>]. Additionally, more advanced parallelization methods would allow for faster calculation of a tree decomposition as well as faster contractions.</p>
  </sec>
  <sec sec-type="supplementary-material" id="sec013">
    <title>Supporting information</title>
    <supplementary-material content-type="local-data" id="pone.0208510.s001">
      <label>S1 Appendix</label>
      <caption>
        <title>The appendix contains a more complete introduction to QAOA and Max-Cut, and gives implementation details of the LIQ<italic>Ui</italic>| &gt;simulations.</title>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pone.0208510.s001.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <p>We are grateful to Edward Farhi and Aram Harrow for discussions about QAOA, to Salvatore Mandrà for general discussions, and to Dave Wecker for helpful advice on using LIQ<italic>Ui</italic>| &gt;. N.S. acknowledges the use of resources of the National Energy Research Scientific Computing Center, a DOE Office of Science User Facility supported by the Office of Science of the U.S. Department of Energy under Contract No. DE-AC02-05CH11231. A.A.-G. and E.F. were supported by the Office of Naval Research under grant N00014-16-1-2008 (Vannevar Bush Faculty Fellowship). A. A.-G. and Y.C. were supported by NSF grant CHE-1655187.</p>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="pone.0208510.ref001">
      <label>1</label>
      <mixed-citation publication-type="other">Wecker D, Svore KM. LIQUi|&gt;: A Software Design Architecture and Domain-Specific Language for Quantum Computing; 2014. arXiv:1402.4467.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref002">
      <label>2</label>
      <mixed-citation publication-type="other">Smelyanskiy M, Sawaya NPD, Aspuru-Guzik A. qHiPSTER: The Quantum High Performance Software Testing Environment; 2016. arXiv:1601.07195.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref003">
      <label>3</label>
      <mixed-citation publication-type="journal"><name><surname>Tabakin</surname><given-names>F</given-names></name>, <name><surname>Julia-Diaz</surname><given-names>B</given-names></name>. <article-title>Qcmpi: A Parallel Environment for Quantum Computing</article-title>. <source>Computer Physics Communications</source>. <year>2009</year>;<volume>180</volume>:<fpage>948</fpage><ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.cpc.2008.11.021">10.1016/j.cpc.2008.11.021</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref004">
      <label>4</label>
      <mixed-citation publication-type="journal"><name><surname>Tabakin</surname><given-names>F</given-names></name>, <name><surname>Juliá-Díaz</surname><given-names>B</given-names></name>. <article-title>{QCWAVE}—A Mathematica quantum computer simulation update</article-title>. <source>Computer Physics Communications</source>. <year>2011</year>;<volume>182</volume>(<issue>8</issue>):<fpage>1693</fpage>–<lpage>1707</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.cpc.2011.04.010">10.1016/j.cpc.2011.04.010</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref005">
      <label>5</label>
      <mixed-citation publication-type="journal"><name><surname>Miszczak</surname><given-names>JA</given-names></name>. <article-title>Models of quantum computation and quantum programming languages</article-title>. <source>Bull Pol Acad Sci-Tech Sci</source>. <year>2010</year>;<volume>59</volume>(<issue>3</issue>):<fpage>305</fpage>.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref006">
      <label>6</label>
      <mixed-citation publication-type="journal"><name><surname>Sawaya</surname><given-names>NPD</given-names></name>, <name><surname>Smelyanskiy</surname><given-names>M</given-names></name>, <name><surname>McClean</surname><given-names>JR</given-names></name>, <name><surname>Aspuru-Guzik</surname><given-names>A</given-names></name>. <article-title>Error Sensitivity to Environmental Noise in Quantum Circuits for Chemical State Preparation</article-title>. <source>Journal of Chemical Theory and Computation</source>. <year>2016</year>;<volume>12</volume>(<issue>7</issue>):<fpage>3097</fpage>–<lpage>3108</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1021/acs.jctc.6b00220">10.1021/acs.jctc.6b00220</ext-link><?supplied-pmid 27254482?><pub-id pub-id-type="pmid">27254482</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref007">
      <label>7</label>
      <mixed-citation publication-type="journal"><name><surname>Silva</surname><given-names>M</given-names></name>, <name><surname>Magesan</surname><given-names>E</given-names></name>, <name><surname>Kribs</surname><given-names>DW</given-names></name>, <name><surname>Emerson</surname><given-names>J</given-names></name>. <article-title>Scalable protocol for identification of correctable codes</article-title>. <source>Phys Rev A</source>. <year>2008</year>;<volume>78</volume>:<fpage>012347</fpage><ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1103/PhysRevA.78.012347">10.1103/PhysRevA.78.012347</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref008">
      <label>8</label>
      <mixed-citation publication-type="journal"><name><surname>Geller</surname><given-names>MR</given-names></name>, <name><surname>Zhou</surname><given-names>Z</given-names></name>. <article-title>Efficient error models for fault-tolerant architectures and the Pauli twirling approximation</article-title>. <source>Phys Rev A</source>. <year>2013</year>;<volume>88</volume>:<fpage>012314</fpage><ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1103/PhysRevA.88.012314">10.1103/PhysRevA.88.012314</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref009">
      <label>9</label>
      <mixed-citation publication-type="journal"><name><surname>Tomita</surname><given-names>Y</given-names></name>, <name><surname>Svore</surname><given-names>KM</given-names></name>. <article-title>Low-distance surface codes under realistic quantum noise</article-title>. <source>Phys Rev A</source>. <year>2014</year>;<volume>90</volume>:<fpage>062320</fpage><ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1103/PhysRevA.90.062320">10.1103/PhysRevA.90.062320</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref010">
      <label>10</label>
      <mixed-citation publication-type="journal"><name><surname>Boixo</surname><given-names>S</given-names></name>, <name><surname>Isakov</surname><given-names>SV</given-names></name>, <name><surname>Smelyanskiy</surname><given-names>VN</given-names></name>, <name><surname>Babbush</surname><given-names>R</given-names></name>, <name><surname>Ding</surname><given-names>N</given-names></name>, <name><surname>Jiang</surname><given-names>Z</given-names></name>, <etal>et al</etal><article-title>Characterizing quantum supremacy in near-term devices</article-title>. <source>Nature Physics</source>. <year>2018</year>;<volume>14</volume>(<issue>6</issue>):<fpage>595</fpage>–<lpage>600</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1038/s41567-018-0124-x">10.1038/s41567-018-0124-x</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref011">
      <label>11</label>
      <mixed-citation publication-type="other">Farhi E, Harrow AW. Quantum Supremacy through the Quantum Approximate Optimization Algorithm; 2016. arXiv:1602.07674.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref012">
      <label>12</label>
      <mixed-citation publication-type="other">Boixo S, Isakov SV, Smelyanskiy VN, Neven H. Simulation of low-depth quantum circuits as complex undirected graphical models; 2017. arXiv:1712.05384.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref013">
      <label>13</label>
      <mixed-citation publication-type="other">Chen J, Zhang F, Huang C, Newman M, Shi Y. Classical Simulation of Intermediate-Size Quantum Circuits; 2018. arXiv:1805.01450.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref014">
      <label>14</label>
      <mixed-citation publication-type="other">Childs AM, Maslov D, Nam Y, Ross NJ, Su Y. Toward the first quantum simulation with quantum speedup; 2017. arXiv:1711.10980.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref015">
      <label>15</label>
      <mixed-citation publication-type="other">Bouland A, Fefferman B, Nirkhe C, Vazirani U. Quantum Supremacy and the Complexity of Random Circuit Sampling; 2018. arXiv:1803.04402.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref016">
      <label>16</label>
      <mixed-citation publication-type="other">Pednault E, Gunnels JA, Nannicini G, Horesh L, Magerlein T, Solomonik E, et al. Breaking the 49-Qubit Barrier in the Simulation of Quantum Circuits; 2017. arXiv:1710.05867.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref017">
      <label>17</label>
      <mixed-citation publication-type="other">Chen ZY, Zhou Q, Xue C, Yang X, Guo GC, Guo GP. 64-Qubit Quantum Circuit Simulation; 2018. arXiv:1802.06952.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref018">
      <label>18</label>
      <mixed-citation publication-type="other">Steiger DS, Häner T, Troyer M. ProjectQ: An Open Source Software Framework for Quantum Computing; 2016. arXiv:1612.08091.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref019">
      <label>19</label>
      <mixed-citation publication-type="other">Häner T, Steiger DS. 0.5 Petabyte Simulation of a 45-Qubit Quantum Circuit; 2017. arXiv:1704.01127.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref020">
      <label>20</label>
      <mixed-citation publication-type="other">Gottesman D. The Heisenberg Representation of Quantum Computers; 1998. arXiv:quant-ph/9807006.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref021">
      <label>21</label>
      <mixed-citation publication-type="journal"><name><surname>Aaronson</surname><given-names>S</given-names></name>, <name><surname>Gottesman</surname><given-names>D</given-names></name>. <article-title>Improved Simulation of Stabilizer Circuits</article-title>. <source>Physical Review A</source>. <year>2004</year>;<volume>70</volume>:<fpage>052328</fpage><ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1103/PhysRevA.70.052328">10.1103/PhysRevA.70.052328</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref022">
      <label>22</label>
      <mixed-citation publication-type="other">Valiant LG. Quantum Computers That Can Be Simulated Classically in Polynomial Time. In: Proceedings of the Thirty-third Annual ACM Symposium on Theory of Computing. STOC’01. New York, NY, USA; 2001. p. 114–123. Available from: <ext-link ext-link-type="uri" xlink:href="http://doi.acm.org/10.1145/380752.380785">http://doi.acm.org/10.1145/380752.380785</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref023">
      <label>23</label>
      <mixed-citation publication-type="journal"><name><surname>Terhal</surname><given-names>BM</given-names></name>, <name><surname>DiVincenzo</surname><given-names>DP</given-names></name>. <article-title>Classical simulation of noninteracting-fermion quantum circuits</article-title>. <source>Physical Review A</source>. <year>2002</year>;<volume>65</volume>:<fpage>032325</fpage><ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1103/PhysRevA.65.032325">10.1103/PhysRevA.65.032325</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref024">
      <label>24</label>
      <mixed-citation publication-type="journal"><name><surname>Bravyi</surname><given-names>S</given-names></name>, <name><surname>Gosset</surname><given-names>D</given-names></name>. <article-title>Improved Classical Simulation of Quantum Circuits Dominated by Clifford Gates</article-title>. <source>Physical Review Letters</source>. <year>2016</year>;<volume>116</volume>(<issue>25</issue>):<fpage>250501</fpage><ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1103/PhysRevLett.116.250501">10.1103/PhysRevLett.116.250501</ext-link><?supplied-pmid 27391708?><pub-id pub-id-type="pmid">27391708</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref025">
      <label>25</label>
      <mixed-citation publication-type="other">García HJ, Markov IL. Quipu: High-performance simulation of quantum circuits using stabilizer frames. In: 2013 IEEE 31st International Conference on Computer Design (ICCD); 2013. p. 404–410.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref026">
      <label>26</label>
      <mixed-citation publication-type="journal"><article-title>García HJ, Markov IL. Simulation of Quantum Circuits via Stabilizer Frames</article-title>. <source>IEEE Transactions on Computers</source>. <year>2017</year>;<volume>64</volume>(<issue>8</issue>).</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref027">
      <label>27</label>
      <mixed-citation publication-type="other">Rudiak-Gould B. The sum-over-histories formulation of quantum computing; 2006. arXiv:quant-ph/0607151.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref028">
      <label>28</label>
      <mixed-citation publication-type="journal"><name><surname>Viamontes</surname><given-names>GF</given-names></name>, <name><surname>Markov</surname><given-names>IL</given-names></name>, <name><surname>Hayes</surname><given-names>JP</given-names></name>. <article-title>Graph-based simulation of quantum computation in the density matrix representation</article-title>. <source>Quantum Information &amp; Computation</source>. <year>2005</year>;<volume>5</volume>(<issue>2</issue>):<fpage>113</fpage>.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref029">
      <label>29</label>
      <mixed-citation publication-type="journal"><name><surname>Markov</surname><given-names>IL</given-names></name>, <name><surname>Shi</surname><given-names>Y</given-names></name>. <article-title>Simulating quantum computation by contracting tensor networks</article-title>. <source>SIAM Journal on Computing</source>. <year>2005</year>;<volume>38</volume>(<issue>3</issue>):<fpage>963</fpage><ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1137/050644756">10.1137/050644756</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref030">
      <label>30</label>
      <mixed-citation publication-type="book"><name><surname>Nielsen</surname><given-names>MA</given-names></name>, <name><surname>Chuang</surname><given-names>IL</given-names></name>. <source>Quantum Computation and Quantum Information: 10th Anniversary Edition</source>. <edition>10th ed</edition><publisher-loc>New York, NY, USA</publisher-loc>: <publisher-name>Cambridge University Press</publisher-name>; <year>2011</year>.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref031">
      <label>31</label>
      <mixed-citation publication-type="other">McCaskey AJ. Tensor Network Quantum Virtual Machine (TNQVM); 2016. Available from: <ext-link ext-link-type="uri" xlink:href="http://www.osti.gov/scitech/servlets/purl/1340180">http://www.osti.gov/scitech/servlets/purl/1340180</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref032">
      <label>32</label>
      <mixed-citation publication-type="journal"><name><surname>Orús</surname><given-names>R</given-names></name>. <article-title>A practical introduction to tensor networks: Matrix product states and projected entangled pair states</article-title>. <source>Annals of Physics</source>. <year>2014</year>;<volume>349</volume>:<fpage>117</fpage>–<lpage>158</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.aop.2014.06.013">10.1016/j.aop.2014.06.013</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref033">
      <label>33</label>
      <mixed-citation publication-type="journal"><name><surname>Orús</surname><given-names>R</given-names></name>. <article-title>Advances on tensor network theory: Symmetries, fermions, entanglement, and holography</article-title>. <source>European Physical Journal B</source>. <year>2014</year>;<volume>87</volume>(<issue>11</issue>).</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref034">
      <label>34</label>
      <mixed-citation publication-type="other">Ran SJ, Tirrito E, Peng C, Chen X, Su G, Lewenstein M. Review of Tensor Network Contraction Approaches; 2017. arXiv:1708.09213.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref035">
      <label>35</label>
      <mixed-citation publication-type="journal"><name><surname>Robertson</surname><given-names>N</given-names></name>, <name><surname>Seymour</surname><given-names>PD</given-names></name>. <article-title>Graph minors. X. Obstructions to tree-decomposition</article-title>. <source>Journal of Combinatorial Theory, Series B</source>. <year>1991</year>;<volume>52</volume>(<issue>2</issue>):<fpage>153</fpage>–<lpage>190</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/0095-8956(91)90061-N">10.1016/0095-8956(91)90061-N</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref036">
      <label>36</label>
      <mixed-citation publication-type="journal"><name><surname>Bodlaender</surname><given-names>HL</given-names></name>, <name><surname>Koster</surname><given-names>AMCA</given-names></name>. <article-title>Treewidth computations I. Upper bounds</article-title>. <source>Information and Computation</source>. <year>2010</year>;<volume>208</volume>(<issue>3</issue>):<fpage>259</fpage>–<lpage>275</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.ic.2009.03.008">10.1016/j.ic.2009.03.008</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref037">
      <label>37</label>
      <mixed-citation publication-type="journal"><name><surname>Bodlaender</surname><given-names>HL</given-names></name>, <name><surname>Koster</surname><given-names>AMCA</given-names></name>. <article-title>Treewidth computations II. Lower bounds</article-title>. <source>Information and Computation</source>. <year>2011</year>;<volume>209</volume>(<issue>7</issue>):<fpage>1103</fpage>–<lpage>1119</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.ic.2011.04.003">10.1016/j.ic.2011.04.003</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref038">
      <label>38</label>
      <mixed-citation publication-type="other">Gogate V, Dechter R. A Complete Anytime Algorithm for Treewidth. In: Proceedings of the 20th Conference on Uncertainty in Artificial Intelligence. UAI’04. Arlington, Virginia, United States: AUAI Press; 2004. p. 201–208. Available from: <ext-link ext-link-type="uri" xlink:href="http://dl.acm.org/citation.cfm?id=1036843.1036868">http://dl.acm.org/citation.cfm?id=1036843.1036868</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref039">
      <label>39</label>
      <mixed-citation publication-type="journal"><name><surname>Arnborg</surname><given-names>S</given-names></name>, <name><surname>Corneil</surname><given-names>DG</given-names></name>, <name><surname>Proskurowski</surname><given-names>A</given-names></name>. <article-title>Complexity of Finding Embeddings in a K-tree</article-title>. <source>SIAM J Algebraic Discrete Methods</source>. <year>1987</year>;<volume>8</volume>(<issue>2</issue>):<fpage>277</fpage>–<lpage>284</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1137/0608024">10.1137/0608024</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref040">
      <label>40</label>
      <mixed-citation publication-type="journal"><name><surname>Amir</surname><given-names>E</given-names></name>. <article-title>Approximation Algorithms for Treewidth</article-title>. <source>Algorithmica</source>. <year>2010</year>;<volume>56</volume>(<issue>4</issue>):<fpage>448</fpage>–<lpage>479</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1007/s00453-008-9180-4">10.1007/s00453-008-9180-4</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref041">
      <label>41</label>
      <mixed-citation publication-type="journal"><name><surname>Pfeifer</surname><given-names>RNC</given-names></name>, <name><surname>Haegeman</surname><given-names>J</given-names></name>, <name><surname>Verstraete</surname><given-names>F</given-names></name>. <article-title>Faster identification of optimal contraction sequences for tensor networks</article-title>. <source>Physical Review E</source>. <year>2014</year>;<volume>90</volume>(<issue>3</issue>). <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1103/PhysRevE.90.033315">10.1103/PhysRevE.90.033315</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref042">
      <label>42</label>
      <mixed-citation publication-type="journal"><name><surname>Peruzzo</surname><given-names>A</given-names></name>, <name><surname>McClean</surname><given-names>J</given-names></name>, <name><surname>Shadbolt</surname><given-names>P</given-names></name>, <name><surname>Yung</surname><given-names>MH</given-names></name>, <name><surname>Zhou</surname><given-names>XQ</given-names></name>, <name><surname>Love</surname><given-names>PJ</given-names></name>, <etal>et al</etal><article-title>A variational eigenvalue solver on a photonic quantum processor</article-title>. <source>Nat Commun</source>. <year>2014</year>;<volume>5</volume>:<fpage>4213</fpage><ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1038/ncomms5213">10.1038/ncomms5213</ext-link><?supplied-pmid 25055053?><pub-id pub-id-type="pmid">25055053</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref043">
      <label>43</label>
      <mixed-citation publication-type="journal"><name><surname>Wecker</surname><given-names>D</given-names></name>, <name><surname>Hastings</surname><given-names>MB</given-names></name>, <name><surname>Troyer</surname><given-names>M</given-names></name>. <article-title>Progress towards practical quantum variational algorithms</article-title>. <source>Phys Rev A</source>. <year>2015</year>;<volume>92</volume>:<fpage>042303</fpage><ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1103/PhysRevA.92.042303">10.1103/PhysRevA.92.042303</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref044">
      <label>44</label>
      <mixed-citation publication-type="journal"><name><surname>Yung</surname><given-names>MH</given-names></name>, <name><surname>Casanova</surname><given-names>J</given-names></name>, <name><surname>Mezzacapo</surname><given-names>A</given-names></name>, <name><surname>McClean</surname><given-names>J</given-names></name>, <name><surname>Lamata</surname><given-names>L</given-names></name>, <name><surname>Aspuru-Guzik</surname><given-names>A</given-names></name>, <etal>et al</etal><article-title>From transistor to trapped-ion computers for quantum chemistry</article-title>. <source>Sci Rep</source>. <year>2014</year>;<volume>4</volume>:<fpage>3589</fpage><ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1038/srep03589">10.1038/srep03589</ext-link><?supplied-pmid 24395054?><pub-id pub-id-type="pmid">24395054</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref045">
      <label>45</label>
      <mixed-citation publication-type="journal"><name><surname>McClean</surname><given-names>JR</given-names></name>, <name><surname>Romero</surname><given-names>J</given-names></name>, <name><surname>Babbush</surname><given-names>R</given-names></name>, <name><surname>Aspuru-Guzik</surname><given-names>A</given-names></name>. <article-title>The theory of variational hybrid quantum-classical algorithms</article-title>. <source>New J Phys</source>. <year>2016</year>;<volume>18</volume>(<issue>2</issue>):<fpage>023023</fpage><ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1088/1367-2630/18/2/023023">10.1088/1367-2630/18/2/023023</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref046">
      <label>46</label>
      <mixed-citation publication-type="book"><name><surname>Kraus</surname><given-names>K</given-names></name>, <name><surname>Böhm</surname><given-names>A</given-names></name>, <name><surname>Dollard</surname><given-names>JD</given-names></name>, <name><surname>Wootters</surname><given-names>WH</given-names></name>, editors. <source>States, Effects, and Operations Fundamental Notions of Quantum Theory</source>. <publisher-name>Springer</publisher-name><publisher-loc>Berlin Heidelberg</publisher-loc>; <year>1983</year> Available from: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1007%2F3-540-12732-1">https://doi.org/10.1007%2F3-540-12732-1</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref047">
      <label>47</label>
      <mixed-citation publication-type="journal"><name><surname>Aharonov</surname><given-names>D</given-names></name>, <name><surname>Kitaev</surname><given-names>A</given-names></name>, <name><surname>Preskill</surname><given-names>J</given-names></name>. <article-title>Fault-Tolerant Quantum Computation with Long-Range Correlated Noise</article-title>. <source>Phys Rev Lett</source>. <year>2006</year>;<volume>96</volume>:<fpage>050504</fpage><ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1103/PhysRevLett.96.050504">10.1103/PhysRevLett.96.050504</ext-link><?supplied-pmid 16486913?><pub-id pub-id-type="pmid">16486913</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref048">
      <label>48</label>
      <mixed-citation publication-type="journal"><name><surname>Preskill</surname><given-names>J</given-names></name>. <article-title>Sufficient Condition on Noise Correlations for Scalable Quantum Computing</article-title>. <source>Quantum Info Comput</source>. <year>2013</year>;<volume>13</volume>(<issue>3-4</issue>):<fpage>181</fpage>–<lpage>194</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref049">
      <label>49</label>
      <mixed-citation publication-type="other">Farhi E, Goldstone J, Gutmann S. A Quantum Approximate Optimization Algorithm; 2014. arXiv:1411.4028.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref050">
      <label>50</label>
      <mixed-citation publication-type="other">Farhi E, Goldstone J, Gutmann S. A Quantum Approximate Optimization Algorithm Applied to a Bounded Occurrence Constraint Problem; 2014. arXiv:1412.6062.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref051">
      <label>51</label>
      <mixed-citation publication-type="journal"><name><surname>Wecker</surname><given-names>D</given-names></name>, <name><surname>Hastings</surname><given-names>MB</given-names></name>, <name><surname>Troyer</surname><given-names>M</given-names></name>. <article-title>Training a quantum optimizer</article-title>. <source>Phys Rev A</source>. <year>2016</year>;<volume>94</volume>(<issue>2</issue>):<fpage>022309</fpage><ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1103/PhysRevA.94.022309">10.1103/PhysRevA.94.022309</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref052">
      <label>52</label>
      <mixed-citation publication-type="other">Yen-Yu Lin C, Zhu Y. Performance of QAOA on Typical Instances of Constraint Satisfaction Problems with Bounded Degree; 2016. arXiv:1601.01744.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref053">
      <label>53</label>
      <mixed-citation publication-type="other">Giacomo Guerreschi G, Smelyanskiy M. Practical optimization for hybrid quantum-classical algorithms; 2017. arXiv:1701.01450.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref054">
      <label>54</label>
      <mixed-citation publication-type="other">Johnson SG. The NLopt nonlinear-optimization package;. <ext-link ext-link-type="uri" xlink:href="http://ab-initio.mit.edu/nlopt">http://ab-initio.mit.edu/nlopt</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref055">
      <label>55</label>
      <mixed-citation publication-type="journal"><name><surname>McClean</surname><given-names>JR</given-names></name>, <name><surname>Kimchi-Schwartz</surname><given-names>ME</given-names></name>, <name><surname>Carter</surname><given-names>J</given-names></name>, <name><surname>de Jong</surname><given-names>WA</given-names></name>. <article-title>Hybrid quantum-classical hierarchy for mitigation of decoherence and determination of excited states</article-title>. <source>Phys Rev A</source>. <year>2017</year>;<volume>95</volume>:<fpage>042308</fpage><ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1103/PhysRevA.95.042308">10.1103/PhysRevA.95.042308</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref056">
      <label>56</label>
      <mixed-citation publication-type="journal"><name><surname>O’Malley</surname><given-names>PJJ</given-names></name>, <name><surname>Babbush</surname><given-names>R</given-names></name>, <name><surname>Kivlichan</surname><given-names>ID</given-names></name>, <name><surname>Romero</surname><given-names>J</given-names></name>, <name><surname>McClean</surname><given-names>JR</given-names></name>, <name><surname>Barends</surname><given-names>R</given-names></name>, <etal>et al</etal><article-title>Scalable Quantum Simulation of Molecular Energies</article-title>. <source>Phys Rev X</source>. <year>2016</year>;<volume>6</volume>:<fpage>031007</fpage>.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref057">
      <label>57</label>
      <mixed-citation publication-type="other">McClean JR, Kivlichan ID, Sung KJ, Steiger DS, Cao Y, Dai C, et al. OpenFermion: The Electronic Structure Package for Quantum Computers; 2017. arXiv:1710.07629.</mixed-citation>
    </ref>
    <ref id="pone.0208510.ref058">
      <label>58</label>
      <mixed-citation publication-type="journal"><name><surname>Whitfield</surname><given-names>JD</given-names></name>, <name><surname>Biamonte</surname><given-names>J</given-names></name>, <name><surname>Aspuru-Guzik</surname><given-names>A</given-names></name>. <article-title>Simulation of electronic structure Hamiltonians using quantum computers</article-title>. <source>Mol Phys</source>. <year>2011</year>;<volume>109</volume>(<issue>5</issue>):<fpage>735</fpage>–<lpage>750</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1080/00268976.2011.552441">10.1080/00268976.2011.552441</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0208510.ref059">
      <label>59</label>
      <mixed-citation publication-type="journal"><name><surname>Merkel</surname><given-names>D</given-names></name>. <article-title>Docker: Lightweight Linux Containers for Consistent Development and Deployment</article-title>. <source>Linux J</source>. <year>2014</year>;<volume>2014</volume>(<issue>239</issue>).</mixed-citation>
    </ref>
  </ref-list>
</back>
