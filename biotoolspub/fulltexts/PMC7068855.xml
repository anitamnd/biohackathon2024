<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7068855</article-id>
    <article-id pub-id-type="publisher-id">3348</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-020-3348-6</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>BLAMM: BLAS-based algorithm for finding position weight matrix occurrences in DNA sequences on CPUs and GPUs</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Fostier</surname>
          <given-names>Jan</given-names>
        </name>
        <address>
          <email>jan.fostier@ugent.be</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <aff id="Aff1"><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 2069 7798</institution-id><institution-id institution-id-type="GRID">grid.5342.0</institution-id><institution>Department of Information Technology - IDLab, Ghent University - imec, </institution></institution-wrap>Technologiepark 126, Ghent (Zwijnaarde), B-9052 Belgium </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>11</day>
      <month>3</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>11</day>
      <month>3</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2020</year>
    </pub-date>
    <volume>21</volume>
    <issue>Suppl 2</issue>
    <issue-sponsor>Publication of this supplement has not been supported by sponsorship. Information about the source of funding for publication charges can be found in the individual articles. The articles have undergone the journal's standard peer review process for supplements. The Supplement Editors declare that they have no competing interests.</issue-sponsor>
    <elocation-id>81</elocation-id>
    <permissions>
      <copyright-statement>© The Author(s) 2020</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p id="Par1">The identification of all matches of a large set of position weight matrices (PWMs) in long DNA sequences requires significant computational resources for which a number of efficient yet complex algorithms have been proposed.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p id="Par2">We propose BLAMM, a simple and efficient tool inspired by high performance computing techniques. The workload is expressed in terms of matrix-matrix products that are evaluated with high efficiency using optimized BLAS library implementations. The algorithm is easy to parallelize and implement on CPUs and GPUs and has a runtime that is independent of the selected <italic>p</italic>-value. In terms of single-core performance, it is competitive with state-of-the-art software for PWM matching while being much more efficient when using multithreading. Additionally, BLAMM requires negligible memory. For example, both strands of the entire human genome can be scanned for 1404 PWMs in the JASPAR database in 13 min with a <italic>p</italic>-value of 10<sup>−4</sup> using a 36-core machine. On a dual GPU system, the same task can be performed in under 5 min.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p id="Par3">BLAMM is an efficient tool for identifying PWM matches in large DNA sequences. Its C++ source code is available under the GNU General Public License Version 3 at <ext-link ext-link-type="uri" xlink:href="https://github.com/biointec/blamm">https://github.com/biointec/blamm</ext-link>.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Position weight matrix (PWM)</kwd>
      <kwd>High performance computing (HPC)</kwd>
      <kwd>Basic linear algebra subprograms (BLAS)</kwd>
      <kwd>Graphics processing units (GPUs)</kwd>
    </kwd-group>
    <conference xlink:href="http://iwbbio.ugr.es/">
      <conf-name>6th International Work-Conference on Bioinformatics and Biomedical Engineering</conf-name>
      <conf-loc>Granada, Spain</conf-loc>
      <conf-date>25-27 April 2018</conf-date>
    </conference>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2020</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p>Position weight matrices (PWM), also referred to as a position-specific scoring matrices (PSSM), are used to model short, biologically relevant sequence patterns such as transcription factor binding sites [<xref ref-type="bibr" rid="CR1">1</xref>]. PWMs offer more flexibility than consensus patterns as they can allow variation at each position in the pattern. Databases such as JASPAR [<xref ref-type="bibr" rid="CR2">2</xref>], UniPROBE [<xref ref-type="bibr" rid="CR3">3</xref>] and TRANSFAC [<xref ref-type="bibr" rid="CR4">4</xref>] host large collections of curated PWMs.</p>
    <p>Position weight matrices are generated from an alignment of functionally related sequences. In this work we focus on DNA sequences. Assuming independence between positions, these alignments can be summarized in a 4×<italic>m</italic> position frequency matrix (PFM), with <italic>m</italic> the length of the alignment, where each matrix element PFM (<italic>i</italic>,<italic>j</italic>) represents the frequency of character <italic>i</italic> (0=‘A’; 1=‘C’; 2=‘G’; 3=‘T’) at position <italic>j</italic> in the alignment. By computing, at each position, the relative occurrence of each nucleotide, the position probability matrix (PPM) is derived:
<disp-formula id="Equ1"><label>1</label><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ \text{PPM}(i,j) = \frac{\text{PFM}(i,j)+\alpha}{\sum_{i}(\text{PFM}(i,j)+\alpha)}  $$ \end{document}</tex-math><mml:math id="M2"><mml:mtext>PPM</mml:mtext><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext>PFM</mml:mtext><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:mo>(</mml:mo><mml:mtext>PFM</mml:mtext><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>α</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mfrac></mml:math><graphic xlink:href="12859_2020_3348_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula></p>
    <p>where <italic>α</italic>≥0 is a pseudocount that acts as a smoothing parameter to avoid zero probabilities [<xref ref-type="bibr" rid="CR5">5</xref>]. Finally, when computing the logarithm (base-2) of the ratio of the PPM elements and the corresponding background nucleotide probability <italic>b</italic><sub><italic>i</italic></sub>, the PWM is obtained:
<disp-formula id="Equ2"><label>2</label><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ \text{PWM}(i,j) = \log_{2}\left(\frac{\text{PPM}(i,j)}{b_{i}}\right)  $$ \end{document}</tex-math><mml:math id="M4"><mml:mtext>PWM</mml:mtext><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>log</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:munder><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:mfrac><mml:mrow><mml:mtext>PPM</mml:mtext><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math><graphic xlink:href="12859_2020_3348_Article_Equ2.gif" position="anchor"/></alternatives></disp-formula></p>
    <p>Each element PWM(<italic>i</italic>,<italic>j</italic>) thus represents the log-likelihood ratio of observing character <italic>i</italic> at position <italic>j</italic> in a functional site compared with a random sequence. Figure <xref rid="Fig1" ref-type="fig">1</xref> shows an example of a PFM, PPM and PWM and its corresponding sequence logo visualization [<xref ref-type="bibr" rid="CR6">6</xref>].
<fig id="Fig1"><label>Fig. 1</label><caption><p>Position frequency matrix (PFM), position probability matrix (PPM), position weight matrix (PWM) and sequence logo of the MYB.Ph3 transcription factor. The PFM was obtained from the JASPAR database [<xref ref-type="bibr" rid="CR2">2</xref>]. The PPM/PWM were computed using a pseudocount <italic>α</italic>=1 and assuming a uniform background nucleotide composition (<italic>b</italic><sub><italic>i</italic></sub>=0.25). The sequence logo was generated using WebLogo [<xref ref-type="bibr" rid="CR32">32</xref>]. <bold>a</bold> Position Frequency Matrix (PFM). <bold>b</bold> Position Probability Matrix (PPM). <bold>c</bold> Position Weight Matrix (PWM). <bold>d</bold> Sequence Logo</p></caption><graphic xlink:href="12859_2020_3348_Fig1_HTML" id="MO1"/></fig></p>
    <p>Given a sequence of length <italic>m</italic>, the PWM score is obtained by summing over the PWM log-likelihood ratios at <italic>m</italic> positions, each time selecting the appropriate PWM element, i.e., the one that corresponds to the nucleotide in the sequence. Higher PWM scores express a better correspondence to the PWM model and thus a higher likelihood that the sequence represents a functional site.</p>
    <p>In this work, we focus on the <italic>PWM matching problem</italic>: given an input sequence of length <italic>n</italic> (with typically <italic>n</italic>≫<italic>m</italic>), identify all <italic>matches</italic> or <italic>occurrences</italic> of a PWM, i.e. all subsequences for which the PWM score exceeds a user-defined threshold. These matches are then putative functional sites. The problem can be generalized to the case where the matches of multiple PWMs need to be identified, referred to as the <italic>multiple PWM matching problem</italic>. For long input sequences and/or a large number of PWMs, PWM matching is a compute-intensive problem that may require a large runtime. We briefly review the most important algorithmic approaches and refer to [<xref ref-type="bibr" rid="CR7">7</xref>] for a more detailed overview.</p>
    <p>A simple brute-force algorithm evaluates the PWM score at each possible starting position of the input sequence(s) and has a time complexity of <italic>O</italic>(<italic>n</italic><italic>m</italic>). A simple improvement, called <italic>lookahead scoring</italic>, is to stop the computation of the PWM score as soon as it has been determined that the score threshold can no longer possibly be reached [<xref ref-type="bibr" rid="CR8">8</xref>]. In <italic>permuted lookahead scoring</italic>, the PWM score is evaluated in such order that potential early termination is established as soon as possible. More advanced techniques for PWM matching usually involve generalizations of algorithms developed for exact pattern matching. They can be categorized as either online algorithms, that rely on the preprocessing of the PWM search matrices, or algorithms based on index structures, that rely on the preprocessing of the input sequence(s). In [<xref ref-type="bibr" rid="CR9">9</xref>], PWM matches are identified using a depth-first traversal up to depth <italic>m</italic> of a suffix tree representation of the input sequence(s). This means that PWM score computations of repeated subsequences only need to be performed once and that computations can be partly reused between subsequences that share the same prefix. The use of lookahead scoring allows for the identification of subtrees that contain no PWM matches and that can be discarded from the search procedure. Similarly, the more space-efficient enhanced suffix array (ESA) [<xref ref-type="bibr" rid="CR10">10</xref>] index structure is used in PoSSuMsearch [<xref ref-type="bibr" rid="CR11">11</xref>, <xref ref-type="bibr" rid="CR12">12</xref>]. As index structures require <italic>O</italic>(<italic>n</italic>) memory, which can be costly in practice, much research has been devoted to online algorithms as well. In [<xref ref-type="bibr" rid="CR13">13</xref>], index tables are constructed that contain precomputed (partial) PWM scores for all possible words or a short, fixed length. Additionally, potential similarity between multiple PWMs is exploited to accelerate the multiple PWM matching problem. In [<xref ref-type="bibr" rid="CR14">14</xref>], the shift-add algorithm has been adopted for PWM matching. Similarly, in [<xref ref-type="bibr" rid="CR15">15</xref>], the Morris-Pratt and Knuth-Morris-Pratt algorithms [<xref ref-type="bibr" rid="CR16">16</xref>] are generalized to PWM matching. Finally, in [<xref ref-type="bibr" rid="CR17">17</xref>], the Aho-Corasick, filtration and super-alphabet techniques developed for exact string matching are generalized to PWM matching, and further extended to the multiple PWM matching problem [<xref ref-type="bibr" rid="CR18">18</xref>] and to higher-order PWM matching [<xref ref-type="bibr" rid="CR19">19</xref>]. These algorithms are collectively implemented in the MOODS software package [<xref ref-type="bibr" rid="CR20">20</xref>]. The use of graphics processing unit (GPU) architectures is investigated in [<xref ref-type="bibr" rid="CR21">21</xref>]. The brute-force algorithm is parallelized over the different starting positions of the input sequence, as well as over the different PWMs, thus realizing important performance gains. Additionally, similarly to [<xref ref-type="bibr" rid="CR13">13</xref>], index tables with precomputed partial PWM scores are used for further accelerate the search process.</p>
    <p>These more complex PWM matching methods accelerate the (multiple) PWM matching problem by using various algorithmic techniques to avoid redundant computations and/or eliminate parts of the search space that are guaranteed not to contain PWM matches. The degree to which they can be successful largely depends on the PWM score threshold that is selected. When a high threshold is selected, the PWM matching problem resembles exact pattern matching for which efficient algorithms with <italic>O</italic>(<italic>n</italic>+<italic>m</italic>) time complexity exist. In contrast, for relaxed PWM score thresholds, the fraction of the search space that can be eliminated is small, and the time complexity eventually approaches the <italic>O</italic>(<italic>n</italic><italic>m</italic>) complexity of the brute-force algorithm. As <italic>m</italic> takes a value between 5 and 15 for most practical applications, complex PWM matching algorithms may attain a speedup of approximately one order of magnitude over implementations of the brute-force algorithm.</p>
    <p>In this work, we propose an alternative methodology to accelerate the PWM matching problem that is inspired by High Performance Computing techniques [<xref ref-type="bibr" rid="CR22">22</xref>]. Rather than reducing the search space, we adopt the brute-force algorithm and reduce its runtime by expressing the PWM matching problem in terms of matrix-matrix products (MMP). MMPs can be evaluated with very high efficiency on modern CPUs for two reasons. First, they leverage SIMD (Single Instruction, Multiple Data) instructions that allow the same operation (multiplication, addition) to be performed on multiple data elements simultaneously. Second, MMPs can be implemented such that they maximally exploit spatial and temporal locality of reference, thus ensuring that most data accesses are satisfied from the CPU’s cache memory. As such, MMPs are among a select class of algorithms that can be evaluated with a performance that approaches the theoretical peak performance of the CPU. The latter is typically two orders of magnitude higher than what is effectively obtained by scalar (i.e., non-SIMD), compiler-generated code. High performance MMPs are provided through Basic Linear Algebra Subroutines (BLAS) [<xref ref-type="bibr" rid="CR23">23</xref>] library implementations, for which most CPU vendors offer highly optimized implementations. Alternatively, open-source implementations such as ATLAS [<xref ref-type="bibr" rid="CR24">24</xref>] or GotoBLAS [<xref ref-type="bibr" rid="CR25">25</xref>] can be considered. The proposed method, named BLAMM (BLAS-Accelerated Motif Matching) inherits the advantages of the brute-force algorithm: it requires very little RAM, has a runtime that is independent of the selected PWM threshold(s) and is easy to implement and parallelize. We evaluated BLAMM on three recent generations of Intel CPU architectures and compared its performance with a naive implementation of the brute-force algorithm, MOODS (state-of-the-art online algorithm) and PoSSuMsearch (state-of-the-art index structure based algorithm) for different data sets and PWM threshold settings. Finally, we demonstrate BLAMM can easily leverage the computing power of graphics processing unit (GPU) architectures. To this end, we use the cuBLAS library [<xref ref-type="bibr" rid="CR26">26</xref>] to efficiently perform the MMPs on the GPU rather than on the GPU. The performance of the GPU version of BLAMM is compared with TFM-CUDA, a state-of-the-art GPU implementation.</p>
    <p>This paper is an extended version of the proceedings paper [<xref ref-type="bibr" rid="CR27">27</xref>]. When comparing current benchmark results with the ones initially presented in [<xref ref-type="bibr" rid="CR27">27</xref>], it should be understood that the performance of BLAMM in between both publications has improved significantly through various algorithmic and implementation improvements.</p>
  </sec>
  <sec id="Sec2">
    <title>Implementation</title>
    <p>We consider the multiple PWM matching problem over a DNA alphabet. Starting from the brute-force algorithm, we express the evaluation of the PWM score at each possible starting position of the input sequence(s) in terms of matrix-matrix products (MMP). The procedure involves three matrices:
<list list-type="bullet"><list-item><p>A pattern matrix <italic>P</italic> that contains all of the PWMs.</p></list-item><list-item><p>A sequence matrix <italic>S</italic> that encodes (part of) the DNA input sequence(s) using only elements 0 and 1.</p></list-item><list-item><p>A result matrix <italic>R</italic> that is computed as <italic>R</italic>=sub(<italic>S</italic>)∗<italic>P</italic> and that contains the PWM scores of all PWMs at <italic>some</italic> positions in the input sequence(s). The routine sub(.) denotes that a submatrix of <italic>S</italic> is used.</p></list-item></list></p>
    <p>We now describe each matrix in detail. Figure <xref rid="Fig2" ref-type="fig">2</xref> provides an overview of the algorithm.
<fig id="Fig2"><label>Fig. 2</label><caption><p>The result matrix <italic>R</italic> is computed as the matrix-matrix product of a submatrix of sequence matrix <italic>S</italic> and pattern matrix <italic>P</italic>. Each column of <italic>P</italic> represents a single PWM. Matrix <italic>S</italic> represents (part of) the input sequence. Each element in <italic>R</italic> contains a PWM score at some position in the input sequence</p></caption><graphic xlink:href="12859_2020_3348_Fig2_HTML" id="MO2"/></fig></p>
    <sec id="Sec3">
      <title>Pattern matrix <italic>P</italic></title>
      <p>The pattern matrix <italic>P</italic> is built once and remains constant during the execution of the algorithm. It has dimensions 4<italic>m</italic>×<italic>c</italic> where <italic>c</italic> denotes the total number of PWMs and <italic>m</italic>=max<sub><italic>j</italic></sub>(<italic>m</italic><sup><italic>j</italic></sup>) refers to the maximum PWM length with <italic>m</italic><sup><italic>j</italic></sup> the length of PWM <sup><italic>j</italic></sup>. Every column of <italic>P</italic> corresponds to a single PWM. The values in a column of <italic>P</italic> are obtained by unrolling the values of the corresponding PWM. For PWMs shorter than <italic>m</italic> characters, trailing zeros are appended to the corresponding column in <italic>P</italic>. Formally:
<disp-formula id="Equ3"><label>3</label><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ P(i,j) = \left\{\begin{array}{ll} \text{PWM}^{j}(i~\text{mod}~4, \lfloor i / 4 \rfloor) &amp; \quad 0 \le i &lt; 4m^{j}\\ 0 &amp; \quad i \ge 4m^{j} \end{array}\right.  $$ \end{document}</tex-math><mml:math id="M6"><mml:mi>P</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfenced close="" open="{" separators=""><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msup><mml:mrow><mml:mtext>PWM</mml:mtext></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mspace width="1em"/><mml:mtext>mod</mml:mtext><mml:mspace width="1em"/><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mo>⌊</mml:mo><mml:mi>i</mml:mi><mml:mo>/</mml:mo><mml:mn>4</mml:mn><mml:mo>⌋</mml:mo><mml:mo>)</mml:mo></mml:mtd><mml:mtd><mml:mspace width="1em"/><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>4</mml:mn><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mspace width="1em"/><mml:mi>i</mml:mi><mml:mo>≥</mml:mo><mml:mn>4</mml:mn><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msup></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math><graphic xlink:href="12859_2020_3348_Article_Equ3.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>for all 0≤<italic>j</italic>&lt;<italic>c</italic>.</p>
      <p>In case PWM occurrences on both strands of the input sequence(s) need to be identified, <italic>c</italic> additional columns are added to matrix <italic>P</italic> that represent the reverse-complement of each PWM.</p>
    </sec>
    <sec id="Sec4">
      <title>Sequence matrix <italic>S</italic></title>
      <p>The sequence matrix <italic>S</italic> has dimensions <italic>h</italic>×4(<italic>w</italic>+<italic>m</italic>−1) where <italic>h</italic> and <italic>w</italic> can be arbitrarily chosen ≥1 and where <italic>m</italic> again represents the maximum PWM length. The matrix <italic>S</italic> is used to encode (part of) the input sequence(s) <italic>S</italic><sup>DNA</sup> of exactly <italic>h</italic><italic>w</italic>+<italic>m</italic>−1 nucleotides. First, the string <italic>S</italic><sup>DNA</sup> is converted into an array <italic>S</italic><sup>enc</sup> of 4(<italic>h</italic><italic>w</italic>+<italic>m</italic>−1) zeros and ones by simply replacing character A by 1000; C by 0100; G by 0010; and T by 0001. Formally:
<disp-formula id="Equ4"><label>4</label><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ S^{\text{enc}}(i) = \left\{\begin{array}{ll} 1 &amp; \quad S^{\text{DNA}}(\lfloor i/4 \rfloor) = A \wedge i~\text{mod}~4 = 0 \\ 1 &amp; \quad S^{\text{DNA}}(\lfloor i/4 \rfloor) = C \wedge i~\text{mod}~4 = 1 \\ 1 &amp; \quad S^{\text{DNA}}(\lfloor i/4 \rfloor) = G \wedge i~\text{mod}~4 = 2 \\ 1 &amp; \quad S^{\text{DNA}}(\lfloor i/4 \rfloor) = T \wedge i~\text{mod}~4 = 3 \\ 0 &amp; \quad \text{otherwise} \end{array}\right.  $$ \end{document}</tex-math><mml:math id="M8"><mml:msup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mtext>enc</mml:mtext></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfenced close="" open="{" separators=""><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mspace width="1em"/><mml:msup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mtext>DNA</mml:mtext></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mo>⌊</mml:mo><mml:mi>i</mml:mi><mml:mo>/</mml:mo><mml:mn>4</mml:mn><mml:mo>⌋</mml:mo><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mo>∧</mml:mo><mml:mi>i</mml:mi><mml:mspace width="1em"/><mml:mtext>mod</mml:mtext><mml:mspace width="1em"/><mml:mn>4</mml:mn><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mspace width="1em"/><mml:msup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mtext>DNA</mml:mtext></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mo>⌊</mml:mo><mml:mi>i</mml:mi><mml:mo>/</mml:mo><mml:mn>4</mml:mn><mml:mo>⌋</mml:mo><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:mo>∧</mml:mo><mml:mi>i</mml:mi><mml:mspace width="1em"/><mml:mtext>mod</mml:mtext><mml:mspace width="1em"/><mml:mn>4</mml:mn><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mspace width="1em"/><mml:msup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mtext>DNA</mml:mtext></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mo>⌊</mml:mo><mml:mi>i</mml:mi><mml:mo>/</mml:mo><mml:mn>4</mml:mn><mml:mo>⌋</mml:mo><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>G</mml:mi><mml:mo>∧</mml:mo><mml:mi>i</mml:mi><mml:mspace width="1em"/><mml:mtext>mod</mml:mtext><mml:mspace width="1em"/><mml:mn>4</mml:mn><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mspace width="1em"/><mml:msup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mtext>DNA</mml:mtext></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mo>⌊</mml:mo><mml:mi>i</mml:mi><mml:mo>/</mml:mo><mml:mn>4</mml:mn><mml:mo>⌋</mml:mo><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mo>∧</mml:mo><mml:mi>i</mml:mi><mml:mspace width="1em"/><mml:mtext>mod</mml:mtext><mml:mspace width="1em"/><mml:mn>4</mml:mn><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mspace width="1em"/><mml:mtext>otherwise</mml:mtext></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math><graphic xlink:href="12859_2020_3348_Article_Equ4.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>for all 0≤<italic>i</italic>&lt;4(<italic>h</italic><italic>w</italic>+<italic>m</italic>−1). The matrix <italic>S</italic> is constructed from this temporary array as follows:
<disp-formula id="Equ5"><label>5</label><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ S(i,j) = S^{\text{enc}}(4iw+j)  $$ \end{document}</tex-math><mml:math id="M10"><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mtext>enc</mml:mtext></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mn>4</mml:mn><mml:mtext mathvariant="italic">iw</mml:mtext><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:math><graphic xlink:href="12859_2020_3348_Article_Equ5.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>for all 0≤<italic>i</italic>&lt;<italic>h</italic> and 0≤<italic>j</italic>&lt;4(<italic>w</italic>+<italic>m</italic>−1).</p>
      <p>Every row in <italic>S</italic> contains a contiguous subarray of <italic>S</italic><sup>enc</sup> and thus encodes a substring of <italic>S</italic><sup>DNA</sup>. The rightmost 4(<italic>m</italic>−1) elements of row <italic>i</italic> are identical to the leftmost 4(<italic>m</italic>−1) elements of row <italic>i</italic>+1. In other words, subsequent rows of <italic>S</italic> encode overlapping substrings of <italic>S</italic><sup>DNA</sup> with an overlap of <italic>m</italic>−1 characters.</p>
    </sec>
    <sec id="Sec5">
      <title>Result matrix <italic>R</italic></title>
      <p>The result matrix <italic>R</italic> has dimensions <italic>h</italic>×<italic>c</italic> and is computed as the matrix-matrix product of a submatrix of <italic>S</italic> and matrix <italic>P</italic>. Given an offset <italic>o</italic> with 0≤<italic>o</italic>&lt;<italic>w</italic>, <italic>R</italic><sup><italic>o</italic></sup> is computed as follows:
<disp-formula id="Equ6"><label>6</label><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ R^{o} = S(:,\,[4o,4(o+m)[) * P  $$ \end{document}</tex-math><mml:math id="M12"><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>o</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mo>:</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.3em"/><mml:mo>[</mml:mo><mml:mn>4</mml:mn><mml:mi>o</mml:mi><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo>(</mml:mo><mml:mi>o</mml:mi><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo>)</mml:mo><mml:mo>[</mml:mo><mml:mo>)</mml:mo><mml:mo>∗</mml:mo><mml:mi>P</mml:mi></mml:math><graphic xlink:href="12859_2020_3348_Article_Equ6.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>where the notation <italic>S</italic>(:, [4<italic>o</italic>,4(<italic>o</italic>+<italic>m</italic>)[) refers to the <italic>h</italic>×4<italic>m</italic> submatrix of <italic>S</italic> where the first column of the submatrix corresponds to the column with index 4<italic>o</italic> in <italic>S</italic>. Every element in <italic>R</italic><sup><italic>o</italic></sup> is thus computed as the dot product of (part of) a row in <italic>S</italic> and a column in <italic>P</italic>. The elements of <italic>S</italic> (zeros and ones) are multiplied with the elements of the PWM and thus generate the terms that, when added, correspond to the PWM score. As such, element <italic>R</italic><sup><italic>o</italic></sup>(<italic>i</italic>,<italic>j</italic>) contains the score for PWM <sup><italic>j</italic></sup> at position <italic>i</italic><italic>w</italic>+<italic>o</italic> in <italic>S</italic><sup>DNA</sup>.</p>
      <p>
        <graphic position="anchor" xlink:href="12859_2020_3348_Figa_HTML" id="MO5"/>
      </p>
      <p>Algorithm 1 provides pseudocode for the entire workflow. In the outer for-loop, a portion of the input sequence(s) of length <italic>h</italic><italic>w</italic>+<italic>m</italic>−1 is read into <italic>S</italic><sup>DNA</sup>. In the inner for-loop, the PWM scores are exhaustively computed for all <italic>c</italic> PWMs at the <italic>hw</italic> first positions of <italic>S</italic><sup>DNA</sup>. Therefore, the <italic>S</italic><sup>DNA</sup> strings at consecutive outer for-loop iterations overlap by <italic>m</italic>−1 nucleotides.</p>
      <p>The time complexity of Algorithm 1 is given by:
<disp-formula id="Equ7"><label>7</label><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{*{20}l}  T(n,m,c) &amp;= \sum_{i=1}^{n/(hw)} \left[ O(hw) + \sum_{o=0}^{w-1}\left[ O(hmc) + O(n^{o,i}_{occ}) \right] \right] \end{array} $$ \end{document}</tex-math><mml:math id="M14"><mml:mtable class="align" columnalign="left"><mml:mtr><mml:mtd class="align-1"><mml:mspace width="-9.0pt"/><mml:mi>T</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>)</mml:mo></mml:mtd><mml:mtd class="align-2"><mml:mo>=</mml:mo><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">hw</mml:mtext><mml:mo>)</mml:mo></mml:mrow></mml:munderover><mml:mfenced close="]" open="[" separators=""><mml:mrow><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">hw</mml:mtext><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>o</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mfenced close="]" open="[" separators=""><mml:mrow><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">hmc</mml:mtext><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msubsup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">occ</mml:mtext></mml:mrow><mml:mrow><mml:mi>o</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msubsup><mml:mo>)</mml:mo></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mspace width="2em"/></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="12859_2020_3348_Article_Equ7.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>
        <disp-formula id="Equ8">
          <label>8</label>
          <alternatives>
            <tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{*{20}l} &amp;= \sum_{i=1}^{n/(hw)} \left[ O(hw) + O(hwmc) + O(n^{i}_{occ}) \right] \end{array} $$ \end{document}</tex-math>
            <mml:math id="M16">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1"/>
                  <mml:mtd class="align-2">
                    <mml:mo>=</mml:mo>
                    <mml:munderover accent="false" accentunder="false">
                      <mml:mrow>
                        <mml:mo mathsize="big">∑</mml:mo>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                        <mml:mo>=</mml:mo>
                        <mml:mn>1</mml:mn>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>n</mml:mi>
                        <mml:mo>/</mml:mo>
                        <mml:mo>(</mml:mo>
                        <mml:mtext mathvariant="italic">hw</mml:mtext>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:munderover>
                    <mml:mfenced close="]" open="[" separators="">
                      <mml:mrow>
                        <mml:mi>O</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:mtext mathvariant="italic">hw</mml:mtext>
                        <mml:mo>)</mml:mo>
                        <mml:mo>+</mml:mo>
                        <mml:mi>O</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:mtext mathvariant="italic">hwmc</mml:mtext>
                        <mml:mo>)</mml:mo>
                        <mml:mo>+</mml:mo>
                        <mml:mi>O</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msubsup>
                          <mml:mrow>
                            <mml:mi>n</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mtext mathvariant="italic">occ</mml:mtext>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msubsup>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
            <graphic xlink:href="12859_2020_3348_Article_Equ8.gif" position="anchor"/>
          </alternatives>
        </disp-formula>
      </p>
      <p>
        <disp-formula id="Equ9">
          <label>9</label>
          <alternatives>
            <tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{*{20}l} &amp;= O(n) + O(nmc) + O(n_{occ}) \end{array} $$ \end{document}</tex-math>
            <mml:math id="M18">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1"/>
                  <mml:mtd class="align-2">
                    <mml:mo>=</mml:mo>
                    <mml:mi>O</mml:mi>
                    <mml:mo>(</mml:mo>
                    <mml:mi>n</mml:mi>
                    <mml:mo>)</mml:mo>
                    <mml:mo>+</mml:mo>
                    <mml:mi>O</mml:mi>
                    <mml:mo>(</mml:mo>
                    <mml:mtext mathvariant="italic">nmc</mml:mtext>
                    <mml:mo>)</mml:mo>
                    <mml:mo>+</mml:mo>
                    <mml:mi>O</mml:mi>
                    <mml:mo>(</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>n</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mtext mathvariant="italic">occ</mml:mtext>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>)</mml:mo>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
            <graphic xlink:href="12859_2020_3348_Article_Equ9.gif" position="anchor"/>
          </alternatives>
        </disp-formula>
      </p>
      <p>where <italic>n</italic><sub><italic>occ</italic></sub> denotes the total number of motif occurrences identified. This further simplifies to <italic>O</italic>(<italic>n</italic><italic>m</italic><italic>c</italic>) which is the same time complexity as the brute-force algorithm. Note that the time complexity is indeed independent of the choice of parameters <italic>h</italic> and <italic>w</italic>.</p>
      <p>The space complexity is given by <inline-formula id="IEq1"><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$O(mc + h(w+m) + hc + n^{\text {buf}}_{occ})$\end{document}</tex-math><mml:math id="M20"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">mc</mml:mtext><mml:mo>+</mml:mo><mml:mi>h</mml:mi><mml:mo>(</mml:mo><mml:mi>w</mml:mi><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">hc</mml:mtext><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">occ</mml:mtext></mml:mrow><mml:mrow><mml:mtext>buf</mml:mtext></mml:mrow></mml:msubsup><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2020_3348_Article_IEq1.gif"/></alternatives></inline-formula>, i.e. the space to store the three matrices and where <inline-formula id="IEq2"><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$n^{\text {buf}}_{occ}$\end{document}</tex-math><mml:math id="M22"><mml:msubsup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">occ</mml:mtext></mml:mrow><mml:mrow><mml:mtext>buf</mml:mtext></mml:mrow></mml:msubsup></mml:math><inline-graphic xlink:href="12859_2020_3348_Article_IEq2.gif"/></alternatives></inline-formula> denotes the maximum number of occurrences that are buffered in memory before they are spilled to disk (user-defined).</p>
      <p>Note that in case the input data consists of multiple DNA sequences, these sequences can be concatenated when generating <italic>S</italic><sup>DNA</sup>. With minimal extra bookkeeping, one can prevent the reporting of occurrences that span adjacent DNA sequences.</p>
    </sec>
    <sec id="Sec6">
      <title>Implementation details and performance considerations</title>
      <p>The algorithm was implemented in C++ with support for multithreading using C++11 threads. The workload is easily split in independent subtasks by parallelizing the outer for-loop in Algorithm 1. Under the EREW-PRAM (Exclusive Read, Exclusive Write, Parallel Random-Access Machine) model, the time complexity using <italic>p</italic> parallel processes is given by:
<disp-formula id="Equ10"><label>10</label><alternatives><tex-math id="M23">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{*{20}l} T_{p}(n,m,c) \le O(n) + O(nmc)/p + O(n_{occ})  \end{array} $$ \end{document}</tex-math><mml:math id="M24"><mml:mtable class="align" columnalign="left"><mml:mtr><mml:mtd class="align-1"><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>)</mml:mo><mml:mo>≤</mml:mo><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">nmc</mml:mtext><mml:mo>)</mml:mo><mml:mo>/</mml:mo><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">occ</mml:mtext></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="12859_2020_3348_Article_Equ10.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>where the <italic>O</italic>(<italic>n</italic>) term refers to data input and the <italic>O</italic>(<italic>n</italic><sub><italic>occ</italic></sub>) term refers to data output. Concurrent disk access is indeed prohibited through the use of a mutual-exclusion (mutex) synchronization primitive. The ≤ sign in (<xref rid="Equ10" ref-type="">10</xref>) reflects the fact that disk access and computations can overlap. As all datastructures involved are duplicated per thread, the memory complexity is given by <inline-formula id="IEq3"><alternatives><tex-math id="M25">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$pO(mc + h(w+m) + hc + n^{\text {buf}}_{occ})$\end{document}</tex-math><mml:math id="M26"><mml:mtext mathvariant="italic">pO</mml:mtext><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">mc</mml:mtext><mml:mo>+</mml:mo><mml:mi>h</mml:mi><mml:mo>(</mml:mo><mml:mi>w</mml:mi><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">hc</mml:mtext><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">occ</mml:mtext></mml:mrow><mml:mrow><mml:mtext>buf</mml:mtext></mml:mrow></mml:msubsup><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2020_3348_Article_IEq3.gif"/></alternatives></inline-formula>. This seems reasonable as the matrices require little memory in practice. The thread-local duplication of the read-only matrix <italic>P</italic> is done to avoid performance issues on non-uniform memory access (NUMA) architectures.</p>
      <p>The BLAS sgemm routine [<xref ref-type="bibr" rid="CR23">23</xref>] is used to evaluate the MMPs using single-precision computations. The runtime of BLAMM is largely governed by the time required to evaluate these MMPs and hence the quality of the BLAS library implementation.</p>
      <p>Even though parameters <italic>h</italic> and <italic>w</italic> that govern the dimensions of matrix <italic>S</italic> can be arbitrarily chosen, for performance reasons, they should not be too small (as evaluating MMPs with small matrices is not very efficient) nor too large (to avoid excessive memory requirements). In our implementation, we set <italic>h</italic>=1000 and <italic>w</italic>=250 such that matrix <italic>S</italic> corresponds to a 1000×[1000+4(<italic>m</italic>−1)] matrix.</p>
      <p>Note that BLAS routines have full support to specify submatrix ranges without any need to explicitly copy these submatrices onto separate data structures.</p>
      <p>Finally, note that in [<xref ref-type="bibr" rid="CR27">27</xref>], we described the algorithm in using the transpose matrices <italic>R</italic>, <italic>P</italic> and <italic>S</italic>. Even though both approaches are mathematically equivalent, we found that current representation has a higher performance in practice. This is likely due to the fact that, when using a column-major matrix layout (as is natural in BLAS), matrix sub <sup><italic>o</italic></sup>(<italic>S</italic>) is represented as a linear array and strided-memory access is avoided.</p>
    </sec>
    <sec id="Sec7">
      <title>GPU version</title>
      <p>Graphics processing units (GPUs) contain massively parallel processors able to perform certain tasks with higher efficiency than general-purpose CPUs. Using the cuBLAS [<xref ref-type="bibr" rid="CR26">26</xref>] library, one can evaluate the MMPs on a GPU thus boosting the performance of BLAMM. To this end, the matrices <italic>P</italic> and <italic>S</italic> must be copied to the GPU memory. The constant pattern matrix <italic>P</italic> is copied only once, while a new sequence matrix <italic>S</italic> is copied during each outer for-loop iteration in Algorithm 1. To avoid having to copy the entire result matrix <italic>R</italic><sup><italic>o</italic></sup> from GPU memory to regular RAM after each MMP in the inner for-loop iteration, a kernel was developed in the CUDA programming language to identify the matrix indices (<italic>i</italic>,<italic>j</italic>) for which <italic>R</italic><sup><italic>o</italic></sup>(<italic>i</italic>,<italic>j</italic>) exceeds the threshold score for PWM <sup><italic>j</italic></sup>. This task, known as <italic>stream compaction</italic>, is also executed on the GPU itself. Only the set of indices (<italic>i</italic>,<italic>j</italic>) that correspond to actual PWM matches is copied from GPU to system RAM, thus minimizing the volume of the data that has to be transferred. The CPU itself is only responsible for preparing the <italic>S</italic> matrices and converting the indices (<italic>i</italic>,<italic>j</italic>) to formatted output that is written to disk. Again, by parallelizing over the outer for-loop in Algorithm 1, BLAMM supports the use of multiple GPU devices simultaneously.</p>
      <p>The programming efforts required to enable GPU support are minimal as most tasks are handled by CUDA library calls (copying data between CPU and GPU, calling cublasSgemm,...). The only exception is the stream compaction kernel itself which consists of 7 lines of CUDA code.</p>
    </sec>
    <sec id="Sec8">
      <title>Partitioning of the <italic>P</italic>-matrix</title>
      <p>The total number of floating point operations in BLAMM depends on the size of the input sequence(s) <italic>n</italic>, the total number of PWMs <italic>c</italic> and the length of the <italic>longest</italic> PWM <italic>m</italic>. Indeed, recall that PWMs with a length shorter than <italic>m</italic> are represented as a column in <italic>P</italic> by adding trailing zeros. In case many PWMs have a length that is substantially shorter than <italic>m</italic>, matrix <italic>P</italic> may contain a large fraction of zero elements. In turn, this may create significant overhead during the evaluation of the MMPs.</p>
      <p>This overhead can easily be reduced by sorting the columns in <italic>P</italic> according to length of the PWM they represent and subsequently partitioning <italic>P</italic> into a number of tiles. The evaluation of <italic>R</italic><sup><italic>o</italic></sup>=sub<sup><italic>o</italic></sup>(<italic>S</italic>)∗<italic>P</italic> can then be computed as a number of smaller MMPs as follows:.
<disp-formula id="Equ11"><label>11</label><alternatives><tex-math id="M27">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ R^{o}(:,[\!c_{i},\,c_{i+1}[\!) \,=\, S(:,[\!4o,4(o+m_{i})[\!) * P([0,4m_{i}[,[c_{i},c_{i+1}[)   $$ \end{document}</tex-math><mml:math id="M28"><mml:mspace width="-15.0pt"/><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>o</mml:mi></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mo>:</mml:mo><mml:mo>,</mml:mo><mml:mo>[</mml:mo><mml:mspace width="0.3em"/><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mspace width="0.3em"/><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>[</mml:mo><mml:mspace width="0.3em"/><mml:mo>)</mml:mo><mml:mspace width="0.3em"/><mml:mo>=</mml:mo><mml:mspace width="0.3em"/><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mo>:</mml:mo><mml:mo>,</mml:mo><mml:mo>[</mml:mo><mml:mspace width="0.3em"/><mml:mn>4</mml:mn><mml:mi>o</mml:mi><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo>(</mml:mo><mml:mi>o</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>[</mml:mo><mml:mspace width="0.3em"/><mml:mo>)</mml:mo><mml:mo>∗</mml:mo><mml:mi>P</mml:mi><mml:mo>(</mml:mo><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>[</mml:mo><mml:mo>,</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>[</mml:mo><mml:mo>)</mml:mo></mml:math><graphic xlink:href="12859_2020_3348_Article_Equ11.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>where the interval [<italic>c</italic><sub><italic>i</italic></sub>,<italic>c</italic><sub><italic>i</italic>+1</sub>[ corresponds to a subset of the columns in <italic>R</italic> and <italic>P</italic> and where <italic>m</italic><sub><italic>i</italic></sub> denotes the maximum PWM length in that range. When <italic>m</italic><sub><italic>i</italic></sub>&lt;<italic>m</italic> overhead is reduced.</p>
      <p>The idea is illustrated in Fig. <xref rid="Fig3" ref-type="fig">3</xref> for the JASPAR dataset (see description below). The pattern matrix <italic>P</italic> represents 1404 PWMs with lengths between 5 and 30 and initially contains 62% zero elements (Fig. <xref rid="Fig3" ref-type="fig">3</xref>a). This means that more than half of the floating point operations executed during the MMP are redundant. Matrix <italic>P</italic> is divided into two tiles along some column index <italic>c</italic><sub><italic>i</italic></sub> (Fig. <xref rid="Fig3" ref-type="fig">3</xref>b). The leftmost tile then contains, at the bottom, a submatrix with only zero elements that can be discarded when evaluating the MMP. The column index <italic>c</italic><sub><italic>i</italic></sub> is selected such that the area of this zero submatrix is maximal. The process of matrix subdividing is applied recursively to the two tiles individually. The procedure is stopped when the area of the zero submatrix that can be discarded is smaller than a user-defined parameter. After two rounds of subdividing, four tiles are obtained (Fig. <xref rid="Fig3" ref-type="fig">3</xref>c) and 90% of the zero elements are discarded from <italic>P</italic>. Figure <xref rid="Fig3" ref-type="fig">3</xref>d shows the relative performance gains obtained by subdividing matrix <italic>P</italic>. Different CPU architectures (discussed further) benefit to varying degrees (40% to 18% reduction in runtime). The GPU architecture did not benefit from partitioning <italic>P</italic> (6% increase in runtime). The reason is that even though the total number of floating point operations is reduced, the process of tiling also yields smaller matrices for which the evaluation of the MMPs is less efficient. Current tiling algorithm appears to provide a good trade-off between reduction of zero fill while maintaining fairly large tiles. Note that this tiling algorithm is more efficient than the one we originally described in [<xref ref-type="bibr" rid="CR27">27</xref>] where <italic>P</italic> was partitioned in slices with uniform width.
<fig id="Fig3"><label>Fig. 3</label><caption><p>Example of a pattern matrix <italic>P</italic> containing 1404 JASPAR PWMs where many columns contain trailing zeros because of differences in length of the corresponding PWMs (panel <bold>a</bold>). Matrix <italic>P</italic> subdivided into two (panel <bold>b</bold>) and four (panel <bold>c</bold>) tiles. Relative performance gain/loss from tiling for different CPU and GPU architectures (panel <bold>d</bold>)</p></caption><graphic xlink:href="12859_2020_3348_Fig3_HTML" id="MO3"/></fig></p>
    </sec>
  </sec>
  <sec id="Sec9">
    <title>Benchmark results</title>
    <p>The performance of BLAMM was benchmarked against i) a naive implementation of the brute-force algorithm, ii) MOODS [<xref ref-type="bibr" rid="CR20">20</xref>] as a state-of-the-art online algorithm, iii) PoSSuMsearch [<xref ref-type="bibr" rid="CR11">11</xref>] as a state-of-the-art index structure based implementation and iv) TFM-CUDA [<xref ref-type="bibr" rid="CR21">21</xref>], a state-of-the-art GPU-accelerated implementation. The naive implementation simply scans for PWM occurrences using three nested for-loops: one for-loop over the input sequence(s), a second for-loop over the different PWMs and a third for-loop to compute the PWM score. It has the same code quality standards as BLAMM to ensure a fair comparison.</p>
    <p>A total of 1404 position frequency matrices with length between 5 and 30 were downloaded from the JASPAR CORE database [<xref ref-type="bibr" rid="CR28">28</xref>]. The human genome reference genome (HG38) was retrieved from the GATK Resource Bundle [<xref ref-type="bibr" rid="CR29">29</xref>]. Part of the benchmarks were run only on chromosome 1 (230 Mbp). For all tools, both strands of the DNA sequences were scanned for PWM occurrences. In the case of BLAMM, this is achieved by including the reverse complements of the PWM matrices as columns in matrix <italic>P</italic>. Thus effectively, 2808 PWM matrices were used in total.</p>
    <p>Each tool computes the PWM score thresholds from a user-defined <italic>p</italic>-value. Smaller <italic>p</italic>-values give rise to higher thresholds and vice versa. Like MOODS, PoSSuMsearch and TFM-CUDA, BLAMM implements a dynamic programming algorithm to convert <italic>p</italic>-values to PWM score thresholds [<xref ref-type="bibr" rid="CR30">30</xref>, <xref ref-type="bibr" rid="CR31">31</xref>]. Note that all tools use exact algorithms and should, in principle, produce identical results. Minor differences in output are due to i) slight differences in the process of converting <italic>p</italic>-values to PWM thresholds, ii) slight differences in the way pseudocounts are implemented, iii) differences in the way non-ACGT characters in the input sequences are handled. BLAMM’s CPU and GPU versions produce results identical to the naive brute-force implementation, regardless of the number of threads used. The exact command line arguments for each tool are listed in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Section S1.</p>
    <p>The benchmarks were run on three generations of Intel CPU architectures, referred to as node A, B and C, respectively (see Table <xref rid="Tab1" ref-type="table">1</xref> for details). With each generation, the number of CPU cores increases (16, 24, 36, resp.) while the clock frequency shows a slight decrease (2.6, 2.5 and 2.3 GHz, resp.). Particularly relevant for BLAMM, however, are the SIMD capabilities of the different CPUs. Node A contains CPUs that support Advanced Vector Extensions (AVX) that operate on 256-bit AVX registers and that can thus contain 8 single precision (SP) floating point numbers. Each core is able to generate 16 single precision (SP) floating point operations (FLOPs) per CPU cycle: one 8-wide AVX addition and one 8-wide AVX multiplication. The CPUs in node B support AVX2 instructions which include fused multiply-add (FMA) operations that effectively perform a multiplication and addition in a single instruction. Hence, these CPU cores are able to generate 32 SP FLOPs per CPU cycle: two 8-wide FMA instructions. Finally, the CPU in node C has support for AVX-512 instructions which operate on 512-bit AVX registers that can hold 32 SP numbers again doubling the theoretical peak performance to 64 SP FLOPs per cycle. Table <xref rid="Tab1" ref-type="table">1</xref> also contains the specifications of a node with two nVidia 1080 Ti GPUs. In this case, as most of the workload is performed by the GPUs, the other system specifications (no. of CPU cores, SIMD capabilities) have only a marginal influence on the runtime.
<table-wrap id="Tab1"><label>Table 1</label><caption><p>Configuration details of three generations of CPU nodes with AVX, AVX2 and AVX-512 SIMD support and one node with a dual GPU</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left"/><th align="left">node A</th><th align="left">node B</th><th align="left">node C</th><th align="left">GPU node</th></tr></thead><tbody><tr><td align="left">CPU</td><td align="left">2 x Intel Xeon</td><td align="left">2 x Intel Xeon</td><td align="left">2 x Intel Xeon</td><td align="left">2 x Intel Xeon</td></tr><tr><td align="left"/><td align="left">E5-2670</td><td align="left">E5-2680v3</td><td align="left">Gold 6140</td><td align="left">E5-2630v4</td></tr><tr><td align="left">No. CPU cores</td><td align="left">2 x 8 = 16</td><td align="left">2 x 12 = 24</td><td align="left">2 x 18 = 36</td><td align="left">2 x 10 = 20</td></tr><tr><td align="left">Clock freq.</td><td align="left">2.6 GHz</td><td align="left">2.5 GHz</td><td align="left">2.3 GHz</td><td align="left">2.2 GHz</td></tr><tr><td align="left">Architecture</td><td align="left">Sandy Bridge</td><td align="left">Haswell-EP</td><td align="left">Skylake</td><td align="left">Broadwell</td></tr><tr><td align="left">RAM</td><td align="left">64 GB</td><td align="left">64 GB</td><td align="left">192 GB</td><td align="left">128 GB</td></tr><tr><td align="left">SIMD</td><td align="left">AVX</td><td align="left">AVX2</td><td align="left">AVX-512</td><td align="left">AVX2</td></tr><tr><td align="left">GPU</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">2 x nVidia 1080 Ti</td></tr></tbody></table></table-wrap></p>
    <p>The C++ source code of BLAMM was compiled against the Intel Math Kernel Library (MKL) version 2018.1.163 which implements optimized BLAS routines for Intel CPUs. Depending on the CPU’s capabilities (AVX, AVX2, AVX-512), it automatically selects the most appropriate implementation. In all cases, multi-threading <italic>within</italic> the MKL was disabled. In other words, individual calls to sgemm were always executed in a single-threaded manner but multiple calls to sgemm are issued by different threads concurrently. The CUDA code was compiled with the nvcc compiler and linked against cuBLAS from the CUDA SDK version 8.0.</p>
    <p>When performing the benchmarks with fewer threads than CPU cores, the remaining CPU cores were idle. Runtime (wall clock time) and peak resident memory use were measured using the Linux /usr/bin/time -v tool.</p>
    <p>Table <xref rid="Tab2" ref-type="table">2</xref> shows the benchmark results of the brute-force, MOODS, PoSSuMsearch, TFM-CUDA and BLAMM algorithm on node C (36 CPU cores with AVX-512 support) when searching the occurrences of 1404 JASPAR PWMs on both strands of human chromosome 1 for two different <italic>p</italic>-values: 10<sup>−5</sup> and 10<sup>−4</sup>. The brute-force algorithm, PoSSuMsearch (PWM matching module) and BLAMM support multithreading and were run using 1, 4, 16 and 36 CPU cores respectively. For those cases, the parallel speedup (acceleration factor w.r.t. the single-threaded run) and parallel efficiency (ratio of the parallel speedup and the no. of CPU cores used) are provided. PoSSuM requires an enhanced suffix array (ESA) to be constructed prior to the actual PWM matching; this runtime is reported separately and needs to be performed only once, independent of the <italic>p</italic>-value. The PoSSuM ESA construction step as well as MOODS do not have multithreading support. A more extensive version of this table is provided in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Table S3. Similar tables for node A and B are provided in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Tables S1 and S2, respectively.
<table-wrap id="Tab2"><label>Table 2</label><caption><p>Benchmark results of the brute-force, MOODS, PoSSuMsearch and the proposed BLAMM algorithm on a 36-core Intel Skylake architecture (node C) and on a dual GPU system for TFM-CUDA and BLAMM (GPU mode)</p></caption><graphic position="anchor" xlink:href="12859_2020_3348_Figb_HTML" id="d29e2816"/><table-wrap-foot><p>In all cases, the occurrences of 1404 JASPAR PWMs were searched on both strands of human chromosome 1 for two different <italic>p</italic>-values (10<sup>−5</sup> and 10<sup>−4</sup>)</p></table-wrap-foot></table-wrap></p>
    <p>Despite being the slowest, the naive implementation of the brute-force algorithm has only negligible memory use and shows nearly perfect scaling behavior. Additionally, its runtime is nearly independent of the <italic>p</italic>-value that is used. The minor differences can be attributed to the larger volume of output that has to be written to disk when more relaxed <italic>p</italic>-values are used. MOODS shows excellent runtime performance, taking into account that the software uses only a single CPU-core. However, its memory use is high, exceeding 50 GByte for a <italic>p</italic>-value of 10<sup>−4</sup>. Additionally, both the runtime and memory use depend on the selection of the <italic>p</italic>-value: more relaxed (i.e., higher) <italic>p</italic>-value settings result in additional resource requirements. The same is true for PoSSuMsearch: more relaxed <italic>p</italic>-value settings render it more difficult to eliminate parts of the search space that are guaranteed not to contain PWM occurrences. PoSSuMsearch has a runtime that is comparable to MOODS, albeit with a lower memory use. The software does not benefit much from multithreading with a parallel speedup of at most 2 despite the availability of 36 CPU cores. BLAMM shares the benefits of the brute-force algorithm: a low memory footprint, a runtime that is largely independent of the selected <italic>p</italic>-value, and very good multithreading scaling behavior with a parallel speedup exceeding 27 using 36 CPU cores. When comparing the single-core performance of BLAMM with MOODS and PoSSuMsearch, BLAMM is somewhat slower: it requires 2 to 4 CPU cores to achieve the same runtime. However, when allowed to make use of all available CPU cores, it is 6.2× to 13.7× faster than MOODS, while using only a fraction of the memory. When run on the dual GPU system, runtime is further reduced and PWM occurrences are identified in only 25s. Compared with TFM-CUDA, the GPU version of BLAMM is more than four times faster (single-GPU results). This again illustrates the high performance one can obtain when evaluating MMPs.</p>
    <p>Table <xref rid="Tab3" ref-type="table">3</xref> shows the benchmark results when applying the algorithms to the entire human genome. Again, Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Tables S4 and S5 contain the benchmark results on nodes A and B, respectively. The runtime of MOODS ranges from 36 min to over 3 h, depending on the <italic>p</italic>-value while the memory use ranges from 17.5 GB to 79 GB. Because of these high memory requirements, MOODS cannot be run on nodes A and B for this configuration. Due to the much larger size of the input sequence, memory requirements of PoSSuM also increase significantly. It takes over three hours to construct the ESA index structure and an additional 11 min to over three hours to identify the PWM matches. In contrast, BLAMM has a runtime that is nearly constant (13 min) and requires very little memory. On the GPU system, the runtimes of BLAMM are further reduced to under 5 min. Note that we were unable to run TFM-CUDA on this dataset, likely due to GPU memory restrictions.
<table-wrap id="Tab3"><label>Table 3</label><caption><p>Benchmark results of the naive, MOODS, PoSSuMsearch and the proposed BLAMM algorithm on a 36-core Intel Skylake architecture (node C) and on a dual GPU system for BLAMM (GPU mode)</p></caption><graphic position="anchor" xlink:href="12859_2020_3348_Figc_HTML" id="d29e2875"/><table-wrap-foot><p>In all cases, the occurrences of 1404 JASPAR PWMs were searched on both strands of the entire human genome for three different <italic>p</italic>-values (10<sup>−6</sup>, 10<sup>−5</sup> and 10<sup>−4</sup>)</p></table-wrap-foot></table-wrap></p>
    <p>Figure <xref rid="Fig4" ref-type="fig">4</xref> shows the relative performance gains of the individual tools from newer CPU architectures. For each tool individually, we normalized its runtime (using chr. 1 and a <italic>p</italic>-value = 10<sup>−5</sup>) to the runtime obtained on the oldest CPU architecture (node A). Despite the decrease in CPU clock frequency, all tools benefit from newer architectures, albeit to varying degrees. Due to the introduction of AVX2 and AVX-512 in nodes B and C, respectively, BLAMM is able to benefit the most in terms of single-core performance. The availability of more powerful SIMD instructions in newer architectures automatically translates to faster MMPs and hence, lower runtimes. Also when considering the multithreaded case, BLAMM benefits the most. In that case, we observe that performance benefits not only from newer SIMD instructions, but also from an increasing number of CPU cores.
<fig id="Fig4"><label>Fig. 4</label><caption><p>Relative performance gains from newer CPU architectures. For each tool, runtime was normalized to its runtime on node type A. Both single-threaded and multi-threaded results are shown. For the multi-threaded case, all available CPU cores were used on each node type (16, 24 and 36 for node type A, B and C, respectively)</p></caption><graphic xlink:href="12859_2020_3348_Fig4_HTML" id="MO4"/></fig></p>
  </sec>
  <sec id="Sec10" sec-type="discussion">
    <title>Discussion</title>
    <p>The PWM matching problem is a form of imprecise string matching. Under stringent settings (low <italic>p</italic>-value and hence, a high PWM score threshold), the problem approaches that of exact string matching for which efficient algorithms have been developed, both online and based on index structures. They reduce the complexity from <italic>O</italic>(<italic>n</italic><italic>m</italic>) for a brute-force search to <italic>O</italic>(<italic>n</italic>+<italic>m</italic>). These ideas have been extended to PWM matching and implemented in tools such as MOODS and PoSSuMsearch. Nevertheless, for more relaxed <italic>p</italic>-values, these algorithms lose their ability to a-priori eliminate large parts of the search space and thus require more computational resources. In that respect, the proposed BLAMM algorithm has certain advantages:
<list list-type="bullet"><list-item><p>The runtime does not depend on the selected <italic>p</italic>-value. A small increase in runtime can be observed when relaxing the <italic>p</italic>-value, however, this is due to a higher number of PWM occurrences that have to be written to disk.</p></list-item><list-item><p>The memory use of BLAMM is negligible and again independent of the selected <italic>p</italic>-value. Per CPU core, memory is required for the (relatively small) <italic>S</italic>, <italic>P</italic> and <italic>R</italic> matrices and to buffer occurrences before spilling them to disk. All data structures involved are thread-local and hence, BLAMM makes efficient use of multithreading up to a high number of CPU cores, even on non-uniform memory architectures (NUMA).</p></list-item><list-item><p>The runtime of BLAMM is governed largely by the time required to evaluate the MMPs and hence, the quality of the BLAS implementation. Optimized BLAS libraries are provided by almost all CPU vendors. This enables BLAMM to make full use of current and future SIMD capabilities of CPUs, without needing to modify the source code of BLAMM itself. We have demonstrated this for AVX, AVX2 and AVX-512. As many applications in High Performance Computing and Artificial Intelligence benefit from improved BLAS performance, CPU vendors will surely continue along this path of developments in the future. For example, half-precision floating point computations are increasingly supported and might further improve BLAMM’s performance.</p></list-item><list-item><p>The algorithm and its implementation are very simple.</p></list-item><list-item><p>The algorithm is easily portable to GPUs and/or other co-processors or hardware accelerators. For GPUs, this achieved using the cuBLAS library to enable MMPs to be evaluated on massively parallel processors such as GPUs, thus offloading the CPU and boosting performance.</p></list-item></list></p>
  </sec>
  <sec id="Sec11" sec-type="conclusion">
    <title>Conclusions</title>
    <p>We proposed and described BLAMM as a simple yet effective algorithm to identify position weight matrix occurrences in DNA sequences. The BLAMM algorithm is based on the brute-force algorithm in the sense that it exhaustively computes all PWM scores for all PWMs at each starting position of the input sequence(s). However, it does so with much higher efficiency by expressing all computations through matrix-matrix products (MMPs). It is well-known that MMPs are among a select class of algorithms that can be evaluated on modern, cache-based CPUs with a performance that approaches the theoretical peak performance of the CPU. Highly optimized MMP implementations are provided by CPU vendors through the BLAS library. BLAMM outperforms a naive implementation of the brute-force algorithm by a factor of 13 to 17. Additionally, it inherits the advantages of the brute-force algorithm, namely its simplicity, its negligible memory use, its ability to make very efficient use of multithreading and the fact that runtime and memory use are (largely) independent of the selected <italic>p</italic>-value or PWM score thresholds. Compared with state-of-the-art software package such as MOODS and PoSSuMsearch which implement more sophisticated search algorithms, BLAMM is a factor 2 to 4 slower when considering single-core performance. When using multithreading, BLAMM can be an order of magnitude faster than MOODS and PoSSuMsearch, while requiring only a fraction of their memory use. Finally, we presented an implementation of BLAMM on a GPU system that outperforms all CPU-based algorithms, as well as an existing GPU implementation by a large margin.</p>
  </sec>
  <sec id="Sec12">
    <title>Availability and requirements</title>
    <p><bold>Project name:</bold> BLAMM – BLAS-Accelerated Motif Matching <bold>Project home page:</bold><ext-link ext-link-type="uri" xlink:href="https://github.com/biointec/blamm">https://github.com/biointec/blamm</ext-link><bold>Operating system:</bold> Platform independent <bold>Programming language:</bold> C++11 <bold>Other requirements:</bold> BLAS library, CUDA optional <bold>License:</bold> GNU GPL v3 <bold>Any restrictions to use by non-academics:</bold> none</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary information</title>
    <sec id="Sec13">
      <p>
        <supplementary-material content-type="local-data" id="MOESM1">
          <media xlink:href="12859_2020_3348_MOESM1_ESM.pdf">
            <caption>
              <p><bold>Additional file 1</bold> BLAMM: BLAS-based Algorithm for Finding Position Weight Matrix Occurrences in DNA sequences on CPUs and GPUs.</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
    </sec>
  </sec>
</body>
<back>
  <glossary>
    <title>Abbreviations</title>
    <def-list>
      <def-item>
        <term>ATLAS</term>
        <def>
          <p>Automatically tuned linear algebra software</p>
        </def>
      </def-item>
      <def-item>
        <term>AVX</term>
        <def>
          <p>Advanced vector extensions</p>
        </def>
      </def-item>
      <def-item>
        <term>BLAMM</term>
        <def>
          <p>BLAS-accelerated motif matching</p>
        </def>
      </def-item>
      <def-item>
        <term>BLAS</term>
        <def>
          <p>Basic linear algebra subroutines</p>
        </def>
      </def-item>
      <def-item>
        <term>CUDA</term>
        <def>
          <p>Compute unified device architecture</p>
        </def>
      </def-item>
      <def-item>
        <term>EREW-PRAM</term>
        <def>
          <p>Exclusive read exclusive write parallel random-access machine</p>
        </def>
      </def-item>
      <def-item>
        <term>FLOPs</term>
        <def>
          <p>Floating point operations</p>
        </def>
      </def-item>
      <def-item>
        <term>FMA</term>
        <def>
          <p>Fused multiply-add</p>
        </def>
      </def-item>
      <def-item>
        <term>GPU</term>
        <def>
          <p>Graphics processing unit</p>
        </def>
      </def-item>
      <def-item>
        <term>HPC</term>
        <def>
          <p>High performance computing</p>
        </def>
      </def-item>
      <def-item>
        <term>MKL</term>
        <def>
          <p>Math kernel library</p>
        </def>
      </def-item>
      <def-item>
        <term>MMP</term>
        <def>
          <p>Matrix-matrix product</p>
        </def>
      </def-item>
      <def-item>
        <term>MOODS</term>
        <def>
          <p>Motif occurrence detection suite</p>
        </def>
      </def-item>
      <def-item>
        <term>PFM</term>
        <def>
          <p>Position frequency matrix</p>
        </def>
      </def-item>
      <def-item>
        <term>PPM</term>
        <def>
          <p>Position probability matrix</p>
        </def>
      </def-item>
      <def-item>
        <term>PSSM</term>
        <def>
          <p>Position specific scoring matrix</p>
        </def>
      </def-item>
      <def-item>
        <term>PWM</term>
        <def>
          <p>Position weight matrix</p>
        </def>
      </def-item>
      <def-item>
        <term>SIMD</term>
        <def>
          <p>Single instruction multiple data</p>
        </def>
      </def-item>
    </def-list>
  </glossary>
  <fn-group>
    <fn>
      <p>
        <bold>Publisher’s Note</bold>
      </p>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
  </fn-group>
  <sec>
    <title>Supplementary information</title>
    <p><bold>Supplementary information</bold> accompanies this paper at 10.1186/s12859-020-3348-6.</p>
  </sec>
  <ack>
    <title>Acknowledgements</title>
    <p>The computational resources (Stevin Supercomputer Infrastructure) and services used in this work were provided by the VSC (Flemish Supercomputer Center), funded by Ghent University, FWO and the Flemish Government – department EWI. JF would like to acknowledge Klaas Vandepoele and Subhada Kulkarni for testing the software and providing useful suggestions.</p>
    <sec id="d29e3035">
      <title>About this supplement</title>
      <p>This article has been published as part of <italic>BMC Bioinformatics Volume 21 Supplement 2, 2020: Selected articles from the 6th International Work-Conference on Bioinformatics and Biomedical Engineering</italic>. The full contents of the supplement are available online at URL.</p>
    </sec>
  </ack>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>JF conceived the method, implemented the software, performed benchmarks and wrote the manuscript. The author read and approved the final manuscript.</p>
  </notes>
  <notes notes-type="funding-information">
    <title>Funding</title>
    <p>JF was supported by Ghent University - imec. Publication costs are funded by Ghent University.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Availability of data and materials</title>
    <p>The motifs from the JASPAR database are publicly available [<xref ref-type="bibr" rid="CR2">2</xref>]. The human genome reference genome (HG38) was retrieved from the GATK Resource Bundle [<xref ref-type="bibr" rid="CR29">29</xref>].</p>
  </notes>
  <notes>
    <title>Ethics approval and consent to participate</title>
    <p>Not applicable</p>
  </notes>
  <notes>
    <title>Consent for publication</title>
    <p>Not applicable</p>
  </notes>
  <notes notes-type="COI-statement">
    <title>Competing interests</title>
    <p>The author declares that he has no competing interests.</p>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Stormo</surname>
            <given-names>GD</given-names>
          </name>
        </person-group>
        <article-title>DNA binding sites: representation and discovery</article-title>
        <source>Bioinformatics</source>
        <year>2000</year>
        <volume>16</volume>
        <issue>1</issue>
        <fpage>16</fpage>
        <lpage>23</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/16.1.16</pub-id>
        <pub-id pub-id-type="pmid">10812473</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Khan</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Fornes</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Stigliani</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Gheorghe</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Castro-Mondragon</surname>
            <given-names>JA</given-names>
          </name>
          <name>
            <surname>van der Lee</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Bessy</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Chèneby</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Kulkarni</surname>
            <given-names>SR</given-names>
          </name>
          <name>
            <surname>Tan</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Baranasic</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Arenillas</surname>
            <given-names>DJ</given-names>
          </name>
          <name>
            <surname>Sandelin</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Vandepoele</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Lenhard</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Ballester</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Wasserman</surname>
            <given-names>WW</given-names>
          </name>
          <name>
            <surname>Parcy</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Mathelier</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>JASPAR 2018: update of the open-access database of transcription factor binding profiles and its web framework</article-title>
        <source>Nucleic Acids Res</source>
        <year>2018</year>
        <volume>46</volume>
        <issue>D1</issue>
        <fpage>260</fpage>
        <lpage>6</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkx1126</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Newburger</surname>
            <given-names>DE</given-names>
          </name>
          <name>
            <surname>Bulyk</surname>
            <given-names>ML</given-names>
          </name>
        </person-group>
        <article-title>UniPROBE: an online database of protein binding microarray data on protein-DNA interactions</article-title>
        <source>Nucleic Acids Res</source>
        <year>2009</year>
        <volume>37</volume>
        <issue>Database issue</issue>
        <fpage>77</fpage>
        <lpage>82</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkn660</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wingender</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Dietze</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Karas</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Knüppel</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>TRANSFAC: A database on transcription factors and their DNA binding sites</article-title>
        <source>Nucleic Acids Res</source>
        <year>1996</year>
        <volume>24</volume>
        <issue>1</issue>
        <fpage>238</fpage>
        <lpage>41</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/24.1.238</pub-id>
        <pub-id pub-id-type="pmid">8594589</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Nishida</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Frith</surname>
            <given-names>MC</given-names>
          </name>
          <name>
            <surname>Nakai</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>Pseudocounts for transcription factor binding sites</article-title>
        <source>Nucleic Acids Res</source>
        <year>2009</year>
        <volume>37</volume>
        <issue>3</issue>
        <fpage>939</fpage>
        <lpage>44</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkn1019</pub-id>
        <pub-id pub-id-type="pmid">19106141</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schneider</surname>
            <given-names>TD</given-names>
          </name>
          <name>
            <surname>Stephens</surname>
            <given-names>RM</given-names>
          </name>
        </person-group>
        <article-title>Sequence logos: A new way to display consensus sequences</article-title>
        <source>Nucleic Acids Res</source>
        <year>1990</year>
        <volume>18</volume>
        <fpage>6097</fpage>
        <lpage>6100</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/18.20.6097</pub-id>
        <pub-id pub-id-type="pmid">2172928</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pizzi</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Ukkonen</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Fast profile matching algorithms – A survey</article-title>
        <source>Theor Comput Sci</source>
        <year>2008</year>
        <volume>395</volume>
        <issue>2–3</issue>
        <fpage>137</fpage>
        <lpage>57</lpage>
        <pub-id pub-id-type="doi">10.1016/j.tcs.2008.01.015</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wu</surname>
            <given-names>TD</given-names>
          </name>
          <name>
            <surname>Nevill-Manning</surname>
            <given-names>CG</given-names>
          </name>
          <name>
            <surname>Brutlag</surname>
            <given-names>DL</given-names>
          </name>
        </person-group>
        <article-title>Fast probabilistic analysis of sequence function using scoring matrices</article-title>
        <source>Bioinformatics</source>
        <year>2000</year>
        <volume>16</volume>
        <issue>3</issue>
        <fpage>233</fpage>
        <lpage>44</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/16.3.233</pub-id>
        <pub-id pub-id-type="pmid">10869016</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9</label>
      <mixed-citation publication-type="other">Dorohonceanu B, Nevill-Manning CG. Accelerating protein classification using suffix trees. In: Proceedings of the Eighth International Conference on Intelligent Systems for Molecular Biology, August 19-23, 2000, La Jolla / San Diego, CA, USA: 2000. p. 128–33. <ext-link ext-link-type="uri" xlink:href="http://www.aaai.org/Library/ISMB/2000/ismb00-013.php">http://www.aaai.org/Library/ISMB/2000/ismb00-013.php</ext-link>. Accessed July 2018.</mixed-citation>
    </ref>
    <ref id="CR10">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Abouelhoda</surname>
            <given-names>MI</given-names>
          </name>
          <name>
            <surname>Kurtz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Ohlebusch</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Replacing suffix trees with enhanced suffix arrays</article-title>
        <source>J Discret Algoritm</source>
        <year>2004</year>
        <volume>2</volume>
        <issue>1</issue>
        <fpage>53</fpage>
        <lpage>86</lpage>
        <pub-id pub-id-type="doi">10.1016/S1570-8667(03)00065-0</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11</label>
      <mixed-citation publication-type="other">Beckstette M, Strothmann D, Homann R, Giegerich R, Kurtz S. PoSSuMsearch: Fast and sensitive matching of position specific scoring matrices using enhanced suffix arrays. In: Proc. of the German Conference on Bioinformatics, Volume P-53, GI Lecture Notes in Informatics. 2004. p. 53–64.</mixed-citation>
    </ref>
    <ref id="CR12">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Beckstette</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Homann</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Giegerich</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Kurtz</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Fast index based algorithms and software for matching position specific scoring matrices</article-title>
        <source>BMC Bioinformatics</source>
        <year>2006</year>
        <volume>7</volume>
        <issue>1</issue>
        <fpage>389</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-7-389</pub-id>
        <pub-id pub-id-type="pmid">16930469</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Liefooghe</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Touzet</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Varré</surname>
            <given-names>J-S</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Lewenstein</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Valiente</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Large scale matching for position weight matrices</article-title>
        <source>Combinatorial Pattern Matching</source>
        <year>2006</year>
        <publisher-loc>Berlin</publisher-loc>
        <publisher-name>Springer</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Salmela</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Tarhio</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Ziviani</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Baeza-Yates</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Algorithms for weighted matching</article-title>
        <source>String Processing and Information Retrieval</source>
        <year>2007</year>
        <publisher-loc>Berlin</publisher-loc>
        <publisher-name>Springer</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15</label>
      <mixed-citation publication-type="other">Liefooghe A, Touzet H, Varré J-S. Self-overlapping occurrences and Knuth-Morris-Pratt algorithm for weighted matching. In: 3rd International Conference on Language and Automata Theory and Applications, vol. 5457. Tarragona: 2009. p. 481–92. <ext-link ext-link-type="uri" xlink:href="https://hal.inria.fr/inria-00365411">https://hal.inria.fr/inria-00365411</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR16">
      <label>16</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Knuth</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Morris</surname>
            <given-names>JJr</given-names>
          </name>
          <name>
            <surname>Pratt</surname>
            <given-names>V</given-names>
          </name>
        </person-group>
        <article-title>Fast pattern matching in strings</article-title>
        <source>SIAM J Comput</source>
        <year>1977</year>
        <volume>6</volume>
        <issue>2</issue>
        <fpage>323</fpage>
        <lpage>50</lpage>
        <pub-id pub-id-type="doi">10.1137/0206024</pub-id>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Pizzi</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Rastas</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Ukkonen</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Fast search algorithms for position specific scoring matrices</article-title>
        <source>Proceedings of the 1st International Conference on Bioinformatics Research and Development, BIRD’07</source>
        <year>2007</year>
        <publisher-loc>Berlin</publisher-loc>
        <publisher-name>Springer</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pizzi</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Rastas</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Ukkonen</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Finding significant matches of position weight matrices in linear time</article-title>
        <source>IEEE/ACM Trans Comput Biol Bioinforma</source>
        <year>2011</year>
        <volume>8</volume>
        <issue>1</issue>
        <fpage>69</fpage>
        <lpage>79</lpage>
        <pub-id pub-id-type="doi">10.1109/TCBB.2009.35</pub-id>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19</label>
      <mixed-citation publication-type="other">Korhonen JH, Palin K, Taipale J, Ukkonen E. Fast motif matching revisited: high-order PWMs, SNPs and indels. Bioinforma (Oxf Engl). 2016. 10.1093/bioinformatics/btw683.</mixed-citation>
    </ref>
    <ref id="CR20">
      <label>20</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Korhonen</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Martinmäki</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Pizzi</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Rastas</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Ukkonen</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>MOODS: fast search for position weight matrix matches in DNA sequences</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>23</issue>
        <fpage>3181</fpage>
        <lpage>2</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp554</pub-id>
        <pub-id pub-id-type="pmid">19773334</pub-id>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Giraud</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Varré</surname>
            <given-names>J-S</given-names>
          </name>
        </person-group>
        <article-title>Parallel position weight matrices algorithms</article-title>
        <source>Parallel Comput</source>
        <year>2011</year>
        <volume>37</volume>
        <issue>8</issue>
        <fpage>466</fpage>
        <lpage>78</lpage>
        <pub-id pub-id-type="doi">10.1016/j.parco.2010.10.001</pub-id>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schmidt</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Hildebrandt</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Next-generation sequencing: Big Data meets High Performance Computing</article-title>
        <source>Drug Disc Today</source>
        <year>2017</year>
        <volume>22</volume>
        <issue>4</issue>
        <fpage>712</fpage>
        <lpage>7</lpage>
        <pub-id pub-id-type="doi">10.1016/j.drudis.2017.01.014</pub-id>
      </element-citation>
    </ref>
    <ref id="CR23">
      <label>23</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dongarra</surname>
            <given-names>JJ</given-names>
          </name>
          <name>
            <surname>Du Croz</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Hammarling</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Duff</surname>
            <given-names>IS</given-names>
          </name>
        </person-group>
        <article-title>A set of level 3 basic linear algebra subprograms</article-title>
        <source>ACM Trans Math Softw</source>
        <year>1990</year>
        <volume>16</volume>
        <issue>1</issue>
        <fpage>1</fpage>
        <lpage>17</lpage>
        <pub-id pub-id-type="doi">10.1145/77626.79170</pub-id>
      </element-citation>
    </ref>
    <ref id="CR24">
      <label>24</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Whaley</surname>
            <given-names>RC</given-names>
          </name>
          <name>
            <surname>Dongarra</surname>
            <given-names>JJ</given-names>
          </name>
        </person-group>
        <article-title>Automatically tuned linear algebra software</article-title>
        <source>Proceedings of the 1998 ACM/IEEE Conference on Supercomputing, SC ’98</source>
        <year>1998</year>
        <publisher-loc>Washington, DC</publisher-loc>
        <publisher-name>IEEE Comput Soc</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR25">
      <label>25</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Goto</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Geijn</surname>
            <given-names>RAvd</given-names>
          </name>
        </person-group>
        <article-title>Anatomy of high-performance matrix multiplication</article-title>
        <source>ACM Trans Math Softw</source>
        <year>2008</year>
        <volume>34</volume>
        <issue>3</issue>
        <fpage>12</fpage>
        <lpage>11225</lpage>
        <pub-id pub-id-type="doi">10.1145/1356052.1356053</pub-id>
      </element-citation>
    </ref>
    <ref id="CR26">
      <label>26</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Cook</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <source>CUDA Programming: A Developer’s Guide to Parallel Computing with GPUs, 1st edn.</source>
        <year>2013</year>
        <publisher-loc>San Francisco</publisher-loc>
        <publisher-name>Morgan Kaufmann Publishers Inc.</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR27">
      <label>27</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Fostier</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>A BLAS-based algorithm for finding position weight matrix occurrences in DNA sequences on CPUs and GPUs</article-title>
        <source>Bioinformatics and Biomedical Engineering, Lecture Notes in Bioinformatics</source>
        <year>2018</year>
        <publisher-loc>Cham</publisher-loc>
        <publisher-name>Springer</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR28">
      <label>28</label>
      <mixed-citation publication-type="other">Mathelier A, Fornes O, Arenillas DJ, Chen C-YY, Denay G, Lee J, Shi W, Shyr C, Tan G, Worsley-Hunt R, Zhang AW, Parcy F, Lenhard B, Sandelin A, Wasserman WW. JASPAR 2016: a major expansion and update of the open-access database of transcription factor binding profiles. Nucleic Acids Res. 2016; 44(D1). 10.1093/nar/gkv1176.</mixed-citation>
    </ref>
    <ref id="CR29">
      <label>29</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>McKenna</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Hanna</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Banks</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Sivachenko</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Cibulskis</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Kernytsky</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Garimella</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Altshuler</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Gabriel</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Daly</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>DePristo</surname>
            <given-names>MA</given-names>
          </name>
        </person-group>
        <article-title>The Genome Analysis Toolkit: a MapReduce framework for analyzing next-generation DNA sequencing data</article-title>
        <source>Genome Res</source>
        <year>2010</year>
        <volume>20</volume>
        <issue>9</issue>
        <fpage>1297</fpage>
        <lpage>303</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.107524.110</pub-id>
        <pub-id pub-id-type="pmid">20644199</pub-id>
      </element-citation>
    </ref>
    <ref id="CR30">
      <label>30</label>
      <mixed-citation publication-type="other">Touzet H, Varre JS. Efficient and accurate P-value computation for Position Weight Matrices. Algoritm Mol Biol. 2007; 2(1). 10.1186/1748-7188-2-15.</mixed-citation>
    </ref>
    <ref id="CR31">
      <label>31</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Jiang</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Tromp</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>MQ</given-names>
          </name>
        </person-group>
        <article-title>Computing exact P-values for DNA motifs</article-title>
        <source>Bioinformatics</source>
        <year>2007</year>
        <volume>23</volume>
        <issue>5</issue>
        <fpage>531</fpage>
        <lpage>537</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btl662</pub-id>
        <pub-id pub-id-type="pmid">17237046</pub-id>
      </element-citation>
    </ref>
    <ref id="CR32">
      <label>32</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Crooks</surname>
            <given-names>GE</given-names>
          </name>
          <name>
            <surname>Hon</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Chandonia</surname>
            <given-names>J-M</given-names>
          </name>
          <name>
            <surname>Brenner</surname>
            <given-names>SE</given-names>
          </name>
        </person-group>
        <article-title>WebLogo: a sequence logo generator</article-title>
        <source>Genome Res</source>
        <year>2004</year>
        <volume>14</volume>
        <fpage>1188</fpage>
        <lpage>90</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.849004</pub-id>
        <pub-id pub-id-type="pmid">15173120</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
