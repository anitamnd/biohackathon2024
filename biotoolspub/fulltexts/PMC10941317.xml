<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinform Adv</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinform Adv</journal-id>
    <journal-id journal-id-type="publisher-id">bioadv</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics Advances</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2635-0041</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10941317</article-id>
    <article-id pub-id-type="doi">10.1093/bioadv/vbad117</article-id>
    <article-id pub-id-type="publisher-id">vbad117</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Application Note</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>RepairNatrix: a Snakemake workflow for processing DNA sequencing data for DNA storage</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8763-1507</contrib-id>
        <name>
          <surname>Schwarz</surname>
          <given-names>Peter Michael</given-names>
        </name>
        <aff><institution>Department of Mathematics and Computer Science, University of Marburg</institution>, Marburg 35032, <country country="DE">Germany</country></aff>
        <xref rid="vbad117-cor1" ref-type="corresp"/>
        <!--schwarzk@uni-marburg.de-->
        <xref rid="vbad117-FM1" ref-type="author-notes"/>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-4946-2156</contrib-id>
        <name>
          <surname>Welzel</surname>
          <given-names>Marius</given-names>
        </name>
        <aff><institution>Department of Mathematics and Computer Science, University of Marburg</institution>, Marburg 35032, <country country="DE">Germany</country></aff>
        <xref rid="vbad117-FM1" ref-type="author-notes"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Heider</surname>
          <given-names>Dominik</given-names>
        </name>
        <aff><institution>Department of Mathematics and Computer Science, University of Marburg</institution>, Marburg 35032, <country country="DE">Germany</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Freisleben</surname>
          <given-names>Bernd</given-names>
        </name>
        <aff><institution>Department of Mathematics and Computer Science, University of Marburg</institution>, Marburg 35032, <country country="DE">Germany</country></aff>
        <xref rid="vbad117-cor1" ref-type="corresp"/>
        <!--freisleben@uni-marburg.de-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Fraternali</surname>
          <given-names>Franca</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="vbad117-cor1">Corresponding authors. Department of Mathematics and Computer Science, University of Marburg, Marburg 35032, Germany. E-mail: <email>schwarzk@uni-marburg.de</email> (P.M.S.) and <email>freisleben@uni-marburg.de</email> (B.F.)</corresp>
      <fn id="vbad117-FM1">
        <p>Peter Michael Schwarz and Marius Welzel contributed equally to this work.</p>
      </fn>
    </author-notes>
    <pub-date pub-type="collection">
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-08-26">
      <day>26</day>
      <month>8</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>26</day>
      <month>8</month>
      <year>2023</year>
    </pub-date>
    <volume>3</volume>
    <issue>1</issue>
    <elocation-id>vbad117</elocation-id>
    <history>
      <date date-type="received">
        <day>03</day>
        <month>5</month>
        <year>2023</year>
      </date>
      <date date-type="rev-recd">
        <day>17</day>
        <month>8</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>18</day>
        <month>8</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>24</day>
        <month>8</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>31</day>
        <month>8</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="vbad117.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>There has been rapid progress in the development of error-correcting and constrained codes for DNA storage systems in recent years. However, improving the steps for processing raw sequencing data for DNA storage has a lot of untapped potential for further progress. In particular, constraints can be used as prior information to improve the processing of DNA sequencing data. Furthermore, a workflow tailored to DNA storage codes enables fair comparisons between different approaches while leading to reproducible results.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We present RepairNatrix, a read-processing workflow for DNA storage. RepairNatrix supports preprocessing of raw sequencing data for DNA storage applications and can be used to flag and heuristically repair constraint-violating sequences to further increase the recoverability of encoded data in the presence of errors. Compared to a preprocessing strategy without repair functionality, RepairNatrix reduced the number of raw reads required for the successful, error-free decoding of the input files by a factor of 25–35 across different datasets.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>RepairNatrix is available on Github: <ext-link xlink:href="https://github.com/umr-ds/repairnatrix" ext-link-type="uri">https://github.com/umr-ds/repairnatrix</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>LOEWE program of the State of Hesse</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="7"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>In recent years, using DNA as a storage device has drawn increased attention from academia and industry (<xref rid="vbad117-B25" ref-type="bibr">Takahashi <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="vbad117-B16" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>, <xref rid="vbad117-B2" ref-type="bibr">Bee <italic toggle="yes">et al.</italic> 2021</xref>, <xref rid="vbad117-B13" ref-type="bibr">Löchel <italic toggle="yes">et al.</italic> 2021</xref>, <xref rid="vbad117-B21" ref-type="bibr">Schwarz and Freisleben 2021</xref>, <xref rid="vbad117-B6" ref-type="bibr">El-Shaikh <italic toggle="yes">et al.</italic> 2022</xref>, <xref rid="vbad117-B5" ref-type="bibr">El-Shaikh and Seeger 2023</xref>, <xref rid="vbad117-B9" ref-type="bibr">Ezekannagha <italic toggle="yes">et al.</italic> 2023</xref>, <xref rid="vbad117-B15" ref-type="bibr">Pic <italic toggle="yes">et al.</italic> 2023</xref>, <xref rid="vbad117-B27" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2023</xref>). DNA is an attractive alternative to traditional storage devices, due to its large storage density of up to <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mn>18</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mi mathvariant="italic">bytes</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:math></inline-formula>, long life expectancy, and low energy requirements for storage (<xref rid="vbad117-B3" ref-type="bibr">Ceze <italic toggle="yes">et al.</italic> 2019</xref>). To store digital data in DNA, the data must be converted into the quaternary DNA alphabet, consisting of the nucleotides Adenine (A), Guanine (G), Cytosine (C), and Thymine (T). Instead of simply assigning each two-bit pair to one of the four bases, it is common to use more sophisticated codes to translate binary data to DNA and add redundancy for error correction. To generate DNA that satisfies desired constraints, such codes often restrict the output codewords to a subset of all possible base combinations of a given length. Common constraints (<xref rid="vbad117-B20" ref-type="bibr">Schwarz <italic toggle="yes">et al.</italic> 2020</xref>) are: (i) Guanine–Cytosine (GC) content of 40%–60%, and no large subsequences that deviate from this range, (ii) limited length of homopolymers (a repetition of the same base), and (iii) no occurrence of specific motifs (short subsequences of a specific pattern), e.g. restriction recognition sites used to cut DNA fragments during synthesis. Furthermore, the codes split the input data into shorter fragments to decrease synthesis costs and ease subsequent sequencing. DNA oligonucleotides (oligos) with the base composition of the generated codewords are generated during synthesis. The chemical synthesis methods often generate only short oligos of 100 nucleotides (nt). If the generated codewords are longer than these limitations, multiple shorter oligos are hybridized using various methods (<xref rid="vbad117-B11" ref-type="bibr">Kosuri and Church 2014</xref>).</p>
    <p>Several approaches exist to store the synthesized DNA, e.g. in microwell plates and in lower temperatures to further reduce the probability of depurination (<xref rid="vbad117-B1" ref-type="bibr">An <italic toggle="yes">et al.</italic> 2014</xref>). Alternative storage methods described in the literature are, for example, storing DNA in silicone gel (<xref rid="vbad117-B10" ref-type="bibr">Grass <italic toggle="yes">et al.</italic> 2015</xref>) or integrating the information carrying DNA into living cells, i.e. <italic toggle="yes">in vivo</italic> storage. DNA sequencing methods are used to digitize the DNA again; the Illumina sequencing-by-synthesis approach is commonly used for this purpose. The Illumina approach generates many short reads of up to 150 bp. With paired-end reads, this can increase to 300 bp.</p>
    <p>The sequencers generate FASTQ files that contain multiple reads and, for each read, a sequence identifier, the read itself, and a quality score for each base. The quality score, or PHRED score, is encoded as a single ASCII letter. It is related to the probability that a base was called wrongly: <italic toggle="yes">Q</italic> = −10log<sub>10</sub><italic toggle="yes">P</italic>, where <italic toggle="yes">Q</italic> is the quality score and <italic toggle="yes">P</italic> is the probability that the base was called wrongly by the sequencer. For each sample, either one (single-end) or two (paired-end) FASTQ files are generated. In the paired-end approach, where a single sequence is read from both directions, each forward and reverse read has to be merged to get the full-length read. The resulting FASTQ files consist of different sequences, with multiple reads per unique parent sequence in varying qualities, including sequences with a low quality that are likely wrong. The FASTQ files need extensive processing before the input data can be decoded.</p>
    <p>There are several workflows that process raw sequencing data, but no general workflow exists to process sequencing data for DNA data storage. Typically, a custom script (<xref rid="vbad117-B7" ref-type="bibr">Erlich and Zielinski 2017</xref>) or a customized version of a workflow designed for biological data (<xref rid="vbad117-B27" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2023</xref>) is used. We present RepairNatrix, a workflow for processing DNA sequencing data designed for DNA storage. RepairNatrix uses the Snakemake workflow management engine (<xref rid="vbad117-B12" ref-type="bibr">Köster and Rahmann 2012</xref>) to encapsulate each workflow step into self-contained rules with automatic dependency deployment and allows seamless scaling to different computing environments. RepairNatrix contains rules for quality filtering, primer removal, forward- and reverse-read merging, de-replication, optional rules for similarity clustering, assembly of <italic toggle="yes">in vivo</italic> data, and filtering according to sequence constraints. RepairNatrix can repair erroneous sequences using a maximum-likelihood repair algorithm. It leverages knowledge of sequence constraints to infer the most likely originating sequence from an erroneous one. Compared to a preprocessing strategy without repair functionality, RepairNatrix reduced the number of raw reads required for the successful, error-free decoding of the input files by a factor of 25–35 across different datasets. We also show how the sequence design limitations of DNA storage can be used as additional information during the reconstruction of oligonucleotides, thereby improving decodability.</p>
  </sec>
  <sec>
    <title>2 Approach</title>
    <p>DNA sequencing workflows such as QIIME 2 (<xref rid="vbad117-B8" ref-type="bibr">Estaki <italic toggle="yes">et al.</italic> 2020</xref>) or Natrix (<xref rid="vbad117-B27" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2023</xref>) are designed for processing environmental samples, with the goal of clustering and taxonomically assigning corresponding sequencing reads. Since there are various restrictions during <italic toggle="yes">de novo</italic> synthesis, storage, and sequencing for DNA storage, these sequencing workflows are not optimized for this use case.</p>
    <p>The status quo for en- and decoding in DNA storage is to treat these restrictions as limitations of the medium, and thus create codes that simply adhere to these rules. Our approach is to use the limitations and restrictions as additional information. From an information theory point of view, the presence or absence of rule violations contains information that can and should be used to retrieve the original data. Using this prior knowledge, we present a DNA processing workflow dedicated to different kinds of DNA data storage, and we provide a code-independent repair approach.</p>
    <sec>
      <title>2.1 FASTQ files</title>
      <p>The primary input of RepairNatrix is (one or multiple) FASTQ files. FASTQ is used as an output format of several sequencing technologies, such as Illumina and Oxford Nanopore sequencing machines. Typically, a FASTQ file consists of multiple entries. Each entry consists of a header line that contains the sequence ID and a description, one line of the sequence itself (the read of the sequencing machine), a line consisting of a plus symbol, and a line containing the PHRED quality information of the read. It is a single ASCII encoded value for each base in a sequence, representing the probability that the base was called wrongly by the sequencer. The PHRED quality score can be calculated from the probability of a wrongly called base (<inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>) as follows (<xref rid="vbad117-B4" ref-type="bibr">Cock <italic toggle="yes">et al.</italic> 2009</xref>): <italic toggle="yes">Q</italic><sub>PHRED</sub> = −10 × log<sub>10</sub>(<inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>) It is common to generate a single FASTQ file per sample (<xref rid="vbad117-B23" ref-type="bibr">Sieber <italic toggle="yes">et al.</italic> 2022</xref>). This approach can be utilized for DNA data storage by sequencing single or closely related files. Alternatively, several different files can be sequenced in a single sample and subsequently sorted according to a short identifier added to the sequences. This process is known as demultiplexing.</p>
    </sec>
    <sec>
      <title>2.2 Primer table</title>
      <p>Before sequencing, samples are often amplified using polymerase chain reaction (PCR), a fast and cost-efficient approach to duplicate DNA. The PCR process requires the addition of short subsequences (primers) to the amplification target. To remove these primer sequences, together with other additional subsequences that are not part of the encoded data (like barcodes that identify sequences belonging to the same file or poly-N spacers), RepairNatrix uses a primer table that contains the additional subsequences that are present in each FASTQ file, both for the forward reads and (optionally) for the reverse read. The subsequences can also be removed using a length parameter, removing the first <italic toggle="yes">n</italic> bases of each read. An example primer table is shown in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>.</p>
    </sec>
    <sec>
      <title>2.3 Configuration file</title>
      <p>A configuration file is also required. It contains the parameters for each workflow step. Using a single configuration file supports automated processing of several files in parallel, while allowing users to adjust RepairNatrix to their requirements and experimental conditions. An example of a configuration file is provided in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>.</p>
    </sec>
    <sec>
      <title>2.4 Demultiplexing and initial read filtering</title>
      <p>As an optional first step of the workflow, the input can be demultiplexed by sorting all reads according to their barcode specified in the primer table. The raw data are then filtered using PRINSEQ (<xref rid="vbad117-B19" ref-type="bibr">Schmieder and Edwards, 2011</xref>). The filtering process removes all reads with a lower mean PHRED quality score than a user-defined threshold.</p>
    </sec>
    <sec>
      <title>2.5 Sequence removal, read merging, and de-replication</title>
      <p>If additional subsequences from the biochemical processing are still present in the data, they must be removed before further processing. RepairNatrix supports the removal of barcode and primer sequences either by the base composition of the subsequences or by length. The merging of forward- and reverse-reads, which is required for paired-end Illumina data, together with removing additional subsequences, is carried out by PANDAseq (<xref rid="vbad117-B14" ref-type="bibr">Masella <italic toggle="yes">et al.</italic> 2012</xref>). Then, the sequences are de-replicated, i.e. identical sequences are replaced by a single representation containing the abundance information in the header of the read data.</p>
    </sec>
    <sec>
      <title>2.6 Similarity clustering</title>
      <p>RepairNatrix supports optional clustering of sequences by a similarity threshold, using VSEARCH (<xref rid="vbad117-B18" ref-type="bibr">Rognes <italic toggle="yes">et al.</italic> 2016</xref>) and a user-defined similarity threshold. For clustering, the sequences are sorted by frequency, with the most common sequence first, or by quality, with the sequence with the highest mean PHRED quality score first. In each iteration of the clustering, the first sequence is removed from the pool of remaining sequences and used as a new cluster’s representative sequence. Each sequence in the pool with a higher similarity than the user-defined threshold (with a default value of 97%) to the representative of the current cluster is added to this cluster and removed from the pool of available sequences. This approach is commonly used to generate operational taxonomic units in microbiome analysis (<xref rid="vbad117-B26" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2020</xref>). Here, it serves to merge sequences that differ slightly, using the sequence with either the highest quality (i.e. the sequence with the highest confidence of the sequencer) or the most common sequence as the most likely correct sequence. The similarity threshold should be adjusted to reflect the minimal Hamming distance of two encoded sequences with the used error-correcting code.</p>
    </sec>
    <sec>
      <title>2.7 Filtering constraint-violating sequences</title>
      <p>RepairNatrix can (optionally) remove sequences that violate user-defined constraints, which is carried out after merging forward- and reverse-reads. Since many DNA storage codes can not only add redundancy to the input for error correction purposes but can also generate outputs that adhere to specific constraints, reads that contain subsequences that could not be generated by the codes can, optionally, be filtered out from further processing. Removing these reads can lead to an increase in error correction performance, especially if, for example, early during PCR amplification an error occurred that led to the formation of an erroneous subsequence, like a long homopolymer. This could lead to the wrong sequence being designated as the representative sequence of the cluster. With the erroneous reads filtered out, less potential errors to be corrected by the error correcting code remain, increasing the probability of successful decoding. Since repairing the sequences requires prior similarity clustering, filtering allows users to remove erroneous sequences, even if users do not want the data to be clustered or repaired. This feature will ensure that all processed sequences adhere to the restrictions defined by a user, but it is not possible to use the repair features afterwards. Filtering is divided into two main modes. In the first mode, it can operate as an input filter, removing constraint-violating sequences. This approach ensures that the downstream decoding receives only valid sequences according to the coding restrictions. While this approach does not introduce any additional incorrect sequences and thus cannot reduce the dataset’s quality, some coding schemes might be able to reconstruct the correct data from sequences that violate the restrictions. For these codes, removing these sequences could lower the number of unique sequences in the dataset and thus prevent successful decoding. To accommodate this scenario, RepairNatrix can be used in a second mode to sort the sequences regarding compliance with the rules. In this mode, a weight is applied to each rule violation, together with the (mean) quality score for each (clustered) sequence. Thus, decoding algorithms for coding schemes with unordered encoded data (such as fountain codes) will successfully reconstruct the encoded file before reading low-quality and rule-violating sequences with a higher probability.</p>
    </sec>
    <sec>
      <title>2.8 Maximum-likelihood repair</title>
      <p>One of the key features of RepairNatrix is its ability to perform a maximum-likelihood repair of constraint-violating sequences. The repair functionality requires user-defined constraints that the encoded sequences must adhere to. Such constraints are: (i) global and per-window GC-content, (ii) maximum allowed homopolymer length, (iii) k-mer length, (iv) undesired subsequences, and (v) length of the sequence.</p>
      <p>RepairNatrix comes with pre-defined rules, but its Snakemake-based design allows users to add additional rules. The pre-defined rules can be adjusted by modifying the .yaml file of the project. In contrast, custom rules require modifying the calc_errors function to include user-created functions in the detection and repair process. Such user-defined rules could include support for functions like checksums, unique constraints, or secondary structure predictions. This flexibility allows RepairNatrix to improve the recovery rate for all constraint-satisfying coding schemes.</p>
      <p>The maximum-likelihood repair algorithm of RepairNatrix replaces the base with the highest likelihood of an error by the base, which would minimize the overall error prediction of the current sequence. Depending on the number of rules and mutations, this can be a heuristic approach, but it is very unlikely that the final output will be worse than without maximum-likelihood repair. Users can opt to keep the constraint-violating sequence in the set of all sequences. At the same time, the modified sequence will also be flagged with additional information about the number of changes performed to this sequence.</p>
      <p>As shown in <xref rid="vbad117-F1" ref-type="fig">Fig. 1</xref>, the repair algorithm performs a series of operations on each cluster. First, each centroid of a cluster will be checked against the defined rules. If the sequence adheres to the rules, the centroid will be treated as correct and tagged accordingly. Otherwise, each element in the cluster will be analyzed regarding the user-defined rules (sorted by their edit distance to the centroid). If such a sequence exists, it replaces the current centroid and will be tagged accordingly. If no such sequence exists in the current cluster, the algorithm tries to perform maximum-likelihood repair on the sequences in the cluster (sorted by their edit distances to the centroid). For this purpose, the algorithm applies all user-defined rules to create an error metric for each base in the sequence, then it modifies the base with the highest error metric to minimize the overall error of the sequence, as well as the error metric of the chosen base. This process might continue for up to <italic toggle="yes">n</italic> bases, where <italic toggle="yes">n</italic> is a user-defined threshold after which a sequence will be treated as not recoverable. By default, this algorithm will perform such a repair for all sequences in a cluster, filter out all sequences for which the repair failed, and return the sequence with the lowest number of changes introduced during the repair.</p>
      <fig position="float" id="vbad117-F1">
        <label>Figure 1.</label>
        <caption>
          <p>Top: Overview of the RepairNatrix main sequence processing modules. Nodes with dashed borders are optional. Dark nodes represent raw sequence processing steps, light grey nodes are related to the constraint-based output improvements, and white nodes are <italic toggle="yes">in vivo</italic> specific. Bottom: Workflow for sequence selection/repair for each cluster.</p>
        </caption>
        <graphic xlink:href="vbad117f1" position="float"/>
      </fig>
      <p><xref rid="vbad117-F2" ref-type="fig">Fig. 2</xref> and <xref rid="vbad117-F3" ref-type="fig">3</xref> show a simplified example of possible repairable sequences. For these sequences, we assume an overall and windowed (per 15 bases) GC content of [40, 60], a maximum allowed homopolymer length of 3, as well as a fixed sequence length of 30.
</p>
      <fig position="float" id="vbad117-F2">
        <label>Figure 2.</label>
        <caption>
          <p>A sequence with a homopolymer of length 5, no GC content violations, and a sequence length of 32. The algorithm correctly flags all positions with a homopolymer and detects that the length of the sequence is longer than allowed. The corrected sequence has neither a homopolymer longer than 3, and the sequence length is 30.</p>
        </caption>
        <graphic xlink:href="vbad117f2" position="float"/>
      </fig>
      <fig position="float" id="vbad117-F3">
        <label>Figure 3.</label>
        <caption>
          <p>A sequence with an invalid homopolymer running between two GC windows. The maximum likelihood repair iterates over the homopolymer from the last to the first position to find a suitable repair path. While substituting the last <italic toggle="yes">C</italic> with <italic toggle="yes">A</italic> or <italic toggle="yes">T</italic> would violate the windowed GC content constraint, a substitution with <italic toggle="yes">G</italic> yields a valid solution.</p>
        </caption>
        <graphic xlink:href="vbad117f3" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>2.9 <italic toggle="yes">In vivo</italic> filtering and assembly</title>
      <p>To process data stored <italic toggle="yes">in vivo</italic>, RepairNatrix offers filtering by user-provided genomic data. For <italic toggle="yes">in vivo</italic> data storage, the raw reads typically contain a mixture of payload data and genomic data from the host, or data from the used vector. If the payload data are not extracted from the mixture of reads, the decoding could fail, even in the presence of a sufficiently large number of raw payload reads. With a provided database consisting of the genome of the host organism, RepairNatrix uses the basic local alignment tool (BLAST) to separate the input data into two files: one containing reads that are likely part of the host genome and do not contain stored data, and a second one containing the reads that either did not match any target of the database or only match with low confidence (i.e. a high <italic toggle="yes">E</italic>-value), which are likely sequences belonging to the encoded data. To support shotgun-style sequencing, in which the genome is cloned and randomly fragmented, RepairNatrix uses SPAdes (<xref rid="vbad117-B17" ref-type="bibr">Prjibelski <italic toggle="yes">et al.</italic> 2020</xref>) to assemble fragments to larger contigs, combined with knowledge regarding the length of the encoded data sequences, or if short spacer sequences are used to identify the start and end of encoded data. This approach supports the reconstruction of the encoded sequences from sequencing data consisting of a mixture of the encoded data fragments and other sequences (e.g. host genomic data or artificial chromosomes).</p>
    </sec>
  </sec>
  <sec>
    <title>3 Evaluation</title>
    <p>We evaluated RepairNatrix’s ability to improve sequence processing output for DNA storage using the data and evaluation metrics published by (<xref rid="vbad117-B27" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2023</xref>).</p>
    <p>The complete results are shown in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>. The evaluation was carried out for a mean quality threshold of 10 and a PANDAseq quality score of 0.3. This combination led to the lowest required number of sequences in the results published previously (<xref rid="vbad117-B27" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2023</xref>). Using RepairNatrix, the number of raw reads needed for the successful, error-free decoding of the input files was between 25 (Dornröschen, CRC interval 2 and 3) and 35 (Dornröschen, CRC interval 5) times lower using the repair and cluster representative choosing algorithms of RepairNatrix than without, as shown in <xref rid="vbad117-F4" ref-type="fig">Fig. 4</xref>.</p>
    <fig position="float" id="vbad117-F4">
      <label>Figure 4.</label>
      <caption>
        <p>The minimal number of raw reads required for successful decoding before processing. The numbers after the dataset names describe the CRC interval parameter used for the encoding.</p>
      </caption>
      <graphic xlink:href="vbad117f4" position="float"/>
    </fig>
    <p>The lowest number of sequences after processing that were required for successful decoding were 77%–89% of the encoded sequences before synthesis, as shown in <xref rid="vbad117-F5" ref-type="fig">Fig. 5</xref>. This implies that most of the sequences left after processing were descendants of unique encoded sequences and not just erroneous variants of the same encoded sequence. The results shown in <xref rid="vbad117-F4" ref-type="fig">Figs 4</xref> and <xref rid="vbad117-F5" ref-type="fig">5</xref> demonstrate that incorporating prior constraints into the preprocessing leads to successful decoding with either fewer raw reads or reads that contain a higher percentage of erroneous sequences.</p>
    <fig position="float" id="vbad117-F5">
      <label>Figure 5.</label>
      <caption>
        <p>The minimal amount of sequences left for successful decoding after processing. The numbers after the dataset names describe the CRC interval parameter used for the encoding.</p>
      </caption>
      <graphic xlink:href="vbad117f5" position="float"/>
    </fig>
    <p>To analyze the behavior of the proposed method, we compared the resulting sequence categories. For the <italic toggle="yes">in vitro</italic> experiments using 247 and 429 chunks, the coverage was reduced to the corresponding percentage (e.g. 0.003%, 10% of the raw sequenced reads). For the Dorn_RU10 in-silico experiment, a more restrictive ruleset was enforced during creation of the 184 nt long sequences. This included limiting the maximum allowed homopolymer count to 3, blacklisting 57 sequences from 6 nt to up to 35 nt, as well as enforcing a global and windowed GC content between 40% and 60%. <xref rid="vbad117-F6" ref-type="fig">Figure 6</xref> shows the number of sequences for each output category per experiment. For the more restrictive <italic toggle="yes">in silico</italic> experiment, for which we also introduced a higher number of indel errors and substitution errors using the MESA simulator (<xref rid="vbad117-B20" ref-type="bibr">Schwarz <italic toggle="yes">et al.</italic> 2020</xref>), the number of repaired or substituted sequences significantly increases. Information about the repaired sequences, the affected cluster, and their difference will be stored in a json file for each processed file.</p>
    <fig position="float" id="vbad117-F6">
      <label>Figure 6.</label>
      <caption>
        <p>The distribution of each sequence category for different experiments. For low overhead (01), only a fraction of all sequences violate the constraints. For four clusters, a rule abiding substitute could be found.</p>
      </caption>
      <graphic xlink:href="vbad117f6" position="float"/>
    </fig>
    <p><xref rid="vbad117-F7" ref-type="fig">Figure 7</xref> shows the found and corrected rule violations for the parsed sequences. Besides the shown rules, no violation toward undesired sequences was found. While this is mainly due to the small list of undesired subsequences (5 sequences between 19 and 35 nt each), the absence of homopolymer errors can be explained by the (mostly) error-free synthesis, short storage duration, and robust sequencing technology used. Therefore, most errors detected were based on a constraint-violating (windowed) GC content as well as a non-matching sequence length.</p>
    <fig position="float" id="vbad117-F7">
      <label>Figure 7.</label>
      <caption>
        <p>Different constraint violations for the <italic toggle="yes">in vitro</italic> experiment (Sleeping Beauty) reduced to 10% of its original coverage.</p>
      </caption>
      <graphic xlink:href="vbad117f7" position="float"/>
    </fig>
    <p>To further evaluate the effectiveness of RepairNatrix, we compared using it for raw sequence file preprocessing with the preprocessing method described in the DNA-Fountain publication, where the authors were able to successfully decode data using a random selection of 750 000 raw Illumina sequencing reads. We downloaded the raw data and, after confirming that using both RepairNatrix and the preprocessing approach described by the authors, the data could be successfully decoded using a random selection of 750 000 reads, we reduced the input data to 700 000 randomly selected sequencing reads and preprocessed the reads with both strategies, followed by decoding the preprocessed data using DNA-Fountain. Using the approach described in the DNA-Fountain publication, 123 326 sequences of length 152 nucleotides were left after preprocessing. The decoding reported success, but the MD5 hash of the encoded file did not match the MD5 hash of the input data, indicating a failure to decode the data correctly. An inspection of the output file indicated that it was corrupted. With RepairNatrix, 125 283 sequences of length 152 nucleotides were left after preprocessing. The decoding resulted in a file with the MD5 hash of the input data, as described in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref> of the DNA-Fountain publication. The decoded file was a gzip compressed tarball containing multiple files, including an image of the KolibriOS, a PDF of Shannon’s Mathematical Theory of Communication (<xref rid="vbad117-B22" ref-type="bibr">Shannon 1948</xref>), and a 3 pg video.</p>
  </sec>
  <sec>
    <title>4 Conclusion</title>
    <p>RepairNatrix is a Snakemake-based read-processing workflow that combines Natrix’s raw sequencing data processing capabilities with maximum likelihood reconstruction algorithms tailored to DNA data storage, the ability to extract payload data from a mixture of genomic sequences and payload sequences, and filtering of data with user-defined constraints. This combination allows easy and fast recovery of data stored in DNA, agnostic to the coding scheme used for translating binary data to DNA. The low-code configuration and setup of RepairNatrix allow users to easily restore the most likely sequences for DNA storage experiments from a pool of raw sequencing data. Besides in-vitro storage, RepairNatrix also supports <italic toggle="yes">in vivo</italic> storage, allowing users to blast against a database consisting of host-genome data to filter out biological sequences from encoded sequences and to assemble shotgun sequencing data into contigs. In addition, RepairNatrix processes Illumina and Oxford Nanopore data. Since RepairNatrix is written in the workflow management engine Snakemake, with all dependencies encapsulated in rule-specific Conda (<ext-link xlink:href="https://docs.conda.io/en/latest/" ext-link-type="uri">https://docs.conda.io/en/latest/</ext-link>) environments, results can easily be reproduced, allowing a comparison of different coding methods with the same preprocessing, including the same version for every tool used. All configuration entries are written in a single configuration file, making it easy to share and adjust. In its current version, RepairNatrix can be used with almost any code that requires some form of preprocessing of raw reads before decoding. Codes directly utilizing any form of majority voting during the decoding would most likely only benefit from the basic quality control, read assembly, dereplication and, possibly, from the filtering of constraint-violating sequences. An example of such a code is described in <xref rid="vbad117-B24" ref-type="bibr">Tabatabaei Yazdi <italic toggle="yes">et al.</italic> (2015)</xref>. However, such codes could integrate the maximum-likelihood repair into their workflow to profit from our approach. Additionally, the proposed method could be adapted for any code using non-canonical restrictions by implementing and adding these restrictions into the ruleset. For codes that generate sequences with a dependency between each other (e.g. a guaranteed minimal Hamming distance), a more sophisticated maximum-likelihood approach would have to be implemented taking all possible clusters into account. This would be possible using the RepairNatrix architecture, but it is currently not implemented.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>vbad117_Supplementary_Data</label>
      <media xlink:href="vbad117_supplementary_data.pdf"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>The authors thank Sandra Clemens for the contributions to the code base.</p>
  </ack>
  <sec>
    <title>Author contributions</title>
    <p>M.W. developed the workflow framework and the rules for quality control, assembly, dereplication, clustering, and BLAST. M.W. conducted the <italic toggle="yes">in silico</italic> comparisons. P.M.S. developed the maximum-likelihood repair algorithm and its associated rules. P.M.S. implemented and conducted the <italic toggle="yes">in silico</italic> error type analysis. B.F. and D.H. supervised the work and acquired funding. P.M.S. and M.W. wrote the initial manuscript, with support from B.F. and D.H. All authors contributed to the final manuscript.</p>
  </sec>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics Advances</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work is financially supported by the LOEWE program of the State of Hesse (Germany) in the MOSLA research cluster. The funding body did not influence any aspect of this work.</p>
  </sec>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>The source code of RepairNatrix is available at <ext-link xlink:href="https://github.com/umr-ds/RepairNatrix" ext-link-type="uri">https://github.com/umr-ds/RepairNatrix</ext-link>. The data underlying this article are available as supplementary data of the mentioned articles (<xref rid="vbad117-B27" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2023</xref> and <xref rid="vbad117-B7" ref-type="bibr">Erlich and Zielinski 2017</xref>).</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="vbad117-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>An</surname><given-names>R</given-names></string-name>, <string-name><surname>Jia</surname><given-names>Y</given-names></string-name>, <string-name><surname>Wan</surname><given-names>B</given-names></string-name></person-group><etal>et al</etal><article-title>Non-enzymatic depurination of nucleic acids: factors and mechanisms</article-title>. <source>PLoS One</source><year>2014</year>;<volume>9</volume>:<fpage>e115950</fpage>.<pub-id pub-id-type="pmid">25546310</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bee</surname><given-names>C</given-names></string-name>, <string-name><surname>Chen</surname><given-names>Y-J</given-names></string-name>, <string-name><surname>Queen</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Molecular-level similarity search brings computing to DNA data storage</article-title>. <source>Nat Commun</source><year>2021</year>;<volume>12</volume>:<fpage>4764</fpage>.<pub-id pub-id-type="pmid">34362913</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ceze</surname><given-names>L</given-names></string-name>, <string-name><surname>Nivala</surname><given-names>J</given-names></string-name>, <string-name><surname>Strauss</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>Molecular digital data storage using DNA</article-title>. <source>Nat Rev Genet</source><year>2019</year>;<volume>20</volume>:<fpage>456</fpage>–<lpage>66</lpage>.<pub-id pub-id-type="pmid">31068682</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cock</surname><given-names>PJA</given-names></string-name>, <string-name><surname>Fields</surname><given-names>CJ</given-names></string-name>, <string-name><surname>Goto</surname><given-names>N</given-names></string-name></person-group><etal>et al</etal><article-title>The sanger FASTQ file format for sequences with quality scores, and the solexa/illumina FASTQ variants</article-title>. <source>Nucleic Acids Res</source><year>2009</year>;<volume>38</volume>:<fpage>1767</fpage>–<lpage>71</lpage>.<pub-id pub-id-type="pmid">20015970</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B5">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>El-Shaikh</surname><given-names>A</given-names></string-name>, <string-name><surname>Seeger</surname><given-names>B.</given-names></string-name></person-group> DNAContainer: an object-based storage architecture on DNA. In: <italic toggle="yes">BTW 2023</italic>. Bonn: Gesellschaft für Informatik e.V., <year>2023</year>, <fpage>773</fpage>–<lpage>95</lpage>. doi: <pub-id pub-id-type="doi">10.18420/BTW2023-50</pub-id>.</mixed-citation>
    </ref>
    <ref id="vbad117-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>El-Shaikh</surname><given-names>A</given-names></string-name>, <string-name><surname>Welzel</surname><given-names>M</given-names></string-name>, <string-name><surname>Heider</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>High-scale random access on DNA storage systems</article-title>. <source>NAR Genom Bioinform</source><year>2022</year>;<volume>4</volume>:<fpage>lqab126</fpage>.<pub-id pub-id-type="pmid">35156022</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Erlich</surname><given-names>Y</given-names></string-name>, <string-name><surname>Zielinski</surname><given-names>D.</given-names></string-name></person-group><article-title>DNA fountain enables a robust and efficient storage architecture</article-title>. <source>Science</source><year>2017</year>;<volume>355</volume>:<fpage>950</fpage>–<lpage>4</lpage>.<pub-id pub-id-type="pmid">28254941</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Estaki</surname><given-names>M</given-names></string-name>, <string-name><surname>Jiang</surname><given-names>L</given-names></string-name>, <string-name><surname>Bokulich</surname><given-names>NA</given-names></string-name></person-group><etal>et al</etal><article-title>QIIME 2 enables comprehensive end-to-end analysis of diverse microbiome data and comparative studies with publicly available data</article-title>. <source>Curr Protoc Bioinformatics</source><year>2020</year>;<volume>70</volume>:<fpage>e100</fpage>.<pub-id pub-id-type="pmid">32343490</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ezekannagha</surname><given-names>C</given-names></string-name>, <string-name><surname>Welzel</surname><given-names>M</given-names></string-name>, <string-name><surname>Heider</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>DNAsmart: multiple attribute ranking tool for DNA data storage systems</article-title>. <source>Comput Struct Biotechnol J</source><year>2023</year>;<volume>21</volume>:<fpage>1448</fpage>–<lpage>60</lpage>.<pub-id pub-id-type="pmid">36851917</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Grass</surname><given-names>RN</given-names></string-name>, <string-name><surname>Heckel</surname><given-names>R</given-names></string-name>, <string-name><surname>Puddu</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Robust chemical preservation of digital information on DNA in silica with error-correcting codes</article-title>. <source>Angew Chem Int Ed Engl</source><year>2015</year>;<volume>54</volume>:<fpage>2552</fpage>–<lpage>5</lpage>.<pub-id pub-id-type="pmid">25650567</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kosuri</surname><given-names>S</given-names></string-name>, <string-name><surname>Church</surname><given-names>GM.</given-names></string-name></person-group><article-title>Large-scale de novo DNA synthesis: technologies and applications</article-title>. <source>Nat Methods</source><year>2014</year>;<volume>11</volume>:<fpage>499</fpage>–<lpage>507</lpage>.<pub-id pub-id-type="pmid">24781323</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Köster</surname><given-names>J</given-names></string-name>, <string-name><surname>Rahmann</surname><given-names>S.</given-names></string-name></person-group><article-title>Snakemake—a scalable bioinformatics workflow engine</article-title>. <source>Bioinformatics</source><year>2012</year>;<volume>28</volume>:<fpage>2520</fpage>–<lpage>2</lpage>.<pub-id pub-id-type="pmid">22908215</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Löchel</surname><given-names>HF</given-names></string-name>, <string-name><surname>Welzel</surname><given-names>M</given-names></string-name>, <string-name><surname>Hattab</surname><given-names>G</given-names></string-name></person-group><etal>et al</etal><article-title>Fractal construction of constrained code words for DNA storage systems</article-title>. <source>Nucleic Acids Res</source><year>2021</year>;<volume>50</volume>:<fpage>e30</fpage>.</mixed-citation>
    </ref>
    <ref id="vbad117-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Masella</surname><given-names>AP</given-names></string-name>, <string-name><surname>Bartram</surname><given-names>AK</given-names></string-name>, <string-name><surname>Truszkowski</surname><given-names>JM</given-names></string-name></person-group><etal>et al</etal><article-title>PANDAseq: paired-end assembler for illumina sequences</article-title>. <source>BMC Bioinformatics</source><year>2012</year>;<volume>13</volume>:<fpage>31</fpage>.<pub-id pub-id-type="pmid">22333067</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B15">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Pic</surname><given-names>X</given-names></string-name>, <string-name><surname>Antonio</surname><given-names>EGS</given-names></string-name>, <string-name><surname>Dimopoulou</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal> Rotating labeling of entropy coders for synthetic DNA data storage. In: <italic toggle="yes">2023 24th International Conference on Digital Signal Processing (DSP), Rhodes (Rodos), Greece</italic>, 2023, 1–5. doi: <pub-id pub-id-type="doi">10.1109/DSP58604.2023.10167907</pub-id>.</mixed-citation>
    </ref>
    <ref id="vbad117-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Press</surname><given-names>WH</given-names></string-name>, <string-name><surname>Hawkins</surname><given-names>JA</given-names></string-name>, <string-name><surname>Jones</surname><given-names>SK</given-names></string-name></person-group><etal>et al</etal><article-title>HEDGES error-correcting code for DNA storage corrects indels and allows sequence constraints</article-title>. <source>Proc Natl Acad Sci USA</source><year>2020</year>;<volume>117</volume>:<fpage>18489</fpage>–<lpage>96</lpage>.<pub-id pub-id-type="pmid">32675237</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Prjibelski</surname><given-names>A</given-names></string-name>, <string-name><surname>Antipov</surname><given-names>D</given-names></string-name>, <string-name><surname>Meleshko</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>Using SPAdes de novo assembler</article-title>. <source>Curr Protoc Bioinformatics</source><year>2020</year>;<volume>70</volume>:<fpage>e102</fpage>.<pub-id pub-id-type="pmid">32559359</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rognes</surname><given-names>T</given-names></string-name>, <string-name><surname>Flouri</surname><given-names>T</given-names></string-name>, <string-name><surname>Nichols</surname><given-names>B</given-names></string-name></person-group><etal>et al</etal><article-title>Vsearch: a versatile open source tool for metagenomics</article-title>. <source>PeerJ</source><year>2016</year>;<volume>4</volume>:<fpage>e2584</fpage>.<pub-id pub-id-type="pmid">27781170</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Schmieder</surname><given-names>R</given-names></string-name>, <string-name><surname>Edwards</surname><given-names>R.</given-names></string-name></person-group><article-title>Quality control and preprocessing of metagenomic datasets</article-title>. <source>Bioinformatics</source><year>2011</year>;<volume>27</volume>:<fpage>863</fpage>–<lpage>4</lpage>.<pub-id pub-id-type="pmid">21278185</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Schwarz</surname><given-names>M</given-names></string-name>, <string-name><surname>Welzel</surname><given-names>M</given-names></string-name>, <string-name><surname>Kabdullayeva</surname><given-names>T</given-names></string-name></person-group><etal>et al</etal><article-title>MESA: automated assessment of synthetic DNA fragments and simulation of DNA synthesis, storage, sequencing and PCR errors</article-title>. <source>Bioinformatics</source><year>2020</year>;<volume>36</volume>:<fpage>3322</fpage>–<lpage>6</lpage>.<pub-id pub-id-type="pmid">32129840</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Schwarz</surname><given-names>PM</given-names></string-name>, <string-name><surname>Freisleben</surname><given-names>B.</given-names></string-name></person-group><article-title>NOREC4DNA: near-optimal rateless erasure codes for DNA storage</article-title>. <source>BMC Bioinformatics</source><year>2021</year>;<volume>22</volume>:<fpage>406</fpage>.<pub-id pub-id-type="pmid">34404355</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Shannon</surname><given-names>CE.</given-names></string-name></person-group><article-title>A mathematical theory of communication</article-title>. <source>Bell Syst Tech J</source><year>1948</year>;<volume>27</volume>:<fpage>379</fpage>–<lpage>423</lpage>.</mixed-citation>
    </ref>
    <ref id="vbad117-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sieber</surname><given-names>G</given-names></string-name>, <string-name><surname>Beisser</surname><given-names>D</given-names></string-name>, <string-name><surname>Rothenberger</surname><given-names>JL</given-names></string-name></person-group><etal>et al</etal><article-title>Microbial community shifts induced by plastic and zinc as substitutes of tire abrasion</article-title>. <source>Sci Rep</source><year>2022</year>;<volume>12</volume>:<fpage>18684</fpage>.<pub-id pub-id-type="pmid">36333419</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yazdi</surname><given-names>SMHT</given-names></string-name>, <string-name><surname>Yuan</surname><given-names>Y</given-names></string-name>, <string-name><surname>Ma</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>A rewritable, random-access DNA-based storage system</article-title>. <source>Sci Rep</source><year>2015</year>;<volume>5</volume>:<fpage>14138</fpage>.<pub-id pub-id-type="pmid">26382652</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Takahashi</surname><given-names>CN</given-names></string-name>, <string-name><surname>Nguyen</surname><given-names>BH</given-names></string-name>, <string-name><surname>Strauss</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>Demonstration of end-to-end automation of DNA data storage</article-title>. <source>Sci Rep</source><year>2019</year>;<volume>9</volume>:<fpage>4998</fpage>.<pub-id pub-id-type="pmid">30899031</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Welzel</surname><given-names>M</given-names></string-name>, <string-name><surname>Lange</surname><given-names>A</given-names></string-name>, <string-name><surname>Heider</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>Natrix: a snakemake-based workflow for processing, clustering, and taxonomically assigning amplicon sequencing reads</article-title>. <source>BMC Bioinformatics</source><year>2020</year>;<volume>21</volume>:<fpage>526</fpage>.<pub-id pub-id-type="pmid">33198651</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Welzel</surname><given-names>M</given-names></string-name>, <string-name><surname>Schwarz</surname><given-names>PM</given-names></string-name>, <string-name><surname>Löchel</surname><given-names>HF</given-names></string-name></person-group><etal>et al</etal><article-title>DNA-Aeon provides flexible arithmetic coding for constraint adherence and error correction in DNA storage</article-title>. <source>Nat Commun</source><year>2023</year>;<volume>14</volume>:<fpage>628</fpage>.<pub-id pub-id-type="pmid">36746948</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinform Adv</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinform Adv</journal-id>
    <journal-id journal-id-type="publisher-id">bioadv</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics Advances</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2635-0041</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10941317</article-id>
    <article-id pub-id-type="doi">10.1093/bioadv/vbad117</article-id>
    <article-id pub-id-type="publisher-id">vbad117</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Application Note</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>RepairNatrix: a Snakemake workflow for processing DNA sequencing data for DNA storage</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8763-1507</contrib-id>
        <name>
          <surname>Schwarz</surname>
          <given-names>Peter Michael</given-names>
        </name>
        <aff><institution>Department of Mathematics and Computer Science, University of Marburg</institution>, Marburg 35032, <country country="DE">Germany</country></aff>
        <xref rid="vbad117-cor1" ref-type="corresp"/>
        <!--schwarzk@uni-marburg.de-->
        <xref rid="vbad117-FM1" ref-type="author-notes"/>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-4946-2156</contrib-id>
        <name>
          <surname>Welzel</surname>
          <given-names>Marius</given-names>
        </name>
        <aff><institution>Department of Mathematics and Computer Science, University of Marburg</institution>, Marburg 35032, <country country="DE">Germany</country></aff>
        <xref rid="vbad117-FM1" ref-type="author-notes"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Heider</surname>
          <given-names>Dominik</given-names>
        </name>
        <aff><institution>Department of Mathematics and Computer Science, University of Marburg</institution>, Marburg 35032, <country country="DE">Germany</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Freisleben</surname>
          <given-names>Bernd</given-names>
        </name>
        <aff><institution>Department of Mathematics and Computer Science, University of Marburg</institution>, Marburg 35032, <country country="DE">Germany</country></aff>
        <xref rid="vbad117-cor1" ref-type="corresp"/>
        <!--freisleben@uni-marburg.de-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Fraternali</surname>
          <given-names>Franca</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="vbad117-cor1">Corresponding authors. Department of Mathematics and Computer Science, University of Marburg, Marburg 35032, Germany. E-mail: <email>schwarzk@uni-marburg.de</email> (P.M.S.) and <email>freisleben@uni-marburg.de</email> (B.F.)</corresp>
      <fn id="vbad117-FM1">
        <p>Peter Michael Schwarz and Marius Welzel contributed equally to this work.</p>
      </fn>
    </author-notes>
    <pub-date pub-type="collection">
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-08-26">
      <day>26</day>
      <month>8</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>26</day>
      <month>8</month>
      <year>2023</year>
    </pub-date>
    <volume>3</volume>
    <issue>1</issue>
    <elocation-id>vbad117</elocation-id>
    <history>
      <date date-type="received">
        <day>03</day>
        <month>5</month>
        <year>2023</year>
      </date>
      <date date-type="rev-recd">
        <day>17</day>
        <month>8</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>18</day>
        <month>8</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>24</day>
        <month>8</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>31</day>
        <month>8</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="vbad117.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>There has been rapid progress in the development of error-correcting and constrained codes for DNA storage systems in recent years. However, improving the steps for processing raw sequencing data for DNA storage has a lot of untapped potential for further progress. In particular, constraints can be used as prior information to improve the processing of DNA sequencing data. Furthermore, a workflow tailored to DNA storage codes enables fair comparisons between different approaches while leading to reproducible results.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We present RepairNatrix, a read-processing workflow for DNA storage. RepairNatrix supports preprocessing of raw sequencing data for DNA storage applications and can be used to flag and heuristically repair constraint-violating sequences to further increase the recoverability of encoded data in the presence of errors. Compared to a preprocessing strategy without repair functionality, RepairNatrix reduced the number of raw reads required for the successful, error-free decoding of the input files by a factor of 25–35 across different datasets.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>RepairNatrix is available on Github: <ext-link xlink:href="https://github.com/umr-ds/repairnatrix" ext-link-type="uri">https://github.com/umr-ds/repairnatrix</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>LOEWE program of the State of Hesse</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="7"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>In recent years, using DNA as a storage device has drawn increased attention from academia and industry (<xref rid="vbad117-B25" ref-type="bibr">Takahashi <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="vbad117-B16" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>, <xref rid="vbad117-B2" ref-type="bibr">Bee <italic toggle="yes">et al.</italic> 2021</xref>, <xref rid="vbad117-B13" ref-type="bibr">Löchel <italic toggle="yes">et al.</italic> 2021</xref>, <xref rid="vbad117-B21" ref-type="bibr">Schwarz and Freisleben 2021</xref>, <xref rid="vbad117-B6" ref-type="bibr">El-Shaikh <italic toggle="yes">et al.</italic> 2022</xref>, <xref rid="vbad117-B5" ref-type="bibr">El-Shaikh and Seeger 2023</xref>, <xref rid="vbad117-B9" ref-type="bibr">Ezekannagha <italic toggle="yes">et al.</italic> 2023</xref>, <xref rid="vbad117-B15" ref-type="bibr">Pic <italic toggle="yes">et al.</italic> 2023</xref>, <xref rid="vbad117-B27" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2023</xref>). DNA is an attractive alternative to traditional storage devices, due to its large storage density of up to <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mn>18</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mi mathvariant="italic">bytes</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:math></inline-formula>, long life expectancy, and low energy requirements for storage (<xref rid="vbad117-B3" ref-type="bibr">Ceze <italic toggle="yes">et al.</italic> 2019</xref>). To store digital data in DNA, the data must be converted into the quaternary DNA alphabet, consisting of the nucleotides Adenine (A), Guanine (G), Cytosine (C), and Thymine (T). Instead of simply assigning each two-bit pair to one of the four bases, it is common to use more sophisticated codes to translate binary data to DNA and add redundancy for error correction. To generate DNA that satisfies desired constraints, such codes often restrict the output codewords to a subset of all possible base combinations of a given length. Common constraints (<xref rid="vbad117-B20" ref-type="bibr">Schwarz <italic toggle="yes">et al.</italic> 2020</xref>) are: (i) Guanine–Cytosine (GC) content of 40%–60%, and no large subsequences that deviate from this range, (ii) limited length of homopolymers (a repetition of the same base), and (iii) no occurrence of specific motifs (short subsequences of a specific pattern), e.g. restriction recognition sites used to cut DNA fragments during synthesis. Furthermore, the codes split the input data into shorter fragments to decrease synthesis costs and ease subsequent sequencing. DNA oligonucleotides (oligos) with the base composition of the generated codewords are generated during synthesis. The chemical synthesis methods often generate only short oligos of 100 nucleotides (nt). If the generated codewords are longer than these limitations, multiple shorter oligos are hybridized using various methods (<xref rid="vbad117-B11" ref-type="bibr">Kosuri and Church 2014</xref>).</p>
    <p>Several approaches exist to store the synthesized DNA, e.g. in microwell plates and in lower temperatures to further reduce the probability of depurination (<xref rid="vbad117-B1" ref-type="bibr">An <italic toggle="yes">et al.</italic> 2014</xref>). Alternative storage methods described in the literature are, for example, storing DNA in silicone gel (<xref rid="vbad117-B10" ref-type="bibr">Grass <italic toggle="yes">et al.</italic> 2015</xref>) or integrating the information carrying DNA into living cells, i.e. <italic toggle="yes">in vivo</italic> storage. DNA sequencing methods are used to digitize the DNA again; the Illumina sequencing-by-synthesis approach is commonly used for this purpose. The Illumina approach generates many short reads of up to 150 bp. With paired-end reads, this can increase to 300 bp.</p>
    <p>The sequencers generate FASTQ files that contain multiple reads and, for each read, a sequence identifier, the read itself, and a quality score for each base. The quality score, or PHRED score, is encoded as a single ASCII letter. It is related to the probability that a base was called wrongly: <italic toggle="yes">Q</italic> = −10log<sub>10</sub><italic toggle="yes">P</italic>, where <italic toggle="yes">Q</italic> is the quality score and <italic toggle="yes">P</italic> is the probability that the base was called wrongly by the sequencer. For each sample, either one (single-end) or two (paired-end) FASTQ files are generated. In the paired-end approach, where a single sequence is read from both directions, each forward and reverse read has to be merged to get the full-length read. The resulting FASTQ files consist of different sequences, with multiple reads per unique parent sequence in varying qualities, including sequences with a low quality that are likely wrong. The FASTQ files need extensive processing before the input data can be decoded.</p>
    <p>There are several workflows that process raw sequencing data, but no general workflow exists to process sequencing data for DNA data storage. Typically, a custom script (<xref rid="vbad117-B7" ref-type="bibr">Erlich and Zielinski 2017</xref>) or a customized version of a workflow designed for biological data (<xref rid="vbad117-B27" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2023</xref>) is used. We present RepairNatrix, a workflow for processing DNA sequencing data designed for DNA storage. RepairNatrix uses the Snakemake workflow management engine (<xref rid="vbad117-B12" ref-type="bibr">Köster and Rahmann 2012</xref>) to encapsulate each workflow step into self-contained rules with automatic dependency deployment and allows seamless scaling to different computing environments. RepairNatrix contains rules for quality filtering, primer removal, forward- and reverse-read merging, de-replication, optional rules for similarity clustering, assembly of <italic toggle="yes">in vivo</italic> data, and filtering according to sequence constraints. RepairNatrix can repair erroneous sequences using a maximum-likelihood repair algorithm. It leverages knowledge of sequence constraints to infer the most likely originating sequence from an erroneous one. Compared to a preprocessing strategy without repair functionality, RepairNatrix reduced the number of raw reads required for the successful, error-free decoding of the input files by a factor of 25–35 across different datasets. We also show how the sequence design limitations of DNA storage can be used as additional information during the reconstruction of oligonucleotides, thereby improving decodability.</p>
  </sec>
  <sec>
    <title>2 Approach</title>
    <p>DNA sequencing workflows such as QIIME 2 (<xref rid="vbad117-B8" ref-type="bibr">Estaki <italic toggle="yes">et al.</italic> 2020</xref>) or Natrix (<xref rid="vbad117-B27" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2023</xref>) are designed for processing environmental samples, with the goal of clustering and taxonomically assigning corresponding sequencing reads. Since there are various restrictions during <italic toggle="yes">de novo</italic> synthesis, storage, and sequencing for DNA storage, these sequencing workflows are not optimized for this use case.</p>
    <p>The status quo for en- and decoding in DNA storage is to treat these restrictions as limitations of the medium, and thus create codes that simply adhere to these rules. Our approach is to use the limitations and restrictions as additional information. From an information theory point of view, the presence or absence of rule violations contains information that can and should be used to retrieve the original data. Using this prior knowledge, we present a DNA processing workflow dedicated to different kinds of DNA data storage, and we provide a code-independent repair approach.</p>
    <sec>
      <title>2.1 FASTQ files</title>
      <p>The primary input of RepairNatrix is (one or multiple) FASTQ files. FASTQ is used as an output format of several sequencing technologies, such as Illumina and Oxford Nanopore sequencing machines. Typically, a FASTQ file consists of multiple entries. Each entry consists of a header line that contains the sequence ID and a description, one line of the sequence itself (the read of the sequencing machine), a line consisting of a plus symbol, and a line containing the PHRED quality information of the read. It is a single ASCII encoded value for each base in a sequence, representing the probability that the base was called wrongly by the sequencer. The PHRED quality score can be calculated from the probability of a wrongly called base (<inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>) as follows (<xref rid="vbad117-B4" ref-type="bibr">Cock <italic toggle="yes">et al.</italic> 2009</xref>): <italic toggle="yes">Q</italic><sub>PHRED</sub> = −10 × log<sub>10</sub>(<inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>) It is common to generate a single FASTQ file per sample (<xref rid="vbad117-B23" ref-type="bibr">Sieber <italic toggle="yes">et al.</italic> 2022</xref>). This approach can be utilized for DNA data storage by sequencing single or closely related files. Alternatively, several different files can be sequenced in a single sample and subsequently sorted according to a short identifier added to the sequences. This process is known as demultiplexing.</p>
    </sec>
    <sec>
      <title>2.2 Primer table</title>
      <p>Before sequencing, samples are often amplified using polymerase chain reaction (PCR), a fast and cost-efficient approach to duplicate DNA. The PCR process requires the addition of short subsequences (primers) to the amplification target. To remove these primer sequences, together with other additional subsequences that are not part of the encoded data (like barcodes that identify sequences belonging to the same file or poly-N spacers), RepairNatrix uses a primer table that contains the additional subsequences that are present in each FASTQ file, both for the forward reads and (optionally) for the reverse read. The subsequences can also be removed using a length parameter, removing the first <italic toggle="yes">n</italic> bases of each read. An example primer table is shown in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>.</p>
    </sec>
    <sec>
      <title>2.3 Configuration file</title>
      <p>A configuration file is also required. It contains the parameters for each workflow step. Using a single configuration file supports automated processing of several files in parallel, while allowing users to adjust RepairNatrix to their requirements and experimental conditions. An example of a configuration file is provided in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>.</p>
    </sec>
    <sec>
      <title>2.4 Demultiplexing and initial read filtering</title>
      <p>As an optional first step of the workflow, the input can be demultiplexed by sorting all reads according to their barcode specified in the primer table. The raw data are then filtered using PRINSEQ (<xref rid="vbad117-B19" ref-type="bibr">Schmieder and Edwards, 2011</xref>). The filtering process removes all reads with a lower mean PHRED quality score than a user-defined threshold.</p>
    </sec>
    <sec>
      <title>2.5 Sequence removal, read merging, and de-replication</title>
      <p>If additional subsequences from the biochemical processing are still present in the data, they must be removed before further processing. RepairNatrix supports the removal of barcode and primer sequences either by the base composition of the subsequences or by length. The merging of forward- and reverse-reads, which is required for paired-end Illumina data, together with removing additional subsequences, is carried out by PANDAseq (<xref rid="vbad117-B14" ref-type="bibr">Masella <italic toggle="yes">et al.</italic> 2012</xref>). Then, the sequences are de-replicated, i.e. identical sequences are replaced by a single representation containing the abundance information in the header of the read data.</p>
    </sec>
    <sec>
      <title>2.6 Similarity clustering</title>
      <p>RepairNatrix supports optional clustering of sequences by a similarity threshold, using VSEARCH (<xref rid="vbad117-B18" ref-type="bibr">Rognes <italic toggle="yes">et al.</italic> 2016</xref>) and a user-defined similarity threshold. For clustering, the sequences are sorted by frequency, with the most common sequence first, or by quality, with the sequence with the highest mean PHRED quality score first. In each iteration of the clustering, the first sequence is removed from the pool of remaining sequences and used as a new cluster’s representative sequence. Each sequence in the pool with a higher similarity than the user-defined threshold (with a default value of 97%) to the representative of the current cluster is added to this cluster and removed from the pool of available sequences. This approach is commonly used to generate operational taxonomic units in microbiome analysis (<xref rid="vbad117-B26" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2020</xref>). Here, it serves to merge sequences that differ slightly, using the sequence with either the highest quality (i.e. the sequence with the highest confidence of the sequencer) or the most common sequence as the most likely correct sequence. The similarity threshold should be adjusted to reflect the minimal Hamming distance of two encoded sequences with the used error-correcting code.</p>
    </sec>
    <sec>
      <title>2.7 Filtering constraint-violating sequences</title>
      <p>RepairNatrix can (optionally) remove sequences that violate user-defined constraints, which is carried out after merging forward- and reverse-reads. Since many DNA storage codes can not only add redundancy to the input for error correction purposes but can also generate outputs that adhere to specific constraints, reads that contain subsequences that could not be generated by the codes can, optionally, be filtered out from further processing. Removing these reads can lead to an increase in error correction performance, especially if, for example, early during PCR amplification an error occurred that led to the formation of an erroneous subsequence, like a long homopolymer. This could lead to the wrong sequence being designated as the representative sequence of the cluster. With the erroneous reads filtered out, less potential errors to be corrected by the error correcting code remain, increasing the probability of successful decoding. Since repairing the sequences requires prior similarity clustering, filtering allows users to remove erroneous sequences, even if users do not want the data to be clustered or repaired. This feature will ensure that all processed sequences adhere to the restrictions defined by a user, but it is not possible to use the repair features afterwards. Filtering is divided into two main modes. In the first mode, it can operate as an input filter, removing constraint-violating sequences. This approach ensures that the downstream decoding receives only valid sequences according to the coding restrictions. While this approach does not introduce any additional incorrect sequences and thus cannot reduce the dataset’s quality, some coding schemes might be able to reconstruct the correct data from sequences that violate the restrictions. For these codes, removing these sequences could lower the number of unique sequences in the dataset and thus prevent successful decoding. To accommodate this scenario, RepairNatrix can be used in a second mode to sort the sequences regarding compliance with the rules. In this mode, a weight is applied to each rule violation, together with the (mean) quality score for each (clustered) sequence. Thus, decoding algorithms for coding schemes with unordered encoded data (such as fountain codes) will successfully reconstruct the encoded file before reading low-quality and rule-violating sequences with a higher probability.</p>
    </sec>
    <sec>
      <title>2.8 Maximum-likelihood repair</title>
      <p>One of the key features of RepairNatrix is its ability to perform a maximum-likelihood repair of constraint-violating sequences. The repair functionality requires user-defined constraints that the encoded sequences must adhere to. Such constraints are: (i) global and per-window GC-content, (ii) maximum allowed homopolymer length, (iii) k-mer length, (iv) undesired subsequences, and (v) length of the sequence.</p>
      <p>RepairNatrix comes with pre-defined rules, but its Snakemake-based design allows users to add additional rules. The pre-defined rules can be adjusted by modifying the .yaml file of the project. In contrast, custom rules require modifying the calc_errors function to include user-created functions in the detection and repair process. Such user-defined rules could include support for functions like checksums, unique constraints, or secondary structure predictions. This flexibility allows RepairNatrix to improve the recovery rate for all constraint-satisfying coding schemes.</p>
      <p>The maximum-likelihood repair algorithm of RepairNatrix replaces the base with the highest likelihood of an error by the base, which would minimize the overall error prediction of the current sequence. Depending on the number of rules and mutations, this can be a heuristic approach, but it is very unlikely that the final output will be worse than without maximum-likelihood repair. Users can opt to keep the constraint-violating sequence in the set of all sequences. At the same time, the modified sequence will also be flagged with additional information about the number of changes performed to this sequence.</p>
      <p>As shown in <xref rid="vbad117-F1" ref-type="fig">Fig. 1</xref>, the repair algorithm performs a series of operations on each cluster. First, each centroid of a cluster will be checked against the defined rules. If the sequence adheres to the rules, the centroid will be treated as correct and tagged accordingly. Otherwise, each element in the cluster will be analyzed regarding the user-defined rules (sorted by their edit distance to the centroid). If such a sequence exists, it replaces the current centroid and will be tagged accordingly. If no such sequence exists in the current cluster, the algorithm tries to perform maximum-likelihood repair on the sequences in the cluster (sorted by their edit distances to the centroid). For this purpose, the algorithm applies all user-defined rules to create an error metric for each base in the sequence, then it modifies the base with the highest error metric to minimize the overall error of the sequence, as well as the error metric of the chosen base. This process might continue for up to <italic toggle="yes">n</italic> bases, where <italic toggle="yes">n</italic> is a user-defined threshold after which a sequence will be treated as not recoverable. By default, this algorithm will perform such a repair for all sequences in a cluster, filter out all sequences for which the repair failed, and return the sequence with the lowest number of changes introduced during the repair.</p>
      <fig position="float" id="vbad117-F1">
        <label>Figure 1.</label>
        <caption>
          <p>Top: Overview of the RepairNatrix main sequence processing modules. Nodes with dashed borders are optional. Dark nodes represent raw sequence processing steps, light grey nodes are related to the constraint-based output improvements, and white nodes are <italic toggle="yes">in vivo</italic> specific. Bottom: Workflow for sequence selection/repair for each cluster.</p>
        </caption>
        <graphic xlink:href="vbad117f1" position="float"/>
      </fig>
      <p><xref rid="vbad117-F2" ref-type="fig">Fig. 2</xref> and <xref rid="vbad117-F3" ref-type="fig">3</xref> show a simplified example of possible repairable sequences. For these sequences, we assume an overall and windowed (per 15 bases) GC content of [40, 60], a maximum allowed homopolymer length of 3, as well as a fixed sequence length of 30.
</p>
      <fig position="float" id="vbad117-F2">
        <label>Figure 2.</label>
        <caption>
          <p>A sequence with a homopolymer of length 5, no GC content violations, and a sequence length of 32. The algorithm correctly flags all positions with a homopolymer and detects that the length of the sequence is longer than allowed. The corrected sequence has neither a homopolymer longer than 3, and the sequence length is 30.</p>
        </caption>
        <graphic xlink:href="vbad117f2" position="float"/>
      </fig>
      <fig position="float" id="vbad117-F3">
        <label>Figure 3.</label>
        <caption>
          <p>A sequence with an invalid homopolymer running between two GC windows. The maximum likelihood repair iterates over the homopolymer from the last to the first position to find a suitable repair path. While substituting the last <italic toggle="yes">C</italic> with <italic toggle="yes">A</italic> or <italic toggle="yes">T</italic> would violate the windowed GC content constraint, a substitution with <italic toggle="yes">G</italic> yields a valid solution.</p>
        </caption>
        <graphic xlink:href="vbad117f3" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>2.9 <italic toggle="yes">In vivo</italic> filtering and assembly</title>
      <p>To process data stored <italic toggle="yes">in vivo</italic>, RepairNatrix offers filtering by user-provided genomic data. For <italic toggle="yes">in vivo</italic> data storage, the raw reads typically contain a mixture of payload data and genomic data from the host, or data from the used vector. If the payload data are not extracted from the mixture of reads, the decoding could fail, even in the presence of a sufficiently large number of raw payload reads. With a provided database consisting of the genome of the host organism, RepairNatrix uses the basic local alignment tool (BLAST) to separate the input data into two files: one containing reads that are likely part of the host genome and do not contain stored data, and a second one containing the reads that either did not match any target of the database or only match with low confidence (i.e. a high <italic toggle="yes">E</italic>-value), which are likely sequences belonging to the encoded data. To support shotgun-style sequencing, in which the genome is cloned and randomly fragmented, RepairNatrix uses SPAdes (<xref rid="vbad117-B17" ref-type="bibr">Prjibelski <italic toggle="yes">et al.</italic> 2020</xref>) to assemble fragments to larger contigs, combined with knowledge regarding the length of the encoded data sequences, or if short spacer sequences are used to identify the start and end of encoded data. This approach supports the reconstruction of the encoded sequences from sequencing data consisting of a mixture of the encoded data fragments and other sequences (e.g. host genomic data or artificial chromosomes).</p>
    </sec>
  </sec>
  <sec>
    <title>3 Evaluation</title>
    <p>We evaluated RepairNatrix’s ability to improve sequence processing output for DNA storage using the data and evaluation metrics published by (<xref rid="vbad117-B27" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2023</xref>).</p>
    <p>The complete results are shown in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>. The evaluation was carried out for a mean quality threshold of 10 and a PANDAseq quality score of 0.3. This combination led to the lowest required number of sequences in the results published previously (<xref rid="vbad117-B27" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2023</xref>). Using RepairNatrix, the number of raw reads needed for the successful, error-free decoding of the input files was between 25 (Dornröschen, CRC interval 2 and 3) and 35 (Dornröschen, CRC interval 5) times lower using the repair and cluster representative choosing algorithms of RepairNatrix than without, as shown in <xref rid="vbad117-F4" ref-type="fig">Fig. 4</xref>.</p>
    <fig position="float" id="vbad117-F4">
      <label>Figure 4.</label>
      <caption>
        <p>The minimal number of raw reads required for successful decoding before processing. The numbers after the dataset names describe the CRC interval parameter used for the encoding.</p>
      </caption>
      <graphic xlink:href="vbad117f4" position="float"/>
    </fig>
    <p>The lowest number of sequences after processing that were required for successful decoding were 77%–89% of the encoded sequences before synthesis, as shown in <xref rid="vbad117-F5" ref-type="fig">Fig. 5</xref>. This implies that most of the sequences left after processing were descendants of unique encoded sequences and not just erroneous variants of the same encoded sequence. The results shown in <xref rid="vbad117-F4" ref-type="fig">Figs 4</xref> and <xref rid="vbad117-F5" ref-type="fig">5</xref> demonstrate that incorporating prior constraints into the preprocessing leads to successful decoding with either fewer raw reads or reads that contain a higher percentage of erroneous sequences.</p>
    <fig position="float" id="vbad117-F5">
      <label>Figure 5.</label>
      <caption>
        <p>The minimal amount of sequences left for successful decoding after processing. The numbers after the dataset names describe the CRC interval parameter used for the encoding.</p>
      </caption>
      <graphic xlink:href="vbad117f5" position="float"/>
    </fig>
    <p>To analyze the behavior of the proposed method, we compared the resulting sequence categories. For the <italic toggle="yes">in vitro</italic> experiments using 247 and 429 chunks, the coverage was reduced to the corresponding percentage (e.g. 0.003%, 10% of the raw sequenced reads). For the Dorn_RU10 in-silico experiment, a more restrictive ruleset was enforced during creation of the 184 nt long sequences. This included limiting the maximum allowed homopolymer count to 3, blacklisting 57 sequences from 6 nt to up to 35 nt, as well as enforcing a global and windowed GC content between 40% and 60%. <xref rid="vbad117-F6" ref-type="fig">Figure 6</xref> shows the number of sequences for each output category per experiment. For the more restrictive <italic toggle="yes">in silico</italic> experiment, for which we also introduced a higher number of indel errors and substitution errors using the MESA simulator (<xref rid="vbad117-B20" ref-type="bibr">Schwarz <italic toggle="yes">et al.</italic> 2020</xref>), the number of repaired or substituted sequences significantly increases. Information about the repaired sequences, the affected cluster, and their difference will be stored in a json file for each processed file.</p>
    <fig position="float" id="vbad117-F6">
      <label>Figure 6.</label>
      <caption>
        <p>The distribution of each sequence category for different experiments. For low overhead (01), only a fraction of all sequences violate the constraints. For four clusters, a rule abiding substitute could be found.</p>
      </caption>
      <graphic xlink:href="vbad117f6" position="float"/>
    </fig>
    <p><xref rid="vbad117-F7" ref-type="fig">Figure 7</xref> shows the found and corrected rule violations for the parsed sequences. Besides the shown rules, no violation toward undesired sequences was found. While this is mainly due to the small list of undesired subsequences (5 sequences between 19 and 35 nt each), the absence of homopolymer errors can be explained by the (mostly) error-free synthesis, short storage duration, and robust sequencing technology used. Therefore, most errors detected were based on a constraint-violating (windowed) GC content as well as a non-matching sequence length.</p>
    <fig position="float" id="vbad117-F7">
      <label>Figure 7.</label>
      <caption>
        <p>Different constraint violations for the <italic toggle="yes">in vitro</italic> experiment (Sleeping Beauty) reduced to 10% of its original coverage.</p>
      </caption>
      <graphic xlink:href="vbad117f7" position="float"/>
    </fig>
    <p>To further evaluate the effectiveness of RepairNatrix, we compared using it for raw sequence file preprocessing with the preprocessing method described in the DNA-Fountain publication, where the authors were able to successfully decode data using a random selection of 750 000 raw Illumina sequencing reads. We downloaded the raw data and, after confirming that using both RepairNatrix and the preprocessing approach described by the authors, the data could be successfully decoded using a random selection of 750 000 reads, we reduced the input data to 700 000 randomly selected sequencing reads and preprocessed the reads with both strategies, followed by decoding the preprocessed data using DNA-Fountain. Using the approach described in the DNA-Fountain publication, 123 326 sequences of length 152 nucleotides were left after preprocessing. The decoding reported success, but the MD5 hash of the encoded file did not match the MD5 hash of the input data, indicating a failure to decode the data correctly. An inspection of the output file indicated that it was corrupted. With RepairNatrix, 125 283 sequences of length 152 nucleotides were left after preprocessing. The decoding resulted in a file with the MD5 hash of the input data, as described in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref> of the DNA-Fountain publication. The decoded file was a gzip compressed tarball containing multiple files, including an image of the KolibriOS, a PDF of Shannon’s Mathematical Theory of Communication (<xref rid="vbad117-B22" ref-type="bibr">Shannon 1948</xref>), and a 3 pg video.</p>
  </sec>
  <sec>
    <title>4 Conclusion</title>
    <p>RepairNatrix is a Snakemake-based read-processing workflow that combines Natrix’s raw sequencing data processing capabilities with maximum likelihood reconstruction algorithms tailored to DNA data storage, the ability to extract payload data from a mixture of genomic sequences and payload sequences, and filtering of data with user-defined constraints. This combination allows easy and fast recovery of data stored in DNA, agnostic to the coding scheme used for translating binary data to DNA. The low-code configuration and setup of RepairNatrix allow users to easily restore the most likely sequences for DNA storage experiments from a pool of raw sequencing data. Besides in-vitro storage, RepairNatrix also supports <italic toggle="yes">in vivo</italic> storage, allowing users to blast against a database consisting of host-genome data to filter out biological sequences from encoded sequences and to assemble shotgun sequencing data into contigs. In addition, RepairNatrix processes Illumina and Oxford Nanopore data. Since RepairNatrix is written in the workflow management engine Snakemake, with all dependencies encapsulated in rule-specific Conda (<ext-link xlink:href="https://docs.conda.io/en/latest/" ext-link-type="uri">https://docs.conda.io/en/latest/</ext-link>) environments, results can easily be reproduced, allowing a comparison of different coding methods with the same preprocessing, including the same version for every tool used. All configuration entries are written in a single configuration file, making it easy to share and adjust. In its current version, RepairNatrix can be used with almost any code that requires some form of preprocessing of raw reads before decoding. Codes directly utilizing any form of majority voting during the decoding would most likely only benefit from the basic quality control, read assembly, dereplication and, possibly, from the filtering of constraint-violating sequences. An example of such a code is described in <xref rid="vbad117-B24" ref-type="bibr">Tabatabaei Yazdi <italic toggle="yes">et al.</italic> (2015)</xref>. However, such codes could integrate the maximum-likelihood repair into their workflow to profit from our approach. Additionally, the proposed method could be adapted for any code using non-canonical restrictions by implementing and adding these restrictions into the ruleset. For codes that generate sequences with a dependency between each other (e.g. a guaranteed minimal Hamming distance), a more sophisticated maximum-likelihood approach would have to be implemented taking all possible clusters into account. This would be possible using the RepairNatrix architecture, but it is currently not implemented.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>vbad117_Supplementary_Data</label>
      <media xlink:href="vbad117_supplementary_data.pdf"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>The authors thank Sandra Clemens for the contributions to the code base.</p>
  </ack>
  <sec>
    <title>Author contributions</title>
    <p>M.W. developed the workflow framework and the rules for quality control, assembly, dereplication, clustering, and BLAST. M.W. conducted the <italic toggle="yes">in silico</italic> comparisons. P.M.S. developed the maximum-likelihood repair algorithm and its associated rules. P.M.S. implemented and conducted the <italic toggle="yes">in silico</italic> error type analysis. B.F. and D.H. supervised the work and acquired funding. P.M.S. and M.W. wrote the initial manuscript, with support from B.F. and D.H. All authors contributed to the final manuscript.</p>
  </sec>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics Advances</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work is financially supported by the LOEWE program of the State of Hesse (Germany) in the MOSLA research cluster. The funding body did not influence any aspect of this work.</p>
  </sec>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>The source code of RepairNatrix is available at <ext-link xlink:href="https://github.com/umr-ds/RepairNatrix" ext-link-type="uri">https://github.com/umr-ds/RepairNatrix</ext-link>. The data underlying this article are available as supplementary data of the mentioned articles (<xref rid="vbad117-B27" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2023</xref> and <xref rid="vbad117-B7" ref-type="bibr">Erlich and Zielinski 2017</xref>).</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="vbad117-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>An</surname><given-names>R</given-names></string-name>, <string-name><surname>Jia</surname><given-names>Y</given-names></string-name>, <string-name><surname>Wan</surname><given-names>B</given-names></string-name></person-group><etal>et al</etal><article-title>Non-enzymatic depurination of nucleic acids: factors and mechanisms</article-title>. <source>PLoS One</source><year>2014</year>;<volume>9</volume>:<fpage>e115950</fpage>.<pub-id pub-id-type="pmid">25546310</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bee</surname><given-names>C</given-names></string-name>, <string-name><surname>Chen</surname><given-names>Y-J</given-names></string-name>, <string-name><surname>Queen</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Molecular-level similarity search brings computing to DNA data storage</article-title>. <source>Nat Commun</source><year>2021</year>;<volume>12</volume>:<fpage>4764</fpage>.<pub-id pub-id-type="pmid">34362913</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ceze</surname><given-names>L</given-names></string-name>, <string-name><surname>Nivala</surname><given-names>J</given-names></string-name>, <string-name><surname>Strauss</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>Molecular digital data storage using DNA</article-title>. <source>Nat Rev Genet</source><year>2019</year>;<volume>20</volume>:<fpage>456</fpage>–<lpage>66</lpage>.<pub-id pub-id-type="pmid">31068682</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cock</surname><given-names>PJA</given-names></string-name>, <string-name><surname>Fields</surname><given-names>CJ</given-names></string-name>, <string-name><surname>Goto</surname><given-names>N</given-names></string-name></person-group><etal>et al</etal><article-title>The sanger FASTQ file format for sequences with quality scores, and the solexa/illumina FASTQ variants</article-title>. <source>Nucleic Acids Res</source><year>2009</year>;<volume>38</volume>:<fpage>1767</fpage>–<lpage>71</lpage>.<pub-id pub-id-type="pmid">20015970</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B5">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>El-Shaikh</surname><given-names>A</given-names></string-name>, <string-name><surname>Seeger</surname><given-names>B.</given-names></string-name></person-group> DNAContainer: an object-based storage architecture on DNA. In: <italic toggle="yes">BTW 2023</italic>. Bonn: Gesellschaft für Informatik e.V., <year>2023</year>, <fpage>773</fpage>–<lpage>95</lpage>. doi: <pub-id pub-id-type="doi">10.18420/BTW2023-50</pub-id>.</mixed-citation>
    </ref>
    <ref id="vbad117-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>El-Shaikh</surname><given-names>A</given-names></string-name>, <string-name><surname>Welzel</surname><given-names>M</given-names></string-name>, <string-name><surname>Heider</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>High-scale random access on DNA storage systems</article-title>. <source>NAR Genom Bioinform</source><year>2022</year>;<volume>4</volume>:<fpage>lqab126</fpage>.<pub-id pub-id-type="pmid">35156022</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Erlich</surname><given-names>Y</given-names></string-name>, <string-name><surname>Zielinski</surname><given-names>D.</given-names></string-name></person-group><article-title>DNA fountain enables a robust and efficient storage architecture</article-title>. <source>Science</source><year>2017</year>;<volume>355</volume>:<fpage>950</fpage>–<lpage>4</lpage>.<pub-id pub-id-type="pmid">28254941</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Estaki</surname><given-names>M</given-names></string-name>, <string-name><surname>Jiang</surname><given-names>L</given-names></string-name>, <string-name><surname>Bokulich</surname><given-names>NA</given-names></string-name></person-group><etal>et al</etal><article-title>QIIME 2 enables comprehensive end-to-end analysis of diverse microbiome data and comparative studies with publicly available data</article-title>. <source>Curr Protoc Bioinformatics</source><year>2020</year>;<volume>70</volume>:<fpage>e100</fpage>.<pub-id pub-id-type="pmid">32343490</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ezekannagha</surname><given-names>C</given-names></string-name>, <string-name><surname>Welzel</surname><given-names>M</given-names></string-name>, <string-name><surname>Heider</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>DNAsmart: multiple attribute ranking tool for DNA data storage systems</article-title>. <source>Comput Struct Biotechnol J</source><year>2023</year>;<volume>21</volume>:<fpage>1448</fpage>–<lpage>60</lpage>.<pub-id pub-id-type="pmid">36851917</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Grass</surname><given-names>RN</given-names></string-name>, <string-name><surname>Heckel</surname><given-names>R</given-names></string-name>, <string-name><surname>Puddu</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Robust chemical preservation of digital information on DNA in silica with error-correcting codes</article-title>. <source>Angew Chem Int Ed Engl</source><year>2015</year>;<volume>54</volume>:<fpage>2552</fpage>–<lpage>5</lpage>.<pub-id pub-id-type="pmid">25650567</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kosuri</surname><given-names>S</given-names></string-name>, <string-name><surname>Church</surname><given-names>GM.</given-names></string-name></person-group><article-title>Large-scale de novo DNA synthesis: technologies and applications</article-title>. <source>Nat Methods</source><year>2014</year>;<volume>11</volume>:<fpage>499</fpage>–<lpage>507</lpage>.<pub-id pub-id-type="pmid">24781323</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Köster</surname><given-names>J</given-names></string-name>, <string-name><surname>Rahmann</surname><given-names>S.</given-names></string-name></person-group><article-title>Snakemake—a scalable bioinformatics workflow engine</article-title>. <source>Bioinformatics</source><year>2012</year>;<volume>28</volume>:<fpage>2520</fpage>–<lpage>2</lpage>.<pub-id pub-id-type="pmid">22908215</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Löchel</surname><given-names>HF</given-names></string-name>, <string-name><surname>Welzel</surname><given-names>M</given-names></string-name>, <string-name><surname>Hattab</surname><given-names>G</given-names></string-name></person-group><etal>et al</etal><article-title>Fractal construction of constrained code words for DNA storage systems</article-title>. <source>Nucleic Acids Res</source><year>2021</year>;<volume>50</volume>:<fpage>e30</fpage>.</mixed-citation>
    </ref>
    <ref id="vbad117-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Masella</surname><given-names>AP</given-names></string-name>, <string-name><surname>Bartram</surname><given-names>AK</given-names></string-name>, <string-name><surname>Truszkowski</surname><given-names>JM</given-names></string-name></person-group><etal>et al</etal><article-title>PANDAseq: paired-end assembler for illumina sequences</article-title>. <source>BMC Bioinformatics</source><year>2012</year>;<volume>13</volume>:<fpage>31</fpage>.<pub-id pub-id-type="pmid">22333067</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B15">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Pic</surname><given-names>X</given-names></string-name>, <string-name><surname>Antonio</surname><given-names>EGS</given-names></string-name>, <string-name><surname>Dimopoulou</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal> Rotating labeling of entropy coders for synthetic DNA data storage. In: <italic toggle="yes">2023 24th International Conference on Digital Signal Processing (DSP), Rhodes (Rodos), Greece</italic>, 2023, 1–5. doi: <pub-id pub-id-type="doi">10.1109/DSP58604.2023.10167907</pub-id>.</mixed-citation>
    </ref>
    <ref id="vbad117-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Press</surname><given-names>WH</given-names></string-name>, <string-name><surname>Hawkins</surname><given-names>JA</given-names></string-name>, <string-name><surname>Jones</surname><given-names>SK</given-names></string-name></person-group><etal>et al</etal><article-title>HEDGES error-correcting code for DNA storage corrects indels and allows sequence constraints</article-title>. <source>Proc Natl Acad Sci USA</source><year>2020</year>;<volume>117</volume>:<fpage>18489</fpage>–<lpage>96</lpage>.<pub-id pub-id-type="pmid">32675237</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Prjibelski</surname><given-names>A</given-names></string-name>, <string-name><surname>Antipov</surname><given-names>D</given-names></string-name>, <string-name><surname>Meleshko</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>Using SPAdes de novo assembler</article-title>. <source>Curr Protoc Bioinformatics</source><year>2020</year>;<volume>70</volume>:<fpage>e102</fpage>.<pub-id pub-id-type="pmid">32559359</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rognes</surname><given-names>T</given-names></string-name>, <string-name><surname>Flouri</surname><given-names>T</given-names></string-name>, <string-name><surname>Nichols</surname><given-names>B</given-names></string-name></person-group><etal>et al</etal><article-title>Vsearch: a versatile open source tool for metagenomics</article-title>. <source>PeerJ</source><year>2016</year>;<volume>4</volume>:<fpage>e2584</fpage>.<pub-id pub-id-type="pmid">27781170</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Schmieder</surname><given-names>R</given-names></string-name>, <string-name><surname>Edwards</surname><given-names>R.</given-names></string-name></person-group><article-title>Quality control and preprocessing of metagenomic datasets</article-title>. <source>Bioinformatics</source><year>2011</year>;<volume>27</volume>:<fpage>863</fpage>–<lpage>4</lpage>.<pub-id pub-id-type="pmid">21278185</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Schwarz</surname><given-names>M</given-names></string-name>, <string-name><surname>Welzel</surname><given-names>M</given-names></string-name>, <string-name><surname>Kabdullayeva</surname><given-names>T</given-names></string-name></person-group><etal>et al</etal><article-title>MESA: automated assessment of synthetic DNA fragments and simulation of DNA synthesis, storage, sequencing and PCR errors</article-title>. <source>Bioinformatics</source><year>2020</year>;<volume>36</volume>:<fpage>3322</fpage>–<lpage>6</lpage>.<pub-id pub-id-type="pmid">32129840</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Schwarz</surname><given-names>PM</given-names></string-name>, <string-name><surname>Freisleben</surname><given-names>B.</given-names></string-name></person-group><article-title>NOREC4DNA: near-optimal rateless erasure codes for DNA storage</article-title>. <source>BMC Bioinformatics</source><year>2021</year>;<volume>22</volume>:<fpage>406</fpage>.<pub-id pub-id-type="pmid">34404355</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Shannon</surname><given-names>CE.</given-names></string-name></person-group><article-title>A mathematical theory of communication</article-title>. <source>Bell Syst Tech J</source><year>1948</year>;<volume>27</volume>:<fpage>379</fpage>–<lpage>423</lpage>.</mixed-citation>
    </ref>
    <ref id="vbad117-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sieber</surname><given-names>G</given-names></string-name>, <string-name><surname>Beisser</surname><given-names>D</given-names></string-name>, <string-name><surname>Rothenberger</surname><given-names>JL</given-names></string-name></person-group><etal>et al</etal><article-title>Microbial community shifts induced by plastic and zinc as substitutes of tire abrasion</article-title>. <source>Sci Rep</source><year>2022</year>;<volume>12</volume>:<fpage>18684</fpage>.<pub-id pub-id-type="pmid">36333419</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yazdi</surname><given-names>SMHT</given-names></string-name>, <string-name><surname>Yuan</surname><given-names>Y</given-names></string-name>, <string-name><surname>Ma</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>A rewritable, random-access DNA-based storage system</article-title>. <source>Sci Rep</source><year>2015</year>;<volume>5</volume>:<fpage>14138</fpage>.<pub-id pub-id-type="pmid">26382652</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Takahashi</surname><given-names>CN</given-names></string-name>, <string-name><surname>Nguyen</surname><given-names>BH</given-names></string-name>, <string-name><surname>Strauss</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>Demonstration of end-to-end automation of DNA data storage</article-title>. <source>Sci Rep</source><year>2019</year>;<volume>9</volume>:<fpage>4998</fpage>.<pub-id pub-id-type="pmid">30899031</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Welzel</surname><given-names>M</given-names></string-name>, <string-name><surname>Lange</surname><given-names>A</given-names></string-name>, <string-name><surname>Heider</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>Natrix: a snakemake-based workflow for processing, clustering, and taxonomically assigning amplicon sequencing reads</article-title>. <source>BMC Bioinformatics</source><year>2020</year>;<volume>21</volume>:<fpage>526</fpage>.<pub-id pub-id-type="pmid">33198651</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Welzel</surname><given-names>M</given-names></string-name>, <string-name><surname>Schwarz</surname><given-names>PM</given-names></string-name>, <string-name><surname>Löchel</surname><given-names>HF</given-names></string-name></person-group><etal>et al</etal><article-title>DNA-Aeon provides flexible arithmetic coding for constraint adherence and error correction in DNA storage</article-title>. <source>Nat Commun</source><year>2023</year>;<volume>14</volume>:<fpage>628</fpage>.<pub-id pub-id-type="pmid">36746948</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinform Adv</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinform Adv</journal-id>
    <journal-id journal-id-type="publisher-id">bioadv</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics Advances</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2635-0041</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10941317</article-id>
    <article-id pub-id-type="doi">10.1093/bioadv/vbad117</article-id>
    <article-id pub-id-type="publisher-id">vbad117</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Application Note</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>RepairNatrix: a Snakemake workflow for processing DNA sequencing data for DNA storage</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8763-1507</contrib-id>
        <name>
          <surname>Schwarz</surname>
          <given-names>Peter Michael</given-names>
        </name>
        <aff><institution>Department of Mathematics and Computer Science, University of Marburg</institution>, Marburg 35032, <country country="DE">Germany</country></aff>
        <xref rid="vbad117-cor1" ref-type="corresp"/>
        <!--schwarzk@uni-marburg.de-->
        <xref rid="vbad117-FM1" ref-type="author-notes"/>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-4946-2156</contrib-id>
        <name>
          <surname>Welzel</surname>
          <given-names>Marius</given-names>
        </name>
        <aff><institution>Department of Mathematics and Computer Science, University of Marburg</institution>, Marburg 35032, <country country="DE">Germany</country></aff>
        <xref rid="vbad117-FM1" ref-type="author-notes"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Heider</surname>
          <given-names>Dominik</given-names>
        </name>
        <aff><institution>Department of Mathematics and Computer Science, University of Marburg</institution>, Marburg 35032, <country country="DE">Germany</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Freisleben</surname>
          <given-names>Bernd</given-names>
        </name>
        <aff><institution>Department of Mathematics and Computer Science, University of Marburg</institution>, Marburg 35032, <country country="DE">Germany</country></aff>
        <xref rid="vbad117-cor1" ref-type="corresp"/>
        <!--freisleben@uni-marburg.de-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Fraternali</surname>
          <given-names>Franca</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="vbad117-cor1">Corresponding authors. Department of Mathematics and Computer Science, University of Marburg, Marburg 35032, Germany. E-mail: <email>schwarzk@uni-marburg.de</email> (P.M.S.) and <email>freisleben@uni-marburg.de</email> (B.F.)</corresp>
      <fn id="vbad117-FM1">
        <p>Peter Michael Schwarz and Marius Welzel contributed equally to this work.</p>
      </fn>
    </author-notes>
    <pub-date pub-type="collection">
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-08-26">
      <day>26</day>
      <month>8</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>26</day>
      <month>8</month>
      <year>2023</year>
    </pub-date>
    <volume>3</volume>
    <issue>1</issue>
    <elocation-id>vbad117</elocation-id>
    <history>
      <date date-type="received">
        <day>03</day>
        <month>5</month>
        <year>2023</year>
      </date>
      <date date-type="rev-recd">
        <day>17</day>
        <month>8</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>18</day>
        <month>8</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>24</day>
        <month>8</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>31</day>
        <month>8</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="vbad117.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>There has been rapid progress in the development of error-correcting and constrained codes for DNA storage systems in recent years. However, improving the steps for processing raw sequencing data for DNA storage has a lot of untapped potential for further progress. In particular, constraints can be used as prior information to improve the processing of DNA sequencing data. Furthermore, a workflow tailored to DNA storage codes enables fair comparisons between different approaches while leading to reproducible results.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We present RepairNatrix, a read-processing workflow for DNA storage. RepairNatrix supports preprocessing of raw sequencing data for DNA storage applications and can be used to flag and heuristically repair constraint-violating sequences to further increase the recoverability of encoded data in the presence of errors. Compared to a preprocessing strategy without repair functionality, RepairNatrix reduced the number of raw reads required for the successful, error-free decoding of the input files by a factor of 25–35 across different datasets.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>RepairNatrix is available on Github: <ext-link xlink:href="https://github.com/umr-ds/repairnatrix" ext-link-type="uri">https://github.com/umr-ds/repairnatrix</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>LOEWE program of the State of Hesse</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="7"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>In recent years, using DNA as a storage device has drawn increased attention from academia and industry (<xref rid="vbad117-B25" ref-type="bibr">Takahashi <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="vbad117-B16" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>, <xref rid="vbad117-B2" ref-type="bibr">Bee <italic toggle="yes">et al.</italic> 2021</xref>, <xref rid="vbad117-B13" ref-type="bibr">Löchel <italic toggle="yes">et al.</italic> 2021</xref>, <xref rid="vbad117-B21" ref-type="bibr">Schwarz and Freisleben 2021</xref>, <xref rid="vbad117-B6" ref-type="bibr">El-Shaikh <italic toggle="yes">et al.</italic> 2022</xref>, <xref rid="vbad117-B5" ref-type="bibr">El-Shaikh and Seeger 2023</xref>, <xref rid="vbad117-B9" ref-type="bibr">Ezekannagha <italic toggle="yes">et al.</italic> 2023</xref>, <xref rid="vbad117-B15" ref-type="bibr">Pic <italic toggle="yes">et al.</italic> 2023</xref>, <xref rid="vbad117-B27" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2023</xref>). DNA is an attractive alternative to traditional storage devices, due to its large storage density of up to <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mn>18</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mi mathvariant="italic">bytes</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:math></inline-formula>, long life expectancy, and low energy requirements for storage (<xref rid="vbad117-B3" ref-type="bibr">Ceze <italic toggle="yes">et al.</italic> 2019</xref>). To store digital data in DNA, the data must be converted into the quaternary DNA alphabet, consisting of the nucleotides Adenine (A), Guanine (G), Cytosine (C), and Thymine (T). Instead of simply assigning each two-bit pair to one of the four bases, it is common to use more sophisticated codes to translate binary data to DNA and add redundancy for error correction. To generate DNA that satisfies desired constraints, such codes often restrict the output codewords to a subset of all possible base combinations of a given length. Common constraints (<xref rid="vbad117-B20" ref-type="bibr">Schwarz <italic toggle="yes">et al.</italic> 2020</xref>) are: (i) Guanine–Cytosine (GC) content of 40%–60%, and no large subsequences that deviate from this range, (ii) limited length of homopolymers (a repetition of the same base), and (iii) no occurrence of specific motifs (short subsequences of a specific pattern), e.g. restriction recognition sites used to cut DNA fragments during synthesis. Furthermore, the codes split the input data into shorter fragments to decrease synthesis costs and ease subsequent sequencing. DNA oligonucleotides (oligos) with the base composition of the generated codewords are generated during synthesis. The chemical synthesis methods often generate only short oligos of 100 nucleotides (nt). If the generated codewords are longer than these limitations, multiple shorter oligos are hybridized using various methods (<xref rid="vbad117-B11" ref-type="bibr">Kosuri and Church 2014</xref>).</p>
    <p>Several approaches exist to store the synthesized DNA, e.g. in microwell plates and in lower temperatures to further reduce the probability of depurination (<xref rid="vbad117-B1" ref-type="bibr">An <italic toggle="yes">et al.</italic> 2014</xref>). Alternative storage methods described in the literature are, for example, storing DNA in silicone gel (<xref rid="vbad117-B10" ref-type="bibr">Grass <italic toggle="yes">et al.</italic> 2015</xref>) or integrating the information carrying DNA into living cells, i.e. <italic toggle="yes">in vivo</italic> storage. DNA sequencing methods are used to digitize the DNA again; the Illumina sequencing-by-synthesis approach is commonly used for this purpose. The Illumina approach generates many short reads of up to 150 bp. With paired-end reads, this can increase to 300 bp.</p>
    <p>The sequencers generate FASTQ files that contain multiple reads and, for each read, a sequence identifier, the read itself, and a quality score for each base. The quality score, or PHRED score, is encoded as a single ASCII letter. It is related to the probability that a base was called wrongly: <italic toggle="yes">Q</italic> = −10log<sub>10</sub><italic toggle="yes">P</italic>, where <italic toggle="yes">Q</italic> is the quality score and <italic toggle="yes">P</italic> is the probability that the base was called wrongly by the sequencer. For each sample, either one (single-end) or two (paired-end) FASTQ files are generated. In the paired-end approach, where a single sequence is read from both directions, each forward and reverse read has to be merged to get the full-length read. The resulting FASTQ files consist of different sequences, with multiple reads per unique parent sequence in varying qualities, including sequences with a low quality that are likely wrong. The FASTQ files need extensive processing before the input data can be decoded.</p>
    <p>There are several workflows that process raw sequencing data, but no general workflow exists to process sequencing data for DNA data storage. Typically, a custom script (<xref rid="vbad117-B7" ref-type="bibr">Erlich and Zielinski 2017</xref>) or a customized version of a workflow designed for biological data (<xref rid="vbad117-B27" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2023</xref>) is used. We present RepairNatrix, a workflow for processing DNA sequencing data designed for DNA storage. RepairNatrix uses the Snakemake workflow management engine (<xref rid="vbad117-B12" ref-type="bibr">Köster and Rahmann 2012</xref>) to encapsulate each workflow step into self-contained rules with automatic dependency deployment and allows seamless scaling to different computing environments. RepairNatrix contains rules for quality filtering, primer removal, forward- and reverse-read merging, de-replication, optional rules for similarity clustering, assembly of <italic toggle="yes">in vivo</italic> data, and filtering according to sequence constraints. RepairNatrix can repair erroneous sequences using a maximum-likelihood repair algorithm. It leverages knowledge of sequence constraints to infer the most likely originating sequence from an erroneous one. Compared to a preprocessing strategy without repair functionality, RepairNatrix reduced the number of raw reads required for the successful, error-free decoding of the input files by a factor of 25–35 across different datasets. We also show how the sequence design limitations of DNA storage can be used as additional information during the reconstruction of oligonucleotides, thereby improving decodability.</p>
  </sec>
  <sec>
    <title>2 Approach</title>
    <p>DNA sequencing workflows such as QIIME 2 (<xref rid="vbad117-B8" ref-type="bibr">Estaki <italic toggle="yes">et al.</italic> 2020</xref>) or Natrix (<xref rid="vbad117-B27" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2023</xref>) are designed for processing environmental samples, with the goal of clustering and taxonomically assigning corresponding sequencing reads. Since there are various restrictions during <italic toggle="yes">de novo</italic> synthesis, storage, and sequencing for DNA storage, these sequencing workflows are not optimized for this use case.</p>
    <p>The status quo for en- and decoding in DNA storage is to treat these restrictions as limitations of the medium, and thus create codes that simply adhere to these rules. Our approach is to use the limitations and restrictions as additional information. From an information theory point of view, the presence or absence of rule violations contains information that can and should be used to retrieve the original data. Using this prior knowledge, we present a DNA processing workflow dedicated to different kinds of DNA data storage, and we provide a code-independent repair approach.</p>
    <sec>
      <title>2.1 FASTQ files</title>
      <p>The primary input of RepairNatrix is (one or multiple) FASTQ files. FASTQ is used as an output format of several sequencing technologies, such as Illumina and Oxford Nanopore sequencing machines. Typically, a FASTQ file consists of multiple entries. Each entry consists of a header line that contains the sequence ID and a description, one line of the sequence itself (the read of the sequencing machine), a line consisting of a plus symbol, and a line containing the PHRED quality information of the read. It is a single ASCII encoded value for each base in a sequence, representing the probability that the base was called wrongly by the sequencer. The PHRED quality score can be calculated from the probability of a wrongly called base (<inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>) as follows (<xref rid="vbad117-B4" ref-type="bibr">Cock <italic toggle="yes">et al.</italic> 2009</xref>): <italic toggle="yes">Q</italic><sub>PHRED</sub> = −10 × log<sub>10</sub>(<inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>) It is common to generate a single FASTQ file per sample (<xref rid="vbad117-B23" ref-type="bibr">Sieber <italic toggle="yes">et al.</italic> 2022</xref>). This approach can be utilized for DNA data storage by sequencing single or closely related files. Alternatively, several different files can be sequenced in a single sample and subsequently sorted according to a short identifier added to the sequences. This process is known as demultiplexing.</p>
    </sec>
    <sec>
      <title>2.2 Primer table</title>
      <p>Before sequencing, samples are often amplified using polymerase chain reaction (PCR), a fast and cost-efficient approach to duplicate DNA. The PCR process requires the addition of short subsequences (primers) to the amplification target. To remove these primer sequences, together with other additional subsequences that are not part of the encoded data (like barcodes that identify sequences belonging to the same file or poly-N spacers), RepairNatrix uses a primer table that contains the additional subsequences that are present in each FASTQ file, both for the forward reads and (optionally) for the reverse read. The subsequences can also be removed using a length parameter, removing the first <italic toggle="yes">n</italic> bases of each read. An example primer table is shown in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>.</p>
    </sec>
    <sec>
      <title>2.3 Configuration file</title>
      <p>A configuration file is also required. It contains the parameters for each workflow step. Using a single configuration file supports automated processing of several files in parallel, while allowing users to adjust RepairNatrix to their requirements and experimental conditions. An example of a configuration file is provided in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>.</p>
    </sec>
    <sec>
      <title>2.4 Demultiplexing and initial read filtering</title>
      <p>As an optional first step of the workflow, the input can be demultiplexed by sorting all reads according to their barcode specified in the primer table. The raw data are then filtered using PRINSEQ (<xref rid="vbad117-B19" ref-type="bibr">Schmieder and Edwards, 2011</xref>). The filtering process removes all reads with a lower mean PHRED quality score than a user-defined threshold.</p>
    </sec>
    <sec>
      <title>2.5 Sequence removal, read merging, and de-replication</title>
      <p>If additional subsequences from the biochemical processing are still present in the data, they must be removed before further processing. RepairNatrix supports the removal of barcode and primer sequences either by the base composition of the subsequences or by length. The merging of forward- and reverse-reads, which is required for paired-end Illumina data, together with removing additional subsequences, is carried out by PANDAseq (<xref rid="vbad117-B14" ref-type="bibr">Masella <italic toggle="yes">et al.</italic> 2012</xref>). Then, the sequences are de-replicated, i.e. identical sequences are replaced by a single representation containing the abundance information in the header of the read data.</p>
    </sec>
    <sec>
      <title>2.6 Similarity clustering</title>
      <p>RepairNatrix supports optional clustering of sequences by a similarity threshold, using VSEARCH (<xref rid="vbad117-B18" ref-type="bibr">Rognes <italic toggle="yes">et al.</italic> 2016</xref>) and a user-defined similarity threshold. For clustering, the sequences are sorted by frequency, with the most common sequence first, or by quality, with the sequence with the highest mean PHRED quality score first. In each iteration of the clustering, the first sequence is removed from the pool of remaining sequences and used as a new cluster’s representative sequence. Each sequence in the pool with a higher similarity than the user-defined threshold (with a default value of 97%) to the representative of the current cluster is added to this cluster and removed from the pool of available sequences. This approach is commonly used to generate operational taxonomic units in microbiome analysis (<xref rid="vbad117-B26" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2020</xref>). Here, it serves to merge sequences that differ slightly, using the sequence with either the highest quality (i.e. the sequence with the highest confidence of the sequencer) or the most common sequence as the most likely correct sequence. The similarity threshold should be adjusted to reflect the minimal Hamming distance of two encoded sequences with the used error-correcting code.</p>
    </sec>
    <sec>
      <title>2.7 Filtering constraint-violating sequences</title>
      <p>RepairNatrix can (optionally) remove sequences that violate user-defined constraints, which is carried out after merging forward- and reverse-reads. Since many DNA storage codes can not only add redundancy to the input for error correction purposes but can also generate outputs that adhere to specific constraints, reads that contain subsequences that could not be generated by the codes can, optionally, be filtered out from further processing. Removing these reads can lead to an increase in error correction performance, especially if, for example, early during PCR amplification an error occurred that led to the formation of an erroneous subsequence, like a long homopolymer. This could lead to the wrong sequence being designated as the representative sequence of the cluster. With the erroneous reads filtered out, less potential errors to be corrected by the error correcting code remain, increasing the probability of successful decoding. Since repairing the sequences requires prior similarity clustering, filtering allows users to remove erroneous sequences, even if users do not want the data to be clustered or repaired. This feature will ensure that all processed sequences adhere to the restrictions defined by a user, but it is not possible to use the repair features afterwards. Filtering is divided into two main modes. In the first mode, it can operate as an input filter, removing constraint-violating sequences. This approach ensures that the downstream decoding receives only valid sequences according to the coding restrictions. While this approach does not introduce any additional incorrect sequences and thus cannot reduce the dataset’s quality, some coding schemes might be able to reconstruct the correct data from sequences that violate the restrictions. For these codes, removing these sequences could lower the number of unique sequences in the dataset and thus prevent successful decoding. To accommodate this scenario, RepairNatrix can be used in a second mode to sort the sequences regarding compliance with the rules. In this mode, a weight is applied to each rule violation, together with the (mean) quality score for each (clustered) sequence. Thus, decoding algorithms for coding schemes with unordered encoded data (such as fountain codes) will successfully reconstruct the encoded file before reading low-quality and rule-violating sequences with a higher probability.</p>
    </sec>
    <sec>
      <title>2.8 Maximum-likelihood repair</title>
      <p>One of the key features of RepairNatrix is its ability to perform a maximum-likelihood repair of constraint-violating sequences. The repair functionality requires user-defined constraints that the encoded sequences must adhere to. Such constraints are: (i) global and per-window GC-content, (ii) maximum allowed homopolymer length, (iii) k-mer length, (iv) undesired subsequences, and (v) length of the sequence.</p>
      <p>RepairNatrix comes with pre-defined rules, but its Snakemake-based design allows users to add additional rules. The pre-defined rules can be adjusted by modifying the .yaml file of the project. In contrast, custom rules require modifying the calc_errors function to include user-created functions in the detection and repair process. Such user-defined rules could include support for functions like checksums, unique constraints, or secondary structure predictions. This flexibility allows RepairNatrix to improve the recovery rate for all constraint-satisfying coding schemes.</p>
      <p>The maximum-likelihood repair algorithm of RepairNatrix replaces the base with the highest likelihood of an error by the base, which would minimize the overall error prediction of the current sequence. Depending on the number of rules and mutations, this can be a heuristic approach, but it is very unlikely that the final output will be worse than without maximum-likelihood repair. Users can opt to keep the constraint-violating sequence in the set of all sequences. At the same time, the modified sequence will also be flagged with additional information about the number of changes performed to this sequence.</p>
      <p>As shown in <xref rid="vbad117-F1" ref-type="fig">Fig. 1</xref>, the repair algorithm performs a series of operations on each cluster. First, each centroid of a cluster will be checked against the defined rules. If the sequence adheres to the rules, the centroid will be treated as correct and tagged accordingly. Otherwise, each element in the cluster will be analyzed regarding the user-defined rules (sorted by their edit distance to the centroid). If such a sequence exists, it replaces the current centroid and will be tagged accordingly. If no such sequence exists in the current cluster, the algorithm tries to perform maximum-likelihood repair on the sequences in the cluster (sorted by their edit distances to the centroid). For this purpose, the algorithm applies all user-defined rules to create an error metric for each base in the sequence, then it modifies the base with the highest error metric to minimize the overall error of the sequence, as well as the error metric of the chosen base. This process might continue for up to <italic toggle="yes">n</italic> bases, where <italic toggle="yes">n</italic> is a user-defined threshold after which a sequence will be treated as not recoverable. By default, this algorithm will perform such a repair for all sequences in a cluster, filter out all sequences for which the repair failed, and return the sequence with the lowest number of changes introduced during the repair.</p>
      <fig position="float" id="vbad117-F1">
        <label>Figure 1.</label>
        <caption>
          <p>Top: Overview of the RepairNatrix main sequence processing modules. Nodes with dashed borders are optional. Dark nodes represent raw sequence processing steps, light grey nodes are related to the constraint-based output improvements, and white nodes are <italic toggle="yes">in vivo</italic> specific. Bottom: Workflow for sequence selection/repair for each cluster.</p>
        </caption>
        <graphic xlink:href="vbad117f1" position="float"/>
      </fig>
      <p><xref rid="vbad117-F2" ref-type="fig">Fig. 2</xref> and <xref rid="vbad117-F3" ref-type="fig">3</xref> show a simplified example of possible repairable sequences. For these sequences, we assume an overall and windowed (per 15 bases) GC content of [40, 60], a maximum allowed homopolymer length of 3, as well as a fixed sequence length of 30.
</p>
      <fig position="float" id="vbad117-F2">
        <label>Figure 2.</label>
        <caption>
          <p>A sequence with a homopolymer of length 5, no GC content violations, and a sequence length of 32. The algorithm correctly flags all positions with a homopolymer and detects that the length of the sequence is longer than allowed. The corrected sequence has neither a homopolymer longer than 3, and the sequence length is 30.</p>
        </caption>
        <graphic xlink:href="vbad117f2" position="float"/>
      </fig>
      <fig position="float" id="vbad117-F3">
        <label>Figure 3.</label>
        <caption>
          <p>A sequence with an invalid homopolymer running between two GC windows. The maximum likelihood repair iterates over the homopolymer from the last to the first position to find a suitable repair path. While substituting the last <italic toggle="yes">C</italic> with <italic toggle="yes">A</italic> or <italic toggle="yes">T</italic> would violate the windowed GC content constraint, a substitution with <italic toggle="yes">G</italic> yields a valid solution.</p>
        </caption>
        <graphic xlink:href="vbad117f3" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>2.9 <italic toggle="yes">In vivo</italic> filtering and assembly</title>
      <p>To process data stored <italic toggle="yes">in vivo</italic>, RepairNatrix offers filtering by user-provided genomic data. For <italic toggle="yes">in vivo</italic> data storage, the raw reads typically contain a mixture of payload data and genomic data from the host, or data from the used vector. If the payload data are not extracted from the mixture of reads, the decoding could fail, even in the presence of a sufficiently large number of raw payload reads. With a provided database consisting of the genome of the host organism, RepairNatrix uses the basic local alignment tool (BLAST) to separate the input data into two files: one containing reads that are likely part of the host genome and do not contain stored data, and a second one containing the reads that either did not match any target of the database or only match with low confidence (i.e. a high <italic toggle="yes">E</italic>-value), which are likely sequences belonging to the encoded data. To support shotgun-style sequencing, in which the genome is cloned and randomly fragmented, RepairNatrix uses SPAdes (<xref rid="vbad117-B17" ref-type="bibr">Prjibelski <italic toggle="yes">et al.</italic> 2020</xref>) to assemble fragments to larger contigs, combined with knowledge regarding the length of the encoded data sequences, or if short spacer sequences are used to identify the start and end of encoded data. This approach supports the reconstruction of the encoded sequences from sequencing data consisting of a mixture of the encoded data fragments and other sequences (e.g. host genomic data or artificial chromosomes).</p>
    </sec>
  </sec>
  <sec>
    <title>3 Evaluation</title>
    <p>We evaluated RepairNatrix’s ability to improve sequence processing output for DNA storage using the data and evaluation metrics published by (<xref rid="vbad117-B27" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2023</xref>).</p>
    <p>The complete results are shown in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>. The evaluation was carried out for a mean quality threshold of 10 and a PANDAseq quality score of 0.3. This combination led to the lowest required number of sequences in the results published previously (<xref rid="vbad117-B27" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2023</xref>). Using RepairNatrix, the number of raw reads needed for the successful, error-free decoding of the input files was between 25 (Dornröschen, CRC interval 2 and 3) and 35 (Dornröschen, CRC interval 5) times lower using the repair and cluster representative choosing algorithms of RepairNatrix than without, as shown in <xref rid="vbad117-F4" ref-type="fig">Fig. 4</xref>.</p>
    <fig position="float" id="vbad117-F4">
      <label>Figure 4.</label>
      <caption>
        <p>The minimal number of raw reads required for successful decoding before processing. The numbers after the dataset names describe the CRC interval parameter used for the encoding.</p>
      </caption>
      <graphic xlink:href="vbad117f4" position="float"/>
    </fig>
    <p>The lowest number of sequences after processing that were required for successful decoding were 77%–89% of the encoded sequences before synthesis, as shown in <xref rid="vbad117-F5" ref-type="fig">Fig. 5</xref>. This implies that most of the sequences left after processing were descendants of unique encoded sequences and not just erroneous variants of the same encoded sequence. The results shown in <xref rid="vbad117-F4" ref-type="fig">Figs 4</xref> and <xref rid="vbad117-F5" ref-type="fig">5</xref> demonstrate that incorporating prior constraints into the preprocessing leads to successful decoding with either fewer raw reads or reads that contain a higher percentage of erroneous sequences.</p>
    <fig position="float" id="vbad117-F5">
      <label>Figure 5.</label>
      <caption>
        <p>The minimal amount of sequences left for successful decoding after processing. The numbers after the dataset names describe the CRC interval parameter used for the encoding.</p>
      </caption>
      <graphic xlink:href="vbad117f5" position="float"/>
    </fig>
    <p>To analyze the behavior of the proposed method, we compared the resulting sequence categories. For the <italic toggle="yes">in vitro</italic> experiments using 247 and 429 chunks, the coverage was reduced to the corresponding percentage (e.g. 0.003%, 10% of the raw sequenced reads). For the Dorn_RU10 in-silico experiment, a more restrictive ruleset was enforced during creation of the 184 nt long sequences. This included limiting the maximum allowed homopolymer count to 3, blacklisting 57 sequences from 6 nt to up to 35 nt, as well as enforcing a global and windowed GC content between 40% and 60%. <xref rid="vbad117-F6" ref-type="fig">Figure 6</xref> shows the number of sequences for each output category per experiment. For the more restrictive <italic toggle="yes">in silico</italic> experiment, for which we also introduced a higher number of indel errors and substitution errors using the MESA simulator (<xref rid="vbad117-B20" ref-type="bibr">Schwarz <italic toggle="yes">et al.</italic> 2020</xref>), the number of repaired or substituted sequences significantly increases. Information about the repaired sequences, the affected cluster, and their difference will be stored in a json file for each processed file.</p>
    <fig position="float" id="vbad117-F6">
      <label>Figure 6.</label>
      <caption>
        <p>The distribution of each sequence category for different experiments. For low overhead (01), only a fraction of all sequences violate the constraints. For four clusters, a rule abiding substitute could be found.</p>
      </caption>
      <graphic xlink:href="vbad117f6" position="float"/>
    </fig>
    <p><xref rid="vbad117-F7" ref-type="fig">Figure 7</xref> shows the found and corrected rule violations for the parsed sequences. Besides the shown rules, no violation toward undesired sequences was found. While this is mainly due to the small list of undesired subsequences (5 sequences between 19 and 35 nt each), the absence of homopolymer errors can be explained by the (mostly) error-free synthesis, short storage duration, and robust sequencing technology used. Therefore, most errors detected were based on a constraint-violating (windowed) GC content as well as a non-matching sequence length.</p>
    <fig position="float" id="vbad117-F7">
      <label>Figure 7.</label>
      <caption>
        <p>Different constraint violations for the <italic toggle="yes">in vitro</italic> experiment (Sleeping Beauty) reduced to 10% of its original coverage.</p>
      </caption>
      <graphic xlink:href="vbad117f7" position="float"/>
    </fig>
    <p>To further evaluate the effectiveness of RepairNatrix, we compared using it for raw sequence file preprocessing with the preprocessing method described in the DNA-Fountain publication, where the authors were able to successfully decode data using a random selection of 750 000 raw Illumina sequencing reads. We downloaded the raw data and, after confirming that using both RepairNatrix and the preprocessing approach described by the authors, the data could be successfully decoded using a random selection of 750 000 reads, we reduced the input data to 700 000 randomly selected sequencing reads and preprocessed the reads with both strategies, followed by decoding the preprocessed data using DNA-Fountain. Using the approach described in the DNA-Fountain publication, 123 326 sequences of length 152 nucleotides were left after preprocessing. The decoding reported success, but the MD5 hash of the encoded file did not match the MD5 hash of the input data, indicating a failure to decode the data correctly. An inspection of the output file indicated that it was corrupted. With RepairNatrix, 125 283 sequences of length 152 nucleotides were left after preprocessing. The decoding resulted in a file with the MD5 hash of the input data, as described in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref> of the DNA-Fountain publication. The decoded file was a gzip compressed tarball containing multiple files, including an image of the KolibriOS, a PDF of Shannon’s Mathematical Theory of Communication (<xref rid="vbad117-B22" ref-type="bibr">Shannon 1948</xref>), and a 3 pg video.</p>
  </sec>
  <sec>
    <title>4 Conclusion</title>
    <p>RepairNatrix is a Snakemake-based read-processing workflow that combines Natrix’s raw sequencing data processing capabilities with maximum likelihood reconstruction algorithms tailored to DNA data storage, the ability to extract payload data from a mixture of genomic sequences and payload sequences, and filtering of data with user-defined constraints. This combination allows easy and fast recovery of data stored in DNA, agnostic to the coding scheme used for translating binary data to DNA. The low-code configuration and setup of RepairNatrix allow users to easily restore the most likely sequences for DNA storage experiments from a pool of raw sequencing data. Besides in-vitro storage, RepairNatrix also supports <italic toggle="yes">in vivo</italic> storage, allowing users to blast against a database consisting of host-genome data to filter out biological sequences from encoded sequences and to assemble shotgun sequencing data into contigs. In addition, RepairNatrix processes Illumina and Oxford Nanopore data. Since RepairNatrix is written in the workflow management engine Snakemake, with all dependencies encapsulated in rule-specific Conda (<ext-link xlink:href="https://docs.conda.io/en/latest/" ext-link-type="uri">https://docs.conda.io/en/latest/</ext-link>) environments, results can easily be reproduced, allowing a comparison of different coding methods with the same preprocessing, including the same version for every tool used. All configuration entries are written in a single configuration file, making it easy to share and adjust. In its current version, RepairNatrix can be used with almost any code that requires some form of preprocessing of raw reads before decoding. Codes directly utilizing any form of majority voting during the decoding would most likely only benefit from the basic quality control, read assembly, dereplication and, possibly, from the filtering of constraint-violating sequences. An example of such a code is described in <xref rid="vbad117-B24" ref-type="bibr">Tabatabaei Yazdi <italic toggle="yes">et al.</italic> (2015)</xref>. However, such codes could integrate the maximum-likelihood repair into their workflow to profit from our approach. Additionally, the proposed method could be adapted for any code using non-canonical restrictions by implementing and adding these restrictions into the ruleset. For codes that generate sequences with a dependency between each other (e.g. a guaranteed minimal Hamming distance), a more sophisticated maximum-likelihood approach would have to be implemented taking all possible clusters into account. This would be possible using the RepairNatrix architecture, but it is currently not implemented.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>vbad117_Supplementary_Data</label>
      <media xlink:href="vbad117_supplementary_data.pdf"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>The authors thank Sandra Clemens for the contributions to the code base.</p>
  </ack>
  <sec>
    <title>Author contributions</title>
    <p>M.W. developed the workflow framework and the rules for quality control, assembly, dereplication, clustering, and BLAST. M.W. conducted the <italic toggle="yes">in silico</italic> comparisons. P.M.S. developed the maximum-likelihood repair algorithm and its associated rules. P.M.S. implemented and conducted the <italic toggle="yes">in silico</italic> error type analysis. B.F. and D.H. supervised the work and acquired funding. P.M.S. and M.W. wrote the initial manuscript, with support from B.F. and D.H. All authors contributed to the final manuscript.</p>
  </sec>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics Advances</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work is financially supported by the LOEWE program of the State of Hesse (Germany) in the MOSLA research cluster. The funding body did not influence any aspect of this work.</p>
  </sec>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>The source code of RepairNatrix is available at <ext-link xlink:href="https://github.com/umr-ds/RepairNatrix" ext-link-type="uri">https://github.com/umr-ds/RepairNatrix</ext-link>. The data underlying this article are available as supplementary data of the mentioned articles (<xref rid="vbad117-B27" ref-type="bibr">Welzel <italic toggle="yes">et al.</italic> 2023</xref> and <xref rid="vbad117-B7" ref-type="bibr">Erlich and Zielinski 2017</xref>).</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="vbad117-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>An</surname><given-names>R</given-names></string-name>, <string-name><surname>Jia</surname><given-names>Y</given-names></string-name>, <string-name><surname>Wan</surname><given-names>B</given-names></string-name></person-group><etal>et al</etal><article-title>Non-enzymatic depurination of nucleic acids: factors and mechanisms</article-title>. <source>PLoS One</source><year>2014</year>;<volume>9</volume>:<fpage>e115950</fpage>.<pub-id pub-id-type="pmid">25546310</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bee</surname><given-names>C</given-names></string-name>, <string-name><surname>Chen</surname><given-names>Y-J</given-names></string-name>, <string-name><surname>Queen</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Molecular-level similarity search brings computing to DNA data storage</article-title>. <source>Nat Commun</source><year>2021</year>;<volume>12</volume>:<fpage>4764</fpage>.<pub-id pub-id-type="pmid">34362913</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ceze</surname><given-names>L</given-names></string-name>, <string-name><surname>Nivala</surname><given-names>J</given-names></string-name>, <string-name><surname>Strauss</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>Molecular digital data storage using DNA</article-title>. <source>Nat Rev Genet</source><year>2019</year>;<volume>20</volume>:<fpage>456</fpage>–<lpage>66</lpage>.<pub-id pub-id-type="pmid">31068682</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cock</surname><given-names>PJA</given-names></string-name>, <string-name><surname>Fields</surname><given-names>CJ</given-names></string-name>, <string-name><surname>Goto</surname><given-names>N</given-names></string-name></person-group><etal>et al</etal><article-title>The sanger FASTQ file format for sequences with quality scores, and the solexa/illumina FASTQ variants</article-title>. <source>Nucleic Acids Res</source><year>2009</year>;<volume>38</volume>:<fpage>1767</fpage>–<lpage>71</lpage>.<pub-id pub-id-type="pmid">20015970</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B5">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>El-Shaikh</surname><given-names>A</given-names></string-name>, <string-name><surname>Seeger</surname><given-names>B.</given-names></string-name></person-group> DNAContainer: an object-based storage architecture on DNA. In: <italic toggle="yes">BTW 2023</italic>. Bonn: Gesellschaft für Informatik e.V., <year>2023</year>, <fpage>773</fpage>–<lpage>95</lpage>. doi: <pub-id pub-id-type="doi">10.18420/BTW2023-50</pub-id>.</mixed-citation>
    </ref>
    <ref id="vbad117-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>El-Shaikh</surname><given-names>A</given-names></string-name>, <string-name><surname>Welzel</surname><given-names>M</given-names></string-name>, <string-name><surname>Heider</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>High-scale random access on DNA storage systems</article-title>. <source>NAR Genom Bioinform</source><year>2022</year>;<volume>4</volume>:<fpage>lqab126</fpage>.<pub-id pub-id-type="pmid">35156022</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Erlich</surname><given-names>Y</given-names></string-name>, <string-name><surname>Zielinski</surname><given-names>D.</given-names></string-name></person-group><article-title>DNA fountain enables a robust and efficient storage architecture</article-title>. <source>Science</source><year>2017</year>;<volume>355</volume>:<fpage>950</fpage>–<lpage>4</lpage>.<pub-id pub-id-type="pmid">28254941</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Estaki</surname><given-names>M</given-names></string-name>, <string-name><surname>Jiang</surname><given-names>L</given-names></string-name>, <string-name><surname>Bokulich</surname><given-names>NA</given-names></string-name></person-group><etal>et al</etal><article-title>QIIME 2 enables comprehensive end-to-end analysis of diverse microbiome data and comparative studies with publicly available data</article-title>. <source>Curr Protoc Bioinformatics</source><year>2020</year>;<volume>70</volume>:<fpage>e100</fpage>.<pub-id pub-id-type="pmid">32343490</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ezekannagha</surname><given-names>C</given-names></string-name>, <string-name><surname>Welzel</surname><given-names>M</given-names></string-name>, <string-name><surname>Heider</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>DNAsmart: multiple attribute ranking tool for DNA data storage systems</article-title>. <source>Comput Struct Biotechnol J</source><year>2023</year>;<volume>21</volume>:<fpage>1448</fpage>–<lpage>60</lpage>.<pub-id pub-id-type="pmid">36851917</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Grass</surname><given-names>RN</given-names></string-name>, <string-name><surname>Heckel</surname><given-names>R</given-names></string-name>, <string-name><surname>Puddu</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Robust chemical preservation of digital information on DNA in silica with error-correcting codes</article-title>. <source>Angew Chem Int Ed Engl</source><year>2015</year>;<volume>54</volume>:<fpage>2552</fpage>–<lpage>5</lpage>.<pub-id pub-id-type="pmid">25650567</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kosuri</surname><given-names>S</given-names></string-name>, <string-name><surname>Church</surname><given-names>GM.</given-names></string-name></person-group><article-title>Large-scale de novo DNA synthesis: technologies and applications</article-title>. <source>Nat Methods</source><year>2014</year>;<volume>11</volume>:<fpage>499</fpage>–<lpage>507</lpage>.<pub-id pub-id-type="pmid">24781323</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Köster</surname><given-names>J</given-names></string-name>, <string-name><surname>Rahmann</surname><given-names>S.</given-names></string-name></person-group><article-title>Snakemake—a scalable bioinformatics workflow engine</article-title>. <source>Bioinformatics</source><year>2012</year>;<volume>28</volume>:<fpage>2520</fpage>–<lpage>2</lpage>.<pub-id pub-id-type="pmid">22908215</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Löchel</surname><given-names>HF</given-names></string-name>, <string-name><surname>Welzel</surname><given-names>M</given-names></string-name>, <string-name><surname>Hattab</surname><given-names>G</given-names></string-name></person-group><etal>et al</etal><article-title>Fractal construction of constrained code words for DNA storage systems</article-title>. <source>Nucleic Acids Res</source><year>2021</year>;<volume>50</volume>:<fpage>e30</fpage>.</mixed-citation>
    </ref>
    <ref id="vbad117-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Masella</surname><given-names>AP</given-names></string-name>, <string-name><surname>Bartram</surname><given-names>AK</given-names></string-name>, <string-name><surname>Truszkowski</surname><given-names>JM</given-names></string-name></person-group><etal>et al</etal><article-title>PANDAseq: paired-end assembler for illumina sequences</article-title>. <source>BMC Bioinformatics</source><year>2012</year>;<volume>13</volume>:<fpage>31</fpage>.<pub-id pub-id-type="pmid">22333067</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B15">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Pic</surname><given-names>X</given-names></string-name>, <string-name><surname>Antonio</surname><given-names>EGS</given-names></string-name>, <string-name><surname>Dimopoulou</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal> Rotating labeling of entropy coders for synthetic DNA data storage. In: <italic toggle="yes">2023 24th International Conference on Digital Signal Processing (DSP), Rhodes (Rodos), Greece</italic>, 2023, 1–5. doi: <pub-id pub-id-type="doi">10.1109/DSP58604.2023.10167907</pub-id>.</mixed-citation>
    </ref>
    <ref id="vbad117-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Press</surname><given-names>WH</given-names></string-name>, <string-name><surname>Hawkins</surname><given-names>JA</given-names></string-name>, <string-name><surname>Jones</surname><given-names>SK</given-names></string-name></person-group><etal>et al</etal><article-title>HEDGES error-correcting code for DNA storage corrects indels and allows sequence constraints</article-title>. <source>Proc Natl Acad Sci USA</source><year>2020</year>;<volume>117</volume>:<fpage>18489</fpage>–<lpage>96</lpage>.<pub-id pub-id-type="pmid">32675237</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Prjibelski</surname><given-names>A</given-names></string-name>, <string-name><surname>Antipov</surname><given-names>D</given-names></string-name>, <string-name><surname>Meleshko</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>Using SPAdes de novo assembler</article-title>. <source>Curr Protoc Bioinformatics</source><year>2020</year>;<volume>70</volume>:<fpage>e102</fpage>.<pub-id pub-id-type="pmid">32559359</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rognes</surname><given-names>T</given-names></string-name>, <string-name><surname>Flouri</surname><given-names>T</given-names></string-name>, <string-name><surname>Nichols</surname><given-names>B</given-names></string-name></person-group><etal>et al</etal><article-title>Vsearch: a versatile open source tool for metagenomics</article-title>. <source>PeerJ</source><year>2016</year>;<volume>4</volume>:<fpage>e2584</fpage>.<pub-id pub-id-type="pmid">27781170</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Schmieder</surname><given-names>R</given-names></string-name>, <string-name><surname>Edwards</surname><given-names>R.</given-names></string-name></person-group><article-title>Quality control and preprocessing of metagenomic datasets</article-title>. <source>Bioinformatics</source><year>2011</year>;<volume>27</volume>:<fpage>863</fpage>–<lpage>4</lpage>.<pub-id pub-id-type="pmid">21278185</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Schwarz</surname><given-names>M</given-names></string-name>, <string-name><surname>Welzel</surname><given-names>M</given-names></string-name>, <string-name><surname>Kabdullayeva</surname><given-names>T</given-names></string-name></person-group><etal>et al</etal><article-title>MESA: automated assessment of synthetic DNA fragments and simulation of DNA synthesis, storage, sequencing and PCR errors</article-title>. <source>Bioinformatics</source><year>2020</year>;<volume>36</volume>:<fpage>3322</fpage>–<lpage>6</lpage>.<pub-id pub-id-type="pmid">32129840</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Schwarz</surname><given-names>PM</given-names></string-name>, <string-name><surname>Freisleben</surname><given-names>B.</given-names></string-name></person-group><article-title>NOREC4DNA: near-optimal rateless erasure codes for DNA storage</article-title>. <source>BMC Bioinformatics</source><year>2021</year>;<volume>22</volume>:<fpage>406</fpage>.<pub-id pub-id-type="pmid">34404355</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Shannon</surname><given-names>CE.</given-names></string-name></person-group><article-title>A mathematical theory of communication</article-title>. <source>Bell Syst Tech J</source><year>1948</year>;<volume>27</volume>:<fpage>379</fpage>–<lpage>423</lpage>.</mixed-citation>
    </ref>
    <ref id="vbad117-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sieber</surname><given-names>G</given-names></string-name>, <string-name><surname>Beisser</surname><given-names>D</given-names></string-name>, <string-name><surname>Rothenberger</surname><given-names>JL</given-names></string-name></person-group><etal>et al</etal><article-title>Microbial community shifts induced by plastic and zinc as substitutes of tire abrasion</article-title>. <source>Sci Rep</source><year>2022</year>;<volume>12</volume>:<fpage>18684</fpage>.<pub-id pub-id-type="pmid">36333419</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yazdi</surname><given-names>SMHT</given-names></string-name>, <string-name><surname>Yuan</surname><given-names>Y</given-names></string-name>, <string-name><surname>Ma</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>A rewritable, random-access DNA-based storage system</article-title>. <source>Sci Rep</source><year>2015</year>;<volume>5</volume>:<fpage>14138</fpage>.<pub-id pub-id-type="pmid">26382652</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Takahashi</surname><given-names>CN</given-names></string-name>, <string-name><surname>Nguyen</surname><given-names>BH</given-names></string-name>, <string-name><surname>Strauss</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>Demonstration of end-to-end automation of DNA data storage</article-title>. <source>Sci Rep</source><year>2019</year>;<volume>9</volume>:<fpage>4998</fpage>.<pub-id pub-id-type="pmid">30899031</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Welzel</surname><given-names>M</given-names></string-name>, <string-name><surname>Lange</surname><given-names>A</given-names></string-name>, <string-name><surname>Heider</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>Natrix: a snakemake-based workflow for processing, clustering, and taxonomically assigning amplicon sequencing reads</article-title>. <source>BMC Bioinformatics</source><year>2020</year>;<volume>21</volume>:<fpage>526</fpage>.<pub-id pub-id-type="pmid">33198651</pub-id></mixed-citation>
    </ref>
    <ref id="vbad117-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Welzel</surname><given-names>M</given-names></string-name>, <string-name><surname>Schwarz</surname><given-names>PM</given-names></string-name>, <string-name><surname>Löchel</surname><given-names>HF</given-names></string-name></person-group><etal>et al</etal><article-title>DNA-Aeon provides flexible arithmetic coding for constraint adherence and error correction in DNA storage</article-title>. <source>Nat Commun</source><year>2023</year>;<volume>14</volume>:<fpage>628</fpage>.<pub-id pub-id-type="pmid">36746948</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
