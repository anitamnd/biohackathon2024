<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20031101//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id>
    <journal-id journal-id-type="iso-abbrev">PLoS Comput. Biol</journal-id>
    <journal-id journal-id-type="publisher-id">plos</journal-id>
    <journal-id journal-id-type="pmc">ploscomp</journal-id>
    <journal-title-group>
      <journal-title>PLoS Computational Biology</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1553-734X</issn>
    <issn pub-type="epub">1553-7358</issn>
    <publisher>
      <publisher-name>Public Library of Science</publisher-name>
      <publisher-loc>San Francisco, USA</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">2678294</article-id>
    <article-id pub-id-type="pmid">19461883</article-id>
    <article-id pub-id-type="publisher-id">09-PLCB-RA-0017R2</article-id>
    <article-id pub-id-type="doi">10.1371/journal.pcbi.1000386</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
      <subj-group subj-group-type="Discipline">
        <subject>Computational Biology/Genomics</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>SHRiMP: Accurate Mapping of Short Color-space Reads</article-title>
      <alt-title alt-title-type="running-head">SHRiMP: Mapping Short Reads</alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Rumble</surname>
          <given-names>Stephen M.</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="aff2">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Lacroute</surname>
          <given-names>Phil</given-names>
        </name>
        <xref ref-type="aff" rid="aff3">
          <sup>3</sup>
        </xref>
        <xref ref-type="aff" rid="aff4">
          <sup>4</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Dalca</surname>
          <given-names>Adrian V.</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Fiume</surname>
          <given-names>Marc</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Sidow</surname>
          <given-names>Arend</given-names>
        </name>
        <xref ref-type="aff" rid="aff3">
          <sup>3</sup>
        </xref>
        <xref ref-type="aff" rid="aff4">
          <sup>4</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Brudno</surname>
          <given-names>Michael</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="aff5">
          <sup>5</sup>
        </xref>
        <xref ref-type="corresp" rid="cor1">
          <sup>*</sup>
        </xref>
      </contrib>
    </contrib-group>
    <aff id="aff1">
      <label>1</label>
      <addr-line>Department of Computer Science, University of Toronto, Toronto, Ontario, Canada</addr-line>
    </aff>
    <aff id="aff2">
      <label>2</label>
      <addr-line>Department of Computer Science, Stanford University, Stanford, California, United States of America</addr-line>
    </aff>
    <aff id="aff3">
      <label>3</label>
      <addr-line>Department of Genetics, Stanford University, Stanford, California, United States of America</addr-line>
    </aff>
    <aff id="aff4">
      <label>4</label>
      <addr-line>Department of Pathology, Stanford University, Stanford, California, United States of America</addr-line>
    </aff>
    <aff id="aff5">
      <label>5</label>
      <addr-line>Banting &amp; Best Department of Medical Research, University of Toronto, Toronto, Ontario, Canada</addr-line>
    </aff>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Wasserman</surname>
          <given-names>Wyeth W.</given-names>
        </name>
        <role>Editor</role>
        <xref ref-type="aff" rid="edit1"/>
      </contrib>
    </contrib-group>
    <aff id="edit1">University of British Columbia, Canada</aff>
    <author-notes>
      <corresp id="cor1">* E-mail: <email>brudno@cs.toronto.edu</email></corresp>
      <fn fn-type="con">
        <p>Conceived and designed the experiments: SMR PL AS MB. Performed the experiments: SMR PL AVD MF. Analyzed the data: SMR PL AVD MF AS MB. Contributed reagents/materials/analysis tools: AS. Wrote the paper: SMR PL AVD MF AS MB.</p>
      </fn>
    </author-notes>
    <pub-date pub-type="collection">
      <month>5</month>
      <year>2009</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>22</day>
      <month>5</month>
      <year>2009</year>
    </pub-date>
    <volume>5</volume>
    <issue>5</issue>
    <elocation-id>e1000386</elocation-id>
    <history>
      <date date-type="received">
        <day>8</day>
        <month>1</month>
        <year>2009</year>
      </date>
      <date date-type="accepted">
        <day>9</day>
        <month>4</month>
        <year>2009</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Rumble et al.</copyright-statement>
      <copyright-year>2009</copyright-year>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are properly credited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p>The development of Next Generation Sequencing technologies, capable of sequencing hundreds of millions of short reads (25–70 bp each) in a single run, is opening the door to population genomic studies of non-model species. In this paper we present SHRiMP - the SHort Read Mapping Package: a set of algorithms and methods to map short reads to a genome, even in the presence of a large amount of polymorphism. Our method is based upon a fast read mapping technique, separate thorough alignment methods for regular letter-space as well as AB SOLiD (color-space) reads, and a statistical model for false positive hits. We use SHRiMP to map reads from a newly sequenced <italic>Ciona savignyi</italic> individual to the reference genome. We demonstrate that SHRiMP can accurately map reads to this highly polymorphic genome, while confirming high heterozygosity of <italic>C. savignyi</italic> in this second individual. SHRiMP is freely available at <ext-link ext-link-type="uri" xlink:href="http://compbio.cs.toronto.edu/shrimp">http://compbio.cs.toronto.edu/shrimp</ext-link>.</p>
    </abstract>
    <abstract abstract-type="summary">
      <title>Author Summary</title>
      <p>Next Generation Sequencing (NGS) technologies are revolutionizing the way biologists acquire and analyze genomic data. NGS machines, such as Illumina/Solexa and AB SOLiD, are able to sequence genomes more cheaply by 200-fold than previous methods. One of the main application areas of NGS technologies is the discovery of genomic variation within a given species. The first step in discovering this variation is the mapping of reads sequenced from a donor individual to a known (“reference”) genome. Differences between the reference and the reads are indicative either of polymorphisms, or of sequencing errors. Since the introduction of NGS technologies, many methods have been devised for mapping reads to reference genomes. However, these algorithms often sacrifice sensitivity for fast running time. While they are successful at mapping reads from organisms that exhibit low polymorphism rates, they do not perform well at mapping reads from highly polymorphic organisms. We present a novel read mapping method, SHRiMP, that can handle much greater amounts of polymorphism. Using <italic>Ciona savignyi</italic> as our target organism, we demonstrate that our method discovers significantly more variation than other methods. Additionally, we develop color-space extensions to classical alignment algorithms, allowing us to map color-space, or “dibase”, reads generated by AB SOLiD sequencers.</p>
    </abstract>
    <counts>
      <page-count count="11"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec id="s1">
    <title>Introduction</title>
    <p>Next generation sequencing (NGS) technologies are revolutionizing the study of variation among individuals in a population. The ability of sequencing platforms such as AB SOLiD and Illumina (Solexa) to sequence one billion basepairs (gigabase) or more in a few days has enabled the cheap re-sequencing of human genomes, with the genomes of a Chinese individual <xref rid="pcbi.1000386-Wang1" ref-type="bibr">[1]</xref>, a Yoruban individual <xref rid="pcbi.1000386-Bentley1" ref-type="bibr">[2]</xref>, and matching tumor and healthy samples from a female individual <xref rid="pcbi.1000386-Ley1" ref-type="bibr">[3]</xref> sequenced in the last few months. These resequencing efforts have been enabled by the development of extremely efficient mapping tools, capable of aligning millions of short (25–70 bp) reads to the human genome <xref rid="pcbi.1000386-Bowtie.1" ref-type="bibr">[4]</xref>–<xref rid="pcbi.1000386-Ma1" ref-type="bibr">[10]</xref>. In order to accelerate the computation, most of these methods allow for only a fixed number of mismatches (usually two or three) between the reference genome and the read, and usually do not allow for the matching of reads with insertion/deletion (indel) polymorphisms. These methods are extremely effective for mapping reads to the human genome, most of which has a low polymorphism rate, and so the likelihood that a single read spans multiple SNPs is small. While matching with up to a few differences (allowing for a SNP and 1–2 errors) is sufficient in these regions, these methods fail when the polymorphism level is high.</p>
    <p>NGS technologies are also opening the door to the study of population genomics of non-model individuals in other species. Various organisms have a wide range of polymorphism rates - from 0.1% in humans to 4.5% in the marine ascidian <italic>Ciona savignyi</italic>. The polymorphisms present in a particular species can be used to discern its evolutionary history and understand the selective pressures in various genomic loci. For example, the large amount of variation in <italic>C. savignyi</italic> (two individuals' genomes are as different as Human and Macaque) was found to be due to a large effective population size <xref rid="pcbi.1000386-Small1" ref-type="bibr">[11]</xref>. The re-sequencing of species like <italic>C. savignyi</italic> (and regions of the human genome with high variability) requires methods for short read mapping that allow for a combination of several SNPs, indels, and sequencing errors within a single (short) read. Furthermore, due to larger-scale “structural” variation, only a fraction of the read may match to the genome, necessitating the use of local, rather than global, alignment methods.</p>
    <p>Previous short read mapping tools typically allow for a fixed number of mismatches by separating a read into several sections and requiring some number of these to match perfectly, while others are allowed to vary <xref rid="pcbi.1000386-Bowtie.1" ref-type="bibr">[4]</xref>,<xref rid="pcbi.1000386-Maq.1" ref-type="bibr">[6]</xref>,<xref rid="pcbi.1000386-Li2" ref-type="bibr">[8]</xref>. An alternative approach generates a set of subsequences from the read (often represented as spaced seeds <xref rid="pcbi.1000386-Li1" ref-type="bibr">[7]</xref>,<xref rid="pcbi.1000386-Ma1" ref-type="bibr">[10]</xref>,<xref rid="pcbi.1000386-Buhler1" ref-type="bibr">[12]</xref>), again in such a manner that if a read were to match at a particular location with some number of mismatches, at least one of the subsequences would match the genome <xref rid="pcbi.1000386-mapreads.1" ref-type="bibr">[5]</xref>,<xref rid="pcbi.1000386-Lin1" ref-type="bibr">[9]</xref>. While these methods are extremely fast, they were developed for genomes with relatively low levels of polymorphism, and typically cannot handle a highly polymorphic, non-model genome.</p>
    <p>This becomes especially apparent when working with data from Applied Biosystem's SOLiD sequencing platform (AB SOLiD). AB SOLiD uses a di-base sequencing chemistry that generates one of four possible calls (colors) for each pair of nucleotides. While a sequencing error is a change of one color-call to another, a single SNP will change two adjacent color positions. Hence a read with two (non-adjacent) SNPs and a sequencing error will differ from the reference genome in five different positions. Simultaneously, the nature of the di-base sequencing code allows for the identification (and correction) of sequencing errors, so by carefully analyzing the exact sequence of matches and mismatches within a read, it is possible to determine that the read and the genome differ by two SNPs. While efficient mappers for color-space sequences have been developed <xref rid="pcbi.1000386-mapreads.1" ref-type="bibr">[5]</xref>,<xref rid="pcbi.1000386-Ondov1" ref-type="bibr">[13]</xref>, they translate the genome to color-space, and directly compare to the color-space read. The complexity of the color-space representation makes the identification of complex variation such as adjacent SNPs and short indels challenging or impossible with these tools.</p>
    <p>In this paper we develop algorithms for the mapping of short reads to highly polymorphic genomes and methods for the analysis of the mappings. We demonstrate an algorithm for mapping short reads in the presence of a large amount of polymorphism. By employing a fast k-mer hashing step and a simple, very efficient implementation of the Smith-Waterman algorithm, our method conducts a full alignment of each read to all areas of the genome that are potentially homologous. Secondly, we introduce a novel, specialized algorithm for mapping di-base (color-space) reads, which allows for an accurate, non-heuristic alignment of AB SOLiD reads to a reference genome. Finally, we introduce methodology for evaluating the accuracy of discovered alignments. Because a read may match the genome in several locations with variable amounts of polymorphism, we develop a statistical method for scoring the hits, allowing for the selection of the most probable variants, and filtering of false positives.</p>
    <p>Our methods are implemented as part of SHRiMP: the SHort Read Mapping Package. To demonstrate the usefulness of SHRiMP we re-sequenced a Japanese <italic>Ciona savignyi</italic> genome on the SOLiD platform. Preliminary estimates obtained in the course of sequencing the reference genome indicate that the SNP heterozygosity is 4.5%, whereas indel heterozygosity is 16.6%. This species represents the most challenging known test case for the detection of polymorphisms with short read technologies. We aligned the SOLiD reads of the Japanese individual to the <italic>C. savignyi</italic> reference genome using both SHRiMP and AB's read mapper. SHRiMP is able to identify 5-fold more SNPs than AB's mapper, while also capturing 70,000 indel variants.</p>
  </sec>
  <sec id="s2">
    <title>Results/Discussion</title>
    <p>This section is organized as follows: we begin with three methodological sections, in which we first present an overview of the algorithms used in SHRiMP for mapping short reads, explain our specialized algorithm for alignment of di-base sequencing (AB SOLiD) data, and present our framework for computing p-values and other statistics for alignment quality. The data flow for these methods is illustrated in <xref ref-type="fig" rid="pcbi-1000386-g001">Figure 1</xref>. In the last two subsections we will first show the application of SHRiMP to the resequencing of <italic>Ciona savignyi</italic> using the AB SOLiD sequencing technology and present results on the accuracy of the SHRiMP tool on simulated data.</p>
    <fig id="pcbi-1000386-g001" position="float">
      <object-id pub-id-type="doi">10.1371/journal.pcbi.1000386.g001</object-id>
      <label>Figure 1</label>
      <caption>
        <title>Data flow and processing within the SHRiMP.</title>
        <p>Candidate mapping locations are first discovered by the seed scanner and then validated by the vectorized Smith-Waterman algorithm, computing only a score. Top scoring hits are then fully aligned by a platform-specific algorithm (i.e. letter-space for Solexa data and color-space for SOLiD data). Statistical confidence for the final mappings are then computed using the PROBCALC utility.</p>
      </caption>
      <graphic xlink:href="pcbi.1000386.g001"/>
    </fig>
    <sec id="s2a">
      <title>Read Mapping Algorithm</title>
      <p>The SHRiMP algorithm draws upon three recent developments in the field of sequence alignment: q-gram filter approaches, introduced by Rasmussen et al <xref rid="pcbi.1000386-Rasmussen1" ref-type="bibr">[14]</xref>; spaced seeds, introduced by Califano and Rigoutsos <xref rid="pcbi.1000386-Califano1" ref-type="bibr">[15]</xref> and popularized by the PatterHunter family of tools <xref rid="pcbi.1000386-Li1" ref-type="bibr">[7]</xref>,<xref rid="pcbi.1000386-Ma1" ref-type="bibr">[10]</xref>; and specialized vector computing hardware to speed up the Smith-Waterman Algorithm <xref rid="pcbi.1000386-Rognes1" ref-type="bibr">[16]</xref>–<xref rid="pcbi.1000386-Wozniak1" ref-type="bibr">[18]</xref> to rapidly find the likely locations for the reads on the genome. Once these locations are identified, we conduct a thorough, Smith-Waterman-based algorithm to rigorously evaluate the alignments. In this section we will provide a brief exposition of the methods used to align short reads in SHRiMP (a more thorough description of each of these steps is in <xref ref-type="sec" rid="s3">Methods</xref>).</p>
      <sec id="s2a1">
        <title>Spaced seeds</title>
        <p>Most heuristic methods for local alignment rely on the identification of seeds – short exact matches between the two sequences. The advantage of using exact matches is that they are easy to find using hash tables, suffix arrays, or related techniques. While classically seeds have been contiguous matches, more recently “spaced” seeds, where <italic>predetermined</italic> positions in the read are allowed not to match, have been shown to be more sensitive. Spaced seeds are often represented as a string of 1 s and 0 s, where 1 s indicate positions that must match, while 0 s indicate positions that may mismatch. We refer to the <italic>length</italic> or <italic>span</italic> of the seed as the total length of the string, and the <italic>weight</italic> of the seed as the number of 1 s in the string. For example, the seed “11100111” requires matches at positions 1–3 and 6–8, and has length 8 and weight 6. Because seeds with such small weight match extremely often, we require multiple seeds to match within a region before it is further considered, using a technique called Q-gram filtering.</p>
      </sec>
      <sec id="s2a2">
        <title>Q-gram filters</title>
        <p>While most older local alignment tools, such as BLAST, use a single matching seed to start a thorough comparison of the strings around the seed, more recently Rassmussen et al <xref rid="pcbi.1000386-Rasmussen1" ref-type="bibr">[14]</xref> introduced the use of q-gram filters, where multiple seeds are used to determine if a good match exists. This idea is also used in SHRiMP where we require a pre-determined number of seeds from a read to match within a window of the genome before we conduct a thorough comparison.</p>
      </sec>
      <sec id="s2a3">
        <title>Vectorized Smith-Waterman</title>
        <p>If a particular read has the required number of seeds matching to a window of the genome we conduct a rapid alignment of the two regions to verify the similarity. This alignment is done using the classical Smith-Waterman algorithm <xref rid="pcbi.1000386-Smith1" ref-type="bibr">[19]</xref>, implemented using specialized “vector” instructions that are part of all modern CPUs. In order to speed up this stage we compute just the score of the optimal alignment, and not the alignment itself. For every read we store the locations of top hits, sorted by their score. The number of top hits to store is a parameter.</p>
      </sec>
      <sec id="s2a4">
        <title>Final alignment</title>
        <p>After we finish aligning all of the reads to all of the potential locations, we conduct a final, full alignment of each read to all of the top hits. This final alignment stage differs depending on the specifics of the sequencing technology. Within SHRiMP we have implemented separate final alignment modules for Illumina/Solexa data (this is done with the regular Smith-Waterman algorithm) and for color-space (di-base) data produced by the AB SOLiD instrument (described in the next section). Additionally we have an experimental module for alignment of two-pass sequencing data, where two reads are generated from every genomic location, which is described elsewhere <xref rid="pcbi.1000386-Yanovsky1" ref-type="bibr">[20]</xref>.</p>
      </sec>
    </sec>
    <sec id="s2b">
      <title>Algorithm for Color-space Alignment</title>
      <p>The AB SOLiD sequencing technology introduced a novel dibase sequencing technique, which reads overlapping pairs of letters and generates one of four colors (typically labelled 0–3) at every stage. Each base is interrogated twice: first as the right nucleotide of a pair, and then as the left one. The exact combinations of letters and the colors they generate are shown in <xref ref-type="fig" rid="pcbi-1000386-g002">Figure 2A</xref>. The sequencing code can be thought of as a finite state automaton (FSA), in which each previous letter is a state and each color code is a transition to the next letter state. This automaton is demonstrated in <xref ref-type="fig" rid="pcbi-1000386-g002">Figure 2B</xref>. It is notable that the sequence of colors is insufficient to reconstruct the DNA sequence, as reconstruction requires knowledge of the first letter of the sequence (or the last letter of the primer, which is fixed for a single run of the technology).</p>
      <fig id="pcbi-1000386-g002" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pcbi.1000386.g002</object-id>
        <label>Figure 2</label>
        <caption>
          <title>Two representations of the color-space (dibase) encoding used by the AB SOLiD sequencing system.</title>
          <p>A: The standard representation, with the first and second letter of the queried pair along the horizontal and vertical axes, respectively. B: The equivalent Finite State Automaton representation, with edges labelled with the readouts and nodes corresponding to the basepairs of the underlying genome.</p>
        </caption>
        <graphic xlink:href="pcbi.1000386.g002"/>
      </fig>
      <p>The AB SOLiD sequencing technology has the remarkable property of differentiating between sequencing errors and biological SNPs (under the assumption that the reference genome has no sequencing errors): a SNP changes two adjacent readouts of the color-space code, while a sequencing error is unlikely to happen at two adjacent positions by chance (the technology does not sequence adjacent letters at adjacent time points). At the same time, however, the color-space code introduces certain complexities.</p>
      <p>Let us consider a comparison done by first translating the color-space read code into the letter-space sequence. Notice that a single sequencing error would cause every position after the place of error to be mistranslated (<xref ref-type="fig" rid="pcbi-1000386-g003">Figure 3B</xref>). Consequently, most approaches have translated the letter-space genome into the corresponding color code. However, this is problematic: since the color-coding of every dibase pairing is not unique, a string of colors can represent one of several DNA strings, depending on the preceding base pair. For example, a string of zeroes could be translated as a poly-A, poly-C, poly-G or poly-T string.</p>
      <fig id="pcbi-1000386-g003" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pcbi.1000386.g003</object-id>
        <label>Figure 3</label>
        <caption>
          <title>Various mutation and error events, and their effects on the color-code readouts.</title>
          <p>The reference genome is labeled G and the read R. A: A perfect alignment; B: In case of a sequencing error (the 2 should have been read as a 0) the rest of the read no longer matches the genome in letter-space; C: In case of a SNP two adjacent colors do not match the genome, but all subsequent letters do match. However, D: only 3 of the 9 possible color changes represent valid SNPs; E: the rules for deciding which insertion and deletion events are valid are even more complex, as indels can also change adjacent color readouts.</p>
        </caption>
        <graphic xlink:href="pcbi.1000386.g003"/>
      </fig>
      <p>There is an additional drawback to translating the genome into color-space code: a sequence of matches and mismatches in color-space does not map uniquely into letter-space similarity. For example, a single SNP results in two sequential color-space mismatches. However, given two consecutive colors, there are 9 possible ways to generate two mismatches. Of these, only 3 correspond to a SNP, while the rest lead to DNA strings that completely differ from the reference. This is illustrated in <xref ref-type="fig" rid="pcbi-1000386-g003">Figure 3D</xref>.</p>
      <p>We propose an alternate approach. Our key observation is that while a color-space error causes the rest of the sequence to be mistranslated, the genome will match one of the other three possible translations. This is illustrated in <xref ref-type="fig" rid="pcbi-1000386-g004">Figure 4C</xref>. Consequently, we adapt the classical dynamic programming algorithm to simultaneously align the genome to all four possible translations of the read, allowing the algorithm to move from one translation to another by paying a “crossover”, or sequencing error penalty. If one wishes for a probabilistic interpretation of the algorithm, one can consider the FSA in <xref ref-type="fig" rid="pcbi-1000386-g002">Figure 2B</xref> to be a Hidden Markov Model, where the letter is the hidden state, and the color-space sequence is the output of the model. By taking the cross product of this HMM with the standard pair-HMM associated with the Smith-Waterman algorithm, we can allow all of the typical alignment parameters, including the error penalty, to be probabilistically motivated as the log of the probability of the event, and trained using the Expectation-Maximization algorithm. It is notable that our approach handles not only matches, mismatches, and sequencing errors, but also indels. Because the sequences are aligned in letter-space (to be precise, they are aligned and translated simultaneously), indels can be penalized using the standard affine gap penalty with no further modification of the algorithm.</p>
      <fig id="pcbi-1000386-g004" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pcbi.1000386.g004</object-id>
        <label>Figure 4</label>
        <caption>
          <title>Color-space (dibase) sequence alignment.</title>
          <p>A: The Dynamic Programming (DP) representation, B: recurrences, and C: alignment of a letter space sequence to a color-space read with a sequencing error. Within the DP matrix we simultaneously align all of the four possible translations (vertical) to the reference genome (horizontal); however the alignment can transition between translations by paying the crossover penalty. This is illustrated by the fourth recurrence, where the third index (<inline-formula><inline-graphic xlink:href="pcbi.1000386.e001.jpg" mimetype="image"/></inline-formula>) corresponds to the translation currently being used. In the alignment (C) after the sequencing error, the original translation of the read (starting from a T) no longer matches, but a different one (starting from a C) does.</p>
        </caption>
        <graphic xlink:href="pcbi.1000386.g004"/>
      </fig>
      <p>In the SHRiMP algorithm, we only apply the special color-space Smith-Waterman algorithm in the final stage. For the initial stages, we convert the genome from letter-space to color-space, and search for k-mer matches as well as perform vectorized Smith-Waterman strictly in color-space. In order to better incorporate SNPs in color-space data, we use a spaced seed that allows for two adjacent mismatching colors between the read and the reference genome.</p>
    </sec>
    <sec id="s2c">
      <title>Computing Statistics for Reads and Mate-pairs</title>
      <p>Once all of the reads are mapped, for every read and mate-pair we compute mapping confidence statistics. Initially these are computed for each read; however, they are then combined to compute likelihoods of accidental matches for mate-pairs.</p>
      <sec id="s2c1">
        <title>Computing statistics for single reads</title>
        <p>While a very thorough statistical theory for local alignments has been established <xref rid="pcbi.1000386-Karlin1" ref-type="bibr">[21]</xref>, this theory assumes the comparison of infinite length strings, and hence is inappropriate for evaluating alignments of very short reads to a reference genome. Instead, we have designed confidence statistics that explicitly model short reads, and allow for the computation of confidences in the presence of short insertions and deletions. We estimate the confidence in the possible mappings of each read by using the following statistics (calculated by the PROBCALC program): <italic>pchance</italic> – the probability that the hit occurred by chance – and <italic>pgenome</italic> – the probability that the hit was generated by the genome, given the observed rates of the various evolutionary and error events. For example, a good alignment would have a low <italic>pchance</italic> (close to 0) and a very high <italic>pgenome</italic> (close to 1). In this section we briefly expand on these two concepts, give them mathematical definitions, and merge them to formulate an overall alignment quality measurement. A detailed description is in <xref ref-type="sec" rid="s3">Methods</xref> (Computing Statistics: <italic>pchance</italic> and <italic>pgenome</italic>).</p>
        <p>The <italic>pchance</italic> of a hit is the probability that the read will align with as good a score to a genome that has the same length, but random nucleotide composition with equal base frequencies (that is, the read will align as well <italic>by chance</italic>). In order to compute this, we count all of the possible k-mers with an equal number of changes as observed in the hit, and we call this number <inline-formula><inline-graphic xlink:href="pcbi.1000386.e002.jpg" mimetype="image"/></inline-formula>. For example, if we only have substitutions in our alignment (that is, no indels) and an alignment length of <inline-formula><inline-graphic xlink:href="pcbi.1000386.e003.jpg" mimetype="image"/></inline-formula>, then <inline-formula><inline-graphic xlink:href="pcbi.1000386.e004.jpg" mimetype="image"/></inline-formula> gives the number of unique strings to which the read can align with the specified number of substitutions. A more detailed discussion on the construction of <inline-formula><inline-graphic xlink:href="pcbi.1000386.e005.jpg" mimetype="image"/></inline-formula>, especially for the more complex <inline-formula><inline-graphic xlink:href="pcbi.1000386.e006.jpg" mimetype="image"/></inline-formula> count for indels, appears in Computing Statistics: <italic>pchance</italic> and <italic>pgenome</italic>. The term <inline-formula><inline-graphic xlink:href="pcbi.1000386.e007.jpg" mimetype="image"/></inline-formula> compares the number of unique strings with the given score (when aligned to the read) compared to all possible unique reads of length <inline-formula><inline-graphic xlink:href="pcbi.1000386.e008.jpg" mimetype="image"/></inline-formula>, and gives us the probability that a read matches by chance at any location. To compute the <italic>pchance</italic> statistic over the entire length of the genome, we assume independence of positions, and evaluate the likelihood that there is a match at any of the positions:<disp-formula><graphic xlink:href="pcbi.1000386.e009.jpg" mimetype="image" position="float"/><label>(1)</label></disp-formula>where <inline-formula><inline-graphic xlink:href="pcbi.1000386.e010.jpg" mimetype="image"/></inline-formula> is the alignment length, <inline-formula><inline-graphic xlink:href="pcbi.1000386.e011.jpg" mimetype="image"/></inline-formula> is the genome length (2 corresponds to the two strands), and <inline-formula><inline-graphic xlink:href="pcbi.1000386.e012.jpg" mimetype="image"/></inline-formula> is a correction factor for mappings that are shorter than the length of the read, detailed in Computing Statistics: <italic>pchance</italic> and <italic>pgenome</italic>.</p>
        <p>Our second computation, <italic>pgenome</italic>, defines the probability that a hit was generated by the genome via common evolutionary events characteristic of the genome - i.e. substitutions, indels and errors. First, we estimate the rate for each type of event via bootstrapping. Then, we compute the likelihood that the read will differ by as many events from the genome via a binomial probability that uses this estimation and our observations for the events in the current hit. For example, when considering the number of errors, we first estimate the average error rate <inline-formula><inline-graphic xlink:href="pcbi.1000386.e013.jpg" mimetype="image"/></inline-formula> over all hits, and then we can define the probability that the current read was created via this many errors by<disp-formula><graphic xlink:href="pcbi.1000386.e014.jpg" mimetype="image" position="float"/><label>(2)</label></disp-formula>where <inline-formula><inline-graphic xlink:href="pcbi.1000386.e015.jpg" mimetype="image"/></inline-formula> is the number of observed errors in the current hit, and <inline-formula><inline-graphic xlink:href="pcbi.1000386.e016.jpg" mimetype="image"/></inline-formula> is the alignment length. We can similarly define <inline-formula><inline-graphic xlink:href="pcbi.1000386.e017.jpg" mimetype="image"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pcbi.1000386.e018.jpg" mimetype="image"/></inline-formula> for substituion and indel events, respectively. Finally, we can form <inline-formula><inline-graphic xlink:href="pcbi.1000386.e019.jpg" mimetype="image"/></inline-formula> as<disp-formula><graphic xlink:href="pcbi.1000386.e020.jpg" mimetype="image" position="float"/><label>(3)</label></disp-formula>More specifics about the mathematical formulations are available in Computing Statistics: <italic>pchance</italic> and <italic>pgenome</italic>.</p>
        <p>Finally, we define the quality measurement of this hit as the <italic>normalized odds</italic>, i.e. a probability odds ratio <inline-formula><inline-graphic xlink:href="pcbi.1000386.e021.jpg" mimetype="image"/></inline-formula> normalized over all of the hits of this read:<disp-formula><graphic xlink:href="pcbi.1000386.e022.jpg" mimetype="image" position="float"/><label>(4)</label></disp-formula>This value represents a relative credibility of this hit compared to the others for a given read: A single hit would have a normalized odds score of 1, two equally good hits will both have <inline-formula><inline-graphic xlink:href="pcbi.1000386.e023.jpg" mimetype="image"/></inline-formula> of 0.5 for both, while for an exact match and a more distant one, the former will have a <inline-formula><inline-graphic xlink:href="pcbi.1000386.e024.jpg" mimetype="image"/></inline-formula> close to 1, and the latter close to 0.</p>
      </sec>
      <sec id="s2c2">
        <title>Computing statistics for mate-pairs</title>
        <p>SHRiMP also assigns mate-pair confidence values (akin to the read confidence values predicted by probcalc) by combining the confidence values for individual reads with emprically observed distributions of insert sizes in the library. We compute the distribution of the mapped distances (distance between the mapped positions of the two reads) <inline-formula><inline-graphic xlink:href="pcbi.1000386.e025.jpg" mimetype="image"/></inline-formula> for all mate-pairs, and save the average distance <inline-formula><inline-graphic xlink:href="pcbi.1000386.e026.jpg" mimetype="image"/></inline-formula> (see <italic>Computing Mate Pairs with Statistics</italic> for more details). Then, for each mate-pair mapping, we assign a pchance, pgenome and normodds score, similar in meaning to those used in the previous section:</p>
        <list list-type="bullet">
          <list-item>
            <p><bold><italic>pchance</italic></bold><bold> for mate-pairs</bold>: assume <inline-formula><inline-graphic xlink:href="pcbi.1000386.e027.jpg" mimetype="image"/></inline-formula> is the pchance of a read that takes g, the length of the genome, as a parameter. Now, the pchance of a mate-pair read_1, read_2 is defined as<disp-formula><graphic xlink:href="pcbi.1000386.e028.jpg" mimetype="image" position="float"/><label>(5)</label></disp-formula>where <inline-formula><inline-graphic xlink:href="pcbi.1000386.e029.jpg" mimetype="image"/></inline-formula> is the length of the genome used in probcalc, <inline-formula><inline-graphic xlink:href="pcbi.1000386.e030.jpg" mimetype="image"/></inline-formula> is the average mate-pair distance, and <inline-formula><inline-graphic xlink:href="pcbi.1000386.e031.jpg" mimetype="image"/></inline-formula> is the distance of the current mate-pair. That is, we ask the question: what is the probability that a read as good as the first read would align anywhere in the genome by chance, <italic>and</italic> that a second read will align by chance within the observed mate-pair distance?</p>
          </list-item>
          <list-item>
            <p><bold><italic>pgenome</italic></bold><bold> for mate-pairs</bold>: assume <inline-formula><inline-graphic xlink:href="pcbi.1000386.e032.jpg" mimetype="image"/></inline-formula> is the pgenome of a read. We can compute the pgenome of each mate-pair by<disp-formula><graphic xlink:href="pcbi.1000386.e033.jpg" mimetype="image" position="float"/><label>(6)</label></disp-formula>where <inline-formula><inline-graphic xlink:href="pcbi.1000386.e034.jpg" mimetype="image"/></inline-formula> is the tail probability of the mate-pair distance distribution we computed (both tails, starting at the <inline-formula><inline-graphic xlink:href="pcbi.1000386.e035.jpg" mimetype="image"/></inline-formula> cutoff). Therefore, for a mate-pair with the distance really close to <inline-formula><inline-graphic xlink:href="pcbi.1000386.e036.jpg" mimetype="image"/></inline-formula>, the pgenome will be close to <inline-formula><inline-graphic xlink:href="pcbi.1000386.e037.jpg" mimetype="image"/></inline-formula>, otherwise, it will be penalized. Thus, following the difinition of pgenome, we will get a lower probability that the mate-pair was generated from the genome if the mate-pair distance is too big or too small compared to the average.</p>
          </list-item>
        </list>
        <p>A discussion of the implementation steps are included in the SHRiMP README, and a more detailed discussion of the statistical values is included in <italic>Computing Mate Pairs with Statistics</italic>.</p>
      </sec>
    </sec>
    <sec id="s2d">
      <title>Validation</title>
      <p>In our experiments, we used SHRiMP to compare 135 million 35 bp reads from a tunicate <italic>Ciona savignyi</italic> to the reference genome <xref rid="pcbi.1000386-Small2" ref-type="bibr">[22]</xref>. The fragments were sequenced from sheared genomic DNA with an AB SOLiD 1.0 instrument. In the following sections we first describe the running time of SHRiMP at different parameter settings, and then evaluate the quality of our alignments compared to the Applied Biosystem's read mapping program.</p>
      <sec id="s2d1">
        <title>Running time analysis</title>
        <p>One of the advantages of the SHRiMP algorithm is the seamless parallelism provided by the fact that we can simply subdivide the reads into separate computational jobs, without affecting the results. This allows us to take full advantage of compute clusters regardless of the amount of memory available at each machine. We took a random subset consisting of 500,000 35 bp <italic>C. Savignyi</italic> reads and mapped them to the genome. The full read dataset and reference genome are available at <ext-link ext-link-type="uri" xlink:href="http://compbio.cs.toronto.edu/shrimp/misc/paper_ciona_reads_35mer.csfasta.tar.bz2">http://compbio.cs.toronto.edu/shrimp/misc/paper_ciona_reads_35mer.csfasta.tar.bz2</ext-link> and <ext-link ext-link-type="uri" xlink:href="http://mendel.stanford.edu/sidowlab/CionaData/CionaSavignyi_v.2.1.fa.zip">http://mendel.stanford.edu/sidowlab/CionaData/CionaSavignyi_v.2.1.fa.zip</ext-link>, respectively.</p>
        <p>The running times at several parameter settings are summarized in <xref ref-type="table" rid="pcbi-1000386-t001">Table 1</xref>. Note that from smallest to largest seed weight, we see a nearly two orders of magnitude difference in total run time, most of which is concentrated in the vectorized Smith-Waterman filter, and, to a lesser degree, in the spaced k-mer scan. The final, full color-space Smith-Waterman alignment took approximately constant time across all runs, as the average number of top scoring hits that reached the stage was nearly constant (24.49±0.5); however, proportional time increased as the filter stages became more efficient. While SHRiMP is somewhat slower than other short read mapping programs, it allows both for micro-indels in the alignments and a proper color-space alignment algorithm. SHRiMP is also very configurable in terms of sensitivity and running time trade-offs.</p>
        <table-wrap id="pcbi-1000386-t001" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pcbi.1000386.t001</object-id>
          <label>Table 1</label>
          <caption>
            <title>Running time of SHRiMP for mapping 500,000 35 bp SOLiD <italic>C. savignyi</italic> reads to the 180 Mb reference genome on a single Core2 2.66 GHz processor.</title>
          </caption>
          <alternatives>
            <graphic id="pcbi-1000386-t001-1" xlink:href="pcbi.1000386.t001"/>
            <table frame="hsides" rules="groups">
              <colgroup span="1">
                <col align="left" span="1"/>
                <col align="center" span="1"/>
                <col align="center" span="1"/>
                <col align="center" span="1"/>
                <col align="center" span="1"/>
                <col align="center" span="1"/>
                <col align="center" span="1"/>
              </colgroup>
              <thead>
                <tr>
                  <td align="left" rowspan="1" colspan="1">K-mer</td>
                  <td align="left" rowspan="1" colspan="1">(7,8)</td>
                  <td align="left" rowspan="1" colspan="1">(8,9)</td>
                  <td align="left" rowspan="1" colspan="1">(9,10)</td>
                  <td align="left" rowspan="1" colspan="1">(10,11)</td>
                  <td align="left" rowspan="1" colspan="1">(11,12)</td>
                  <td align="left" rowspan="1" colspan="1">(12,13)</td>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="left" rowspan="1" colspan="1">% K-mer Scan</td>
                  <td align="left" rowspan="1" colspan="1">10.1%</td>
                  <td align="left" rowspan="1" colspan="1">16.5%</td>
                  <td align="left" rowspan="1" colspan="1">18.9%</td>
                  <td align="left" rowspan="1" colspan="1">13.4%</td>
                  <td align="left" rowspan="1" colspan="1">9.8%</td>
                  <td align="left" rowspan="1" colspan="1">7.4%</td>
                </tr>
                <tr>
                  <td align="left" rowspan="1" colspan="1">% Vectorized SW Filter</td>
                  <td align="left" rowspan="1" colspan="1">88.8%</td>
                  <td align="left" rowspan="1" colspan="1">75.4%</td>
                  <td align="left" rowspan="1" colspan="1">49.8%</td>
                  <td align="left" rowspan="1" colspan="1">30.2%</td>
                  <td align="left" rowspan="1" colspan="1">20.1%</td>
                  <td align="left" rowspan="1" colspan="1">14.9%</td>
                </tr>
                <tr>
                  <td align="left" rowspan="1" colspan="1">% Full SW Alignment</td>
                  <td align="left" rowspan="1" colspan="1">1.1%</td>
                  <td align="left" rowspan="1" colspan="1">8.0%</td>
                  <td align="left" rowspan="1" colspan="1">30.7%</td>
                  <td align="left" rowspan="1" colspan="1">55.5%</td>
                  <td align="left" rowspan="1" colspan="1">68.8%</td>
                  <td align="left" rowspan="1" colspan="1">76.2%</td>
                </tr>
                <tr>
                  <td align="left" rowspan="1" colspan="1">Time</td>
                  <td align="left" rowspan="1" colspan="1">1 d21 h34 m</td>
                  <td align="left" rowspan="1" colspan="1">6 h18 m</td>
                  <td align="left" rowspan="1" colspan="1">1 h36 m</td>
                  <td align="left" rowspan="1" colspan="1">50 m28 s</td>
                  <td align="left" rowspan="1" colspan="1">37 m52 s</td>
                  <td align="left" rowspan="1" colspan="1">32 m32 s</td>
                </tr>
              </tbody>
            </table>
          </alternatives>
          <table-wrap-foot>
            <fn id="nt101">
              <p>In all cases, two k-mer hits were required within a 41 bp window to invoke the vectorized Smith-Waterman filter.</p>
            </fn>
          </table-wrap-foot>
        </table-wrap>
      </sec>
      <sec id="s2d2">
        <title><italic>Ciona savignyi</italic> polymorphism analysis</title>
        <p>The primary strength of SHRiMP and other mapping methods based on Smith-Waterman alignments is the ability to map reads containing complex patterns of sequence variation, including insertions, deletions and clusters of closely-space SNPs. Mappers that exclusively produce ungapped alignments can only find SNPs. Furthermore they are more likely to miss dense clusters of SNPs, since the overlapping reads contain many mismatches, and SNPs adjacent to an indel, since only a small fraction of the overlapping reads contain just the SNP. Finally, since SHRiMP produces local alignments, it can map a read even if either end overlaps a large indel or structural variant.</p>
        <p>To evaluate the effectiveness of SHRiMP for detecting sequence variation we used it to find polymorphisms in a resequenced <italic>Ciona savignyi</italic> individual. <italic>C. savignyi</italic> is a challenging test case because of its very high polymorphism rate: the SNP heterozygosity is 4.5% and the average per-base indel heterozygosity is 16.6% (indel rate of 0.0072 events per base) <xref rid="pcbi.1000386-Small1" ref-type="bibr">[11]</xref>. We therefore expect that even short reads will frequently span multiple variant sites.</p>
        <p>We used the AB SOLiD sequencing platform to generate 135 million reads of length 35 bp from a single <italic>C. savignyi</italic> individual. We then aligned those reads to the reference genome <xref rid="pcbi.1000386-Small2" ref-type="bibr">[22]</xref> with SHRiMP using lenient scoring thresholds so that reads with multiple variant sites could be mapped, and we selected the single highest-scoring alignment for each read (see <xref ref-type="sec" rid="s3">Methods</xref>). We discarded alignments in repetitive sequence by removing reads with multiple similarly scoring alignments (“non-unique” matches). The mapping took 48 hours using 250 2.33 GHz cores. <xref ref-type="table" rid="pcbi-1000386-t002">Table 2</xref> summarizes the mapping results.</p>
        <table-wrap id="pcbi-1000386-t002" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pcbi.1000386.t002</object-id>
          <label>Table 2</label>
          <caption>
            <title>Mapping results for 135 million 35 bp SOLiD reads from <italic>Ciona savignyi</italic> using SHRiMP and the SOLiD mapper provided by Applied Biosystems.</title>
          </caption>
          <alternatives>
            <graphic id="pcbi-1000386-t002-2" xlink:href="pcbi.1000386.t002"/>
            <table frame="hsides" rules="groups">
              <colgroup span="1">
                <col align="left" span="1"/>
                <col align="center" span="1"/>
                <col align="center" span="1"/>
              </colgroup>
              <thead>
                <tr>
                  <td align="left" rowspan="1" colspan="1"/>
                  <td align="left" rowspan="1" colspan="1">SHRiMP</td>
                  <td align="left" rowspan="1" colspan="1">SOLiD Mapper</td>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="left" rowspan="1" colspan="1">Uniquely-Mapped Reads</td>
                  <td align="left" rowspan="1" colspan="1">51,856,904 (38.5%)</td>
                  <td align="left" rowspan="1" colspan="1">15,268,771 (11.3%)</td>
                </tr>
                <tr>
                  <td align="left" rowspan="1" colspan="1">Non-Uniquely-Mapped Reads</td>
                  <td align="left" rowspan="1" colspan="1">64,252,692 (47.7%)</td>
                  <td align="left" rowspan="1" colspan="1">12,602,387 (9.4%)</td>
                </tr>
                <tr>
                  <td align="left" rowspan="1" colspan="1">Unmapped Reads</td>
                  <td align="left" rowspan="1" colspan="1">18,657,736 (13.8%)</td>
                  <td align="left" rowspan="1" colspan="1">106,896,174 (79.3%)</td>
                </tr>
                <tr>
                  <td align="left" rowspan="1" colspan="1">Average Coverage (Uniquely-Mapped Reads)</td>
                  <td align="left" rowspan="1" colspan="1">10.3</td>
                  <td align="left" rowspan="1" colspan="1">3.0</td>
                </tr>
                <tr>
                  <td align="left" rowspan="1" colspan="1">Median Coverage (Uniquely-Mapped Reads)</td>
                  <td align="left" rowspan="1" colspan="1">8</td>
                  <td align="left" rowspan="1" colspan="1">1</td>
                </tr>
                <tr>
                  <td align="left" rowspan="1" colspan="1">SNPs</td>
                  <td align="left" rowspan="1" colspan="1">2,119,720</td>
                  <td align="left" rowspan="1" colspan="1">383,099</td>
                </tr>
                <tr>
                  <td align="left" rowspan="1" colspan="1">Deletions (1–5 bp)</td>
                  <td align="left" rowspan="1" colspan="1">51,592</td>
                  <td align="left" rowspan="1" colspan="1">0</td>
                </tr>
                <tr>
                  <td align="left" rowspan="1" colspan="1">Insertions (1–5 bp)</td>
                  <td align="left" rowspan="1" colspan="1">19,970</td>
                  <td align="left" rowspan="1" colspan="1">0</td>
                </tr>
              </tbody>
            </table>
          </alternatives>
          <table-wrap-foot>
            <fn id="nt102">
              <p>Non-uniquely-mapped reads have at least two alignments, none of which is significantly better than the others (see <xref ref-type="sec" rid="s3">Methods</xref>). SNPs and indels have at least four supporting reads.</p>
            </fn>
          </table-wrap-foot>
        </table-wrap>
        <p>The alignment data contains noise due to two types of errors: sequencing errors and chance alignments. Chance alignments are a significant problem for short reads, particularly with the low alignment score thresholds necessary for mapping reads containing significant variation. Reads containing both sequence variation and sequencing errors are even more likely to map to the wrong position in the reference sequence. To combat the high false-positive rate, for the remaining analysis we focused on a high-quality subset of the data consisting of sequence variants supported by at least four independent reads.</p>
        <p>Across the genome SHRiMP detected 2,119,720 SNPs supported by at least four reads. For comparison, we used the SOLiD aligner provided by Applied Biosystems to map the reads to the genome with up to three mismatches, where each mismatch can be either a single color-space mismatch or a pair of adjacent mismatches consistent with the presence of a SNP. Compared to the SOLiD mapper, SHRiMP mapped 4.2 times as many reads and found 5.5 times as many SNPs. The AB mapper, however, was a lot faster, requiring 255 CPU hours to complete the alignments, or roughly 50× faster than SHRiMP. While it is possible to run the mapper with greater sensitivity, allowing for more errors and SNPs, and thus more mapped reads, doing so would surrender much of the runtime advantage and still not overcome its fundamental inability to detect insertion and deletion polymorphisms. SHRiMP, on the other hand, is capable of handling indels, and detected tens of thousands of them.</p>
        <p>SHRiMP detected 51,592 deletions and 19,970 insertions of size 1–5 bp. The observed ratio of 2.5× between insertions and deletions for the <italic>C. savignyi</italic> data is biased by the construction of the reference genome – whenever the two haplomes differed, the reference agreed with the longer one. While there is a smaller inherent bias against detecting insertions (reads containing nucleotides not present in the reference) compared to deletions because a read spanning a deletion only incurs a gap penalty whereas an insertion both incurs a gap penalty and has fewer bases that match the reference. For simulated data (see next section) this bias was only ∼5% for single basepair indels (data not shown). The size distribution of the detected indels (<xref ref-type="fig" rid="pcbi-1000386-g005">Figure 5A</xref>) drops more rapidly with length than expected <xref rid="pcbi.1000386-Small1" ref-type="bibr">[11]</xref>, but this detection bias against longer indels is not surprising since longer indels have lower alignments scores.</p>
        <fig id="pcbi-1000386-g005" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pcbi.1000386.g005</object-id>
          <label>Figure 5</label>
          <caption>
            <title>Size distribution of indels.</title>
            <p>(A) and distance between adjacent SNPs (B) detected by SHRiMP. The distance between adjacent SNPs shows a clear 3-periodicity, due to the fact that a significant fraction of the non-repetitive <italic>C. savignyi</italic> genome is coding.</p>
          </caption>
          <graphic xlink:href="pcbi.1000386.g005"/>
        </fig>
        <p>Mapping <italic>C. savignyi</italic> sequence is challenging primarily because the population contains so much variation. <xref ref-type="fig" rid="pcbi-1000386-g005">Figure 5B</xref> shows the high frequency of closely spaced SNPs detected by SHRiMP. Mappers that can only detect nearly exact matches fail to map the reads overlapping these dense SNP clusters. Note that even though the reads are generated from the whole genome, a significant fraction of the non-repetitive <italic>C. savignyi</italic> genome is coding, making it is possible to see the typical three-periodicity of SNPs in coding regions. Furthermore SHRiMP recovers microindels, which are completely invisible to ungapped aligners and yet account for a significant fraction of sequence variation in <italic>C. savignyi</italic>.</p>
      </sec>
      <sec id="s2d3">
        <title>Analysis of simulated data</title>
        <p>In order to further validate the accuracy of the SHRiMP alignments we have designed simulated experiments, where we sampled random locations from the <italic>C. savignyi</italic> genome, introduced polymorphisms (SNPs and indels) at the rates previously observed in the C. savignyi genome <xref rid="pcbi.1000386-Small2" ref-type="bibr">[22]</xref>, added sequencing errors at rates observed in our <italic>C. savignyi</italic> dataset (2–7%, depending on the position in the read), and mapped the reads back to the original genome. Each sampled read could have multiple SNPs and indels, though due to the low indel rate only a small fraction of the reads had multiple indels. We mapped the reads with SHRiMP and postprocessed with PROBCALC (<italic>pchance</italic>&lt;0.001). Considering only those reads that had a unique top hit, we computed the <bold>precision</bold> – the fraction of reads for which this unique hit was correct, and <bold>recall</bold> – the fraction of all reads that had a unique, correct hit. <xref ref-type="table" rid="pcbi-1000386-t003">Table 3</xref> shows the results of this analysis. For each read, we classified it based on the number of SNPs and the maximum indel length, and computed precision and recall for each class. With such polymorphism, we can expect the average read to have approximately 1.5 SNPs and 1.9 errors. SHRiMP was able to accurately map 76% of reads with 2 SNPs and 0 indels, at 84% precision, and nearly half of all reads with 2 SNPs and 3 bp indels at 74% precision.</p>
        <table-wrap id="pcbi-1000386-t003" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pcbi.1000386.t003</object-id>
          <label>Table 3</label>
          <caption>
            <title>Color-space mapping accuracy of SHRiMP.</title>
          </caption>
          <alternatives>
            <graphic id="pcbi-1000386-t003-3" xlink:href="pcbi.1000386.t003"/>
            <table frame="hsides" rules="groups">
              <colgroup span="1">
                <col align="left" span="1"/>
                <col align="center" span="1"/>
                <col align="center" span="1"/>
                <col align="center" span="1"/>
                <col align="center" span="1"/>
                <col align="center" span="1"/>
                <col align="center" span="1"/>
                <col align="center" span="1"/>
                <col align="center" span="1"/>
                <col align="center" span="1"/>
                <col align="center" span="1"/>
                <col align="center" span="1"/>
              </colgroup>
              <thead>
                <tr>
                  <td align="left" rowspan="1" colspan="1"/>
                  <td align="left" rowspan="1" colspan="1"/>
                  <td colspan="10" align="left" rowspan="1">Number of SNPs</td>
                </tr>
                <tr>
                  <td align="left" rowspan="1" colspan="1"/>
                  <td align="left" rowspan="1" colspan="1"/>
                  <td colspan="2" align="left" rowspan="1">0</td>
                  <td colspan="2" align="left" rowspan="1">1</td>
                  <td colspan="2" align="left" rowspan="1">2</td>
                  <td colspan="2" align="left" rowspan="1">3</td>
                  <td colspan="2" align="left" rowspan="1">4</td>
                </tr>
                <tr>
                  <td align="left" rowspan="1" colspan="1"/>
                  <td align="left" rowspan="1" colspan="1"/>
                  <td align="left" rowspan="1" colspan="1">Prec.</td>
                  <td align="left" rowspan="1" colspan="1">Rec.</td>
                  <td align="left" rowspan="1" colspan="1">Prec.</td>
                  <td align="left" rowspan="1" colspan="1">Rec.</td>
                  <td align="left" rowspan="1" colspan="1">Prec.</td>
                  <td align="left" rowspan="1" colspan="1">Rec.</td>
                  <td align="left" rowspan="1" colspan="1">Prec.</td>
                  <td align="left" rowspan="1" colspan="1">Rec.</td>
                  <td align="left" rowspan="1" colspan="1">Prec.</td>
                  <td align="left" rowspan="1" colspan="1">Rec.</td>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="left" rowspan="1" colspan="1"/>
                  <td align="left" rowspan="1" colspan="1">0</td>
                  <td align="left" rowspan="1" colspan="1">85.7</td>
                  <td align="left" rowspan="1" colspan="1">83.2</td>
                  <td align="left" rowspan="1" colspan="1">84.8</td>
                  <td align="left" rowspan="1" colspan="1">81.3</td>
                  <td align="left" rowspan="1" colspan="1">83.5</td>
                  <td align="left" rowspan="1" colspan="1">76.6</td>
                  <td align="left" rowspan="1" colspan="1">80.6</td>
                  <td align="left" rowspan="1" colspan="1">65.2</td>
                  <td align="left" rowspan="1" colspan="1">75.6</td>
                  <td align="left" rowspan="1" colspan="1">46.8</td>
                </tr>
                <tr>
                  <td align="left" rowspan="1" colspan="1">Max</td>
                  <td align="left" rowspan="1" colspan="1">1</td>
                  <td align="left" rowspan="1" colspan="1">83.8</td>
                  <td align="left" rowspan="1" colspan="1">79.4</td>
                  <td align="left" rowspan="1" colspan="1">82.2</td>
                  <td align="left" rowspan="1" colspan="1">74.0</td>
                  <td align="left" rowspan="1" colspan="1">79.4</td>
                  <td align="left" rowspan="1" colspan="1">62.6</td>
                  <td align="left" rowspan="1" colspan="1">72.8</td>
                  <td align="left" rowspan="1" colspan="1">43.2</td>
                  <td align="left" rowspan="1" colspan="1">63.1</td>
                  <td align="left" rowspan="1" colspan="1">24.7</td>
                </tr>
                <tr>
                  <td align="left" rowspan="1" colspan="1">Indel</td>
                  <td align="left" rowspan="1" colspan="1">2</td>
                  <td align="left" rowspan="1" colspan="1">83.2</td>
                  <td align="left" rowspan="1" colspan="1">77.1</td>
                  <td align="left" rowspan="1" colspan="1">80.8</td>
                  <td align="left" rowspan="1" colspan="1">69.6</td>
                  <td align="left" rowspan="1" colspan="1">77.9</td>
                  <td align="left" rowspan="1" colspan="1">56.6</td>
                  <td align="left" rowspan="1" colspan="1">68.2</td>
                  <td align="left" rowspan="1" colspan="1">36.4</td>
                  <td align="left" rowspan="1" colspan="1">56.4</td>
                  <td align="left" rowspan="1" colspan="1">18.9</td>
                </tr>
                <tr>
                  <td align="left" rowspan="1" colspan="1">Length</td>
                  <td align="left" rowspan="1" colspan="1">3</td>
                  <td align="left" rowspan="1" colspan="1">80.7</td>
                  <td align="left" rowspan="1" colspan="1">71.0</td>
                  <td align="left" rowspan="1" colspan="1">79.6</td>
                  <td align="left" rowspan="1" colspan="1">64.2</td>
                  <td align="left" rowspan="1" colspan="1">73.6</td>
                  <td align="left" rowspan="1" colspan="1">48.3</td>
                  <td align="left" rowspan="1" colspan="1">66.5</td>
                  <td align="left" rowspan="1" colspan="1">31.5</td>
                  <td align="left" rowspan="1" colspan="1">57.1</td>
                  <td align="left" rowspan="1" colspan="1">16.6</td>
                </tr>
                <tr>
                  <td align="left" rowspan="1" colspan="1"/>
                  <td align="left" rowspan="1" colspan="1">4</td>
                  <td align="left" rowspan="1" colspan="1">78.0</td>
                  <td align="left" rowspan="1" colspan="1">65.4</td>
                  <td align="left" rowspan="1" colspan="1">76.5</td>
                  <td align="left" rowspan="1" colspan="1">56.1</td>
                  <td align="left" rowspan="1" colspan="1">71.4</td>
                  <td align="left" rowspan="1" colspan="1">41.9</td>
                  <td align="left" rowspan="1" colspan="1">60.6</td>
                  <td align="left" rowspan="1" colspan="1">23.9</td>
                  <td align="left" rowspan="1" colspan="1">50.3</td>
                  <td align="left" rowspan="1" colspan="1">12.4</td>
                </tr>
                <tr>
                  <td align="left" rowspan="1" colspan="1"/>
                  <td align="left" rowspan="1" colspan="1">5</td>
                  <td align="left" rowspan="1" colspan="1">75.9</td>
                  <td align="left" rowspan="1" colspan="1">58.9</td>
                  <td align="left" rowspan="1" colspan="1">73.0</td>
                  <td align="left" rowspan="1" colspan="1">48.1</td>
                  <td align="left" rowspan="1" colspan="1">69.7</td>
                  <td align="left" rowspan="1" colspan="1">36.6</td>
                  <td align="left" rowspan="1" colspan="1">57.0</td>
                  <td align="left" rowspan="1" colspan="1">21.3</td>
                  <td align="left" rowspan="1" colspan="1">46.0</td>
                  <td align="left" rowspan="1" colspan="1">12.7</td>
                </tr>
              </tbody>
            </table>
          </alternatives>
          <table-wrap-foot>
            <fn id="nt103">
              <p>Each cell shows the precision and recall for mapping simulated reads with varying amounts of polymorphism. SHRiMP was able to accurately map &gt;46% of all reads with either 4 SNPs or 5 bp indels, despite the large number of sequencing errors in our dataset (up to 7% towards the end of the read).</p>
            </fn>
          </table-wrap-foot>
        </table-wrap>
      </sec>
    </sec>
  </sec>
  <sec id="s3">
    <title>Methods</title>
    <sec id="s3a">
      <title>Details of the SHRiMP Algorithm</title>
      <p>The algorithm starts with a rapid k-mer hashing step to localize potential areas of similarity between the reads and the genome. All of the spaced k-mers present in the reads are indexed. Then for each k-mer in the genome, all of the matches of that particular k-mer among the reads are found. If a particular read has as many or more than a specified number of k-mer matches within a given window of the genome, we execute a vectorized Smith-Waterman step, described in the next section, to score and validate the similarity. The top <inline-formula><inline-graphic xlink:href="pcbi.1000386.e038.jpg" mimetype="image"/></inline-formula> highest-scoring regions are retained, filtered through a full backtracking Smith-Waterman algorithm, and output at the end of the program if their final scores meet a specified threshold. The SHRiMP algorithm is summarized in <xref ref-type="fig" rid="pcbi-1000386-g006">Figure 6</xref>.</p>
      <fig id="pcbi-1000386-g006" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pcbi.1000386.g006</object-id>
        <label>Figure 6</label>
        <caption>
          <title>SHRiMP Hashing technique &amp; Vectorized Alignment algorithm.</title>
          <p>A: Overview of the k-mer filtering stage within SHRiMP: A window is moved along the genome. If a particular read has a preset number of k-mers within the window the vectorized Smith-Waterman stage is run to align the read to the genome. B: Schematic of the vectorized-implementation of the Needleman-Wunsch algorithm. The red cells are the vector being computed, on the basis of the vectors computed in the last step (yellow) and the next-to-last (blue). The match/mismatch vector for the diagonal is determined by comparing one sequence with the other one reversed (indicated by the red arrow below). To obtain the set of match/mismatch positions for the next diagonal, the lower sequence needs to be shifted to the right.</p>
        </caption>
        <graphic xlink:href="pcbi.1000386.g006"/>
      </fig>
      <sec id="s3a1">
        <title>Spaced seed filter</title>
        <p>We build an index of all spaced k-mers in the reads, and query this index with the genome. Our approach was taken primarily for simplicity: our algorithm can rapidly isolate which reads have several k-mer matches within a small window by maintaining a simple circular buffer of recent positions in the genome that matched the read. Since our targeted compute platform is a cluster of batch processing machines, indexing the reads means that we can easily control memory usage and parallelism by varying the read input size and splitting the read set accordingly. Data is only loaded at program invocation; we do not stream in new reads from disk as the algorithm runs.</p>
      </sec>
      <sec id="s3a2">
        <title>Vectorized Smith-Waterman implementation</title>
        <p>The SHRiMP approach relies on a rather liberal initial filtering step, followed by a rigorous, but very fast Smith-Waterman alignment process. By maximizing the speed of the Smith-Waterman comparison, we are permitted to let the algorithm test a larger number of potential regions.</p>
        <p>Most contemporary mobile, desktop and server-class processors have special <italic>vector</italic> execution units, which perform multiple simultaneous data operations in a single instruction. For example, it is possible to add the eight individual, 16-bit elements of two 128-bit vectors in one machine instruction. Over the past decade, several methods have been devised to significantly enhance the execution speed of Smith-Waterman-type algorithms by parallelizing the computation of several cells of the dynamic programming matrix. The simplest such implementation computes the dynamic programming matrix using diagonals. Since each cell of the matrix can be computed once the cell immediately above, immediately to the left, and at the upper-left corner have been computed, one can compute each successive diagonal once the two prior diagonals have been completed. In this way, the problem can be parallelized across the length of supported diagonals (see <xref ref-type="fig" rid="pcbi-1000386-g006">Figure 6B</xref>). In most cases, this is a factor of 4 to 16. The only portion of such a ‘Wozniak’ approach that cannot be parallelized is the identification of match/mismatch scores for every cell of the matrix, which has to be done sequentially. These operations are expensive, necessitating 24 independent data loads for 8-cell vectors, and become increasingly problematic as vector sizes increase. Because memory loads cannot be ‘vectorized’, when the parallelism grows, so does the number of lookups. For example, with 16-cell vectors, the number of data loads doubles to 48.</p>
        <p>We propose an alternate method, where the running time of the fully vectorized algorithm is independent of the number of matches and mismatches in the matrix, though it only supports fixed match/mismatch scores (rather than full scoring matrices). Our key observation is that it is possible to completely parallelize the score computation for every diagonal. <xref ref-type="fig" rid="pcbi-1000386-g006">Figure 6B</xref> demonstrates the essence of our algorithm: by storing one of the sequences backwards, we can align them in such a way that a small number of logical instructions obtain the positions of matches and mismatches for a given diagonal. We then construct a vector of match and mismatch scores for every cell of the diagonal without having to use expensive and un-vectorizable load instructions or a pre-compute a ‘query profile’. In our tests, using a diagonal approach with our scoring scheme surpasses the performance of Wozniak's original algorithm and performs on par with Farrar's method <xref rid="pcbi.1000386-Farrar1" ref-type="bibr">[17]</xref>. <xref ref-type="table" rid="pcbi-1000386-t004">Table 4</xref> summarizes these results. The advantage of our method over Farrar's is that it is independent of the scores used for matches/mismatches/gaps, and it will scale better with larger vector sizes. A disadvantage is that we cannot support full scoring matrices and are restricted to match/mismatch scores, though this is less important for DNA alignment. Additionally, Farrar's method is much faster for large databases where most of the sequence is dissimilar to the query. However, this is never the case for SHRiMP as the seed scan phase targets only small, similar regions for dynamic programming. In these cases our algorithms perform similarly.</p>
        <table-wrap id="pcbi-1000386-t004" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pcbi.1000386.t004</object-id>
          <label>Table 4</label>
          <caption>
            <title>Performance (in millions of cells per second) of the various Smith-Waterman implementations, including a regular implementation (not vectorized), Wozniak's diagonal implementation with memory lookups, Farrar's method and our diagonal approach without score lookups.</title>
          </caption>
          <alternatives>
            <graphic id="pcbi-1000386-t004-4" xlink:href="pcbi.1000386.t004"/>
            <table frame="hsides" rules="groups">
              <colgroup span="1">
                <col align="left" span="1"/>
                <col align="center" span="1"/>
                <col align="center" span="1"/>
                <col align="center" span="1"/>
                <col align="center" span="1"/>
              </colgroup>
              <thead>
                <tr>
                  <td align="left" rowspan="1" colspan="1">Processor type</td>
                  <td align="left" rowspan="1" colspan="1">Unvectorized</td>
                  <td align="left" rowspan="1" colspan="1">Wozniak</td>
                  <td align="left" rowspan="1" colspan="1">Farrar</td>
                  <td align="left" rowspan="1" colspan="1">SHRiMP</td>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="left" rowspan="1" colspan="1">
                    <bold>Xeon</bold>
                  </td>
                  <td align="left" rowspan="1" colspan="1">97</td>
                  <td align="left" rowspan="1" colspan="1">261</td>
                  <td align="left" rowspan="1" colspan="1">335</td>
                  <td align="left" rowspan="1" colspan="1">338</td>
                </tr>
                <tr>
                  <td align="left" rowspan="1" colspan="1">
                    <bold>Core 2</bold>
                  </td>
                  <td align="left" rowspan="1" colspan="1">105</td>
                  <td align="left" rowspan="1" colspan="1">285</td>
                  <td align="left" rowspan="1" colspan="1">533</td>
                  <td align="left" rowspan="1" colspan="1">537</td>
                </tr>
              </tbody>
            </table>
          </alternatives>
          <table-wrap-foot>
            <fn id="nt104">
              <p>We inserted each into SHRiMP, and used SHRiMP to align 50 thousand reads to a reference genome with default parameters. The improvements of the Core 2 architecture for vectored instructions lead to a significant speedup for our approach and Farrar's, while Wozniak's algorithm slight improvement is due to the slow match/mismatch lookups.</p>
            </fn>
          </table-wrap-foot>
        </table-wrap>
      </sec>
      <sec id="s3a3">
        <title>Final pass</title>
        <p>The vectorized Smith-Waterman approach described above is used to rapidly determine if the read has a strong match to the local genomic sequence. The locations of the top <inline-formula><inline-graphic xlink:href="pcbi.1000386.e039.jpg" mimetype="image"/></inline-formula> hits for each read are stored in a heap data structure, which is updated after every invocation of the vectorized Smith-Waterman algorithm if the heap is not full, or if the attained score is greater than or equal to the lowest scoring top hit. Once the whole genome is processed, highest scoring <inline-formula><inline-graphic xlink:href="pcbi.1000386.e040.jpg" mimetype="image"/></inline-formula> matches are re-aligned using the appropriate full color- or letter-space Smith-Waterman algorithm. This is necessary, as the vectorized Smith-Waterman algorithm described above only computes the maximum score of an alignment, not the traceback, as this would require a much more complicated and costly implementation. Instead, at most only the top <inline-formula><inline-graphic xlink:href="pcbi.1000386.e041.jpg" mimetype="image"/></inline-formula> alignments for each read are re-aligned in the final step.</p>
      </sec>
    </sec>
    <sec id="s3b">
      <title>Computing Statistics: <italic>pchance</italic> and <italic>pgenome</italic>
</title>
      <p>In <italic>Computing Statistics for Single Reads</italic>, we briefly introduced the concepts of the <italic>pchance</italic>, <italic>pgenome</italic> and <italic>normalized odds</italic> of a hit. In this section we expand on the details regarding the construction of <italic>pchance</italic> and <italic>pgenome</italic>. In these formulas we make use the following definitions:</p>
      <list list-type="bullet">
        <list-item>
          <p><inline-formula><inline-graphic xlink:href="pcbi.1000386.e042.jpg" mimetype="image"/></inline-formula> is the genome length</p>
        </list-item>
        <list-item>
          <p><inline-formula><inline-graphic xlink:href="pcbi.1000386.e043.jpg" mimetype="image"/></inline-formula> is the alignment length (note this may be different from the read length, which is constant)</p>
        </list-item>
        <list-item>
          <p><inline-formula><inline-graphic xlink:href="pcbi.1000386.e044.jpg" mimetype="image"/></inline-formula> is the number of substitutions (mismatches) in our alignment</p>
        </list-item>
        <list-item>
          <p><inline-formula><inline-graphic xlink:href="pcbi.1000386.e045.jpg" mimetype="image"/></inline-formula> is the number of nucleotide insertions in our alignment, where the genome is the “original” sequence. For example, if the genome is AC-G and a read is ACTG, there is an insertion of a T.</p>
        </list-item>
        <list-item>
          <p><inline-formula><inline-graphic xlink:href="pcbi.1000386.e046.jpg" mimetype="image"/></inline-formula> is the number of nucleotide deletions in our alignment. For example, if the genome is ACTG and a read is A-TG, there is a deletion of a C.</p>
        </list-item>
        <list-item>
          <p><inline-formula><inline-graphic xlink:href="pcbi.1000386.e047.jpg" mimetype="image"/></inline-formula> is the number of insertion events (for example, for a single insertion of length 3 we have <inline-formula><inline-graphic xlink:href="pcbi.1000386.e048.jpg" mimetype="image"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pcbi.1000386.e049.jpg" mimetype="image"/></inline-formula>.) <inline-formula><inline-graphic xlink:href="pcbi.1000386.e050.jpg" mimetype="image"/></inline-formula> is similar.</p>
        </list-item>
        <list-item>
          <p><inline-formula><inline-graphic xlink:href="pcbi.1000386.e051.jpg" mimetype="image"/></inline-formula>: following the previous definition, <inline-formula><inline-graphic xlink:href="pcbi.1000386.e052.jpg" mimetype="image"/></inline-formula> will describe the number of permutations of insertion events. To determine the number of <italic>distinguishable</italic> permutations, we need to first look at the frequency of insertion events of a certain size, <inline-formula><inline-graphic xlink:href="pcbi.1000386.e053.jpg" mimetype="image"/></inline-formula>. For example, is we have 3 insertions of size 2, we need to divide the permutations by <inline-formula><inline-graphic xlink:href="pcbi.1000386.e054.jpg" mimetype="image"/></inline-formula>. Therefore, the <italic>distinguishable</italic> permutations of insertion events can be written as:<disp-formula><graphic xlink:href="pcbi.1000386.e055.jpg" mimetype="image" position="float"/></disp-formula>
</p>
        </list-item>
      </list>
      <p>Below, we refer to this denominator term <inline-formula><inline-graphic xlink:href="pcbi.1000386.e056.jpg" mimetype="image"/></inline-formula> as <inline-formula><inline-graphic xlink:href="pcbi.1000386.e057.jpg" mimetype="image"/></inline-formula>. We similarly define <inline-formula><inline-graphic xlink:href="pcbi.1000386.e058.jpg" mimetype="image"/></inline-formula>.</p>
      <list list-type="bullet">
        <list-item>
          <p><inline-formula><inline-graphic xlink:href="pcbi.1000386.e059.jpg" mimetype="image"/></inline-formula> describes the number of ways to assign <inline-formula><inline-graphic xlink:href="pcbi.1000386.e060.jpg" mimetype="image"/></inline-formula> indistinguishable objects in <inline-formula><inline-graphic xlink:href="pcbi.1000386.e061.jpg" mimetype="image"/></inline-formula> indistinguishable bins, which is recursively defined by <inline-formula><inline-graphic xlink:href="pcbi.1000386.e062.jpg" mimetype="image"/></inline-formula> with <inline-formula><inline-graphic xlink:href="pcbi.1000386.e063.jpg" mimetype="image"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pcbi.1000386.e064.jpg" mimetype="image"/></inline-formula>.</p>
        </list-item>
      </list>
      <sec id="s3b1">
        <title>pchance</title>
        <p>We begin with the mathematical formulation of <italic>pchance</italic> (defined above):<disp-formula><graphic xlink:href="pcbi.1000386.e065.jpg" mimetype="image" position="float"/><label>(7)</label></disp-formula>where, as described before, <inline-formula><inline-graphic xlink:href="pcbi.1000386.e066.jpg" mimetype="image"/></inline-formula> is the number of possible unique sequences with the given edit distance as a fraction of all possible unique reads of length <inline-formula><inline-graphic xlink:href="pcbi.1000386.e067.jpg" mimetype="image"/></inline-formula>. Thus, <inline-formula><inline-graphic xlink:href="pcbi.1000386.e068.jpg" mimetype="image"/></inline-formula> gives us the probability that the current read has aligned by chance to a random genome of the size of a read. To this term, we add a correction factor of <inline-formula><inline-graphic xlink:href="pcbi.1000386.e069.jpg" mimetype="image"/></inline-formula> which accounts for all the possible places the alignment of size <inline-formula><inline-graphic xlink:href="pcbi.1000386.e070.jpg" mimetype="image"/></inline-formula> might match. For example, if the <inline-formula><inline-graphic xlink:href="pcbi.1000386.e071.jpg" mimetype="image"/></inline-formula> is 25 and we have a match of size 22, we should count <inline-formula><inline-graphic xlink:href="pcbi.1000386.e072.jpg" mimetype="image"/></inline-formula> for every position where this match could be found, that is 25−22+1 = 4. Finally, to get the probability that the current read has aligned by chance to a random genome of size <inline-formula><inline-graphic xlink:href="pcbi.1000386.e073.jpg" mimetype="image"/></inline-formula> (instead of size <inline-formula><inline-graphic xlink:href="pcbi.1000386.e074.jpg" mimetype="image"/></inline-formula>), we get formula (7).</p>
        <p>The factor that lies at the core of this calculation is <inline-formula><inline-graphic xlink:href="pcbi.1000386.e075.jpg" mimetype="image"/></inline-formula>, the number of possible unique sequences that would align to the read with the given edit distance. We have shown the definition of <inline-formula><inline-graphic xlink:href="pcbi.1000386.e076.jpg" mimetype="image"/></inline-formula>, which computes <inline-formula><inline-graphic xlink:href="pcbi.1000386.e077.jpg" mimetype="image"/></inline-formula> when there are no indels in the alignment:<disp-formula><graphic xlink:href="pcbi.1000386.e078.jpg" mimetype="image" position="float"/><label>(8)</label></disp-formula>
</p>
        <p>However, the calculation of the number of references to which a read will map with a particular <italic>indel</italic> count, <inline-formula><inline-graphic xlink:href="pcbi.1000386.e079.jpg" mimetype="image"/></inline-formula>, depends on the sequence of that read and is significantly more complicated. We define a lower and upper bound on <inline-formula><inline-graphic xlink:href="pcbi.1000386.e080.jpg" mimetype="image"/></inline-formula> in this case: a lower bound (least number of unique sequences) occurs when the current read is one repeated nucleotide, for example [<named-content content-type="gene">AAAAAA</named-content>], and the higher bound occurs with the most change in nearby nucleotides, say [<named-content content-type="gene">ACGTAC</named-content>]. In the former case, we need to look at the deletion events from the genome to this read, consider all the combinations of that number of deletion events and deleted nucleotides, as well as all the places where these combinations may occur. This gives the formula<disp-formula><graphic xlink:href="pcbi.1000386.e081.jpg" mimetype="image" position="float"/><label>(9)</label></disp-formula>Looking for the upper bound, we note that the places and combinations of insertions also matters in generating unique sequences, therefore giving us two extra terms involving <inline-formula><inline-graphic xlink:href="pcbi.1000386.e082.jpg" mimetype="image"/></inline-formula>
<disp-formula><graphic xlink:href="pcbi.1000386.e083.jpg" mimetype="image" position="float"/><label>(10)</label></disp-formula>
<disp-formula><graphic xlink:href="pcbi.1000386.e084.jpg" mimetype="image" position="float"/><label>(11)</label></disp-formula>
</p>
        <p>In order to estimate the correct value for <inline-formula><inline-graphic xlink:href="pcbi.1000386.e085.jpg" mimetype="image"/></inline-formula>, we estimated the average complexity of the reads in our dataset (i.e., between the simplest [<named-content content-type="gene">AAAAA…</named-content>] and the most complex [<named-content content-type="gene">ACGTACGT…</named-content>]). And have found that the mean observed <inline-formula><inline-graphic xlink:href="pcbi.1000386.e086.jpg" mimetype="image"/></inline-formula> could be accurately estimated by<disp-formula><graphic xlink:href="pcbi.1000386.e087.jpg" mimetype="image" position="float"/><label>(12)</label></disp-formula>Finally, we can approximate the total <inline-formula><inline-graphic xlink:href="pcbi.1000386.e088.jpg" mimetype="image"/></inline-formula> as<disp-formula><graphic xlink:href="pcbi.1000386.e089.jpg" mimetype="image" position="float"/><label>(13)</label></disp-formula>
</p>
      </sec>
      <sec id="s3b2">
        <title>pgenome</title>
        <p>In <italic>Computing Statistics for Single Reads</italic>, we defined our pgenome factor as <inline-formula><inline-graphic xlink:href="pcbi.1000386.e090.jpg" mimetype="image"/></inline-formula>, where<disp-formula><graphic xlink:href="pcbi.1000386.e091.jpg" mimetype="image" position="float"/><label>(14)</label></disp-formula>with <inline-formula><inline-graphic xlink:href="pcbi.1000386.e092.jpg" mimetype="image"/></inline-formula> the rate of event <inline-formula><inline-graphic xlink:href="pcbi.1000386.e093.jpg" mimetype="image"/></inline-formula> (estimated via bootstrapping) and <inline-formula><inline-graphic xlink:href="pcbi.1000386.e094.jpg" mimetype="image"/></inline-formula> the number of observed events of type <inline-formula><inline-graphic xlink:href="pcbi.1000386.e095.jpg" mimetype="image"/></inline-formula> in the current alignment. We wrote <inline-formula><inline-graphic xlink:href="pcbi.1000386.e096.jpg" mimetype="image"/></inline-formula> as an approximation because there are small corrections to this formula for each probability that is part of pgenome. First, for the <italic>error</italic> term <inline-formula><inline-graphic xlink:href="pcbi.1000386.e097.jpg" mimetype="image"/></inline-formula>, the number of sites that can support errors is in fact one minus the read size, giving us<disp-formula><graphic xlink:href="pcbi.1000386.e098.jpg" mimetype="image" position="float"/><label>(15)</label></disp-formula>When considering substitutions, we can have changes at any of the inner nucleotides, excluding erroneous sites:<disp-formula><graphic xlink:href="pcbi.1000386.e099.jpg" mimetype="image" position="float"/><label>(16)</label></disp-formula>As before, when we look at alignments that involve indels, the formula becomes more complex. In the case of <italic>pgenome</italic>, we do not have to consider the various placements of insertion or deletion events, but we do have to consider, for fixed placements of events, the various combinations of the total number of insertions and deletions into a set number of events.<disp-formula><graphic xlink:href="pcbi.1000386.e100.jpg" mimetype="image" position="float"/><label>(17)</label></disp-formula>
</p>
      </sec>
      <sec id="s3b3">
        <title>Computing mate pairs with statistics</title>
        <p>In this section we provide several details for the implementation, usage and statistics of the matepair post-processing step introduced in <italic>Computing Statistics for Mate-pairs</italic>. We define a <bold>good</bold> matepair mapping as a mapping whose distance <inline-formula><inline-graphic xlink:href="pcbi.1000386.e101.jpg" mimetype="image"/></inline-formula> (between the two reads) are smaller than some chosen limit <inline-formula><inline-graphic xlink:href="pcbi.1000386.e102.jpg" mimetype="image"/></inline-formula>, and for which the read mappings are in a consistent orientation and strand(i.e. R<sub>+</sub>F<sub>+</sub> or F<sub>−</sub>R<sub>−</sub>). First, probcalc_mp will compute a matepair distance and standard deviation by looking at all the connected forward and reverse reads - all matepairs - and adding the distance of any matepair with exactly one <italic>good</italic> mapping to a histogram. Optionally, one can choose to use only unique good mappings, or only use a certain number of mappings (say, the first 100,000) to speed up the program.</p>
        <p>Next, we call a matepair <bold>concordant</bold> if it has at least one <italic>good</italic> mapping, and otherwise we call it <bold>discordant</bold>. Depending on the task, probcalc_mp can output all concordant matepairs, or all discordant matepairs. For each matepair mapping, probcalc_mp will compute the pgenome and pchance, as introduced in <italic>Computing Mate Pairs with Statistics</italic>.</p>
      </sec>
    </sec>
    <sec id="s3c">
      <title>Parameters</title>
      <p>For the <italic>C. savignyi</italic> polymorphism analysis we ran SHRiMP with the following parameters. We used the spaced seed “11110111” and required two hits per 40-base window to invoke the Smith-Waterman algorithm. The Smith-Waterman scoring parameters were set to +100 for a matching base, −90 for a mismatch, −250 and −100 to open and extend a gap respectively, and −300 for a crossover (sequencing error). The minimum Smith-Waterman score thresholds were 1000 for the vectorized first pass and 1275 for the final alignment pass. We discarded alignments with <italic>pchance</italic> less than 0.05, and to remove reads from known repetitive sequence we required <italic>normodds</italic> to be at least 0.8.</p>
    </sec>
  </sec>
</body>
<back>
  <ack>
    <p>We thank Ziming Weng for preparing the <italic>C. savignyi</italic> library and Cheryl Smith for sequencing the library. We also thank Aston Wallis for proofing the manuscript.</p>
  </ack>
  <fn-group>
    <fn fn-type="COI-statement">
      <p>The authors have declared that no competing interests exist.</p>
    </fn>
    <fn fn-type="financial-disclosure">
      <p>This work was sponsored by Natural Sciences and Engineering Research Council (NSERC) of Canada Undergraduate Student Research Awards, Canadian Institute for Health Research (CIHR), Applied Biosystems, NSERC Discovery Grant, MITACS, and a Canada Foundation for Innovation equipment grant. Computational resources were provided by the Stanford BioX2 compute cluster, supported by NSF award CNS-0619926. The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</p>
    </fn>
  </fn-group>
  <ref-list>
    <title>References</title>
    <ref id="pcbi.1000386-Wang1">
      <label>1</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Tian</surname>
            <given-names>G</given-names>
          </name>
          <etal/>
        </person-group>
        <year>2008</year>
        <article-title>The diploid genome sequence of an asian individual.</article-title>
        <source>Nature</source>
        <volume>456</volume>
        <fpage>60</fpage>
        <lpage>65</lpage>
        <pub-id pub-id-type="pmid">18987735</pub-id>
      </element-citation>
    </ref>
    <ref id="pcbi.1000386-Bentley1">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bentley</surname>
            <given-names>DR</given-names>
          </name>
          <name>
            <surname>Balasubramanian</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Swerdlow</surname>
            <given-names>HP</given-names>
          </name>
          <name>
            <surname>Smith</surname>
            <given-names>GP</given-names>
          </name>
          <name>
            <surname>Milton</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <year>2008</year>
        <article-title>Accurate whole human genome sequencing using reversible terminator chemistry.</article-title>
        <source>Nature</source>
        <volume>456</volume>
        <fpage>53</fpage>
        <lpage>59</lpage>
        <pub-id pub-id-type="pmid">18987734</pub-id>
      </element-citation>
    </ref>
    <ref id="pcbi.1000386-Ley1">
      <label>3</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ley</surname>
            <given-names>TJ</given-names>
          </name>
          <name>
            <surname>Mardis</surname>
            <given-names>ER</given-names>
          </name>
          <name>
            <surname>Ding</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Fulton</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Mclellan</surname>
            <given-names>MD</given-names>
          </name>
          <etal/>
        </person-group>
        <year>2008</year>
        <article-title>DNA sequencing of a cytogenetically normal acute myeloid leukaemia genome.</article-title>
        <source>Nature</source>
        <volume>456</volume>
        <fpage>66</fpage>
        <lpage>72</lpage>
        <pub-id pub-id-type="pmid">18987736</pub-id>
      </element-citation>
    </ref>
    <ref id="pcbi.1000386-Bowtie.1">
      <label>4</label>
      <mixed-citation publication-type="other">
        <comment>Bowtie. <ext-link ext-link-type="uri" xlink:href="http://bowtie-bio.sourceforge.net">http://bowtie-bio.sourceforge.net</ext-link></comment>
      </mixed-citation>
    </ref>
    <ref id="pcbi.1000386-mapreads.1">
      <label>5</label>
      <mixed-citation publication-type="other">
        <comment>mapreads. <ext-link ext-link-type="uri" xlink:href="http://www.solidsoftwaretools.com/gf/project/mapreads">http://www.solidsoftwaretools.com/gf/project/mapreads</ext-link></comment>
      </mixed-citation>
    </ref>
    <ref id="pcbi.1000386-Maq.1">
      <label>6</label>
      <mixed-citation publication-type="other">
        <comment>Maq. <ext-link ext-link-type="uri" xlink:href="http://maq.sourceforge.net">http://maq.sourceforge.net</ext-link></comment>
      </mixed-citation>
    </ref>
    <ref id="pcbi.1000386-Li1">
      <label>7</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Ma</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Kisman</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Tromp</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <year>2004</year>
        <article-title>Patternhunter ii: highly sensitive and fast homology search.</article-title>
        <source>J Bioinform Comput Biol</source>
        <volume>2</volume>
        <fpage>417</fpage>
        <lpage>439</lpage>
        <pub-id pub-id-type="pmid">15359419</pub-id>
      </element-citation>
    </ref>
    <ref id="pcbi.1000386-Li2">
      <label>8</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Kristiansen</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <year>2008</year>
        <article-title>SOAP: short oligonucleotide alignment program.</article-title>
        <source>Bioinformatics</source>
      </element-citation>
    </ref>
    <ref id="pcbi.1000386-Lin1">
      <label>9</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lin</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>MQ</given-names>
          </name>
          <name>
            <surname>Ma</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <year>2008</year>
        <article-title>Zoom! zillions of oligos mapped.</article-title>
        <source>Bioinformatics</source>
        <volume>24</volume>
        <fpage>2431</fpage>
        <lpage>2437</lpage>
        <pub-id pub-id-type="pmid">18684737</pub-id>
      </element-citation>
    </ref>
    <ref id="pcbi.1000386-Ma1">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ma</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Tromp</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <year>2002</year>
        <article-title>Patternhunter: faster and more sensitive homology search.</article-title>
        <source>Bioinformatics</source>
        <volume>18</volume>
        <fpage>440</fpage>
        <lpage>445</lpage>
        <pub-id pub-id-type="pmid">11934743</pub-id>
      </element-citation>
    </ref>
    <ref id="pcbi.1000386-Small1">
      <label>11</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Small</surname>
            <given-names>KS</given-names>
          </name>
          <name>
            <surname>Brudno</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Hill</surname>
            <given-names>MM</given-names>
          </name>
          <name>
            <surname>Sidow</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <year>2007</year>
        <article-title>Extreme genomic variation in a natural population.</article-title>
        <source>PNAS</source>
        <volume>104</volume>
        <fpage>5698</fpage>
        <lpage>5703</lpage>
        <pub-id pub-id-type="pmid">17372217</pub-id>
      </element-citation>
    </ref>
    <ref id="pcbi.1000386-Buhler1">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Buhler</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Tompa</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <year>2002</year>
        <article-title>Finding motifs using random projections.</article-title>
        <source>J Comput Biol</source>
        <volume>9</volume>
        <fpage>225</fpage>
        <lpage>242</lpage>
        <pub-id pub-id-type="pmid">12015879</pub-id>
      </element-citation>
    </ref>
    <ref id="pcbi.1000386-Ondov1">
      <label>13</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ondov</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Varadarajan</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Passalacqua</surname>
            <given-names>KDD</given-names>
          </name>
          <name>
            <surname>Bergman</surname>
            <given-names>NHH</given-names>
          </name>
        </person-group>
        <year>2008</year>
        <article-title>Efficient mapping of applied biosystems solid sequence data to a reference genome for functional genomic applications.</article-title>
        <source>Bioinformatics (Oxford, England)</source>
      </element-citation>
    </ref>
    <ref id="pcbi.1000386-Rasmussen1">
      <label>14</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rasmussen</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Stoye</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>EW</given-names>
          </name>
        </person-group>
        <year>2006</year>
        <article-title>Efficient q-gram filters for finding all e-matches over a given length.</article-title>
        <source>J of Computational Biology</source>
        <volume>13</volume>
        <fpage>296</fpage>
        <lpage>308</lpage>
      </element-citation>
    </ref>
    <ref id="pcbi.1000386-Califano1">
      <label>15</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Califano</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Rigoutsos</surname>
            <given-names>I</given-names>
          </name>
        </person-group>
        <year>1993</year>
        <article-title>Flash: a fast look-up algorithm for string homology.</article-title>
        <source>Computer Vision and Pattern Recognition, 1993 Proceedings CVPR '93, 1993 IEEE Computer Society Conference on</source>
        <fpage>353</fpage>
        <lpage>359</lpage>
      </element-citation>
    </ref>
    <ref id="pcbi.1000386-Rognes1">
      <label>16</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rognes</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Seeberg</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <year>2000</year>
        <article-title>Six-fold speed-up of smith-waterman sequence database searches using parallel processing on common microprocessors.</article-title>
        <source>Bioinformatics</source>
        <volume>16</volume>
        <fpage>699</fpage>
        <lpage>706</lpage>
        <pub-id pub-id-type="pmid">11099256</pub-id>
      </element-citation>
    </ref>
    <ref id="pcbi.1000386-Farrar1">
      <label>17</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Farrar</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <year>2007</year>
        <article-title>Striped smith-waterman speeds database searches six times over other simd implementations.</article-title>
        <source>Bioinformatics</source>
        <volume>23</volume>
        <fpage>156</fpage>
        <lpage>161</lpage>
        <pub-id pub-id-type="pmid">17110365</pub-id>
      </element-citation>
    </ref>
    <ref id="pcbi.1000386-Wozniak1">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wozniak</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <year>1997</year>
        <article-title>Using video-oriented instructions to speed up sequence comparison.</article-title>
        <source>Comput Appl Biosci</source>
        <fpage>145</fpage>
        <lpage>150</lpage>
        <pub-id pub-id-type="pmid">9146961</pub-id>
      </element-citation>
    </ref>
    <ref id="pcbi.1000386-Smith1">
      <label>19</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smith</surname>
            <given-names>TF</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>MS</given-names>
          </name>
        </person-group>
        <year>1981</year>
        <article-title>Identification of common molecular subsequences.</article-title>
        <source>J Mol Biol</source>
        <volume>147</volume>
        <fpage>195</fpage>
        <lpage>197</lpage>
        <pub-id pub-id-type="pmid">7265238</pub-id>
      </element-citation>
    </ref>
    <ref id="pcbi.1000386-Yanovsky1">
      <label>20</label>
      <element-citation publication-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Yanovsky</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Rumble</surname>
            <given-names>SM</given-names>
          </name>
          <name>
            <surname>Brudno</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <year>2008</year>
        <article-title>Read mapping algorithms for single molecule sequencing data.</article-title>
        <fpage>38</fpage>
        <lpage>49</lpage>
        <comment>In: WABI. Springer, volume 5251 of <italic>Lecture Notes in Computer Science</italic></comment>
        <comment>URL <ext-link ext-link-type="uri" xlink:href="http://dblp.uni-trier.de/db/conf/wabi/wabi2008.html">http://dblp.uni-trier.de/db/conf/wabi/wabi2008.html</ext-link></comment>
      </element-citation>
    </ref>
    <ref id="pcbi.1000386-Karlin1">
      <label>21</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Karlin</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
        </person-group>
        <year>1990</year>
        <article-title>Methods for assessing the statistical significance of molecular sequence features by using general scoring schemes.</article-title>
        <source>Proc Natl Acad Sci U S A</source>
        <volume>87</volume>
        <fpage>2264</fpage>
        <lpage>2268</lpage>
        <pub-id pub-id-type="pmid">2315319</pub-id>
      </element-citation>
    </ref>
    <ref id="pcbi.1000386-Small2">
      <label>22</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Small</surname>
            <given-names>KS</given-names>
          </name>
          <name>
            <surname>Brudno</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Hill</surname>
            <given-names>MM</given-names>
          </name>
          <name>
            <surname>Sidow</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <year>2007</year>
        <article-title>A haplome alignment and reference sequence of the highly polymorphic ciona savignyi genome.</article-title>
        <source>Genome Biology</source>
        <volume>8</volume>
        <fpage>R41</fpage>
        <pub-id pub-id-type="pmid">17374142</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
