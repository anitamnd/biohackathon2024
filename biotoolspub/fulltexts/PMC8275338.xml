<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8275338</article-id>
    <article-id pub-id-type="pmid">34252959</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btab295</article-id>
    <article-id pub-id-type="publisher-id">btab295</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Systems Biology and Networks</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>A novel constrained genetic algorithm-based Boolean network inference method from steady-state gene expression data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Trinh</surname>
          <given-names>Hung-Cuong</given-names>
        </name>
        <aff><institution>Faculty of Information Technology, Ton Duc Thang University</institution>, Ho Chi Minh 758307, <country country="VN">Vietnam</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Kwon</surname>
          <given-names>Yung-Keun</given-names>
        </name>
        <aff><institution>Department of IT Convergence, University of Ulsan</institution>, Ulsan 680-749, <country country="KR">Korea</country></aff>
        <xref rid="btab295-cor1" ref-type="corresp"/>
        <!--kwonyk@ulsan.ac.kr-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btab295-cor1">To whom correspondence should be addressed. <email>kwonyk@ulsan.ac.kr</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>7</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2021-07-12">
      <day>12</day>
      <month>7</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>12</day>
      <month>7</month>
      <year>2021</year>
    </pub-date>
    <volume>37</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB/ECCB 2021 Proceedings</issue-title>
    <fpage>i383</fpage>
    <lpage>i391</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2021. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2021</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btab295.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>It is a challenging problem in systems biology to infer both the network structure and dynamics of a gene regulatory network from steady-state gene expression data. Some methods based on Boolean or differential equation models have been proposed but they were not efficient in inference of large-scale networks. Therefore, it is necessary to develop a method to infer the network structure and dynamics accurately on large-scale networks using steady-state expression.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>In this study, we propose a novel constrained genetic algorithm-based Boolean network inference (CGA-BNI) method where a Boolean canalyzing update rule scheme was employed to capture coarse-grained dynamics. Given steady-state gene expression data as an input, CGA-BNI identifies a set of path consistency-based constraints by comparing the gene expression level between the wild-type and the mutant experiments. It then searches Boolean networks which satisfy the constraints and induce attractors most similar to steady-state expressions. We devised a heuristic mutation operation for faster convergence and implemented a parallel evaluation routine for execution time reduction. Through extensive simulations on the artificial and the real gene expression datasets, CGA-BNI showed better performance than four other existing methods in terms of both structural and dynamics prediction accuracies. Taken together, CGA-BNI is a promising tool to predict both the structure and the dynamics of a gene regulatory network when a highest accuracy is needed at the cost of sacrificing the execution time.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>Source code and data are freely available at <ext-link xlink:href="https://github.com/csclab/CGA-BNI" ext-link-type="uri">https://github.com/csclab/CGA-BNI</ext-link>.</p>
      </sec>
      <sec id="s6">
        <title>Supplementary information</title>
        <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>2021 Research Fund</institution>
          </institution-wrap>
          <!-- oupReleaseDelayRemoved from OA Article (00|0) -->
        </funding-source>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Recent high-throughput sequencing technologies have yielded a mass of gene expression data (<xref rid="btab295-B15" ref-type="bibr">Hughes <italic toggle="yes">et al.</italic>, 2000</xref>; <xref rid="btab295-B30" ref-type="bibr">Quackenbush, 2001</xref>), which provides an opportunity to investigate the underlying gene-regulatory mechanism from a system-level perspective. It is a challenging problem in systems biology to infer gene regulatory networks (GRNs) from these high-throughput gene expression data, and many computational methods have been developed for it (<xref rid="btab295-B3" ref-type="bibr">Banf and Rhee, 2017</xref>; <xref rid="btab295-B7" ref-type="bibr">Chai <italic toggle="yes">et al.</italic>, 2014</xref>; <xref rid="btab295-B11" ref-type="bibr">De Smet and Marchal, 2010</xref>). Specifically, the problem aims to infer not only a set of regulatory genes for a target gene (i.e. network structure inference), but also the regulatory rules between genes (i.e. network dynamics inference). In fact, most previous methods based on Bayesian networks (<xref rid="btab295-B10" ref-type="bibr">de Matos Simoes and Emmert-Streib, 2012</xref>; <xref rid="btab295-B24" ref-type="bibr">Liu <italic toggle="yes">et al.</italic>, 2016</xref>), graphical Gaussian models (<xref rid="btab295-B21" ref-type="bibr">Krämer <italic toggle="yes">et al.</italic>, 2009</xref>; <xref rid="btab295-B28" ref-type="bibr">Menéndez <italic toggle="yes">et al.</italic>, 2010</xref>), information theory approaches (<xref rid="btab295-B26" ref-type="bibr">Margolin <italic toggle="yes">et al.</italic>, 2006</xref>; <xref rid="btab295-B36" ref-type="bibr">Xiao <italic toggle="yes">et al.</italic>, 2016</xref>), correlation approaches (<xref rid="btab295-B37" ref-type="bibr">Yu <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btab295-B38" ref-type="bibr">Zuo <italic toggle="yes">et al.</italic>, 2014</xref>) and supervised learning approaches (<xref rid="btab295-B16" ref-type="bibr">Huynh-Thu <italic toggle="yes">et al.</italic>, 2010</xref>; <xref rid="btab295-B20" ref-type="bibr">Kotera <italic toggle="yes">et al.</italic>, 2012</xref>) have focused on only the network structure inference. On the other hand, a few methods using Boolean models (<xref rid="btab295-B18" ref-type="bibr">Kauffman, 1969</xref>; <xref rid="btab295-B19" ref-type="bibr">1993</xref>), or differential equation-based models (<xref rid="btab295-B9" ref-type="bibr">Coddington and Levinson, 1955</xref>) have been proposed to predict both the network structure and dynamics. Although the differential equation-based models can offer higher precision predictions, they involve a large number of parameters which are difficult to optimize. In contrast, a Boolean model is the simplest model using the smallest number of parameters to simulate the dynamics of a system, and hence many Boolean model-based algorithms have been developed to infer the GRNs (<xref rid="btab295-B5" ref-type="bibr">Barman and Kwon, 2017</xref>; <xref rid="btab295-B6" ref-type="bibr">Berestovsky and Nakhleh, 2013</xref>; <xref rid="btab295-B13" ref-type="bibr">Han <italic toggle="yes">et al.</italic>, 2015</xref>). However, we note that most existing methods for Boolean network inference use time-series gene expression data as an input whereas a few studies proposed a Boolean network inference method using steady-state expression data (<xref rid="btab295-B1" ref-type="bibr">Almudevar <italic toggle="yes">et al.</italic>, 2011</xref>; <xref rid="btab295-B8" ref-type="bibr">Chevalier <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="btab295-B23" ref-type="bibr">Lim <italic toggle="yes">et al.</italic>, 2016</xref>). A recent study (<xref rid="btab295-B8" ref-type="bibr">Chevalier <italic toggle="yes">et al.</italic>, 2019</xref>) addressed the synthesis of the Boolean networks from constraints on their domain and emerging dynamical properties of the resulting network, but it requires a prior knowledge about a network structure as well as the biological dynamical constraints, which depend on the assumptions about the phenotypes. Another study (<xref rid="btab295-B1" ref-type="bibr">Almudevar <italic toggle="yes">et al.</italic>, 2011</xref>) proposed a Bayesian method to infer a Boolean GRN from steady-state expression data by directly evaluating a model uncertainty. However, it was applicable to only small-scale networks consisting of a few genes because of the expensive computational cost in the Bayesian model. A swarming hill climbing search-based method (<xref rid="btab295-B23" ref-type="bibr">Lim <italic toggle="yes">et al.</italic>, 2016</xref>) was suggested to refine or reconstruct Boolean models from single-cell expression data. IT is basically a local search which iteratively improves a known network structure. In addition, it explores all neighborhood solutions of a currently selected Boolean model which limits the inference of large-scale networks. Taken together, the previous methods of inferring Boolean network from steady state expression have limitations in handling large-scale networks or in obtaining a priori biological information.</p>
    <p>To overcome the limitation, we propose a novel constrained genetic algorithm-based Boolean network inference (CGA-BNI) method. Given steady-state gene expression data as an input, the method first identifies a set of path consistency-based constraints by comparing the gene expression level between the wild-type and the mutant experiments. Next, a genetic algorithm searches not only a network structure to meet the consistency-based constraints but also a set of Boolean update functions to best fit the gene expression dynamics. Our method is a global-search algorithm and intrinsically slow, thus we devised a heuristic mutation operation in the genetic algorithm for faster convergence and implemented the evaluation step in parallel by using Java multi-core programming to make CGA-BNI be applicable to larger networks. Through extensive simulations on three kinds of datasets such as the DREAM challenge data, the artificial data and the large-scale <italic toggle="yes">E</italic>. <italic toggle="yes">coli</italic> gene expression data, CGA-BNI showed consistently better performance than five other well-known existing methods, CellNOptR, ARACNE, GENIE3, BC3NET and BTR in terms of both structural and dynamics prediction accuracy. Considering that the execution time of CGA-BNI was second slowest among the five models, it is most suitable when a highest prediction accuracy is expected at the cost of sacrificing the execution time.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <p>In this section, we explain the basic concept of a Boolean network model employed in CGI-BNI and introduce the Boolean network inference problem from steady-state gene expression data.</p>
    <sec>
      <title>2.1 A Boolean network model</title>
      <p>A Boolean network is one of the simplest computational models to describe network dynamics (<xref rid="btab295-B18" ref-type="bibr">Kauffman, 1969</xref>; <xref rid="btab295-B19" ref-type="bibr">1993</xref>), and it has been frequently used to investigate the complex behaviors of biological networks (<xref rid="btab295-B14" ref-type="bibr">Helikar <italic toggle="yes">et al.</italic>, 2008</xref>; <xref rid="btab295-B22" ref-type="bibr">Le and Kwon, 2011</xref>; <xref rid="btab295-B35" ref-type="bibr">Trinh <italic toggle="yes">et al.</italic>, 2014</xref>). It is represented by a directed graph <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> where <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mfenced open="{" close="}" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math></inline-formula> is a set of nodes and <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mi>A</mml:mi></mml:math></inline-formula> is a set of ordered pairs of the nodes called directed links (<inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> and <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> denote the number of nodes and links, respectively). A directed link <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>∈</mml:mo><mml:mi>A</mml:mi></mml:math></inline-formula> represents a positive (activating) or a negative (inhibiting) regulation from <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> to <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>. Each <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:math></inline-formula> has a state value of 1 (on) or 0 (off). The state of <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> at time <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula> denoted by <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math></inline-formula> is established by the values of <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> other nodes <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:math></inline-formula> with a link to <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> at time <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mi>t</mml:mi></mml:math></inline-formula> by a Boolean function <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:msup><mml:mrow><mml:mfenced open="{" close="}" separators="|"><mml:mrow><mml:mn>0,1</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mo>→</mml:mo><mml:mfenced open="{" close="}" separators="|"><mml:mrow><mml:mn>0,1</mml:mn></mml:mrow></mml:mfenced></mml:math></inline-formula> and the states of all nodes are synchronously updated. Here, we employed a nested canalyzing function (NCF) model (<xref rid="btab295-B17" ref-type="bibr">Kauffman <italic toggle="yes">et al.</italic>, 2004</xref>) to represent an update rule as follows:
<disp-formula id="E1"><mml:math id="M1" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced open="{" close="" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:maligngroup/><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mi>f</mml:mi><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo> </mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:maligngroup/><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mi>f</mml:mi><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mi mathvariant="italic">and</mml:mi><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo> </mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:maligngroup/><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mi>f</mml:mi><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mi mathvariant="italic">and</mml:mi><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mi mathvariant="italic">and</mml:mi><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo> </mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:maligngroup/><mml:mo>⋮</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:maligngroup/><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mi>f</mml:mi><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mi mathvariant="italic">and</mml:mi><mml:mo> </mml:mo><mml:mo>⋯</mml:mo><mml:mi mathvariant="italic">and</mml:mi><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mi mathvariant="italic">and</mml:mi><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:maligngroup/><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">def</mml:mi></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mi mathvariant="italic">otherwise</mml:mi><mml:mo> </mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math></disp-formula>where all <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> and <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mi mathvariant="normal"> </mml:mi><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>1,2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:math></inline-formula> denote the canalyzing and canalyzed Boolean values, respectively, and <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">def</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> is set to <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:math></inline-formula> in general. For convenience, we denote <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> as <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>⋯</mml:mo><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">def</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>, which is a sequence of pairs of canalyzing and canalyzed values, followed by the default value. In this study, each NCF is randomized by specifying every <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> and <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> between 0 and 1 uniformly at random. We note that many molecular interactions were successfully represented by NCFs in previous studies (<xref rid="btab295-B32" ref-type="bibr">Samal and Jain, 2008</xref>; <xref rid="btab295-B34" ref-type="bibr">Trinh and Kwon, 2016</xref>).</p>
      <p>A <italic toggle="yes">network state</italic> at time <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mi>t</mml:mi></mml:math></inline-formula> can be denoted by an ordered list of state values of all nodes, <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mi mathvariant="bold">v</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mfenced open="{" close="}" separators="|"><mml:mrow><mml:mn>0,1</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>. Since a synchronous update scheme was considered in this study, every network state transits to another network state through a set of Boolean update functions <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mi>F</mml:mi><mml:mo>=</mml:mo><mml:mfenced open="{" close="}" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math></inline-formula> in a deterministic way. Hence, a network state trajectory starting from an initial network state eventually converges to either a fixed-point or a limit-cycle attractor. These attractors can represent diverse biological network behaviors such as multi-stability, homeostasis and oscillation. We define the attractor more rigorously as follows.</p>
      <p><bold><italic toggle="yes">Definition.</italic></bold> Given a Boolean network<inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mi mathvariant="normal"> </mml:mi><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> where <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mfenced open="{" close="}" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math></inline-formula> and <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mi>A</mml:mi><mml:mo>⊆</mml:mo><mml:mi>V</mml:mi><mml:mo>×</mml:mo><mml:mi>V</mml:mi></mml:math></inline-formula> and a set of Boolean update functions <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mi>F</mml:mi><mml:mo>=</mml:mo><mml:mfenced open="{" close="}" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math></inline-formula>, let <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mi mathvariant="bold">v</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:mi mathvariant="bold">v</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:mo>⋯</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi></mml:math></inline-formula>be a network state trajectory starting at <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mi mathvariant="bold">v</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:mfenced></mml:math></inline-formula>. The <italic toggle="yes">attractor</italic> is defined as an ordered list of network states <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mo>α</mml:mo><mml:mo>=</mml:mo><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:mi mathvariant="bold">v</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mo>τ</mml:mo></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mi mathvariant="bold">v</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mo>τ</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="bold">v</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mo>τ</mml:mo><mml:mo>+</mml:mo><mml:mi>p</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math></inline-formula> where <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mo>τ</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:munder><mml:mrow><mml:mi mathvariant="normal">minarg </mml:mi><mml:mo>(</mml:mo></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:munder></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mi mathvariant="bold">v</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:mi mathvariant="bold">v</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:mfenced><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> for some <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mi>p</mml:mi></mml:math></inline-formula> with <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mi mathvariant="bold">v</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced><mml:mo>≠</mml:mo><mml:mi mathvariant="bold">v</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:mfenced><mml:mi mathvariant="normal"> </mml:mi><mml:mi mathvariant="normal">for</mml:mi><mml:mi mathvariant="normal"> </mml:mi><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mfenced open="{" close="}" separators="|"><mml:mrow><mml:mo>τ</mml:mo><mml:mo>,</mml:mo><mml:mo>τ</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mo>τ</mml:mo><mml:mo>+</mml:mo><mml:mi>p</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math></inline-formula> (herein, <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mi>p</mml:mi></mml:math></inline-formula> is called a length of the attractor).</p>
    </sec>
    <sec>
      <title>2.2 Boolean network inference problem</title>
      <p>The Boolean network inference problem tackled in this study is a problem of inferring a Boolean network which best fits the observed steady-state gene expression data (<xref rid="btab295-F1" ref-type="fig">Fig. 1</xref>). As shown in the figure, a steady-state expression dataset of real values can be obtained from an unseen underlying target network <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mi>G</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula>. The dataset is represented by a matrix consisting of <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mi>N</mml:mi></mml:math></inline-formula> columns of genes and <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mi>R</mml:mi></mml:math></inline-formula> rows of experiments. Then, it is transformed into a dataset of binary values by a discretization method and we herein used the <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mi>K</mml:mi></mml:math></inline-formula>-means clustering-based discretization method (<xref rid="btab295-B25" ref-type="bibr">MacQueen, 1967</xref>), which groups all of the expression values of a gene into two clusters, and assigns 1 (the ‘on’ state) and 0 (the ‘off’ state) to the clusters having relatively higher and lower average values, respectively. As a result, we can construct the set of steady-state Boolean gene expression matrix <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mi>E</mml:mi></mml:math></inline-formula> where a row corresponding to an experiment is represented by an <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mi>N</mml:mi></mml:math></inline-formula>-dimensional Boolean expression vector i.e. <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mi mathvariant="bold">e</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mfenced open="{" close="}" separators="|"><mml:mrow><mml:mn>0,1</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>. In addition, the experimental information about the mutated gene (available in case of a perturbation experiment), the type of experiments (i.e. one of wild-type or perturbation experiments) and the base wild-type experiment are annotated by ‘MG’, ‘ET’ and ‘WT’ fields, respectively. For example, the fifth experiment in <xref rid="btab295-F1" ref-type="fig">Figure 1</xref> describes a knockout perturbation subject to gene <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:math></inline-formula> and the base wild-type experiment is ‘WT01’ which means the first wild-type experiment. A Boolean network inference method uses both the dataset <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mi>E</mml:mi></mml:math></inline-formula> and the experimental information as inputs, and produces an inferred network <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">'</mml:mi></mml:mrow></mml:msup><mml:mfenced separators="|"><mml:mrow><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">'</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math></inline-formula> as a result. Unlike most previous methods which do not focus on the inference of a regulatory function, we defined the problem such that the inference result should include an estimated update Boolean rule for each gene because it is required to evaluate the dynamics accuracy of the inferred network. Specifically, the dynamics accuracy is calculated by comparing the Boolean steady-state expression in <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mi>E</mml:mi></mml:math></inline-formula> and the attractor which is derived from the inferred network. Consider an arbitrary Boolean expression <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mi mathvariant="bold">e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:math></inline-formula> and let <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold-italic">b</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> the Boolean expression of the base experiment of <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mi mathvariant="bold">e</mml:mi></mml:math></inline-formula> (Note that <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold-italic">b</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> is equivalent to <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mi mathvariant="bold">e</mml:mi></mml:math></inline-formula> if <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mi mathvariant="bold">e</mml:mi></mml:math></inline-formula> is the case of the wild-type experiment). To compute the corresponding attractor of the inferred network, the initial state of <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">'</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> is specified to <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold-italic">b</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> and the trajectory is simulated by the inferred update function until an attractor is obtained. For example, the third experiment in <xref rid="btab295-F1" ref-type="fig">Figure 1</xref> describes a knock-out perturbation (KO) experiment subject to <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></inline-formula> where the base wild-type experiment is the second experiment denoted by WT02. Thus, the inferred network state is initialized to <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold-italic">b</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:mn>11010</mml:mn></mml:mrow></mml:mfenced></mml:math></inline-formula> by referring to the Boolean steady-state expression of WT02 in <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mi>E</mml:mi></mml:math></inline-formula>. Then the gene <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></inline-formula> is assumed to be knocked out and the attractor which <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">'</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> converges to is examined. Assume that a fixed-point attractor <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:mn>00100</mml:mn></mml:mrow></mml:mfenced></mml:math></inline-formula> is found as shown in <xref rid="btab295-F1" ref-type="fig">Figure 1</xref>. Then, it is compared with the Boolean expression of the third experiment in <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mi>E</mml:mi></mml:math></inline-formula>, <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mi mathvariant="bold">e</mml:mi><mml:mo>=</mml:mo><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:mn>00000</mml:mn></mml:mrow></mml:mfenced></mml:math></inline-formula>, to compute the dynamics accuracy. In this way, we obtain the attractor by simulating <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">'</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> for each steady-state expression <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mi mathvariant="bold">e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:math></inline-formula> and construct the resultant set of attractors <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mi>E</mml:mi><mml:mi mathvariant="normal">'</mml:mi></mml:math></inline-formula>.</p>
      <fig position="float" id="btab295-F1">
        <label>Fig. 1.</label>
        <caption>
          <p>Overview of a Boolean network inference problem. An unseen target network <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mi>G</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> produces a steady-state gene expression dataset that is converted to a Boolean steady-state dataset <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mi>E</mml:mi></mml:math></inline-formula> by a discretization method. An inference algorithm trains the Boolean dataset <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mi>E</mml:mi></mml:math></inline-formula> along with experimental information as an input and infers a Boolean network <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">'</mml:mi></mml:mrow></mml:msup><mml:mfenced separators="|"><mml:mrow><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">'</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math></inline-formula> as an output. The inference performance is evaluated in terms of a structural accuracy by comparing the inferred connections <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">'</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> to the true connections <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mi>A</mml:mi></mml:math></inline-formula> and a dynamics accuracy by comparing the derived Boolean attractors <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">'</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> to the observed data <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mi>E</mml:mi></mml:math></inline-formula>. <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mi>M</mml:mi><mml:mi>G</mml:mi></mml:math></inline-formula>, <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mi>E</mml:mi><mml:mi>T</mml:mi></mml:math></inline-formula>, <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mi>W</mml:mi><mml:mi>T</mml:mi></mml:math></inline-formula>, <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mi>K</mml:mi><mml:mi>O</mml:mi></mml:math></inline-formula> and <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mi>O</mml:mi><mml:mi>E</mml:mi></mml:math></inline-formula> denote ‘mutated gene’, ‘experiment type’, ‘wild-type’, ‘gene knockout’ and ‘gene overexpression’, respectively</p>
        </caption>
        <graphic xlink:href="btab295f1" position="float"/>
      </fig>
      <p>In this study, we consider two types of inference performance. The first one is the structural performance by comparing <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mi>A</mml:mi></mml:math></inline-formula> and <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">'</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>, and we employed three well-known metrics, precision, recall and structural accuracy. Precision is defined as the ratio of correctly inferred connections out of all positive predictions, as follows:
<disp-formula id="E2"><label>(1)</label><mml:math id="M2" display="block" overflow="scroll"><mml:mi mathvariant="italic">Precision</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>T</mml:mi><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>P</mml:mi><mml:mo>+</mml:mo><mml:mi>F</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:mfrac><mml:mi mathvariant="normal"> </mml:mi><mml:mo>,</mml:mo></mml:math></disp-formula>where <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mi>T</mml:mi><mml:mi>P</mml:mi></mml:math></inline-formula> (true positive) and <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mi>F</mml:mi><mml:mi>P</mml:mi></mml:math></inline-formula> (false positive) denote the numbers of correctly and incorrectly predicted connections, respectively. Recall is the ratio of inferred connections among the true connections in <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mi>G</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula>:
<disp-formula id="E3"><label>(2)</label><mml:math id="M3" display="block" overflow="scroll"><mml:mi mathvariant="italic">Recall</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>T</mml:mi><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>P</mml:mi><mml:mo>+</mml:mo><mml:mi>F</mml:mi><mml:mi>N</mml:mi></mml:mrow></mml:mfrac><mml:mi mathvariant="normal"> </mml:mi><mml:mo>,</mml:mo></mml:math></disp-formula>where <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mi>F</mml:mi><mml:mi>N</mml:mi></mml:math></inline-formula> (false negative) means the number of non-inferred connections in <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mi>G</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula>. Structural accuracy is the ratio of correct predictions, as follows:
<disp-formula id="E4"><label>(3)</label><mml:math id="M4" display="block" overflow="scroll"><mml:mi mathvariant="italic">Structural</mml:mi><mml:mi mathvariant="normal"> </mml:mi><mml:mi mathvariant="italic">Accuracy</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>T</mml:mi><mml:mi>P</mml:mi><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>P</mml:mi><mml:mo>+</mml:mo><mml:mi>F</mml:mi><mml:mi>P</mml:mi><mml:mo>+</mml:mo><mml:mi>F</mml:mi><mml:mi>N</mml:mi><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mi>N</mml:mi></mml:mrow></mml:mfrac><mml:mi mathvariant="normal"> </mml:mi><mml:mo>,</mml:mo></mml:math></disp-formula>where <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mi>T</mml:mi><mml:mi>N</mml:mi></mml:math></inline-formula> (true negative) is the number of correct negative predictions.</p>
      <p>The second performance type is the network dynamics accuracy by comparing <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mi>E</mml:mi></mml:math></inline-formula> and <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">'</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>. Let <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mi mathvariant="bold">e</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub><mml:mi mathvariant="normal"> </mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0,1</mml:mn><mml:mo>}</mml:mo><mml:mo>)</mml:mo></mml:math></inline-formula> a steady-state Boolean expression in <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mi>E</mml:mi></mml:math></inline-formula> and <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:mi mathvariant="bold">v</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mi mathvariant="bold">v</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="bold">v</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math></inline-formula> the attractor in <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">'</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> corresponding to <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mi mathvariant="bold">e</mml:mi></mml:math></inline-formula> (<inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mi>p</mml:mi></mml:math></inline-formula> is the attractor length). For convenience, we first define the similarity of <inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mi>i</mml:mi></mml:math></inline-formula>th gene between <inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mi mathvariant="bold">e</mml:mi></mml:math></inline-formula> and<inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mi mathvariant="normal"> </mml:mi><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> as follows:
<disp-formula id="E5"><mml:math id="M5" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi mathvariant="bold">e</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:munderover><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mi>I</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold-italic">i</mml:mi></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mrow><mml:mo>,</mml:mo></mml:math></disp-formula>where <inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold-italic">i</mml:mi></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> means the state value of <inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mi>i</mml:mi></mml:math></inline-formula>th gene in <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mi mathvariant="bold">v</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> and <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mi>I</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mo>·</mml:mo></mml:mrow></mml:mfenced></mml:math></inline-formula> is an indicator function that returns 1 if the condition is true, or 0 otherwise. Then the similarity function between <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mi mathvariant="bold">e</mml:mi></mml:math></inline-formula> and<inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mi mathvariant="normal"> </mml:mi><mml:mo>α</mml:mo></mml:math></inline-formula> denoted by <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="bold">e</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:math></inline-formula> means the average similarity of all genes between <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mi mathvariant="bold">e</mml:mi></mml:math></inline-formula> and<inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mi mathvariant="normal"> </mml:mi><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> as follows:
<disp-formula id="E6"><mml:math id="M6" display="block" overflow="scroll"><mml:mi>s</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi mathvariant="bold">e</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:munderover><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi mathvariant="bold">e</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:math></disp-formula></p>
      <p>Then, we evaluate the network dynamics performance of the inferred network using a dynamics accuracy function defined as follows:
<disp-formula id="E7"><label>(4)</label><mml:math id="M7" display="block" overflow="scroll"><mml:mi mathvariant="italic">Dynamics</mml:mi><mml:mi mathvariant="normal"> </mml:mi><mml:mi mathvariant="italic">Accuracy</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mfrac><mml:mrow><mml:munder><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi mathvariant="bold">e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mi>s</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi mathvariant="bold">e</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></disp-formula></p>
      <p>In other words, the network dynamics accuracy represents the average similarity between the steady-state Boolean expression set <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula> and the attractor set <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">'</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math></inline-formula> of the inferred network. We also note that most previous studies have focused on the structural inference performance larger than the dynamics one (<xref rid="btab295-B27" ref-type="bibr">Maucher <italic toggle="yes">et al.</italic>, 2011</xref>), which is considerably crucial, though, because the network inference ultimately aims to characterize various cellular dynamical behaviors through complex molecular interactions.</p>
      <p>In our proposed method, it is necessary to assess how accurately the inferred update function of each target gene fits the steady-state expression dataset (see section ‘A constrained Genetic Algorithm for Boolean network inference’ for details). In this regard, we define the average similarity of <inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mi>i</mml:mi></mml:math></inline-formula>th gene over all experiments as follows:
<disp-formula id="E8"><label>(5)</label><mml:math id="M8" display="block" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mo>-</mml:mo></mml:mover></mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mfrac><mml:mrow><mml:munder><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi mathvariant="bold">e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi mathvariant="bold">e</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mrow><mml:mi mathvariant="normal"> </mml:mi><mml:mo>.</mml:mo></mml:math></disp-formula></p>
    </sec>
    <sec>
      <title>2.3 Overall framework of the proposed Boolean network inference algorithm</title>
      <p>In this work, we propose a constrained genetic algorithm-based Boolean network inference method called CGA-BNI. We first introduce a procedure to generate path consistency-based constraints from steady-state gene expression data. The set of constraints as well as the steady-state expressions are used as input for our genetic algorithm to infer the Boolean network.</p>
      <sec>
        <title>2.3.1 Path consistency-based constraints</title>
        <p>A path-consistency constraint can efficiently reduce the cost in searching a feasible network structure. In this study, we devised two measures to establish a path-consistency constraint between a pair of genes using the steady-state expression data. The first measure is the gene–gene coherency which is deduced by comparing the gene expressions between the wild-type and the mutant experiments. Consider a pair of a perturbation experimental Boolean expression vector <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mi mathvariant="bold">e</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub><mml:mi mathvariant="normal"> </mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="bold">e</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mfenced open="{" close="}" separators="|"><mml:mrow><mml:mn>0,1</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math></inline-formula> and a corresponding wild-type experimental Boolean expression vector <inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mi mathvariant="bold">w</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub><mml:mi mathvariant="normal"> </mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="bold">w</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mfenced open="{" close="}" separators="|"><mml:mrow><mml:mn>0,1</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math></inline-formula>, and let <inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mi>k</mml:mi><mml:mo> </mml:mo><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo>}</mml:mo><mml:mo>)</mml:mo></mml:math></inline-formula> the index of the mutated gene in <inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mi mathvariant="bold">e</mml:mi></mml:math></inline-formula>. For every gene index <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mi>l</mml:mi><mml:mo>≠</mml:mo><mml:mi>k</mml:mi></mml:math></inline-formula>, the gene–gene coherency is defined as <inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mi mathvariant="normal">Δ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math></inline-formula>. A positive or negative value of <inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mi mathvariant="normal">Δ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> means that two genes have a consistent or inconsistent trend of change in the expression level, which eventually implies the positive or negative path from gene <inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> to gene <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>. Next, the second measure is the Pearson correlation coefficient to quantify the strength of a linear association between two genes, which is denoted by <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mi>r</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula> as follows:
<disp-formula id="E9"><label>(6)</label><mml:math id="M9" display="block" overflow="scroll"><mml:mi>r</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:munder><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi mathvariant="bold">e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>-</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>-</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:munder><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi mathvariant="bold">e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msup><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>-</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:msqrt><mml:mo>×</mml:mo><mml:msqrt><mml:mrow><mml:munder><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi mathvariant="bold">e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msup><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>-</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac><mml:mi mathvariant="normal"> </mml:mi><mml:mo>,</mml:mo></mml:math></disp-formula>where <inline-formula id="IE124"><mml:math id="IM124" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mo>-</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mfrac><mml:mrow><mml:munder><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi mathvariant="bold">e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> denotes the average Boolean expression value of gene <inline-formula id="IE125"><mml:math id="IM125" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> in the steady-state Boolean expression dataset <inline-formula id="IE126"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mi>E</mml:mi></mml:math></inline-formula>. As the linear association of gene <inline-formula id="IE127"><mml:math id="IM127" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> and <inline-formula id="IE128"><mml:math id="IM128" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> gets stronger, the value of <inline-formula id="IE129"><mml:math id="IM129" display="inline" overflow="scroll"><mml:mi>r</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula> is closer to either +1 or -1 depending on the sign of the relationship. As shown in <xref rid="btab295-T1" ref-type="table">Table 1</xref>, we established two criteria of conditions to identify the path consistency-based constraint. The first condition is the positiveness condition based on the signs of <inline-formula id="IE130"><mml:math id="IM130" display="inline" overflow="scroll"><mml:mi mathvariant="normal">Δ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> and <inline-formula id="IE131"><mml:math id="IM131" display="inline" overflow="scroll"><mml:mi>r</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula>. If both of them are positive (or negative), the network is supposed to contain a positive (resp., negative) path from gene <inline-formula id="IE132"><mml:math id="IM132" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> to gene <inline-formula id="IE133"><mml:math id="IM133" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>. The second condition determines the directness of the path. If the correlation is relatively strong (<inline-formula id="IE134"><mml:math id="IM134" display="inline" overflow="scroll"><mml:mo>|</mml:mo><mml:mi>r</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>)</mml:mo><mml:mo>|</mml:mo><mml:mo>≥</mml:mo><mml:mo>β</mml:mo></mml:math></inline-formula>), a direct path is presumed. On the other hand, if the correlation is relatively weak (<inline-formula id="IE135"><mml:math id="IM135" display="inline" overflow="scroll"><mml:mo>α</mml:mo><mml:mo>&lt;</mml:mo><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mi>r</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mfenced><mml:mo>&lt;</mml:mo><mml:mo>β</mml:mo></mml:math></inline-formula>), an indirect path is presumed. We note that the parameters <inline-formula id="IE136"><mml:math id="IM136" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula> and <inline-formula id="IE137"><mml:math id="IM137" display="inline" overflow="scroll"><mml:mo>β</mml:mo></mml:math></inline-formula> were heuristically set to 0.1 and 0.5, respectively, in this study. As a result, there can be four types of a regulatory path relation between an ordered pair of genes, if applicable, according to the positiveness and the directedness conditions. The set of all identified regulatory paths are used as the path-consistency constraints which the candidate network should meet during the network inference process.</p>
        <table-wrap position="float" id="btab295-T1">
          <label>Table 1.</label>
          <caption>
            <p>Path consistency-based constraints in CGA-BNI</p>
          </caption>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col valign="top" align="left" span="1"/>
              <col valign="top" align="left" span="1"/>
              <col valign="top" align="left" span="1"/>
              <col valign="top" align="left" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th colspan="2" rowspan="2"/>
                <th colspan="2" rowspan="1">Positiveness condition<hr/></th>
              </tr>
              <tr>
                <th rowspan="1" colspan="1"><inline-formula id="IE138"><mml:math id="IM138" display="inline" overflow="scroll"><mml:mi mathvariant="normal">Δ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:mfenced><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> and <inline-formula id="IE139"><mml:math id="IM139" display="inline" overflow="scroll"><mml:mi>r</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>)</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula></th>
                <th rowspan="1" colspan="1"><inline-formula id="IE140"><mml:math id="IM140" display="inline" overflow="scroll"><mml:mi mathvariant="normal">Δ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:mfenced><mml:mo>&lt;</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> and <inline-formula id="IE141"><mml:math id="IM141" display="inline" overflow="scroll"><mml:mi>r</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>)</mml:mo><mml:mo>&lt;</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula></th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="2" colspan="1">Directedness Condition</td>
                <td rowspan="1" colspan="1">
                  <inline-formula id="IE142">
                    <mml:math id="IM142" display="inline" overflow="scroll">
                      <mml:mfenced open="|" close="|" separators="|">
                        <mml:mrow>
                          <mml:mi>r</mml:mi>
                          <mml:mo>(</mml:mo>
                          <mml:mi>k</mml:mi>
                          <mml:mo>,</mml:mo>
                          <mml:mi>l</mml:mi>
                          <mml:mo>)</mml:mo>
                        </mml:mrow>
                      </mml:mfenced>
                      <mml:mo>≥</mml:mo>
                      <mml:mo>β</mml:mo>
                    </mml:math>
                  </inline-formula>
                </td>
                <td rowspan="1" colspan="1">Direct and positive</td>
                <td rowspan="1" colspan="1">Direct and negative</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">
                  <inline-formula id="IE143">
                    <mml:math id="IM143" display="inline" overflow="scroll">
                      <mml:mo>α</mml:mo>
                      <mml:mo>&lt;</mml:mo>
                      <mml:mfenced open="|" close="|" separators="|">
                        <mml:mrow>
                          <mml:mi>r</mml:mi>
                          <mml:mo>(</mml:mo>
                          <mml:mi>k</mml:mi>
                          <mml:mo>,</mml:mo>
                          <mml:mi>l</mml:mi>
                          <mml:mo>)</mml:mo>
                        </mml:mrow>
                      </mml:mfenced>
                      <mml:mo>&lt;</mml:mo>
                      <mml:mo>β</mml:mo>
                    </mml:math>
                  </inline-formula>
                </td>
                <td rowspan="1" colspan="1">Indirect and positive</td>
                <td rowspan="1" colspan="1">Indirect and negative</td>
              </tr>
            </tbody>
          </table>
        </table-wrap>
      </sec>
      <sec>
        <title>2.3.2 A constrained genetic algorithm for Boolean network inference</title>
        <p>Our proposed genetic algorithm (GA) takes the set of path-consistency constraints and the Boolean steady-state gene expression as inputs and infers a Boolean network which satisfies the constraints and induces the dynamics as close as to the experimental Boolean gene expression data. The procedure of the proposed method is outlined in <xref rid="btab295-F2" ref-type="fig">Figure 2</xref>. Our GA starts with an initial population of 200 random Boolean networks which are generated by using the Barabási-Albert (BA) model (<xref rid="btab295-B4" ref-type="bibr">Barabási and Albert, 1999</xref>) (see Supplementary Fig. S1 for the pseudo-code) such that the network topology satisfies the path-consistency constraints. Then, the GA creates the next population of networks by conducting the following steps:</p>
        <fig position="float" id="btab295-F2">
          <label>Fig. 2.</label>
          <caption>
            <p>Overall framework of the CGA-BNI algorithm. Our GA takes the path consistency-based constraints <inline-formula id="IE144"><mml:math id="IM144" display="inline" overflow="scroll"><mml:mi>C</mml:mi></mml:math></inline-formula> and the observed steady-state data <inline-formula id="IE145"><mml:math id="IM145" display="inline" overflow="scroll"><mml:mi>E</mml:mi></mml:math></inline-formula> as inputs and returns a Boolean network such that the topology satisfies <inline-formula id="IE146"><mml:math id="IM146" display="inline" overflow="scroll"><mml:mi>C</mml:mi></mml:math></inline-formula> and the induced dynamics is most similar to <inline-formula id="IE147"><mml:math id="IM147" display="inline" overflow="scroll"><mml:mi>E</mml:mi></mml:math></inline-formula>. First, an initial population of random feasible Boolean networks (BNs) are generated by using the Barabási-Albert (BA) model (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S1</xref> for the pseudo-code). Some elite BNs are kept in the next population. In addition, the GA selects the parent BNs, produces the new BNs by applying the rule-based mutation operator to the parent BNs, and insert them into the next population. This generation is repeated until a stop condition is met</p>
          </caption>
          <graphic xlink:href="btab295f2" position="float"/>
        </fig>
        <list list-type="roman-lower">
          <list-item>
            <p>The fitness of each network is scored by the dynamics accuracy (see <xref rid="E7" ref-type="disp-formula">Equation 4</xref> in Section 2). We note that this task was implemented in parallel by using multi-threaded Java programming where each network is assigned to a Java thread for calculation. This parallel implementation can reduce the computation cost in evaluating a candidate network.</p>
          </list-item>
          <list-item>
            <p>Some best networks in the current population with higher fitness are chosen as <inline-formula id="IE148"><mml:math id="IM148" display="inline" overflow="scroll"><mml:mi mathvariant="italic">elite</mml:mi></mml:math></inline-formula>, and they are passed to the next population. In this study, we set the number of elite networks to 2.</p>
          </list-item>
          <list-item>
            <p>A<inline-formula id="IE149"><mml:math id="IM149" display="inline" overflow="scroll"><mml:mi mathvariant="normal"> </mml:mi><mml:mi mathvariant="italic">parent</mml:mi></mml:math></inline-formula> network is chosen among the current population. The selection probability of a network is linearly proportional to its fitness.</p>
          </list-item>
          <list-item>
            <p>A new network is produced by applying the rule-based mutation operator to the <inline-formula id="IE150"><mml:math id="IM150" display="inline" overflow="scroll"><mml:mi mathvariant="italic">parent</mml:mi></mml:math></inline-formula> network.</p>
          </list-item>
          <list-item>
            <p>The new network replaces the parent network in the population.</p>
          </list-item>
        </list>
        <p>The GA stops when the best network in the population is not improved during 200 past generations. We note that our GA did not involve a crossover operator unlike other traditional genetic algorithms. In addition, the path consistency constraints are hard conditions. This is the reason why such mutations that satisfy the path-consistency constraints are allowed in the middle of GA operations. In other words, the constraints must be satisfied by any feasible solution. In the following sub-sections, we introduce the details of our GA including the chromosomes encoding, the selection operation and the mutation operation.</p>
        <p>
          <bold>Chromosomal codification</bold>
        </p>
        <p>In GAs, a solution to a problem is called a chromosome and a population consists of a set of chromosomes. In this study, we represent a chromosome by a set of NCF rules, <inline-formula id="IE151"><mml:math id="IM151" display="inline" overflow="scroll"><mml:mfenced open="{" close="}" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math></inline-formula> where <inline-formula id="IE152"><mml:math id="IM152" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> is the Boolean update function for <inline-formula id="IE153"><mml:math id="IM153" display="inline" overflow="scroll"><mml:mi>i</mml:mi></mml:math></inline-formula>th gene (see Methods for the definition of NCF). Let <inline-formula id="IE154"><mml:math id="IM154" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> be a Boolean NCF update function with <inline-formula id="IE155"><mml:math id="IM155" display="inline" overflow="scroll"><mml:mi>m</mml:mi></mml:math></inline-formula> regulatory inputs which is represented by the following sequence:
<disp-formula id="E10"><label>(7)</label><mml:math id="M10" display="block" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">def</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mi mathvariant="normal"> </mml:mi><mml:mo>.</mml:mo></mml:math></disp-formula></p>
        <p>In addition, we can further divide <inline-formula id="IE156"><mml:math id="IM156" display="inline" overflow="scroll"><mml:mi>m</mml:mi></mml:math></inline-formula> tuples in <inline-formula id="IE157"><mml:math id="IM157" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> into two disjoint subgroups: the fixed-path subgroup (FPS) and the variable-path subgroup (VPS). A tuple is classified into FPS or VPS if it is necessary to meet the path-consistency constraints or not, respectively. For example, a tuple <inline-formula id="IE158"><mml:math id="IM158" display="inline" overflow="scroll"><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math></inline-formula> in <inline-formula id="IE159"><mml:math id="IM159" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> implies the existence of a directed interaction from gene <inline-formula id="IE160"><mml:math id="IM160" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> to gene <inline-formula id="IE161"><mml:math id="IM161" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> (Note that the sign of the interaction is determined by the values of <inline-formula id="IE162"><mml:math id="IM162" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> and <inline-formula id="IE163"><mml:math id="IM163" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>). If <inline-formula id="IE164"><mml:math id="IM164" display="inline" overflow="scroll"><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math></inline-formula> is an element of FPS, it is prohibited that the mutation operator in our GA disrupt the path information of the tuple. On the other hand, if it is an element of VPS, there is no restriction about the disruption by the mutation operator.</p>
        <p>
          <bold>Selection</bold>
        </p>
        <p>Our GA selects a parent chromosome among a population to produce a new chromosome for the next population. We adopted the traditional roulette wheel selection scheme where the selection probability of a chromosome <inline-formula id="IE165"><mml:math id="IM165" display="inline" overflow="scroll"><mml:mi>x</mml:mi></mml:math></inline-formula> is proportional to the fitness value of <inline-formula id="IE166"><mml:math id="IM166" display="inline" overflow="scroll"><mml:mi>x</mml:mi></mml:math></inline-formula> as follows:
<disp-formula id="E11"><label>(8)</label><mml:math id="M11" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">Pr</mml:mi></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi mathvariant="italic">fitness</mml:mi><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mrow><mml:munder><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>y</mml:mi><mml:mo>∈</mml:mo><mml:mi>P</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mi mathvariant="italic">fitness</mml:mi><mml:mo>(</mml:mo><mml:mi>y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:math></disp-formula>where <inline-formula id="IE167"><mml:math id="IM167" display="inline" overflow="scroll"><mml:mi mathvariant="italic">fitness</mml:mi><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula> means the dynamics accuracy of <inline-formula id="IE168"><mml:math id="IM168" display="inline" overflow="scroll"><mml:mi>x</mml:mi></mml:math></inline-formula> (see <xref rid="E8" ref-type="disp-formula">Equation 5</xref>).</p>
        <p>
          <bold>Mutation</bold>
        </p>
        <p>In our GA, the mutation operator is used to generate a new chromosome by changing the parent chromosome. Let <inline-formula id="IE169"><mml:math id="IM169" display="inline" overflow="scroll"><mml:mfenced open="{" close="}" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math></inline-formula> be a parent chromosome selected among the population. Then the mutation operator first randomly chooses one update rule <inline-formula id="IE170"><mml:math id="IM170" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> such that <italic toggle="yes">i</italic>) the gene-wise dynamics consistency of the gene <inline-formula id="IE171"><mml:math id="IM171" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> is not perfect (i.e. <inline-formula id="IE172"><mml:math id="IM172" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mo>-</mml:mo></mml:mover></mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mo>&lt;</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula>) and <italic toggle="yes">ii</italic>) <inline-formula id="IE173"><mml:math id="IM173" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mo>-</mml:mo></mml:mover></mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> is not converged during 100 previous consecutive generations with a 2% tolerance rate. Our GA implemented the following six different types of mutation operators (<xref rid="btab295-F3" ref-type="fig">Fig. 3</xref> and Supplementary <xref rid="sup1" ref-type="supplementary-material">Fig. S2</xref> in <xref rid="sup1" ref-type="supplementary-material">Supplementary Information</xref>), and one of them is randomly applied to the update rule <inline-formula id="IE174"><mml:math id="IM174" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>.</p>
        <fig position="float" id="btab295-F3">
          <label>Fig. 3.</label>
          <caption>
            <p>Illustrations of canalyzing/canalyzed-value reversion mutation types in the CGA-BNI algorithm. See <xref rid="sup1" ref-type="supplementary-material">Supplementary Figure S2</xref> for other mutations types</p>
          </caption>
          <graphic xlink:href="btab295f3" position="float"/>
        </fig>
        <list list-type="bullet">
          <list-item>
            <p><italic toggle="yes">Canalyzing-value reversion</italic>: A tuple <inline-formula id="IE175"><mml:math id="IM175" display="inline" overflow="scroll"><mml:mfenced separators="|"><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>O</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> is randomly selected among the VPS of <inline-formula id="IE176"><mml:math id="IM176" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> and it is replaced by <inline-formula id="IE177"><mml:math id="IM177" display="inline" overflow="scroll"><mml:mfenced separators="|"><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>O</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula>. In other words, this mutation operator flips the corresponding canalyzing value and thus causes to switch the type of molecular interaction between <inline-formula id="IE178"><mml:math id="IM178" display="inline" overflow="scroll"><mml:mi>v</mml:mi></mml:math></inline-formula> and <inline-formula id="IE179"><mml:math id="IM179" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> from a positive interaction to a negative one and vice versa (<xref rid="btab295-F3" ref-type="fig">Fig. 3a</xref>).</p>
          </list-item>
          <list-item>
            <p><italic toggle="yes">Canalyzed-value reversion</italic>: A tuple <inline-formula id="IE180"><mml:math id="IM180" display="inline" overflow="scroll"><mml:mfenced separators="|"><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>O</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> is randomly selected among the VPS of <inline-formula id="IE181"><mml:math id="IM181" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> and it is replaced by <inline-formula id="IE182"><mml:math id="IM182" display="inline" overflow="scroll"><mml:mfenced separators="|"><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mi>O</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula>. In other words, this mutation operator flips the corresponding canalyzed value and thus causes to switch the type of molecular interaction between <inline-formula id="IE183"><mml:math id="IM183" display="inline" overflow="scroll"><mml:mi>v</mml:mi></mml:math></inline-formula> and <inline-formula id="IE184"><mml:math id="IM184" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> from a positive interaction to a negative one and vice versa (<xref rid="btab295-F3" ref-type="fig">Fig. 3b</xref>). Although the structural change by this mutation operator is same with that by the canalyzing-value reversion, the difference is that the relationship between <inline-formula id="IE185"><mml:math id="IM185" display="inline" overflow="scroll"><mml:mi>v</mml:mi></mml:math></inline-formula> and <inline-formula id="IE186"><mml:math id="IM186" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> is changed from a conjunction logical function to a disjunction one and vice versa.</p>
          </list-item>
          <list-item>
            <p><italic toggle="yes">Canalyzing and canalyzed values reversion</italic>: A tuple <inline-formula id="IE187"><mml:math id="IM187" display="inline" overflow="scroll"><mml:mfenced separators="|"><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>O</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> is randomly selected among the FPS and VPS of <inline-formula id="IE188"><mml:math id="IM188" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> and it is replaced by <inline-formula id="IE189"><mml:math id="IM189" display="inline" overflow="scroll"><mml:mfenced separators="|"><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mi>O</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula>. This mutation operator flips both the corresponding canalyzing and canalyzed values and thus causes to change only the relationship between <inline-formula id="IE190"><mml:math id="IM190" display="inline" overflow="scroll"><mml:mi>v</mml:mi></mml:math></inline-formula> and <inline-formula id="IE191"><mml:math id="IM191" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> from a conjunction logical function to a disjunction one and vice versa (see Supplementary <xref rid="sup1" ref-type="supplementary-material">Fig. S2</xref>a in <xref rid="sup1" ref-type="supplementary-material">Supplementary Information</xref>). We note that this mutation does not affect the type of molecular interaction between <inline-formula id="IE192"><mml:math id="IM192" display="inline" overflow="scroll"><mml:mi>v</mml:mi></mml:math></inline-formula> and <inline-formula id="IE193"><mml:math id="IM193" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>.</p>
          </list-item>
          <list-item>
            <p><italic toggle="yes">Canalyzing and canalyzed values swapping</italic>: Two FPS tuples or two VPS tuples of <inline-formula id="IE194"><mml:math id="IM194" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>,<inline-formula id="IE195"><mml:math id="IM195" display="inline" overflow="scroll"><mml:mi mathvariant="normal"> </mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>O</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> and <inline-formula id="IE196"><mml:math id="IM196" display="inline" overflow="scroll"><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">'</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">'</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">'</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math></inline-formula>, are randomly selected and their orders in the sequence of <inline-formula id="IE197"><mml:math id="IM197" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> are swapped (see Supplementary <xref rid="sup1" ref-type="supplementary-material">Fig. S2</xref>b in <xref rid="sup1" ref-type="supplementary-material">Supplementary Information</xref>). It changes the precedence of two regulatory inputs <inline-formula id="IE198"><mml:math id="IM198" display="inline" overflow="scroll"><mml:mi>v</mml:mi></mml:math></inline-formula> and <inline-formula id="IE199"><mml:math id="IM199" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">'</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> in updating the state value of <inline-formula id="IE200"><mml:math id="IM200" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>.</p>
          </list-item>
          <list-item>
            <p><italic toggle="yes">Canalyzing and canalyzed values removal</italic>: A tuple <inline-formula id="IE201"><mml:math id="IM201" display="inline" overflow="scroll"><mml:mfenced separators="|"><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>O</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> is randomly selected among the VPS of <inline-formula id="IE202"><mml:math id="IM202" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> and is removed from <inline-formula id="IE203"><mml:math id="IM203" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> (see Supplementary <xref rid="sup1" ref-type="supplementary-material">Fig. S2</xref>c in <xref rid="sup1" ref-type="supplementary-material">Supplementary Information</xref>). This mutation represents the loss of the molecular interaction between <inline-formula id="IE204"><mml:math id="IM204" display="inline" overflow="scroll"><mml:mi>v</mml:mi></mml:math></inline-formula> and <inline-formula id="IE205"><mml:math id="IM205" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>.</p>
          </list-item>
          <list-item>
            <p><italic toggle="yes">Canalyzing and canalyzed values insertion</italic>: A new tuple <inline-formula id="IE206"><mml:math id="IM206" display="inline" overflow="scroll"><mml:mfenced separators="|"><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>O</mml:mi></mml:mrow></mml:mfenced><mml:mo>∉</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> such that <inline-formula id="IE207"><mml:math id="IM207" display="inline" overflow="scroll"><mml:mi>v</mml:mi><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> is randomly generated and it is then inserted into the first position in the VPS part of <inline-formula id="IE208"><mml:math id="IM208" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> (see Supplementary <xref rid="sup1" ref-type="supplementary-material">Fig. S2</xref>d in <xref rid="sup1" ref-type="supplementary-material">Supplementary Information</xref>). This mutation represents the gain of a new molecular interaction between <inline-formula id="IE209"><mml:math id="IM209" display="inline" overflow="scroll"><mml:mi>v</mml:mi></mml:math></inline-formula> and <inline-formula id="IE210"><mml:math id="IM210" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>. The mutation can be applied only if <inline-formula id="IE211"><mml:math id="IM211" display="inline" overflow="scroll"><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mi>r</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>&gt;</mml:mo><mml:mo>α</mml:mo></mml:math></inline-formula>.</p>
          </list-item>
        </list>
        <p>Note that if a chosen mutation operator generates a network which does not meet any path-consistency constraint, it is discarded and another mutation is randomly selected until a feasible network is generated.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>To validate our approach, we tested it with the artificial, the DREAM challenge and a real large-scale gene expression dataset.</p>
    <sec>
      <title>3.1 Performance on DREAM and artificial datasets</title>
      <p>DREAM challenge gives a series of noisy gene expression datasets and gold benchmark networks, which were selected from source networks of real species, <italic toggle="yes">E.coli</italic> and <italic toggle="yes">Yeast</italic>. In this section, we use the steady-state gene expression data from DREAM3 challenge. There are three synthetic datasets: dataset10, dataset50 and dataset100, which contain 10, 50 and 100 genes with variable number of edges, respectively. They express the steady state levels for the wild-type and the null-mutant strains for each gene. The continuous-valued gene expression data was converted to Boolean-valued data by using the <italic toggle="yes">K</italic>-means clustering algorithm (<xref rid="btab295-B25" ref-type="bibr">MacQueen, 1967</xref>). To show that our method is stable against the Binarization result, we generated 50 different Boolean-valued gene expression datasets by varying the starting centroids in the <italic toggle="yes">K</italic>-means clustering algorithm. Then the Boolean-valued steady-states of all genes were used as an input to execute the CGA-BNI.</p>
      <p>In addition, we generated artificial datasets as follows. Ten groups of random Boolean networks with different network sizes (<inline-formula id="IE212"><mml:math id="IM212" display="inline" overflow="scroll"><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:mn>20</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:mn>100</mml:mn></mml:math></inline-formula> and <inline-formula id="IE213"><mml:math id="IM213" display="inline" overflow="scroll"><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula>) are created by using the Barabási-Albert (BA) model (<xref rid="btab295-B4" ref-type="bibr">Barabási and Albert, 1999</xref>) (see Supplementary Fig. S1 in <xref rid="sup1" ref-type="supplementary-material">Supplementary Information</xref> for the pseudo-code). For each group, 20 networks were generated and thus a total of 200 BA random networks were created. For each network, the update rules of all genes were randomly generated. The number of initial-states was set to 10000, and the corresponding wild-type attractors were computed. In addition, each gene was subject to a knockout perturbation and the corresponding mutated attractor was calculated. In both of DREAM and random BA networks datasets, CGA-BNI outputs an inferred network structure and predicts wild-type and mutated attractors of all genes. Accordingly, we analyzed the performance of CGA-BNI in terms of both structural and dynamics accuracies.</p>
      <p>To verify that the inference problem is not trivial, we examined the ratio of ‘0’ value for each gene in one of the binarized steady-state gene expression datasets (see Supplementary <xref rid="sup1" ref-type="supplementary-material">Fig. S5</xref> in <xref rid="sup1" ref-type="supplementary-material">Supplementary Information</xref>). As shown in the figure, most of them are not biased to 0 or 1. This implies that a simple regulatory rule which almost outputs a constant value cannot be a good solution.</p>
      <p>
        <bold>Structural accuracy analysis</bold>
      </p>
      <p>To compare performance, we applied CGA-BNI, CellNOptR, ARACNE, GENIE3, BC3NET and BTR to the DREAM and random BA networks datasets and examined the structural accuracies with respect to the inferred networks (<xref rid="btab295-F4" ref-type="fig">Fig. 4</xref> and Supplementary <xref rid="sup1" ref-type="supplementary-material">Fig. S3</xref> in <xref rid="sup1" ref-type="supplementary-material">Supplementary Information</xref>). CellNOptR is an open-source R package for building predictive logic models of signaling networks by training networks derived from prior knowledge to signaling data (<xref rid="btab295-B33" ref-type="bibr">Terfve <italic toggle="yes">et al.</italic>, 2012</xref>). ARACNE (<xref rid="btab295-B26" ref-type="bibr">Margolin <italic toggle="yes">et al.</italic>, 2006</xref>) represents one of the most widely used reverse engineering algorithms, and it uses an information theoretic framework based on the data processing inequality to identify direct regulatory relationships between transcriptional regulator proteins and target genes. GENIE3 (<xref rid="btab295-B16" ref-type="bibr">Huynh-Thu <italic toggle="yes">et al.</italic>, 2010</xref>) exploits a variable importance score derived from Random Forests to retrieve the regulators of each target gene, and it showed high performance in both the DREAM4 and DREAM5 challenges. BC3NET (<xref rid="btab295-B10" ref-type="bibr">de Matos Simoes and Emmert-Streib, 2012</xref>) is an ensemble method based on bagging the C3NET algorithm (<xref rid="btab295-B2" ref-type="bibr">Altay and Emmert-Streib, 2010</xref>) and it is a Bayesian approach with non-informative priors. BTR is an approach based on the swarming hill climbing strategy, in which a population of multiple solutions are heuristically searched in an iterative way until they are converged. We note that both BTR and our method are based on a search strategy in a solution space. However, BTR is more geared toward a local search and it even requires an initial network structure. In fact, BTR was not so scalable that it failed to infer a network in the cases of dataset50 and dataset100 in the DREAM datasets and the cases of the networks with &gt;10 genes in the artificial BA datasets. We used default values for the parameters in all the compared methods.</p>
      <fig position="float" id="btab295-F4">
        <label>Fig. 4.</label>
        <caption>
          <p>Comparison of precision, recall, structural accuracy, dynamic accuracy and running time between CGA-BNI and other methods in DREAM datasets. (<bold>a</bold>–<bold>e</bold>) Results of precision, recall, structural accuracy, dynamic accuracy and running time, respectively. In all subfigures, the three synthetic datasets (dataset10, dataset50 and dataset100) from DREAM3 challenge with different network sizes <inline-formula id="IE214"><mml:math id="IM214" display="inline" overflow="scroll"><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:mn>50</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:mn>100</mml:mn></mml:math></inline-formula>, respectively, were used. Y-axis value and error bar represent the average and 95% confidence interval, respectively</p>
        </caption>
        <graphic xlink:href="btab295f4" position="float"/>
      </fig>
      <p>To achieve a stable performance, we conducted the simulations 50 trials and retrieved the average results of precision, recall and structural accuracy over DREAM (<xref rid="btab295-F4" ref-type="fig">Fig. 4a–c</xref>) and BA (Supplementary <xref rid="sup1" ref-type="supplementary-material">Fig. S3</xref>a–c) in <xref rid="sup1" ref-type="supplementary-material">Supplementary Information</xref>) datasets. As shown in the <xref rid="btab295-F4" ref-type="fig">Figure 4a</xref> and Supplementary Figure S3a, CGA-BNI showed significantly higher precision values than those of the other methods (<italic toggle="yes">P</italic>-values &lt; 0.05), and CellNOptR showed a second-best precision. In terms of recall, CellNOptR was best in both DREAM datasets (<xref rid="btab295-F4" ref-type="fig">Fig. 4b</xref>) and BA random datasets (Supplementary <xref rid="sup1" ref-type="supplementary-material">Fig. S3</xref>b). We note that CellNOptR utilizes priori information about the network structure. All other methods were obviously worse than those three methods in both precision and recall. As a result, CGA-BNI, CellNOptR and BC3NET significantly showed the highest structural accuracy in all datasets (<xref rid="btab295-F4" ref-type="fig">Fig. 4c</xref> and Supplementary <xref rid="sup1" ref-type="supplementary-material">Fig. S3</xref>c). We note that our proposed method showed best performance robustly against the network size. In addition, the binarization parameter has little impact on the performance of our method.</p>
      <p>
        <bold>Dynamics accuracy analysis</bold>
      </p>
      <p>Boolean networks with different structures can produce the same dynamics. In this regard, it is also important to verify the network inference performance in terms of the dynamics accuracy. Therefore, we examined the dynamics accuracy (see Methods section for the definition) of the inferred networks by the CGA-BNI, CellNOptR, ARACNE, GENIE3, BC3NET and BTR methods over the DREAM (<xref rid="btab295-F4" ref-type="fig">Fig. 4d</xref>) and random BA networks datasets (Supplementary <xref rid="sup1" ref-type="supplementary-material">Fig. S3</xref>d in <xref rid="sup1" ref-type="supplementary-material">Supplementary Information</xref>). We note that the original ARACNE, GENIE3 and BC3NET methods are not available to infer the regulatory functions. In this regard, we added a ‘regulatory-function-search’ routine which tries to find the optimal update function for each gene in the network structure found by those methods (see Supplementary <xref rid="sup1" ref-type="supplementary-material">Fig. S4</xref> in <xref rid="sup1" ref-type="supplementary-material">Supplementary Information</xref>). In fact, it is equivalent to CGA-BNI except that the canalyzing and canalyzed values removal/insertion mutation operations (see Supplementary <xref rid="sup1" ref-type="supplementary-material">Fig. S2</xref>c and d in <xref rid="sup1" ref-type="supplementary-material">Supplementary Information</xref>) are excluded from consideration because they will change the network structure. As shown in the <xref rid="btab295-F4" ref-type="fig">Figure 4d</xref> and Supplementary Figure S3d, CGA-BNI showed significantly higher dynamics accuracy than all other methods (<italic toggle="yes">P</italic>-values &lt; 0.05). Similar to the structural accuracy, the binarization parameter has little impact on the dynamics accuracy of our method.</p>
      <p>
        <bold>Computation time</bold>
      </p>
      <p>We compared the running time of CGA-BNI with those of the CellNOptR, ARACNE, GENIE3, BC3NET and BTR methods over the DREAM and random BA networks datasets (<xref rid="btab295-F4" ref-type="fig">Fig. 4e</xref> and Supplementary <xref rid="sup1" ref-type="supplementary-material">Fig. S3</xref>e in <xref rid="sup1" ref-type="supplementary-material">Supplementary Information</xref>). In regard to ARACNE, GENIE3 and BC3NET, we measure the time spent for only finding regulatory interactions (i.e. ‘regulatory-function-search’ execution time was not included). The running time of CGA-BNI was significantly smaller than those of GENIE3 and BTR in both types of datasets. In particular, BTR is another global search algorithm as our method, but it was not applicable for large network of <inline-formula id="IE215"><mml:math id="IM215" display="inline" overflow="scroll"><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>&gt;</mml:mo><mml:mn>10</mml:mn></mml:math></inline-formula>. ARACNE and BC3NET achieved the smallest and second-smallest running times in all datasets, but we note that they inferred only the regulatory structure. Despite of the inherently expensive costs, the running time of our method was comparable because the fitness calculation routine in CGA-BNI was implemented in parallel by using the multithreaded Java programming.</p>
    </sec>
    <sec>
      <title>3.2 Performance on a real gene expression dataset</title>
      <p>In order to evaluate the performance of a real expression dataset, we retrieved the largest public <italic toggle="yes">E.coli</italic> microarray dataset (‘<italic toggle="yes">E_coli</italic>_v4_Build_6’) available from the Many Microbe Microarrays database (M3D) (<xref rid="btab295-B12" ref-type="bibr">Faith <italic toggle="yes">et al.</italic>, 2008</xref>). Among 4297 genes of 446 samples, we extracted 44 knockout/overexpression samples with 32 mutated genes and 11 related wild-type samples (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref> in <xref rid="sup1" ref-type="supplementary-material">Supplementary Information</xref> for details). The real-valued gene expression was converted to the Boolean values using a <italic toggle="yes">K</italic>-means clustering algorithm-based discretization method (<xref rid="btab295-B25" ref-type="bibr">MacQueen, 1967</xref>). We generated 50 different Boolean-valued gene expression datasets by varying the starting centroids in the <italic toggle="yes">K</italic>-means clustering algorithm. Next, we obtained a list of genes from the RegulonDB database which curates the largest and best-known information on the transcriptional regulation of <italic toggle="yes">E. coli</italic> (<xref rid="btab295-B31" ref-type="bibr">Salgado <italic toggle="yes">et al.</italic>, 2013</xref>). In this analysis, we focused on the intersection between the M3D and the RegulonDB. Considering a small portion of knockout/overexpression samples, we reduced the network by retaining only out-going interactions of the 32 mutated genes. Consequently, we constructed a <italic toggle="yes">E. coli</italic> network including 925 genes and 1346 transcriptional interactions as a gold standard (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S2</xref> in <xref rid="sup1" ref-type="supplementary-material">Supplementary Information</xref> for details). We note that BTR was not applicable for this analysis due to the unfeasible computational time.</p>
      <p>As shown in <xref rid="btab295-T2" ref-type="table">Table 2</xref>, CGA-BNI achieved the highest precision and recall values among all methods. With respect to the structural accuracy metric, the number of actual and predicted interactions were less than 2000 among 925 × 924 × 2 possible interactions in the <italic toggle="yes">E. coli</italic> network with 925 genes, and thus the comparison was not effective because of a huge number of true negative cases in inference of a large-scale network. Moreover, CGA-BNI showed significantly higher dynamics accuracy than all the other methods. It seems that our GA search might easily find regulatory rules fitting the expression data. In addition, the small standard deviation means that the performance of our method was stable against the binarization parameter. In regard to the running time, we compared the time to infer both structure and regulatory function. In other words, the execution time of ‘regulatory-function-search’ routine for the cases of GENIE3, ARACNE and BC3NET are also included in the total running time. As shown in the table, CGA-BNI was second slowest among them. ARACNE and BC3NET were fastest but their accuracy performances were not acceptable. Taken together, these results indicate that CGA-BNI method is suitable to infer both regulatory interactions and functions of large-scale GRNs when high accuracy is desired at the cost of sacrificing the running time.</p>
      <table-wrap position="float" id="btab295-T2">
        <label>Table 2.</label>
        <caption>
          <p>Comparison of precision, recall, structural accuracy, dynamic accuracy and running time between CGA-BNI and other methods in the large-scale <italic toggle="yes">E.coli</italic> expression dataset. Bold face means the best result in the corresponding metric.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="char" char="±" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Method</th>
              <th rowspan="1" colspan="1">Precision</th>
              <th rowspan="1" colspan="1">Recall</th>
              <th rowspan="1" colspan="1">Structure accuracy</th>
              <th rowspan="1" colspan="1">Dynamic accuracy</th>
              <th rowspan="1" colspan="1">Running time(s)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">CGA-BNI</td>
              <td rowspan="1" colspan="1">
                <bold>0.254 ± 0.001</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.333 ± 0.000</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.997 ± 0.000</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.806 ± 0.001</bold>
              </td>
              <td rowspan="1" colspan="1">2614 ± 145</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">CellNOptR</td>
              <td rowspan="1" colspan="1">0.230 ± 0.001</td>
              <td rowspan="1" colspan="1">0.293 ± 0.001</td>
              <td rowspan="1" colspan="1">0.995 ± 0.000</td>
              <td rowspan="1" colspan="1">0.685 ± 0.000</td>
              <td rowspan="1" colspan="1">2439 ± 164</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">GENIE3</td>
              <td rowspan="1" colspan="1">0.006 ± 0.000</td>
              <td rowspan="1" colspan="1">0.018 ± 0.001</td>
              <td rowspan="1" colspan="1">0.994 ± 0.000</td>
              <td rowspan="1" colspan="1">0.614 ± 0.001</td>
              <td rowspan="1" colspan="1">7454 ± 1003</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">ARACNE</td>
              <td rowspan="1" colspan="1">0.005 ± 0.000</td>
              <td rowspan="1" colspan="1">0.015 ± 0.000</td>
              <td rowspan="1" colspan="1">0.994 ± 0.000</td>
              <td rowspan="1" colspan="1">0.602 ± 0.000</td>
              <td rowspan="1" colspan="1">232±13</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BC3NET</td>
              <td rowspan="1" colspan="1">0.006 ± 0.001</td>
              <td rowspan="1" colspan="1">0.015 ± 0.001</td>
              <td rowspan="1" colspan="1">0.995 ± 0.000</td>
              <td rowspan="1" colspan="1">0.604 ± 0.001</td>
              <td rowspan="1" colspan="1">
                <bold>131±6</bold>
              </td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
  </sec>
  <sec>
    <title>4 Conclusions</title>
    <p>In this study, we proposed a novel constrained genetic algorithm-based Boolean network inference method, CGA-BNI. Through extensive simulations on the benchmark datasets from DREAM challenge, artificial datasets and a large-scale gene expression dataset in <italic toggle="yes">E. coli</italic>, CGA-BNI showed consistently better performance than four well-known existing methods, ARACNE, GENIE3, BC3NET and BTR in terms of both structural and dynamics prediction accuracy. It turns out that the GA search combining with path consistency-based constraints and network dynamics is efficient to infer a network from gene expression data. CGA-BNI also showed acceptable running time for the large-scale dataset. Taken together, CGA-BNI is a promising tool for predicting both the structure and the dynamics of a gene regulatory network.</p>
    <p>There are some notable issues to be discussed. First, we used the synchronous update scheme for the Boolean network model. In fact, it is more likely that the genes are asynchronously updated in the real signaling networks. However, the asynchronous update scheme requires some additional parameters such as the update order of genes, which are generally unknown. Considering that they affect the network dynamics greatly, it is not guaranteed that the asynchronous update scheme can describe the dynamics of a real signaling network more accurately than the synchronous scheme. In addition, we employed NCFs to randomly specify the update rule. It is known that NCFs can represent various types of regulatory interactions (<xref rid="btab295-B32" ref-type="bibr">Samal and Jain, 2008</xref>; <xref rid="btab295-B34" ref-type="bibr">Trinh and Kwon, 2016</xref>). Despite of the effectiveness of NCFs, a more realistic representation model of the regulatory interaction can improve the usefulness of our tool. Another issue is that CGA-BNI can include a way to help the search to avoid local optima. In fact, it already has some characteristics to keep the diversity of a population such as a relatively large population size, no crossover operation and the replacement of a parent solution with a worse new solution. Finally, it is necessary to validate our approach through other evaluation framework using a single-cell transcriptomic data (<xref rid="btab295-B29" ref-type="bibr">Pratapa <italic toggle="yes">et al.</italic>, 2020</xref>).</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by the 2021 Research Fund of University of Ulsan.</p>
    <p><italic toggle="yes">Conflict of Interest</italic>: none declared.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btab295_Supplementary_Data</label>
      <media xlink:href="btab295_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btab295-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Almudevar</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2011</year>) <article-title>Fitting Boolean networks from steady state perturbation data</article-title>. <source>Stat. Appl. Genet. Mol. Biol</source>., <volume>10</volume>, <fpage>47</fpage>.<pub-id pub-id-type="pmid">23089817</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Altay</surname><given-names>G.</given-names></string-name>, <string-name><surname>Emmert-Streib</surname><given-names>F.</given-names></string-name></person-group> (<year>2010</year>) <article-title>Inferring the conservative causal core of gene regulatory networks</article-title>. <source>BMC Syst. Biol</source>., <volume>4</volume>, <fpage>132</fpage>.<pub-id pub-id-type="pmid">20920161</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Banf</surname><given-names>M.</given-names></string-name>, <string-name><surname>Rhee</surname><given-names>S.Y.</given-names></string-name></person-group> (<year>2017</year>) <article-title>Computational inference of gene regulatory networks: approaches, limitations and opportunities</article-title>. <source>Biochim. Biophys. Acta Gene Regul. Mech</source>., <volume>1860</volume>, <fpage>41</fpage>–<lpage>52</lpage>.<pub-id pub-id-type="pmid">27641093</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Barabási</surname><given-names>A.-L.</given-names></string-name>, <string-name><surname>Albert</surname><given-names>R.</given-names></string-name></person-group> (<year>1999</year>) <article-title>Emergence of scaling in random networks</article-title>. <source>Science</source>, <volume>286</volume>, <fpage>509</fpage>–<lpage>512</lpage>.<pub-id pub-id-type="pmid">10521342</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Barman</surname><given-names>S.</given-names></string-name>, <string-name><surname>Kwon</surname><given-names>Y.-K.</given-names></string-name></person-group> (<year>2017</year>) <article-title>A novel mutual information-based Boolean network inference method from time-series gene expression data</article-title>. <source>PLoS One</source>, <volume>12</volume>, <fpage>e0171097</fpage>.<pub-id pub-id-type="pmid">28178334</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Berestovsky</surname><given-names>N.</given-names></string-name>, <string-name><surname>Nakhleh</surname><given-names>L.</given-names></string-name></person-group> (<year>2013</year>) <article-title>An evaluation of methods for inferring Boolean networks from time-series data</article-title>. <source>PLoS One</source>, <volume>8</volume>, <fpage>e66031</fpage>.<pub-id pub-id-type="pmid">23805196</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chai</surname><given-names>L.E.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) <article-title>A review on the computational approaches for gene regulatory network construction</article-title>. <source>Comput. Biol. Med</source>., <volume>48</volume>, <fpage>55</fpage>–<lpage>65</lpage>.<pub-id pub-id-type="pmid">24637147</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B8">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Chevalier</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) Synthesis of Boolean networks from biological dynamical constraints using answer-set programming. In: <italic toggle="yes">2019 IEEE 31st International Conference on Tools with Artificial Intelligence (ICTAI)</italic>. Portland, OR, USA, pp. <fpage>34</fpage>–<lpage>41</lpage>.</mixed-citation>
    </ref>
    <ref id="btab295-B9">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Coddington</surname><given-names>E.A.</given-names></string-name>, <string-name><surname>Levinson</surname><given-names>N.</given-names></string-name></person-group> (<year>1955</year>) <source>Theory of Ordinary Differential Equations</source>. <publisher-name>Tata McGraw-Hill Education, New York, USA</publisher-name>.</mixed-citation>
    </ref>
    <ref id="btab295-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>de Matos Simoes</surname><given-names>R.</given-names></string-name>, <string-name><surname>Emmert-Streib</surname><given-names>F.</given-names></string-name></person-group> (<year>2012</year>) <article-title>Bagging statistical network inference from large-scale gene expression data</article-title>. <source>PLoS One</source>, <volume>7</volume>, <fpage>e33624</fpage>.<pub-id pub-id-type="pmid">22479422</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>De Smet</surname><given-names>R.</given-names></string-name>, <string-name><surname>Marchal</surname><given-names>K.</given-names></string-name></person-group> (<year>2010</year>) <article-title>Advantages and limitations of current network inference methods</article-title>. <source>Nat. Rev. Micro</source>, <volume>8</volume>, <fpage>717</fpage>–<lpage>729</lpage>.</mixed-citation>
    </ref>
    <ref id="btab295-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Faith</surname><given-names>J.J.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2008</year>) <article-title>Many microbe microarrays database: uniformly normalized affymetrix compendia with structured experimental metadata</article-title>. <source>Nucleic Acids Res</source>., <volume>36</volume>, <fpage>D866</fpage>–<lpage>D870</lpage>.<pub-id pub-id-type="pmid">17932051</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Han</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2015</year>) <article-title>A full Bayesian approach for Boolean genetic network inference</article-title>. <source>PLoS One</source>, <volume>9</volume>, <fpage>e115806</fpage>.</mixed-citation>
    </ref>
    <ref id="btab295-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Helikar</surname><given-names>T.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2008</year>) <article-title>Emergent decision-making in biological signal transduction networks</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>105</volume>, <fpage>1913</fpage>–<lpage>1918</lpage>.<pub-id pub-id-type="pmid">18250321</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Hughes</surname><given-names>T.R.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2000</year>) <article-title>Functional discovery via a compendium of expression profiles</article-title>. <source>Cell</source>, <volume>102</volume>, <fpage>109</fpage>–<lpage>126</lpage>.<pub-id pub-id-type="pmid">10929718</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Huynh-Thu</surname><given-names>V.A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2010</year>) <article-title>Inferring regulatory networks from expression data using tree-based methods</article-title>. <source>PLoS One</source>, <volume>5</volume>, <fpage>e12776</fpage>.<pub-id pub-id-type="pmid">20927193</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kauffman</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2004</year>) <article-title>Genetic networks with canalyzing Boolean rules are always stable</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>101</volume>, <fpage>17102</fpage>–<lpage>17107</lpage>.<pub-id pub-id-type="pmid">15572453</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kauffman</surname><given-names>S.A.</given-names></string-name></person-group> (<year>1969</year>) <article-title>Metabolic stability and epigenesis in randomly constructed genetic nets</article-title>. <source>J. Theor. Biol</source>., <volume>22</volume>, <fpage>437</fpage>–<lpage>467</lpage>.<pub-id pub-id-type="pmid">5803332</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B19">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Kauffman</surname><given-names>S.A.</given-names></string-name></person-group> (<year>1993</year>) <source>The Origins of Order: Self-Organization and Selection in Evolution</source>. <publisher-name>Oxford University Press</publisher-name>, <publisher-loc>New York, Oxford</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btab295-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kotera</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2012</year>) <article-title>GENIES: gene network inference engine based on supervised analysis</article-title>. <source>Nucleic Acids Res</source>., <volume>40</volume>, <fpage>W162</fpage>–<lpage>W167</lpage>.<pub-id pub-id-type="pmid">22610856</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Krämer</surname><given-names>N.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2009</year>) <article-title>Regularized estimation of large-scale gene association networks using graphical Gaussian models</article-title>. <source>BMC Bioinformatics</source>, <volume>10</volume>, <fpage>384</fpage>.<pub-id pub-id-type="pmid">19930695</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Le</surname><given-names>D.H.</given-names></string-name>, <string-name><surname>Kwon</surname><given-names>Y.K.</given-names></string-name></person-group> (<year>2011</year>) <article-title>The effects of feedback loops on disease comorbidity in human signaling networks</article-title>. <source>Bioinformatics</source>, <volume>27</volume>, <fpage>1113</fpage>–<lpage>1120</lpage>.<pub-id pub-id-type="pmid">21325303</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lim</surname><given-names>C.Y.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) <article-title>BTR: training asynchronous Boolean models using single-cell expression data</article-title>. <source>BMC Bioinformatics</source>, <volume>17</volume>, <fpage>355</fpage>.<pub-id pub-id-type="pmid">27600248</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Liu</surname><given-names>F.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) <article-title>Inference of gene regulatory network based on local bayesian networks</article-title>. <source>PLoS Comput. Biol</source>., <volume>12</volume>, <fpage>e1005024</fpage>.<pub-id pub-id-type="pmid">27479082</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B25">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>MacQueen</surname><given-names>J.</given-names></string-name></person-group> (<year>1967</year>) Some methods for classification and analysis of multivariate observations. In <italic toggle="yes">Proceedings of the Fifth Berkeley Symposium on Mathematical Statistics and Probability</italic>, Volume 1: Statistics. University of California Press, Berkeley, CA, pp. <fpage>281</fpage>–<lpage>297</lpage>.</mixed-citation>
    </ref>
    <ref id="btab295-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Margolin</surname><given-names>A.A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2006</year>) <article-title>ARACNE: an algorithm for the reconstruction of gene regulatory networks in a mammalian cellular context</article-title>. <source>BMC Bioinformatics</source>, <volume>7</volume>, <fpage>S7</fpage>–<lpage>S7</lpage>.</mixed-citation>
    </ref>
    <ref id="btab295-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Maucher</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2011</year>) <article-title>Inferring Boolean network structure via correlation</article-title>. <source>Bioinformatics</source>, <volume>27</volume>, <fpage>1529</fpage>–<lpage>1536</lpage>.<pub-id pub-id-type="pmid">21471013</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Menéndez</surname><given-names>P.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2010</year>) <article-title>Gene regulatory networks from multifactorial perturbations using graphical Lasso: application to the DREAM4 challenge</article-title>. <source>PLoS One</source>, <volume>5</volume>, <fpage>e14147</fpage>.<pub-id pub-id-type="pmid">21188141</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Pratapa</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2020</year>) <article-title>Benchmarking algorithms for gene regulatory network inference from single-cell transcriptomic data</article-title>. <source>Nat. Methods</source>, <volume>17</volume>, <fpage>147</fpage>–<lpage>154</lpage>.<pub-id pub-id-type="pmid">31907445</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Quackenbush</surname><given-names>J.</given-names></string-name></person-group> (<year>2001</year>) <article-title>Computational analysis of microarray data</article-title>. <source>Nat. Rev. Genet</source>., <volume>2</volume>, <fpage>418</fpage>–<lpage>427</lpage>.<pub-id pub-id-type="pmid">11389458</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Salgado</surname><given-names>H.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2013</year>) <article-title>RegulonDB v8.0: omics data sets, evolutionary conservation, regulatory phrases, cross-validated gold standards and more</article-title>. <source>Nucleic Acids Res</source>., <volume>41</volume>, <fpage>D203</fpage>–<lpage>D213</lpage>.<pub-id pub-id-type="pmid">23203884</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Samal</surname><given-names>A.</given-names></string-name>, <string-name><surname>Jain</surname><given-names>S.</given-names></string-name></person-group> (<year>2008</year>) <article-title>The regulatory network of <italic toggle="yes">E. coli</italic> metabolism as a Boolean dynamical system exhibits both homeostasis and flexibility of response</article-title>. <source>BMC Syst. Biol</source>., <volume>2</volume>, <fpage>21</fpage>.<pub-id pub-id-type="pmid">18312613</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Terfve</surname><given-names>C.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2012</year>) <article-title>CellNOptR: a flexible toolkit to train protein signaling networks to data using multiple logic formalisms</article-title>. <source>BMC Syst. Biol</source>., <volume>6</volume>, <fpage>133</fpage>.<pub-id pub-id-type="pmid">23079107</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Trinh</surname><given-names>H.C.</given-names></string-name>, <string-name><surname>Kwon</surname><given-names>Y.K.</given-names></string-name></person-group> (<year>2016</year>) <article-title>Edge-based sensitivity analysis of signaling networks by using Boolean dynamics</article-title>. <source>Bioinformatics</source>, <volume>32</volume>, <fpage>i763</fpage>–<lpage>i771</lpage>.<pub-id pub-id-type="pmid">27587699</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Trinh</surname><given-names>H.C.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) <article-title>PANET: a GPU-based tool for fast parallel analysis of robustness dynamics and feed-forward/feedback loop structures in large-scale biological networks</article-title>. <source>PLoS One</source>, <volume>9</volume>, <fpage>e103010</fpage>.<pub-id pub-id-type="pmid">25058310</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Xiao</surname><given-names>F.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) <article-title>Inferring gene regulatory networks using conditional regulation pattern to guide candidate genes</article-title>. <source>PLoS One</source>, <volume>11</volume>, <fpage>e0154953</fpage>.<pub-id pub-id-type="pmid">27171286</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B37">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yu</surname><given-names>D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) <article-title>Enhanced construction of gene regulatory networks using hub gene information</article-title>. <source>BMC Bioinformatics</source>, <volume>18</volume>, <fpage>186</fpage>.<pub-id pub-id-type="pmid">28335719</pub-id></mixed-citation>
    </ref>
    <ref id="btab295-B38">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zuo</surname><given-names>Y.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) <article-title>Biological network inference using low order partial correlation</article-title>. <source>Methods</source>, <volume>69</volume>, <fpage>266</fpage>–<lpage>273</lpage>.<pub-id pub-id-type="pmid">25003577</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
