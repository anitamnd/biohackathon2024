<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d1 20130915//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 39.96?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4908322</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btw076</article-id>
    <article-id pub-id-type="publisher-id">btw076</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="heading">
          <subject>Gene Expression</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title><italic>SplAdder</italic>: identification, quantification and testing of alternative splicing events from RNA-Seq data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Kahles</surname>
          <given-names>André</given-names>
        </name>
        <xref ref-type="aff" rid="btw076-aff1">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="btw076-cor1">*</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ong</surname>
          <given-names>Cheng Soon</given-names>
        </name>
        <xref ref-type="aff" rid="btw076-aff2">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Zhong</surname>
          <given-names>Yi</given-names>
        </name>
        <xref ref-type="aff" rid="btw076-aff1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Rätsch</surname>
          <given-names>Gunnar</given-names>
        </name>
        <xref ref-type="aff" rid="btw076-aff1">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="btw076-cor1">*</xref>
      </contrib>
      <aff id="btw076-aff1"><sup>1</sup>Memorial Sloan Kettering Cancer Center, New York, NY 10065, USA and</aff>
      <aff id="btw076-aff2"><sup>2</sup>Canberra Research Laboratory, NICTA, Canberra, ACT 2601, Australia</aff>
    </contrib-group>
    <author-notes>
      <corresp id="btw076-cor1">*To whom correspondence should be addressed.</corresp>
      <fn id="btw076-FN1">
        <p>Associate Editor: Janet Kelso</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>6</month>
      <year>2016</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>11</day>
      <month>2</month>
      <year>2016</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>11</day>
      <month>2</month>
      <year>2016</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>32</volume>
    <issue>12</issue>
    <fpage>1840</fpage>
    <lpage>1847</lpage>
    <history>
      <date date-type="received">
        <day>25</day>
        <month>3</month>
        <year>2015</year>
      </date>
      <date date-type="rev-recd">
        <day>18</day>
        <month>12</month>
        <year>2015</year>
      </date>
      <date date-type="accepted">
        <day>04</day>
        <month>2</month>
        <year>2016</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author 2016. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2016</copyright-year>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/" license-type="creative-commons">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation</bold>: Understanding the occurrence and regulation of alternative splicing (AS) is a key task towards explaining the regulatory processes that shape the complex transcriptomes of higher eukaryotes. With the advent of high-throughput sequencing of RNA (RNA-Seq), the diversity of AS transcripts could be measured at an unprecedented depth. Although the catalog of known AS events has grown ever since, novel transcripts are commonly observed when working with less well annotated organisms, in the context of disease, or within large populations. Whereas an identification of complete transcripts is technically challenging and computationally expensive, focusing on single splicing events as a proxy for transcriptome characteristics is fruitful and sufficient for a wide range of analyses.</p>
      <p><bold>Results</bold>: We present SplAdder, an alternative splicing toolbox, that takes RNA-Seq alignments and an annotation file as input to (i) augment the annotation based on RNA-Seq evidence, (ii) identify alternative splicing events present in the augmented annotation graph, (iii) quantify and confirm these events based on the RNA-Seq data and (iv) test for significant quantitative differences between samples. Thereby, our main focus lies on performance, accuracy and usability.</p>
      <p><bold>Availability:</bold> Source code and documentation are available for download at <ext-link ext-link-type="uri" xlink:href="http://github.com/ratschlab/spladder">http://github.com/ratschlab/spladder</ext-link>. Example data, introductory information and a small tutorial are accessible via <ext-link ext-link-type="uri" xlink:href="http://bioweb.me/spladder">http://bioweb.me/spladder</ext-link>.</p>
      <p><bold>Contacts</bold>: <email>andre.kahles@ratschlab.org</email> or <email>gunnar.ratsch@ratschlab.org</email></p>
      <p><bold>Supplementary information:</bold><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplementary data</ext-link> are available at <italic>Bioinformatics</italic> online.</p>
    </abstract>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Alternative splicing (AS) is an mRNA processing mechanism that cuts and re-joins maturing mRNA in a highly regulated manner, thereby increasing transcriptome complexity. Depending on the organism, up to 95% of expressed genes are transcribed into multiple transcript variants (<xref rid="btw076-B20" ref-type="bibr">Pan <italic>et al.</italic>, 2008</xref>; <xref rid="btw076-B25" ref-type="bibr">Wang <italic>et al.</italic>, 2008</xref>), where various transcripts with differing exon composition can arise from the same gene locus. (Throughout this text, we will use the term <italic>transcript</italic> to identify a variant of a gene that was generated through transcriptional processing.) Although these transcripts might never coexist at the same time and place, each one of them can be essential for cell differentiation, development or play an important role within signaling processes (<xref rid="btw076-B17" ref-type="bibr">Kornblihtt <italic>et al.</italic>, 2013</xref>). Thus, the two major challenges in computational transcriptome analysis are complexity and completeness. In SplAdder, we leverage evidence from RNA-Seq data to compute a more complete representation of the splicing diversity within a sample and tackle the complexity with a reduction to alternative splicing events instead of full transcripts. We provide open source implementations for SplAdder in MATLAB and Python that contain all features described below and produce the same results. However, future development will focus on the Python implementation for reasons of accessibility. All inputs follow the standardized formats for alignments and annotation such as BAM and GFF. For complete examples, use cases and information regarding the user interface, we provide a <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">supplementary website</ext-link>. User documentation is available in the wiki section of the source code repository.</p>
    <p>In Section 2 we will give a brief overview on related approaches that also focus on the analysis and quantification of alternative splicing based on RNA-Seq data. Our main focus will be on methods that are able to characterize alternative splicing events. In the subsequent Section 3, we give an outline of the SplAdder methodology and the algorithmic details of its main compute phases. To show how SplAdder compares to other strategies for RNA-Seq based alternative splicing analysis, we have compiled a set of different evaluations and comparisons to existing methods. Our experimental design will be described in Section 4 and the main results are discussed in Section 5. Lastly, Section 6 summarizes this work.</p>
  </sec>
  <sec>
    <title>2 Related work</title>
    <p>Prior to the advent of high throughput RNA-Seq, methods based on expressed sequence tags (ESTs) were developed to elucidate the complex patterns of alternative splicing in higher organisms (<xref rid="btw076-B19" ref-type="bibr">Modrek and Lee, 2002</xref>). Although designed for a much lower data throughput, the algorithmic ideas presented for ESTs have had a strong influence to the field in the following years. One central idea is the representation of splicing variation at a gene locus as a graph that encodes exon segments as nodes and the intron segments as connecting edges (<xref rid="btw076-B6" ref-type="bibr">Eichner <italic>et al.</italic>, 2011</xref>; <xref rid="btw076-B13" ref-type="bibr">Heber <italic>et al.</italic>, 2002</xref>; <xref rid="btw076-B15" ref-type="bibr">Kianianmomeni <italic>et al.</italic>, 2014</xref>). Similar to SplAdder, numerous tools are based on such splicing graph representations; however, none of the existing approaches combines all aspects of the SplAdder workflow: the augmentation of existing annotation information, the detection and quantification of alternative splicing events, differential testing of events between two given sets of samples and detailed visualization of the splicing variation. There exist several approaches that cover at least a subset of the steps in the SplAdder pipeline. The most notable ones are JuncBase (<xref rid="btw076-B2" ref-type="bibr">Brooks <italic>et al.</italic>, 2011</xref>), rMATS (<xref rid="btw076-B23" ref-type="bibr">Shen <italic>et al.</italic>, 2014</xref>) and SpliceGrapher (<xref rid="btw076-B22" ref-type="bibr">Rogers <italic>et al.</italic>, 2012</xref>). JuncBase utilizes third party prediction tools such as Cufflinks (<xref rid="btw076-B24" ref-type="bibr">Trapnell <italic>et al.</italic>, 2010</xref>) to allow for the detection of novel exon nodes in the splicing graph. It then extracts and quantifies splicing events of the most common AS types and reports them in a custom format. Further, JuncBase provides basic differential analyses and basic visualizations of the test results. However, the pipeline consists of 10 different steps, including building a Cufflinks output based database, which is quite laborious to generate, has a long running-time and is thus not ideal for larger scale studies. SpliceGrapher directly integrates information from RNA-Seq or EST data into a splicing graph and can display splicing events in the graph visualizations. Unfortunately, it does not provide an easy method to explicitly generate and quantify alternative splicing events and does not allow for differential analysis. rMATs focuses on the differential analysis of splicing between RNA-Seq samples. It can detect the most common AS events from either RNA-Seq alignments or from a set of reads by applying a third party mapping algorithm. Based on the RNA-Seq evidence, it will also fill in some missing information to call events not present in the provided annotation but has a limited capacity to do so.</p>
    <p>Other methods, such as Scripture (<xref rid="btw076-B11" ref-type="bibr">Guttman <italic>et al.</italic>, 2010</xref>), Cufflinks (<xref rid="btw076-B24" ref-type="bibr">Trapnell <italic>et al.</italic>, 2010</xref>) or MISO (<xref rid="btw076-B14" ref-type="bibr">Katz <italic>et al.</italic>, 2010</xref>) also use graphs internally and allow for novel splice variants based on RNA-Seq evidence but focus on the prediction of full transcripts instead of single events. These tools aim to solve a much harder problem and thereby miss potential local variability for AS studies. These tools are also computationally more expensive, limiting their applicability in the context of thousands of samples. Another popular tool that is focused on the extraction of alternative splicing events from a given annotated locus is the Astalavista toolbox (<xref rid="btw076-B7" ref-type="bibr">Foissac and Sammeth, 2007</xref>). Although many splicing events are covered in the detection phase, the tool relies on a complete annotation as input and does not provide any quantification values for the events However, the authors introduce a logical representation of splice events (the splicing code) that we will utilize later on. The software SpliceTrap (<xref rid="btw076-B27" ref-type="bibr">Wu <italic>et al.</italic>, 2011</xref>) is able to generate quantification values for the most common AS types, but recognizes much fewer transcripts than Astalavista. For both tools no novel splice variants are considered.</p>
    <p>In our evaluation on simulated data, we will show that SplAdder is more accurate in detecting novel events and shows better performance in differential analysis than any of the tested competitors. We have chosen to compare SplAdder against JuncBase, rMATS and SpliceGrapher as these methods are closest to the presented SplAdder pipeline. We discuss further details regarding the comparisons in Section 4 and Suppl. Section D.</p>
  </sec>
  <sec>
    <title>3 Approach</title>
    <p>The SplAdder algorithm consists of multiple steps that convert a given annotation into a splicing graph, enrich that graph with splicing evidence from RNA-Seq samples, identify splicing events from the augmented graph and use the given RNA-Seq data to quantify the single events (<xref ref-type="fig" rid="btw076-F1">Fig. 1</xref>). Optionally, the quantifications can then be used for differential analysis. We find this distinction important, as differential analysis between samples is only one of many possible applications of AS event phenotypes. Other examples may include generating of sample specific splicing profiles or using AS phenotypes in genome-wide association studies.
<fig id="btw076-F1" orientation="portrait" position="float"><label>Fig. 1.</label><caption><p>SplAdder analysis flowchart. The main steps of the SplAdder workflow consist of (1) integrating annotation information and RNA-Seq data, (2) generating an augmented splicing graph from the integrated data, (3) extraction of splicing events from that graph, (4) quantifying the extracted events and optionally (5) the differential analysis between samples and producing visualizations</p></caption><graphic xlink:href="btw076f1p"/></fig>
</p>
    <sec>
      <title>3.1 Preliminaries</title>
      <p>Here, we will introduce our notation and make definitions that will be used throughout the following descriptions of the algorithm.</p>
      <sec>
        <title>3.1.1 Coordinates</title>
        <p>All positions used in the following descriptions are in a genomic coordinate system. We begin by defining the genome <inline-formula id="IE1"><mml:math id="IEQ1"><mml:mi mathvariant="double-struck">G</mml:mi></mml:math></inline-formula> as a string of consecutive positions <inline-formula id="IE2"><mml:math id="IEQ2"><mml:mrow><mml:mi mathvariant="double-struck">G</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mi>g</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. When addressing any range <italic>x</italic> within these positions, e.g. to define a gene <italic>x</italic>, we describe this as the pair of the first and the last position of <inline-formula id="IE3"><mml:math id="IEQ3"><mml:mrow><mml:mi>x</mml:mi><mml:mo>:</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mtext>start</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mtext>end</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. When addressing a specific entity <italic>x<sub>i</sub></italic>, we will write <inline-formula id="IE4"><mml:math id="IEQ4"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mtext>start</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mtext>end</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. For simplicity, we ignore chromosomes and assume the genome to be one continuous string.</p>
      </sec>
      <sec>
        <title>3.1.2 Representation of genes as transcript graphs</title>
        <p>A given gene annotation can be represented as a set of linear directed graphs. Assume gene <inline-formula id="IE5"><mml:math id="IEQ5"><mml:mi mathvariant="script" class="calligraphy">G</mml:mi></mml:math></inline-formula> as given, that has <italic>k</italic> different transcripts <inline-formula id="IE6"><mml:math id="IEQ6"><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>…</mml:mo><mml:mo> </mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi mathvariant="script" class="calligraphy">G</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE7"><mml:math id="IEQ7"><mml:mrow><mml:msub><mml:mi>J</mml:mi><mml:mi mathvariant="script" class="calligraphy">G</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the set of all transcripts of gene <inline-formula id="IE8"><mml:math id="IEQ8"><mml:mi mathvariant="script" class="calligraphy">G</mml:mi></mml:math></inline-formula>. As we consider each gene <inline-formula id="IE9"><mml:math id="IEQ9"><mml:mi mathvariant="script" class="calligraphy">G</mml:mi></mml:math></inline-formula> independently, we will omit the index <inline-formula id="IE10"><mml:math id="IEQ10"><mml:mi mathvariant="script" class="calligraphy">G</mml:mi></mml:math></inline-formula> wherever possible in order to keep the notation uncluttered. Each transcript consists of a set of exons that are connected by introns. Each exon can be uniquely identified by its start and end. We thus represent all exons as coordinate pairs of their genomic start and end position:
<disp-formula id="E1"><mml:math id="EQ1"><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mtext>start</mml:mtext><mml:mo>,</mml:mo><mml:mtext>end</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mtext>start</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mtext>end</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mi mathvariant="double-struck">N</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
</p>
        <p>where <inline-formula id="IE11"><mml:math id="IEQ11"><mml:mrow><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mtext>start</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE12"><mml:math id="IEQ12"><mml:mrow><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mtext>end</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> are the first and last position of exon <italic>v</italic> in genomic coordinates, respectively. Although further coordinate information like chromosome and strand are used in the program implementation, we will limit this description to an identification by start and end for simplicity. The exons of each transcript <italic>j<sub>i</sub></italic> can then be represented as a node set <inline-formula id="IE13"><mml:math id="IEQ13"><mml:mrow><mml:msub><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> with <inline-formula id="IE14"><mml:math id="IEQ14"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> and <italic>m<sub>i</sub></italic> as the number of exons in transcript <italic>j<sub>i</sub></italic>. As transcripts have a direction (the exons within a transcript follow a strict order), we require, that the index of the nodes reflects the order of the exons in the transcript. As no two exons in a transcript overlap by definition, this order is implied by <inline-formula id="IE15"><mml:math id="IEQ15"><mml:mrow><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mtext>start</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE16"><mml:math id="IEQ16"><mml:mrow><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mtext>end</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. We then define the edge set of transcript <italic>j<sub>i</sub></italic> as
<disp-formula id="E2"><mml:math id="EQ2"><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>⋃</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>s</mml:mi><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:munder><mml:mrow><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo></mml:mrow></mml:mstyle><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>}</mml:mo><mml:mo>⊂</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></disp-formula>
</p>
        <p>with <inline-formula id="IE17"><mml:math id="IEQ17"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. The pair <inline-formula id="IE18"><mml:math id="IEQ18"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> forms the directed <italic>transcript graph</italic> of transcript <italic>j<sub>i</sub></italic>.</p>
      </sec>
      <sec>
        <title>3.1.3 Definition of Splicing Graphs</title>
        <p>We define the set of exons occurring in <italic>any</italic> transcript <italic>j<sub>i</sub></italic> as <italic>V</italic>. As the single exons are uniquely identified by their coordinates, we can write <inline-formula id="IE19"><mml:math id="IEQ19"><mml:mrow><mml:mi>V</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∪</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:math></inline-formula>. Hence, we define the set of all edges as
<disp-formula id="E3"><mml:math id="EQ3"><mml:mrow><mml:mi>E</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>⋃</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>⊂</mml:mo><mml:mi>V</mml:mi><mml:mo>×</mml:mo><mml:mi>V</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
</p>
        <p>Note that only already existing edges are merged, preserving the preexisting order of nodes. The pair <inline-formula id="IE20"><mml:math id="IEQ20"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a directed acyclic graph and is called the <italic>splicing graph</italic> representation of a gene. <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplemental Figure S2</ext-link> illustrates how a set of five transcripts is collapsed into a splicing graph. The key concept is, that when multiple transcripts contain the same exon, this will be represented by a single node in the splicing graph.</p>
        <p>We define the <italic>in-degree</italic> and the <italic>out-degree</italic> of a node as the number of its incoming and outgoing edges, respectively. We further define a node to be <italic>start-terminal</italic>, if its in-degree is zero and <italic>end-terminal</italic> if its out-degree is zero. Each transcript can now be represented as a path through the splicing graph, beginning at a start-terminal node and ending at an end-terminal node.</p>
        <p>Note that although the splicing graph representation resolves many redundancies and efficiently stores large numbers of different but mostly overlapping transcripts, this comes at the cost of information loss. Long range dependencies between single exons are not preserved. An example of this is provided in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplemental Figure S2</ext-link>. Although exon T2E1/T3E1 exclusively occurs in transcripts that end in exon T2E3/T3E3, this relationship is lost in the graph, where E2 can connect to both E6 and E7. Our approach is not severely affected by this limitation as we only extract local information about alternative exon- or intron-usage.</p>
      </sec>
      <sec>
        <title>3.1.4 Definition of Segment Graphs</title>
        <p>Following the splicing graph definition, two or more nodes in the graph may overlap. Thus, when collecting expression information for each node from a given alignment, the same genomic positions may be queried multiple times. To overcome this inefficiency, we use the concept of breaking down each node into non-overlapping exon segments, similarly used in (<xref rid="btw076-B1" ref-type="bibr">Behr <italic>et al</italic>., 2013</xref>; <xref rid="btw076-B21" ref-type="bibr">Reyes <italic>et al.</italic>, 2012</xref>).</p>
        <p>The same principle that is applied when collapsing different transcripts that share the same exons into a graph structure can also be applied to collapse exon segments that are shared by several nodes of the splicing graph. Following this idea, we divide each exon into non-overlapping segments. Analogous to an exon, a segment is uniquely identified by its genomic coordinate pair and the same order as on exons can be applied: <inline-formula id="IE21"><mml:math id="IEQ21"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mtext>start</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mtext>end</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We say an exon <italic>v<sub>i</sub></italic> is <italic>composed</italic> from segments <inline-formula id="IE22"><mml:math id="IEQ22"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> through <inline-formula id="IE23"><mml:math id="IEQ23"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, if <inline-formula id="IE24"><mml:math id="IEQ24"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>ˆ</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, with <italic>q </italic>&lt;<italic> r</italic> and where <inline-formula id="IE25"><mml:math id="IEQ25"><mml:mrow><mml:mo>·</mml:mo><mml:mo>○</mml:mo><mml:mo>·</mml:mo></mml:mrow></mml:math></inline-formula> denotes the concatenation of segment positions. Thus, the set of all segments can be defined as
<disp-formula id="E4"><mml:math id="EQ4"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∪</mml:mo><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>ˆ</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
</p>
        <p>To explicitly define the set of all segments, first we define the set <inline-formula id="IE26"><mml:math id="IEQ26"><mml:mrow><mml:msub><mml:mi>V</mml:mi><mml:mtext>S</mml:mtext></mml:msub></mml:mrow></mml:math></inline-formula> of all node-starts in <italic>V</italic> and the set <inline-formula id="IE27"><mml:math id="IEQ27"><mml:mrow><mml:msub><mml:mi>V</mml:mi><mml:mtext>T</mml:mtext></mml:msub></mml:mrow></mml:math></inline-formula> of all node ends in <italic>V</italic>. The set of all segments <italic>S</italic> can then be defined as
<disp-formula id="E5"><mml:math id="EQ5"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∪</mml:mo><mml:mrow><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mtext>start</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mtext>end</mml:mtext></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mtext>ST</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:mrow><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo></mml:mrow></mml:mstyle><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mtext>start</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mtext>end</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>∃</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo>:</mml:mo></mml:mrow></mml:math></disp-formula>
<disp-formula id="E6"><mml:math id="EQ6"><mml:mrow><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mtext>start</mml:mtext></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mtext>start</mml:mtext></mml:mrow></mml:msub><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mtext>end</mml:mtext></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mtext>end</mml:mtext></mml:mrow></mml:msub><mml:mo>}</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
</p>
        <p>where <inline-formula id="IE28"><mml:math id="IEQ28"><mml:mrow><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mtext>ST</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mtext>S</mml:mtext></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mtext>T</mml:mtext></mml:msub></mml:mrow></mml:math></inline-formula>. The computation of <italic>S</italic> from <italic>V</italic> is straightforward. Let <italic>P</italic> be a sorted array containing all genomic positions that are either start or end positions of an exon in <italic>V</italic>. We denote the <italic>i</italic>th element of the array as <inline-formula id="IE29"><mml:math id="IEQ29"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. Let <italic>L<sub>S</sub></italic> and <italic>L<sub>E</sub></italic> be two binary label-arrays with the same length as <italic>P</italic>, where <inline-formula id="IE30"><mml:math id="IEQ30"><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is 1 if <inline-formula id="IE31"><mml:math id="IEQ31"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is start of an exon in <italic>V</italic> and 0 otherwise. Correspondingly, <inline-formula id="IE32"><mml:math id="IEQ32"><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mi>E</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is 1 if <inline-formula id="IE33"><mml:math id="IEQ33"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is the end of an exon in <italic>V</italic> and 0 otherwise. Let further <italic>C<sub>S</sub></italic> and <italic>C<sub>E</sub></italic> be two arrays with the same length as <italic>P</italic>, where <inline-formula id="IE34"><mml:math id="IEQ34"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="false"><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>i</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mi>S</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE35"><mml:math id="IEQ35"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>E</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mstyle displaystyle="false"><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>i</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mi>E</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> are the cumulative starts and ends up to position <italic>i</italic>. We can then determine the set of all segments as
<disp-formula id="E7"><mml:math id="EQ7"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>⋃</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>E</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo stretchy="true">}</mml:mo></mml:mrow></mml:mrow></mml:mstyle><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
</p>
        <p>Similar to the definition of the edges for the splicing graph, we define
<disp-formula id="E8"><graphic xlink:href="btw076pg4.jpg" position="float" orientation="portrait"/></disp-formula>
to be the set of segment pairs that are connected by an intron. We then denote the pair <inline-formula id="IE36"><mml:math id="IEQ36"><mml:mrow><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to be the <italic>segment graph</italic> of a gene. For practical reasons, we store an additional matrix that relates each node in the splicing graph to the segments it is composed of. <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplemental Figure S5</ext-link> illustrates the relationship between splicing graph and segment graph.</p>
        <p>We will use the splicing graph representation to incorporate new information based on RNA-Seq evidence as well as for the extraction of alternative splicing events. We will use the segment graph representation for event quantification, as this is computationally much more efficient.</p>
      </sec>
    </sec>
    <sec>
      <title>3.2 Construction of an augmented splicing graph</title>
      <p>As a preprocessing step, the input annotation is transformed into the initial splicing graph <italic>G</italic> according to the definitions above, thereby collapsing exons shared by multiple transcripts into single nodes of the graph. In the following, we describe how <italic>G</italic> is transformed into an augmented graph <inline-formula id="IE37"><mml:math id="IEQ37"><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>ˆ</mml:mo></mml:mover></mml:math></inline-formula> using information from RNA-Seq data, thereby introducing new nodes and edges. This is an integral part of the SplAdder workflow that enables the discovery of novel splicing variation based on RNA-Seq data.</p>
      <p>The augmentation of <italic>G</italic> is a four-step algorithm:
<list list-type="simple"><list-item><p>1. build initial graph</p></list-item><list-item><p>2. add novel cassette exons</p></list-item><list-item><p>3. add novel intron retentions</p></list-item><list-item><p>4. while novel edges can be added
<list list-type="simple"><list-item><p>  4.1 insert novel intron edges</p></list-item></list></p></list-item></list></p>
      <p>When a newly added node shares one boundary with an existing node, the existing edges are inherited by the new node. Following, we will provide a detailed explanation for each step.</p>
      <p>Given an RNA-Seq sample and a gene <inline-formula id="IE38"><mml:math id="IEQ38"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mo>,</mml:mo><mml:mtext>start</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mo>,</mml:mo><mml:mtext>end</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we extract all intron junctions from the alignment that overlap <inline-formula id="IE39"><mml:math id="IEQ39"><mml:mi mathvariant="script" class="calligraphy">G</mml:mi></mml:math></inline-formula> and show sufficient alignment support. Whether an intron junction is sufficiently well supported is based on a set of given confidence criteria (cf. <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplemental Table C</ext-link>) We define the list of RNA-Seq intron junctions <inline-formula id="IE40"><mml:math id="IEQ40"><mml:mi mathvariant="script" class="calligraphy">R</mml:mi></mml:math></inline-formula> as
<disp-formula id="E11"><mml:math id="EQ11"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">R</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mo>,</mml:mo><mml:mtext>start</mml:mtext></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mo>,</mml:mo><mml:mtext>end</mml:mtext></mml:mrow></mml:msub><mml:mo>}</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
</p>
      <p>where (<italic>g<sub>i</sub></italic>, <italic>g<sub>j</sub></italic>) describes the intron starting at <italic>g<sub>i</sub></italic> and ending at <italic>g<sub>j</sub></italic>. Further, let <inline-formula id="IE41"><mml:math id="IEQ41"><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mtext>start</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mtext>end</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, with <inline-formula id="IE42"><mml:math id="IEQ42"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>, be an existing node in the splicing graph. The augmentation process will transform the existing splicing graph <inline-formula id="IE43"><mml:math id="IEQ43"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> into an augmented graph <inline-formula id="IE44"><mml:math id="IEQ44"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>ˆ</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mi>V</mml:mi><mml:mo>ˆ</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>E</mml:mi><mml:mo>ˆ</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We initialize <inline-formula id="IE45"><mml:math id="IEQ45"><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>ˆ</mml:mo></mml:mover></mml:math></inline-formula> with <italic>G</italic>.</p>
      <sec>
        <title>3.2.1 Adding novel cassette exons</title>
        <p>In the first augmentation step, new cassette exon structures are added to the splicing graph. For this, the algorithm iterates over all non-overlapping pairs of <inline-formula id="IE46"><mml:math id="IEQ46"><mml:mi mathvariant="script" class="calligraphy">R</mml:mi></mml:math></inline-formula>. For each pair <inline-formula id="IE47"><mml:math id="IEQ47"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE48"><mml:math id="IEQ48"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, two conditions need to be fulfilled. Briefly, both intron ends need to be attached to existing exons and the cassette exon must not already exist. Formally, we check for the following conditions:
<disp-formula id="E12"><mml:math id="EQ12"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Intron</mml:mi></mml:mstyle><mml:mtext> </mml:mtext><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>ends</mml:mi></mml:mstyle><mml:mtext> </mml:mtext><mml:mo>∃</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mover accent="true"><mml:mi>V</mml:mi><mml:mo>ˆ</mml:mo></mml:mover><mml:mo>:</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mtext>end</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>and  </mml:mtext><mml:mo>∃</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mover accent="true"><mml:mi>V</mml:mi><mml:mo>ˆ</mml:mo></mml:mover><mml:mo>:</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mtext>start</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mtext> and </mml:mtext><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
<disp-formula id="E13"><mml:math id="EQ13"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>New</mml:mi></mml:mstyle><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>exon</mml:mi></mml:mstyle></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:menclose notation="updiagonalstrike"><mml:mo>∄</mml:mo></mml:menclose><mml:msub><mml:mi>v</mml:mi><mml:mi>h</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mover accent="true"><mml:mi>V</mml:mi><mml:mo>ˆ</mml:mo></mml:mover><mml:mo>:</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>h</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mtext>start</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mtext> and  </mml:mtext><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>h</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mtext>end</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula>
</p>
        <p>If both conditions are met, a new node <inline-formula id="IE49"><mml:math id="IEQ49"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is added to the node set <inline-formula id="IE50"><mml:math id="IEQ50"><mml:mover accent="true"><mml:mi>V</mml:mi><mml:mo>ˆ</mml:mo></mml:mover></mml:math></inline-formula> and two new edges (<italic>v<sub>i</sub></italic>, <italic>v<sub>n</sub></italic>) and (<italic>v<sub>n</sub></italic>, <italic>v<sub>j</sub></italic>) are added to <inline-formula id="IE51"><mml:math id="IEQ51"><mml:mover accent="true"><mml:mi>E</mml:mi><mml:mo>ˆ</mml:mo></mml:mover></mml:math></inline-formula>. <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplementary Figure S1</ext-link>, Panel A, schematically describes the addition of a cassette exon. The criteria for adding a cassette exon are listed in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplemental Table A</ext-link>.</p>
      </sec>
      <sec>
        <title>3.2.2 Adding Novel Intron Retentions</title>
        <p>The second augmentation step adds intron retention events to the splicing graph. For each edge <inline-formula id="IE52"><mml:math id="IEQ52"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mover accent="true"><mml:mi>E</mml:mi><mml:mo>ˆ</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, the algorithm decides whether there is enough evidence from the given RNA-Seq sample for expression inside the intron, to consider the intron sequence as retained. Again, heuristic confidence criteria are applied (cf. <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplemental Table B</ext-link>). Briefly, the central criteria for adding a new intron retention is the number of sufficiently covered positions within the intron as well as the differences in mean coverage between intronic and exonic part of that region. When sufficient evidence for a retention is found, a new node <inline-formula id="IE53"><mml:math id="IEQ53"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mtext>start</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mtext>end</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is added to <inline-formula id="IE54"><mml:math id="IEQ54"><mml:mover accent="true"><mml:mi>V</mml:mi><mml:mo>ˆ</mml:mo></mml:mover></mml:math></inline-formula>. The new node inherits all incoming edges from <italic>v<sub>s</sub></italic> and all outgoing edges from <italic>v<sub>t</sub></italic>, thus we get the set of newly added edges
<disp-formula id="E14"><mml:math id="EQ14"><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>∀</mml:mo><mml:mi>x</mml:mi><mml:mo>:</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mover accent="true"><mml:mi>E</mml:mi><mml:mo>ˆ</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="true">}</mml:mo></mml:mrow><mml:mo>∪</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>∀</mml:mo><mml:mi>x</mml:mi><mml:mo>:</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mover accent="true"><mml:mi>E</mml:mi><mml:mo>ˆ</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="true">}</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
</p>
        <p>Then, the set of edges is updated with <inline-formula id="IE55"><mml:math id="IEQ55"><mml:mrow><mml:mover accent="true"><mml:mi>E</mml:mi><mml:mo>ˆ</mml:mo></mml:mover><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>E</mml:mi><mml:mo>ˆ</mml:mo></mml:mover><mml:mo>∪</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplemental Figure S1</ext-link>, Panel B, illustrates this case.</p>
      </sec>
      <sec>
        <title>3.2.3 Insert Novel Intron Edges</title>
        <p>The last augmentation makes once more use of the list of RNA-Seq supported intron junctions <inline-formula id="IE56"><mml:math id="IEQ56"><mml:mi mathvariant="script" class="calligraphy">R</mml:mi></mml:math></inline-formula> generated during the first step. Based on start and end position of the intron, we can test if any existing nodes start or end at these positions, respectively. We have to distinguish between four different basic cases: (i) neither start nor end coincide with any existing node boundary, (ii) the intron-start coincides with an existing node end, (iii) the intron end coincides with an existing node-start, (iv) both the intron-start coincides with an existing node end and the intron-end coincides with an existing node-start. The four cases and their respective sub-cases are illustrated in Panels C–H of <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplemental Figure S1</ext-link>. Formal definitions of the different cases are given in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplemental Section A</ext-link>. As the addition of novel intron edges depends on other possibly novel edges, this addition step is repeated iteratively until no new edges can be added or a pre-defined maximum number of iterations is reached.</p>
      </sec>
      <sec>
        <title>3.2.4 Splicing Graph Pruning</title>
        <p>When multiple RNA-Seq samples are available, SplAdder allows for an optional filtering step to reduce false positive edges. All edges that are not supported by a given minimum number of RNA-Seq samples will be pruned from the graph. Resulting orphan nodes that were not present in the initial graph will be pruned as well.</p>
      </sec>
    </sec>
    <sec>
      <title>3.3 Detect and quantify alternative splicing events</title>
      <p>Based on the augmented splicing graph, we extract various classes of AS events as subsets of connected nodes. SplAdder currently supports the following event types: exon skip, intron retention, alternative 3′ and alternative 5′ splice sites, multiple exon skips as well as mutually exclusive exons. Note, that currently alternative transcript starts and ends are not detected, as they are products of alternative transcriptional processing rather then results of alternative splicing. Each event is then represented as a ‘mini-gene’ consisting of two splice variants minimally describing the alternatives of the event. Overlapping events that share the same intron coordinates and do only differ in the flanking exon ends are merged into a short common representation. We refer to <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplemental Section B.1</ext-link> for the formal definitions of all classes of alternative events and a detailed description of the extraction algorithms.</p>
      <p>Finally, the event set identified from the splicing graph is quantified using the given read alignment data. For each event, we report the mean coverage of each exon and the number of spliced alignments supporting each intron. Remember, that to speed up the quantification process, the read counting is performed on the segment graph representation defined above. Thus, no exon position needs to be quantified twice.</p>
    </sec>
    <sec>
      <title>3.4 Differential analysis</title>
      <p>If the set of input samples can be separated into two or more groups representing different conditions, the splice quantifications produced by SplAdder can be subjected to differential testing. For this, SplAdder provides two basic strategies. The first is to use the SplAdder output files that describe event structure and quantification as input to other tools dedicated to analyze differential expression, such as rDiff (<xref rid="btw076-B5" ref-type="bibr">Drewe <italic>et al.</italic>, 2013</xref>) or DESeq (<xref rid="btw076-B21" ref-type="bibr">Reyes <italic>et al.</italic>, 2012</xref>). In previous studies, we have generally used the combination of SplAdder and rDiff. In this case, the mini genes predicted by SplAdder are re-quantified by rDiff and subjected to a test for differential relative transcript usage.</p>
      <p>The second strategy is to directly use the exon-intron junction counts generated by SplAdder to apply a differential test. Briefly, we model junction read counts with a negative binomial distribution and employ a generalized linear model (GLM) framework for testing similar to (<xref rid="btw076-B18" ref-type="bibr">Love <italic>et al.</italic>, 2014</xref>). Similar to the previous approach, we use the sample replicate to estimate a mean variance relationship to better account for overdispersion. Details of the GLM based test are provided in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplemental Section C</ext-link>. This strategy can be run as part of the SplAdder pipeline. It directly accesses the event quantifications and is computationally more efficient than the previous hybrid approach. We have included both strategies into our evaluation presented in Section 4.</p>
    </sec>
    <sec>
      <title>3.5 Visualization</title>
      <p>SplAdder also provides means for publication-ready visualization of the RNA-seq read coverage of exon positions and of intron junctions. Visualization allows for effective visual inspection of identified alternative splicing events in light of primary read data. These visualizations provide summarization of multiple samples as well as the comparison of different groups of samples to highlight differential splicing over several replicate groups or conditions. An example is provided in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplemental Figure S8</ext-link>.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Evaluation and applications</title>
    <p>The SplAdder approach has been successfully applied in various biological studies on <italic>Arabidopsis thaliana</italic> (<xref rid="btw076-B4" ref-type="bibr">Drechsel <italic>et al.</italic>, 2013</xref>; <xref rid="btw076-B8" ref-type="bibr">Gan <italic>et al.</italic>, 2011</xref>) as well as in the context of large-scale cancer projects with several thousand RNA-seq libraries (<xref rid="btw076-B26" ref-type="bibr">Weinstein <italic>et al.</italic>, 2013</xref>). Here, we have created several sets of simulated data to evaluate SplAdder. Simulated data allows for an accurate measure of performance and provides a ground truth for a fair comparison against other existing methods. To allow as little bias as possible towards our own method, we used an external data simulator (<xref rid="btw076-B9" ref-type="bibr">Griebel <italic>et al.</italic>, 2012</xref>). In the following, we describe the generated datasets and which evaluations were performed on them.</p>
    <sec>
      <title>4.1 Data simulation</title>
      <sec>
        <title>4.1.1 Detection of novel events</title>
        <p>We have used the FluxSimulator (<xref rid="btw076-B9" ref-type="bibr">Griebel <italic>et al.</italic>, 2012</xref>) toolbox to simulate RNA-Seq datasets of sizes 5 million, 10 million and 20 million reads, covering 1000 genes randomly selected from the human GENCODE annotation (v19) (<xref rid="btw076-B12" ref-type="bibr">Harrow <italic>et al.</italic>, 2012</xref>) at various depths. For this analysis, we put our main focus on the sensitive detection of novel alternative splicing events. Thus, we pre-filtered the annotation to genes that had at least two transcripts annotated.</p>
        <p>All reads were aligned to the human reference genome using the STAR (<xref rid="btw076-B3" ref-type="bibr">Dobin <italic>et al.</italic>, 2013</xref>) as well as the TopHat2 (<xref rid="btw076-B16" ref-type="bibr">Kim <italic>et al.</italic>, 2013</xref>) aligners to show the applicability of our pipeline in a general context. In both cases, we provided the full reference annotation for index creation. TopHat2 implements a 2-pass alignment mode per default. As this mode is optional for STAR, we ran it with and without 2-pass mode to also get a better understanding of its benefits. In addition to the alignment output, we also transformed the simulated read alignments into BAM format and used it as optimal input for the splice prediction tools, best reflecting ground truth information.</p>
        <p>To simulate a realistic scenario of detecting novel AS events based on the provided RNA-Seq alignments only, we provided only a reduced annotation to the tools performing the AS event prediction. This reduced representation contains only the first annotated transcript of a gene, where first is defined as first occurrence in the complete annotation file.</p>
        <p>For further details on dataset creation and alignment, including all command line parameter settings, we refer to <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplemental Section D</ext-link>.</p>
      </sec>
      <sec>
        <title>4.1.2 Differential analysis</title>
        <p>The simulated data for the analysis of differential testing was taken from the publication of rDiff (<xref rid="btw076-B5" ref-type="bibr">Drewe <italic>et al.</italic>, 2013</xref>), a tool for the detection of differentially expressed transcripts from RNA-Seq data. The two datasets consist of 5785 genes each, where one half of the genes shows differential relative transcript expression and the other half does not. The rDiff publication gives further details on dataset generation.</p>
      </sec>
    </sec>
    <sec>
      <title>4.2 Evaluation</title>
      <sec>
        <title>4.2.1 Detection of novel events</title>
        <p>We used the Astalavista toolbox (<xref rid="btw076-B7" ref-type="bibr">Foissac and Sammeth, 2007</xref>) to extract all annotated alternative splicing events from the set of the randomly chosen 1000 genes that we used for data simulation. In contrast to the individual prediction tasks, Astalavista had access to all annotated transcripts of a gene and thus generated our ground truth set used for evaluation later on. Astalavista generates output following a well-defined nomenclature (<xref rid="btw076-B10" ref-type="bibr">Guigó Serra <italic>et al.</italic>, 2008</xref>).</p>
        <p>The single AS event predictors were run on the limited annotation containing only the first transcript but had access to the RNA-Seq data generated from the non-constrained annotation set. We then converted the output of all other tools into the well-defined Astalavista format to allow for an easy comparison. For each of the four AS event types (exon skip, intron retention, alternative 3′ splice site and alternative 5′ splice site), we compared the predictions to the ground truth set and computed precision, recall and <italic>F</italic>-score metrics.</p>
        <p>For this evaluation we considered JuncBase, rMATS, SpliceGrapher and SplAdder.</p>
      </sec>
      <sec>
        <title>4.2.2 Event quantification</title>
        <p>Based on the read data simulated for the detection of novel events, we were also able to evaluate the event quantifications provided by the respective approaches. We based all our analyses on percent spliced in (PSI) values, as they are an accepted standard in the community. To generate the ground truth PSI values, we took the relative expression of a transcript for each gene as simulated by FluxSimulator. For each alternative splicing event, we computed its PSI value as the ratio between the sum of abundances of transcripts that represented the inclusion (e.g. not skipping the exon in an exon skip event) over the sum of abundances of all transcripts containing any of the event exons.</p>
        <p>The so generated PSI values were then used as ground truth for comparison of the predicted event quantifications. Only the correctly detected events of each approach could be compared to the ground truth quantifications. We used the Pearson correlation coefficient as a measure of agreement between predicted and true PSI values.</p>
        <p>This evaluation was performed for JuncBase, rMATs and SplAdder, as SpliceGrapher does not provide quantification values.</p>
      </sec>
      <sec>
        <title>4.2.3 Differential analysis</title>
        <p>The two test sets taken from (<xref rid="btw076-B5" ref-type="bibr">Drewe <italic>et al.</italic>, 2013</xref>) contain 5785 genes each that either do (2937) or do not (2938) show differential transcript usage. One dataset shows small variability and the other large variability, which we will further refer to as the <italic>small</italic> and <italic>large</italic> dataset, respectively. For each dataset, we used the set of differential genes as ground truth and counted a prediction as a true positive if the tool found at least one significant AS event in that gene. From this we generated receiver operating characteristic (ROC) curves with increasing significance cut-offs to evaluate each tool’s performance.</p>
        <p>For this analysis we compared only rMATS, JuncBase and SplAdder, as SpliceGrapher does not provide differential testing functionality.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>5 Results</title>
    <sec>
      <title>5.1 Detection of novel events</title>
      <p>Based on the three sets of simulated reads and the different alignments performed on these read sets, we evaluated how well the single prediction tools can reconstruct the splicing variability in the sample from read alignments and limited annotation. In comparison to the ground truth dataset generated by using Astalavista on the non-restricted annotation file, we computed precision, recall and F-Score metrics for four types of AS events (<xref ref-type="fig" rid="btw076-F2">Figs 2</xref>, S6 and S7).
<fig id="btw076-F2" orientation="portrait" position="float"><label>Fig. 2.</label><caption><p>SplAdder evaluation results. This matrix of bar charts summarizes the evaluation results for the comparison of rMATS, SpliceGrapher, JuncBase and SplAdder (see legend) on different sets of simulated RNA-Seq read data. The metric shown here is the <italic>F</italic>-Score, defined as the harmonic mean of precision and recall. (Plots of the same design with details on precision and recall are provided in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplemental Figs S6 and S7</ext-link>.) The rows of the plot matrix represent four different event types: (<bold>a</bold>) exon skip, (<bold>b</bold>) intron retention, (<bold>c</bold>) alternative 3′ splice site and (<bold>d</bold>) alternative 5′ splice site. The columns represent different read set sizes (5 million, 10 million, 20 million). The four bar groups represent the different aligners used (from left to right: STAR 1-pass, STAR 2-pass, TopHat2 and the simulated ground truth alignment) (Color version of this figure is available at Bioinformatics online.)</p></caption><graphic xlink:href="btw076f2p"/></fig>
</p>
      <p>In general we find varying accuracies across the different event types, with consistent patterns for all the tested tools. Intron retentions are the most difficult to predict and exon skips the easiest. rMATS was able to detect only two kinds of events on the data we provided: exon skips and mutual exclusive exons. Only exon skips were part of our evaluation. All event types that were not predicted are shown as bars of height zero. We also would like to note, that the simulated data resembles a polyA selected library. When working with non-polyA selected, rRNA depleted libraries, performance will likely be worse, as incompletely spliced transcripts will be amongst the sequenced fragments, diluting the signal.</p>
      <p>Across all event types, sample sizes and alignment methods SplAdder shows the best performance compared to the other tools. Although rMATS shows the highest precision on the predicted exon skip events (0.965, cf. <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplemental Fig. S6</ext-link>), it has a considerably lower recall, thus affecting its overall performance. Further, it does not predict any of the other assessed types. In contrast JuncBase shows a generally high recall but predicts many false positive events, resulting in a low precision (cf. <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplemental Figs S6 and S7</ext-link>).</p>
      <p>A high read coverage has, in general, a positive effect on prediction accuracy with better results for the samples covered at a higher depth. However, we observed some instances where high coverage results in lower performance, most likely due to more false positives in the predicted set.</p>
    </sec>
    <sec>
      <title>5.2 Event quantification</title>
      <p>For all events that were correctly predicted by each approach, we compared the associated PSI value to the ground truth computed on the simulated abundances.</p>
      <p>In general, we observe good correlation between predicted and true PSI values (cf. <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplemental Table F</ext-link> for a list of all coefficients). Whereas SplAdder shows the highest correlation for exon skip events, JuncBase has slightly higher accuracy for the other event types, although closely followed by the SplAdder predictions. As rMATS only predicted exon skip events, we could only include this one event type into our comparison.</p>
      <p>We did not observe large differences between correlation values for the different aligners. Interestingly, a higher read depth led to slightly lower quantification accuracies for all tools, even when using the unaligned ground truth read data. We speculate that this is an effect of the simulation tool. However, since we use the reads only for a relative comparison of the different approaches, our evaluation should not suffer from this.</p>
    </sec>
    <sec>
      <title>5.3 Differential analysis</title>
      <p>SplAdder can be utilized in two different ways to compare alternative splicing between samples. One approach is to use the event mini-genes output by SplAdder as input to other tools for the analysis of differential transcript usage. For our experiments, we use rDiff and refer to this use case as SplAdder + rDiff. In addition, we recently added a testing module to the SplAdder core pipeline that uses a Generalized Linear Model (GLM), which we will refer to as SplAdder + GLM in the following evaluations. Based on the two artificial datasets described above, we find that SplAdder shows very good performance overall when compared to other testing approaches (<xref ref-type="fig" rid="btw076-F3">Fig. 3</xref>).
<fig id="btw076-F3" orientation="portrait" position="float"><label>Fig. 3.</label><caption><p>Differential testing evaluation. Testing accuracy for four different methods (SplAdder + GLM, SplAdder + rDiff, rMATS and JuncBase; see legend). Each plot represents a different test set. The plot shown on the left represents the sample dataset with large biological variance between replicates, whereas the plot on the right is based on the sample set with small biological variance between replicates. The dashed line represents the diagonal and reflects the performance of a random assignment of classes (Color version of this figure is available at <italic>Bioinformatics</italic> online.)</p></caption><graphic xlink:href="btw076f3p"/></fig>
</p>
      <p>In the range of a low false positive rate, the performance of SplAdder + rDiff is comparable to rMATS and slightly inferior to SplAdder + GLM. This is consistent for both the small and large variance dataset. JuncBase uses a <italic>t</italic>-test for assessing the different groups of samples, which appears less well suited for testing read count data, as it leads to relatively many false positives at high confidence. The ROC curve shape directly reflects this.</p>
    </sec>
    <sec>
      <title>5.4 Software and usability</title>
      <p>We have taken great care when implementing the SplAdder approach. It has been developed in Matlab but was translated into Python to improve accessibility. Both implementations provide the same functionality, however we will continue future development in Python only. When it comes to usability, SplAdder is a convenient one-stop-shop that provides all analysis within a single pipeline. With one simple command line call specifying the parameter set, all subsequent steps are automatized. In addition, the pipeline can be broken into single steps if necessary.</p>
      <p>All other tested approaches required invocation of multiple separate tool components and required custom scripting on the user side to form a coherent pipeline. A single exception is rMATS that is also well engineered and is quite usable. Most of this also reflects in the running times of the implementations (cf. <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw076/-/DC1">Supplemental Table E</ext-link>). Whereas rMATS and SplAdder have quite low running times, JuncBase and SpliceGrapher are considerably slower. Especially the Cufflinks preprocessing for JuncBase is very compute intense, with up to 30 h for some evaluation samples of the largest size. Thus, we have excluded this preprocessing time from the running time table for JuncBase.</p>
      <p>We believe that SplAdder’s improved usability is an important feature that will enable comprehensive AS analysis on RNA-Seq data for a wider audience than with previous methods. Our method is particularly timely, given the ubiquitous presence of available RNA-seq data, high interest in quantifying splicing phenotypes, and scalability to process thousands of samples.</p>
    </sec>
  </sec>
  <sec>
    <title>6 Conclusion</title>
    <p>We present SplAdder, a novel approach for the large-scale analysis of alternative splicing events based on RNA-Seq data. We also provide a thoroughly engineered software implementation that is straightforward to use and can be easily deployed in a high performance computing framework. SplAdder has been successfully applied to splicing analysis in various organisms, compares favorably to various other state of the art methods showing an overall high accuracy and can be readily applied to datasets of thousands of samples. We are working to further improve SplAdder to natively work with high performance compute clusters and generate more interactive visualizations.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="PMC_1" content-type="local-data">
      <caption>
        <title>Supplementary Data</title>
      </caption>
      <media mimetype="text" mime-subtype="html" xlink:href="supp_32_12_1840__index.html"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="pdf" xlink:href="supp_btw076_supplement_submitted.pdf"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgements</title>
    <p>The authors are grateful to Vipin T Sreedharan for providing code to convert annotation files, to Andreas Wachter for valuable discussions and feedback on the software and to David Kuo for proofreading.</p>
  </ack>
  <sec>
    <title>Funding</title>
    <p>Funding was provided by the <funding-source>Max Planck Society, Memorial Sloan Kettering Cancer Center, by the German Research Foundation</funding-source> (<award-id>RA1894/2-1</award-id>) and the <funding-source>Lucille Castori Center for Microbes, Inflammation, and Cancer</funding-source> (No. <award-id>223316</award-id>).</p>
    <p><italic>Conflict of Interest:</italic> none declared.</p>
  </sec>
  <ref-list>
    <title>References</title>
    <ref id="btw076-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Behr</surname><given-names>J.</given-names></name></person-group><etal/> (<year>2013</year>) <article-title>MITIE: Simultaneous RNA-Seq-based transcript identification and quantification in multiple samples</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>2529</fpage>–<lpage>2538</lpage>.<pub-id pub-id-type="pmid">23980025</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Brooks</surname><given-names>A.N.</given-names></name></person-group><etal/> (<year>2011</year>) <article-title>Conservation of an RNA regulatory map between Drosophila and mammals</article-title>. <source>Genome Res</source>., <volume>21</volume>, <fpage>193</fpage>–<lpage>202</lpage>.<pub-id pub-id-type="pmid">20921232</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Dobin</surname><given-names>A.</given-names></name></person-group><etal/> (<year>2013</year>) <article-title>STAR: ultrafast universal RNA-seq aligner</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>15</fpage>–<lpage>21</lpage>.<pub-id pub-id-type="pmid">23104886</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Drechsel</surname><given-names>G.</given-names></name></person-group><etal/> (<year>2013</year>) <article-title>Nonsense-mediated decay of alternative precursor mRNA splicing variants is a major determinant of the arabidopsis steady state transcriptome</article-title>. <source>Plant Cell</source>, <volume>25</volume>, <fpage>3726</fpage>–<lpage>3742</lpage>.<pub-id pub-id-type="pmid">24163313</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Drewe</surname><given-names>P.</given-names></name></person-group><etal/> (<year>2013</year>) <article-title>Accurate detection of differential RNA processing</article-title>. <source>Nucleic Acids Res</source>., <volume>41</volume>, <fpage>5189</fpage>–<lpage>5198</lpage>.<pub-id pub-id-type="pmid">23585274</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Eichner</surname><given-names>J.</given-names></name></person-group><etal/> (<year>2011</year>) <article-title>Support vector machines-based identification of alternative splicing in Arabidopsis thaliana from whole-genome tiling arrays</article-title>. <source>BMC Bioinf</source>., <volume>12</volume>, <fpage>55</fpage></mixed-citation>
    </ref>
    <ref id="btw076-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Foissac</surname><given-names>S.</given-names></name><name><surname>Sammeth</surname><given-names>M.</given-names></name></person-group> (<year>2007</year>) <article-title>Astalavista: dynamic and flexible analysis of alternative splicing events in custom gene datasets</article-title>. <source>Nucleic Acids Res</source>., <volume>35</volume>, <fpage>W297</fpage>–<lpage>W299</lpage>.<pub-id pub-id-type="pmid">17485470</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gan</surname><given-names>X.</given-names></name></person-group><etal/> (<year>2011</year>) <article-title>Multiple reference genomes and transcriptomes for <italic>Arabidopsis thaliana</italic></article-title>. <source>Nature</source>, <volume>108</volume>, <fpage>10249</fpage>–<lpage>10254</lpage>.</mixed-citation>
    </ref>
    <ref id="btw076-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Griebel</surname><given-names>T.</given-names></name></person-group><etal/> (<year>2012</year>) <article-title>Modelling and simulating generic RNA-Seq experiments with the flux simulator</article-title>. <source>Nucleic Acids Res</source>., <volume>40</volume>, <fpage>10073</fpage>–<lpage>10083</lpage>.<pub-id pub-id-type="pmid">22962361</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Guigó Serra</surname><given-names>R.</given-names></name></person-group><etal/> (<year>2008</year>) <article-title>A general definition and nomenclature for alternative splicing events</article-title>. <source>PLoS Comput. Biol</source>., <volume>4</volume>, <fpage>e1000147</fpage>.<pub-id pub-id-type="pmid">18688268</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Guttman</surname><given-names>M.</given-names></name></person-group><etal/> (<year>2010</year>) <article-title>Ab initio reconstruction of cell type-specific transcriptomes in mouse reveals the conserved multi-exonic structure of lincRNAs</article-title>. <source>Nat. Biotechnol</source>., <volume>28</volume>, <fpage>503</fpage>–<lpage>510</lpage>.<pub-id pub-id-type="pmid">20436462</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Harrow</surname><given-names>J.</given-names></name></person-group><etal/> (<year>2012</year>) <article-title>GENCODE: The reference human genome annotation for The ENCODE Project</article-title>. <source>Genome Res</source>., <volume>22</volume>, <fpage>1760</fpage>–<lpage>1774</lpage>.<pub-id pub-id-type="pmid">22955987</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Heber</surname><given-names>S.</given-names></name></person-group><etal/> (<year>2002</year>) <article-title>Splicing graphs and est assembly problem</article-title>. <source>Bioinformatics</source>, <volume>18</volume>, <fpage>181</fpage>–<lpage>188</lpage>.</mixed-citation>
    </ref>
    <ref id="btw076-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Katz</surname><given-names>Y.</given-names></name></person-group><etal/> (<year>2010</year>) <article-title>Analysis and design of RNA sequencing experiments for identifying isoform regulation</article-title>. <source>Nat. Methods</source>, <volume>7</volume>, <fpage>1009</fpage>–<lpage>1015</lpage>.<pub-id pub-id-type="pmid">21057496</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kianianmomeni</surname><given-names>A.</given-names></name></person-group><etal/> (<year>2014</year>) <article-title>Genome-wide analysis of alternative splicing in volvox carteri</article-title>. <source>BMC Genomics</source>, <volume>15</volume>, <fpage>1117</fpage>.<pub-id pub-id-type="pmid">25516378</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kim</surname><given-names>D.</given-names></name></person-group><etal/> (<year>2013</year>) <article-title>TopHat2: accurate alignment of transcriptomes in the presence of insertions, deletions and gene fusions</article-title>. <source>Genome Biol</source>., <volume>14</volume>, <fpage>R36</fpage>.<pub-id pub-id-type="pmid">23618408</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kornblihtt</surname><given-names>A.R.</given-names></name></person-group><etal/> (<year>2013</year>) <article-title>Alternative splicing: a pivotal step between eukaryotic transcription and translation</article-title>. <source>Nat. Rev. Mol. Cell Biol</source>., <volume>14</volume>, <fpage>153</fpage>–<lpage>165</lpage>.<pub-id pub-id-type="pmid">23385723</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Love</surname><given-names>M.I.</given-names></name></person-group><etal/> (<year>2014</year>) <article-title>Moderated estimation of fold change and dispersion for RNA-seq data with deseq2</article-title>. <source>Genome Biol</source>., <volume>15</volume>, <fpage>550</fpage>.<pub-id pub-id-type="pmid">25516281</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Modrek</surname><given-names>B.</given-names></name><name><surname>Lee</surname><given-names>C.</given-names></name></person-group> (<year>2002</year>) <article-title>A genomic view of alternative splicing</article-title>. <source>Nat. Genet</source>., <volume>30</volume>, <fpage>13</fpage>–<lpage>19</lpage>.<pub-id pub-id-type="pmid">11753382</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pan</surname><given-names>Q.</given-names></name></person-group><etal/> (<year>2008</year>) <article-title>Deep surveying of alternative splicing complexity in the human transcriptome by high-throughput sequencing</article-title>. <source>Nat. Genet</source>., <volume>40</volume>, <fpage>1413</fpage>–<lpage>1415</lpage>.<pub-id pub-id-type="pmid">18978789</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Reyes</surname><given-names>A.</given-names></name></person-group><etal/> (<year>2012</year>) <article-title>Detecting differential usage of exons from RNA-Seq data</article-title>. <source>Genome Res</source>., <volume>22</volume>, <fpage>2008</fpage>–<lpage>2017</lpage>.<pub-id pub-id-type="pmid">22722343</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rogers</surname><given-names>M.F.</given-names></name></person-group><etal/> (<year>2012</year>) <article-title>SpliceGrapher: detecting patterns of alternative splicing from RNA-Seq data in the context of gene models and EST data</article-title>. <source>Genome Biol</source>., <volume>13</volume>, <fpage>R4</fpage><pub-id pub-id-type="pmid">22293517</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Shen</surname><given-names>S.</given-names></name></person-group><etal/> (<year>2014</year>) <article-title>rmats: Robust and flexible detection of differential alternative splicing from replicate rna-seq data</article-title>. <source>Proc. Natl. Acad. Sci. U. S. A</source>., <volume>111</volume>, <fpage>E5593</fpage>–<lpage>E5601</lpage>.<pub-id pub-id-type="pmid">25480548</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Trapnell</surname><given-names>C.</given-names></name></person-group><etal/> (<year>2010</year>) <article-title>Transcript assembly and quantification by RNA-Seq reveals unannotated transcripts and isoform switching during cell differentiation</article-title>. <source>Nat. Biotechnol</source>., <volume>28</volume>, <fpage>511</fpage>–<lpage>515</lpage>.<pub-id pub-id-type="pmid">20436464</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wang</surname><given-names>E.T.</given-names></name></person-group><etal/> (<year>2008</year>) <article-title>Alternative isoform regulation in human tissue transcriptomes</article-title>. <source>Nature</source>, <volume>456</volume>, <fpage>470</fpage>–<lpage>476</lpage>.<pub-id pub-id-type="pmid">18978772</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Weinstein</surname><given-names>J.N.</given-names></name></person-group><etal/> (<year>2013</year>) <article-title>The Cancer Genome Atlas Pan-Cancer analysis project</article-title>. <source>Nat. Genet</source>., <volume>45</volume>, <fpage>1113</fpage>–<lpage>1120</lpage>.<pub-id pub-id-type="pmid">24071849</pub-id></mixed-citation>
    </ref>
    <ref id="btw076-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wu</surname><given-names>J.</given-names></name></person-group><etal/> (<year>2011</year>) <article-title>Splicetrap: a method to quantify alternative splicing under single cellular conditions</article-title>. <source>Bioinformatics</source>, <volume>27</volume>, <fpage>3010</fpage>–<lpage>3016</lpage>.<pub-id pub-id-type="pmid">21896509</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
