<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-title>BMC Bioinformatics</journal-title>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">2648751</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-10-S1-S16</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-10-S1-S16</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Crystallizing short-read assemblies around seeds</article-title>
    </title-group>
    <contrib-group>
      <contrib id="A1" contrib-type="author">
        <name>
          <surname>Hossain</surname>
          <given-names>Mohammad Sajjad</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>sajjad@cs.sunysb.edu</email>
      </contrib>
      <contrib id="A2" contrib-type="author">
        <name>
          <surname>Azimi</surname>
          <given-names>Navid</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>navid@cs.sunysb.edu</email>
      </contrib>
      <contrib id="A3" corresp="yes" contrib-type="author">
        <name>
          <surname>Skiena</surname>
          <given-names>Steven</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>skiena@cs.sunysb.edu</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Department of Computer Science, Stony Brook University, Stony Brook, NY 11794-4400 USA</aff>
    <pub-date pub-type="collection">
      <year>2009</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>30</day>
      <month>1</month>
      <year>2009</year>
    </pub-date>
    <volume>10</volume>
    <issue>Suppl 1</issue>
    <supplement>
      <named-content content-type="supplement-title">Selected papers from the Seventh Asia-Pacific Bioinformatics Conference (APBC 2009)</named-content>
      <named-content content-type="supplement-editor">Michael Q Zhang, Michael S Waterman and Xuegong Zhang</named-content>
    </supplement>
    <fpage>S16</fpage>
    <lpage>S16</lpage>
    <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10/S1/S16"/>
    <permissions>
      <copyright-statement>Copyright © 2009 Hossain et al; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2009</copyright-year>
      <copyright-holder>Hossain et al; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p>
        <!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>
               Hossain
               Sajjad
               Mohammad
               
               sajjad@cs.sunysb.edu
            </dc:author><dc:title>
            Crystallizing short-read assemblies around seeds
         </dc:title><dc:date>2009</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 10(Suppl 1): S16-. (2009)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2009)10:Suppl 1&#x0003c;S16&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>-->
      </license>
    </permissions>
    <abstract>
      <sec>
        <title>Background</title>
        <p>New short-read sequencing technologies produce enormous volumes of 25–30 base paired-end reads. The resulting reads have vastly different characteristics than produced by Sanger sequencing, and require different approaches than the previous generation of sequence assemblers. In this paper, we present a short-read de novo assembler particularly targeted at the new ABI SOLiD sequencing technology.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>This paper presents what we believe to be the first de novo sequence assembly results on <italic>real </italic>data from the emerging SOLiD platform, introduced by <italic>Applied Biosystems</italic>. Our assembler SHORTY augments short-paired reads using a trivially small number (5 – 10) of <italic>seeds </italic>of length 300 – 500 bp. These seeds enable us to produce significant assemblies using short-read coverage no more than 100×, which can be obtained in a single run of these high-capacity sequencers. SHORTY exploits two ideas which we believe to be of interest to the short-read assembly community: (1) using single seed reads to crystallize assemblies, and (2) estimating intercontig distances accurately from multiple spanning paired-end reads.</p>
      </sec>
      <sec>
        <title>Conclusion</title>
        <p>We demonstrate effective assemblies (N50 contig sizes ~40 kb) of three different bacterial species using simulated SOLiD data. Sequencing artifacts limit our performance on real data, however our results on this data are substantially better than those achieved by competing assemblers.</p>
      </sec>
    </abstract>
    <conference>
      <conf-date>13–16 January 2009</conf-date>
      <conf-name>The Seventh Asia Pacific Bioinformatics Conference (APBC 2009)</conf-name>
      <conf-loc>Beijing, China</conf-loc>
    </conference>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>Several new short-read sequencing technologies are now actively competing in the race towards the $1,000 genome. Each of these technologies produces raw sequence data with particular characteristics and distinct error models. However, it has become clear that three major contenders (Solexa/Illumina, Agencourt/Applied Biosystems, and Helicos BioSciences) aim to produce high volume, 25–30 base paired-end reads.</p>
    <p>Short read sequencing has lead to a new surge of interest in the old problem of sequence assembly. These new technologies have only recently started producing data suitable for de novo assembly. Several teams are now building short-read assemblers (see Section "Related Work"), but the protocols optimizing assembly projects (e.g. optimal mixes of short- and long-reads) are still being invented.</p>
    <p>In this paper we present our assembler SHORTY, targeted towards paired-end microread sequencing data. SHORTY uses a very small volume of "seeds", perhaps 5–10 reads/contigs per bacterial genome. These seeds can be either virtually constructed using a conventional single-ended read assembler, or purchased with a trivial amount of Sanger sequencing. Still, these seeds enable us to produce significant assemblies with a short-read coverage of 100×, easily obtainable on one run of any of the new machines. Further, our final assemblies prove very accurate even though our reads contain base error rates associated with the machines available today. Certain previous work on microread assembly underestimates the complexity of the problem by simulating assembly on error-free reads.</p>
    <p>SHORTY exploits two ideas which we believe of interest to the short-read assembly community:</p>
    <p>• <italic>Seed reads for crystallizing assemblies </italic>– Several other assemblers intermix low (say 2×) coverage from Sanger or 454 reads with a higher coverage of short reads to fill up gaps. Instead, we use a single 300 – 500 base computed seed read to grow a neighboring contig of greater or equal to Sanger length. By repeating this process on the new contig, we can walk across the full genome assembling perhaps 90% of the genome into 15–20 kb contigs. Assembling the results of such walks from a trivial number of seeds produces contigs with an N50 size (length such that at least 50% of the assembled genome lies in blocks of the N50 size or greater) of 40 kb on bacterial genomes and 98% coverage in non-trivial contigs.</p>
    <p>The <italic>seed </italic>coverage assumed by our protocol is so modest it eliminates the need for a lab to own more than one type of sequencing platform. These trivial number of reads can be generated from short reads by following any simple assembly algorithm or likely even extracted from highly-conserved ribosomal RNA sequences scavenged from databases. Already existing assemblers (e.g. [<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B2">2</xref>]) for single-ended short reads can generate these starter seeds.</p>
    <p>• <italic>Inter-contig distance estimation from spanning paired-end reads </italic>– Sequencing protocols specify the mean separation distance and variance between the ends of the paired-end reads. Typically, these insert lengths are normally distributed, say with a mean distance of 2700 bases and a standard deviation of 350 bases. Our walking assembly strategy naturally produces two neighboring contigs separated by some insert distance. The substantial number of paired-end reads with one end anchored in each contig provides the possibility of accurately estimating the distance between the contigs. Such estimation enables us to order contigs and fill gaps using shorter overlaps that would be unconvincing in the absence of distance information.</p>
    <p>Huson et. al [<xref ref-type="bibr" rid="B3">3</xref>] proposes an idea to order contigs from mate-pair reads but it is not scalable for the volume of data we have in a short read assembly project. In this paper, we use such distance estimation efforts in a way that scales for short read assemblers.</p>
    <p>We survey related work on short-read assembly below. The primary research issue today is not the head-to-head comparison of which assembler is "best", but to identify the most cost-effective short-read sequencing protocol which results in data that can be reconstructed when coupled with the right assembly strategy.</p>
    <sec>
      <title>Short read sequencing technologies</title>
      <p>Although the Sanger sequencing method [<xref ref-type="bibr" rid="B4">4</xref>] has been the dominant sequencing technology for decades, novel technologies for short read sequencing are being developed by several groups. [<xref ref-type="bibr" rid="B5">5</xref>-<xref ref-type="bibr" rid="B9">9</xref>]. See [<xref ref-type="bibr" rid="B10">10</xref>] for a recent survey and analysis of these technologies. These new short-read sequencing technologies differ in details of localizing molecules, amplification and sequencing approach. Our assembler has been developed for microread technologies that generate mate paired short reads. Hence, it is suitable for data generated by companies like:</p>
      <p>• <italic>Applied Biosystems</italic>: They recently released their SOLiD™ sequencing machine, which uses technology that is acquired from Agencourt Bioscience Corporation. Agencourt commercialized their technology based on <italic>Polony Sequencing </italic>developed by Church and Mitra [<xref ref-type="bibr" rid="B11">11</xref>,<xref ref-type="bibr" rid="B12">12</xref>]. Indeed, the parameters underlying our simulations were selected with SOLiD™ in mind.</p>
      <p>• <italic>Solexa</italic>: They were recently acquired by <italic>Illumina</italic>. Their sequencing machine, <italic>Illumina Genome Analyzer</italic>, can load to eight samples onto their flow cell surface for simultaneous analysis. The platform offers high accuracy, high throughput and relatively low cost ($3000 per run, $400 per channel), and promises real support for double-ended reads forthcoming very soon.</p>
      <p>• <italic>Helicos BioSciences</italic>: They are pioneering a single-molecule approach to sequencing based on technology from [<xref ref-type="bibr" rid="B13">13</xref>]. This offers advantages in capacity and eliminating amplification-specific bias. Their HeliScope™ sequencing machine contains two flow cells where billions of single molecules of sample DNA are captured on an application-specific proprietary surface to serve as templates for the sequencing-by-synthesis process. Recently, they published [<xref ref-type="bibr" rid="B14">14</xref>] M13 genome re-sequencing data based on their new technology.</p>
      <p>Table <xref ref-type="table" rid="T1">1</xref> compares the primary performance characteristics of various short read sequencing technologies.</p>
      <table-wrap position="float" id="T1">
        <label>Table 1</label>
        <caption>
          <p>Comparison of different short read sequencing technologies. Comparison of existing short read sequencing technologies in terms of throughput and read length.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td align="center">Company</td>
              <td align="center">Machine</td>
              <td align="center">Throughput (per run)</td>
              <td align="center">Read length (base)</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">454</td>
              <td align="center">GS FLX</td>
              <td align="center">100 M bases/7 hours</td>
              <td align="center">100 or more</td>
            </tr>
            <tr>
              <td align="center">Helicos</td>
              <td align="center">HeliScope</td>
              <td align="center">2 G bases/day</td>
              <td align="center">around 25</td>
            </tr>
            <tr>
              <td align="center">Applied Biosystems</td>
              <td align="center">SOLiD</td>
              <td align="center">4 G bases</td>
              <td align="center">25 – 30</td>
            </tr>
            <tr>
              <td align="center">Solexa</td>
              <td align="center">Illumina Genome Analyzer</td>
              <td align="center">2 G bases/2 days</td>
              <td align="center">25 – 30</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
    <sec>
      <title>Related work</title>
      <p>The success of shotgun sequencing [<xref ref-type="bibr" rid="B4">4</xref>] led to the development of several successful assemblers for Sanger reads. Most of them were based on the overlap-layout-consensus [<xref ref-type="bibr" rid="B15">15</xref>] paradigm, while others took a graph-theoretic approach. Some assemblers were suitable for hierarchical sequencing, while others targeted <italic>whole genome shotgun </italic>(WGS) sequencing.</p>
      <p>As short read sequencing technologies mature, several bioinformatics groups have started working on short read assembly projects. Most algorithms are still tested on simulated data, as true assembly-quality data is not yet readily available for most platforms. Solexa double-ended reads and Applied Biosystems' SOLiD™ system have just entered the market, so real data should be available in relatively short order. We classify short read assemblers in three different groups, based on the type of reads they expect. The first class of assemblers are similar to ours in targeting mate-paired data generated from Solexa/ABI machines:</p>
      <p>• ALLPATHS [<xref ref-type="bibr" rid="B16">16</xref>] is an assembler being developed at the <italic>Broad Institute </italic>reporting excellent assembly on paired-end Solexa-type data with 80× coverage using a protocol with three different insert sizes (50 kb ± 10%, 6 kb ± 10%, and 0.5 kb ± 1%). SHORTY is different in (1) assuming a substantially simpler, single library experimental protocol and (2) employing shorter reads (25 vs. 30 bp).</p>
      <p>• Medvedev and Brudno's RECOMB 2008 paper [<xref ref-type="bibr" rid="B17">17</xref>] reports assembly results for bacterial scale genomes which are more directly comparable to ours. They assemble simulated 25-base paired (although error-free) reads into contigs with N50 contig sizes around 25 kb. We produced bigger N50 (30 – 45 kb) even with the presence of sequencing errors.</p>
      <p>• <italic>Velvet </italic>[<xref ref-type="bibr" rid="B18">18</xref>] augments 50× Solexa data to produce high quality assemblies. They use reads of 35 bp length whereas SHORTY can handle 25 bp long reads, which is more realistic for SOLiD data. Our N50 size is comparable with those of <italic>Velvet </italic>despite the shorter read length.</p>
      <p>The second class are assemblers targeting 454 data, which include:</p>
      <p>• <italic>Newbler </italic>[<xref ref-type="bibr" rid="B19">19</xref>] is a proprietary de novo assembler from 454 Life Sciences Corporation which is designed to handle their data which is in the form of flowgrams. It is based on the overlap-layout-consensus paradigm and consists of three modules: Overlapper, Unitigger and Multialigner. As 454 doesn't typically produce paired-end data, <italic>Newbler </italic>generates a set of unlinked contigs.</p>
      <p>• <italic>EULER </italic>[<xref ref-type="bibr" rid="B20">20</xref>] analyzed the feasibility of short read assembly of read length 70–200 using EULER. On simulated data from several bacterial genomes, they produced a mix of long and short contigs.</p>
      <p>• EULER-SR [<xref ref-type="bibr" rid="B21">21</xref>], the new version of EULER is particularly designed for reads generated by next generation sequencing technologies. The results are based on a hybrid approach where they used 454 and Sanger type data together to generate an assembly. They presented some results for simulated paired 454 reads as well.</p>
      <p>• SHRAP [<xref ref-type="bibr" rid="B22">22</xref>] is another assembler that assemble reads of length around 200 base pairs using a proposed sequencing protocol for mammalian-scale genomes.</p>
      <p>A final class of short-read assemblers focuses on single-ended reads produced by the first generation of Solexa machines:</p>
      <p>• SSAKE [<xref ref-type="bibr" rid="B1">1</xref>] is a short read assembler that was tested with simulated error-free 25 mers. It performs well with viral genomes. In a recent release, SSAKE started supporting paired end reads.</p>
      <p>• SHARCGS [<xref ref-type="bibr" rid="B2">2</xref>] is a de novo short read assembler that handles short reads as short as 25–40 bases. It generates a set of large contigs but without any ordering information. Their algorithm was tested against <italic>Illumina's </italic>1 G sequencing instrument. It uses a method that it calls <italic>contig elongation</italic>: a read is extended by looking for other reads in a prefix tree for potential extensions. It doesn't handle paired-end reads.</p>
      <p>• <italic>Phusion </italic>[<xref ref-type="bibr" rid="B23">23</xref>] was used by <italic>Sanger Institute </italic>to assemble many genomes from shotgun sequences. Recently they showed [<xref ref-type="bibr" rid="B24">24</xref>] possibilities of assembling short reads by mixing a low coverage (0.5–2×) of capillary reads with them. They used 454 and Solexa data for their prototype.</p>
      <p>• <italic>Adena </italic>[<xref ref-type="bibr" rid="B25">25</xref>] is a recently published short read assembler that works on 35 bp long Illumina data and performs better and less resource hungry in comparison to SSAKE and SHARCGS. N50 sizes presented in their paper was in the range 6–14 k bp long.</p>
    </sec>
  </sec>
  <sec>
    <title>Results and Discussion</title>
    <sec>
      <title>Data preparation</title>
      <p>We have rigorously tested our assembler on simulated sequence data generated from three bacterial genomes – <italic>M. genitallium</italic>, <italic>S. suis </italic>(strain P1/7) and <italic>E. coli </italic>(DH10B). The reference sequences are 580, 075; 2, 007, 490 and 4, 686, 136 bases long. Our simulations were designed to conform as closely as possible to an assembly project on the Applied Biosystems' SOLiD platform. Indeed our coverage, insert distribution, and base error distribution are derived the actual data set discussed below.</p>
      <p>SOLiD is an ultra high-throughput technology. Thus we can exploit the resulting huge coverage to discard bad reads based on the base quality scores [<xref ref-type="bibr" rid="B26">26</xref>,<xref ref-type="bibr" rid="B27">27</xref>]. After discarding all the reads from the real data set that had average quality scores below 15, we still had 200× of raw reads with a 0.1% base sequencing error rate. The insert length for the data set was found to be normally distributed with mean length of 2,270 and standard deviation 350.</p>
      <p>We maintained these properties in our simulated dataset, except that we sampled our reads uniformly whereas the real data set contains artifacts like thinly sampled regions. All reads were 25 bases long and sampled in SOLiD's color space. Starter seeds used in the experiments were around 500 bases long. All data were sampled from both strands of the corresponding genome. All datasets were generated in SOLiD's <italic>two base encoding </italic>format and hence the contigs we generate are also two base encoded.</p>
    </sec>
    <sec>
      <title>Experiments with simulated SOLiD data</title>
      <p>Results for one dataset from each of the three species under consideration are shown in Table <xref ref-type="table" rid="T2">2</xref>. All the datasets were assembled with 100× input coverage and a small number of starter seeds. The results are shown in different levels of minimum contig accuracy (<italic>S</italic><sub><italic>c</italic></sub>) along with the overall assembly score (<italic>S</italic><sub><italic>a</italic></sub>) which basically shows the quality of our contigs. For a definition of these terms, please see the end of the Methods section.</p>
      <table-wrap position="float" id="T2">
        <label>Table 2</label>
        <caption>
          <p>Assembly results. Assembly results for different data sets. <italic>Coverage </italic>is the fraction of the reference sequence covered by the generated contigs. Results are shown within different levels of minimum contig accuracy (97%, 99%, 99.9%). Minimum length of a contig considered for this analysis was 100 bases. All contig lengths are expressed in kilo bases. <italic>L</italic><sub><italic>c </italic></sub>is the length of contig <italic>c </italic>whereas <italic>S</italic><sub><italic>c </italic></sub>is its accuracy score. <italic>S</italic><sub><italic>a </italic></sub>is the total assembly score. For further illustration of these terms, refer to the end of the Methods section.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td align="center">Species</td>
              <td align="center"># of reads (million)</td>
              <td align="center"># of seeds</td>
              <td align="center" colspan="3">Coverage (%)</td>
              <td align="center" colspan="3">N50 length (kb)</td>
              <td align="center">Max</td>
              <td align="center">
                <italic>S</italic>
                <sub>
                  <italic>a</italic>
                </sub>
              </td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td/>
              <td colspan="7">
                <hr/>
              </td>
              <td/>
            </tr>
            <tr>
              <td/>
              <td/>
              <td/>
              <td align="center">97</td>
              <td align="center">99</td>
              <td align="center">99.9</td>
              <td align="center">97</td>
              <td align="center">99</td>
              <td align="center">99.9</td>
              <td align="center"><italic>L</italic><sub><italic>c </italic></sub>(<italic>S</italic><sub><italic>c</italic></sub>)</td>
              <td/>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">
                <italic>M. genitallium</italic>
              </td>
              <td align="center">2.42</td>
              <td align="center">5</td>
              <td align="center">96.3</td>
              <td align="center">88.9</td>
              <td align="center">64.6</td>
              <td align="center">45.8</td>
              <td align="center">36.7</td>
              <td align="center">3.5</td>
              <td align="center">86.1 (99.1)</td>
              <td align="center">96.1</td>
            </tr>
            <tr>
              <td colspan="11">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center">
                <italic>S. suis</italic>
              </td>
              <td align="center">8.36</td>
              <td align="center">7</td>
              <td align="center">97.8</td>
              <td align="center">93.6</td>
              <td align="center">86.3</td>
              <td align="center">31.5</td>
              <td align="center">25.6</td>
              <td align="center">9.5</td>
              <td align="center">170.7 (95)</td>
              <td align="center">95.7</td>
            </tr>
            <tr>
              <td colspan="11">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center">
                <italic>E. coli</italic>
              </td>
              <td align="center">19.53</td>
              <td align="center">10</td>
              <td align="center">98.2</td>
              <td align="center">96.1</td>
              <td align="center">88.1</td>
              <td align="center">41.8</td>
              <td align="center">32.4</td>
              <td align="center">12</td>
              <td align="center">165 (97.4)</td>
              <td align="center">97.1</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>Table <xref ref-type="table" rid="T2">2</xref> shows the reference coverage achieved along with N50 size generated by SHORTY. In all cases, we achieved over 90% coverage with contig accuracy at least 99%. Our N50 size was also superior than most other comparable assemblers. For <italic>E. coli</italic>, the largest bacteria we considered, we obtained an N50 size of 41.8 kb with contig accuracy at least 97%. The largest contig had a size of 165 kb with an accuracy of 97.4%. Figure <xref ref-type="fig" rid="F1">1</xref> shows the coverage achieved by different size of contigs in the <italic>E. coli </italic>dataset. It also shows N90 size with high accuracy (at least 90%) is somewhere around 18 kb.</p>
      <fig position="float" id="F1">
        <label>Figure 1</label>
        <caption>
          <p><bold>Min contig len vs. coverage</bold>. Coverage of reference sequence by various sizes of contigs with different levels of minimum contig accuracies (90%, 95%, 97%, 99%, 99.9%; shown in different colors) for the <italic>E. coli </italic>dataset. First portion of the graph (the region containing N50) is zoomed inside the small rectangle.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-S1-S16-1"/>
      </fig>
    </sec>
    <sec>
      <title>Experiments with real SOLiD data</title>
      <p>We obtained access to an initial real dataset of 300× (read size was 25) coverage of <italic>E. coli </italic>(DH10B) in June 2008. Throwing out the "bad reads" (average base quality score 15 or less) still left us with 200× coverage. After running SHORTY on it, we managed to maintain more than 90% coverage of the reference sequence in pieces of length 100 or more. However the maximum contig length was only 1,641 where the simulated data with half the coverage produced a contig as big as 165,013 bp (Table <xref ref-type="table" rid="T2">2</xref>). We ran three experiments (Table <xref ref-type="table" rid="T3">3</xref>) with each of them processing three randomly chosen seeds from the reference. All of them show similar results in terms of coverage, contig length and distribution of gaps. Gaps were of short length and uniformly distributed over the sequence. This was due to the thinly sampled regions (see Figure <xref ref-type="fig" rid="F2">2</xref>) or missing points which we believe is an artifact that needs to be overcome by SOLiD.</p>
      <table-wrap position="float" id="T3">
        <label>Table 3</label>
        <caption>
          <p>Assembly with real data. Three SHORTY experiments with real ABI SOLiD data. Each experiment was run using three different and randomly sampled seeds. <italic>Coverage </italic>is the fraction of the reference sequence covered by the generated contigs. Results are shown within different levels of minimum contig accuracy (97%, 99%, 99.9%). Minimum length of a contig considered for this analysis was 100 bases. For gap analysis, minimum contigs accuracy considered was 90%. <italic>L</italic><sub><italic>c </italic></sub>is the length of contig <italic>c </italic>whereas <italic>S</italic><sub><italic>a </italic></sub>is the total assembly score. For further illustration of these terms, refer to the end of Section "Methods".</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td align="center">Test</td>
              <td align="center" colspan="3">Coverage (%)</td>
              <td align="center">Average <italic>L</italic><sub><italic>c</italic></sub></td>
              <td align="center"># of gaps</td>
              <td align="center">Avg. gap len</td>
              <td align="center">
                <italic>S</italic>
                <sub>
                  <italic>a</italic>
                </sub>
              </td>
            </tr>
            <tr>
              <td/>
              <td colspan="3">
                <hr/>
              </td>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td/>
              <td align="center">97</td>
              <td align="center">99</td>
              <td align="center">99.9</td>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">1</td>
              <td align="center">92.3</td>
              <td align="center">87.8</td>
              <td align="center">57.4</td>
              <td align="center">161.5</td>
              <td align="center">4691</td>
              <td align="center">62.3</td>
              <td align="center">94.4</td>
            </tr>
            <tr>
              <td colspan="8">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center">2</td>
              <td align="center">93.3</td>
              <td align="center">88.4</td>
              <td align="center">58.7</td>
              <td align="center">164.5</td>
              <td align="center">4736</td>
              <td align="center">58.5</td>
              <td align="center">94.5</td>
            </tr>
            <tr>
              <td colspan="8">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center">3</td>
              <td align="center">92.9</td>
              <td align="center">88.1</td>
              <td align="center">58.2</td>
              <td align="center">165.0</td>
              <td align="center">4690</td>
              <td align="center">63.4</td>
              <td align="center">94.5</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <fig position="float" id="F2">
        <label>Figure 2</label>
        <caption>
          <p><bold>Thickness in real data</bold>. Frequency of thickness in 200× real SOLiD reads sampled from <italic>E. coli</italic>. Thickness of a position is defined as the number of reads covering that position. The zoomed area shows the areas with low thickness (no more than 50).</p>
        </caption>
        <graphic xlink:href="1471-2105-10-S1-S16-2"/>
      </fig>
      <p>To put our performance on the real dataset into perspective, we tested the data against other available assemblers. None of them currently works with ABI's <italic>color space </italic>data, making it difficult to find suitable assembler that could run SOLiD data with minor format change. We tried SHARCGS [<xref ref-type="bibr" rid="B2">2</xref>], but even the 32 G memory available in our machines did not suffice for assembly. We tried the latest version of SSAKE [<xref ref-type="bibr" rid="B1">1</xref>] with the default setting for paired end reads. SSAKE produced only 846 contigs (only 2.1% coverage of the reference sequence) that were longer than 100 bases, with the maximum contig size of 337 bp.</p>
    </sec>
    <sec>
      <title>Resource consumption</title>
      <p>All experiments mentioned here were running in machines with two 1.8 GHz AMD Opteron processors. In the end, SHORTY was proved to be extremely efficient in memory consumption. A 100× single seeded experiment with <italic>M. genitallium </italic>took 220 M of memory. Experiments with <italic>S. suis </italic>and <italic>E. coli </italic>consumed 1.2 G and 2.7 G memory respectively. Their corresponding running time was 3, 6 and 10 hours. When using multiple seeds, we run each seed in parallel in different machines. That means, SHORTY is capable of running in most of today's personal computers. We have seen that resource consumption was one of the major concerns with short read assembly due the the huge volume of data.</p>
    </sec>
  </sec>
  <sec>
    <title>Conclusion</title>
    <p>We have presented what we believe to be the first results on the de novo assembly of ABI SOLiD data. The results we have presented here provide evidence that high-quality short read assembly is indeed possible using simple and economical protocols on real short-read data. Unlike previous works, our protocol uses a single sample preparation as opposed to a mix of insert sizes or or runs on a mix of different platforms (e.g. 454 and Solexa). Our assemblies thrive on significant variance in insert length, further simplifying preparation over others in the literature.</p>
    <p>Our use of single seed reads is more of a nuisance than a problem, as this data can be obtained cheaply through outsourcing services. An interesting question is whether they are really necessary. Database sequence from closely-related species should suffice, but even more to the point is noting how little information they add to the process. Three 500 base seeds represent only 3,000 bits of information in an assembled genome of 4,000,000 bits, making it hard to believe they really are essential. Our proposed alternative to this is to run an existing assembler on the initial reads to get few contigs large enough to serve as starter seeds. We hope add this to SHORTY as part of a future release.</p>
    <p>Our primary direction of further work is demonstrating significant de novo assemblies on each of the major short-read platforms, namely ABI SOLiD™, Solexa paired-read data, and Helicos Biosciences data as they become available to us. We are also working to raise our N50 sizes through gap filling techniques based on accurate positional estimation.</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <p>SHORTY is designed to work on paired end short reads. These reads (optionally accompanied by quality scores) are generated by recent technologies developed by Applied Biosystems, Solexa and others to come. Laboratory protocols aim to select targets whose insert separating the two reads is normally distributed around a given target length. Each paired read contains a distinct <italic>left-mer </italic>(<italic>lmer</italic>) and a <italic>right-mer </italic>(<italic>rmer</italic>). These reads may contain insertion, deletion, substitution or homo-polymer errors. Our protocol also uses a few 300 – 500 bp long reads (we call them <italic>seeds</italic>) to start with. Here is the basic workflow of SHORTY algorithm which is followed by a detailed description of each step:</p>
    <p>1. Reads are stored in an efficient data structure to be able to be retrieved later. Also all bad reads are discarded.</p>
    <p>2. A <italic>seed </italic>is chosen and processed. This can be any of the <italic>starter-seeds </italic>or <italic>next generation </italic>seeds that SHORTY generates. This step basically gives us a set of neighboring reads whose other ends (from the mate-pair) map onto the seed.</p>
    <p>3. From the group of reads we got from the previous step, we generate contigs based on their overlap information. We discard contigs that are below certain threshold length (say 100 bases).</p>
    <p>4. Some of the contigs generated are long enough to be considered as seeds again. For each such contig, we repeat from step 2. If we don't have any such contigs, we continue to the next step.</p>
    <p>5. All contigs generated from all seeds (including multiple starter seeds) are considered together for further processing to generate larger contigs.</p>
    <p>6. Scaffolds are generated and inter-contig gaps are calculated. Also, mis-assemblies (e.g. chimera) are detected at this step.</p>
    <sec>
      <title>Read storage</title>
      <p>In a typical data set, we have millions of pairs of reads. Our use of these reads requires them to be accessed many times during the assembly process. To make the searching process faster while spending less memory, we store the reads in a compact trie. We insert all the pairs based on their <italic>left-mers </italic>and <italic>right-mers</italic>. From each pair, we generate another pair of reads. The <italic>left-mer </italic>of the new pair will be the reverse complement of the <italic>left-mer </italic>of the original pair. Similarly the <italic>right-mer </italic>of the new pair will be the reverse complement of the <italic>right-mer </italic>of the original pair. We insert the new pair in a similar way. So, after the trie building process is finished, we know for a particular <italic>k-mer </italic>which pairs of reads contain that <italic>k-mer </italic>in their <italic>left-mer </italic>or <italic>right-mer</italic>.</p>
      <p>Since reads contain a variety of sequencing errors, our trie searching method is designed to search a <italic>k-mer </italic>within a certain number of maximum mismatches allowed.</p>
    </sec>
    <sec>
      <title>Processing a seed</title>
      <p>For each <italic>seed </italic>we detect the group of read pairs whose <italic>left-mers </italic>(or <italic>right-mers</italic>) will map onto that seed (by searching the trie we have already built). With high probability, this group of <italic>right-mers </italic>(or <italic>left-mers</italic>) belong to some neighboring reads in the reference sequence (Figure <xref ref-type="fig" rid="F3">3</xref>). The previously built trie of reads is used to determine this group. We take into consideration various types of sequencing errors while trying to map a read on the <italic>seed</italic>. This group forms the basis of forming larger contigs and next generation <italic>seeds</italic>. While processing a seed, we carefully try to handle repeat regions (Figure <xref ref-type="fig" rid="F4">4</xref>) as these might generate contigs with misleading positional information. Another situation where this problem can arise is when there are regions which are similar to their reverse complement. We call such regions <italic>palindrome </italic>regions. We detect seeds with repeats or palindrome regions by checking the number of reads that a seed can map onto itself. If it attracts too many reads (say twice as much as the input coverage), there is a strong chance that it has one of those problems.</p>
      <fig position="float" id="F3">
        <label>Figure 3</label>
        <caption>
          <p><bold>Seed processing</bold>. Group of <italic>right-mers </italic>(red) whose corresponding <italic>left-mers </italic>(blue) can be mapped on the <italic>seed </italic>(black). It can also be in the other way, i.e. <italic>right-mers </italic>mapped on the <italic>seed </italic>to form a group of <italic>left-mers</italic>.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-S1-S16-3"/>
      </fig>
      <fig position="float" id="F4">
        <label>Figure 4</label>
        <caption>
          <p><bold>Repeats and palindromes</bold>. Repeats (R) and palindromes (P) can generate contigs with misleading positional information.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-S1-S16-4"/>
      </fig>
    </sec>
    <sec>
      <title>Generating contigs</title>
      <p>The group of reads formed in the previous stage is expected to have overlapping reads when we are presented with enough input coverage. We construct a directed graph <italic>G </italic>= (<italic>V</italic>, <italic>E</italic>) where <italic>V </italic>is the set of reads in the group. <italic>E </italic>contains all the edges in the graph. An edge <italic>e</italic><sub><italic>ij </italic></sub>∈ <italic>E </italic>if there is a qualified (say above some threshold) overlap from read <italic>i </italic>to <italic>j</italic>. <italic>e</italic><sub><italic>ij </italic></sub>denotes the amount of overlap (For 25 base long SOLiD reads, we considered an overlap if it were at least 15 base long. But it depends on the coverage and quality of the data). We greedily choose the longest path from <italic>G </italic>and merge the reads along that path to produce a contig. We keep doing this for the next longest path possible. We only consider paths longer than a threshold. This generates a set of contigs which are expected to be in neighboring positions in the reference. While considering an overlap, we also take into account the quality of the bases. Considering the possibility that the reads may contain different kinds of errors, it is not always possible to have 'clean' overlaps. We use a <italic>dynamic programming </italic>based approach where we penalize for such error conditions. We also store voting information (for each position we count the number of A, T, G and C that comes from the constituting reads) for each position of a contig which helps us to choose the appropriate base for a position in case we have multiple candidates which might be the result of errors in the constituting reads. This can be used to determine the quality of that base.</p>
    </sec>
    <sec>
      <title>Generating new seeds</title>
      <p>Some of the <italic>contigs </italic>generated in the previous stage might qualify to be used as <italic>seeds </italic>again. These <italic>next generation seeds </italic>are chosen based on the length and quality of the <italic>contigs</italic>. It is also possible to use a collection of neighboring <italic>contigs </italic>as a single <italic>seed</italic>. However, in SHORTY we only consider individual <italic>contigs </italic>as <italic>seeds</italic>.</p>
      <p>New seeds are treated like starter seeds. This is where SHORTY keeps iterating until we have no more seeds or reads available for use or we have reached our desired output thickness level.</p>
    </sec>
    <sec>
      <title>Generating larger contigs</title>
      <p>At this stage we are expected to have decent sized <italic>contigs</italic>. In SHORTY, we allow a single read to be used multiple times to generate redundancy of contigs. This compensates for sequence repetitions, and works well when the data is sampled uniformly with few gaps, as should happen when sequencing with high coverage. We define output thickness defined as the ratio of the total length of generated contigs and reference sequence length. If our target output thickness is <italic>t</italic>, we usually allow a read to be used maximum <italic>t </italic>times. A typical value of <italic>t </italic>for a single starter seeded run is 5. With more starter seeds, we can choose a lower value of <italic>t</italic>. With <italic>t </italic>&gt; 1, it is expected that contigs will overlap among themselves. This along with the normal distribution of insert lengths form the basis of forming larger contigs and removal of inter-contig gaps.</p>
      <p>Figure <xref ref-type="fig" rid="F5">5</xref> explains how the gap between <italic>contigs </italic>get reduced. Contigs <italic>B </italic>and <italic>C </italic>are generated from seed <italic>A</italic>. If the standard deviation of <italic>insert length </italic>was zero, <italic>D</italic>, which is generated from <italic>C</italic>, must have overlapped completely with <italic>A</italic>. But we can safely assume that we will have 10–15% standard deviation in actual situation. However, we can still proceed in a situation where the standard deviation is zero using multiple <italic>seeds</italic>. As we can see in Figure <xref ref-type="fig" rid="F5">5</xref><italic>A</italic>, <italic>D </italic>and <italic>E </italic>now overlap to produce a larger <italic>contig </italic>while also reducing the gaps.</p>
      <fig position="float" id="F5">
        <label>Figure 5</label>
        <caption>
          <p><bold>Narrowing gaps</bold>. Because of the standard deviation of insert-length, gap between successive <italic>contigs </italic>reduces.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-S1-S16-5"/>
      </fig>
      <p>The number of contigs available for processing in this stage is very large. For example, a SHORTY run of <italic>E. coli </italic>with desired output thickness 5 and read reuse limit 5 produces more than 90, 000 contigs. Finding candidate merges like Figure <xref ref-type="fig" rid="F5">5</xref> from this large amount of possibilities can be expensive. Also, with the presence of repeat regions, considering a merge based on overlaps without any other information might be misleading.</p>
      <p>But SHORTY keeps track of reads that made the contigs. Also, because of the way we generate a contig, with very high probability constituting reads are not fooled by repeats and are from the neighboring locations. We use this information to merge these contigs. At first we construct a directed graph <italic>G </italic>= (<italic>V</italic>, <italic>E</italic>) like before (see Section "seed processing"). But in this graph <italic>V </italic>contains all the contigs and <italic>E </italic>contains all the edges in the graph. Again, an edge <italic>e</italic><sub><italic>ij </italic></sub>represents an overlap from contig <italic>i </italic>to contig <italic>j</italic>. But unlike the overlap calculation used in "seed processing", here overlaps don't represent a string overlap only. An overlap here also indicates that a common set of reads (Figure <xref ref-type="fig" rid="F6">6</xref>) made the overlapping portion in both contigs. This way we are able to avoid many repeat related issues. Once we have the graph, we keep extracting the longest possible paths from <italic>G </italic>using the previously used greedy algorithm. This also increased our contigs' size significantly.</p>
      <fig position="float" id="F6">
        <label>Figure 6</label>
        <caption>
          <p><bold>Contig overlap</bold>. Overlap between two contigs is only considered when reads with similar ids from both contigs make this. Here blue and red reads appear in both contigs and can form this overlap.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-S1-S16-6"/>
      </fig>
    </sec>
    <sec>
      <title>Contig scaffolding</title>
      <p>We use mate pair data in such a way that it is possible to trace back which contig was generated from which seed (Figure <xref ref-type="fig" rid="F7">7</xref>). We construct a directed graph <italic>G </italic>= (<italic>V</italic>, <italic>E</italic>) from this information. Vertices of <italic>G </italic>are the contigs and each seed is connected to all of its children. An edge <italic>e</italic><sub><italic>ij </italic></sub>is a directed edge from <italic>i </italic>to <italic>j </italic>if <italic>i </italic>is the generating seed for <italic>j</italic>. A chain of contigs in the same direction in the graph forms a scaffold.</p>
      <fig position="float" id="F7">
        <label>Figure 7</label>
        <caption>
          <p><bold>Scaffold construction</bold>. A chain of contigs in the same direction is used as a scaffold. Three different scaffold are shown in this figure in red, blue and black.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-S1-S16-7"/>
      </fig>
      <p>Contiguous contigs in the scaffold are merged if they become large enough in the previous steps. We can also re-map our initial reads to fill the gaps in a scaffold (Figure <xref ref-type="fig" rid="F8">8</xref>). If the gaps still persist, we provide an estimated gap length (see "Estimating gap between contigs").</p>
      <fig position="float" id="F8">
        <label>Figure 8</label>
        <caption>
          <p><bold>Scaffold gap removal</bold>. Unfilled gaps in scaffolds can be filled by re-mapping the reads onto the contigs.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-S1-S16-8"/>
      </fig>
    </sec>
    <sec>
      <title>Detecting misassemblies</title>
      <p>We detect mis-assemblies by mapping the reads back to the contigs (Figure <xref ref-type="fig" rid="F9">9</xref>). If there is a point where a wrong merge occurred, there are only a few paired reads where both of them get mapped to the opposite sides of that point. We split the contigs in such points. Our scaffolds can also be another source of identifying <italic>chimeras </italic>(Figure <xref ref-type="fig" rid="F10">10</xref>). Our scaffolds are ordered chains of contigs generated from mate paired reads. When two contigs become large enough to cover the gap between them, they should ovelap. Otherwise, there is a chance that at least one of them is a <italic>chimera</italic>.</p>
      <fig position="float" id="F9">
        <label>Figure 9</label>
        <caption>
          <p><bold>Chimera detection from read pairs</bold>. <italic>Chimeras </italic>are detected by mapping back the reads onto the contig. The contig is partitioned at a point where only a few pair have their reads in both sides of that point.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-S1-S16-9"/>
      </fig>
      <fig position="float" id="F10">
        <label>Figure 10</label>
        <caption>
          <p><bold>Chimera detection from scaffold</bold>. Contigs shown here are from one scaffold. <italic>A </italic>and <italic>B </italic>are two consecutive contigs large enough to overlap. If they don't overlap, there is a chance that either <italic>A </italic>or <italic>B </italic>is a chimera produced due to mis-assembly.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-S1-S16-10"/>
      </fig>
    </sec>
    <sec>
      <title>Estimating gap between contigs</title>
      <p>The combination of relatively high-coverage as realized by paired-end microreads provides new opportunities to accurately estimate the distance between non-overlapping contigs (e.g. Figure <xref ref-type="fig" rid="F8">8</xref>). The simulations discussed in this paper assume 100× sequence coverage in 25-base paired reads. This yields an expectation of two reads starting from each position on the genome, half of which will represent the 5' read. This implies that the number of read-pairs spanning any interior position on the genome roughly equals the insert length. Thus hundreds or even thousands of read pairs connect each two non-overlapping contigs, all of whose insert sizes were drawn from a normal distribution of known mean and standard deviation. By analyzing where these read-pairs map on each contig we can accurately estimate the inter-contig distance. Huson et. al [<xref ref-type="bibr" rid="B3">3</xref>] has the statistical analysis required to calculate such distances and we use similar calculations for SHORTY.</p>
      <p>Accurate distance estimation is vital in later-stage contig merging in SHORTY. Many contigs generated from seeds overlap, but too weakly to be statistically significant over the scale of a genome assembly. Accurate information about position enables us to merge them confidently. Secondary benefits include reduced running times (by avoiding unpromising contig-overlap pairs) and dealing with repeats.</p>
    </sec>
    <sec>
      <title>Contig accuracy</title>
      <p>To verify how well SHORTY is performing we determine the accuracy of a contig by mapping it back to the reference genome. MUMmer [<xref ref-type="bibr" rid="B28">28</xref>], which uses an efficient method based on suffix tree, is used to find these matches. For a match, an accuracy score <italic>S</italic><sub><italic>c </italic></sub>is defined as <italic>x </italic>+ <italic>y </italic>- 100, where <italic>x</italic>% of contig <italic>c </italic>was matched to the reference sequence with <italic>y</italic>% similarity. This way, we highly penalize for mismatched parts of a contig and only very good contigs get a good score. This is in contrast to some other assemblers where accuracy is only based on similarity and low penalty for mismatches.</p>
    </sec>
    <sec>
      <title>Assembly score</title>
      <p>SHORTY produces some misassembled contigs, just like any other assembler. In order to determine the overall assembly quality, these bad contigs should be taken into account. Unlike most other methods (where % of good contigs are reported) used in the literature, we take an weighted scoring scheme where alonger contig has more influence than a shorter contig. The total assembly score <italic>S</italic><sub><italic>a </italic></sub>is defined as (∑<sub>∀<italic>c</italic>∈<italic>C </italic></sub><italic>S</italic><sub><italic>c</italic></sub><italic>L</italic><sub><italic>c</italic></sub>)/∑<sub>∀<italic>c</italic>∈<italic>C </italic></sub><italic>L</italic><sub><italic>c</italic></sub>, where <italic>C </italic>is the set of all contigs, <italic>S</italic><sub><italic>c </italic></sub>is the accuracy measure for contig <italic>c </italic>∈ <italic>C </italic>and <italic>L</italic><sub><italic>c </italic></sub>is the length of contig <italic>c </italic>∈ <italic>C</italic>.</p>
    </sec>
  </sec>
  <sec>
    <title>Availability</title>
    <p>All documentation, source code and other information on SHORTY are available at <ext-link ext-link-type="uri" xlink:href="http://www.cs.sunysb.edu/~skiena/shorty"/>.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>MSH was responsible for the overall design and implementation of SHORTY and drafted the manuscript. NA made significant contributions in designing certain key data structures and contig geography. SS was involved in the overall design and drafting the manuscript. All authors reviewed and approved the final manuscript.</p>
  </sec>
</body>
<back>
  <ack>
    <sec>
      <title>Acknowledgements</title>
      <p>We are grateful for earlier work on SHORTY by J. Chen and G. Sabbani. We also thank Francisco M. De La Vega and Michael D. Rhodes of Applied Biosystems for their interest in the project. Comments made by the anonymous reviewers were also very helpful. This project is partially supported by NSF Grants EIA-0325123 and DBI-0444815.</p>
      <p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 10 Supplement 1, 2009: Proceedings of The Seventh Asia Pacific Bioinformatics Conference (APBC) 2009. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10?issue=S1"/></p>
    </sec>
  </ack>
  <ref-list>
    <ref id="B1">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Warren</surname>
            <given-names>RL</given-names>
          </name>
          <name>
            <surname>Sutton</surname>
            <given-names>GG</given-names>
          </name>
          <name>
            <surname>Jones</surname>
            <given-names>SJM</given-names>
          </name>
          <name>
            <surname>Holt</surname>
            <given-names>RA</given-names>
          </name>
        </person-group>
        <article-title>Assembling millions of short DNA sequences using SSAKE</article-title>
        <source>Bioinformatics</source>
        <year>2007</year>
        <volume>23</volume>
        <fpage>500</fpage>
        <lpage>501</lpage>
        <pub-id pub-id-type="pmid">17158514</pub-id>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btl629</pub-id>
      </citation>
    </ref>
    <ref id="B2">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dohm</surname>
            <given-names>JC</given-names>
          </name>
          <name>
            <surname>Lottaz</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Borodina</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Himmelbauer</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>SHARCGS, a fast and highly accurate short-read assembly algorithm for de novo genomic sequencing</article-title>
        <source>Genome Research</source>
        <year>2007</year>
        <volume>17</volume>
        <fpage>1697</fpage>
        <lpage>1706</lpage>
        <pub-id pub-id-type="pmid">17908823</pub-id>
        <pub-id pub-id-type="doi">10.1101/gr.6435207</pub-id>
      </citation>
    </ref>
    <ref id="B3">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Huson</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Reinert</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>EW</given-names>
          </name>
        </person-group>
        <article-title>The greedy path-merging algorithm for contig scaffolding</article-title>
        <source>Journal of the ACM (JACM)</source>
        <year>2002</year>
        <volume>49</volume>
        <fpage>603</fpage>
        <lpage>615</lpage>
        <pub-id pub-id-type="doi">10.1145/585265.585267</pub-id>
      </citation>
    </ref>
    <ref id="B4">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sanger</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Nicklen</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Coulson</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>DNA sequencing with chain-terminating inhibitors</article-title>
        <source>Proc Natl Acad Sci USA</source>
        <year>1977</year>
        <fpage>5463</fpage>
        <lpage>7</lpage>
        <pub-id pub-id-type="pmid">271968</pub-id>
        <pub-id pub-id-type="doi">10.1073/pnas.74.12.5463</pub-id>
      </citation>
    </ref>
    <ref id="B5">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Shendure</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Mitra</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Church</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Advanced sequencing technologies: methods and goals</article-title>
        <source>Nature Rev Gen</source>
        <year>2004</year>
        <volume>5</volume>
        <fpage>335</fpage>
        <lpage>344</lpage>
        <pub-id pub-id-type="doi">10.1038/nrg1325</pub-id>
      </citation>
    </ref>
    <ref id="B6">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Brenner</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Johnson</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Bridgham</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Golda</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Lloyd</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Johnson</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Luo</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>McCurdy</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Foy</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Ewan</surname>
            <given-names>M</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Gene expression analysis by massively parallel signature sequencing (MPSS) on microbead arrays</article-title>
        <source>Nat Biotechnol</source>
        <year>2003</year>
        <volume>18</volume>
        <fpage>630</fpage>
        <lpage>634</lpage>
        <pub-id pub-id-type="pmid">10835600</pub-id>
        <pub-id pub-id-type="doi">10.1038/76469</pub-id>
      </citation>
    </ref>
    <ref id="B7">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kling</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Ultrafast DNA sequencing</article-title>
        <source>Nat Biotechol</source>
        <year>2003</year>
        <volume>21</volume>
        <fpage>1425</fpage>
        <lpage>1427</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt1203-1425</pub-id>
      </citation>
    </ref>
    <ref id="B8">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Miller</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Duan</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Lovins</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Kloss</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Kwok</surname>
            <given-names>PY</given-names>
          </name>
        </person-group>
        <article-title>Efficient high-throughput resequencing of genomic DNA</article-title>
        <source>Genome Res</source>
        <year>2003</year>
        <volume>13</volume>
        <fpage>717</fpage>
        <lpage>720</lpage>
        <pub-id pub-id-type="pmid">12654721</pub-id>
        <pub-id pub-id-type="doi">10.1101/gr.886203</pub-id>
      </citation>
    </ref>
    <ref id="B9">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ronaghi</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Uhlen</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Nyren</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>DNA sequencing: a sequencing method based on real-time pyrophosphate</article-title>
        <source>Science</source>
        <year>1998</year>
        <volume>281</volume>
        <fpage>363</fpage>
        <lpage>365</lpage>
        <pub-id pub-id-type="pmid">9705713</pub-id>
        <pub-id pub-id-type="doi">10.1126/science.281.5375.363</pub-id>
      </citation>
    </ref>
    <ref id="B10">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Mitchelson</surname>
            <given-names>KR</given-names>
          </name>
          <collab>(Ed)</collab>
        </person-group>
        <source>New High Throughput Technologies For DNA Sequencing And Genomics, of Perspectives</source>
        <year>2007</year>
        <volume>2</volume>
        <publisher-name>Bioanalysis. Elsevier</publisher-name>
      </citation>
    </ref>
    <ref id="B11">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mitra</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Church</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>In situ localized amplification and contact replication of many individual DNA molecules</article-title>
        <source>Nucleic Acids Research</source>
        <year>1999</year>
        <volume>27</volume>
        <fpage>1</fpage>
        <lpage>6</lpage>
        <pub-id pub-id-type="pmid">9847130</pub-id>
        <pub-id pub-id-type="doi">10.1093/nar/27.24.e34</pub-id>
      </citation>
    </ref>
    <ref id="B12">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mitra</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Shendure</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Olejnik</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Church</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Fluorescent in situ Sequencing on Polymerase Colonies</article-title>
        <source>Analyt Biochem</source>
        <year>2003</year>
        <pub-id pub-id-type="pmid">12895469</pub-id>
      </citation>
    </ref>
    <ref id="B13">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Braslavsky</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Hebert</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Kartalov</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Quake</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Sequence Information can be obtained from single DNA molecules</article-title>
        <source>PNAS</source>
        <year>2003</year>
        <volume>100</volume>
        <fpage>3960</fpage>
        <lpage>3964</lpage>
        <pub-id pub-id-type="pmid">12651960</pub-id>
        <pub-id pub-id-type="doi">10.1073/pnas.0230489100</pub-id>
      </citation>
    </ref>
    <ref id="B14">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Harris</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Buzby</surname>
            <given-names>P</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Single-molecule DNA sequencing of a viral genome</article-title>
        <source>Science</source>
        <year>2008</year>
        <fpage>106</fpage>
        <lpage>9</lpage>
        <pub-id pub-id-type="pmid">18388294</pub-id>
        <pub-id pub-id-type="doi">10.1126/science.1150427</pub-id>
      </citation>
    </ref>
    <ref id="B15">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kececioglu</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Combinatorial Algorithms for DNA Sequence Assembly</article-title>
        <source>Algorithmica</source>
        <year>1995</year>
        <volume>13</volume>
        <fpage>7</fpage>
        <lpage>51</lpage>
        <pub-id pub-id-type="doi">10.1007/BF01188580</pub-id>
      </citation>
    </ref>
    <ref id="B16">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Butler</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>MacCalluma</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Kleber</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Shlyakhter</surname>
            <given-names>IA</given-names>
          </name>
          <name>
            <surname>Belmonte</surname>
            <given-names>MK</given-names>
          </name>
          <name>
            <surname>Lander</surname>
            <given-names>ES</given-names>
          </name>
          <name>
            <surname>Nusbaum</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Jaffe</surname>
            <given-names>DB</given-names>
          </name>
        </person-group>
        <article-title>ALLPATHS: De novo assembly of whole-genome shotgun microreads</article-title>
        <source>Genome Research</source>
        <year>2008</year>
        <volume>18</volume>
        <fpage>810</fpage>
        <lpage>820</lpage>
        <pub-id pub-id-type="pmid">18340039</pub-id>
        <pub-id pub-id-type="doi">10.1101/gr.7337908</pub-id>
      </citation>
    </ref>
    <ref id="B17">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Medvedev</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Brudno</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Ab Initio Whole Genome Shotgun Assembly With Mated Short Reads</article-title>
        <source>RECOMB</source>
        <year>2008</year>
      </citation>
    </ref>
    <ref id="B18">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zerbino</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Velvet: Algorithms for De Novo Short Read Assembly Using De Bruijn Graphs</article-title>
        <source>Genome Research</source>
        <year>2008</year>
        <pub-id pub-id-type="pmid">18349386</pub-id>
      </citation>
    </ref>
    <ref id="B19">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Margulies</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Jarvie</surname>
            <given-names>TP</given-names>
          </name>
          <name>
            <surname>Knight</surname>
            <given-names>JR</given-names>
          </name>
          <name>
            <surname>Simons</surname>
            <given-names>JF</given-names>
          </name>
        </person-group>
        <source>New High Throughput Technologies for DNA Sequencing and Genomics, Amsterdam: Elsevier 2007 chap The 454 Life Sciences Picoliter Sequencing System</source>
        <fpage>151</fpage>
        <lpage>186</lpage>
      </citation>
    </ref>
    <ref id="B20">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chaisson</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Pevzner</surname>
            <given-names>PA</given-names>
          </name>
          <name>
            <surname>Tang</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Fragment assembly with short reads</article-title>
        <source>Bioinformatics</source>
        <year>2004</year>
        <volume>20</volume>
        <fpage>2067</fpage>
        <lpage>2074</lpage>
        <pub-id pub-id-type="pmid">15059830</pub-id>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bth205</pub-id>
      </citation>
    </ref>
    <ref id="B21">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Chaisson</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Pevzner</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Short Read Fragment Assembly of Bacterial Genomes</article-title>
        <comment/>
      </citation>
    </ref>
    <ref id="B22">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sundquist</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Ronaghi</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Tang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Pevzner</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Batzoglou</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Whole-genome sequencing and assembly with high-throughput, short-read technologies</article-title>
        <source>PLoS ONE</source>
        <year>2007</year>
        <volume>2</volume>
        <pub-id pub-id-type="pmid">17534434</pub-id>
      </citation>
    </ref>
    <ref id="B23">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mullikin</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Ning</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <article-title>The Phusion Assembler</article-title>
        <source>Genome Res</source>
        <year>2003</year>
        <volume>13</volume>
        <fpage>81</fpage>
        <lpage>90</lpage>
        <pub-id pub-id-type="pmid">12529309</pub-id>
        <pub-id pub-id-type="doi">10.1101/gr.731003</pub-id>
      </citation>
    </ref>
    <ref id="B24">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Keane</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Ning</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <article-title>Assessing Assemblability of Reads from New Sequencing Platforms</article-title>
        <source>15th Annual International Conference on Intelligent Systems for Molecular Biology (ISMB) Poster</source>
        <year>2007</year>
        <ext-link ext-link-type="uri" xlink:href="http://www.iscb.org/uploaded/css/B16Keane.pdf"/>
      </citation>
    </ref>
    <ref id="B25">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hernandez</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Francois</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Farinelli</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Osteras</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Schrenzel</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>De novo bacterial genome sequencing: millions of very short reads assembled on a desktop computer</article-title>
        <source>Genome Research</source>
        <year>2008</year>
        <pub-id pub-id-type="pmid">18332092</pub-id>
      </citation>
    </ref>
    <ref id="B26">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ewing</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Hillier</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Wendl</surname>
            <given-names>MC</given-names>
          </name>
          <name>
            <surname>Green</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Base-Calling of Automated Sequencer Traces Phred. I. Using Accuracy Assessment</article-title>
        <source>Genome Res</source>
        <year>1998</year>
        <volume>8</volume>
        <fpage>175</fpage>
        <lpage>185</lpage>
        <pub-id pub-id-type="pmid">9521921</pub-id>
      </citation>
    </ref>
    <ref id="B27">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ewing</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Green</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Base-Calling of Automated Sequencer Traces Using Phred. II. Error Probabilities</article-title>
        <source>Genome Res</source>
        <year>1998</year>
        <volume>8</volume>
        <fpage>186</fpage>
        <lpage>194</lpage>
        <pub-id pub-id-type="pmid">9521922</pub-id>
      </citation>
    </ref>
    <ref id="B28">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kurtz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Phillippy</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Delcher</surname>
            <given-names>AL</given-names>
          </name>
          <name>
            <surname>Smoot</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Shumway</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Antonescu</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>Versatile and open software for comparing large genomes</article-title>
        <source>Genome Biology</source>
        <year>2004</year>
        <volume>5</volume>
        <pub-id pub-id-type="pmid">14759262</pub-id>
      </citation>
    </ref>
  </ref-list>
</back>
