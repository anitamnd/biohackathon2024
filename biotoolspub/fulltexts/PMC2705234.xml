<?properties open_access?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1460-2059</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">2705234</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btp324</article-id>
    <article-id pub-id-type="publisher-id">btp324</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group>
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Fast and accurate short read alignment with Burrows–Wheeler transform</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Li</surname>
          <given-names>Heng</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Durbin</surname>
          <given-names>Richard</given-names>
        </name>
        <xref ref-type="corresp" rid="COR1">*</xref>
      </contrib>
    </contrib-group>
    <aff id="AFF1">Wellcome Trust Sanger Institute, Wellcome Trust Genome Campus, Cambridge, CB10 1SA, UK</aff>
    <author-notes>
      <corresp id="COR1">* To whom correspondence should be addressed.</corresp>
      <fn>
        <p>Associate Editor: John Quackenbush</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>7</month>
      <year>2009</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>18</day>
      <month>5</month>
      <year>2009</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>18</day>
      <month>5</month>
      <year>2009</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>25</volume>
    <issue>14</issue>
    <fpage>1754</fpage>
    <lpage>1760</lpage>
    <history>
      <date date-type="received">
        <day>20</day>
        <month>2</month>
        <year>2009</year>
      </date>
      <date date-type="rev-recd">
        <day>6</day>
        <month>5</month>
        <year>2009</year>
      </date>
      <date date-type="accepted">
        <day>12</day>
        <month>5</month>
        <year>2009</year>
      </date>
    </history>
    <permissions>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by-nc/2.0/uk/">
        <license-p><!--CREATIVE COMMONS-->This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/2.0/uk/">http://creativecommons.org/licenses/by-nc/2.0/uk/</ext-link>) which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> The enormous amount of short reads generated by the new DNA sequencing technologies call for the development of fast and accurate read alignment programs. A first generation of hash table-based methods has been developed, including MAQ, which is accurate, feature rich and fast enough to align short reads from a single individual. However, MAQ does not support gapped alignment for single-end reads, which makes it unsuitable for alignment of longer reads where indels may occur frequently. The speed of MAQ is also a concern when the alignment is scaled up to the resequencing of hundreds of individuals.</p>
      <p><bold>Results:</bold> We implemented Burrows-Wheeler Alignment tool (BWA), a new read alignment package that is based on backward search with Burrows–Wheeler Transform (BWT), to efficiently align short sequencing reads against a large reference sequence such as the human genome, allowing mismatches and gaps. BWA supports both base space reads, e.g. from Illumina sequencing machines, and color space reads from AB SOLiD machines. Evaluations on both simulated and real data suggest that BWA is ∼10–20× faster than MAQ, while achieving similar accuracy. In addition, BWA outputs alignment in the new standard SAM (Sequence Alignment/Map) format. Variant calling and other downstream analyses after the alignment can be achieved with the open source SAMtools software package.</p>
      <p>
        <bold>Availability:</bold>
        <ext-link ext-link-type="uri" xlink:href="http://maq.sourceforge.net">http://maq.sourceforge.net</ext-link>
      </p>
      <p>
        <bold>Contact:</bold>
        <email>rd@sanger.ac.uk</email>
      </p>
    </abstract>
  </article-meta>
</front>
<body>
  <sec sec-type="intro" id="SEC1">
    <title>1 INTRODUCTION</title>
    <p>The Illumina/Solexa sequencing technology typically produces 50–200 million 32–100 bp reads on a single run of the machine. Mapping this large volume of short reads to a genome as large as human poses a great challenge to the existing sequence alignment programs. To meet the requirement of efficient and accurate short read mapping, many new alignment programs have been developed. Some of these, such as Eland (Cox, 2007, unpublished material), RMAP (Smith <italic>et al.</italic>, <xref ref-type="bibr" rid="B17">2008</xref>), MAQ (Li <italic>et al.</italic>, <xref ref-type="bibr" rid="B13">2008a</xref>), ZOOM (Lin <italic>et al.</italic>, <xref ref-type="bibr" rid="B11">2008</xref>), SeqMap (Jiang and Wong, <xref ref-type="bibr" rid="B7">2008</xref>), CloudBurst (Schatz, <xref ref-type="bibr" rid="B16">2009</xref>) and SHRiMP (<ext-link ext-link-type="uri" xlink:href="http://compbio.cs.toronto.edu/shrimp">http://compbio.cs.toronto.edu/shrimp</ext-link>), work by hashing the read sequences and scan through the reference sequence. Programs in this category usually have flexible memory footprint, but may have the overhead of scanning the whole genome when few reads are aligned. The second category of software, including SOAPv1 (Li <italic>et al.</italic>, <xref ref-type="bibr" rid="B14">2008b</xref>), PASS (Campagna <italic>et al.</italic>, <xref ref-type="bibr" rid="B2">2009</xref>), MOM (Eaves and Gao, <xref ref-type="bibr" rid="B3">2009</xref>), ProbeMatch (Jung Kim <italic>et al.</italic>, <xref ref-type="bibr" rid="B8">2009</xref>), NovoAlign (<ext-link ext-link-type="uri" xlink:href="http://www.novocraft.com">http://www.novocraft.com</ext-link>), ReSEQ (<ext-link ext-link-type="uri" xlink:href="http://code.google.com/p/re-seq">http://code.google.com/p/re-seq</ext-link>), Mosaik (<ext-link ext-link-type="uri" xlink:href="http://bioinformatics.bc.edu/marthlab/Mosaik">http://bioinformatics.bc.edu/marthlab/Mosaik</ext-link>) and BFAST (<ext-link ext-link-type="uri" xlink:href="http://genome.ucla.edu/bfast">http://genome.ucla.edu/bfast</ext-link>), hash the genome. These programs can be easily parallelized with multi-threading, but they usually require large memory to build an index for the human genome. In addition, the iterative strategy frequently introduced by these software may make their speed sensitive to the sequencing error rate. The third category includes slider (Malhis <italic>et al.</italic>, <xref ref-type="bibr" rid="B15">2009</xref>) which does alignment by merge-sorting the reference subsequences and read sequences.</p>
    <p>Recently, the theory on string matching using Burrows–Wheeler Transform (BWT) (Burrows and Wheeler, <xref ref-type="bibr" rid="B1">1994</xref>) has drawn the attention of several groups, which has led to the development of SOAPv2 (<ext-link ext-link-type="uri" xlink:href="http://soap.genomics.org.cn/">http://soap.genomics.org.cn/</ext-link>), Bowtie (Langmead <italic>et al.</italic>, <xref ref-type="bibr" rid="B10">2009</xref>) and BWA, our new aligner described in this article. Essentially, using backward search (Ferragina and Manzini, <xref ref-type="bibr" rid="B4">2000</xref>; Lippert, <xref ref-type="bibr" rid="B12">2005</xref>) with BWT, we are able to effectively mimic the top-down traversal on the prefix trie of the genome with relatively small memory footprint (Lam <italic>et al.</italic>, <xref ref-type="bibr" rid="B9">2008</xref>) and to count the number of exact hits of a string of length <italic>m</italic> in <italic>O</italic>(<italic>m</italic>) time independent of the size of the genome. For inexact search, BWA samples from the implicit prefix trie the distinct substrings that are less than <italic>k</italic> edit distance away from the query read. Because exact repeats are collapsed on one path on the prefix trie, we do not need to align the reads against each copy of the repeat. This is the main reason why BWT-based algorithms are efficient.</p>
    <p>In this article, we will give a sufficient introduction to the background of BWT and backward search for exact matching, and present the algorithm for inexact matching which is implemented in BWA. We evaluate the performance of BWA on simulated data by comparing the BWA alignment with the true alignment from the simulation, as well as on real paired-end data by checking the fraction of reads mapped in consistent pairs and by counting misaligned reads mapped against a hybrid genome.</p>
  </sec>
  <sec sec-type="methods" id="SEC2">
    <title>2 METHODS</title>
    <sec id="SEC2.1">
      <title>2.1 Prefix trie and string matching</title>
      <p>The prefix trie for string <italic>X</italic> is a tree where each edge is labeled with a symbol and the string concatenation of the edge symbols on the path from a leaf to the root gives a unique prefix of <italic>X</italic>. On the prefix trie, the string concatenation of the edge symbols from a node to the root gives a unique substring of <italic>X</italic>, called the string represented by the node. Note that the prefix trie of <italic>X</italic> is identical to the suffix trie of reverse of <italic>X</italic> and therefore suffix trie theories can also be applied to prefix trie.</p>
      <p>With the prefix trie, testing whether a query <italic>W</italic> is an exact substring of <italic>X</italic> is equivalent to finding the node that represents <italic>W</italic>, which can be done in <italic>O</italic>(|<italic>W</italic>|) time by matching each symbol in <italic>W</italic> to an edge, starting from the root. To allow mismatches, we can exhaustively traverse the trie and match <italic>W</italic> to each possible path. We will later show how to accelerate this search by using prefix information of <italic>W</italic>. <xref ref-type="fig" rid="F1">Figure 1</xref> gives an example of the prefix trie for ‘<monospace>GOOGOL</monospace>’. The suffix array (SA) interval in each node is explained in <xref ref-type="sec" rid="SEC2.3">Section 2.3</xref>.
<fig id="F1" position="float"><label>Fig. 1.</label><caption><p>Prefix trie of string ‘<monospace>GOOGOL</monospace>’. Symbol ∧ marks the start of the string. The two numbers in a node give the SA interval of the string represented by the node (see <xref ref-type="sec" rid="SEC2.3">Section 2.3</xref>). The dashed line shows the route of the brute-force search for a query string ‘<monospace>LOL</monospace>’, allowing at most one mismatch. Edge labels in squares mark the mismatches to the query in searching. The only hit is the bold node [1, 1] which represents string ‘<monospace>GOL</monospace>’.</p></caption><graphic xlink:href="btp324f1"/></fig></p>
    </sec>
    <sec id="SEC2.2">
      <title>2.2 Burrows–Wheeler transform</title>
      <p>Let Σ be an alphabet. Symbol $ is not present in Σ and is lexicographically smaller than all the symbols in Σ. A string <italic>X</italic>=<italic>a</italic><sub>0</sub><italic>a</italic><sub>1</sub>…<italic>a</italic><sub><italic>n</italic>−1</sub> is always ended with symbol $ (i.e. <italic>a</italic><sub><italic>n</italic>−1</sub>=$) and this symbol only appears at the end. Let <italic>X</italic>[<italic>i</italic>]=<italic>a</italic><sub><italic>i</italic></sub>, <italic>i</italic>=0, 1,…, <italic>n</italic>−1, be the <italic>i</italic>-th symbol of <italic>X</italic>, <italic>X</italic>[<italic>i</italic>, <italic>j</italic>]=<italic>a</italic><sub><italic>i</italic></sub> …<italic>a</italic><sub><italic>j</italic></sub> a substring and <italic>X</italic><sub><italic>i</italic></sub>=<italic>X</italic>[<italic>i</italic>, <italic>n</italic>−1] a suffix of <italic>X</italic>. Suffix array <italic>S</italic> of <italic>X</italic> is a permutation of the integers 0…<italic>n</italic>−1 such that <italic>S</italic>(<italic>i</italic>) is the start position of the <italic>i</italic>-th smallest suffix. The BWT of <italic>X</italic> is defined as <italic>B</italic>[<italic>i</italic>]=$ when <italic>S</italic>(<italic>i</italic>)=0 and <italic>B</italic>[<italic>i</italic>]=<italic>X</italic>[<italic>S</italic>(<italic>i</italic>)−1] otherwise. We also define the length of string <italic>X</italic> as |<italic>X</italic>| and therefore |<italic>X</italic>|=|<italic>B</italic>|=<italic>n</italic>. <xref ref-type="fig" rid="F2">Figure 2</xref> gives an example on how to construct BWT and suffix array.
<fig id="F2" position="float"><label>Fig. 2.</label><caption><p>Constructing suffix array and BWT string for <italic>X</italic>=<monospace>googol$</monospace>. String <italic>X</italic> is circulated to generate seven strings, which are then lexicographically sorted. After sorting, the positions of the first symbols form the suffix array (6, 3, 0, 5, 2, 4, 1) and the concatenation of the last symbols of the circulated strings gives the BWT string <monospace>lo$oogg</monospace>.</p></caption><graphic xlink:href="btp324f2"/></fig></p>
      <p>The algorithm shown in <xref ref-type="fig" rid="F2">Figure 2</xref> is quadratic in time and space. However, this is not necessary. In practice, we usually construct the suffix array first and then generate BWT. Most algorithms for constructing suffix array require at least <italic>n</italic>⌈log<sub>2</sub><italic>n</italic>⌉ bits of working space, which amounts to 12 GB for human genome. Recently, Hon <italic>et al.</italic> (<xref ref-type="bibr" rid="B6">2007</xref>) gave a new algorithm that uses <italic>n</italic> bits of working space and only requires &lt;1 GB memory at peak time for constructing the BWT of human genome . This algorithm is implemented in BWT-SW (Lam <italic>et al.</italic>, <xref ref-type="bibr" rid="B9">2008</xref>). We adapted its source code to make it work with BWA.</p>
    </sec>
    <sec id="SEC2.3">
      <title>2.3 Suffix array interval and sequence alignment</title>
      <p>If string <italic>W</italic> is a substring of <italic>X</italic>, the position of each occurrence of <italic>W</italic> in <italic>X</italic> will occur in an interval in the suffix array. This is because all the suffixes that have <italic>W</italic> as prefix are sorted together. Based on this observation, we define:
<disp-formula id="M1"><label>(1)</label><graphic xlink:href="btp324m1"/></disp-formula>
<disp-formula id="M2"><label>(2)</label><graphic xlink:href="btp324m2"/></disp-formula>
In particular, if <italic>W</italic> is an empty string, <underline><italic>R</italic></underline>(<italic>W</italic>)=1 and <inline-formula><inline-graphic xlink:href="btp324i1.jpg"/></inline-formula>. The interval <inline-formula><inline-graphic xlink:href="btp324i2.jpg"/></inline-formula> is called the <italic>SA interval</italic> of <italic>W</italic> and the set of positions of all occurrences of <italic>W</italic> in <italic>X</italic> is <inline-formula><inline-graphic xlink:href="btp324i3.jpg"/></inline-formula>. For example in <xref ref-type="fig" rid="F2">Figure 2</xref>, the SA interval of string ‘<monospace>go</monospace>’ is [1, 2]. The suffix array values in this interval are 3 and 0 which give the positions of all the occurrences of ‘<monospace>go</monospace>’.</p>
      <p>Knowing the intervals in suffix array we can get the positions. Therefore, sequence alignment is equivalent to searching for the SA intervals of substrings of <italic>X</italic> that match the query. For the exact matching problem, we can find only one such interval; for the inexact matching problem, there may be many.</p>
    </sec>
    <sec id="SEC2.4">
      <title>2.4 Exact matching: backward search</title>
      <p>Let <italic>C</italic>(<italic>a</italic>) be the number of symbols in <italic>X</italic>[0, <italic>n</italic>−2] that are lexicographically smaller than <italic>a</italic> ∈ Σ and <italic>O</italic>(<italic>a</italic>, <italic>i</italic>) the number of occurrences of <italic>a</italic> in <italic>B</italic>[0, <italic>i</italic>]. Ferragina and Manzini (<xref ref-type="bibr" rid="B4">2000</xref>) proved that if <italic>W</italic> is a substring of <italic>X</italic>:
<disp-formula id="M3"><label>(3)</label><graphic xlink:href="btp324m3"/></disp-formula>
<disp-formula id="M4"><label>(4)</label><graphic xlink:href="btp324m4"/></disp-formula>
and that <inline-formula><inline-graphic xlink:href="btp324i4.jpg"/></inline-formula> if and only if <italic>aW</italic> is a substring of <italic>X</italic>. This result makes it possible to test whether <italic>W</italic> is a substring of <italic>X</italic> and to count the occurrences of <italic>W</italic> in <italic>O</italic>(|<italic>W</italic>|) time by iteratively calculating <underline><italic>R</italic></underline> and <inline-formula><inline-graphic xlink:href="btp324i5.jpg"/></inline-formula> from the end of <italic>W</italic>. This procedure is called <italic>backward search</italic>.</p>
      <p>It is important to note that Equations (<xref ref-type="disp-formula" rid="M3">3</xref>) and (<xref ref-type="disp-formula" rid="M4">4</xref>) actually realize the top-down traversal on the prefix trie of <italic>X</italic> given that we can calculate the SA interval of a child node in constant time if we know the interval of its parent. In this sense, backward search is equivalent to exact string matching on the prefix trie, but without explicitly putting the trie in the memory.</p>
    </sec>
    <sec id="SEC2.5">
      <title>2.5 Inexact matching: bounded traversal/backtracking</title>
      <p><xref ref-type="fig" rid="F3">Figure 3</xref> gives a recursive algorithm to search for the SA intervals of substrings of <italic>X</italic> that match the query string <italic>W</italic> with no more than <italic>z</italic> differences (mismatches or gaps). Essentially, this algorithm uses backward search to sample distinct substrings from the genome. This process is bounded by the <italic>D</italic>(·) array where <italic>D</italic>(<italic>i</italic>) is the lower bound of the number of differences in <italic>W</italic>[0, <italic>i</italic>]. The better the <italic>D</italic> is estimated, the smaller the search space and the more efficient the algorithm is. A naive bound is achieved by setting <italic>D</italic>(<italic>i</italic>)=0 for all <italic>i</italic>, but the resulting algorithm is clearly exponential in the number of differences and would be less efficient.
<fig id="F3" position="float"><label>Fig. 3.</label><caption><p>Algorithm for inexact search of SA intervals of substrings that match <italic>W</italic>. Reference <italic>X</italic> is $ terminated, while <italic>W</italic> is A/C/G/T terminated. Procedure I<sc>nexact</sc>S<sc>earch</sc>(<italic>W</italic>, <italic>z</italic>) returns the SA intervals of substrings that match <italic>W</italic> with no more than <italic>z</italic> differences (mismatches or gaps); I<sc>nex</sc>R<sc>ecur</sc>(<italic>W</italic>, <italic>i</italic>, <italic>z</italic>, <italic>k</italic>, <italic>l</italic>) recursively calculates the SA intervals of substrings that match <italic>W</italic>[0, <italic>i</italic>] with no more than <italic>z</italic> differences on the condition that suffix <italic>W</italic><sub><italic>i</italic>+1</sub> matches interval [<italic>k</italic>, <italic>l</italic>]. Lines started with asterisk are for insertions to and deletions from <italic>X</italic>, respectively. <italic>D</italic>(<italic>i</italic>) is the lower bound of the number of differences in string <italic>W</italic>[0, <italic>i</italic>].</p></caption><graphic xlink:href="btp324f3"/></fig></p>
      <p>The C<sc>alculate</sc>D procedure in <xref ref-type="fig" rid="F3">Figure 3</xref> gives a better, though not optimal, bound. It is conceptually equivalent to the one described in <xref ref-type="fig" rid="F4">Figure 4</xref>, which is simpler to understand. We use the BWT of the reverse (not complemented) reference sequence to test if a substring of <italic>W</italic> is also a substring of <italic>X</italic>. Note that to do this test with BWT string <italic>B</italic> alone would make C<sc>alculate</sc>D an <italic>O</italic>(|<italic>W</italic>|<sup>2</sup>) procedure, rather than <italic>O</italic>(|<italic>W</italic>|) as is described in <xref ref-type="fig" rid="F3">Figure 3</xref>.
<fig id="F4" position="float"><label>Fig. 4.</label><caption><p>Equivalent algorithm to calculate <italic>D</italic>(<italic>i</italic>).</p></caption><graphic xlink:href="btp324f4"/></fig></p>
      <p>To understand the role of <italic>D</italic>, we come back to the example of searching for <italic>W</italic> =<monospace>LOL</monospace> in <italic>X</italic>=<monospace>GOOGOL$</monospace> (<xref ref-type="fig" rid="F1">Fig. 1</xref>). If we set <italic>D</italic>(<italic>i</italic>)=0 for all <italic>i</italic> and disallow gaps (removing the two star lines in the algorithm), the call graph of I<sc>nex</sc>R<sc>ecur</sc>, which is a tree, effectively mimics the search route shown as the dashed line in <xref ref-type="fig" rid="F1">Figure 1</xref>. However, with C<sc>alculate</sc>D, we know that <italic>D</italic>(0)=0 and <italic>D</italic>(1)=<italic>D</italic>(2)=1. We can then avoid descending into the ‘<monospace>G</monospace>’ and ‘<monospace>O</monospace>’ subtrees in the prefix trie to get a much smaller search space.</p>
      <p>The algorithm in <xref ref-type="fig" rid="F3">Figure 3</xref> guarantees to find all the intervals allowing maximum <italic>z</italic> differences. It is complete in theory, but in practice, we also made various modifications. First, we pay different penalties for mismatches, gap opens and gap extensions, which is more realistic to biological data. Second, we use a heap-like data structure to keep partial hits rather than using recursion. The heap-like structure is prioritized on the alignment score of the partial hits to make BWA always find the best intervals first. The reverse complemented read sequence is processed at the same time. Note that the recursion described in <xref ref-type="fig" rid="F3">Figure 3</xref> effectively mimics a depth-first search (DFS) on the prefix trie, while BWA implements a breadth-first search (BFS) using this heap-like data structure. Third, we adopt an iterative strategy: if the top interval is repetitive, we do not search for suboptimal intervals by default; if the top interval is unique and has <italic>z</italic> difference, we only search for hits with up to <italic>z</italic> + 1 differences. This iterative strategy accelerates BWA while retaining the ability to generate mapping quality. However, this also makes BWA's speed sensitive to the mismatch rate between the reads and the reference because finding hits with more differences is usually slower. Fourth, we allow to set a limit on the maximum allowed differences in the first few tens of base pairs on a read, which we call the <italic>seed</italic> sequence. Given 70 bp simulated reads, alignment with maximum two differences in the 32 bp seed is 2.5× faster than without seeding. The alignment error rate, which is the fraction of wrong alignments out of confident mappings in simulation (see also <xref ref-type="sec" rid="SEC3.2">Section 3.2</xref>), only increases from 0.08% to 0.11%. Seeding is less effective for shorter reads.</p>
    </sec>
    <sec id="SEC2.6">
      <title>2.6 Reducing memory</title>
      <p>The algorithm described above needs to load the occurrence array <italic>O</italic> and the suffix array <italic>S</italic> in the memory. Holding the full <italic>O</italic> and <italic>S</italic> arrays requires huge memory. Fortunately, we can reduce the memory by only storing a small fraction of the <italic>O</italic> and <italic>S</italic> arrays, and calculating the rest on the fly. BWT-SW (Lam <italic>et al.</italic>, <xref ref-type="bibr" rid="B9">2008</xref>) and Bowtie (Langmead <italic>et al.</italic>, <xref ref-type="bibr" rid="B10">2009</xref>) use a similar strategy which was first introduced by Ferragina and Manzini (<xref ref-type="bibr" rid="B4">2000</xref>).</p>
      <p>Given a genome of size <italic>n</italic>, the occurrence array <italic>O</italic>(·, ·) requires 4<italic>n</italic>⌈log<sub>2</sub><italic>n</italic>⌉ bits as each integer takes ⌈log<sub>2</sub><italic>n</italic>⌉ bits and there are 4<italic>n</italic> of them in the array. In practice, we store in memory <italic>O</italic>(·, <italic>k</italic>) for <italic>k</italic> that is a factor of 128 and calculate the rest of elements using the BWT string <italic>B</italic>. When we use two bits to represent a nucleotide, <italic>B</italic> takes 2<italic>n</italic> bits. The memory for backward search is thus 2<italic>n</italic>+<italic>n</italic>⌈log<sub>2</sub><italic>n</italic>⌉/32 bits. As we also need to store the BWT of the reverse genome to calculate the bound, the memory required for calculating intervals is doubled, or about 2.3 GB for a 3 Gb genome.</p>
      <p>Enumerating the position of each occurrence requires the suffix array <italic>S</italic>. If we put the entire <italic>S</italic> in memory, it would use <italic>n</italic>⌈log<sub>2</sub><italic>n</italic>⌉ bits. However, it is also possible to reconstruct the entire <italic>S</italic> when knowing part of it. In fact, <italic>S</italic> and inverse compressed suffix array (inverse CSA) Ψ<sup>−1</sup> (Grossi and Vitter, <xref ref-type="bibr" rid="B5">2000</xref>) satisfy:
<disp-formula id="M5"><label>(5)</label><graphic xlink:href="btp324m5"/></disp-formula>
where (Ψ<sup>−1</sup>)<sup>(<italic>j</italic>)</sup> denotes repeatedly applying the transform Ψ<sup>−1</sup> for <italic>j</italic> times. The inverse CSA Ψ<sup>−1</sup> can be calculated with the occurrence array <italic>O</italic>:
<disp-formula id="M6"><label>(6)</label><graphic xlink:href="btp324m6"/></disp-formula>
In BWA, we only store in memory <italic>S</italic>(<italic>k</italic>) for <italic>k</italic> that can be divided by 32. For <italic>k</italic> that is not a factor of 32, we repeatedly apply Ψ<sup>−1</sup> until for some <italic>j</italic>, (Ψ<sup>−1</sup>)<sup>(<italic>j</italic>)</sup>(<italic>k</italic>) is a factor of 32 and then <italic>S</italic>((Ψ<sup>−1</sup>)<sup>(<italic>j</italic>)</sup>(<italic>k</italic>)) can be looked up and <italic>S</italic>(<italic>k</italic>) can be calculated with Equation (<xref ref-type="disp-formula" rid="M5">5</xref>).</p>
      <p>In all, the alignment procedure uses 4<italic>n</italic>+<italic>n</italic>⌈log<sub>2</sub><italic>n</italic>⌉/8 bits, or <italic>n</italic> bytes for genomes &lt;4 Gb. This includes the memory for the BWT string, partial occurrence array and partial suffix array for both original and the reversed genome. Additionally, a few hundred megabyte of memory is required for heap, cache and other data structures.</p>
    </sec>
    <sec id="SEC2.7">
      <title>2.7 Other practical concerns for Illumina reads</title>
      <sec id="SEC2.7.1">
        <title>2.7.1 Ambiguous bases</title>
        <p>Non-A/C/G/T bases on reads are simply treated as mismatches, which is implicit in the algorithm (<xref ref-type="fig" rid="F3">Fig. 3</xref>). Non-A/C/G/T bases on the reference genome are converted to random nucleotides. Doing so may lead to false hits to regions full of ambiguous bases. Fortunately, the chance that this may happen is very small given relatively long reads. We tried 2 million 32 bp reads and did not see any reads mapped to poly-N regions by chance.</p>
      </sec>
      <sec id="SEC2.7.2">
        <title>2.7.2 Paired-end mapping</title>
        <p>BWA supports paired-end mapping. It first finds the positions of all the good hits, sorts them according to the chromosomal coordinates and then does a linear scan through all the potential hits to pair the two ends. Calculating all the chromosomal coordinates requires to look up the suffix array frequently. This pairing process is time consuming as generating the full suffix array on the fly with the method described above is expensive. To accelerate pairing, we cache large intervals. This strategy halves the time spent on pairing.</p>
        <p>In pairing, BWA processes 256K read pairs in a batch. In each batch, BWA loads the full BWA index into memory, generates the chromosomal coordinate for each occurrence, estimates the insert size distribution from read pairs with both ends mapped with mapping quality higher than 20, and then pairs them. After that, BWA clears the BWT index from the memory, loads the 2 bit encoded reference sequence and performs Smith–Waterman alignment for unmapped reads whose mates can be reliably aligned. Smith–Waterman alignment rescues some reads with excessive differences.</p>
      </sec>
      <sec id="SEC2.7.3">
        <title>2.7.3 Determining the allowed maximum number of differences</title>
        <p>Given a read of length <italic>m</italic>, BWA only tolerates a hit with at most <italic>k</italic> differences (mismatches or gaps), where <italic>k</italic> is chosen such that &lt;4% of <italic>m</italic>-long reads with 2% uniform base error rate may contain differences more than <italic>k</italic>. With this configuration, for 15–37 bp reads, <italic>k</italic> equals 2; for 38–63 bp, <italic>k</italic>=3; for 64–92 bp, <italic>k</italic>=4; for 93–123 bp, <italic>k</italic>=5; and for 124–156 bp reads, <italic>k</italic>=6.</p>
      </sec>
      <sec id="SEC2.7.4">
        <title>2.7.4 Generating mapping quality scores</title>
        <p>For each alignment, BWA calculates a mapping quality score, which is the Phred-scaled probability of the alignment being incorrect. The algorithm is similar to MAQ's except that in BWA we assume the true hit can always be found. We made this modification because we are aware that MAQ's formula overestimates the probability of missing the true hit, which leads to underestimated mapping quality. Simulation reveals that BWA may overestimate mapping quality due to this modification, but the deviation is relatively small. For example, BWA wrongly aligns 11 reads out of 1 569 108 simulated 70 bp reads mapped with mapping quality 60. The error rate 7 × 10<sup>−6</sup> (= 11/1 569 108) for these Q60 mappings is higher than the theoretical expectation 10<sup>−6</sup>.</p>
      </sec>
    </sec>
    <sec id="SEC2.8">
      <title>2.8 Mapping SOLiD reads</title>
      <p>For SOLiD reads, BWA converts the reference genome to dinucleotide ‘color’ sequence and builds the BWT index for the color genome. Reads are mapped in the color space where the reverse complement of a sequence is the same as the reverse, because the complement of a color is itself. For SOLiD paired-end mapping, a read pair is said to be in the correct orientation if either of the two scenarios is true: (i) both ends mapped to the forward strand of the genome with the R3 read having smaller coordinate; and (ii) both ends mapped to the reverse strand of the genome with the F3 read having smaller coordinate. Smith–Waterman alignment is also done in the color space.</p>
      <p>After the alignment, BWA decodes the color read sequences to the nucleotide sequences using dynamic programming. Given a nucleotide reference subsequence <italic>b</italic><sub>1</sub><italic>b</italic><sub>2</sub>…<italic>b</italic><sub><italic>l</italic>+1</sub> and a color read sequence <italic>c</italic><sub>1</sub><italic>c</italic><sub>2</sub>…<italic>c</italic><sub><italic>l</italic></sub> mapped to the subsequence, BWA infers a nucleotide sequence <inline-formula><inline-graphic xlink:href="btp324i6.jpg"/></inline-formula> such that it minimizes the following objective function:
<disp-formula><graphic xlink:href="btp324um1"/></disp-formula>
where <italic>q</italic>′ is the Phred-scaled probability of a mutation, <italic>q</italic><sub><italic>i</italic></sub> is the Phred quality of color <italic>c</italic><sub><italic>i</italic></sub> and function <italic>g</italic>(<italic>b</italic>, <italic>b</italic>′)=<italic>g</italic>(<italic>b</italic>′, <italic>b</italic>) gives the color corresponding to the two adjacent nucleotides <italic>b</italic> and <italic>b</italic>′. Essentially, we pay a penalty <italic>q</italic>′ if <inline-formula><inline-graphic xlink:href="btp324i7.jpg"/></inline-formula> and a penalty <italic>q</italic><sub><italic>i</italic></sub> if <inline-formula><inline-graphic xlink:href="btp324i8.jpg"/></inline-formula>.</p>
      <p>This optimization can be done by dynamic programming because the best decoding beyond position <italic>i</italic> only depends on the choice of <inline-formula><inline-graphic xlink:href="btp324i9.jpg"/></inline-formula>. Let <inline-formula><inline-graphic xlink:href="btp324i10.jpg"/></inline-formula> be the best decoding score up to <italic>i</italic>. The iteration equations are
<disp-formula><graphic xlink:href="btp324um2"/></disp-formula>
<disp-formula><graphic xlink:href="btp324um3"/></disp-formula>
BWA approximates base qualities as follows. Let <inline-formula><inline-graphic xlink:href="btp324i11.jpg"/></inline-formula>. The <italic>i</italic>-th base quality <inline-formula><inline-graphic xlink:href="btp324i12.jpg"/></inline-formula>, <italic>i</italic>=2…<italic>l</italic>, is calculated as:
<disp-formula><graphic xlink:href="btp324um4"/></disp-formula>
BWA outputs the sequence <inline-formula><inline-graphic xlink:href="btp324i13.jpg"/></inline-formula> and the quality <inline-formula><inline-graphic xlink:href="btp324i14.jpg"/></inline-formula> as the final result for SOLiD mapping.</p>
    </sec>
  </sec>
  <sec sec-type="results" id="SEC3">
    <title>3 RESULTS</title>
    <sec id="SEC3.1">
      <title>3.1 Implementation</title>
      <p>We implemented BWA to do short read alignment based on the BWT of the reference genome. It performs gapped alignment for single-end reads, supports paired-end mapping, generates mapping quality and gives multiple hits if required. The default output alignment format is SAM (Sequence Alignment/Map format). Users can use SAMtools (<ext-link ext-link-type="uri" xlink:href="http://samtools.sourceforge.net">http://samtools.sourceforge.net</ext-link>) to extract alignments in a region, merge/sort alignments, get single nucleotide polymorphism (SNP) and indel calls and visualize the alignment.</p>
      <p>BWA is distributed under the GNU General Public License (GPL). Documentations and source code are freely available at the MAQ web site: <ext-link ext-link-type="uri" xlink:href="http://maq.sourceforge.net">http://maq.sourceforge.net</ext-link>.</p>
    </sec>
    <sec id="SEC3.2">
      <title>3.2 Evaluated programs</title>
      <p>To evaluate the performance of BWA, we tested additional three alignment programs: MAQ (Li <italic>et al.</italic>, <xref ref-type="bibr" rid="B13">2008a</xref>), SOAPv2 (<ext-link ext-link-type="uri" xlink:href="http://soap.genomics.org.cn">http://soap.genomics.org.cn</ext-link>) and Bowtie (Langmead <italic>et al.</italic>, <xref ref-type="bibr" rid="B10">2009</xref>). MAQ indexes reads with a hash table and scans through the genome. It is the software package we developed previously for large-scale read mapping. SOAPv2 and Bowtie are the other two BWT-based short read aligners that we are aware of. The latest SOAP-2.1.7 (Li <italic>et al.</italic>, unpublished data) uses 2way-BWT (Lam <italic>et al.</italic>, unpublished data) for alignment. It tolerates more mismatches beyond the 35 bp seed sequence and supports gapped alignment limited to one gap open. Bowtie (version 0.9.9.2) deploys a similar algorithm to BWA. Nonetheless, it does not reduce the search space by bounding the search with <italic>D</italic>(<italic>i</italic>), but by cleverly doing the alignment for both original and reverse read sequences to bypass unnecessary searches towards the root of the prefix trie. By default, Bowtie performs a DFS on the prefix trie and stops when the first qualified hit is found. Thus, it may miss the best inexact hit even if its seeding strategy is disabled. It is possible to make Bowtie perform a BFS by applying ‘–best’ at the command line, but this makes Bowtie slower. Bowtie does not support gapped alignment at the moment.</p>
      <p>All the four programs, including BWA, randomly place a repetitive read across the multiple equally best positions. As we are mainly interested in confident mappings in practice, we need to rule out repetitive hits. SOAPv2 gives the number of equally best hits of a read. Only unique mappings are retained. We also ask SOAPv2 to limit the possible gap size to at most 3 bp. We run Bowtie with the command-line option ‘–best -k 2’, which renders Bowtie to output the top two hits of a read. We discard a read alignment if the second best hit contains the same number of mismatches as the best hit. MAQ and BWA generate mapping qualities. We use mapping quality threshold 1 for MAQ and 10 for BWA to determine confident mappings. We use different thresholds because we know that MAQ's mapping quality is underestimated, while BWA's is overestimated.</p>
    </sec>
    <sec id="SEC3.3">
      <title>3.3 Evaluation on simulated data</title>
      <p>We simulated reads from the human genome using the wgsim program that is included in the SAMtools package and ran the four programs to map the reads back to the human genome. As we know the exact coordinate of each read, we are able to calculate the alignment error rate.</p>
      <p><xref ref-type="table" rid="T1">Table 1</xref> shows that BWA and MAQ achieve similar alignment accuracy. BWA is more accurate than Bowtie and SOAPv2 in terms of both the fraction of confidently mapped reads and the error rate of confident mappings. Note that SOAP-2.1.7 is optimized for reads longer than 35 bp. For the 32 bp reads, SOAP-2.0.1 outperforms the latest version.
<table-wrap id="T1" position="float"><label>Table 1.</label><caption><p>Evaluation on simulated data</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1"/><th align="left" colspan="3" rowspan="1">Single-end<hr/></th><th align="left" colspan="3" rowspan="1">Paired-end<hr/></th></tr><tr><th align="left" rowspan="1" colspan="1">Program</th><th align="left" rowspan="1" colspan="1">Time (s)</th><th align="left" rowspan="1" colspan="1">Conf (%)</th><th align="left" rowspan="1" colspan="1">Err (%)</th><th align="left" rowspan="1" colspan="1">Time (s)</th><th align="left" rowspan="1" colspan="1">Conf (%)</th><th align="left" rowspan="1" colspan="1">Err (%)</th></tr></thead><tbody align="left"><tr><td align="left" rowspan="1" colspan="1">Bowtie-32</td><td align="left" rowspan="1" colspan="1">1271</td><td align="left" rowspan="1" colspan="1">79.0</td><td align="left" rowspan="1" colspan="1">0.76</td><td align="left" rowspan="1" colspan="1">1391</td><td align="left" rowspan="1" colspan="1">85.7</td><td align="left" rowspan="1" colspan="1">0.57</td></tr><tr><td align="left" rowspan="1" colspan="1">BWA-32</td><td align="left" rowspan="1" colspan="1">823</td><td align="left" rowspan="1" colspan="1">80.6</td><td align="left" rowspan="1" colspan="1">0.30</td><td align="left" rowspan="1" colspan="1">1224</td><td align="left" rowspan="1" colspan="1">89.6</td><td align="left" rowspan="1" colspan="1">0.32</td></tr><tr><td align="left" rowspan="1" colspan="1">MAQ-32</td><td align="left" rowspan="1" colspan="1">19797</td><td align="left" rowspan="1" colspan="1">81.0</td><td align="left" rowspan="1" colspan="1">0.14</td><td align="left" rowspan="1" colspan="1">21589</td><td align="left" rowspan="1" colspan="1">87.2</td><td align="left" rowspan="1" colspan="1">0.07</td></tr><tr><td align="left" rowspan="1" colspan="1">SOAP2-32</td><td align="left" rowspan="1" colspan="1">256</td><td align="left" rowspan="1" colspan="1">78.6</td><td align="left" rowspan="1" colspan="1">1.16</td><td align="left" rowspan="1" colspan="1">1909</td><td align="left" rowspan="1" colspan="1">86.8</td><td align="left" rowspan="1" colspan="1">0.78</td></tr><tr><td align="left" rowspan="1" colspan="1">Bowtie-70</td><td align="left" rowspan="1" colspan="1">1726</td><td align="left" rowspan="1" colspan="1">86.3</td><td align="left" rowspan="1" colspan="1">0.20</td><td align="left" rowspan="1" colspan="1">1580</td><td align="left" rowspan="1" colspan="1">90.7</td><td align="left" rowspan="1" colspan="1">0.43</td></tr><tr><td align="left" rowspan="1" colspan="1">BWA-70</td><td align="left" rowspan="1" colspan="1">1599</td><td align="left" rowspan="1" colspan="1">90.7</td><td align="left" rowspan="1" colspan="1">0.12</td><td align="left" rowspan="1" colspan="1">1619</td><td align="left" rowspan="1" colspan="1">96.2</td><td align="left" rowspan="1" colspan="1">0.11</td></tr><tr><td align="left" rowspan="1" colspan="1">MAQ-70</td><td align="left" rowspan="1" colspan="1">17928</td><td align="left" rowspan="1" colspan="1">91.0</td><td align="left" rowspan="1" colspan="1">0.13</td><td align="left" rowspan="1" colspan="1">19046</td><td align="left" rowspan="1" colspan="1">94.6</td><td align="left" rowspan="1" colspan="1">0.05</td></tr><tr><td align="left" rowspan="1" colspan="1">SOAP2-70</td><td align="left" rowspan="1" colspan="1">317</td><td align="left" rowspan="1" colspan="1">90.3</td><td align="left" rowspan="1" colspan="1">0.39</td><td align="left" rowspan="1" colspan="1">708</td><td align="left" rowspan="1" colspan="1">94.5</td><td align="left" rowspan="1" colspan="1">0.34</td></tr><tr><td align="left" rowspan="1" colspan="1">bowtie-125</td><td align="left" rowspan="1" colspan="1">1966</td><td align="left" rowspan="1" colspan="1">88.0</td><td align="left" rowspan="1" colspan="1">0.07</td><td align="left" rowspan="1" colspan="1">1701</td><td align="left" rowspan="1" colspan="1">91.0</td><td align="left" rowspan="1" colspan="1">0.37</td></tr><tr><td align="left" rowspan="1" colspan="1">BWA-125</td><td align="left" rowspan="1" colspan="1">3021</td><td align="left" rowspan="1" colspan="1">93.0</td><td align="left" rowspan="1" colspan="1">0.05</td><td align="left" rowspan="1" colspan="1">3059</td><td align="left" rowspan="1" colspan="1">97.6</td><td align="left" rowspan="1" colspan="1">0.04</td></tr><tr><td align="left" rowspan="1" colspan="1">MAQ-125</td><td align="left" rowspan="1" colspan="1">17506</td><td align="left" rowspan="1" colspan="1">92.7</td><td align="left" rowspan="1" colspan="1">0.08</td><td align="left" rowspan="1" colspan="1">19388</td><td align="left" rowspan="1" colspan="1">96.3</td><td align="left" rowspan="1" colspan="1">0.02</td></tr><tr><td align="left" rowspan="1" colspan="1">SOAP2-125</td><td align="left" rowspan="1" colspan="1">555</td><td align="left" rowspan="1" colspan="1">91.5</td><td align="left" rowspan="1" colspan="1">0.17</td><td align="left" rowspan="1" colspan="1">1187</td><td align="left" rowspan="1" colspan="1">90.8</td><td align="left" rowspan="1" colspan="1">0.14</td></tr></tbody></table><table-wrap-foot><fn><p>One million pairs of 32, 70 and 125 bp reads, respectively, were simulated from the human genome with 0.09% SNP mutation rate, 0.01% indel mutation rate and 2% uniform sequencing base error rate. The insert size of 32 bp reads is drawn from a normal distribution <italic>N</italic>(170, 25), and of 70 and 125 bp reads from <italic>N</italic>(500, 50). CPU time in seconds on a single core of a 2.5 GHz Xeon E5420 processor (Time), percent confidently mapped reads (Conf) and percent erroneous alignments out of confident mappings (Err) are shown in the table.</p></fn></table-wrap-foot></table-wrap>
</p>
      <p>On speed, SOAPv2 is the fastest and actually it would be 30–80% faster for paired-end mapping if gapped alignment was disabled. Bowtie with the default option (data not shown) is several times faster than the current setting ‘–best -k 2’ on single-end mapping. However, the speed is gained at a great cost of accuracy. For example, with the default option, Bowtie can map the two million single-end 32 bp reads in 151 s, but 6.4% of confident mappings are wrong. This high alignment error rate may complicate the detection of structural variations and potentially affect SNP accuracy. Between BWA and MAQ, BWA is 6–18× faster, depending on the read length. MAQ's speed is not affected by read length because internally it treats all reads as 128 bp. It is possible to accelerate BWA by not checking suboptimal hits similar to what Bowtie and SOAPv2 are doing. However, calculating mapping quality would be impossible in this case and we believe generating proper mapping quality is useful to various downstream analyses such as the detection of structural variations.</p>
      <p>On memory, SOAPv2 uses 5.4 GB. Both Bowtie and BWA uses 2.3 GB for single-end mapping and about 3 GB for paired-end, larger than MAQ's memory footprint 1 GB. However, the memory usage of all the three BWT-based aligners is independent of the number of reads to be aligned, while MAQ's is linear in it. In addition, all BWT-based aligners support multi-threading, which reduces the memory per CPU core on a multi-core computer. On modern computer servers, memory is not a practical concern with the BWT-based aligners.</p>
    </sec>
    <sec id="SEC3.4">
      <title>3.4 Evaluation on real data</title>
      <p>To assess the performance on real data, we downloaded about 12.2 million pairs of 51 bp reads from European Read Archive (AC:ERR000589). These reads were produced by Illumina for NA12750, a male included in the 1000 Genomes Project (<ext-link ext-link-type="uri" xlink:href="http://www.1000genomes.org">http://www.1000genomes.org</ext-link>). Reads were mapped to the human genome NCBI build 36. <xref ref-type="table" rid="T2">Table 2</xref> shows that almost all confident mappings from MAQ and BWA exist in consistent pairs although MAQ gives fewer confident alignments. A slower mode of BWA (no seeding; searching for suboptimal hits even if the top hit is a repeat) did even better. In that mode, BWA confidently mapped 89.2% of all reads in 6.3 hours with 99.2% of confident mappings in consistent pairs.
<table-wrap id="T2" position="float"><label>Table 2.</label><caption><p>Evaluation on real data</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th align="left" rowspan="1" colspan="1">Program</th><th align="left" rowspan="1" colspan="1">Time (h)</th><th align="left" rowspan="1" colspan="1">Conf (%)</th><th align="left" rowspan="1" colspan="1">Paired (%)</th></tr></thead><tbody align="left"><tr><td align="left" rowspan="1" colspan="1">Bowtie</td><td align="left" rowspan="1" colspan="1">5.2</td><td align="left" rowspan="1" colspan="1">84.4</td><td align="left" rowspan="1" colspan="1">96.3</td></tr><tr><td align="left" rowspan="1" colspan="1">BWA</td><td align="left" rowspan="1" colspan="1">4.0</td><td align="left" rowspan="1" colspan="1">88.9</td><td align="left" rowspan="1" colspan="1">98.8</td></tr><tr><td align="left" rowspan="1" colspan="1">MAQ</td><td align="left" rowspan="1" colspan="1">94.9</td><td align="left" rowspan="1" colspan="1">86.1</td><td align="left" rowspan="1" colspan="1">98.7</td></tr><tr><td align="left" rowspan="1" colspan="1">SOAP2</td><td align="left" rowspan="1" colspan="1">3.4</td><td align="left" rowspan="1" colspan="1">88.3</td><td align="left" rowspan="1" colspan="1">97.5</td></tr></tbody></table><table-wrap-foot><fn><p>The 12.2 million read pairs were mapped to the human genome. CPU time in hours on a single core of a 2.5 GHz Xeon E5420 processor (Time), percent confidently mapped reads (Conf) and percent confident mappings with the mates mapped in the correct orientation and within 300 bp (Paired), are shown in the table.</p></fn></table-wrap-foot></table-wrap>
</p>
      <p>In this experiment, SOAPv2 would be twice as fast with both percent confident mapping (Conf) and percent paired (Paired) dropping by 1% if gapped alignment was disabled. In contrast, BWA is 1.4 times as fast when it performs ungapped alignment only. But even with BWT-based gapped alignment disabled, BWA is still able to recover many short indels with Smith–Waterman alignment given paired-end reads.</p>
      <p>We also obtained the chicken genome sequence (version 2.1) and aligned these 12.2 million read pairs against a human–chicken hybrid reference sequence. The percent confident mappings is almost unchanged in comparison to the human-only alignment. As for the number of reads mapped to the chicken genome, Bowtie mapped 2640, BWA 2942, MAQ 3005 and SOAPv2 mapped 4531 reads to the wrong genome. If we consider that the chicken sequences take up one-quarter of the human–chicken hybrid reference, the alignment error rate for BWA is about 0.06% (=2942×4/12.2M/0.889). Note that such an estimate of the alignment error rate may be underestimated because wrongly aligned human reads tend to be related to repetitive sequences in human and to be mapped back to the human sequences. The estimate may also be overestimated due to the presence of highly conservative sequences and the incomplete assembly of human or misassembly of the chicken genome.</p>
      <p>If we want fewer errors, the mapping quality generated by BWA and MAQ allows us to choose alignments of higher accuracy. If we increased the mapping quality threshold in determining a confident hit to 25 for BWA, 86.4% of reads could be aligned confidently with 1927 reads mapped to the chicken genome, outperforming Bowtie in terms of both percent confident mappings and the number of reads mapped to the wrong genome.</p>
    </sec>
  </sec>
  <sec sec-type="discussion" id="SEC4">
    <title>4 DISCUSSION</title>
    <p>For short read alignment against the human reference genome, BWA is an order of magnitude faster than MAQ while achieving similar alignment accuracy. It supports gapped alignment for single-end reads, which is increasingly important when reads get longer and tend to contain indels. BWA outputs alignment in the SAM format to take the advantage of the downstream analyses implemented in SAMtools. BWA plus SAMtools provides most of functionality of the MAQ package with additional features.</p>
    <p>In comparison to speed, memory and the number of mapped reads, alignment accuracy is much harder to evaluate on real data as we do not know the ground truth. In this article, we used three criteria for evaluating the accuracy of an aligner. The first criterion, which can only be evaluated with simulated data, is the combination of the number of confident mappings and the alignment error rate out of the confident mappings. Note that the number of confident mappings alone may not be a good criterion: we can map more at the cost of accuracy. The second criterion, which is the combination of the number of aligned reads and the number of reads mapped in consistent pairs, works on real data on the assumption that the mating information from the experiment is correct and that structural variations are rare. Although this criterion is related to the way an aligner defines pair ‘consistency’, in our experience it is highly informative if the pairing parameters are set correctly. The third criterion is the fraction of reads mapped to the wrong reference sequence if we intentionally add reference sequences from a diverged species.</p>
    <p>Although in theory BWA works with arbitrarily long reads, its performance is degraded on long reads especially when the sequencing error rate is high. Furthermore, BWA always requires the full read to be aligned, from the first base to the last one (i.e. global with respect to reads), but longer reads are more likely to be interrupted by structural variations or misassemblies in the reference genome, which will fail BWA. For long reads, a possibly better solution would be to divide the read into multiple short fragments, align the fragments separately with the algorithm described above and then join the partial alignments to get the full alignment of the read.</p>
  </sec>
</body>
<back>
  <ack>
    <title>ACKNOWLEDGEMENTS</title>
    <p>We are grateful to Mark DePristo and Jared Maguire from the Broad Institute for their suggestions on standardizing the criteria for evaluating alignment programs, and to the three anonymous reviewers whose comments helped us to improve the manuscript. We also thank the members of the Durbin research group for the comments on the initial draft.</p>
    <p><italic>Funding</italic>: Wellcome Trust/077192/Z/05/Z.</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="B1">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Burrows</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Wheeler</surname>
            <given-names>DJ</given-names>
          </name>
        </person-group>
        <article-title>A block-sorting lossless data compression algorithm</article-title>
        <source>Technical report 124</source>
        <year>1994</year>
        <publisher-loc>Palo Alto, CA</publisher-loc>
        <publisher-name>Digital Equipment Corporation</publisher-name>
      </element-citation>
    </ref>
    <ref id="B2">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Campagna</surname>
            <given-names>D</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>PASS: a program to align short sequences</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>967</fpage>
        <lpage>968</lpage>
        <pub-id pub-id-type="pmid">19218350</pub-id>
      </element-citation>
    </ref>
    <ref id="B3">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Eaves</surname>
            <given-names>HL</given-names>
          </name>
          <name>
            <surname>Gao</surname>
            <given-names>Y</given-names>
          </name>
        </person-group>
        <article-title>MOM: maximum oligonucleotide mapping</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>969</fpage>
        <lpage>970</lpage>
        <pub-id pub-id-type="pmid">19228804</pub-id>
      </element-citation>
    </ref>
    <ref id="B4">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Ferragina</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Opportunistic data structures with applications</article-title>
        <source>Proceedings of the 41st Symposium on Foundations of Computer Science (FOCS 2000)</source>
        <year>2000</year>
        <publisher-name>IEEE Computer Society</publisher-name>
        <fpage>390</fpage>
        <lpage>398</lpage>
      </element-citation>
    </ref>
    <ref id="B5">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Grossi</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Vitter</surname>
            <given-names>JS</given-names>
          </name>
        </person-group>
        <article-title>Compressed suffix arrays and suffix trees with applications to text indexing and string matching</article-title>
        <source>Proceedings on 32nd Annual ACM Symposium on Theory of Computing (STOC 2000)</source>
        <year>2000</year>
        <publisher-name>ACM</publisher-name>
        <fpage>397</fpage>
        <lpage>406</lpage>
      </element-citation>
    </ref>
    <ref id="B6">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hon</surname>
            <given-names>W.-K</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A space and time efficient algorithm for constructing compressed suffix arrays</article-title>
        <source>Algorithmica</source>
        <year>2007</year>
        <volume>48</volume>
        <fpage>23</fpage>
        <lpage>36</lpage>
      </element-citation>
    </ref>
    <ref id="B7">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Jiang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Wong</surname>
            <given-names>WH</given-names>
          </name>
        </person-group>
        <article-title>SeqMap: mapping massive amount of oligonucleotides to the genome</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <fpage>2395</fpage>
        <lpage>2396</lpage>
        <pub-id pub-id-type="pmid">18697769</pub-id>
      </element-citation>
    </ref>
    <ref id="B8">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Jung Kim</surname>
            <given-names>Y</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>ProbeMatch: a tool for aligning oligonucleotide sequences</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>1424</fpage>
        <lpage>1425</lpage>
        <pub-id pub-id-type="pmid">19351619</pub-id>
      </element-citation>
    </ref>
    <ref id="B9">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lam</surname>
            <given-names>TW</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Compressed indexing and local alignment of DNA</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <fpage>791</fpage>
        <lpage>797</lpage>
        <pub-id pub-id-type="pmid">18227115</pub-id>
      </element-citation>
    </ref>
    <ref id="B10">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Langmead</surname>
            <given-names>B</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</article-title>
        <source>Genome Biol.</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>R25</fpage>
        <pub-id pub-id-type="pmid">19261174</pub-id>
      </element-citation>
    </ref>
    <ref id="B11">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lin</surname>
            <given-names>H</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>ZOOM! Zillions of oligos mapped</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <fpage>2431</fpage>
        <lpage>2437</lpage>
        <pub-id pub-id-type="pmid">18684737</pub-id>
      </element-citation>
    </ref>
    <ref id="B12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lippert</surname>
            <given-names>RA</given-names>
          </name>
        </person-group>
        <article-title>Space-efficient whole genome comparisons with Burrows-Wheeler transforms</article-title>
        <source>J. Comput. Biol.</source>
        <year>2005</year>
        <volume>12</volume>
        <fpage>407</fpage>
        <lpage>415</lpage>
        <pub-id pub-id-type="pmid">15882139</pub-id>
      </element-citation>
    </ref>
    <ref id="B13">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Mapping short DNA sequencing reads and calling variants using mapping quality scores</article-title>
        <source>Genome Res.</source>
        <year>2008a</year>
        <volume>18</volume>
        <fpage>1851</fpage>
        <lpage>1858</lpage>
        <pub-id pub-id-type="pmid">18714091</pub-id>
      </element-citation>
    </ref>
    <ref id="B14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>R</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>SOAP: short oligonucleotide alignment program</article-title>
        <source>Bioinformatics</source>
        <year>2008b</year>
        <volume>24</volume>
        <fpage>713</fpage>
        <lpage>714</lpage>
        <pub-id pub-id-type="pmid">18227114</pub-id>
      </element-citation>
    </ref>
    <ref id="B15">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Malhis</surname>
            <given-names>N</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Slider–maximum use of probability information for alignment of short sequence reads and SNP detection</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>6</fpage>
        <lpage>13</lpage>
        <pub-id pub-id-type="pmid">18974170</pub-id>
      </element-citation>
    </ref>
    <ref id="B16">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schatz</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Cloudburst: highly sensitive read mapping with mapreduce</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>1363</fpage>
        <lpage>1369</lpage>
        <pub-id pub-id-type="pmid">19357099</pub-id>
      </element-citation>
    </ref>
    <ref id="B17">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smith</surname>
            <given-names>AD</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Using quality scores and longer reads improves accuracy of Solexa read mapping</article-title>
        <source>BMC Bioinformatics</source>
        <year>2008</year>
        <volume>9</volume>
        <fpage>128</fpage>
        <pub-id pub-id-type="pmid">18307793</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
