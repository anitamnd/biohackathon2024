<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10232250</article-id>
    <article-id pub-id-type="pmid">37171844</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad320</article-id>
    <article-id pub-id-type="publisher-id">btad320</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Efficient short read mapping to a pangenome that is represented by a graph of ED strings</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-9273-5439</contrib-id>
        <name>
          <surname>Büchler</surname>
          <given-names>Thomas</given-names>
        </name>
        <aff><institution>Institute of Theoretical Computer Science, Ulm University</institution>, 89075 Ulm, <country country="DE">Germany</country></aff>
        <xref rid="btad320-cor1" ref-type="corresp"/>
        <!--thomas.buechler@uni-ulm.de-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Olbrich</surname>
          <given-names>Jannik</given-names>
        </name>
        <aff><institution>Institute of Theoretical Computer Science, Ulm University</institution>, 89075 Ulm, <country country="DE">Germany</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Ohlebusch</surname>
          <given-names>Enno</given-names>
        </name>
        <aff><institution>Institute of Theoretical Computer Science, Ulm University</institution>, 89075 Ulm, <country country="DE">Germany</country></aff>
        <xref rid="btad320-cor1" ref-type="corresp"/>
        <!--enno.ohlebusch@uni-ulm.de-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Ponty</surname>
          <given-names>Yann</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad320-cor1">Corresponding authors. Institute Theoretical Computer Science, Ulm University, 89075 Ulm, Germany. E-mails: <email>thomas.buechler@uni-ulm.de</email> (T.B.) and <email>enno.ohlebusch@uni-ulm.de</email> (E.O.)</corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>5</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-05-12">
      <day>12</day>
      <month>5</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>12</day>
      <month>5</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>5</issue>
    <elocation-id>btad320</elocation-id>
    <history>
      <date date-type="received">
        <day>30</day>
        <month>8</month>
        <year>2022</year>
      </date>
      <date date-type="rev-recd">
        <day>30</day>
        <month>3</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>07</day>
        <month>5</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>11</day>
        <month>5</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>31</day>
        <month>5</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad320.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>A pangenome represents many diverse genome sequences of the same species. In order to cope with small variations as well as structural variations, recent research focused on the development of graph-based models of pangenomes. Mapping is the process of finding the original location of a DNA read in a reference sequence, typically a genome. Using a pangenome instead of a (linear) reference genome can, e.g. reduce mapping bias, the tendency to incorrectly map sequences that differ from the reference genome. Mapping reads to a graph, however, is more complex and needs more resources than mapping to a reference genome. Reducing the complexity of the graph by encoding simple variations like SNPs in a simple way can accelerate read mapping and reduce the memory requirements at the same time.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We introduce graphs based on elastic-degenerate strings (ED strings, EDS) and the linearized form of these EDS graphs as a new representation for pangenomes. In this representation, small variations are encoded directly in the sequence. Structural variations are encoded in a graph structure. This reduces the size of the representation in comparison to sequence graphs. In the linearized form, mapping techniques that are known from ordinary strings can be applied with appropriate adjustments. Since most variations are expressed directly in the sequence, the mapping process rarely has to take edges of the EDS graph into account. We developed a prototypical software tool GED-MAP that uses this representation together with a minimizer index to map short reads to the pangenome. Our experiments show that the new method works on a whole human genome scale, taking structural variants properly into account. The advantage of GED-MAP, compared with other pangenomic short read mappers, is that the new representation allows for a simple indexing method. This makes GED-MAP fast and memory efficient.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>Sources are available at: <ext-link xlink:href="https://github.com/thomas-buechler-ulm/gedmap" ext-link-type="uri">https://github.com/thomas-buechler-ulm/gedmap</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Deutsche Forschungsgemeinschaft</institution>
            <institution-id institution-id-type="DOI">10.13039/501100001659</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>OH 53/7-2</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>In genomic studies and diagnostics, a single linear reference is commonly used to represent the human genome. However, there are a lot of differences between the genomes of individuals of the same species and a single reference is unable to cover them. The <xref rid="btad320-B1" ref-type="bibr">1000 Genomes Project Consortium (2015)</xref> produced a database that includes the genomes of 2504 different humans and the differences between them. Including common variations in the reference gives a more accurate representation of the genomes of a species. Such a representation is called a pangenome. In most cases, a pangenome is constructed from a reference sequence and a VCF-file containing the variations. Roughly speaking, a pangenome can be seen as the set of all genomes of a species. Since the genomes share many identical substrings, they can collectively be represented by a sequence graph (<xref rid="btad320-B21" ref-type="bibr">The Computational Pan-Genomics Consortium 2016</xref>) or an elastic degenerate string (EDS) (<xref rid="btad320-B10" ref-type="bibr">Iliopoulos et al. 2017</xref>). Using a pangenome as the ground truth of scientific studies reduces reference allele bias since a common variation in a genome can be recognized as such and will not be treated as an error. Widely used next-generation sequencers produce short reads of a given DNA sample. A read is a substring of the sample that can include errors, and read mapping is the task of finding the locus in the genome the read emerged from. In read mapping, the reference bias has the consequence that reads may not be mapped correctly, e.g. if the allele of the sample differs from the reference allele. It has been shown (<xref rid="btad320-B8" ref-type="bibr">Garrison et al. 2018</xref>, <xref rid="btad320-B12" ref-type="bibr">Kim et al. 2019</xref>, <xref rid="btad320-B20" ref-type="bibr">Sirén et al. 2021</xref>) that the usage of a pangenome instead of a single reference sequence can cope with this problem. In the following, we briefly discuss this related work. HISAT2 (<xref rid="btad320-B12" ref-type="bibr">Kim et al. 2019</xref>) first builds a pangenome graph “by creating a linear graph from the reference genome and then adds mutations, deletions and insertions as alternative paths through the graph” (usually the variants are collected in a VCF file). HISAT2 “can incorporate insertions up to 20 base pairs (bp) and deletions of any length.” Thus, it does not incorporate complex structural variants, such as duplications, inversions or copy number variations. In a second step, HISAT2 constructs a genome graph index structure based on a method developed by Siren et al. (<xref rid="btad320-B19" ref-type="bibr">Sirén et al. 2014</xref>). In addition to the global index for representing the human genome plus a large collection of variants (the HISAT2 index covers 92% of known variants of the NA12878 genome), HISAT2 uses thousands of small indexes, each spanning ∼57 kb, which collectively cover the reference genome and its variants. This improves speed and accuracy. The VG-MAP algorithm (<xref rid="btad320-B8" ref-type="bibr">Garrison et al. 2018</xref>) incorporated complex structural variants into the pangenome graph, resulting in a complex sequence graph that contains cycles produced by duplications and complex genomic rearrangements. In the article that introduces Giraffe, the successor of VG-MAP, <xref rid="btad320-B20" ref-type="bibr">Sirén et al. (2021)</xref> write: “However, VG-MAP is at least an order of magnitude slower than popular linear genome mappers that have comparable accuracy. Given that mapping is frequently a bottleneck in genome analysis, the cost of VG-MAP has proven prohibitive.” For this reason, Giraffe does not incorporate structural variants other than large indels into its pangenome graph. Giraffe and HISAT2 both use a graph Burrows–Wheeler transform (GBWT) index, which is complex and difficult to understand. To speed up the mapping, Giraffe further takes reference haplotypes into account (paths in the pangenome graph that are observed in individuals’ genomes).</p>
    <p>In this article, we define a new representation of pangenomes. Our representation encodes single nucleotide polymorphisms (SNPs) as well as small insertions and deletions (indels) linearly and in place using a method similar to ED strings and the vBWT (<xref rid="btad320-B15" ref-type="bibr">Maciuca et al. 2016</xref>), but with a constant alphabet size. Large indels and copy number variations are represented in a graph structure. Among the advantages of our encoding is good readability and the availability of a simple coordinate system. This means that humans can directly see small variants in the sequence, without the need of plotting a graph.</p>
    <p>Moreover, we show how our representation can be used for short read mapping. The problem of matching (i.e. mapping without errors) patterns to ED strings without indexing is well studied (<xref rid="btad320-B9" ref-type="bibr">Grossi et al. 2017</xref>, <xref rid="btad320-B3" ref-type="bibr">Aoyama et al. 2018</xref>, <xref rid="btad320-B5" ref-type="bibr">Cisłak et al. 2018</xref>, <xref rid="btad320-B16" ref-type="bibr">Procházka et al. 2021</xref>). However, our approach allows errors and uses an index to accelerate the process. Therefore, it is more comparable to pangenomic short read mappers. The coordinate system resulting from our encoding enables us to directly apply position-based indexes, e.g. the minimizer index. We show how common methods like calculating a minimizer index, finding good seeds with the help of the index and aligning using dynamic programming can be adjusted to work efficiently on our representation. We compare our software tool GED-MAP with state-of-the-art tools for short read mapping to pangenomes on simulated and real datasets at a whole human genome scale. While the differences in the mapping accuracy are neglectable (except for structural variants), there are significant differences in the resources required to construct the index as well as in the mapping process. The experiments show that GED-MAP is fast and memory efficient because the new representation of pangenomes allows for a rather simple indexing method.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 Preliminaries</title>
      <p>In the following, <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mo>Σ</mml:mo></mml:math></inline-formula> denotes the alphabet of bases, i.e. <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mo>Σ</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi mathvariant="monospace">A</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="monospace">C</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="monospace">G</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="monospace">T</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. For a string <italic toggle="yes">S</italic>, we denote its length by <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. Furthermore, <italic toggle="yes">S</italic>[<italic toggle="yes">i</italic>, <italic toggle="yes">j</italic>] is the substring of <italic toggle="yes">S</italic> that starts at position <italic toggle="yes">i</italic> and ends at position <italic toggle="yes">j</italic>. In this article we use 1-based indexing. The following definitions specify <italic toggle="yes">Elastic-Degenerate strings (EDS)</italic>.</p>
      <statement id="mthst1">
        <label>Definition 1</label>
        <p>(Elastic-Degenerate symbol). An <italic toggle="yes">Elastic-Degenerate symbol (ED symbol)</italic> <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> over <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mo>Σ</mml:mo></mml:math></inline-formula> is a nonempty and finite set of strings over <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mo>Σ</mml:mo></mml:math></inline-formula>, i.e. <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> with <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>. A string <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math></inline-formula> is called an alternative. We will use the notation <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:mo>…</mml:mo><mml:mi mathvariant="monospace">|</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="italic">u</mml:mi></mml:mrow><mml:mi mathvariant="italic">m</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> (and simply write <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> if <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>). Furthermore, the special symbol <monospace>N</monospace> stands for (<monospace>A|C|T|G</monospace>).</p>
      </statement>
      <statement id="mthst2">
        <label>Definition 2</label>
        <p>(Elastic-Degenerate string). An <italic toggle="yes">Elastic-Degenerate string (EDS)</italic> <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> over <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mo>Σ</mml:mo></mml:math></inline-formula> is a sequence of ED symbols, i.e. <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
      </statement>
      <statement id="mthst3">
        <label>Definition 3</label>
        <p>(Matching). A string <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> matches an EDS <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> if and only if there are <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> with <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (for <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>) such that <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
      </statement>
      <statement id="mthst4">
        <label>Definition 4</label>
        <p>(Occurrence). Let <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> be a pattern and <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be an EDS. Let <italic toggle="yes">p</italic> be a position in <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> belonging to the alternative <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (<inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>) and let <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> be the suffix of <italic toggle="yes">u</italic> starting at this position. We say <italic toggle="yes">P</italic> occurs at position <italic toggle="yes">p</italic> in <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, if <italic toggle="yes">P</italic> matches a prefix of <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
      </statement>
      <p>In our notation (resembling regular expressions), an ED string is a string over the alphabet <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mo>Σ</mml:mo><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mi mathvariant="monospace">N</mml:mi><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="monospace">|</mml:mi><mml:mo>,</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. For instance, <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo></mml:mrow></mml:math></inline-formula><monospace>NG(A|)CA(AT|TA)GA</monospace> is an EDS. Here, <monospace>(A|)</monospace> is an optional <monospace>A</monospace> and <monospace>(AT|TA)</monospace> is an ED symbol with the alternatives <monospace>AT</monospace> and <monospace>TA</monospace>. The length of <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> equals its length as ordinary string (here <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>17</mml:mn></mml:mrow></mml:math></inline-formula>). The strings <monospace>AGACATAGA</monospace> and <monospace>GGCAATGA</monospace> are matching <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and the patterns <monospace>GACA</monospace> and <monospace>GCAT</monospace> both occur at position 2 of <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, and <monospace>ATGA</monospace> occurs at position 10 of <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>.</p>
      <p>Note that our definition of occurrence is more specific than the standard definition in the literature (<xref rid="btad320-B10" ref-type="bibr">Iliopoulos et al. 2017</xref>). Usually, the position of an occurrence refers only to the index of the ED symbol. So, in the example <monospace>ATGA</monospace> would occur at position 4 because it starts in <monospace>(AT|TA)</monospace>, which is the fourth ED symbol. However, this does not provide any information about the position inside the alternative. The alternatives in an ED symbol can be very long in real-world data and therefore we want to be able to address bases inside an alternative. In our definition, the occurrence refers to the coordinate (see Section 2.3) of the first base of the pattern.</p>
      <p>We generate the EDS from a FASTA file containing a reference sequence and a VCF-file containing the variations. Similar to other tools, we ignore overlapping variants in the VCF-file. <xref rid="btad320-F1" ref-type="fig">Figure 1a and b</xref> shows the transition from a sequence and a list of variations to an EDS. The copy number variation is not represented in the EDS but in the EDS graph, which we will define next.</p>
      <fig position="float" id="btad320-F1">
        <label>Figure 1.</label>
        <caption>
          <p>The figure shows the transformation from (a) a linear reference and a list of variants to (b) an EDS, (c) an EDS graph, and (d) its linearized form. In (e) one can see the additional bit-vector <italic toggle="yes">I</italic>, which indicates whether or not a symbol originates from the linear reference.</p>
        </caption>
        <graphic xlink:href="btad320f1" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>2.2 Pangenome as EDS graph</title>
      <p>An EDS, as defined above, can represent simple genomic variations like SNPs and indels, but not complex or cyclic variations. We will represent variations that only affect one or a few bases like SNPs and small indels in the EDS syntax. To properly represent structural variations like copy number variations and large indels, we use a directed graph <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>Each node <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula> corresponds to an EDS <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we say <italic toggle="yes">v</italic> is <italic toggle="yes">labeled</italic> with the EDS <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The nodes and edges of <italic toggle="yes">G</italic> are formed by adding structural variations to the EDS <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. For example, if the substring <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> can appear multiple times, we split <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> into three nodes with the labels <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>|</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo>|</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. (Since we want the three new labels to be syntactically correct ED strings, the positions <italic toggle="yes">i</italic> and <italic toggle="yes">j</italic> cannot be inside parenthesized ED symbols.) We connect them by directed edges in the order of appearance and add a self-loop to the middle node. Such a graph is depicted in <xref rid="btad320-F1" ref-type="fig">Fig. 1c</xref>. We say a string <italic toggle="yes">S</italic> matches the EDS graph <italic toggle="yes">G</italic> if and only if there is a walk <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is a source node in <italic toggle="yes">G</italic>, <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is a sink node in <italic toggle="yes">G</italic>, and <italic toggle="yes">S</italic> matches the EDS <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>…</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Note that every EDS graph can easily be transformed into an equivalent sequence graph. In a sequence graph, the nodes are associated with ordinary strings or even single characters. (To construct the sequence graph from an EDS graph, one has to add a new node for each alternative in each degenerate symbol <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and connect this node to degenerate symbols before and after <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>.) The variation graph, the fundamental data structure of VG, is a sequence graph enhanced with additional information. However, the sequence graph requires more nodes and edges than our representation and therefore more memory.</p>
      <p>We store the node labels of an EDS graph <italic toggle="yes">G</italic> as a string <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> is the concatenation of all node labels, separated by a special separator symbol <monospace>#</monospace>. The node labels are concatenated in the order of their appearance in the linear reference, which enables us to easily transform the coordinates in <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> into coordinates in the linear reference (see Section 2.3). Suppose that separators in <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> are numbered consecutively, starting with 1. Let <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">sep</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be the number of the separator immediately before the EDS <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of node <italic toggle="yes">v</italic> of <italic toggle="yes">G</italic>, where <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">sep</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> if there is none. For an edge <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in <italic toggle="yes">G</italic>, we add an edge from <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">sep</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">sep</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. These edges are stored in an adjacency list. When reading the sequence <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> in forward direction (from left to right), these new edges, or jumps (<xref rid="btad320-B4" ref-type="bibr">Büchler and Ohlebusch 2020</xref>), are the connections between all possible adjacent bases. In <xref rid="btad320-F1" ref-type="fig">Fig. 1d</xref> for instance, when the separator at position 21 is encountered, the following bases are the ones behind positions 3 and 21. (Later we have to traverse the sequence in backward direction as well. Therefore, we additionally store the inverted adjacency list.) From now on, we identify an EDS graph with its representation <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and use the example in <xref rid="btad320-F1" ref-type="fig">Fig. 1</xref> for all our explanations.</p>
    </sec>
    <sec>
      <title>2.3 Coordinate system</title>
      <p>A <italic toggle="yes">coordinate system</italic> is a system that uses coordinates to uniquely address bases in the reference (pan)genome. In a linear reference the coordinate is just the offset. A base can, e.g. be addressed as chromosome 2 with offset 800 000. A <italic toggle="yes">sensible</italic> coordinate system should meet several requirements. It should be <italic toggle="yes">readable</italic>, <italic toggle="yes">monotone</italic>, and <italic toggle="yes">spatial</italic> (<xref rid="btad320-B21" ref-type="bibr">The Computational Pan-Genomics Consortium 2016</xref>, <xref rid="btad320-B17" ref-type="bibr">Rand et al. 2017</xref>). In other words, the coordinates should be concise and comprehensible, increase along the genome and nearby bases should have similar coordinates.</p>
      <p>Since the EDS graph is stored as a string <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> (plus adjacency lists), it naturally provides a concise coordinate system: the coordinate of a base is its position in the string. This coordinate system meets the aforementioned criteria. The coordinate of a base in <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> is its offset from the start of <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. In the absence of variants, it coincides with the coordinate in the linear reference.</p>
      <p>On monotonicity: Let <italic toggle="yes">S</italic> be a string of length <italic toggle="yes">n</italic> that matches <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> without cycles and further let <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be the coordinate of base <italic toggle="yes">S</italic>[<italic toggle="yes">i</italic>] in <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, for <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>. Then it is true that <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, for <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, and hence the coordinates are monotone. For example, <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo></mml:mrow></mml:math></inline-formula><monospace>TTAGACATAGAT</monospace> matches the graph <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> in <xref rid="btad320-F1" ref-type="fig">Fig. 1d</xref> and the sequence of the coordinates <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>7</mml:mn><mml:mo>,</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mn>11</mml:mn><mml:mo>,</mml:mo><mml:mn>16</mml:mn><mml:mo>,</mml:mo><mml:mn>17</mml:mn><mml:mo>,</mml:mo><mml:mn>19</mml:mn><mml:mo>,</mml:mo><mml:mn>20</mml:mn><mml:mo>,</mml:mo><mml:mn>22</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. As one can see, this sequence is monotone. If <italic toggle="yes">S</italic> matches <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> with cycles, the coordinates cannot per se be monotone.</p>
      <p>On spatiality: When there are no variants between two coordinates, the difference between the coordinates is the distance between bases. When there are variants of total length <italic toggle="yes">x</italic> between two coordinates, the difference between the coordinates is roughly the distance between the corresponding bases plus <italic toggle="yes">x</italic>. If there are mostly short variations in the EDS, <italic toggle="yes">x</italic> tends to be small.</p>
      <p>Since the coordinates in the linear reference may still play an important role, we show how to transform a coordinate in <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> to a coordinate in the linear reference. This transformation uses an additional bit-vector <italic toggle="yes">I</italic> and rank queries on <italic toggle="yes">I</italic>. After a linear preprocessing and with the help of an additional data structure, the rank value can be calculated in constant time (<xref rid="btad320-B11" ref-type="bibr">Jacobson 1989</xref>). The bit-vector <italic toggle="yes">I</italic> indicates whether the symbol at position <italic toggle="yes">i</italic> in <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> originated from the linear reference sequence or not. If not, the symbol is a syntax symbol or part of an alternative sequence. If a base <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> originates from the linear reference, then its position in the linear reference is <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:mtext>rank</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:mtext>rank</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the number of ones in the vector <italic toggle="yes">I</italic> up to position <italic toggle="yes">p</italic>. In <xref rid="btad320-F1" ref-type="fig">Fig. 1e</xref>, the vector <italic toggle="yes">I</italic> has ones at the positions of the bases <monospace>AT</monospace> in the second variant, because <monospace>AT</monospace> stems from the linear reference, whereas <italic toggle="yes">I</italic> has zeros at the positions of <monospace>TA</monospace>. The base <monospace>G</monospace> right behind the last bracket corresponds to the tenth one-bit in <italic toggle="yes">I</italic> and therefore originates from the <monospace>G</monospace> at the tenth position in the linear reference.</p>
    </sec>
    <sec>
      <title>2.4 Minimizer index</title>
      <p>A string over <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mo>Σ</mml:mo></mml:math></inline-formula> of length <italic toggle="yes">k</italic> occurring in the pangenome (here EDS graph <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>) is called <italic toggle="yes">k-mer</italic>, and a <italic toggle="yes">k-mer index</italic> provides efficient access to the positions of all occurrences for each k-mer. In order to map a read to the pangenome, one can use a k-mer index to efficiently determine the positions of exactly matching k-mers, which subsequently can be used to find alignments.</p>
      <p>Without the usage of minimizers, a k-mer index for the whole human genome requires tens of gigabytes of memory and actually contains more information than we need for the task of short read mapping. To reduce the amount of storage we use a <italic toggle="yes">minimizer index</italic> (<xref rid="btad320-B18" ref-type="bibr">Roberts et al. 2004</xref>) instead. A <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">-minimizer</italic> is the smallest among all k-mers starting in a window of size <italic toggle="yes">w</italic> in <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. As in <xref rid="btad320-B13" ref-type="bibr">Li (2016)</xref>, we apply a hash function to the lexicographic rank of a k-mer and choose the k-mer with the smallest hash value as a minimizer. However, to keep the examples simple, we will use the smallest k-mer w.r.t. the lexicographic ordering as a minimizer in this article.</p>
      <p>For example, we determine all (4,3)-minimizers of our example graph <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mi mathvariant="monospace">TT</mml:mi><mml:mo>#</mml:mo><mml:mi mathvariant="monospace">NG</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="monospace">A|</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="monospace">CA</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="monospace">AT|TA</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="monospace">GA</mml:mi><mml:mo>#</mml:mo><mml:mi mathvariant="monospace">T</mml:mi></mml:mrow></mml:math></inline-formula> (see <xref rid="btad320-F1" ref-type="fig">Fig. 1</xref>). The first (leftmost) window includes all 3-mers occurring at positions in the interval [1, 4]. The 3-mers occurring at position 1 are <monospace>TTA</monospace>, <monospace>TTC</monospace>, <monospace>TTG</monospace>, and <monospace>TTT</monospace>, at position 2 <monospace>TAG</monospace>, <monospace>TCG</monospace>, <monospace>TGG</monospace>, and <monospace>TTG</monospace>, and at position 4 <monospace>AGA</monospace>, <monospace>CGA</monospace>, <monospace>GGA</monospace>, <monospace>TGA</monospace>, <monospace>AGC</monospace>, <monospace>CGC</monospace>, <monospace>GGC</monospace>, and <monospace>TGC</monospace>. (In accordance with Def. 4, no k-mer occurs at a position with a syntax symbol.) The lexicographically smallest among all these 3-mers is <monospace>AGA</monospace> occurring at position 4, hence it is stored in the minimizer index. The same 3-mer is also the smallest one in the windows (intervals) [2, 5] and [3, 6]. In the interval [4, 7], the 3-mer <monospace>ACA</monospace> at position 7 is the smallest, thus it is stored in the minimizer index. The remaining minimizers are: <monospace>ATG</monospace> at position 13, <monospace>AGA</monospace> at position 17, and <monospace>AAG</monospace> at position 20. <xref rid="btad320-F2" ref-type="fig">Figure 2</xref> shows all (4,3)-minimizers of <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and a table that maps the minimizers to their positions. This table represents the minimizer index. The layout of our minimizer index used in our implementation is discussed in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>.</p>
      <fig position="float" id="btad320-F2">
        <label>Figure 2.</label>
        <caption>
          <p>(4,3)-Minimizers of <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and the index that maps the minimizers to their positions.</p>
        </caption>
        <graphic xlink:href="btad320f2" position="float"/>
      </fig>
      <p><italic toggle="yes">Construction of the minimizer index</italic>: In contrast to standard strings, there can be multiple k-mers occurring at a position in an EDS graph <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. To compute the minimizers, we first compute the set of k-mers occurring at each position and for each position determine the smallest k-mer. Then we slide a window over these k-mers (which are sorted by their position) and iteratively mark the smallest k-mer per window. The k-mer index is then constructed from the marked k-mers.</p>
      <p>In the following, we explain how to efficiently determine the set of k-mers occurring at each position. First, we ignore the graph structure and consider an arbitrary EDS <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. The set of k-mers occurring at a position <italic toggle="yes">p</italic> could be calculated by reading all possible paths in forward direction starting at <italic toggle="yes">p</italic>. A better approach is scanning <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> from right to left once and deducing the set of k-mers <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> occurring at position <italic toggle="yes">p</italic> from <inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. The variations are accounted for with the help of two special sets <inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. <xref rid="btad320-T1" ref-type="table">Table 1</xref> depicts the example used in the following. In the simple case where <inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>∈</mml:mo><mml:mo>Σ</mml:mo></mml:mrow></mml:math></inline-formula>, the set <inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is obtained by prepending <inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> to each k-mer in <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and deleting the last character of each resulting string. In the example <monospace>CAA</monospace><inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> because <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="monospace">C</mml:mi></mml:mrow></mml:math></inline-formula> and <monospace>AAT</monospace><inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
      <table-wrap position="float" id="btad320-T1">
        <label>Table 1.</label>
        <caption>
          <p>Contents of the sets <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> while iterating over the EDS <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mi mathvariant="monospace">CA</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="monospace">AT|TA</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="monospace">GA</mml:mi></mml:mrow></mml:math></inline-formula> with <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula>.<xref rid="tblfn1" ref-type="table-fn"><sup>a</sup></xref></p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
          </colgroup>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">
                <inline-graphic xlink:href="btad320ilf1.jpg"/>
              </td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <label>a</label>
            <p>Only at positions with syntax symbols (here at <inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>6</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> and 9) the sets <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are used.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>If <inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>∈</mml:mo><mml:mo>Σ</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="monospace">|</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is the last character in an alternative. By definition of an EDS, <inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> can be obtained in the same way from <inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, where <italic toggle="yes">r</italic> is the right boundary of the current ED symbol. In our example <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>5</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>8</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> are obtained from <inline-formula id="IE124"><mml:math id="IM124" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. Because we do not store the entire table, we set <inline-formula id="IE125"><mml:math id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> when we see the bracket “<monospace>)</monospace>” at position 9. Then we (implicitly) set <inline-formula id="IE126"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>6</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE127"><mml:math id="IM127" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>9</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE128"><mml:math id="IM128" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Now <inline-formula id="IE129"><mml:math id="IM129" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>5</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE130"><mml:math id="IM130" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>8</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> can be calculated as in the simple case above. At the left boundary <italic toggle="yes">l</italic> of an ED symbol, <inline-formula id="IE131"><mml:math id="IM131" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the union of all k-mer sets of the alternatives. This union is calculated step by step. Whenever we reach the end of an alternative, we add the elements of <inline-formula id="IE132"><mml:math id="IM132" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE133"><mml:math id="IM133" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (see line <inline-formula id="IE134"><mml:math id="IM134" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:math></inline-formula> in the example). At the end of the last alternative, we add the elements of <inline-formula id="IE135"><mml:math id="IM135" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE136"><mml:math id="IM136" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. This happens in line <inline-formula id="IE137"><mml:math id="IM137" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> in the example.</p>
      <p>Because we determine the minimum k-mer by a hash value and not its lexicographic rank, the minimum k-mer in <inline-formula id="IE138"><mml:math id="IM138" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> cannot be obtained from the minimum k-mer of <inline-formula id="IE139"><mml:math id="IM139" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. Furthermore, we treat the character <monospace>N</monospace> in a special way. While calculating the sets, we allow <monospace>N</monospace> in the k-mers (hence <inline-formula id="IE140"><mml:math id="IM140" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE141"><mml:math id="IM141" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE142"><mml:math id="IM142" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are actually containing strings over the alphabet <inline-formula id="IE143"><mml:math id="IM143" display="inline" overflow="scroll"><mml:mrow><mml:mo>Σ</mml:mo><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mi mathvariant="monospace">N</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>). When calculating the minimum of a set, we replace every <monospace>N</monospace> with each character in <inline-formula id="IE144"><mml:math id="IM144" display="inline" overflow="scroll"><mml:mo>Σ</mml:mo></mml:math></inline-formula> and then calculate the hash value. We consider substrings that contain many <monospace>N</monospace> as not helpful and therefore ignore them.</p>
      <p>To compute the minimizer index of an EDS graph <inline-formula id="IE145"><mml:math id="IM145" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, we first determine the minimum k-mer for each position in <inline-formula id="IE146"><mml:math id="IM146" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. Let <italic toggle="yes">v</italic> be such a node and let <inline-formula id="IE147"><mml:math id="IM147" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be its label. Remember that <inline-formula id="IE148"><mml:math id="IM148" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is an EDS. The only k-mers that are not considered to be minimizers are those that span over an edge in <inline-formula id="IE149"><mml:math id="IM149" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. For each node <inline-formula id="IE150"><mml:math id="IM150" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, let <inline-formula id="IE151"><mml:math id="IM151" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> be the set of k-mers starting at the first position in <inline-formula id="IE152"><mml:math id="IM152" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. For a node <italic toggle="yes">v</italic> we define <inline-formula id="IE153"><mml:math id="IM153" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mo>∪</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mi>K</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, i.e. the set of k-mers starting behind <inline-formula id="IE154"><mml:math id="IM154" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as the union of all sets of k-mers starting at a successor of <italic toggle="yes">v</italic>. Then we proceed as in the algorithm above, starting at position <inline-formula id="IE155"><mml:math id="IM155" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> in <italic toggle="yes">v</italic>. (When <italic toggle="yes">k</italic> characters have been added to all k-mers in <inline-formula id="IE156"><mml:math id="IM156" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, we can halt since from then on, the k-mers do not span over an edge and therefore were already calculated before.)</p>
      <p>There can be minimizers that occur at an extraordinarily large number of positions. These positions are not very helpful in the mapping algorithm. Moreover, considering all of them will significantly slow down the mapping process. To cope with this problem, we trim the index by removing all minimizers from the index that occur at more positions than a given threshold. An evaluation on how this trimming affects the index size and the mapping can be found in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>.</p>
    </sec>
    <sec>
      <title>2.5 Short read mapping</title>
      <p>A read is a DNA sequence generated by a sequencer. Today’s most common sequencers are still using next-generation sequencing technologies and produce short reads with a length of up to a few hundred base pairs. Roughly speaking, read mapping is the task of finding the locus of such a read in the genome. A read may contain errors and variants that are not present in the reference pangenome, i.e. it may not match the reference exactly. Thus, one is interested in an optimal semi-global alignment between the read and the reference (i.e. the read is aligned with a substring of the reference). We solve this task by calculating the minimizers of a read, looking up their positions in the minimizer index, ranking the positions, and calculating a semi-global alignment of the read with the reference at the best-ranked positions. This process will be described in more detail below.</p>
      <sec>
        <title>2.5.1 Seed determination</title>
        <p>Given a read <italic toggle="yes">r</italic>, we determine its minimizers and query their positions in <inline-formula id="IE157"><mml:math id="IM157" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> from the minimizer index. This results in a sequence of pairs of positions in <inline-formula id="IE158"><mml:math id="IM158" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and positions in <italic toggle="yes">r</italic>. We then rank the pairs of this sequence and later use the top ranked pairs as seeds in the alignment procedure. Our ranking will prefer minimizers that occur close to other minimizers in <inline-formula id="IE159"><mml:math id="IM159" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and is described in more detail below.</p>
        <p>The idea of combining several exact matches (and a matching minimizer is an exact match) was first used as “two-hit” method in gapped BLAST (<xref rid="btad320-B2" ref-type="bibr">Altschul et al. 1997</xref>). Therein, “two-hit” refers to two k-mers on the same diagonal, i.e. two k-mers with the same difference between their position in the read and their position in the string. Because alternatives can have different lengths, we cannot directly apply this. Our method is more similar to the chaining used by MUMmer (<xref rid="btad320-B6" ref-type="bibr">Delcher et al. 1999</xref>).</p>
        <p>Roughly speaking, we search for multiple minimizers of <italic toggle="yes">r</italic> that occur close to each other in <inline-formula id="IE160"><mml:math id="IM160" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. This is achieved by sorting the pairs by the corresponding position in <inline-formula id="IE161"><mml:math id="IM161" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and then scanning the sorted list. Since the positions for one minimizer are already stored in a sorted list in the minimizer index, we can obtain a sorted list of the occurrences of all minimizers by iteratively merging sorted lists. Consider, e.g. the mapping of the read <inline-formula id="IE162"><mml:math id="IM162" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="monospace">TTAGAATCGA</mml:mi></mml:mrow></mml:math></inline-formula> to the EDS graph <inline-formula id="IE163"><mml:math id="IM163" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> from <xref rid="btad320-F1" ref-type="fig">Fig. 1</xref>. The (4,3)-minimizers of <italic toggle="yes">r</italic> are <monospace>AGA</monospace> occurring at position 3, <monospace>AAT</monospace> at position 5, <monospace>ATC</monospace> at position 6, and <monospace>CGA</monospace> at position 9. The positions of these minimizers in <inline-formula id="IE164"><mml:math id="IM164" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> can be queried in the index (see <xref rid="btad320-F2" ref-type="fig">Fig. 2</xref>). These positions are 4 and 17 for <monospace>AGA</monospace>, 11 for <monospace>AAT</monospace>, and no positions for <monospace>ATC</monospace> and <monospace>CGA</monospace>. So, we get the position pairs <inline-formula id="IE165"><mml:math id="IM165" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>17</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE166"><mml:math id="IM166" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>11</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>To rank the pairs, we define the term <italic toggle="yes">colinear</italic>. Two pairs <inline-formula id="IE167"><mml:math id="IM167" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE168"><mml:math id="IM168" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are colinear if and only if <inline-formula id="IE169"><mml:math id="IM169" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE170"><mml:math id="IM170" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>. We denote this by <inline-formula id="IE171"><mml:math id="IM171" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mrow><mml:mo>&lt;</mml:mo></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. A colinear chain of length <inline-formula id="IE172"><mml:math id="IM172" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula> is a sequence of pairs <inline-formula id="IE173"><mml:math id="IM173" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with <inline-formula id="IE174"><mml:math id="IM174" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mi>q</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mi>q</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mrow><mml:mo>&lt;</mml:mo></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>q</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>q</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE175"><mml:math id="IM175" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>q</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>ℓ</mml:mi></mml:mrow></mml:math></inline-formula>. The score of a pair <inline-formula id="IE176"><mml:math id="IM176" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the length of a maximum colinear chain ending at <inline-formula id="IE177"><mml:math id="IM177" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. In our example above, <inline-formula id="IE178"><mml:math id="IM178" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE179"><mml:math id="IM179" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>17</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> have score 1 and <inline-formula id="IE180"><mml:math id="IM180" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>11</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> has score 2, since <inline-formula id="IE181"><mml:math id="IM181" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mrow><mml:mo>&lt;</mml:mo></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>11</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Hence, <inline-formula id="IE182"><mml:math id="IM182" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>11</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> will be used as seed for the alignment algorithm. If this seed does not yield a satisfying alignment, we will try seeds with lower scores.</p>
        <p>We additionally ensure that all positions in <inline-formula id="IE183"><mml:math id="IM183" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> in such a chain are in a certain range, i.e. <inline-formula id="IE184"><mml:math id="IM184" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mi>ℓ</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>&lt;</mml:mo><mml:mo>λ</mml:mo></mml:mrow></mml:math></inline-formula> for a parameter <inline-formula id="IE185"><mml:math id="IM185" display="inline" overflow="scroll"><mml:mo>λ</mml:mo></mml:math></inline-formula>. It is obvious that the positions in the read <italic toggle="yes">r</italic> are in a range of size <inline-formula id="IE186"><mml:math id="IM186" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>r</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, because they are all <inline-formula id="IE187"><mml:math id="IM187" display="inline" overflow="scroll"><mml:mrow><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mi>r</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. We choose <inline-formula id="IE188"><mml:math id="IM188" display="inline" overflow="scroll"><mml:mo>λ</mml:mo></mml:math></inline-formula> to be greater than <inline-formula id="IE189"><mml:math id="IM189" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>r</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, but in the same order of magnitude (e.g. <inline-formula id="IE190"><mml:math id="IM190" display="inline" overflow="scroll"><mml:mrow><mml:mo>λ</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>|</mml:mo><mml:mi>r</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>). This ensures that only minimizers that are close together in the genome will be chained.</p>
        <p>Let the sorted list of pairs <inline-formula id="IE191"><mml:math id="IM191" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, with <inline-formula id="IE192"><mml:math id="IM192" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mi>ℓ</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE193"><mml:math id="IM193" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>, be given. For each <inline-formula id="IE194"><mml:math id="IM194" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula> we consider the largest <inline-formula id="IE195"><mml:math id="IM195" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo>≤</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula> with <inline-formula id="IE196"><mml:math id="IM196" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mi>ℓ</mml:mi></mml:msub><mml:mo>&lt;</mml:mo><mml:mo>λ</mml:mo></mml:mrow></mml:math></inline-formula>. The problem of calculating the scores of the pairs <inline-formula id="IE197"><mml:math id="IM197" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mi>ℓ</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mi>ℓ</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> then relates to the problem of finding a longest increasing subsequences and hence can be calculated in <inline-formula id="IE198"><mml:math id="IM198" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time, where <inline-formula id="IE199"><mml:math id="IM199" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo>−</mml:mo><mml:mi>ℓ</mml:mi></mml:mrow></mml:math></inline-formula> (<xref rid="btad320-B7" ref-type="bibr">Fredman 1975</xref>).</p>
      </sec>
      <sec>
        <title>2.5.2 Aligning</title>
        <p>After a seed <inline-formula id="IE200"><mml:math id="IM200" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> has been determined, we compute a semi-global alignment of the read and the EDS graph <inline-formula id="IE201"><mml:math id="IM201" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. The alignment is based on affine gap costs (the edit distance can be used as a special case of affine gap costs as well). To keep the presentation simple, we show how an alignment that minimizes the edit distance can be calculated. Semi-global alignment means that the whole read <italic toggle="yes">r</italic> is aligned with a substring of <inline-formula id="IE202"><mml:math id="IM202" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, enforcing that <inline-formula id="IE203"><mml:math id="IM203" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is aligned with <inline-formula id="IE204"><mml:math id="IM204" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. First, we explain the alignment w.r.t. an EDS <inline-formula id="IE205"><mml:math id="IM205" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. More specifically, we determine the smallest edit distance between <italic toggle="yes">r</italic> and <inline-formula id="IE206"><mml:math id="IM206" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> among all <italic toggle="yes">lo</italic> and <italic toggle="yes">hi</italic> with <inline-formula id="IE207"><mml:math id="IM207" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mo>≤</mml:mo><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>≤</mml:mo><mml:mi>h</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> under the assumption that in an optimal alignment <inline-formula id="IE208"><mml:math id="IM208" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is aligned with <inline-formula id="IE209"><mml:math id="IM209" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> (or determine that the edit distance must be greater than some parameter <italic toggle="yes">d</italic>).</p>
        <p>This is done using a variant of the well-known dynamic programming algorithm for the edit distance. Note that we can independently align <inline-formula id="IE210"><mml:math id="IM210" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE211"><mml:math id="IM211" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> with <inline-formula id="IE212"><mml:math id="IM212" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE213"><mml:math id="IM213" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mo>|</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo>|</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, respectively. Hence, we only describe the alignment starting from <inline-formula id="IE214"><mml:math id="IM214" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in forward direction; the backward direction works analogously and the combination of both gives the complete alignment. Furthermore, we impose an upper bound <italic toggle="yes">d</italic> on the error and stop if it becomes apparent that the edit distance must be larger than <italic toggle="yes">d</italic>. Note that an edit distance of <inline-formula id="IE215"><mml:math id="IM215" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo>≤</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula> in forward direction imposes an upper bound of <inline-formula id="IE216"><mml:math id="IM216" display="inline" overflow="scroll"><mml:mrow><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> onto the backwards alignment.</p>
        <p>Let <inline-formula id="IE217"><mml:math id="IM217" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> be the edit distance between <inline-formula id="IE218"><mml:math id="IM218" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE219"><mml:math id="IM219" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. The minimum number of errors in a semi-global alignment is then <inline-formula id="IE220"><mml:math id="IM220" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>≥</mml:mo><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. The optimal alignment itself can be found by tracing the optimal solution back through <italic toggle="yes">D</italic>.</p>
        <p><xref rid="btad320-T2" ref-type="table">Table 2</xref> shows the recurrence relations adapted to EDS and <xref rid="btad320-T3" ref-type="table">Table 3</xref> gives an example of the dynamic programming table <italic toggle="yes">D</italic>. The example is showing the alignment in forward direction of <italic toggle="yes">r</italic> with <inline-formula id="IE221"><mml:math id="IM221" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, using seed <inline-formula id="IE222"><mml:math id="IM222" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>11</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The definition in <xref rid="btad320-T2" ref-type="table">Table 2</xref> includes the standard definition (1a–1d) and cases to cope with alternatives (2–4). In the table <italic toggle="yes">D</italic>, if a column <italic toggle="yes">j</italic> belongs to the ED symbol <inline-formula id="IE223"><mml:math id="IM223" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE224"><mml:math id="IM224" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo></mml:mrow></mml:math></inline-formula><monospace>(,|</monospace><inline-formula id="IE225"><mml:math id="IM225" display="inline" overflow="scroll"><mml:mo>}</mml:mo></mml:math></inline-formula>, then column <italic toggle="yes">j</italic> is defined to be a copy of the column immediately preceding <inline-formula id="IE226"><mml:math id="IM226" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, see cases (2) and (3). If <inline-formula id="IE227"><mml:math id="IM227" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo></mml:mrow></mml:math></inline-formula> “<monospace>)</monospace>”, then <italic toggle="yes">j</italic> is the end of an ED symbol <inline-formula id="IE228"><mml:math id="IM228" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. In this case, the preceding columns of column <inline-formula id="IE229"><mml:math id="IM229" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> are all columns <inline-formula id="IE230"><mml:math id="IM230" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> that represent the end of an alternative <inline-formula id="IE231"><mml:math id="IM231" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math></inline-formula>. Since we define an entry <inline-formula id="IE232"><mml:math id="IM232" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> in column <italic toggle="yes">j</italic> as the minimum of the entries <inline-formula id="IE233"><mml:math id="IM233" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> of all columns <inline-formula id="IE234"><mml:math id="IM234" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> that precede column <inline-formula id="IE235"><mml:math id="IM235" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> (4), column <inline-formula id="IE236"><mml:math id="IM236" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> can be calculated from column <italic toggle="yes">j</italic>. Instead of searching for the values of <inline-formula id="IE237"><mml:math id="IM237" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE238"><mml:math id="IM238" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> in cases 3 and 4, we can cache these values whenever case 2 or 3 occurs and empty the cache in case 4.</p>
        <table-wrap position="float" id="btad320-T2">
          <label>Table 2.</label>
          <caption>
            <p>Inductive definition of <italic toggle="yes">D</italic>.<xref rid="tblfn2" ref-type="table-fn"><sup>a</sup></xref></p>
          </caption>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col valign="top" align="left" span="1"/>
            </colgroup>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">
                  <inline-graphic xlink:href="btad320ilf2.jpg"/>
                </td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <fn id="tblfn2">
              <label>a</label>
              <p>The cases are: match (1a), mismatch (1b), insertion (1c), deletion (1d); start of an ED symbol (2); start of another alternative (3); end of an ED symbol (4).</p>
            </fn>
          </table-wrap-foot>
        </table-wrap>
        <table-wrap position="float" id="btad320-T3">
          <label>Table 3.</label>
          <caption>
            <p>Alignment table <italic toggle="yes">D</italic> for <inline-formula id="IE239"><mml:math id="IM239" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>11</mml:mn><mml:mo>,</mml:mo><mml:mn>22</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo></mml:mrow></mml:math></inline-formula><monospace>A(AT|TA)GA#T</monospace>, <inline-formula id="IE240"><mml:math id="IM240" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>10</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo></mml:mrow></mml:math></inline-formula><monospace>AATCGA</monospace>, and maximum distance 3.<xref rid="tblfn3" ref-type="table-fn"><sup>a</sup></xref></p>
          </caption>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col valign="top" align="left" span="1"/>
            </colgroup>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">
                  <inline-graphic xlink:href="btad320ilf3.jpg"/>
                </td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <fn id="tblfn3">
              <label>a</label>
              <p>Arrows beneath the table illustrate the special cases (2–4). Bold red numbers indicate the path of the best alignment. Crossed out blue numbers will not be calculated, since a complete alignment with better or equal distance was already observed. The alignment itself is shown below the alignment table.</p>
            </fn>
          </table-wrap-foot>
        </table-wrap>
        <p>We calculate the table column-wise and for each column <italic toggle="yes">j</italic> we only calculate the rows <italic toggle="yes">i</italic> that can have values <inline-formula id="IE241"><mml:math id="IM241" display="inline" overflow="scroll"><mml:mrow><mml:mo>≤</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula> and less than the distance of the currently best semi-global alignment if one has been found already. For example, in column <inline-formula id="IE242"><mml:math id="IM242" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>14</mml:mn></mml:mrow></mml:math></inline-formula>, we detect a semi-global alignment with 3 errors. Hence, we can ignore all values greater than or equal to 3 in the following columns. They are blue in <xref rid="btad320-T3" ref-type="table">Table 3</xref> and will not be stored. Furthermore, in column 20 we detect a semi-global alignment with one error. Since there is no smaller value in this column, we can stop because there is no better alignment.</p>
        <p>The alignment of <italic toggle="yes">r</italic>[1, 5] with <inline-formula id="IE243"><mml:math id="IM243" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> in backwards direction, which completes the example above, is given in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>. This alignment includes the insertion and spans over the node boundary “<monospace>#</monospace>” in the graph.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>3 Experiments</title>
    <p>To evaluate our software GED-MAP, we built an index of the human genome and its variants and tested the mapping of sampled and real reads. We compared our approach with VG-Giraffe (<xref rid="btad320-B8" ref-type="bibr">Garrison et al. 2018</xref>, <xref rid="btad320-B20" ref-type="bibr">Sirén et al. 2021</xref>) and HISAT2 (<xref rid="btad320-B12" ref-type="bibr">Kim et al. 2019</xref>). Additionally, we ran the same experiments with Minimap2 (<xref rid="btad320-B14" ref-type="bibr">Li 2018</xref>). Minimap2 works on a linear reference and does not include variations. Its index stores the minimizers of the reference sequence (similar to our approach).</p>
    <p>Time and space consumption was measured externally with the terminal program “time.” Time refers to wall clock and space to the maximum resident set size. The server used to perform the experiments runs Ubuntu 20.04 (64 bit) with an AMD EPYC 7742 64-core processor, 256 GB RAM and 500 GB swap space on an SSD. For mapping, each program used 8 threads. Sources of our tool and scripts to replicate the experiments are available at <ext-link xlink:href="http://github.com/thomas-buechler-ulm/gedmap" ext-link-type="uri">github.com/thomas-buechler-ulm/gedmap</ext-link>. A short overview of the program calls and parameters can be found in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>.</p>
    <sec>
      <title>3.1 Data</title>
      <p>We used the GRCh37 reference and the variants of the 1000 Genomes Project (1000 <xref rid="btad320-B1" ref-type="bibr">Genomes Project Consortium 2015</xref>). This sequence consists of over 3 billion bases and includes over 84 million variants. Over 81 million variants are SNPs, about 3.3 million small indels and alternatives, and 44.9k are structural variants (42.6k copy number variations and 2.3k large indels). (There are less than 17k entries in the VCF file that describe insertions of mobile elements and inversions. These entries are currently neither supported by our software nor by the software we are comparing with.)</p>
      <p>We used two different sets of real reads. The first set (<ext-link xlink:href="http://ftp.sra.ebi.ac.uk/vol1/fastq/SRR769/SRR769545/SRR769545_2.fastq.gz" ext-link-type="uri">ftp.sra.ebi.ac.uk/vol1/fastq/SRR769/SRR769545/SRR769545_2.fastq.gz</ext-link>) contains over 30 million 100 bp reads of a British male and was published by the International Genome Sample Resource. The reads in the second set (<ext-link xlink:href="http://ftp-trace.ncbi.nih.gov/ReferenceSamples/giab/data/NA12878/Garvan_NA12878_HG001_HiSeq_Exome/NIST7035_TAAGGCGA_L001_R1_001.fastq.gz" ext-link-type="uri">ftp-trace.ncbi.nih.gov/ReferenceSamples/giab/data/NA12878/Garvan_NA12878_HG001_HiSeq_Exome/NIST7035_TAAGGCGA_L001_R1_001.fastq.gz</ext-link>) originate from the pilot genome NA12878 of the Genome in a Bottle project (<xref rid="btad320-B22" ref-type="bibr">Zook et al. 2016</xref>) and contains 20 million 100 bp reads. The sampled reads were generated as follows. First, take a substring of the pangenome at a position drawn uniformly at random. For loci with known variants, an alternative is selected uniformly at random. Then errors are added to this substring. An error may be a substitution, insertion or deletion of a base. The probability for each error is <inline-formula id="IE244"><mml:math id="IM244" display="inline" overflow="scroll"><mml:mrow><mml:mn>0.1</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> per base. We generated three test sets, each containing 100 million samples. The first and second set are containing 100 and 250 bp samples, respectively. To evaluate if reads containing structural variations can be mapped, the third set solely contains 150 bp samples that span over edges in the EDS graph <inline-formula id="IE245"><mml:math id="IM245" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>3.2 Index generation and comparison</title>
      <p>We use <inline-formula id="IE246"><mml:math id="IM246" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>20</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-minimizers for our index. When choosing values for <italic toggle="yes">w</italic> and <italic toggle="yes">k</italic>, there is a trade-off between mapping speed, index size, and accuracy. In general, larger values for <italic toggle="yes">k</italic> increase the mapping speed and index size. Larger values for <italic toggle="yes">w</italic> are also increasing the mapping speed but are decreasing the accuracy. An evaluation of the performance of the minimizer index for different values of <italic toggle="yes">w</italic> and <italic toggle="yes">k</italic> can be found in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>. Moreover, experimental results reported there show that in virtually all cases there are enough matching <inline-formula id="IE247"><mml:math id="IM247" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>20</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-minimizers between a read and an EDS to place the read correctly.</p>
      <p><xref rid="btad320-T4" ref-type="table">Table 4</xref> shows the resources required by the tools to build the whole human pangenome index. Among the pangenomic tools, GED-MAP is the fastest and most space-efficient in building its index. Since HISAT2 needed more than 250 GB RAM, it had to make use of the swap space on SSD. Clearly, this considerably slowed down the construction of the index.</p>
      <table-wrap position="float" id="btad320-T4">
        <label>Table 4.</label>
        <caption>
          <p>Comparison of the index sizes on disc and the resources needed to calculate the index.<xref rid="tblfn4" ref-type="table-fn"><sup>a</sup></xref></p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Program</th>
              <th rowspan="1" colspan="1">Time</th>
              <th rowspan="1" colspan="1">Memory usage (GB)</th>
              <th rowspan="1" colspan="1">Index size (GB)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">GED-MAP</td>
              <td rowspan="1" colspan="1">10 min</td>
              <td rowspan="1" colspan="1">58.5</td>
              <td rowspan="1" colspan="1">9.8</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">VG</td>
              <td rowspan="1" colspan="1">12 h</td>
              <td rowspan="1" colspan="1">203.3</td>
              <td rowspan="1" colspan="1">115.1</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">HISAT2</td>
              <td rowspan="1" colspan="1">37 h</td>
              <td rowspan="1" colspan="1">650.0</td>
              <td rowspan="1" colspan="1">16.1</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Minimap2</td>
              <td rowspan="1" colspan="1">1 min</td>
              <td rowspan="1" colspan="1">11.4</td>
              <td rowspan="1" colspan="1">8.5</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn4">
            <label>a</label>
            <p>The row “VG” refers to the generation of all indexes needed to run VG-Giraffe. HISAT2 first transforms the VCF file into its own format. The time for this transformation is not included.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>The index size is the space of all data needed for mapping. For GED-MAP this is 5.9 GB for the minimizer index and 3.9 GB for the EDS graph.</p>
    </sec>
    <sec>
      <title>3.3 Comparison of mapping speed and accuracy</title>
      <p>We mapped the reads to the pangenome and the linear reference, respectively, with the above-mentioned tools and evaluated the mapping rate, time, and space consumption.</p>
      <p>We ran VG Giraffe with default parameters. HISAT2 was used with preset “sensitive” to achieve a similar accuracy as the other graph-based tools. Minimap2 was used with the preset for short reads. The results of these experiments are shown in <xref rid="btad320-F3" ref-type="fig">Fig. 3</xref>. For all sets we show the mapping rate, i.e. the fraction of reads for which an alignment was generated. For the sets containing samples, we additionally depict the accuracy. We define an alignment reported by the mapping software as accurate, if its starting position equals (or is very close to) the position the sample was generated from.</p>
      <fig position="float" id="btad320-F3">
        <label>Figure 3.</label>
        <caption>
          <p>Evaluation of the accuracy, throughput, and space consumption of the mapping process. The upper chart is showing how many reads were aligned. For sampled reads, the proportion of correct alignments is additionally depicted (an alignment is correct if the sample was placed at the locus it was generated from). The percentages are rounded to one decimal place. The lower chart depicts the mapping speed in terms of number of reads per second and thread. All programs were run using eight threads. Please note the log scale of the lower plot. The observed space consumption is given in brackets below the chart.</p>
        </caption>
        <graphic xlink:href="btad320f3" position="float"/>
      </fig>
      <p>For the 100 bp samples, the graph-based tools achieve a mapping rate in range of 99.5–99.8% with an accuracy in range of 97.3–97.5%. Note that Minimap2 is not competitive in this case. All tools are more accurate in mapping the 250 bp samples. Note that GED-MAP has the best accuracy of 99%.</p>
      <p>Regarding the set of 150 bp samples representing structural variations, GED-MAP aligns 98.4% of the reads correctly. Since the other tools do not take copy number variations (CNVs) into account (recall that the included structural variations consist of 42.6k CNVs and 2.3k large indels), their mapping accuracy should be much lower in this case. Although CNVs are not included in the index of the other tools, their mapping accuracy is not as low as expected. This is because all tools apply clipping, i.e. only a partial alignment is computed (a substring of the read is mapped to a substring of the genome). Presumably, most of these partial alignments are part of the correct semi-global alignment. If the aligned part contains the front of the sequence, the reported position will be sufficiently close to the sampled position and counts as correct in our evaluation. (At the moment, GED-MAP does not use clipping.)</p>
      <p>In terms of mapping speed, the linear mapper Minimap2 is 2–6 times faster than the pangenomic tools. HISAT2 and GED-MAP are up to two times faster than VG Giraffe. Furthermore, one can observe that each tool needs more time to place longer samples. GED-MAP is the most space efficient tool—even more efficient than the linear mapper. VG needs an order of magnitude more memory than the other tools. In all our evaluations, we just looked at the primary alignments. This means that when a tool finds more than one alignment for a read, only the best one is taken into account. Therefore, a correctly found alignment could be overlooked if the tool scores another alignment higher.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>In this article, we proposed a new graph representation for a pangenome. We build our graph from a reference sequence and a VCF file. Most variations, like SNPs and small indels, are encoded in place using a syntax well known from regular expressions. To our knowledge, the generation of the nodes and edges for copy number variations, is a new approach in mapping software.</p>
    <p>The experiments show that the 150 bp samples representing structural variations can (partially) be mapped with the help of other techniques as well, but including these variations in the index improves the accuracy remarkably. The linearized form of our representation provides a natural and sensible coordinate system, which allows us to (a) use a minimizer index, (b) easily estimate distances, and (c) to cluster seed positions efficiently.</p>
    <p>As a proof of concept, we developed the prototypical short read mapping software GED-MAP. We tested our software on sampled and real reads and compared it to VG Giraffe, HISAT2, and Minimap2. In our experiments, all graph-based tools achieved a similar mapping rate and accuracy. HISAT2 was slightly faster than GED-MAP, but its index construction is very slow and requires a lot of memory. GED-MAP was the most memory efficient tool. All tools provide parameters to control the mapping speed and rate. (A higher throughput comes with a lower mapping rate.)</p>
    <p>Moreover, HISAT2 is merely able to incorporate variations that can be expressed by EDS. If one is interested in indexing structural variations, tools like VG-Giraffe and GED-MAP are recommended. The memory footage of GED-MAP is remarkably low compared to VG-Giraffe.</p>
    <p>Unsurprisingly the graph-based tools were clearly slower than the linear mapping tool Minimap2. Since the kind of index Minimap2 uses is very similar to the index used by GED-MAP, it might be possible to further improve GED-MAP by implementing heuristics that are used in Minimap2. We are planning to evaluate this in the future. Additionally, we are aiming to implement features like clipping, paired end mapping, etc.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad320_Supplementary_Data</label>
      <media xlink:href="btad320_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> is available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by the Deutsche Forschungsgemeinschaft (DFG) [OH 53/7-2].</p>
  </sec>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>The data underlying this article can be downloaded and generated using the instructions at <ext-link xlink:href="https://github.com/thomas-buechler-ulm/gedmap#data" ext-link-type="uri">https://github.com/thomas-buechler-ulm/gedmap#data</ext-link>.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad320-B1">
      <mixed-citation publication-type="journal"><collab>1000 Genomes Project Consortium</collab>. <article-title>A global reference for human genetic variation</article-title>. <source>Nature</source><year>2015</year>;<volume>526</volume>:<fpage>68</fpage>–<lpage>74</lpage>.<pub-id pub-id-type="pmid">26432245</pub-id></mixed-citation>
    </ref>
    <ref id="btad320-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Altschul</surname><given-names>SF</given-names></string-name>, <string-name><surname>Madden</surname><given-names>TL</given-names></string-name>, <string-name><surname>Schäffer</surname><given-names>AA</given-names></string-name></person-group><etal>et al</etal><article-title>Gapped BLAST and PSI-BLAST: a new generation of protein database search programs</article-title>. <source>Nucleic Acids Res</source><year>1997</year>;<volume>25</volume>:<fpage>3389</fpage>–<lpage>402</lpage>.<pub-id pub-id-type="pmid">9254694</pub-id></mixed-citation>
    </ref>
    <ref id="btad320-B3">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Aoyama</surname><given-names>K</given-names></string-name>, <string-name><surname>Nakashima</surname><given-names>Y</given-names></string-name>, <string-name><surname>Tomohiro</surname><given-names>I</given-names></string-name></person-group><etal>et al</etal> Faster online elastic degenerate string matching. In: <italic toggle="yes">29th Annual Symposium on Combinatorial Pattern Matching</italic>, volume 105 of <italic toggle="yes">LIPIcs</italic> Schloss Dagstuhl–Leibniz–Zentrum für Informatik, Dagstuhl, <year>2018</year>.</mixed-citation>
    </ref>
    <ref id="btad320-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Büchler</surname><given-names>T</given-names></string-name>, <string-name><surname>Ohlebusch</surname><given-names>E.</given-names></string-name></person-group><article-title>An improved encoding of genetic variation in a Burrows–Wheeler transform</article-title>. <source>Bioinformatics</source><year>2020</year>;<volume>36</volume>:<fpage>1413</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">31613311</pub-id></mixed-citation>
    </ref>
    <ref id="btad320-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cisłak</surname><given-names>A</given-names></string-name>, <string-name><surname>Grabowski</surname><given-names>S</given-names></string-name>, <string-name><surname>Holub</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>SOPanG: online text searching over a pan-genome</article-title>. <source>Bioinformatics</source><year>2018</year>;<volume>34</volume>:<fpage>4290</fpage>–<lpage>2</lpage>.<pub-id pub-id-type="pmid">29939210</pub-id></mixed-citation>
    </ref>
    <ref id="btad320-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Delcher</surname><given-names>AL</given-names></string-name>, <string-name><surname>Kasif</surname><given-names>S</given-names></string-name>, <string-name><surname>Fleischmann</surname><given-names>RD</given-names></string-name></person-group><etal>et al</etal><article-title>Alignment of whole genomes</article-title>. <source>Nucleic Acids Res</source><year>1999</year>;<volume>27</volume>:<fpage>2369</fpage>–<lpage>76</lpage>.<pub-id pub-id-type="pmid">10325427</pub-id></mixed-citation>
    </ref>
    <ref id="btad320-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Fredman</surname><given-names>ML.</given-names></string-name></person-group><article-title>On computing the length of longest increasing subsequences</article-title>. <source>Discret Math</source><year>1975</year>;<volume>11</volume>:<fpage>29</fpage>–<lpage>35</lpage>.</mixed-citation>
    </ref>
    <ref id="btad320-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Garrison</surname><given-names>E</given-names></string-name>, <string-name><surname>Sirén</surname><given-names>J</given-names></string-name>, <string-name><surname>Novak</surname><given-names>AM</given-names></string-name></person-group><etal>et al</etal><article-title>Variation graph toolkit improves read mapping by representing genetic variation in the reference</article-title>. <source>Nat Biotechnol</source><year>2018</year>;<volume>36</volume>:<fpage>875</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">30125266</pub-id></mixed-citation>
    </ref>
    <ref id="btad320-B9">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Grossi</surname><given-names>R</given-names></string-name>, <string-name><surname>Iliopoulos</surname><given-names>CS</given-names></string-name>, <string-name><surname>Liu</surname><given-names>C</given-names></string-name></person-group><etal>et al</etal> On-line pattern matching on similar texts. In: <italic toggle="yes">28th Annual Symposium on Combinatorial Pattern Matching</italic>, volume 78 of <italic toggle="yes">LIPIcs</italic> Schloss Dagstuhl–Leibniz–Zentrum für Informatik, Dagstuhl, <year>2017</year>.</mixed-citation>
    </ref>
    <ref id="btad320-B10">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Iliopoulos</surname><given-names>CS</given-names></string-name>, <string-name><surname>Kundu</surname><given-names>R</given-names></string-name>, <string-name><surname>Pissis</surname><given-names>SP</given-names></string-name></person-group>. Efficient pattern matching in elastic-degenerate texts. In: <italic toggle="yes">Language and Automata Theory and Applications</italic>, volume 10168 of <italic toggle="yes">LNCS</italic>, pp. <fpage>131</fpage>–<lpage>42</lpage>, Springer, Cham, <year>2017</year>.</mixed-citation>
    </ref>
    <ref id="btad320-B11">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Jacobson</surname><given-names>G.</given-names></string-name></person-group> Space-efficient static trees and graphs. In: <italic toggle="yes">30th Annual Symposium on Foundations of Computer Science</italic>. pp. <fpage>549</fpage>–<lpage>554</lpage>, IEEE, Research Triangle Park, <year>1989</year>.</mixed-citation>
    </ref>
    <ref id="btad320-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kim</surname><given-names>D</given-names></string-name>, <string-name><surname>Paggi</surname><given-names>JM</given-names></string-name>, <string-name><surname>Park</surname><given-names>C</given-names></string-name></person-group><etal>et al</etal><article-title>Graph-based genome alignment and genotyping with HISAT2 and HISAT-genotype</article-title>. <source>Nat Biotechnol</source><year>2019</year>;<volume>37</volume>:<fpage>907</fpage>–<lpage>15</lpage>.<pub-id pub-id-type="pmid">31375807</pub-id></mixed-citation>
    </ref>
    <ref id="btad320-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group><article-title>Minimap and miniasm: fast mapping and de novo assembly for noisy long sequences</article-title>. <source>Bioinformatics</source><year>2016</year>;<volume>32</volume>:<fpage>2103</fpage>–<lpage>10</lpage>.<pub-id pub-id-type="pmid">27153593</pub-id></mixed-citation>
    </ref>
    <ref id="btad320-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group><article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title>. <source>Bioinformatics</source><year>2018</year>;<volume>34</volume>:<fpage>3094</fpage>–<lpage>100</lpage>.<pub-id pub-id-type="pmid">29750242</pub-id></mixed-citation>
    </ref>
    <ref id="btad320-B15">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Maciuca</surname><given-names>S</given-names></string-name>, <string-name><surname>del Ojo Elias</surname><given-names>C</given-names></string-name>, <string-name><surname>McVean</surname><given-names>G</given-names></string-name></person-group><etal>et al</etal> A natural encoding of genetic variation in a Burrows–Wheeler transform to enable mapping and genome inference. In: <italic toggle="yes">Algorithms in Bioinformatics</italic>, volume 9838 of <italic toggle="yes">LNCS</italic>, pp. <fpage>222</fpage>–<lpage>33</lpage>. Springer, Cham, <year>2016</year>.</mixed-citation>
    </ref>
    <ref id="btad320-B16">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Procházka</surname><given-names>P</given-names></string-name>, <string-name><surname>Cvacho</surname><given-names>O</given-names></string-name>, <string-name><surname>Krčál</surname><given-names>L</given-names></string-name></person-group><etal>et al</etal> Backward pattern matching on elastic degenerate strings. In: <italic toggle="yes">Proceedings of the 14th International Joint Conference on Biomedical Engineering Systems and Technologies – BIOINFORMATICS</italic>. pp. <fpage>50</fpage>–<lpage>9</lpage>. SciTePress, <year>2021</year>. <ext-link xlink:href="https://www.scitepress.org/PublicationsDetail.aspx?ID=MI3JehMNpnI=&amp;t=1" ext-link-type="uri">https://www.scitepress.org/PublicationsDetail.aspx?ID=MI3JehMNpnI=&amp;t=1</ext-link>.</mixed-citation>
    </ref>
    <ref id="btad320-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rand</surname><given-names>KD</given-names></string-name>, <string-name><surname>Grytten</surname><given-names>I</given-names></string-name>, <string-name><surname>Nederbragt</surname><given-names>AJ</given-names></string-name></person-group><etal>et al</etal><article-title>Coordinates and intervals in graph-based reference genomes</article-title>. <source>BMC Bioinformatics</source><year>2017</year>;<volume>18</volume>:<fpage>263</fpage>.<pub-id pub-id-type="pmid">28521770</pub-id></mixed-citation>
    </ref>
    <ref id="btad320-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Roberts</surname><given-names>M</given-names></string-name>, <string-name><surname>Hayes</surname><given-names>W</given-names></string-name>, <string-name><surname>Hunt</surname><given-names>BR</given-names></string-name></person-group><etal>et al</etal><article-title>Reducing storage requirements for biological sequence comparison</article-title>. <source>Bioinformatics</source><year>2004</year>;<volume>20</volume>:<fpage>3363</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">15256412</pub-id></mixed-citation>
    </ref>
    <ref id="btad320-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sirén</surname><given-names>J</given-names></string-name>, <string-name><surname>Välimäki</surname><given-names>N</given-names></string-name>, <string-name><surname>Mäkinen</surname><given-names>V</given-names></string-name></person-group>. <article-title>Indexing graphs for path queries with applications in genome research</article-title>. <source>IEEE/ACM Trans Comput Biol Bioinf</source><year>2014</year>;<volume>11</volume>:<fpage>375</fpage>–<lpage>88</lpage>.</mixed-citation>
    </ref>
    <ref id="btad320-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sirén</surname><given-names>J</given-names></string-name>, <string-name><surname>Monlong</surname><given-names>J</given-names></string-name>, <string-name><surname>Chang</surname><given-names>X</given-names></string-name></person-group><etal>et al</etal><article-title>Pangenomics enables genotyping of known structural variants in 5202 diverse genomes</article-title>. <source>Science</source><year>2021</year>;<volume>374</volume>:<fpage>1461</fpage>.</mixed-citation>
    </ref>
    <ref id="btad320-B21">
      <mixed-citation publication-type="journal"><collab>The Computational Pan-Genomics Consortium</collab>. <article-title>Computational pan-genomics: status, promises and challenges</article-title>. <source>Brief Bioinf</source><year>2016</year>;<volume>19</volume>:<fpage>118</fpage>–<lpage>35</lpage>.</mixed-citation>
    </ref>
    <ref id="btad320-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zook</surname><given-names>JM</given-names></string-name>, <string-name><surname>Catoe</surname><given-names>D</given-names></string-name>, <string-name><surname>McDaniel</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>Extensive sequencing of seven human genomes to characterize benchmark reference materials</article-title>. <source>Sci Data</source><year>2016</year>;<volume>3</volume>:<fpage>160025</fpage>.<pub-id pub-id-type="pmid">27271295</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
