<?DTDIdentifier.IdentifierValue -//ES//DTD journal article DTD version 5.6.0//EN//XML?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName art560.dtd?>
<?SourceDTD.Version 5.6.0?>
<?ConverterInfo.XSLTName elsevier2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<?origin publisher?>
<?FILEmeta_ISCI107402 xml ?>
<?FILEmain xml ?>
<?FILEmain pdf ?>
<?FILEgr1 jpg ?>
<?FILEgr2 jpg ?>
<?FILEgr3 jpg ?>
<?FILEgr4 jpg ?>
<?FILEgr5 jpg ?>
<?FILEgr6 jpg ?>
<?FILEgr7 jpg ?>
<?FILEfx1 jpg ?>
<?FILEmmc1 pdf ?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">iScience</journal-id>
    <journal-id journal-id-type="iso-abbrev">iScience</journal-id>
    <journal-title-group>
      <journal-title>iScience</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2589-0042</issn>
    <publisher>
      <publisher-name>Elsevier</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10415921</article-id>
    <article-id pub-id-type="pii">S2589-0042(23)01479-7</article-id>
    <article-id pub-id-type="doi">10.1016/j.isci.2023.107402</article-id>
    <article-id pub-id-type="publisher-id">107402</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>WGT: Tools and algorithms for recognizing, visualizing, and generating Wheeler graphs</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" id="au1">
        <name>
          <surname>Chao</surname>
          <given-names>Kuan-Hao</given-names>
        </name>
        <email>kh.chao@cs.jhu.edu</email>
        <xref rid="aff1" ref-type="aff">1</xref>
        <xref rid="fn1" ref-type="fn">3</xref>
        <xref rid="cor1" ref-type="corresp">∗</xref>
      </contrib>
      <contrib contrib-type="author" id="au2">
        <name>
          <surname>Chen</surname>
          <given-names>Pei-Wei</given-names>
        </name>
        <xref rid="aff2" ref-type="aff">2</xref>
        <xref rid="fn1" ref-type="fn">3</xref>
      </contrib>
      <contrib contrib-type="author" id="au3">
        <name>
          <surname>Seshia</surname>
          <given-names>Sanjit A.</given-names>
        </name>
        <xref rid="aff2" ref-type="aff">2</xref>
      </contrib>
      <contrib contrib-type="author" id="au4">
        <name>
          <surname>Langmead</surname>
          <given-names>Ben</given-names>
        </name>
        <email>langmea@cs.jhu.edu</email>
        <xref rid="aff1" ref-type="aff">1</xref>
        <xref rid="fn2" ref-type="fn">4</xref>
        <xref rid="cor2" ref-type="corresp">∗∗</xref>
      </contrib>
      <aff id="aff1"><label>1</label>Department of Computer Science, Johns Hopkins University, Baltimore, MD 21218, USA</aff>
      <aff id="aff2"><label>2</label>Department of Electrical Engineering and Computer Sciences, University of California, Berkeley, Berkeley, CA 94720, USA</aff>
    </contrib-group>
    <author-notes>
      <corresp id="cor1"><label>∗</label>Corresponding author <email>kh.chao@cs.jhu.edu</email></corresp>
      <corresp id="cor2"><label>∗∗</label>Corresponding author <email>langmea@cs.jhu.edu</email></corresp>
      <fn id="fn1">
        <label>3</label>
        <p id="ntpara0010">These authors contributed equally</p>
      </fn>
      <fn id="fn2">
        <label>4</label>
        <p id="ntpara0015">Lead contact</p>
      </fn>
    </author-notes>
    <pub-date pub-type="pmc-release">
      <day>14</day>
      <month>7</month>
      <year>2023</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on <pub-date
						pub-type="epub">.-->
    <pub-date pub-type="collection">
      <day>18</day>
      <month>8</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>14</day>
      <month>7</month>
      <year>2023</year>
    </pub-date>
    <volume>26</volume>
    <issue>8</issue>
    <elocation-id>107402</elocation-id>
    <history>
      <date date-type="received">
        <day>29</day>
        <month>4</month>
        <year>2023</year>
      </date>
      <date date-type="rev-recd">
        <day>29</day>
        <month>6</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>12</day>
        <month>7</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2023 The Author(s)</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).</license-p>
      </license>
    </permissions>
    <abstract id="abs0010">
      <title>Summary</title>
      <p>A Wheeler graph represents a collection of strings in a way that is particularly easy to index and query. Such a graph is a practical choice for representing a graph-shaped pangenome, and it is the foundation for current graph-based pangenome indexes. However, there are no practical tools to visualize or to check graphs that may have the Wheeler properties. Here, we present Wheelie, an algorithm that combines a <italic>renaming heuristic</italic> with a permutation solver (Wheelie-PR) or a Satisfiability Modulo Theory (SMT) solver (Wheelie-SMT) to check whether a given graph has the Wheeler properties, a problem that is NP-complete in general. Wheelie can check a variety of random and real-world graphs in far less time than any algorithm proposed to date. It can check a graph with 1,000s of nodes in seconds. We implement these algorithms together with complementary visualization tools in the WGT toolkit, available as open source software at <ext-link ext-link-type="uri" xlink:href="https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit" id="intref0010">https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit</ext-link>.</p>
    </abstract>
    <abstract abstract-type="graphical" id="abs0015">
      <title>Graphical abstract</title>
      <fig id="undfig1" position="anchor">
        <graphic xlink:href="fx1"/>
      </fig>
    </abstract>
    <abstract abstract-type="author-highlights" id="abs0020">
      <title>Highlights</title>
      <p>
        <list list-type="simple" id="ulist0010">
          <list-item id="u0010">
            <label>•</label>
            <p id="p0010">Wheeler graphs are the basis of many pangenome and other sequence analysis tools</p>
          </list-item>
          <list-item id="u0015">
            <label>•</label>
            <p id="p0015">The WGT generates, recognizes, and visualizes Wheeler graphs</p>
          </list-item>
          <list-item id="u0020">
            <label>•</label>
            <p id="p0020">WGT’s Wheelie algorithm efficiently distinguishes Wheeler and non-Wheeler graphs</p>
          </list-item>
          <list-item id="u0025">
            <label>•</label>
            <p id="p0025">WGT’s bipartite Wheeler graph visualizer illustrates Wheeler graphs orderings</p>
          </list-item>
        </list>
      </p>
    </abstract>
    <abstract abstract-type="teaser" id="abs0025">
      <p>Bioinformatics; Algorithms; Data structure</p>
    </abstract>
    <kwd-group id="kwrds0010">
      <title>Subject areas</title>
      <kwd>Bioinformatics</kwd>
      <kwd>Algorithms</kwd>
      <kwd>Data structure</kwd>
    </kwd-group>
  </article-meta>
  <notes>
    <p id="misc9010">Published: July 14, 2023</p>
  </notes>
</front>
<body>
  <sec id="sec1">
    <title>Introduction</title>
    <p id="p0050">A Wheeler graph is a class of directed, edge-labeled graph that is particularly easy to index and query. It is a generalization of the Burrows-Wheeler-Transform (BWT)-based FM index,<xref rid="bib1" ref-type="bibr"><sup>1</sup></xref> and partly forms the basis for existing pangenome alignment tools such as vg.<xref rid="bib2" ref-type="bibr"><sup>2</sup></xref><sup>,</sup><xref rid="bib3" ref-type="bibr"><sup>3</sup></xref></p>
    <p id="p0055">A graph is a Wheeler graph when its nodes can be totally ordered according to the co-lexicographical order of the sets of strings spelled out on all paths leading into the nodes. Formally: an edge-labeled, directed graph is a Wheeler graph if and only if there exists a total ordering over its nodes such that 0-indegree nodes come before all other nodes in the ordering, and for all pairs of edges, <inline-formula><mml:math id="M1" altimg="si1.gif"><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M2" altimg="si2.gif"><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msup><mml:mi>u</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math></inline-formula> labeled <italic>a</italic> and <inline-formula><mml:math id="M3" altimg="si3.gif"><mml:mrow><mml:msup><mml:mi>a</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, respectively: (i) <inline-formula><mml:math id="M4" altimg="si4.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≺</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after" stretchy="true">→</mml:mo><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, and (ii) <inline-formula><mml:math id="M5" altimg="si5.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>∧</mml:mo><mml:mi>u</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:msup><mml:mi>u</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after" stretchy="true">→</mml:mo><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
    <p id="p0060">Many graph- and tree-shaped structures relevant to genomics either have the Wheeler graph properties or can be modified to have them. These include certain trees (via the XBWT),<xref rid="bib4" ref-type="bibr"><sup>4</sup></xref> De Bruijn graphs,<xref rid="bib5" ref-type="bibr"><sup>5</sup></xref> and reverse deterministic graphs derived from multiple alignments.<xref rid="bib6" ref-type="bibr"><sup>6</sup></xref> The discovery of this unified definition of Wheeler graphs will help researchers to develop still more BWT variants, e.g., for pangenome indexing. For instance, the GCSA study proposed building a reverse deterministic graph from a multiple alignment, then modifying the graph through a repeated path doubling procedure, ultimately yielding a Wheeler graph.<xref rid="bib6" ref-type="bibr"><sup>6</sup></xref> This approach can generate smaller graphs while preserving genome coordinates, compared to the more widely used De Bruijn graph, as demonstrated in <xref rid="mmc1" ref-type="supplementary-material">Figure S3</xref>.</p>
    <p id="p0065">Despite the utility of the the Wheeler graphs mentioned previously,<xref rid="bib2" ref-type="bibr"><sup>2</sup></xref><sup>,</sup><xref rid="bib6" ref-type="bibr"><sup>6</sup></xref><sup>,</sup><xref rid="bib7" ref-type="bibr"><sup>7</sup></xref><sup>,</sup><xref rid="bib8" ref-type="bibr"><sup>8</sup></xref> there are no tools or libraries that make it easy to use Wheeler graphs or to check if a particular graph has the requisite properties. This problem is NP-complete in general and hard to approximate.<xref rid="bib9" ref-type="bibr"><sup>9</sup></xref> An exponential-time algorithm was proposed by Gibney &amp; Thanckachan,<xref rid="bib9" ref-type="bibr"><sup>9</sup></xref> but no implementation is available.</p>
    <p id="p0070">We present Wheeler graph toolkit (WGT), an open source suite for generating, recognizing, and visualizing Wheeler graphs. WGT includes functionality for generating graphs that do or do not have the Wheeler properties. Two generators produce De Bruijn graphs and tries derived from one or more input sequences provided as FASTA. Another generator produces reverse deterministic graphs<xref rid="bib6" ref-type="bibr"><sup>6</sup></xref> from multiple sequence alignments. A fourth generator produces random graphs parameterized by the desired number of nodes, edges, distinct edge labels (i.e., alphabet size), and the most number of outgoing same-label edges.</p>
    <p id="p0075">Central to WGT is the fast Wheelie algorithm for Wheeler graph recognition. The algorithm combines a <italic>renaming heuristic</italic> with two alternate solvers, both capable of reaching exact solutions to the recognition problem. One solver uses an exhaustive search over possible node permutations, and the other uses a Satisfiability Modulo Theory (SMT) solver.<xref rid="bib10" ref-type="bibr"><sup>10</sup></xref> We call the overall algorithm “Wheelie”, while we use the names “Wheelie-Pr” and “Wheelie-SMT” for the versions that use the permutation and SMT solvers, respectively. When run on a Wheeler graph, Wheelie also reports a node ordering for which the properties are satisfied and indexes the graph into <italic>O</italic>, <italic>I</italic>, and <italic>L</italic> three bitarrays,<xref rid="bib11" ref-type="bibr"><sup>11</sup></xref> which are useful inputs to a downstream tool for pattern matching.</p>
    <p id="p0080">Here, we benchmark Wheelie’s solvers in comparison to each other and to the algorithm proposed by Gibney and Thankachan.<xref rid="bib9" ref-type="bibr"><sup>9</sup></xref> We benchmark with a variety of input graphs, including graphs derived from real multiple alignments of DNA and protein sequences. We also use randomly generated graphs with various configurable characteristics. Finally, we implement and demonstrate a visualizer that allows the user to picture the graph in light of the Wheeler properties.</p>
    <p id="p0085">In the following, <italic>G</italic> denotes a directed graph, <italic>N</italic> its set of nodes, and <italic>E</italic> its set of edges, with <inline-formula><mml:math id="M6" altimg="si6.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>N</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M7" altimg="si7.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. <inline-formula><mml:math id="M8" altimg="si8.gif"><mml:mrow><mml:mi mathvariant="normal">Σ</mml:mi></mml:mrow></mml:math></inline-formula> denotes the set of edge labels appearing on at least one edge, with <inline-formula><mml:math id="M9" altimg="si9.gif"><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="normal">Σ</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
  </sec>
  <sec id="sec2">
    <title>Results</title>
    <p id="p0090">Graphs used for evaluation were generated using WGT’s generator algorithms, which can produce (a) De Bruijn graphs, (b) tries, (c) a reverse deterministic graphs derived from a multiple alignments, (d) <italic>complete</italic> random Wheeler graphs, and (e) a <italic>d-NFA</italic> random Wheeler graphs. All are discussed further in <xref rid="sec4" ref-type="sec">STAR methods</xref> WGT’s graph generating algorithms, and in <xref rid="mmc1" ref-type="supplementary-material">Figures S1</xref> and <xref rid="mmc1" ref-type="supplementary-material">S2</xref>. For graphs that start from biological sequences, we randomly selected 25 genes and downloaded their DNA and protein ortholog alignments in FASTA format from the Ensembl Comparative Genomics REST API<xref rid="bib12" ref-type="bibr"><sup>12</sup></xref> at <ext-link ext-link-type="uri" xlink:href="https://rest.ensembl.org/documentation/info/genomic_alignment_region" id="intref0020">https://rest.ensembl.org/documentation/info/genomic_alignment_region</ext-link>. All the experiments are conducted on a 24-core, 48-thread Intel(R) Xeon(R) Gold 6248R Linux computer with 1024 GB memory, using a single thread of execution.</p>
    <sec id="sec2.1">
      <title>Comparing Wheelie with Gibney &amp; Thanckachan</title>
      <p id="p0095">Gibney and Thankachan’s recognition algorithm<xref rid="bib9" ref-type="bibr"><sup>9</sup></xref> (henceforth “G &amp; T”) works by enumerating all possible values for the <italic>O</italic>, <italic>I</italic>, and <italic>L</italic> arrays making up the Wheeler graph structure as described by Gagie et al.<xref rid="bib11" ref-type="bibr"><sup>11</sup></xref> The <italic>O</italic> bitarray is a concatenation of unary codes describing the outdegrees of each node. <italic>I</italic> is a similar bitarray that does the same for indegrees. <italic>L</italic> is a sequence of characters labeling the edges in the order they appear in the <italic>O</italic> array. Further, the inner loop of the algorithm must check if a given assignment for <italic>I</italic>, <italic>O</italic>, and <italic>L</italic> is isomorphic to the input graph provided.</p>
      <p id="p0100">While the G &amp; T algorithm explores an exponential-sized space, Wheelie explores the factorial-sized space of node permutations. To consider how this affects the size of an exhaustive search, we compared the search space for the worst-case scenarios for both algorithms in <xref rid="mmc1" ref-type="supplementary-material">Table S1</xref>. We hypothesized that Wheelie could be made faster with the help of strategies for pruning the search space. Wheelie prunes its search by assigning labels to nodes according to their <italic>rough</italic> positions in the order, a strategy we call the “<italic>renaming heuristic</italic>”. This allows Wheelie to arrive rapidly at a rough ordering that either (a) reveals a conflict that prevents the graph from having the Wheeler properties or (b) reduces the problem size for the downstream solving algorithm. An 8-node example illustrating the renaming heuristic is shown in <xref rid="fig1" ref-type="fig">Figure 1</xref>, and the full algorithm is described in <xref rid="sec4" ref-type="sec">STAR methods</xref>
<xref rid="sec4.3.3" ref-type="sec">wheelie and the renaming heuristic</xref>, <xref rid="sec4.3.4" ref-type="sec">satisfiability modulo theories (SMT) solver</xref>. Here, we use a version of the algorithm called Wheelie-Pr, which begins with the <italic>renaming heuristic</italic> then resolves remaining ambiguities by exhaustively searching over the remaining node permutations. Unlike G &amp; T, the Wheelie-Pr algorithm does not need to compute graph isomorphsims.<fig id="fig1"><label>Figure 1</label><caption><p>Illustration of the <italic>renaming heuristic</italic></p><p>(A) An 8-node graph with nodes divided into four groups according to in-coming edge label (with <italic>O</italic> representing 0-indegree nodes).</p><p>(B) presents the workflow of the <italic>renaming heuristic</italic>. The first table in (B) shows the initialized in-node lists for eight nodes. After initialization, the algorithm sorts and relabels nodes in each group until convergence. Then, it passes the range information to either Wheelie-Pr or Wheelie-SMT.</p></caption><graphic xlink:href="gr1"/></fig></p>
      <p id="p0105">We conducted a 30-s timeout test on both algorithms using graphs generated from four generators (WGT’s graph generating algorithms) including both Wheeler and non-Wheeler graphs. Rather than implement G &amp; T’s entire algorithm, we implemented the enumeration of the <italic>I</italic>, <italic>O</italic>, and <italic>L</italic> arrays but omitted the graph isomorphism check in the inner loop. We reasoned that if Wheelie-Pr was faster than the G &amp; T algorithm without the (rather complex) isomorphism check, it would also be faster than the full G &amp; T algorithm. To compare the algorithms, we configured both to perform an exhaustive search, without the possibility of early stopping if a solution is found. This differs from Wheelie-Pr’s default behavior, which allows it to stop upon finding a node ordering for which the Wheeler properties are satisfied. Early stopping is still possible for Wheelie-Pr in these experiments, since it might identify a conflict that proves the graph is non-Wheeler.</p>
      <p id="p0110">We took 25 multiple ortholog alignments, both their DNA and amino acid (AA) sequences, and extracted the first 4 rows of each. To reduce graph size, we truncated the graphs with respect to the multiple-alignment columns. We tested on three types of graphs, De Bruijn graphs, tries, and random Wheeler graphs, that are known Wheeler graphs, and two types of graphs, pseudo-De Bruijn graphs and reverse deterministic graphs, that are not guaranteed Wheeler graphs. Pseudo-De Bruijn graphs are graphs where the nodes correspond to k-1-mers in the multiple alignment, but where we do not collapse identical k-1-mers into single nodes.</p>
      <p id="p0115">For De Bruijn graphs and pseudo-De Bruijn graphs, we took columns 1 to 200 and set <italic>k</italic> to 3 to 9; for tries, we took columns 1 to 200; for reverse deterministic graphs, we took columns 2 to 41. We also benchmarked with a series of randomly generated graphs with <italic>n</italic> set to 3 to 33, <italic>e</italic> from 3 to <italic>n</italic>, and σ from 1 to 21. The number of each type of graphs and their node and edge numbers are shown in <xref rid="fig2" ref-type="fig">Figure 2</xref>B, and the arguments of each generator can be found in the WGT Github repository: <ext-link ext-link-type="uri" xlink:href="https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit" id="intref0025">https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit</ext-link>.<fig id="fig2"><label>Figure 2</label><caption><p>The results of comparing Wheelie-PR and G &amp; T algorithm</p><p>(A) Recognition time comparison between Wheelie-Pr exhaustive search and the G &amp; T algorithm using (1) De Bruijn graphs, (2) tries, (3) pseudo-De Bruijn graphs and (4) reverse deterministic graphs generated from DNA and protein alignments, and (5) random graphs generated with given <italic>n</italic>, <italic>e</italic>, and σ. Wheelie-Pr recognition time is on the y axis, and G &amp; T recognition time on the x axis, both on a <inline-formula><mml:math id="M10" altimg="si38.gif"><mml:mrow><mml:msub><mml:mi>log</mml:mi><mml:mn>10</mml:mn></mml:msub><mml:mtext>microsecond</mml:mtext></mml:mrow></mml:math></inline-formula> scale. Each dot represents a graph. Dots beyond the red lines denote inputs for which the tool timed out after 30 s.</p><p>(B) The graph number, timeout graph number of Wheelie-Pr and the G &amp; T algorithm, and ranges of node and edge number of each type of graphs. Rows in green describe graphs that are guaranteed Wheeler. Rows in red describe graphs that are not guaranteed to be Wheeler; i.e., some instances are Wheeler and some are not.</p></caption><graphic xlink:href="gr2"/></fig></p>
      <p id="p0120"><xref rid="fig2" ref-type="fig">Figure 2</xref>A shows that Wheelie-Pr is significantly faster, allowing it to recognize a range of Wheeler and non-Wheeler graphs. Wheelie-Pr runtimes generally range from 100 to 1,000 μs, with 784 random-graph inputs causing Wheelie-Pr to time out. In sum, the only type of graph that caused Wheelie-Pr to time out is the random graph whereas 8,461 graphs distributed in all types of benchmarked graphs caused G &amp; T to time out.</p>
    </sec>
    <sec id="sec2.2">
      <title>Visualizing and characterizing challenging graphs</title>
      <p id="p0125">We selected a De Bruijn graph with edges being k-mers and nodes being k-1-mers where <inline-formula><mml:math id="M11" altimg="si10.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> from the <xref rid="fig2" ref-type="fig">Figure 2</xref> benchmarks. This graph was derived from the first four rows of the multiple alignment of STAU2 DNA orthologs with sequence length 4. We first visualized it using Graphviz<xref rid="bib13" ref-type="bibr"><sup>13</sup></xref> (<xref rid="fig3" ref-type="fig">Figure 3</xref>A). We ran Wheelie-Pr to find an ordering for which the Wheeler properties hold (<xref rid="fig3" ref-type="fig">Figure 3</xref>B). Finally, we visualized the graph using WGT’s Python-based visualizer, which draws the ordered nodes in two replicas, with outgoing edges leaving one replica (<xref rid="fig4" ref-type="fig">Figure 4</xref>, top rows) and entering the other (bottom rows). For a valid Wheeler ordering, nodes with no incoming edges will appear leftmost, nodes with incoming edges of the smallest character will come next, nodes with incoming edges of the next-smallest character next, etc. Further, no two same-color edges will cross each other. In this way, the diagram, first described by Boucher et al.,<xref rid="bib14" ref-type="bibr"><sup>14</sup></xref> makes it visually obvious when an ordering has yielded the Wheeler properties.<fig id="fig3"><label>Figure 3</label><caption><p>WGT recognition and visualization results of an <italic>k=4</italic> De Bruijn graph</p><p>(A) A <inline-formula><mml:math id="M12" altimg="si10.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> De Bruijn graph outputted from WGT’s De Bruijn graph generator. It is the visualization from Graphviz online visualizer.</p><p>(B) The recognition result showing the Wheeler ordering outputted from Wheelie-Pr.</p><p>(C) The output from WGT’s visualizer. Nodes are duplicated into two rows ordered in Wheeler ordering.</p></caption><graphic xlink:href="gr3"/></fig><fig id="fig4"><label>Figure 4</label><caption><p>The results of WGT visualizer on d-NFAs with different numbers of labels</p><p>Examples of (A) 2-NFA with 1 label (B) 2-NFA with 2 labels (C) 2-NFA with 3 labels (D) 3-NFA with 1 label, from outlier random graphs (blue dots) in <xref rid="fig2" ref-type="fig">Figure 2</xref>.</p></caption><graphic xlink:href="gr4"/></fig></p>
      <p id="p0130">We sought to understand which graphs require the most time for recognition. After investigating the “outlier” graphs where Wheelie-PR timed out with these tools, we found that the graphs requiring the most recognition time tended to have nodes with many outgoing same-label edges. Following Alanko et al.,<xref rid="bib15" ref-type="bibr"><sup>15</sup></xref> we use the term <italic>d</italic>-NFA to describe a Wheeler graph where all nodes have <inline-formula><mml:math id="M13" altimg="si11.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula> outgoing same-label edges, and at least one node has exactly <italic>d</italic> outgoing same-label edges. The De Bruijn graph shown in <xref rid="fig3" ref-type="fig">Figure 3</xref> is a 1-NFA. <xref rid="fig4" ref-type="fig">Figures 4</xref>A–4C are 2-NFAs with σ equal to 1, 2, and 3, respectively. <xref rid="fig4" ref-type="fig">Figure 4</xref>D is a 3-NFA with <inline-formula><mml:math id="M14" altimg="si12.gif"><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Note that the <inline-formula><mml:math id="M15" altimg="si13.gif"><mml:mrow><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula> case is the one proven to be NP-complete.<xref rid="bib9" ref-type="bibr"><sup>9</sup></xref> De Bruijn graphs and tries are 1-NFAs.</p>
      <sec id="sec2.2.1">
        <title>Recognizing challenging graphs with Wheelie-SMT</title>
        <p id="p0135">Motivated by previous work that showed how Boolean satisfiability formulations can solve special cases of the recognition problem,<xref rid="bib15" ref-type="bibr"><sup>15</sup></xref> we hypothesized that SMT solvers<xref rid="bib10" ref-type="bibr"><sup>10</sup></xref> could solve all or part of the Wheeler graph recognition problem. SMT has found many uses in artificial intelligence and formal methods for hardware and software development. As a generalization of the Boolean satisfiability,<xref rid="bib16" ref-type="bibr"><sup>16</sup></xref> SMT allows us to encode the Wheeler graph properties in a fairly straightforward way, building from the propositional logic formulas in the definition.</p>
        <p id="p0140">We conducted two series of 1,000-s timeout tests using graphs generated from the random generator comparing (1) Wheelie-Pr (<italic>renaming heuristic</italic> plus permutation) versus (2) Wheelie-SMT (<italic>renaming heuristic</italic> plus SMT) on different types of <italic>d</italic>-NFA (Recognizing <italic>d</italic>-NFAs) and various sizes of random graphs (Recognizing random Wheeler graphs).</p>
      </sec>
    </sec>
    <sec id="sec2.3">
      <title>Recognizing <italic>d</italic>-NFAs</title>
      <p id="p0145">We fixed <inline-formula><mml:math id="M16" altimg="si14.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1000</mml:mn></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M17" altimg="si15.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>3000</mml:mn></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="M18" altimg="si16.gif"><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> and randomly generated <italic>d</italic>-NFAs with <italic>d</italic> from 1 to 8 and each group with 20 graphs. <xref rid="fig5" ref-type="fig">Figure 5</xref> shows that both solvers can solve graphs swiftly when <italic>d</italic> is 1 and 2; as <italic>d</italic> grows beyond 2, all tools require much more time, demonstrating that <italic>d</italic> impacts the hardness of recognition problem in practice. Wheelie-SMT outperforms Wheelie-Pr and avoids any timeouts; Wheelie-Pr has some timeouts starting at <inline-formula><mml:math id="M19" altimg="si17.gif"><mml:mrow><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> (4 out of 20 graphs), and consistently times out when <inline-formula><mml:math id="M20" altimg="si18.gif"><mml:mrow><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>.<fig id="fig5"><label>Figure 5</label><caption><p>Recognition time for Wheelie-SMT and Wheelie-Pr as a function of the <italic>d</italic> parameter of the <italic>d</italic>-NFA</p><p>Upper panel plots recognition time versus <italic>d</italic> and includes a line connecting the medians. 20 graphs were tested for each <italic>d</italic>. The bottom bar chart shows the number of timeouts.</p></caption><graphic xlink:href="gr5"/></fig></p>
      <p id="p0150">Further, we observed that when <inline-formula><mml:math id="M21" altimg="si19.gif"><mml:mrow><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:math></inline-formula>, the median curve for Wheelie-SMT plateaus. This is because <italic>n</italic> and <italic>e</italic> are too small for the <italic>d</italic>-NFA generator to produce uniformly distributed <italic>d</italic>-NFAs under the given parameters. More precisely speaking, the hardness of the recognition problem is a function of the distribution of nodes having <inline-formula><mml:math id="M22" altimg="si20.gif"><mml:mrow><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M23" altimg="si21.gif"><mml:mrow><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, …, 1 outgoing edges with the same labels. As an example, take a <italic>d</italic>-NFA <italic>G</italic> that has one node with <italic>d</italic> same-label outgoing edges, and the rest of the nodes having at most one outgoing same-label edge. Recognizing <italic>G</italic> is not harder than recognizing a uniformly distributed <inline-formula><mml:math id="M24" altimg="si20.gif"><mml:mrow><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>-NFA. In short, we observed that higher <italic>d</italic>s generally led to a harder recognition problem, but the true level of hardness was also a function of <italic>n</italic>, <italic>e</italic>, and σ.</p>
    </sec>
    <sec id="sec2.4">
      <title>Recognizing random Wheeler graphs</title>
      <p id="p0155">We defined “graph size” as <italic>n</italic> and “label density” as <inline-formula><mml:math id="M25" altimg="si22.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:mi>σ</mml:mi></mml:mrow></mml:math></inline-formula>. We then benchmarked various sizes of random graphs while varying these parameters. We first fixed the number of edges (<inline-formula><mml:math id="M26" altimg="si23.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>8,000</mml:mn></mml:mrow></mml:math></inline-formula>) and labels (<inline-formula><mml:math id="M27" altimg="si16.gif"><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>) while scaling graph size <italic>n</italic> from <inline-formula><mml:math id="M28" altimg="si24.gif"><mml:mrow><mml:mn>2,000</mml:mn></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M29" altimg="si25.gif"><mml:mrow><mml:mn>8,000</mml:mn></mml:mrow></mml:math></inline-formula>. <xref rid="fig6" ref-type="fig">Figure 6</xref>A shows that as <italic>n</italic> grows, Wheelie-SMT outperforms Wheelie-Pr significantly. Wheelie-Pr starts to time out in some cases when <inline-formula><mml:math id="M30" altimg="si26.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>2,000</mml:mn></mml:mrow></mml:math></inline-formula>, and most cases when <inline-formula><mml:math id="M31" altimg="si27.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo><mml:mn>2,500</mml:mn></mml:mrow></mml:math></inline-formula>. In contrast, Wheelie-SMT can solve all cases with <italic>n</italic> up to <inline-formula><mml:math id="M32" altimg="si28.gif"><mml:mrow><mml:mn>4,000</mml:mn></mml:mrow></mml:math></inline-formula>, and most cases when <inline-formula><mml:math id="M33" altimg="si29.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4,500</mml:mn></mml:mrow></mml:math></inline-formula>.<fig id="fig6"><label>Figure 6</label><caption><p>Recognition time comparison for Wheelie-SMT and Wheelie-Pr for various random Wheeler graphs</p><p>Three experiments were conducted.</p><p>(A) Experiment 1: fixing <inline-formula><mml:math id="M34" altimg="si23.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>8,000</mml:mn></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M35" altimg="si16.gif"><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> and scaling up the graph size (<italic>n</italic> from <inline-formula><mml:math id="M36" altimg="si24.gif"><mml:mrow><mml:mn>2,000</mml:mn></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M37" altimg="si25.gif"><mml:mrow><mml:mn>8,000</mml:mn></mml:mrow></mml:math></inline-formula>).</p><p>(B) Experiment 2: fixing <inline-formula><mml:math id="M38" altimg="si30.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4,000</mml:mn></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M39" altimg="si31.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>20,000</mml:mn></mml:mrow></mml:math></inline-formula> and scaling up the label density (<inline-formula><mml:math id="M40" altimg="si22.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:mi>σ</mml:mi></mml:mrow></mml:math></inline-formula> from <inline-formula><mml:math id="M41" altimg="si32.gif"><mml:mrow><mml:mn>1,000</mml:mn></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M42" altimg="si28.gif"><mml:mrow><mml:mn>4,000</mml:mn></mml:mrow></mml:math></inline-formula>).</p><p>(C) Experiment 3: Fixing both graph size (<italic>n</italic>) and label density (<inline-formula><mml:math id="M43" altimg="si22.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:mi>σ</mml:mi></mml:mrow></mml:math></inline-formula>), and scaling up both <italic>e</italic> and σ (<inline-formula><mml:math id="M44" altimg="si36.gif"><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mi mathvariant="italic">min</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> from 1 to 20). The upper-panel plots show the recognition time versus the scale up parameter in microsecond scale. Each dot represents a graph. Dots beyond the red dashed line means timeouts. Plots in the lower panel are the timeout count bar charts.</p></caption><graphic xlink:href="gr6"/></fig></p>
      <p id="p0160">We then fixed the graph size (<inline-formula><mml:math id="M45" altimg="si30.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4,000</mml:mn></mml:mrow></mml:math></inline-formula>) and number of edges (<inline-formula><mml:math id="M46" altimg="si31.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>20,000</mml:mn></mml:mrow></mml:math></inline-formula>) and varied the label density (<inline-formula><mml:math id="M47" altimg="si22.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:mi>σ</mml:mi></mml:mrow></mml:math></inline-formula> from <inline-formula><mml:math id="M48" altimg="si32.gif"><mml:mrow><mml:mn>1,000</mml:mn></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M49" altimg="si28.gif"><mml:mrow><mml:mn>4,000</mml:mn></mml:mrow></mml:math></inline-formula>). <xref rid="fig6" ref-type="fig">Figure 6</xref>B shows that as the label density increases, the graphs take more time to solve. Comparing Wheelie-Pr and Wheelie-SMT, we can see that there are more timeout cases in Wheelie-Pr from <inline-formula><mml:math id="M50" altimg="si33.gif"><mml:mrow><mml:mn>1,200</mml:mn></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M51" altimg="si28.gif"><mml:mrow><mml:mn>4,000</mml:mn></mml:mrow></mml:math></inline-formula> (most are timeouts when <inline-formula><mml:math id="M52" altimg="si34.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo><mml:mn>2,500</mml:mn></mml:mrow></mml:math></inline-formula>) whereas the timeout cases only occur in Wheelie-SMT when label density is <inline-formula><mml:math id="M53" altimg="si28.gif"><mml:mrow><mml:mn>4,000</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
      <p id="p0165">In a third experiment, we fixed the graph size (<inline-formula><mml:math id="M54" altimg="si26.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>2,000</mml:mn></mml:mrow></mml:math></inline-formula>) and varied the number of edges (<italic>e</italic>) and labels (σ) while fixing the label density ratio (<inline-formula><mml:math id="M55" altimg="si35.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>2,000</mml:mn></mml:mrow></mml:math></inline-formula>). <xref rid="fig6" ref-type="fig">Figure 6</xref>C shows that as more edges and labels are added, the recognition problem becomes easier. In short, this is because adding more constraints to <italic>G</italic> breaks more of the ties that would otherwise obstruct Wheelie’s <italic>renaming heuristic</italic>. Comparing Wheelie-Pr to Wheelie-SMT, <xref rid="fig6" ref-type="fig">Figure 6</xref>C shows that the solvers perform similarly, with Wheelie-Pr performing slightly better when <inline-formula><mml:math id="M56" altimg="si36.gif"><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mi mathvariant="italic">min</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> ratio gets larger (<inline-formula><mml:math id="M57" altimg="si37.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula>). These are likely cases where the graph is sufficiently easy to recognize that the overhead of setting up the SMT setup problem becomes harmful. When <inline-formula><mml:math id="M58" altimg="si36.gif"><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mi mathvariant="italic">min</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> gets smaller (3 and 4), Wheelie-SMT is able to solve all 15 cases, whereas Wheelie-Pr’s times out for about half the cases.</p>
    </sec>
    <sec id="sec2.5">
      <title>Benchmarking Wheelie-SMT alone</title>
      <p id="p0170">To isolate the effect of the Wheelie <italic>renaming heuristic</italic>, we conducted a 30-s timeout test with 60 s timeout penalties on (1) Wheelie-SMT (<italic>renaming heuristic</italic> plus SMT) and (2) a pure SMT solver starting from scratch, without the constraints it would otherwise receive from the <italic>renaming heuristic</italic>. We benchmarked these using two generators from DNA alignments: (1) De Bruijn graphs generated with options -k from 5 to 8, -l from 100 to <inline-formula><mml:math id="M59" altimg="si24.gif"><mml:mrow><mml:mn>2,000</mml:mn></mml:mrow></mml:math></inline-formula>, and -a from 6 to 10, 225 graphs in total and (2) reverse deterministic graphs generated with options -l from 100 to 500 and -a from 4 to 6, in total 225 graphs.</p>
      <p id="p0175"><xref rid="fig7" ref-type="fig">Figure 7</xref> shows cactus plots on De Bruijn graphs and reverse deterministic graphs. A cactus plot is an aggregated sorted time plot widely used in solver competitions. It shows how many problems a solver can solve in a limited time period. In <xref rid="fig7" ref-type="fig">Figure 7</xref>A, Wheelie-SMT solved the whole De Bruijn graph set in around 6.5 s whereas the pure SMT approach solved it in around 820 s. For reverse deterministic graphs (<xref rid="fig7" ref-type="fig">Figure 7</xref>B), Wheelie-SMT solved the whole set in less than 9 s whereas the pure SMT approach solved it in around 10,170 s.<fig id="fig7"><label>Figure 7</label><caption><p>Cactus survival plot results of Wheelie-SMT and pure SMT</p><p>(A and B) The cactus survival plots of (A) De Bruijn graphs and (B) reverse deterministic graphs generated from DNA alignments using WGT’s generators. They show the aggregated time comparison between Wheelie-SMT and pure SMT without the constraints from the <italic>renaming heuristic</italic>.</p></caption><graphic xlink:href="gr7"/></fig></p>
      <p id="p0180">We concluded that the <italic>renaming heuristic</italic> is a crucial step, since it greatly narrows the space of possible node ordering that must be resolved by the SMT solver. Wheelie-SMT can solve graphs several orders of magnitude larger than a pure SMT approach.</p>
    </sec>
  </sec>
  <sec id="sec3">
    <title>Discussion</title>
    <p id="p0185">We demonstrated that Wheelie-SMT is the fastest and most robust algorithm available for the Wheeler graph recognition problem. We showed this across a variety of graph types, including large graphs (thousands of nodes and edges) and challenging graphs, such as those that are <italic>d</italic>-NFAs with values of <italic>d</italic> up to 8. We also demonstrated WGT’s facilities for visualizing and understanding these graphs.</p>
    <p id="p0190">While current pangenome representations tend to be based on De Bruijn graphs, which are Wheeler graphs, other relevant pangenome graph representations are not necessarily Wheeler. For example, the reverse deterministic automata of the GCSA study<xref rid="bib6" ref-type="bibr"><sup>6</sup></xref> are not Wheeler, though they can be made Wheeler through a “path doubling” process. In the future, we expect that WGT and the Wheelie algorithm will be useful for studying alternative pangenome graph representations that might improve upon De Bruijn graphs in various ways. In <xref rid="mmc1" ref-type="supplementary-material">Figure S3</xref>, we provide a simple illustration of why another Wheeler graph (besides a De Bruijn graph) might be better suited as a pangenome representation, since it (a) uses fewer nodes and edges than a corresponding De Bruijn graph, (b) does not require that we select a particular value for <italic>k</italic> (the <italic>k</italic>-mer length), and (c) avoids collapsing sequences that are distinct with respect to the coordinate system of a given genome.</p>
    <p id="p0195">We noted a relationship between the renaming heuristic proposed here and the “forward algorithm” of Alanko et al.<xref rid="bib17" ref-type="bibr"><sup>17</sup></xref> In the future, it will be important to clarify the relationship between these two algorithms, which have similar goals but take different approaches to partitioning and ordering the graph nodes. Appealingly, the forward algorithm has polynomial running time when the input is already a Wheeler graph; we do not have a similar guarantee for the renaming heuristic. However, the forward algorithm is not directly usable for the same purpose as the renaming heuristic, since it is possible for the forward algorithm to collapse a non-Wheeler input in a way that produces a Wheeler output. Another question for future work is whether the renaming heuristic could be combined with the forward algorithm to obtain an algorithm with strong guarantees (like the forward algorithm) but that is directly applicable to the recognition problem (like the renaming heuristic).</p>
    <p id="p0200">When Wheelie determines that a graph is is Wheeler graph, it is able to report a node ordering that can then be used to index the graph. In the future, it will be important to extend Wheelie to report other useful information, including when the graph is not a Wheeler graph. For instance, when Wheelie encounters a conflict that proves the graph to be non-Wheeler, Wheelie could supply the user with an explanation for why the graph cannot be Wheeler. Such an explanation could also allow Wheelie to suggest modifications to the graph that would make it a Wheeler graph, without changing which strings it encodes. A trivial example would be a node with two incoming edges having two distinct labels. This violates the Wheeler graph properties, but also suggests a potential solution: the node could be duplicated, with outgoing edges also duplicated. The initial inbound edges could be redrawn to point to the distinct duplicates, possibly restoring the Wheeler properties. A more general approach for understanding Wheeler violations could work by extracting conflicting sets of clauses from the SMT algorithm, and converting them into a human-understandable or other actionable form.</p>
    <p id="p0205">It may also be possible to encode the <italic>renaming heuristic</italic> as a set of clauses in the SMT solver, potentially allowing the entire algorithm to execute within the SMT solver. Finally, as different SMT solvers such as CVC5<xref rid="bib18" ref-type="bibr"><sup>18</sup></xref> or Z3<xref rid="bib19" ref-type="bibr"><sup>19</sup></xref> adopt different heuristics, they could potentially be substituted into WGT, or combined for increased efficiency.<xref rid="bib20" ref-type="bibr"><sup>20</sup></xref></p>
    <sec id="sec3.1">
      <title>Limitations of the study</title>
      <p id="p0210">A theoretical limitation is that we cannot claim to have improved on the worst-case bounds already established for the recognition problem. The problem is NP-complete in general, though our work suggests that the kinds of graphs that appear in pangenome applications (e.g., when they are <italic>d</italic>-NFAs with small <italic>d</italic>) may be of a class that are easier to check in practice. A further practical limitation is the fact that Wheelie cannot yet scale to large pangenome graphs. Wheelie has been demonstrated to effectively identify graphs with up to 4,000 nodes, 20,000 edges, and 5 edge labels within a time frame of around 1000 s. We are still far from being able to efficiently check pangenomes derived from, for example, whole eukaryotic genomes. A final limitation is the fact that our bipartite visualization approach works only when a particular ordering has been proposed. A more general approach would render a useful visualization when such an ordering is either not known or partially known.</p>
    </sec>
  </sec>
  <sec id="sec4">
    <title>STAR★Methods</title>
    <sec id="sec4.1">
      <title>Key resources table</title>
      <p id="p0215">
        <table-wrap position="float" id="undtbl1">
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <th>REAGENT or RESOURCE</th>
                <th>SOURCE</th>
                <th>IDENTIFIER</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td colspan="3">
                  <bold>Deposited data</bold>
                </td>
              </tr>
              <tr>
                <td colspan="3">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td>25 multiple orthologue alignments</td>
                <td>Ensembl Comparative Genomics REST API</td>
                <td>REST API: <ext-link ext-link-type="uri" xlink:href="https://rest.ensembl.org/documentation/info/genomic_alignment_region" id="intref0030">https://rest.ensembl.org/documentation/info/genomic_alignment_region</ext-link>; GitHub: <ext-link ext-link-type="uri" xlink:href="https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit/tree/main/data/multiseq_alignment/Ensembl_REST/fasta" id="intref0035">https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit/tree/main/data/multiseq_alignment/Ensembl_REST/fasta</ext-link></td>
              </tr>
              <tr>
                <td colspan="3">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td colspan="3">
                  <bold>Software and algorithms</bold>
                </td>
              </tr>
              <tr>
                <td colspan="3">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td>G &amp; T’s algorithm</td>
                <td>Gibney &amp; Thankachan</td>
                <td>
                  <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.48550/arXiv.1902.01960" id="intref0040">https://doi.org/10.48550/arXiv.1902.01960</ext-link>
                </td>
              </tr>
              <tr>
                <td>Z3 theorem prover v4.11.1</td>
                <td>Microsoft Corporation</td>
                <td>
                  <ext-link ext-link-type="uri" xlink:href="https://github.com/Z3Prover/z3" id="intref0045">https://github.com/Z3Prover/z3</ext-link>
                </td>
              </tr>
              <tr>
                <td>WGT toolkit v1.0.0</td>
                <td>This study</td>
                <td>Zenodo DOI: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.5281/zenodo.7937689" id="intref0050">https://doi.org/10.5281/zenodo.7937689</ext-link>; GitHub: <ext-link ext-link-type="uri" xlink:href="https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit" id="intref0055">https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit</ext-link></td>
              </tr>
            </tbody>
          </table>
        </table-wrap>
      </p>
    </sec>
    <sec id="sec4.2">
      <title>Resource availability</title>
      <sec id="sec4.2.1">
        <title>Lead contact</title>
        <p id="p0220">Further information and requests for resources and reagents should be directed to and will be fulfilled by the lead contact, Ben Langmead (<ext-link ext-link-type="uri" xlink:href="mailto:langmea@cs.jhu.edu" id="intref0060">langmea@cs.jhu.edu</ext-link>).</p>
      </sec>
      <sec id="sec4.2.2">
        <title>Materials availability</title>
        <p id="p0225">This study did not generate new unique reagents.</p>
      </sec>
    </sec>
    <sec id="sec4.3">
      <title>Method details</title>
      <sec id="sec4.3.1">
        <title>The search space of Wheelie’s permutation approach</title>
        <p id="p0230">While the G &amp; T algorithm explores an exponential-sized space of possible array assignments, Wheelie explores a factorial-sized space of node permutations. This may or may not lead to a larger search space for Wheelie, depending on the graph’s properties. To be specific, the G &amp; T’s algorithm may have to consider all <inline-formula><mml:math id="M60" altimg="si39.gif"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mi>n</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>e</mml:mi><mml:mspace width="0.25em"/><mml:mi>log</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>σ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> assignments for <italic>I</italic>, <italic>O</italic> and <italic>L</italic>. Our approach might need to consider <inline-formula><mml:math id="M61" altimg="si40.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo>!</mml:mo></mml:mrow></mml:math></inline-formula> node permutations in the worst case. We sought a rough comparison between the approaches in light of the fact that G &amp; T’s space depends not only on <italic>n</italic> but also on <italic>e</italic> and σ.<disp-formula id="fd1"><label>(Equation 1)</label><mml:math id="M62" altimg="si41.gif"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mi>e</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo linebreak="badbreak">+</mml:mo><mml:mi>e</mml:mi><mml:mo linebreak="badbreak">×</mml:mo><mml:mi>log</mml:mi><mml:mspace width="0.25em"/><mml:mi>σ</mml:mi></mml:mrow></mml:msup><mml:mo linebreak="badbreak">=</mml:mo><mml:mi>n</mml:mi><mml:mo>!</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="fd2"><label>(Equation 2)</label><mml:math id="M63" altimg="si42.gif"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mi>e</mml:mi><mml:mo linebreak="badbreak">×</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mo linebreak="badbreak">+</mml:mo><mml:mi>log</mml:mi><mml:mspace width="0.25em"/><mml:mi>σ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msup><mml:mo linebreak="badbreak">=</mml:mo><mml:mi>n</mml:mi><mml:mo>!</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="ufd1"><mml:math id="M64" altimg="si43.gif"><mml:mrow><mml:mtext>Let</mml:mtext><mml:mspace width="0.25em"/><mml:mi>C</mml:mi><mml:mo>:</mml:mo><mml:mo linebreak="badbreak">=</mml:mo><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mo linebreak="badbreak">+</mml:mo><mml:mi>log</mml:mi><mml:mspace width="0.25em"/><mml:mi>σ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="fd3"><label>(Equation 3)</label><mml:math id="M65" altimg="si44.gif"><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mi>C</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:msub><mml:mi>log</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mspace width="0.25em"/><mml:mi>n</mml:mi><mml:mo>!</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="fd4"><label>(Equation 4)</label><mml:math id="M66" altimg="si45.gif"><mml:mrow><mml:mi>C</mml:mi><mml:mo linebreak="badbreak">=</mml:mo><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo linebreak="badbreak">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>log</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mspace width="0.25em"/><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p>
      </sec>
      <sec id="sec4.3.2">
        <title>Derivation 1: The relationship between <italic>C</italic> and <italic>n</italic></title>
        <p id="p0235">In Derivation 1, we fixed <italic>n</italic> for both, defining a new variable <italic>C</italic> as <inline-formula><mml:math id="M67" altimg="si46.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mo linebreak="badbreak">+</mml:mo><mml:mi>log</mml:mi><mml:mspace width="0.25em"/><mml:mi>σ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. We then found some values for <italic>C</italic> that equalize the algorithms’ search space size under various values for of <italic>n</italic>s (<xref rid="mmc1" ref-type="supplementary-material">Table S1</xref>). For instance, when <inline-formula><mml:math id="M68" altimg="si47.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>100</mml:mn></mml:mrow></mml:math></inline-formula>, <italic>C</italic> can be at most 324 in order for G &amp; T’s algorithm has an equal or smaller search space than Wheelie-Pr, which is a strict threshold, and furthermore, this comparison is done with Wheelie-Pr skipping the <italic>renaming heuristic</italic>, which in reality makes Wheelie-Pr superiorly faster (ResultsBenchmarking Wheelie-SMT alone).</p>
        <p id="p0240">To gain a further advantage over the G &amp; T algorithm, Wheelie further strives to prune the search space, using a renaming heuristic, an SMT solver, or both, as detailed in MethodsSTAR Methods.</p>
      </sec>
      <sec id="sec4.3.3">
        <title>Wheelie and the <italic>renaming heuristic</italic></title>
        <p id="p0245">Wheelie explores the space of possible node orderings until arriving either at a conflict (e.g., a node with distinctly labeled incoming edges) or an ordering for which the Wheeler properties hold. While this is a large (<inline-formula><mml:math id="M69" altimg="si40.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo>!</mml:mo></mml:mrow></mml:math></inline-formula>-sized) search space, Wheelie prunes the space by assigning labels to nodes according to their <italic>rough</italic> position in the overall order. Initially, a rough ordering is determined according to the labels of the immediate incoming edges for each node, following the Wheeler requirement that <inline-formula><mml:math id="M70" altimg="si4.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≺</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after" stretchy="true">→</mml:mo><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> for all edge pairs. This rough ordering is refined over the course of a procedure that iterates either until the rough ordering becomes total ordering, or until the rough ordering stabilizes. In the latter case, the remaining ambiguities are resolved by a non-heuristic solver. This procedure is detailed in <xref rid="tbox1" ref-type="boxed-text">Algorithm 1</xref> and illustrated in <xref rid="fig1" ref-type="fig">Figure 1</xref>.<boxed-text id="tbox1"><label>Algorithm 1</label><caption><title>Wheeler graph Recognition Algorithm, Wheelie</title></caption><p id="p0375"><bold>Require</bold>:</p><p id="p0380"><bold>Input:</bold> Graph <italic>G</italic> as DOT file.</p><p id="p0385"><bold>Input:</bold> Solver <italic>S</italic> input from -s or --solver tag.<list list-type="simple" id="ulist1010"><list-item id="u1010"><label>1:</label><p id="p0390">Find all 0-indegree nodes, <inline-formula><mml:math id="M71" altimg="si62.gif"><mml:mrow><mml:mi>R</mml:mi><mml:mi>o</mml:mi><mml:mi>o</mml:mi><mml:mi>t</mml:mi><mml:mi>s</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mspace width="0.25em"/><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u2010"><label>2:</label><p id="p0395">Group edges by their labels in a hashMap, <inline-formula><mml:math id="M72" altimg="si63.gif"><mml:mrow><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mo>_</mml:mo><mml:mo>2</mml:mo><mml:mo>_</mml:mo><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> (key: label, value: list of edges)</p></list-item><list-item id="u3010"><label>3:</label><p id="p0400"><inline-formula><mml:math id="M73" altimg="si64.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">←</mml:mo><mml:mi>R</mml:mi><mml:mi>o</mml:mi><mml:mi>o</mml:mi><mml:mi>t</mml:mi><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>z</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> <inline-formula><mml:math id="M74" altimg="si65.gif"><mml:mrow><mml:mo>▷</mml:mo></mml:mrow></mml:math></inline-formula> Relabel nodes with the largest possible order</p></list-item><list-item id="u4010"><label>4:</label><p id="p0405"><bold>for</bold> each <inline-formula><mml:math id="M75" altimg="si66.gif"><mml:mrow><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>o</mml:mi><mml:mi>t</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">∈</mml:mo><mml:mi>R</mml:mi><mml:mi>o</mml:mi><mml:mi>o</mml:mi><mml:mi>t</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>do</bold></p></list-item><list-item id="u5010"><label>5:</label><p id="p0410"> <inline-formula><mml:math id="M76" altimg="si67.gif"><mml:mrow><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mo>_</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>o</mml:mi><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>_</mml:mo><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u6010"><label>6:</label><p id="p0415"><bold>end for</bold>.</p></list-item><list-item id="u7010"><label>7:</label><p id="p0420"><bold>for</bold> each <inline-formula><mml:math id="M77" altimg="si68.gif"><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">∈</mml:mo><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mo>_</mml:mo><mml:mo>2</mml:mo><mml:mo>_</mml:mo><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>do</bold></p></list-item><list-item id="u8010"><label>8:</label><p id="p0425"> <inline-formula><mml:math id="M78" altimg="si69.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">←</mml:mo><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mi>q</mml:mi><mml:mi>u</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>.</mml:mo><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>z</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u9010"><label>9:</label><p id="p0430"> <bold>for</bold> each <inline-formula><mml:math id="M79" altimg="si70.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">∈</mml:mo><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>do</bold></p></list-item><list-item id="u10010"><label>10:</label><p id="p0435"> <inline-formula><mml:math id="M80" altimg="si71.gif"><mml:mrow><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mo>_</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mo>.</mml:mo><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mo>_</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u11010"><label>11:</label><p id="p0440"> <bold>end for</bold>.</p></list-item><list-item id="u12010"><label>12:</label><p id="p0445"><bold>end for</bold>.</p></list-item><list-item id="u13010"><label>13:</label><p id="p0450"><inline-formula><mml:math id="M81" altimg="si72.gif"><mml:mrow><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">←</mml:mo><mml:mi>F</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula> <inline-formula><mml:math id="M82" altimg="si65.gif"><mml:mrow><mml:mo>▷</mml:mo></mml:mrow></mml:math></inline-formula><italic>renaming heuristic</italic></p></list-item><list-item id="u14010"><label>14:</label><p id="p0455"><inline-formula><mml:math id="M83" altimg="si73.gif"><mml:mrow><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mspace width="0.25em"/><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u15010"><label>15:</label><p id="p0460"><bold>while</bold> not <inline-formula><mml:math id="M84" altimg="si74.gif"><mml:mrow><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>do</bold></p></list-item><list-item id="u16010"><label>16:</label><p id="p0465"> <inline-formula><mml:math id="M85" altimg="si75.gif"><mml:mrow><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>c</mml:mi><mml:mi>l</mml:mi><mml:mi>e</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u17010"><label>17:</label><p id="p0470"> <inline-formula><mml:math id="M86" altimg="si76.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">←</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u18010"><label>18:</label><p id="p0475"> <inline-formula><mml:math id="M87" altimg="si77.gif"><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo>_</mml:mo><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mspace width="0.25em"/><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u19010"><label>19:</label><p id="p0480"> <bold>for</bold> each <inline-formula><mml:math id="M88" altimg="si68.gif"><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">∈</mml:mo><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mo>_</mml:mo><mml:mo>2</mml:mo><mml:mo>_</mml:mo><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>do</bold></p></list-item><list-item id="u20010"><label>20:</label><p id="p0485"> <inline-formula><mml:math id="M89" altimg="si78.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">←</mml:mo><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mi>q</mml:mi><mml:mi>u</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mo>_</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u21010"><label>21:</label><p id="p0490"> <bold>for</bold> each <inline-formula><mml:math id="M90" altimg="si79.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">∈</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>do</bold></p></list-item><list-item id="u22010"><label>22:</label><p id="p0495"> <inline-formula><mml:math id="M91" altimg="si80.gif"><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo>_</mml:mo><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo>.</mml:mo><mml:mi>A</mml:mi><mml:mi>d</mml:mi><mml:mi>d</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>t</mml:mi><mml:mo>_</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> <inline-formula><mml:math id="M92" altimg="si65.gif"><mml:mrow><mml:mo>▷</mml:mo></mml:mrow></mml:math></inline-formula> get_innodelist: lists distinct predecessor nodes in order by label</p></list-item><list-item id="u23010"><label>23:</label><p id="p0500"> <bold>end for</bold>.</p></list-item><list-item id="u24010"><label>24:</label><p id="p0505"> <inline-formula><mml:math id="M93" altimg="si81.gif"><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi><mml:mi>i</mml:mi><mml:mi>c</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>s</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mo>_</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo>_</mml:mo><mml:mi>b</mml:mi><mml:mi>y</mml:mi><mml:mo>_</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo>_</mml:mo><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u25010"><label>25:</label><p id="p0510"> <inline-formula><mml:math id="M94" altimg="si82.gif"><mml:mrow><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mo>_</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo>_</mml:mo><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi><mml:mi>i</mml:mi><mml:mi>c</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> <inline-formula><mml:math id="M95" altimg="si65.gif"><mml:mrow><mml:mo>▷</mml:mo></mml:mrow></mml:math></inline-formula> Assign <inline-formula><mml:math id="M96" altimg="si83.gif"><mml:mrow><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo>_</mml:mo><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M97" altimg="si84.gif"><mml:mrow><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>v</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo>_</mml:mo><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula> for each node</p></list-item><list-item id="u26010"><label>26:</label><p id="p0515"> <inline-formula><mml:math id="M98" altimg="si85.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">←</mml:mo><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>z</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u27010"><label>27:</label><p id="p0520"> <bold>end for</bold>.</p></list-item><list-item id="u28010"><label>28:</label><p id="p0525"> <inline-formula><mml:math id="M99" altimg="si86.gif"><mml:mrow><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">←</mml:mo><mml:mi>T</mml:mi><mml:mi>r</mml:mi><mml:mi>u</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u29010"><label>29:</label><p id="p0530"> <bold>for</bold> each <inline-formula><mml:math id="M100" altimg="si79.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">∈</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>do</bold></p></list-item><list-item id="u30010"><label>30:</label><p id="p0535"> <inline-formula><mml:math id="M101" altimg="si87.gif"><mml:mrow><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>A</mml:mi><mml:mi>d</mml:mi><mml:mi>d</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo>.</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo>_</mml:mo><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u31010"><label>31:</label><p id="p0540"> <bold>if</bold><inline-formula><mml:math id="M102" altimg="si88.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo>.</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo>_</mml:mo><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≠</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo>.</mml:mo><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>v</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo>_</mml:mo><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula><bold>then</bold></p></list-item><list-item id="u32010"><label>32:</label><p id="p0545"> <inline-formula><mml:math id="M103" altimg="si72.gif"><mml:mrow><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">←</mml:mo><mml:mi>F</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u33010"><label>33:</label><p id="p0550"> <inline-formula><mml:math id="M104" altimg="si89.gif"><mml:mrow><mml:mi>B</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u34010"><label>34:</label><p id="p0555"> <bold>end if</bold>.</p></list-item><list-item id="u35010"><label>35:</label><p id="p0560"> <bold>end for</bold>.</p></list-item><list-item id="u36010"><label>36:</label><p id="p0565"><bold>end while</bold>.</p></list-item><list-item id="u37010"><label>37:</label><p id="p0570"><bold>if</bold><inline-formula><mml:math id="M105" altimg="si90.gif"><mml:mrow><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mi>q</mml:mi><mml:mi>u</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>z</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>z</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula><bold>then</bold> <inline-formula><mml:math id="M106" altimg="si65.gif"><mml:mrow><mml:mo>▷</mml:mo></mml:mrow></mml:math></inline-formula> Solved by <italic>renaming heuristic</italic></p></list-item><list-item id="u38010"><label>38:</label><p id="p0575"> <italic>G</italic> is a Wheeler graph.</p></list-item><list-item id="u39010"><label>39:</label><p id="p0580"><bold>else</bold>.</p></list-item><list-item id="u40010"><label>40:</label><p id="p0585"> <bold>if</bold><inline-formula><mml:math id="M107" altimg="si91.gif"><mml:mrow><mml:mi>S</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo></mml:mrow></mml:math></inline-formula>'' <inline-formula><mml:math id="M108" altimg="si92.gif"><mml:mrow><mml:mi>P</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>m</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>'' <bold>then</bold></p></list-item><list-item id="u41010"><label>41:</label><p id="p0590"> <inline-formula><mml:math id="M109" altimg="si93.gif"><mml:mrow><mml:mi>P</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>m</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> <inline-formula><mml:math id="M110" altimg="si65.gif"><mml:mrow><mml:mo>▷</mml:mo></mml:mrow></mml:math></inline-formula> Use Wheelie-Pr solver to resolve multi-node groups</p></list-item><list-item id="u42010"><label>42:</label><p id="p0595"> <bold>else if</bold><inline-formula><mml:math id="M111" altimg="si91.gif"><mml:mrow><mml:mi>S</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo></mml:mrow></mml:math></inline-formula>'' <inline-formula><mml:math id="M112" altimg="si94.gif"><mml:mrow><mml:mi>S</mml:mi><mml:mi>M</mml:mi><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula>'' <bold>then</bold></p></list-item><list-item id="u43010"><label>43:</label><p id="p0600"> <inline-formula><mml:math id="M113" altimg="si95.gif"><mml:mrow><mml:mi>S</mml:mi><mml:mi>M</mml:mi><mml:mi>T</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> <inline-formula><mml:math id="M114" altimg="si65.gif"><mml:mrow><mml:mo>▷</mml:mo></mml:mrow></mml:math></inline-formula> Use Wheelie-SMT solver to resolve multi-node groups</p></list-item><list-item id="u44010"><label>44:</label><p id="p0605"> <bold>end if</bold>.</p></list-item><list-item id="u45010"><label>45:</label><p id="p0610"><bold>end if</bold>.</p></list-item></list></p></boxed-text></p>
        <p id="p0250">As the <italic>renaming heuristic</italic> iterates, it repeatedly visits the nodes in groupings according to the label of their incoming edge(s). For each of these groupings, it sorts the edges by sources and destinations in every label group, requiring <inline-formula><mml:math id="M115" altimg="si48.gif"><mml:mrow><mml:mi>O</mml:mi><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:munder><mml:mo>∏</mml:mo><mml:mrow><mml:mi>g</mml:mi><mml:mo linebreak="badbreak">∈</mml:mo><mml:mi mathvariant="normal">Σ</mml:mi></mml:mrow></mml:munder><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>g</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>log</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mspace width="0.25em"/><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>g</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> time, where <inline-formula><mml:math id="M116" altimg="si49.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>g</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is the number of edges labeled as <italic>g</italic>. We observed that many non-Wheeler graphs can be recognized as such directly by the <italic>renaming heuristic</italic>, without requiring a downstream solver.</p>
        <p id="p0255">At each iteration, the algorithm gathers a list of sorted unique temporary orders of nodes that go into it, which we term the “in-node list.” By the Wheeler graph property that requires all edge pairs to satisfy <inline-formula><mml:math id="M117" altimg="si5.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>∧</mml:mo><mml:mi>u</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:msup><mml:mi>u</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after" stretchy="true">→</mml:mo><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, we can find rough orders by sorting the nodes by their in-node lists. Once this has been done for each node group, we reach the end of the current iteration and we check if the rough order changed since the previous iteration. If not, then we say the algorithm has converged and forward any remaining ambiguities to the downstream solver as necessary.</p>
        <p id="p0260">We note that there are similarities between the renaming heuristic and the “forward algorithm” of Alanko et al.<xref rid="bib17" ref-type="bibr"><sup>17</sup></xref> (Algorithm 2 in that paper). While our renaming heuristic performs an explicit sort within each of its rough grouping, the forward algorithm of Alanko et al. uses a pair of nested loops over alphabet characters to visit and partition the nodes in a way that maintains their sorted order implicitly. We discuss this relationship further in Discussion Discussion below.</p>
        <sec id="sec4.3.3.1">
          <title>Wheelie contains two solvers</title>
          <p id="p0265">Wheelie-PR and Wheelie-SMT. Wheelie-PR takes the output from the renaming heuristic and, for any remaining ties in the ordering, simply tries all possible permutations among the tied nodes. The Wheelie-SMT solver is explained in the next subsection Satisfiability Modulo Theories (SMT) solver.</p>
        </sec>
      </sec>
      <sec id="sec4.3.4">
        <title>Satisfiability Modulo Theories (SMT) solver</title>
        <p id="p0270">Motivated by the use of boolean satisfiability formulations to solve special cases of the recognition problem,<xref rid="bib15" ref-type="bibr"><sup>15</sup></xref> we hypothesized that Satisfiability Modulo Theory (SMT) solvers<xref rid="bib10" ref-type="bibr"><sup>10</sup></xref> could be used to solve all or part of the Wheeler-graph recognition problem. SMT has found many uses in artificial intelligence and formal methods for hardware and software development. As a generalization of the Boolean Satisfiability (SAT),<xref rid="bib16" ref-type="bibr"><sup>16</sup></xref> SMT allows us to encode the Wheeler graph properties in a fairly straightforward way, building from the propositional logic formulas in the definition.</p>
        <p id="p0275">An SMT problem decides the satisfiability of a first-order formula with respect to one or more background theories. A <italic>formula</italic> is a set of atoms connected by Boolean connectives (<inline-formula><mml:math id="M118" altimg="si50.gif"><mml:mrow><mml:mo>∧</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M119" altimg="si51.gif"><mml:mrow><mml:mo>∨</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M120" altimg="si52.gif"><mml:mrow><mml:mo>¬</mml:mo></mml:mrow></mml:math></inline-formula>), where an <italic>atom</italic> is a predicate which valuates to True or False given an assignment to the variables. A <italic>literal</italic> is either an atom or its negation. A <italic>theory</italic> gives special meanings, known as <italic>interpretations</italic>, to functions and predicate symbols within the theory. In this paper, we consider only the theory of Integer Difference Logic (IDL), which requires atoms to be of the form <inline-formula><mml:math id="M121" altimg="si53.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="M122" altimg="si54.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M123" altimg="si55.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are integer variables, <italic>c</italic> an integer constant, “<inline-formula><mml:math id="M124" altimg="si56.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo></mml:mrow></mml:math></inline-formula>” the integer subtraction function, and “<inline-formula><mml:math id="M125" altimg="si57.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo></mml:mrow></mml:math></inline-formula>” the usual binary ordering predicate. A theory solver decides the satisfiability of a conjunction of <italic>literals</italic>. In particular, an IDL theory solver can be implemented as the Bellman-Ford algorithm which runs in polynomial time. Incorporating a SAT solver and a theory solver, an SMT solver takes in a formula and outputs an assignment to the variables if the formula is satisfiable or otherwise reports unsatisfiability.</p>
        <p id="p0280">We observed that SMT is a natural way of encoding the Wheeler graph recognition problem. Firstly, for each node a variable is created representing the ordering of the node. Recalling the constraints, for all pairs of edges <inline-formula><mml:math id="M126" altimg="si1.gif"><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M127" altimg="si2.gif"><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msup><mml:mi>u</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math></inline-formula> labeled <italic>a</italic> and <inline-formula><mml:math id="M128" altimg="si3.gif"><mml:mrow><mml:msup><mml:mi>a</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> respectively: (i) <inline-formula><mml:math id="M129" altimg="si4.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≺</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after" stretchy="true">→</mml:mo><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, and (ii) <inline-formula><mml:math id="M130" altimg="si5.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>∧</mml:mo><mml:mi>u</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:msup><mml:mi>u</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after" stretchy="true">→</mml:mo><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>. By indexing the known labels lexicographically, we obtained an SMT formula containing constraints (i) and (ii), in which all atoms are of the form <inline-formula><mml:math id="M131" altimg="si58.gif"><mml:mrow><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> satisfying the IDL requirement. Note that the strict inequality <inline-formula><mml:math id="M132" altimg="si59.gif"><mml:mrow><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> can be rewritten using the the non-strict one as <inline-formula><mml:math id="M133" altimg="si60.gif"><mml:mrow><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Besides constraints (i) and (ii), we also enforced all-different constraints and range constraints for all nodes, which have the form <inline-formula><mml:math id="M134" altimg="si61.gif"><mml:mrow><mml:mn>1</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>. The node orderings can be obtained from the satisfying assignment by solving the SMT formula iff it is satisfiable. In Wheelie-SMT, we used Z3<xref rid="bib19" ref-type="bibr"><sup>19</sup></xref> as the underlying SMT solver.</p>
        <p id="p0285">As the number of constraints and variables are the main factors affecting runtime, simplifying the problem or providing additional information can improve performance. We noticed that the problem can be simplified using the rough order obtained from the <italic>renaming heuristic</italic> described in Section <xref rid="sec4.3.3" ref-type="sec">wheelie and the renaming heuristic</xref>. By adding the range information to the formula, notice that constraint (i) can be removed from the formula. Moreover, the all-different constraints of nodes from different groups can also be removed. The rationale is that if the graph was not reported non-Wheeler during the <italic>renaming heuristic</italic>, the range constraints provided by the procedure must automatically imply constraint (i). The benefits are 2-fold: not only the number of constraints is reduced, the search space is also significantly pruned.</p>
      </sec>
      <sec id="sec4.3.5">
        <title>WGT’s graph generating algorithms</title>
        <p id="p0290">We implemented five generators in Python scripts to produce tries, reverse deterministic graphs,<xref rid="bib6" ref-type="bibr"><sup>6</sup></xref> De Bruijn graphs and <italic>complete</italic> and <italic>d-NFA</italic> random Wheeler graphs. The first three generators take either DNA or protein multiple sequence alignments and produce the corresponding graph structures. As for the two random generators, users can produce a Wheeler graph given its <italic>n</italic>, <italic>e</italic>, and σ, and <italic>d-NFA</italic> random generator can further take <italic>d</italic>, which controls the most number of edges coming out from a node with the same label (<italic>d</italic>-NFA) as user input.</p>
        <p id="p0295">Tries and De Bruijn graphs are Wheeler graphs by definition. These generators start by removing gap placeholders from the multiple alignments. The trie generator iterates through the prefixes of each sequence in the multiple alignment, inserts characters into the trie and creates a new node at the end of a path if a prefix cannot be traversed from the source. Edges are labeled according to the label of the parent. The De Bruijn graph generator constructs a distinct <inline-formula><mml:math id="M135" altimg="si96.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>-mer dictionary from the sequences. It connects edges between adjacent two nodes and label the edge with the first character in the <inline-formula><mml:math id="M136" altimg="si96.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>-mer of the child node. Reverse deterministic graphs are usually invalid Wheeler graphs but might be valid when the graphs are small, and once violations occur, adding more nodes and edges cannot turn them back to Wheeler graphs.</p>
        <p id="p0300">The reverse deterministic graph generator iterates through columns of a multiple sequence alignments from right to left. At a column <italic>i</italic>, it creates distinct nodes for the characters found there, connecting them to the current node with the node of the previous ungapped character with the direction pointing to the end of the alignments and the label of the previous ungapped character. This follows the procedure described in the GCSA study.<xref rid="bib6" ref-type="bibr"><sup>6</sup></xref> Last, three generators initializes the names of nodes with the breadth first search orders and outputs the constructed graph in DOT format.</p>
        <p id="p0305">We also implemented two random generators, a <italic>complete</italic> Wheeler graph generator and a <italic>d-NFA</italic> Wheeler graph generator. We first fix the ordering of nodes and then try to select edges such that both user-specified constraints and Wheeler graph properties are satisfied. Let <inline-formula><mml:math id="M137" altimg="si97.gif"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the nodes with incoming edges labeled <italic>i</italic> and <inline-formula><mml:math id="M138" altimg="si98.gif"><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the edges labeled <italic>i</italic> where <inline-formula><mml:math id="M139" altimg="si99.gif"><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1,2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>σ</mml:mi></mml:mrow></mml:math></inline-formula>, and also let <inline-formula><mml:math id="M140" altimg="si100.gif"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true">|</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M141" altimg="si101.gif"><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true">|</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. In both generated graphs, we assume that <inline-formula><mml:math id="M142" altimg="si102.gif"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">≈</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>r</mml:mi></mml:mrow><mml:mi>σ</mml:mi></mml:mfrac></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M143" altimg="si103.gif"><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">≈</mml:mo><mml:mfrac><mml:mi>e</mml:mi><mml:mi>σ</mml:mi></mml:mfrac></mml:mrow></mml:math></inline-formula> where <italic>r</italic> is the number of nodes without incoming edges.</p>
        <p id="p0310">We say a Wheeler graph <italic>G</italic> is <italic>complete</italic> if no more edges can be added to <italic>G</italic> while maintaining the Wheeler graph properties.</p>
        <p id="p0315">Property 1. Given number of nodes n and number of labels σ, the number of edges of a Wheeler graph is upper bounded by <inline-formula><mml:math id="M144" altimg="si104.gif"><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi mathvariant="italic">max</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>
<italic>where</italic><disp-formula id="fd5"><label>(Equation 5)</label><mml:math id="M145" altimg="si105.gif"><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi mathvariant="italic">max</mml:mi></mml:msub><mml:mo linebreak="badbreak">=</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak">×</mml:mo><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak">+</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak">−</mml:mo><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak">−</mml:mo><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo linebreak="goodbreak">−</mml:mo><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></disp-formula></p>
        <p id="p0320">Proof. Consider the bipartite representation of a Wheeler graph <italic>G</italic> with number of nodes <italic>n</italic> and number of labels σ. Note that<disp-formula id="fd6"><label>(Equation 6)</label><mml:math id="M146" altimg="si106.gif"><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>σ</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak">−</mml:mo><mml:mi>r</mml:mi><mml:mtext>.</mml:mtext></mml:mrow></mml:mrow></mml:math></disp-formula></p>
        <p id="p0325">Observe that for each label <italic>i</italic>, the number of edges that is labeled <italic>i</italic> is at most <inline-formula><mml:math id="M147" altimg="si107.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Taking the sum of edges of each label and applying <xref rid="fd6" ref-type="disp-formula">Equation 6</xref>, we have<disp-formula id="fd7"><label>(Equation 7)</label><mml:math id="M148" altimg="si108.gif"><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi mathvariant="italic">max</mml:mi></mml:msub><mml:mo linebreak="badbreak">=</mml:mo><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>σ</mml:mi></mml:munderover><mml:mrow><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="badbreak">−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo linebreak="badbreak">=</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="badbreak">×</mml:mo><mml:mi>σ</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>σ</mml:mi><mml:mo linebreak="badbreak">+</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>σ</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="badbreak">=</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="badbreak">×</mml:mo><mml:mi>σ</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>σ</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>r</mml:mi><mml:mtext>.</mml:mtext></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p>
        <p id="p0330">One way of generating complete Wheeler graphs is to have all nodes connect to the first node of <inline-formula><mml:math id="M149" altimg="si97.gif"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and the last node additionally connect to the rest of the nodes in <inline-formula><mml:math id="M150" altimg="si97.gif"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for each label <italic>i</italic> (the last node has <inline-formula><mml:math id="M151" altimg="si109.gif"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> outgoing edges in total). By randomly selecting <inline-formula><mml:math id="M152" altimg="si110.gif"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> nodes from <italic>N</italic> and connecting the selected nodes to consecutive nodes in <inline-formula><mml:math id="M153" altimg="si97.gif"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, a new complete Wheeler graph can be generated by appropriately shifting the destination node of each edge such that the Wheeler graph property is maintained. <xref rid="mmc1" ref-type="supplementary-material">Figure S2</xref> shows an example of a complete Wheeler graph with <inline-formula><mml:math id="M154" altimg="si111.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>,</mml:mo><mml:mi>r</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mn>7,18,2,1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. With a complete Wheeler graph of <italic>n</italic> nodes and σ labels, we are able to generate random Wheeler graphs with <inline-formula><mml:math id="M155" altimg="si112.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi mathvariant="italic">max</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> edges by sampling <italic>e</italic> distinct edges from the complete Wheeler graph.</p>
        <p id="p0335">For generation of <italic>d</italic>-NFA Wheeler graphs, let <inline-formula><mml:math id="M156" altimg="si113.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the number of nodes with <italic>k</italic> outgoing edges of the same label <italic>i</italic>. Thus, given <italic>e</italic> and σ we have<disp-formula id="fd8"><label>(Equation 8)</label><mml:math id="M157" altimg="si114.gif"><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>d</mml:mi></mml:munderover><mml:mrow><mml:mi>k</mml:mi><mml:mo>⋅</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo linebreak="goodbreak">=</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></disp-formula>Also the number of nodes <inline-formula><mml:math id="M158" altimg="si109.gif"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> with incoming edges labeled <italic>i</italic> must be greater than the minimum number of nodes <inline-formula><mml:math id="M159" altimg="si115.gif"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi mathvariant="italic">min</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> needed to accommodate <inline-formula><mml:math id="M160" altimg="si116.gif"><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> edges. Thus, we have<disp-formula id="fd9"><label>(Equation 9)</label><mml:math id="M161" altimg="si117.gif"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi mathvariant="italic">min</mml:mi></mml:msub><mml:mo linebreak="badbreak">=</mml:mo><mml:mn>1</mml:mn><mml:mo linebreak="goodbreak">+</mml:mo><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">=</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mi>d</mml:mi></mml:munderover><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>⋅</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo linebreak="goodbreak">≤</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p>
        <p id="p0340">Note that any solution <inline-formula><mml:math id="M162" altimg="si113.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> that satisfies <xref rid="fd8" ref-type="disp-formula">Equations 8</xref> and <xref rid="fd9" ref-type="disp-formula">9</xref> for all edge label <italic>i</italic> represents a set of valid Wheeler graphs. To see this first notice that given <inline-formula><mml:math id="M163" altimg="si113.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we can always order the nodes such that <inline-formula><mml:math id="M164" altimg="si118.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> nodes with one outgoing edge are placed at the front, followed by <inline-formula><mml:math id="M165" altimg="si119.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> nodes with two outgoing edges, followed by <inline-formula><mml:math id="M166" altimg="si120.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> nodes with three outgoing edges and so on. By construction, this gives a valid <italic>d</italic>-NFA Wheeler graph. Moreover, by swapping the nodes and reconnecting the corresponding edges accordingly, different <italic>d</italic>-NFA Wheeler graphs can be obtained. An example is shown in <xref rid="mmc1" ref-type="supplementary-material">Figure S3</xref>.</p>
        <p id="p0345">To obtain a concrete instance, we find a valid solution for <inline-formula><mml:math id="M167" altimg="si113.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and then determine the node ordering. In our case, we set all <inline-formula><mml:math id="M168" altimg="si113.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to be the same, and if not possible assign the residual to <inline-formula><mml:math id="M169" altimg="si118.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> to satisfy <xref rid="fd8" ref-type="disp-formula">Equation 8</xref>. We believe that this reflects the hardness of different benchmarks with different d’s. For node ordering, all the nodes are shuffled and edges are distributed such that each node in <inline-formula><mml:math id="M170" altimg="si97.gif"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> has at least one incoming edge while maintaining the Wheeler properties.</p>
      </sec>
    </sec>
  </sec>
</body>
<back>
  <ref-list id="cebib0010">
    <title>References</title>
    <ref id="bib1">
      <label>1</label>
      <element-citation publication-type="book" id="sref1">
        <person-group person-group-type="author">
          <name>
            <surname>Ferragina</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <part-title>Opportunistic data structures with applications</part-title>
        <source>Proceedings 41st annual symposium on foundations of computer science</source>
        <year>2000</year>
        <fpage>390</fpage>
        <lpage>398</lpage>
      </element-citation>
    </ref>
    <ref id="bib2">
      <label>2</label>
      <element-citation publication-type="journal" id="sref2">
        <person-group person-group-type="author">
          <name>
            <surname>Garrison</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Sirén</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Novak</surname>
            <given-names>A.M.</given-names>
          </name>
          <name>
            <surname>Hickey</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Eizenga</surname>
            <given-names>J.M.</given-names>
          </name>
          <name>
            <surname>Dawson</surname>
            <given-names>E.T.</given-names>
          </name>
          <name>
            <surname>Jones</surname>
            <given-names>W.</given-names>
          </name>
          <name>
            <surname>Garg</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Markello</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Lin</surname>
            <given-names>M.F.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Variation graph toolkit improves read mapping by representing genetic variation in the reference</article-title>
        <source>Nat. Biotechnol.</source>
        <volume>36</volume>
        <year>2018</year>
        <fpage>875</fpage>
        <lpage>879</lpage>
        <pub-id pub-id-type="pmid">30125266</pub-id>
      </element-citation>
    </ref>
    <ref id="bib3">
      <label>3</label>
      <element-citation publication-type="journal" id="sref3">
        <person-group person-group-type="author">
          <name>
            <surname>Sirén</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Monlong</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Chang</surname>
            <given-names>X.</given-names>
          </name>
          <name>
            <surname>Novak</surname>
            <given-names>A.M.</given-names>
          </name>
          <name>
            <surname>Eizenga</surname>
            <given-names>J.M.</given-names>
          </name>
          <name>
            <surname>Markello</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Sibbesen</surname>
            <given-names>J.A.</given-names>
          </name>
          <name>
            <surname>Hickey</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Chang</surname>
            <given-names>P.C.</given-names>
          </name>
          <name>
            <surname>Carroll</surname>
            <given-names>A.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Pangenomics enables genotyping of known structural variants in 5202 diverse genomes</article-title>
        <source>Science</source>
        <volume>374</volume>
        <year>2021</year>
        <fpage>abg8871</fpage>
        <pub-id pub-id-type="pmid">34914532</pub-id>
      </element-citation>
    </ref>
    <ref id="bib4">
      <label>4</label>
      <element-citation publication-type="book" id="sref4">
        <person-group person-group-type="author">
          <name>
            <surname>Ferragina</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Luccio</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Muthukrishnan</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <part-title>Structuring labeled trees for optimal succinctness, and beyond</part-title>
        <source>46th Annual IEEE Symposium on Foundations of Computer Science (FOCS’05)</source>
        <year>2005</year>
        <fpage>184</fpage>
        <lpage>193</lpage>
      </element-citation>
    </ref>
    <ref id="bib5">
      <label>5</label>
      <element-citation publication-type="book" id="sref5">
        <person-group person-group-type="author">
          <name>
            <surname>Bowe</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Onodera</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Sadakane</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Shibuya</surname>
            <given-names>T.</given-names>
          </name>
        </person-group>
        <part-title>Succinct de bruijn graphs</part-title>
        <source>Algorithms in Bioinformatics: 12th International Workshop, WABI 2012, Ljubljana, Slovenia, September 10-12, 2012. Proceedings 12</source>
        <year>2012</year>
        <fpage>225</fpage>
        <lpage>235</lpage>
      </element-citation>
    </ref>
    <ref id="bib6">
      <label>6</label>
      <element-citation publication-type="journal" id="sref6">
        <person-group person-group-type="author">
          <name>
            <surname>Sirén</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Välimäki</surname>
            <given-names>N.</given-names>
          </name>
          <name>
            <surname>Mäkinen</surname>
            <given-names>V.</given-names>
          </name>
        </person-group>
        <article-title>Indexing graphs for path queries with applications in genome research</article-title>
        <source>IEEE/ACM Trans. Comput. Biol. Bioinform.</source>
        <volume>11</volume>
        <year>2014</year>
        <fpage>375</fpage>
        <lpage>388</lpage>
        <pub-id pub-id-type="pmid">26355784</pub-id>
      </element-citation>
    </ref>
    <ref id="bib7">
      <label>7</label>
      <element-citation publication-type="journal" id="sref7">
        <person-group person-group-type="author">
          <name>
            <surname>Kim</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Langmead</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>S.L.</given-names>
          </name>
        </person-group>
        <article-title>Hisat: a fast spliced aligner with low memory requirements</article-title>
        <source>Nat. Methods</source>
        <volume>12</volume>
        <year>2015</year>
        <fpage>357</fpage>
        <lpage>360</lpage>
        <pub-id pub-id-type="pmid">25751142</pub-id>
      </element-citation>
    </ref>
    <ref id="bib8">
      <label>8</label>
      <element-citation publication-type="journal" id="sref8">
        <person-group person-group-type="author">
          <name>
            <surname>Muggli</surname>
            <given-names>M.D.</given-names>
          </name>
          <name>
            <surname>Bowe</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Noyes</surname>
            <given-names>N.R.</given-names>
          </name>
          <name>
            <surname>Morley</surname>
            <given-names>P.S.</given-names>
          </name>
          <name>
            <surname>Belk</surname>
            <given-names>K.E.</given-names>
          </name>
          <name>
            <surname>Raymond</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Gagie</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Puglisi</surname>
            <given-names>S.J.</given-names>
          </name>
          <name>
            <surname>Boucher</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <article-title>Succinct colored de Bruijn graphs</article-title>
        <source>Bioinformatics</source>
        <volume>33</volume>
        <year>2017</year>
        <fpage>3181</fpage>
        <lpage>3187</lpage>
        <pub-id pub-id-type="pmid">28200001</pub-id>
      </element-citation>
    </ref>
    <ref id="bib9">
      <label>9</label>
      <element-citation publication-type="journal" id="sref9">
        <person-group person-group-type="author">
          <name>
            <surname>Gibney</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Thankachan</surname>
            <given-names>S.V.</given-names>
          </name>
        </person-group>
        <article-title>On the hardness and inapproximability of recognizing wheeler graphs</article-title>
        <comment>Preprint at</comment>
        <source>arXiv</source>
        <year>2019</year>
        <pub-id pub-id-type="doi">10.48550/arXiv.1902.01960</pub-id>
      </element-citation>
    </ref>
    <ref id="bib10">
      <label>10</label>
      <element-citation publication-type="book" id="sref10">
        <person-group person-group-type="author">
          <name>
            <surname>Barrett</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Sebastiani</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Seshia</surname>
            <given-names>S.A.</given-names>
          </name>
          <name>
            <surname>Tinelli</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <part-title>Satisfiability Modulo Theories</part-title>
        <person-group person-group-type="editor">
          <name>
            <surname>Biere</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>van Maaren</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Walsh</surname>
            <given-names>T.</given-names>
          </name>
        </person-group>
        <source>Handbook of satisfiability</source>
        <year>2009</year>
        <publisher-name>IOS Press</publisher-name>
        <fpage>825</fpage>
        <lpage>885</lpage>
      </element-citation>
    </ref>
    <ref id="bib11">
      <label>11</label>
      <element-citation publication-type="journal" id="sref11">
        <person-group person-group-type="author">
          <name>
            <surname>Gagie</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Sirén</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>Wheeler graphs: a framework for bwt-based data structures</article-title>
        <source>Theor. Comput. Sci.</source>
        <volume>698</volume>
        <year>2017</year>
        <fpage>67</fpage>
        <lpage>78</lpage>
        <pub-id pub-id-type="pmid">29276331</pub-id>
      </element-citation>
    </ref>
    <ref id="bib12">
      <label>12</label>
      <element-citation publication-type="journal" id="sref12">
        <person-group person-group-type="author">
          <name>
            <surname>Cunningham</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Allen</surname>
            <given-names>J.E.</given-names>
          </name>
          <name>
            <surname>Allen</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Alvarez-Jarreta</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Amode</surname>
            <given-names>M.R.</given-names>
          </name>
          <name>
            <surname>Armean</surname>
            <given-names>I.M.</given-names>
          </name>
          <name>
            <surname>Austine- Orimoloye</surname>
            <given-names>O.</given-names>
          </name>
          <name>
            <surname>Azov</surname>
            <given-names>A.G.</given-names>
          </name>
          <name>
            <surname>Barnes</surname>
            <given-names>I.</given-names>
          </name>
          <name>
            <surname>Bennett</surname>
            <given-names>R.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Ensembl 2022</article-title>
        <source>Nucleic Acids Res.</source>
        <volume>50</volume>
        <year>2022</year>
        <fpage>D988</fpage>
        <lpage>D995</lpage>
        <pub-id pub-id-type="pmid">34791404</pub-id>
      </element-citation>
    </ref>
    <ref id="bib13">
      <label>13</label>
      <element-citation publication-type="book" id="sref13">
        <person-group person-group-type="author">
          <name>
            <surname>Ellson</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Gansner</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Koutsofios</surname>
            <given-names>L.</given-names>
          </name>
          <name>
            <surname>North</surname>
            <given-names>S.C.</given-names>
          </name>
          <name>
            <surname>Woodhull</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <part-title>Graphviz—open source graph drawing tools</part-title>
        <source>International Symposium on Graph Drawing</source>
        <year>2001</year>
        <fpage>483</fpage>
        <lpage>484</lpage>
      </element-citation>
    </ref>
    <ref id="bib14">
      <label>14</label>
      <element-citation publication-type="journal" id="sref14">
        <person-group person-group-type="author">
          <name>
            <surname>Boucher</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Gagie</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Kuhnle</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Langmead</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Mun</surname>
            <given-names>T.</given-names>
          </name>
        </person-group>
        <article-title>Prefix-free parsing for building big BWTs</article-title>
        <source>Algorithm Mol. Biol.</source>
        <volume>14</volume>
        <year>2019</year>
        <fpage>13</fpage>
      </element-citation>
    </ref>
    <ref id="bib15">
      <label>15</label>
      <element-citation publication-type="book" id="sref15">
        <person-group person-group-type="author">
          <name>
            <surname>Alanko</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>D’Agostino</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Policriti</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Prezza</surname>
            <given-names>N.</given-names>
          </name>
        </person-group>
        <part-title>Regular languages meet prefix sorting</part-title>
        <source>Proceedings of the Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms</source>
        <year>2020</year>
        <fpage>911</fpage>
        <lpage>930</lpage>
      </element-citation>
    </ref>
    <ref id="bib16">
      <label>16</label>
      <element-citation publication-type="book" id="sref16">
        <person-group person-group-type="author">
          <name>
            <surname>Biere</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Heule</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>van Maaren</surname>
            <given-names>H.</given-names>
          </name>
        </person-group>
        <series>Handbook of Satisfiability</series>
        <volume>Vol 185</volume>
        <year>2009</year>
        <publisher-name>IOS press</publisher-name>
      </element-citation>
    </ref>
    <ref id="bib17">
      <label>17</label>
      <element-citation publication-type="journal" id="sref17">
        <person-group person-group-type="author">
          <name>
            <surname>Alanko</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>D’Agostino</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Policriti</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Prezza</surname>
            <given-names>N.</given-names>
          </name>
        </person-group>
        <article-title>Wheeler languages</article-title>
        <source>Inf. Comput.</source>
        <volume>281</volume>
        <year>2021</year>
        <fpage>104820</fpage>
      </element-citation>
    </ref>
    <ref id="bib18">
      <label>18</label>
      <element-citation publication-type="book" id="sref18">
        <person-group person-group-type="author">
          <name>
            <surname>Barbosa</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Barrett</surname>
            <given-names>C.W.</given-names>
          </name>
          <name>
            <surname>Brain</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Kremer</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Lachnitt</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Mann</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Mohamed</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Mohamed</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Niemetz</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>N' otzli</surname>
            <given-names>A.</given-names>
          </name>
          <etal/>
        </person-group>
        <part-title>Cvc5: a versatile and industrial-strength SMT solver</part-title>
        <source>28th International Conference on Tools and Algorithms for the Construction and Analysis of Systems</source>
        <year>2022</year>
        <publisher-name>TACAS, 2022</publisher-name>
        <fpage>415</fpage>
        <lpage>442</lpage>
      </element-citation>
    </ref>
    <ref id="bib19">
      <label>19</label>
      <element-citation publication-type="book" id="sref19">
        <person-group person-group-type="author">
          <name>
            <surname>de Moura</surname>
            <given-names>L.M.</given-names>
          </name>
          <name>
            <surname>Bjorner</surname>
            <given-names>N.S.</given-names>
          </name>
        </person-group>
        <part-title>Z3: an efficient SMT solver</part-title>
        <source>Proc. 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems</source>
        <year>2008</year>
        <publisher-name>TACAS 2008</publisher-name>
        <fpage>337</fpage>
        <lpage>340</lpage>
      </element-citation>
    </ref>
    <ref id="bib20">
      <label>20</label>
      <element-citation publication-type="book" id="sref20">
        <person-group person-group-type="author">
          <name>
            <surname>Pimpalkhare</surname>
            <given-names>N.</given-names>
          </name>
          <name>
            <surname>Mora</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Polgreen</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Seshia</surname>
            <given-names>S.A.</given-names>
          </name>
        </person-group>
        <part-title>MedleySolver: Online SMT algorithm selection</part-title>
        <source>24th International Conference on Theory and Applications of Satisfiability Testing (SAT)</source>
        <volume>12831</volume>
        <year>2021</year>
        <fpage>453</fpage>
        <lpage>470</lpage>
      </element-citation>
    </ref>
  </ref-list>
  <sec id="appsec2" sec-type="supplementary-material">
    <title>Supplemental information</title>
    <p id="p0370">
      <supplementary-material content-type="local-data" id="mmc1">
        <caption>
          <title>Document S1. Figures S1–S3 and Table S1</title>
        </caption>
        <media xlink:href="mmc1.pdf"/>
      </supplementary-material>
    </p>
  </sec>
  <sec sec-type="data-availability" id="da0010">
    <title>Data and code availability</title>
    <p id="p0030">
      <list list-type="simple" id="ulist0015">
        <list-item id="u0030">
          <label>•</label>
          <p id="p0035">All original code has been deposited at Zenodo and is publicly available as of the date of publication. DOIs are listed in the <xref rid="sec4.1" ref-type="sec">key resources table</xref>.</p>
        </list-item>
        <list-item id="u0035">
          <label>•</label>
          <p id="p0040">The experimental datasets are listed in the <xref rid="sec4.1" ref-type="sec">key resources table</xref>.</p>
        </list-item>
        <list-item id="u0040">
          <label>•</label>
          <p id="p0045">WGT is publicly available at <ext-link ext-link-type="uri" xlink:href="https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit" id="intref0015">https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit</ext-link>.</p>
        </list-item>
      </list>
    </p>
  </sec>
  <ack id="ack0010">
    <title>Acknowledgments</title>
    <p id="p0350">We thank Markus J. Sommer for proposing the name Wheelie. We thank Nicola Prezza, Nicola Cotumaccio, Travis Gagie, and Christina Boucher for helpful comments. Funding This research was supported in part by the <funding-source id="gs1">U.S. National Institutes of Health</funding-source> under grant R0I-HG006677 and grants R35GM139602 and R01HG011392 to B.L. This work was also supported by the <funding-source id="gs2">U.S. National Science Foundation</funding-source> under grant DBI-1759518, and by a Berkeley Fellowship.</p>
    <sec id="sec5">
      <title>Author contributions</title>
      <p id="p0355">K.C., P.C., and B.L. designed the method. K.C. and P.C. wrote the software and performed the experiments. K.C., P.C., S.A.S., and B.L. wrote the manuscript. All authors read and approved the final manuscript.</p>
    </sec>
    <sec sec-type="COI-statement" id="sec6">
      <title>Declaration of interests</title>
      <p id="p0360">The authors declare no competing interests.</p>
    </sec>
  </ack>
  <fn-group>
    <fn id="appsec1" fn-type="supplementary-material">
      <p id="p0365">Supplemental information can be found online at <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.isci.2023.107402" id="intref0065">https://doi.org/10.1016/j.isci.2023.107402</ext-link>.</p>
    </fn>
  </fn-group>
</back>
<?DTDIdentifier.IdentifierValue -//ES//DTD journal article DTD version 5.6.0//EN//XML?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName art560.dtd?>
<?SourceDTD.Version 5.6.0?>
<?ConverterInfo.XSLTName elsevier2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<?origin publisher?>
<?FILEmeta_ISCI107402 xml ?>
<?FILEmain xml ?>
<?FILEmain pdf ?>
<?FILEgr1 jpg ?>
<?FILEgr2 jpg ?>
<?FILEgr3 jpg ?>
<?FILEgr4 jpg ?>
<?FILEgr5 jpg ?>
<?FILEgr6 jpg ?>
<?FILEgr7 jpg ?>
<?FILEfx1 jpg ?>
<?FILEmmc1 pdf ?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">iScience</journal-id>
    <journal-id journal-id-type="iso-abbrev">iScience</journal-id>
    <journal-title-group>
      <journal-title>iScience</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2589-0042</issn>
    <publisher>
      <publisher-name>Elsevier</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10415921</article-id>
    <article-id pub-id-type="pii">S2589-0042(23)01479-7</article-id>
    <article-id pub-id-type="doi">10.1016/j.isci.2023.107402</article-id>
    <article-id pub-id-type="publisher-id">107402</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>WGT: Tools and algorithms for recognizing, visualizing, and generating Wheeler graphs</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" id="au1">
        <name>
          <surname>Chao</surname>
          <given-names>Kuan-Hao</given-names>
        </name>
        <email>kh.chao@cs.jhu.edu</email>
        <xref rid="aff1" ref-type="aff">1</xref>
        <xref rid="fn1" ref-type="fn">3</xref>
        <xref rid="cor1" ref-type="corresp">∗</xref>
      </contrib>
      <contrib contrib-type="author" id="au2">
        <name>
          <surname>Chen</surname>
          <given-names>Pei-Wei</given-names>
        </name>
        <xref rid="aff2" ref-type="aff">2</xref>
        <xref rid="fn1" ref-type="fn">3</xref>
      </contrib>
      <contrib contrib-type="author" id="au3">
        <name>
          <surname>Seshia</surname>
          <given-names>Sanjit A.</given-names>
        </name>
        <xref rid="aff2" ref-type="aff">2</xref>
      </contrib>
      <contrib contrib-type="author" id="au4">
        <name>
          <surname>Langmead</surname>
          <given-names>Ben</given-names>
        </name>
        <email>langmea@cs.jhu.edu</email>
        <xref rid="aff1" ref-type="aff">1</xref>
        <xref rid="fn2" ref-type="fn">4</xref>
        <xref rid="cor2" ref-type="corresp">∗∗</xref>
      </contrib>
      <aff id="aff1"><label>1</label>Department of Computer Science, Johns Hopkins University, Baltimore, MD 21218, USA</aff>
      <aff id="aff2"><label>2</label>Department of Electrical Engineering and Computer Sciences, University of California, Berkeley, Berkeley, CA 94720, USA</aff>
    </contrib-group>
    <author-notes>
      <corresp id="cor1"><label>∗</label>Corresponding author <email>kh.chao@cs.jhu.edu</email></corresp>
      <corresp id="cor2"><label>∗∗</label>Corresponding author <email>langmea@cs.jhu.edu</email></corresp>
      <fn id="fn1">
        <label>3</label>
        <p id="ntpara0010">These authors contributed equally</p>
      </fn>
      <fn id="fn2">
        <label>4</label>
        <p id="ntpara0015">Lead contact</p>
      </fn>
    </author-notes>
    <pub-date pub-type="pmc-release">
      <day>14</day>
      <month>7</month>
      <year>2023</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on <pub-date
						pub-type="epub">.-->
    <pub-date pub-type="collection">
      <day>18</day>
      <month>8</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>14</day>
      <month>7</month>
      <year>2023</year>
    </pub-date>
    <volume>26</volume>
    <issue>8</issue>
    <elocation-id>107402</elocation-id>
    <history>
      <date date-type="received">
        <day>29</day>
        <month>4</month>
        <year>2023</year>
      </date>
      <date date-type="rev-recd">
        <day>29</day>
        <month>6</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>12</day>
        <month>7</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2023 The Author(s)</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).</license-p>
      </license>
    </permissions>
    <abstract id="abs0010">
      <title>Summary</title>
      <p>A Wheeler graph represents a collection of strings in a way that is particularly easy to index and query. Such a graph is a practical choice for representing a graph-shaped pangenome, and it is the foundation for current graph-based pangenome indexes. However, there are no practical tools to visualize or to check graphs that may have the Wheeler properties. Here, we present Wheelie, an algorithm that combines a <italic>renaming heuristic</italic> with a permutation solver (Wheelie-PR) or a Satisfiability Modulo Theory (SMT) solver (Wheelie-SMT) to check whether a given graph has the Wheeler properties, a problem that is NP-complete in general. Wheelie can check a variety of random and real-world graphs in far less time than any algorithm proposed to date. It can check a graph with 1,000s of nodes in seconds. We implement these algorithms together with complementary visualization tools in the WGT toolkit, available as open source software at <ext-link ext-link-type="uri" xlink:href="https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit" id="intref0010">https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit</ext-link>.</p>
    </abstract>
    <abstract abstract-type="graphical" id="abs0015">
      <title>Graphical abstract</title>
      <fig id="undfig1" position="anchor">
        <graphic xlink:href="fx1"/>
      </fig>
    </abstract>
    <abstract abstract-type="author-highlights" id="abs0020">
      <title>Highlights</title>
      <p>
        <list list-type="simple" id="ulist0010">
          <list-item id="u0010">
            <label>•</label>
            <p id="p0010">Wheeler graphs are the basis of many pangenome and other sequence analysis tools</p>
          </list-item>
          <list-item id="u0015">
            <label>•</label>
            <p id="p0015">The WGT generates, recognizes, and visualizes Wheeler graphs</p>
          </list-item>
          <list-item id="u0020">
            <label>•</label>
            <p id="p0020">WGT’s Wheelie algorithm efficiently distinguishes Wheeler and non-Wheeler graphs</p>
          </list-item>
          <list-item id="u0025">
            <label>•</label>
            <p id="p0025">WGT’s bipartite Wheeler graph visualizer illustrates Wheeler graphs orderings</p>
          </list-item>
        </list>
      </p>
    </abstract>
    <abstract abstract-type="teaser" id="abs0025">
      <p>Bioinformatics; Algorithms; Data structure</p>
    </abstract>
    <kwd-group id="kwrds0010">
      <title>Subject areas</title>
      <kwd>Bioinformatics</kwd>
      <kwd>Algorithms</kwd>
      <kwd>Data structure</kwd>
    </kwd-group>
  </article-meta>
  <notes>
    <p id="misc9010">Published: July 14, 2023</p>
  </notes>
</front>
<body>
  <sec id="sec1">
    <title>Introduction</title>
    <p id="p0050">A Wheeler graph is a class of directed, edge-labeled graph that is particularly easy to index and query. It is a generalization of the Burrows-Wheeler-Transform (BWT)-based FM index,<xref rid="bib1" ref-type="bibr"><sup>1</sup></xref> and partly forms the basis for existing pangenome alignment tools such as vg.<xref rid="bib2" ref-type="bibr"><sup>2</sup></xref><sup>,</sup><xref rid="bib3" ref-type="bibr"><sup>3</sup></xref></p>
    <p id="p0055">A graph is a Wheeler graph when its nodes can be totally ordered according to the co-lexicographical order of the sets of strings spelled out on all paths leading into the nodes. Formally: an edge-labeled, directed graph is a Wheeler graph if and only if there exists a total ordering over its nodes such that 0-indegree nodes come before all other nodes in the ordering, and for all pairs of edges, <inline-formula><mml:math id="M1" altimg="si1.gif"><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M2" altimg="si2.gif"><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msup><mml:mi>u</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math></inline-formula> labeled <italic>a</italic> and <inline-formula><mml:math id="M3" altimg="si3.gif"><mml:mrow><mml:msup><mml:mi>a</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, respectively: (i) <inline-formula><mml:math id="M4" altimg="si4.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≺</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after" stretchy="true">→</mml:mo><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, and (ii) <inline-formula><mml:math id="M5" altimg="si5.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>∧</mml:mo><mml:mi>u</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:msup><mml:mi>u</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after" stretchy="true">→</mml:mo><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
    <p id="p0060">Many graph- and tree-shaped structures relevant to genomics either have the Wheeler graph properties or can be modified to have them. These include certain trees (via the XBWT),<xref rid="bib4" ref-type="bibr"><sup>4</sup></xref> De Bruijn graphs,<xref rid="bib5" ref-type="bibr"><sup>5</sup></xref> and reverse deterministic graphs derived from multiple alignments.<xref rid="bib6" ref-type="bibr"><sup>6</sup></xref> The discovery of this unified definition of Wheeler graphs will help researchers to develop still more BWT variants, e.g., for pangenome indexing. For instance, the GCSA study proposed building a reverse deterministic graph from a multiple alignment, then modifying the graph through a repeated path doubling procedure, ultimately yielding a Wheeler graph.<xref rid="bib6" ref-type="bibr"><sup>6</sup></xref> This approach can generate smaller graphs while preserving genome coordinates, compared to the more widely used De Bruijn graph, as demonstrated in <xref rid="mmc1" ref-type="supplementary-material">Figure S3</xref>.</p>
    <p id="p0065">Despite the utility of the the Wheeler graphs mentioned previously,<xref rid="bib2" ref-type="bibr"><sup>2</sup></xref><sup>,</sup><xref rid="bib6" ref-type="bibr"><sup>6</sup></xref><sup>,</sup><xref rid="bib7" ref-type="bibr"><sup>7</sup></xref><sup>,</sup><xref rid="bib8" ref-type="bibr"><sup>8</sup></xref> there are no tools or libraries that make it easy to use Wheeler graphs or to check if a particular graph has the requisite properties. This problem is NP-complete in general and hard to approximate.<xref rid="bib9" ref-type="bibr"><sup>9</sup></xref> An exponential-time algorithm was proposed by Gibney &amp; Thanckachan,<xref rid="bib9" ref-type="bibr"><sup>9</sup></xref> but no implementation is available.</p>
    <p id="p0070">We present Wheeler graph toolkit (WGT), an open source suite for generating, recognizing, and visualizing Wheeler graphs. WGT includes functionality for generating graphs that do or do not have the Wheeler properties. Two generators produce De Bruijn graphs and tries derived from one or more input sequences provided as FASTA. Another generator produces reverse deterministic graphs<xref rid="bib6" ref-type="bibr"><sup>6</sup></xref> from multiple sequence alignments. A fourth generator produces random graphs parameterized by the desired number of nodes, edges, distinct edge labels (i.e., alphabet size), and the most number of outgoing same-label edges.</p>
    <p id="p0075">Central to WGT is the fast Wheelie algorithm for Wheeler graph recognition. The algorithm combines a <italic>renaming heuristic</italic> with two alternate solvers, both capable of reaching exact solutions to the recognition problem. One solver uses an exhaustive search over possible node permutations, and the other uses a Satisfiability Modulo Theory (SMT) solver.<xref rid="bib10" ref-type="bibr"><sup>10</sup></xref> We call the overall algorithm “Wheelie”, while we use the names “Wheelie-Pr” and “Wheelie-SMT” for the versions that use the permutation and SMT solvers, respectively. When run on a Wheeler graph, Wheelie also reports a node ordering for which the properties are satisfied and indexes the graph into <italic>O</italic>, <italic>I</italic>, and <italic>L</italic> three bitarrays,<xref rid="bib11" ref-type="bibr"><sup>11</sup></xref> which are useful inputs to a downstream tool for pattern matching.</p>
    <p id="p0080">Here, we benchmark Wheelie’s solvers in comparison to each other and to the algorithm proposed by Gibney and Thankachan.<xref rid="bib9" ref-type="bibr"><sup>9</sup></xref> We benchmark with a variety of input graphs, including graphs derived from real multiple alignments of DNA and protein sequences. We also use randomly generated graphs with various configurable characteristics. Finally, we implement and demonstrate a visualizer that allows the user to picture the graph in light of the Wheeler properties.</p>
    <p id="p0085">In the following, <italic>G</italic> denotes a directed graph, <italic>N</italic> its set of nodes, and <italic>E</italic> its set of edges, with <inline-formula><mml:math id="M6" altimg="si6.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>N</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M7" altimg="si7.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. <inline-formula><mml:math id="M8" altimg="si8.gif"><mml:mrow><mml:mi mathvariant="normal">Σ</mml:mi></mml:mrow></mml:math></inline-formula> denotes the set of edge labels appearing on at least one edge, with <inline-formula><mml:math id="M9" altimg="si9.gif"><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="normal">Σ</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
  </sec>
  <sec id="sec2">
    <title>Results</title>
    <p id="p0090">Graphs used for evaluation were generated using WGT’s generator algorithms, which can produce (a) De Bruijn graphs, (b) tries, (c) a reverse deterministic graphs derived from a multiple alignments, (d) <italic>complete</italic> random Wheeler graphs, and (e) a <italic>d-NFA</italic> random Wheeler graphs. All are discussed further in <xref rid="sec4" ref-type="sec">STAR methods</xref> WGT’s graph generating algorithms, and in <xref rid="mmc1" ref-type="supplementary-material">Figures S1</xref> and <xref rid="mmc1" ref-type="supplementary-material">S2</xref>. For graphs that start from biological sequences, we randomly selected 25 genes and downloaded their DNA and protein ortholog alignments in FASTA format from the Ensembl Comparative Genomics REST API<xref rid="bib12" ref-type="bibr"><sup>12</sup></xref> at <ext-link ext-link-type="uri" xlink:href="https://rest.ensembl.org/documentation/info/genomic_alignment_region" id="intref0020">https://rest.ensembl.org/documentation/info/genomic_alignment_region</ext-link>. All the experiments are conducted on a 24-core, 48-thread Intel(R) Xeon(R) Gold 6248R Linux computer with 1024 GB memory, using a single thread of execution.</p>
    <sec id="sec2.1">
      <title>Comparing Wheelie with Gibney &amp; Thanckachan</title>
      <p id="p0095">Gibney and Thankachan’s recognition algorithm<xref rid="bib9" ref-type="bibr"><sup>9</sup></xref> (henceforth “G &amp; T”) works by enumerating all possible values for the <italic>O</italic>, <italic>I</italic>, and <italic>L</italic> arrays making up the Wheeler graph structure as described by Gagie et al.<xref rid="bib11" ref-type="bibr"><sup>11</sup></xref> The <italic>O</italic> bitarray is a concatenation of unary codes describing the outdegrees of each node. <italic>I</italic> is a similar bitarray that does the same for indegrees. <italic>L</italic> is a sequence of characters labeling the edges in the order they appear in the <italic>O</italic> array. Further, the inner loop of the algorithm must check if a given assignment for <italic>I</italic>, <italic>O</italic>, and <italic>L</italic> is isomorphic to the input graph provided.</p>
      <p id="p0100">While the G &amp; T algorithm explores an exponential-sized space, Wheelie explores the factorial-sized space of node permutations. To consider how this affects the size of an exhaustive search, we compared the search space for the worst-case scenarios for both algorithms in <xref rid="mmc1" ref-type="supplementary-material">Table S1</xref>. We hypothesized that Wheelie could be made faster with the help of strategies for pruning the search space. Wheelie prunes its search by assigning labels to nodes according to their <italic>rough</italic> positions in the order, a strategy we call the “<italic>renaming heuristic</italic>”. This allows Wheelie to arrive rapidly at a rough ordering that either (a) reveals a conflict that prevents the graph from having the Wheeler properties or (b) reduces the problem size for the downstream solving algorithm. An 8-node example illustrating the renaming heuristic is shown in <xref rid="fig1" ref-type="fig">Figure 1</xref>, and the full algorithm is described in <xref rid="sec4" ref-type="sec">STAR methods</xref>
<xref rid="sec4.3.3" ref-type="sec">wheelie and the renaming heuristic</xref>, <xref rid="sec4.3.4" ref-type="sec">satisfiability modulo theories (SMT) solver</xref>. Here, we use a version of the algorithm called Wheelie-Pr, which begins with the <italic>renaming heuristic</italic> then resolves remaining ambiguities by exhaustively searching over the remaining node permutations. Unlike G &amp; T, the Wheelie-Pr algorithm does not need to compute graph isomorphsims.<fig id="fig1"><label>Figure 1</label><caption><p>Illustration of the <italic>renaming heuristic</italic></p><p>(A) An 8-node graph with nodes divided into four groups according to in-coming edge label (with <italic>O</italic> representing 0-indegree nodes).</p><p>(B) presents the workflow of the <italic>renaming heuristic</italic>. The first table in (B) shows the initialized in-node lists for eight nodes. After initialization, the algorithm sorts and relabels nodes in each group until convergence. Then, it passes the range information to either Wheelie-Pr or Wheelie-SMT.</p></caption><graphic xlink:href="gr1"/></fig></p>
      <p id="p0105">We conducted a 30-s timeout test on both algorithms using graphs generated from four generators (WGT’s graph generating algorithms) including both Wheeler and non-Wheeler graphs. Rather than implement G &amp; T’s entire algorithm, we implemented the enumeration of the <italic>I</italic>, <italic>O</italic>, and <italic>L</italic> arrays but omitted the graph isomorphism check in the inner loop. We reasoned that if Wheelie-Pr was faster than the G &amp; T algorithm without the (rather complex) isomorphism check, it would also be faster than the full G &amp; T algorithm. To compare the algorithms, we configured both to perform an exhaustive search, without the possibility of early stopping if a solution is found. This differs from Wheelie-Pr’s default behavior, which allows it to stop upon finding a node ordering for which the Wheeler properties are satisfied. Early stopping is still possible for Wheelie-Pr in these experiments, since it might identify a conflict that proves the graph is non-Wheeler.</p>
      <p id="p0110">We took 25 multiple ortholog alignments, both their DNA and amino acid (AA) sequences, and extracted the first 4 rows of each. To reduce graph size, we truncated the graphs with respect to the multiple-alignment columns. We tested on three types of graphs, De Bruijn graphs, tries, and random Wheeler graphs, that are known Wheeler graphs, and two types of graphs, pseudo-De Bruijn graphs and reverse deterministic graphs, that are not guaranteed Wheeler graphs. Pseudo-De Bruijn graphs are graphs where the nodes correspond to k-1-mers in the multiple alignment, but where we do not collapse identical k-1-mers into single nodes.</p>
      <p id="p0115">For De Bruijn graphs and pseudo-De Bruijn graphs, we took columns 1 to 200 and set <italic>k</italic> to 3 to 9; for tries, we took columns 1 to 200; for reverse deterministic graphs, we took columns 2 to 41. We also benchmarked with a series of randomly generated graphs with <italic>n</italic> set to 3 to 33, <italic>e</italic> from 3 to <italic>n</italic>, and σ from 1 to 21. The number of each type of graphs and their node and edge numbers are shown in <xref rid="fig2" ref-type="fig">Figure 2</xref>B, and the arguments of each generator can be found in the WGT Github repository: <ext-link ext-link-type="uri" xlink:href="https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit" id="intref0025">https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit</ext-link>.<fig id="fig2"><label>Figure 2</label><caption><p>The results of comparing Wheelie-PR and G &amp; T algorithm</p><p>(A) Recognition time comparison between Wheelie-Pr exhaustive search and the G &amp; T algorithm using (1) De Bruijn graphs, (2) tries, (3) pseudo-De Bruijn graphs and (4) reverse deterministic graphs generated from DNA and protein alignments, and (5) random graphs generated with given <italic>n</italic>, <italic>e</italic>, and σ. Wheelie-Pr recognition time is on the y axis, and G &amp; T recognition time on the x axis, both on a <inline-formula><mml:math id="M10" altimg="si38.gif"><mml:mrow><mml:msub><mml:mi>log</mml:mi><mml:mn>10</mml:mn></mml:msub><mml:mtext>microsecond</mml:mtext></mml:mrow></mml:math></inline-formula> scale. Each dot represents a graph. Dots beyond the red lines denote inputs for which the tool timed out after 30 s.</p><p>(B) The graph number, timeout graph number of Wheelie-Pr and the G &amp; T algorithm, and ranges of node and edge number of each type of graphs. Rows in green describe graphs that are guaranteed Wheeler. Rows in red describe graphs that are not guaranteed to be Wheeler; i.e., some instances are Wheeler and some are not.</p></caption><graphic xlink:href="gr2"/></fig></p>
      <p id="p0120"><xref rid="fig2" ref-type="fig">Figure 2</xref>A shows that Wheelie-Pr is significantly faster, allowing it to recognize a range of Wheeler and non-Wheeler graphs. Wheelie-Pr runtimes generally range from 100 to 1,000 μs, with 784 random-graph inputs causing Wheelie-Pr to time out. In sum, the only type of graph that caused Wheelie-Pr to time out is the random graph whereas 8,461 graphs distributed in all types of benchmarked graphs caused G &amp; T to time out.</p>
    </sec>
    <sec id="sec2.2">
      <title>Visualizing and characterizing challenging graphs</title>
      <p id="p0125">We selected a De Bruijn graph with edges being k-mers and nodes being k-1-mers where <inline-formula><mml:math id="M11" altimg="si10.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> from the <xref rid="fig2" ref-type="fig">Figure 2</xref> benchmarks. This graph was derived from the first four rows of the multiple alignment of STAU2 DNA orthologs with sequence length 4. We first visualized it using Graphviz<xref rid="bib13" ref-type="bibr"><sup>13</sup></xref> (<xref rid="fig3" ref-type="fig">Figure 3</xref>A). We ran Wheelie-Pr to find an ordering for which the Wheeler properties hold (<xref rid="fig3" ref-type="fig">Figure 3</xref>B). Finally, we visualized the graph using WGT’s Python-based visualizer, which draws the ordered nodes in two replicas, with outgoing edges leaving one replica (<xref rid="fig4" ref-type="fig">Figure 4</xref>, top rows) and entering the other (bottom rows). For a valid Wheeler ordering, nodes with no incoming edges will appear leftmost, nodes with incoming edges of the smallest character will come next, nodes with incoming edges of the next-smallest character next, etc. Further, no two same-color edges will cross each other. In this way, the diagram, first described by Boucher et al.,<xref rid="bib14" ref-type="bibr"><sup>14</sup></xref> makes it visually obvious when an ordering has yielded the Wheeler properties.<fig id="fig3"><label>Figure 3</label><caption><p>WGT recognition and visualization results of an <italic>k=4</italic> De Bruijn graph</p><p>(A) A <inline-formula><mml:math id="M12" altimg="si10.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> De Bruijn graph outputted from WGT’s De Bruijn graph generator. It is the visualization from Graphviz online visualizer.</p><p>(B) The recognition result showing the Wheeler ordering outputted from Wheelie-Pr.</p><p>(C) The output from WGT’s visualizer. Nodes are duplicated into two rows ordered in Wheeler ordering.</p></caption><graphic xlink:href="gr3"/></fig><fig id="fig4"><label>Figure 4</label><caption><p>The results of WGT visualizer on d-NFAs with different numbers of labels</p><p>Examples of (A) 2-NFA with 1 label (B) 2-NFA with 2 labels (C) 2-NFA with 3 labels (D) 3-NFA with 1 label, from outlier random graphs (blue dots) in <xref rid="fig2" ref-type="fig">Figure 2</xref>.</p></caption><graphic xlink:href="gr4"/></fig></p>
      <p id="p0130">We sought to understand which graphs require the most time for recognition. After investigating the “outlier” graphs where Wheelie-PR timed out with these tools, we found that the graphs requiring the most recognition time tended to have nodes with many outgoing same-label edges. Following Alanko et al.,<xref rid="bib15" ref-type="bibr"><sup>15</sup></xref> we use the term <italic>d</italic>-NFA to describe a Wheeler graph where all nodes have <inline-formula><mml:math id="M13" altimg="si11.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula> outgoing same-label edges, and at least one node has exactly <italic>d</italic> outgoing same-label edges. The De Bruijn graph shown in <xref rid="fig3" ref-type="fig">Figure 3</xref> is a 1-NFA. <xref rid="fig4" ref-type="fig">Figures 4</xref>A–4C are 2-NFAs with σ equal to 1, 2, and 3, respectively. <xref rid="fig4" ref-type="fig">Figure 4</xref>D is a 3-NFA with <inline-formula><mml:math id="M14" altimg="si12.gif"><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Note that the <inline-formula><mml:math id="M15" altimg="si13.gif"><mml:mrow><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula> case is the one proven to be NP-complete.<xref rid="bib9" ref-type="bibr"><sup>9</sup></xref> De Bruijn graphs and tries are 1-NFAs.</p>
      <sec id="sec2.2.1">
        <title>Recognizing challenging graphs with Wheelie-SMT</title>
        <p id="p0135">Motivated by previous work that showed how Boolean satisfiability formulations can solve special cases of the recognition problem,<xref rid="bib15" ref-type="bibr"><sup>15</sup></xref> we hypothesized that SMT solvers<xref rid="bib10" ref-type="bibr"><sup>10</sup></xref> could solve all or part of the Wheeler graph recognition problem. SMT has found many uses in artificial intelligence and formal methods for hardware and software development. As a generalization of the Boolean satisfiability,<xref rid="bib16" ref-type="bibr"><sup>16</sup></xref> SMT allows us to encode the Wheeler graph properties in a fairly straightforward way, building from the propositional logic formulas in the definition.</p>
        <p id="p0140">We conducted two series of 1,000-s timeout tests using graphs generated from the random generator comparing (1) Wheelie-Pr (<italic>renaming heuristic</italic> plus permutation) versus (2) Wheelie-SMT (<italic>renaming heuristic</italic> plus SMT) on different types of <italic>d</italic>-NFA (Recognizing <italic>d</italic>-NFAs) and various sizes of random graphs (Recognizing random Wheeler graphs).</p>
      </sec>
    </sec>
    <sec id="sec2.3">
      <title>Recognizing <italic>d</italic>-NFAs</title>
      <p id="p0145">We fixed <inline-formula><mml:math id="M16" altimg="si14.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1000</mml:mn></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M17" altimg="si15.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>3000</mml:mn></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="M18" altimg="si16.gif"><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> and randomly generated <italic>d</italic>-NFAs with <italic>d</italic> from 1 to 8 and each group with 20 graphs. <xref rid="fig5" ref-type="fig">Figure 5</xref> shows that both solvers can solve graphs swiftly when <italic>d</italic> is 1 and 2; as <italic>d</italic> grows beyond 2, all tools require much more time, demonstrating that <italic>d</italic> impacts the hardness of recognition problem in practice. Wheelie-SMT outperforms Wheelie-Pr and avoids any timeouts; Wheelie-Pr has some timeouts starting at <inline-formula><mml:math id="M19" altimg="si17.gif"><mml:mrow><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> (4 out of 20 graphs), and consistently times out when <inline-formula><mml:math id="M20" altimg="si18.gif"><mml:mrow><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>.<fig id="fig5"><label>Figure 5</label><caption><p>Recognition time for Wheelie-SMT and Wheelie-Pr as a function of the <italic>d</italic> parameter of the <italic>d</italic>-NFA</p><p>Upper panel plots recognition time versus <italic>d</italic> and includes a line connecting the medians. 20 graphs were tested for each <italic>d</italic>. The bottom bar chart shows the number of timeouts.</p></caption><graphic xlink:href="gr5"/></fig></p>
      <p id="p0150">Further, we observed that when <inline-formula><mml:math id="M21" altimg="si19.gif"><mml:mrow><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:math></inline-formula>, the median curve for Wheelie-SMT plateaus. This is because <italic>n</italic> and <italic>e</italic> are too small for the <italic>d</italic>-NFA generator to produce uniformly distributed <italic>d</italic>-NFAs under the given parameters. More precisely speaking, the hardness of the recognition problem is a function of the distribution of nodes having <inline-formula><mml:math id="M22" altimg="si20.gif"><mml:mrow><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M23" altimg="si21.gif"><mml:mrow><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, …, 1 outgoing edges with the same labels. As an example, take a <italic>d</italic>-NFA <italic>G</italic> that has one node with <italic>d</italic> same-label outgoing edges, and the rest of the nodes having at most one outgoing same-label edge. Recognizing <italic>G</italic> is not harder than recognizing a uniformly distributed <inline-formula><mml:math id="M24" altimg="si20.gif"><mml:mrow><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>-NFA. In short, we observed that higher <italic>d</italic>s generally led to a harder recognition problem, but the true level of hardness was also a function of <italic>n</italic>, <italic>e</italic>, and σ.</p>
    </sec>
    <sec id="sec2.4">
      <title>Recognizing random Wheeler graphs</title>
      <p id="p0155">We defined “graph size” as <italic>n</italic> and “label density” as <inline-formula><mml:math id="M25" altimg="si22.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:mi>σ</mml:mi></mml:mrow></mml:math></inline-formula>. We then benchmarked various sizes of random graphs while varying these parameters. We first fixed the number of edges (<inline-formula><mml:math id="M26" altimg="si23.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>8,000</mml:mn></mml:mrow></mml:math></inline-formula>) and labels (<inline-formula><mml:math id="M27" altimg="si16.gif"><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>) while scaling graph size <italic>n</italic> from <inline-formula><mml:math id="M28" altimg="si24.gif"><mml:mrow><mml:mn>2,000</mml:mn></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M29" altimg="si25.gif"><mml:mrow><mml:mn>8,000</mml:mn></mml:mrow></mml:math></inline-formula>. <xref rid="fig6" ref-type="fig">Figure 6</xref>A shows that as <italic>n</italic> grows, Wheelie-SMT outperforms Wheelie-Pr significantly. Wheelie-Pr starts to time out in some cases when <inline-formula><mml:math id="M30" altimg="si26.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>2,000</mml:mn></mml:mrow></mml:math></inline-formula>, and most cases when <inline-formula><mml:math id="M31" altimg="si27.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo><mml:mn>2,500</mml:mn></mml:mrow></mml:math></inline-formula>. In contrast, Wheelie-SMT can solve all cases with <italic>n</italic> up to <inline-formula><mml:math id="M32" altimg="si28.gif"><mml:mrow><mml:mn>4,000</mml:mn></mml:mrow></mml:math></inline-formula>, and most cases when <inline-formula><mml:math id="M33" altimg="si29.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4,500</mml:mn></mml:mrow></mml:math></inline-formula>.<fig id="fig6"><label>Figure 6</label><caption><p>Recognition time comparison for Wheelie-SMT and Wheelie-Pr for various random Wheeler graphs</p><p>Three experiments were conducted.</p><p>(A) Experiment 1: fixing <inline-formula><mml:math id="M34" altimg="si23.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>8,000</mml:mn></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M35" altimg="si16.gif"><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> and scaling up the graph size (<italic>n</italic> from <inline-formula><mml:math id="M36" altimg="si24.gif"><mml:mrow><mml:mn>2,000</mml:mn></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M37" altimg="si25.gif"><mml:mrow><mml:mn>8,000</mml:mn></mml:mrow></mml:math></inline-formula>).</p><p>(B) Experiment 2: fixing <inline-formula><mml:math id="M38" altimg="si30.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4,000</mml:mn></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M39" altimg="si31.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>20,000</mml:mn></mml:mrow></mml:math></inline-formula> and scaling up the label density (<inline-formula><mml:math id="M40" altimg="si22.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:mi>σ</mml:mi></mml:mrow></mml:math></inline-formula> from <inline-formula><mml:math id="M41" altimg="si32.gif"><mml:mrow><mml:mn>1,000</mml:mn></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M42" altimg="si28.gif"><mml:mrow><mml:mn>4,000</mml:mn></mml:mrow></mml:math></inline-formula>).</p><p>(C) Experiment 3: Fixing both graph size (<italic>n</italic>) and label density (<inline-formula><mml:math id="M43" altimg="si22.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:mi>σ</mml:mi></mml:mrow></mml:math></inline-formula>), and scaling up both <italic>e</italic> and σ (<inline-formula><mml:math id="M44" altimg="si36.gif"><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mi mathvariant="italic">min</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> from 1 to 20). The upper-panel plots show the recognition time versus the scale up parameter in microsecond scale. Each dot represents a graph. Dots beyond the red dashed line means timeouts. Plots in the lower panel are the timeout count bar charts.</p></caption><graphic xlink:href="gr6"/></fig></p>
      <p id="p0160">We then fixed the graph size (<inline-formula><mml:math id="M45" altimg="si30.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4,000</mml:mn></mml:mrow></mml:math></inline-formula>) and number of edges (<inline-formula><mml:math id="M46" altimg="si31.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>20,000</mml:mn></mml:mrow></mml:math></inline-formula>) and varied the label density (<inline-formula><mml:math id="M47" altimg="si22.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:mi>σ</mml:mi></mml:mrow></mml:math></inline-formula> from <inline-formula><mml:math id="M48" altimg="si32.gif"><mml:mrow><mml:mn>1,000</mml:mn></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M49" altimg="si28.gif"><mml:mrow><mml:mn>4,000</mml:mn></mml:mrow></mml:math></inline-formula>). <xref rid="fig6" ref-type="fig">Figure 6</xref>B shows that as the label density increases, the graphs take more time to solve. Comparing Wheelie-Pr and Wheelie-SMT, we can see that there are more timeout cases in Wheelie-Pr from <inline-formula><mml:math id="M50" altimg="si33.gif"><mml:mrow><mml:mn>1,200</mml:mn></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M51" altimg="si28.gif"><mml:mrow><mml:mn>4,000</mml:mn></mml:mrow></mml:math></inline-formula> (most are timeouts when <inline-formula><mml:math id="M52" altimg="si34.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo><mml:mn>2,500</mml:mn></mml:mrow></mml:math></inline-formula>) whereas the timeout cases only occur in Wheelie-SMT when label density is <inline-formula><mml:math id="M53" altimg="si28.gif"><mml:mrow><mml:mn>4,000</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
      <p id="p0165">In a third experiment, we fixed the graph size (<inline-formula><mml:math id="M54" altimg="si26.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>2,000</mml:mn></mml:mrow></mml:math></inline-formula>) and varied the number of edges (<italic>e</italic>) and labels (σ) while fixing the label density ratio (<inline-formula><mml:math id="M55" altimg="si35.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>2,000</mml:mn></mml:mrow></mml:math></inline-formula>). <xref rid="fig6" ref-type="fig">Figure 6</xref>C shows that as more edges and labels are added, the recognition problem becomes easier. In short, this is because adding more constraints to <italic>G</italic> breaks more of the ties that would otherwise obstruct Wheelie’s <italic>renaming heuristic</italic>. Comparing Wheelie-Pr to Wheelie-SMT, <xref rid="fig6" ref-type="fig">Figure 6</xref>C shows that the solvers perform similarly, with Wheelie-Pr performing slightly better when <inline-formula><mml:math id="M56" altimg="si36.gif"><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mi mathvariant="italic">min</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> ratio gets larger (<inline-formula><mml:math id="M57" altimg="si37.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula>). These are likely cases where the graph is sufficiently easy to recognize that the overhead of setting up the SMT setup problem becomes harmful. When <inline-formula><mml:math id="M58" altimg="si36.gif"><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mi mathvariant="italic">min</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> gets smaller (3 and 4), Wheelie-SMT is able to solve all 15 cases, whereas Wheelie-Pr’s times out for about half the cases.</p>
    </sec>
    <sec id="sec2.5">
      <title>Benchmarking Wheelie-SMT alone</title>
      <p id="p0170">To isolate the effect of the Wheelie <italic>renaming heuristic</italic>, we conducted a 30-s timeout test with 60 s timeout penalties on (1) Wheelie-SMT (<italic>renaming heuristic</italic> plus SMT) and (2) a pure SMT solver starting from scratch, without the constraints it would otherwise receive from the <italic>renaming heuristic</italic>. We benchmarked these using two generators from DNA alignments: (1) De Bruijn graphs generated with options -k from 5 to 8, -l from 100 to <inline-formula><mml:math id="M59" altimg="si24.gif"><mml:mrow><mml:mn>2,000</mml:mn></mml:mrow></mml:math></inline-formula>, and -a from 6 to 10, 225 graphs in total and (2) reverse deterministic graphs generated with options -l from 100 to 500 and -a from 4 to 6, in total 225 graphs.</p>
      <p id="p0175"><xref rid="fig7" ref-type="fig">Figure 7</xref> shows cactus plots on De Bruijn graphs and reverse deterministic graphs. A cactus plot is an aggregated sorted time plot widely used in solver competitions. It shows how many problems a solver can solve in a limited time period. In <xref rid="fig7" ref-type="fig">Figure 7</xref>A, Wheelie-SMT solved the whole De Bruijn graph set in around 6.5 s whereas the pure SMT approach solved it in around 820 s. For reverse deterministic graphs (<xref rid="fig7" ref-type="fig">Figure 7</xref>B), Wheelie-SMT solved the whole set in less than 9 s whereas the pure SMT approach solved it in around 10,170 s.<fig id="fig7"><label>Figure 7</label><caption><p>Cactus survival plot results of Wheelie-SMT and pure SMT</p><p>(A and B) The cactus survival plots of (A) De Bruijn graphs and (B) reverse deterministic graphs generated from DNA alignments using WGT’s generators. They show the aggregated time comparison between Wheelie-SMT and pure SMT without the constraints from the <italic>renaming heuristic</italic>.</p></caption><graphic xlink:href="gr7"/></fig></p>
      <p id="p0180">We concluded that the <italic>renaming heuristic</italic> is a crucial step, since it greatly narrows the space of possible node ordering that must be resolved by the SMT solver. Wheelie-SMT can solve graphs several orders of magnitude larger than a pure SMT approach.</p>
    </sec>
  </sec>
  <sec id="sec3">
    <title>Discussion</title>
    <p id="p0185">We demonstrated that Wheelie-SMT is the fastest and most robust algorithm available for the Wheeler graph recognition problem. We showed this across a variety of graph types, including large graphs (thousands of nodes and edges) and challenging graphs, such as those that are <italic>d</italic>-NFAs with values of <italic>d</italic> up to 8. We also demonstrated WGT’s facilities for visualizing and understanding these graphs.</p>
    <p id="p0190">While current pangenome representations tend to be based on De Bruijn graphs, which are Wheeler graphs, other relevant pangenome graph representations are not necessarily Wheeler. For example, the reverse deterministic automata of the GCSA study<xref rid="bib6" ref-type="bibr"><sup>6</sup></xref> are not Wheeler, though they can be made Wheeler through a “path doubling” process. In the future, we expect that WGT and the Wheelie algorithm will be useful for studying alternative pangenome graph representations that might improve upon De Bruijn graphs in various ways. In <xref rid="mmc1" ref-type="supplementary-material">Figure S3</xref>, we provide a simple illustration of why another Wheeler graph (besides a De Bruijn graph) might be better suited as a pangenome representation, since it (a) uses fewer nodes and edges than a corresponding De Bruijn graph, (b) does not require that we select a particular value for <italic>k</italic> (the <italic>k</italic>-mer length), and (c) avoids collapsing sequences that are distinct with respect to the coordinate system of a given genome.</p>
    <p id="p0195">We noted a relationship between the renaming heuristic proposed here and the “forward algorithm” of Alanko et al.<xref rid="bib17" ref-type="bibr"><sup>17</sup></xref> In the future, it will be important to clarify the relationship between these two algorithms, which have similar goals but take different approaches to partitioning and ordering the graph nodes. Appealingly, the forward algorithm has polynomial running time when the input is already a Wheeler graph; we do not have a similar guarantee for the renaming heuristic. However, the forward algorithm is not directly usable for the same purpose as the renaming heuristic, since it is possible for the forward algorithm to collapse a non-Wheeler input in a way that produces a Wheeler output. Another question for future work is whether the renaming heuristic could be combined with the forward algorithm to obtain an algorithm with strong guarantees (like the forward algorithm) but that is directly applicable to the recognition problem (like the renaming heuristic).</p>
    <p id="p0200">When Wheelie determines that a graph is is Wheeler graph, it is able to report a node ordering that can then be used to index the graph. In the future, it will be important to extend Wheelie to report other useful information, including when the graph is not a Wheeler graph. For instance, when Wheelie encounters a conflict that proves the graph to be non-Wheeler, Wheelie could supply the user with an explanation for why the graph cannot be Wheeler. Such an explanation could also allow Wheelie to suggest modifications to the graph that would make it a Wheeler graph, without changing which strings it encodes. A trivial example would be a node with two incoming edges having two distinct labels. This violates the Wheeler graph properties, but also suggests a potential solution: the node could be duplicated, with outgoing edges also duplicated. The initial inbound edges could be redrawn to point to the distinct duplicates, possibly restoring the Wheeler properties. A more general approach for understanding Wheeler violations could work by extracting conflicting sets of clauses from the SMT algorithm, and converting them into a human-understandable or other actionable form.</p>
    <p id="p0205">It may also be possible to encode the <italic>renaming heuristic</italic> as a set of clauses in the SMT solver, potentially allowing the entire algorithm to execute within the SMT solver. Finally, as different SMT solvers such as CVC5<xref rid="bib18" ref-type="bibr"><sup>18</sup></xref> or Z3<xref rid="bib19" ref-type="bibr"><sup>19</sup></xref> adopt different heuristics, they could potentially be substituted into WGT, or combined for increased efficiency.<xref rid="bib20" ref-type="bibr"><sup>20</sup></xref></p>
    <sec id="sec3.1">
      <title>Limitations of the study</title>
      <p id="p0210">A theoretical limitation is that we cannot claim to have improved on the worst-case bounds already established for the recognition problem. The problem is NP-complete in general, though our work suggests that the kinds of graphs that appear in pangenome applications (e.g., when they are <italic>d</italic>-NFAs with small <italic>d</italic>) may be of a class that are easier to check in practice. A further practical limitation is the fact that Wheelie cannot yet scale to large pangenome graphs. Wheelie has been demonstrated to effectively identify graphs with up to 4,000 nodes, 20,000 edges, and 5 edge labels within a time frame of around 1000 s. We are still far from being able to efficiently check pangenomes derived from, for example, whole eukaryotic genomes. A final limitation is the fact that our bipartite visualization approach works only when a particular ordering has been proposed. A more general approach would render a useful visualization when such an ordering is either not known or partially known.</p>
    </sec>
  </sec>
  <sec id="sec4">
    <title>STAR★Methods</title>
    <sec id="sec4.1">
      <title>Key resources table</title>
      <p id="p0215">
        <table-wrap position="float" id="undtbl1">
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <th>REAGENT or RESOURCE</th>
                <th>SOURCE</th>
                <th>IDENTIFIER</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td colspan="3">
                  <bold>Deposited data</bold>
                </td>
              </tr>
              <tr>
                <td colspan="3">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td>25 multiple orthologue alignments</td>
                <td>Ensembl Comparative Genomics REST API</td>
                <td>REST API: <ext-link ext-link-type="uri" xlink:href="https://rest.ensembl.org/documentation/info/genomic_alignment_region" id="intref0030">https://rest.ensembl.org/documentation/info/genomic_alignment_region</ext-link>; GitHub: <ext-link ext-link-type="uri" xlink:href="https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit/tree/main/data/multiseq_alignment/Ensembl_REST/fasta" id="intref0035">https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit/tree/main/data/multiseq_alignment/Ensembl_REST/fasta</ext-link></td>
              </tr>
              <tr>
                <td colspan="3">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td colspan="3">
                  <bold>Software and algorithms</bold>
                </td>
              </tr>
              <tr>
                <td colspan="3">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td>G &amp; T’s algorithm</td>
                <td>Gibney &amp; Thankachan</td>
                <td>
                  <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.48550/arXiv.1902.01960" id="intref0040">https://doi.org/10.48550/arXiv.1902.01960</ext-link>
                </td>
              </tr>
              <tr>
                <td>Z3 theorem prover v4.11.1</td>
                <td>Microsoft Corporation</td>
                <td>
                  <ext-link ext-link-type="uri" xlink:href="https://github.com/Z3Prover/z3" id="intref0045">https://github.com/Z3Prover/z3</ext-link>
                </td>
              </tr>
              <tr>
                <td>WGT toolkit v1.0.0</td>
                <td>This study</td>
                <td>Zenodo DOI: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.5281/zenodo.7937689" id="intref0050">https://doi.org/10.5281/zenodo.7937689</ext-link>; GitHub: <ext-link ext-link-type="uri" xlink:href="https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit" id="intref0055">https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit</ext-link></td>
              </tr>
            </tbody>
          </table>
        </table-wrap>
      </p>
    </sec>
    <sec id="sec4.2">
      <title>Resource availability</title>
      <sec id="sec4.2.1">
        <title>Lead contact</title>
        <p id="p0220">Further information and requests for resources and reagents should be directed to and will be fulfilled by the lead contact, Ben Langmead (<ext-link ext-link-type="uri" xlink:href="mailto:langmea@cs.jhu.edu" id="intref0060">langmea@cs.jhu.edu</ext-link>).</p>
      </sec>
      <sec id="sec4.2.2">
        <title>Materials availability</title>
        <p id="p0225">This study did not generate new unique reagents.</p>
      </sec>
    </sec>
    <sec id="sec4.3">
      <title>Method details</title>
      <sec id="sec4.3.1">
        <title>The search space of Wheelie’s permutation approach</title>
        <p id="p0230">While the G &amp; T algorithm explores an exponential-sized space of possible array assignments, Wheelie explores a factorial-sized space of node permutations. This may or may not lead to a larger search space for Wheelie, depending on the graph’s properties. To be specific, the G &amp; T’s algorithm may have to consider all <inline-formula><mml:math id="M60" altimg="si39.gif"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mi>n</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>e</mml:mi><mml:mspace width="0.25em"/><mml:mi>log</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>σ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> assignments for <italic>I</italic>, <italic>O</italic> and <italic>L</italic>. Our approach might need to consider <inline-formula><mml:math id="M61" altimg="si40.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo>!</mml:mo></mml:mrow></mml:math></inline-formula> node permutations in the worst case. We sought a rough comparison between the approaches in light of the fact that G &amp; T’s space depends not only on <italic>n</italic> but also on <italic>e</italic> and σ.<disp-formula id="fd1"><label>(Equation 1)</label><mml:math id="M62" altimg="si41.gif"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mi>e</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo linebreak="badbreak">+</mml:mo><mml:mi>e</mml:mi><mml:mo linebreak="badbreak">×</mml:mo><mml:mi>log</mml:mi><mml:mspace width="0.25em"/><mml:mi>σ</mml:mi></mml:mrow></mml:msup><mml:mo linebreak="badbreak">=</mml:mo><mml:mi>n</mml:mi><mml:mo>!</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="fd2"><label>(Equation 2)</label><mml:math id="M63" altimg="si42.gif"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mi>e</mml:mi><mml:mo linebreak="badbreak">×</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mo linebreak="badbreak">+</mml:mo><mml:mi>log</mml:mi><mml:mspace width="0.25em"/><mml:mi>σ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msup><mml:mo linebreak="badbreak">=</mml:mo><mml:mi>n</mml:mi><mml:mo>!</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="ufd1"><mml:math id="M64" altimg="si43.gif"><mml:mrow><mml:mtext>Let</mml:mtext><mml:mspace width="0.25em"/><mml:mi>C</mml:mi><mml:mo>:</mml:mo><mml:mo linebreak="badbreak">=</mml:mo><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mo linebreak="badbreak">+</mml:mo><mml:mi>log</mml:mi><mml:mspace width="0.25em"/><mml:mi>σ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="fd3"><label>(Equation 3)</label><mml:math id="M65" altimg="si44.gif"><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mi>C</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:msub><mml:mi>log</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mspace width="0.25em"/><mml:mi>n</mml:mi><mml:mo>!</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="fd4"><label>(Equation 4)</label><mml:math id="M66" altimg="si45.gif"><mml:mrow><mml:mi>C</mml:mi><mml:mo linebreak="badbreak">=</mml:mo><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo linebreak="badbreak">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>log</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mspace width="0.25em"/><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p>
      </sec>
      <sec id="sec4.3.2">
        <title>Derivation 1: The relationship between <italic>C</italic> and <italic>n</italic></title>
        <p id="p0235">In Derivation 1, we fixed <italic>n</italic> for both, defining a new variable <italic>C</italic> as <inline-formula><mml:math id="M67" altimg="si46.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mo linebreak="badbreak">+</mml:mo><mml:mi>log</mml:mi><mml:mspace width="0.25em"/><mml:mi>σ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. We then found some values for <italic>C</italic> that equalize the algorithms’ search space size under various values for of <italic>n</italic>s (<xref rid="mmc1" ref-type="supplementary-material">Table S1</xref>). For instance, when <inline-formula><mml:math id="M68" altimg="si47.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>100</mml:mn></mml:mrow></mml:math></inline-formula>, <italic>C</italic> can be at most 324 in order for G &amp; T’s algorithm has an equal or smaller search space than Wheelie-Pr, which is a strict threshold, and furthermore, this comparison is done with Wheelie-Pr skipping the <italic>renaming heuristic</italic>, which in reality makes Wheelie-Pr superiorly faster (ResultsBenchmarking Wheelie-SMT alone).</p>
        <p id="p0240">To gain a further advantage over the G &amp; T algorithm, Wheelie further strives to prune the search space, using a renaming heuristic, an SMT solver, or both, as detailed in MethodsSTAR Methods.</p>
      </sec>
      <sec id="sec4.3.3">
        <title>Wheelie and the <italic>renaming heuristic</italic></title>
        <p id="p0245">Wheelie explores the space of possible node orderings until arriving either at a conflict (e.g., a node with distinctly labeled incoming edges) or an ordering for which the Wheeler properties hold. While this is a large (<inline-formula><mml:math id="M69" altimg="si40.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo>!</mml:mo></mml:mrow></mml:math></inline-formula>-sized) search space, Wheelie prunes the space by assigning labels to nodes according to their <italic>rough</italic> position in the overall order. Initially, a rough ordering is determined according to the labels of the immediate incoming edges for each node, following the Wheeler requirement that <inline-formula><mml:math id="M70" altimg="si4.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≺</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after" stretchy="true">→</mml:mo><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> for all edge pairs. This rough ordering is refined over the course of a procedure that iterates either until the rough ordering becomes total ordering, or until the rough ordering stabilizes. In the latter case, the remaining ambiguities are resolved by a non-heuristic solver. This procedure is detailed in <xref rid="tbox1" ref-type="boxed-text">Algorithm 1</xref> and illustrated in <xref rid="fig1" ref-type="fig">Figure 1</xref>.<boxed-text id="tbox1"><label>Algorithm 1</label><caption><title>Wheeler graph Recognition Algorithm, Wheelie</title></caption><p id="p0375"><bold>Require</bold>:</p><p id="p0380"><bold>Input:</bold> Graph <italic>G</italic> as DOT file.</p><p id="p0385"><bold>Input:</bold> Solver <italic>S</italic> input from -s or --solver tag.<list list-type="simple" id="ulist1010"><list-item id="u1010"><label>1:</label><p id="p0390">Find all 0-indegree nodes, <inline-formula><mml:math id="M71" altimg="si62.gif"><mml:mrow><mml:mi>R</mml:mi><mml:mi>o</mml:mi><mml:mi>o</mml:mi><mml:mi>t</mml:mi><mml:mi>s</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mspace width="0.25em"/><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u2010"><label>2:</label><p id="p0395">Group edges by their labels in a hashMap, <inline-formula><mml:math id="M72" altimg="si63.gif"><mml:mrow><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mo>_</mml:mo><mml:mo>2</mml:mo><mml:mo>_</mml:mo><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> (key: label, value: list of edges)</p></list-item><list-item id="u3010"><label>3:</label><p id="p0400"><inline-formula><mml:math id="M73" altimg="si64.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">←</mml:mo><mml:mi>R</mml:mi><mml:mi>o</mml:mi><mml:mi>o</mml:mi><mml:mi>t</mml:mi><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>z</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> <inline-formula><mml:math id="M74" altimg="si65.gif"><mml:mrow><mml:mo>▷</mml:mo></mml:mrow></mml:math></inline-formula> Relabel nodes with the largest possible order</p></list-item><list-item id="u4010"><label>4:</label><p id="p0405"><bold>for</bold> each <inline-formula><mml:math id="M75" altimg="si66.gif"><mml:mrow><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>o</mml:mi><mml:mi>t</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">∈</mml:mo><mml:mi>R</mml:mi><mml:mi>o</mml:mi><mml:mi>o</mml:mi><mml:mi>t</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>do</bold></p></list-item><list-item id="u5010"><label>5:</label><p id="p0410"> <inline-formula><mml:math id="M76" altimg="si67.gif"><mml:mrow><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mo>_</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>o</mml:mi><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>_</mml:mo><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u6010"><label>6:</label><p id="p0415"><bold>end for</bold>.</p></list-item><list-item id="u7010"><label>7:</label><p id="p0420"><bold>for</bold> each <inline-formula><mml:math id="M77" altimg="si68.gif"><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">∈</mml:mo><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mo>_</mml:mo><mml:mo>2</mml:mo><mml:mo>_</mml:mo><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>do</bold></p></list-item><list-item id="u8010"><label>8:</label><p id="p0425"> <inline-formula><mml:math id="M78" altimg="si69.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">←</mml:mo><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mi>q</mml:mi><mml:mi>u</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>.</mml:mo><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>z</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u9010"><label>9:</label><p id="p0430"> <bold>for</bold> each <inline-formula><mml:math id="M79" altimg="si70.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">∈</mml:mo><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>do</bold></p></list-item><list-item id="u10010"><label>10:</label><p id="p0435"> <inline-formula><mml:math id="M80" altimg="si71.gif"><mml:mrow><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mo>_</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mo>.</mml:mo><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mo>_</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u11010"><label>11:</label><p id="p0440"> <bold>end for</bold>.</p></list-item><list-item id="u12010"><label>12:</label><p id="p0445"><bold>end for</bold>.</p></list-item><list-item id="u13010"><label>13:</label><p id="p0450"><inline-formula><mml:math id="M81" altimg="si72.gif"><mml:mrow><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">←</mml:mo><mml:mi>F</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula> <inline-formula><mml:math id="M82" altimg="si65.gif"><mml:mrow><mml:mo>▷</mml:mo></mml:mrow></mml:math></inline-formula><italic>renaming heuristic</italic></p></list-item><list-item id="u14010"><label>14:</label><p id="p0455"><inline-formula><mml:math id="M83" altimg="si73.gif"><mml:mrow><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mspace width="0.25em"/><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u15010"><label>15:</label><p id="p0460"><bold>while</bold> not <inline-formula><mml:math id="M84" altimg="si74.gif"><mml:mrow><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>do</bold></p></list-item><list-item id="u16010"><label>16:</label><p id="p0465"> <inline-formula><mml:math id="M85" altimg="si75.gif"><mml:mrow><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>c</mml:mi><mml:mi>l</mml:mi><mml:mi>e</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u17010"><label>17:</label><p id="p0470"> <inline-formula><mml:math id="M86" altimg="si76.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">←</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u18010"><label>18:</label><p id="p0475"> <inline-formula><mml:math id="M87" altimg="si77.gif"><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo>_</mml:mo><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mspace width="0.25em"/><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u19010"><label>19:</label><p id="p0480"> <bold>for</bold> each <inline-formula><mml:math id="M88" altimg="si68.gif"><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">∈</mml:mo><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mo>_</mml:mo><mml:mo>2</mml:mo><mml:mo>_</mml:mo><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>do</bold></p></list-item><list-item id="u20010"><label>20:</label><p id="p0485"> <inline-formula><mml:math id="M89" altimg="si78.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">←</mml:mo><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mi>q</mml:mi><mml:mi>u</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mo>_</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u21010"><label>21:</label><p id="p0490"> <bold>for</bold> each <inline-formula><mml:math id="M90" altimg="si79.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">∈</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>do</bold></p></list-item><list-item id="u22010"><label>22:</label><p id="p0495"> <inline-formula><mml:math id="M91" altimg="si80.gif"><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo>_</mml:mo><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo>.</mml:mo><mml:mi>A</mml:mi><mml:mi>d</mml:mi><mml:mi>d</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>t</mml:mi><mml:mo>_</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> <inline-formula><mml:math id="M92" altimg="si65.gif"><mml:mrow><mml:mo>▷</mml:mo></mml:mrow></mml:math></inline-formula> get_innodelist: lists distinct predecessor nodes in order by label</p></list-item><list-item id="u23010"><label>23:</label><p id="p0500"> <bold>end for</bold>.</p></list-item><list-item id="u24010"><label>24:</label><p id="p0505"> <inline-formula><mml:math id="M93" altimg="si81.gif"><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi><mml:mi>i</mml:mi><mml:mi>c</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>s</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mo>_</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo>_</mml:mo><mml:mi>b</mml:mi><mml:mi>y</mml:mi><mml:mo>_</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo>_</mml:mo><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u25010"><label>25:</label><p id="p0510"> <inline-formula><mml:math id="M94" altimg="si82.gif"><mml:mrow><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mo>_</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo>_</mml:mo><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi><mml:mi>i</mml:mi><mml:mi>c</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> <inline-formula><mml:math id="M95" altimg="si65.gif"><mml:mrow><mml:mo>▷</mml:mo></mml:mrow></mml:math></inline-formula> Assign <inline-formula><mml:math id="M96" altimg="si83.gif"><mml:mrow><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo>_</mml:mo><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M97" altimg="si84.gif"><mml:mrow><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>v</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo>_</mml:mo><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula> for each node</p></list-item><list-item id="u26010"><label>26:</label><p id="p0515"> <inline-formula><mml:math id="M98" altimg="si85.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">←</mml:mo><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>z</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u27010"><label>27:</label><p id="p0520"> <bold>end for</bold>.</p></list-item><list-item id="u28010"><label>28:</label><p id="p0525"> <inline-formula><mml:math id="M99" altimg="si86.gif"><mml:mrow><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">←</mml:mo><mml:mi>T</mml:mi><mml:mi>r</mml:mi><mml:mi>u</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u29010"><label>29:</label><p id="p0530"> <bold>for</bold> each <inline-formula><mml:math id="M100" altimg="si79.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">∈</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>do</bold></p></list-item><list-item id="u30010"><label>30:</label><p id="p0535"> <inline-formula><mml:math id="M101" altimg="si87.gif"><mml:mrow><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>A</mml:mi><mml:mi>d</mml:mi><mml:mi>d</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo>.</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo>_</mml:mo><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u31010"><label>31:</label><p id="p0540"> <bold>if</bold><inline-formula><mml:math id="M102" altimg="si88.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo>.</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo>_</mml:mo><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≠</mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mo>.</mml:mo><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>v</mml:mi><mml:mo>_</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo>_</mml:mo><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula><bold>then</bold></p></list-item><list-item id="u32010"><label>32:</label><p id="p0545"> <inline-formula><mml:math id="M103" altimg="si72.gif"><mml:mrow><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">←</mml:mo><mml:mi>F</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u33010"><label>33:</label><p id="p0550"> <inline-formula><mml:math id="M104" altimg="si89.gif"><mml:mrow><mml:mi>B</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="u34010"><label>34:</label><p id="p0555"> <bold>end if</bold>.</p></list-item><list-item id="u35010"><label>35:</label><p id="p0560"> <bold>end for</bold>.</p></list-item><list-item id="u36010"><label>36:</label><p id="p0565"><bold>end while</bold>.</p></list-item><list-item id="u37010"><label>37:</label><p id="p0570"><bold>if</bold><inline-formula><mml:math id="M105" altimg="si90.gif"><mml:mrow><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mi>q</mml:mi><mml:mi>u</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>z</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>z</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula><bold>then</bold> <inline-formula><mml:math id="M106" altimg="si65.gif"><mml:mrow><mml:mo>▷</mml:mo></mml:mrow></mml:math></inline-formula> Solved by <italic>renaming heuristic</italic></p></list-item><list-item id="u38010"><label>38:</label><p id="p0575"> <italic>G</italic> is a Wheeler graph.</p></list-item><list-item id="u39010"><label>39:</label><p id="p0580"><bold>else</bold>.</p></list-item><list-item id="u40010"><label>40:</label><p id="p0585"> <bold>if</bold><inline-formula><mml:math id="M107" altimg="si91.gif"><mml:mrow><mml:mi>S</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo></mml:mrow></mml:math></inline-formula>'' <inline-formula><mml:math id="M108" altimg="si92.gif"><mml:mrow><mml:mi>P</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>m</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>'' <bold>then</bold></p></list-item><list-item id="u41010"><label>41:</label><p id="p0590"> <inline-formula><mml:math id="M109" altimg="si93.gif"><mml:mrow><mml:mi>P</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>m</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> <inline-formula><mml:math id="M110" altimg="si65.gif"><mml:mrow><mml:mo>▷</mml:mo></mml:mrow></mml:math></inline-formula> Use Wheelie-Pr solver to resolve multi-node groups</p></list-item><list-item id="u42010"><label>42:</label><p id="p0595"> <bold>else if</bold><inline-formula><mml:math id="M111" altimg="si91.gif"><mml:mrow><mml:mi>S</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo></mml:mrow></mml:math></inline-formula>'' <inline-formula><mml:math id="M112" altimg="si94.gif"><mml:mrow><mml:mi>S</mml:mi><mml:mi>M</mml:mi><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula>'' <bold>then</bold></p></list-item><list-item id="u43010"><label>43:</label><p id="p0600"> <inline-formula><mml:math id="M113" altimg="si95.gif"><mml:mrow><mml:mi>S</mml:mi><mml:mi>M</mml:mi><mml:mi>T</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> <inline-formula><mml:math id="M114" altimg="si65.gif"><mml:mrow><mml:mo>▷</mml:mo></mml:mrow></mml:math></inline-formula> Use Wheelie-SMT solver to resolve multi-node groups</p></list-item><list-item id="u44010"><label>44:</label><p id="p0605"> <bold>end if</bold>.</p></list-item><list-item id="u45010"><label>45:</label><p id="p0610"><bold>end if</bold>.</p></list-item></list></p></boxed-text></p>
        <p id="p0250">As the <italic>renaming heuristic</italic> iterates, it repeatedly visits the nodes in groupings according to the label of their incoming edge(s). For each of these groupings, it sorts the edges by sources and destinations in every label group, requiring <inline-formula><mml:math id="M115" altimg="si48.gif"><mml:mrow><mml:mi>O</mml:mi><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:munder><mml:mo>∏</mml:mo><mml:mrow><mml:mi>g</mml:mi><mml:mo linebreak="badbreak">∈</mml:mo><mml:mi mathvariant="normal">Σ</mml:mi></mml:mrow></mml:munder><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>g</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>log</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mspace width="0.25em"/><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>g</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> time, where <inline-formula><mml:math id="M116" altimg="si49.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>g</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is the number of edges labeled as <italic>g</italic>. We observed that many non-Wheeler graphs can be recognized as such directly by the <italic>renaming heuristic</italic>, without requiring a downstream solver.</p>
        <p id="p0255">At each iteration, the algorithm gathers a list of sorted unique temporary orders of nodes that go into it, which we term the “in-node list.” By the Wheeler graph property that requires all edge pairs to satisfy <inline-formula><mml:math id="M117" altimg="si5.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>∧</mml:mo><mml:mi>u</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:msup><mml:mi>u</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after" stretchy="true">→</mml:mo><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, we can find rough orders by sorting the nodes by their in-node lists. Once this has been done for each node group, we reach the end of the current iteration and we check if the rough order changed since the previous iteration. If not, then we say the algorithm has converged and forward any remaining ambiguities to the downstream solver as necessary.</p>
        <p id="p0260">We note that there are similarities between the renaming heuristic and the “forward algorithm” of Alanko et al.<xref rid="bib17" ref-type="bibr"><sup>17</sup></xref> (Algorithm 2 in that paper). While our renaming heuristic performs an explicit sort within each of its rough grouping, the forward algorithm of Alanko et al. uses a pair of nested loops over alphabet characters to visit and partition the nodes in a way that maintains their sorted order implicitly. We discuss this relationship further in Discussion Discussion below.</p>
        <sec id="sec4.3.3.1">
          <title>Wheelie contains two solvers</title>
          <p id="p0265">Wheelie-PR and Wheelie-SMT. Wheelie-PR takes the output from the renaming heuristic and, for any remaining ties in the ordering, simply tries all possible permutations among the tied nodes. The Wheelie-SMT solver is explained in the next subsection Satisfiability Modulo Theories (SMT) solver.</p>
        </sec>
      </sec>
      <sec id="sec4.3.4">
        <title>Satisfiability Modulo Theories (SMT) solver</title>
        <p id="p0270">Motivated by the use of boolean satisfiability formulations to solve special cases of the recognition problem,<xref rid="bib15" ref-type="bibr"><sup>15</sup></xref> we hypothesized that Satisfiability Modulo Theory (SMT) solvers<xref rid="bib10" ref-type="bibr"><sup>10</sup></xref> could be used to solve all or part of the Wheeler-graph recognition problem. SMT has found many uses in artificial intelligence and formal methods for hardware and software development. As a generalization of the Boolean Satisfiability (SAT),<xref rid="bib16" ref-type="bibr"><sup>16</sup></xref> SMT allows us to encode the Wheeler graph properties in a fairly straightforward way, building from the propositional logic formulas in the definition.</p>
        <p id="p0275">An SMT problem decides the satisfiability of a first-order formula with respect to one or more background theories. A <italic>formula</italic> is a set of atoms connected by Boolean connectives (<inline-formula><mml:math id="M118" altimg="si50.gif"><mml:mrow><mml:mo>∧</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M119" altimg="si51.gif"><mml:mrow><mml:mo>∨</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M120" altimg="si52.gif"><mml:mrow><mml:mo>¬</mml:mo></mml:mrow></mml:math></inline-formula>), where an <italic>atom</italic> is a predicate which valuates to True or False given an assignment to the variables. A <italic>literal</italic> is either an atom or its negation. A <italic>theory</italic> gives special meanings, known as <italic>interpretations</italic>, to functions and predicate symbols within the theory. In this paper, we consider only the theory of Integer Difference Logic (IDL), which requires atoms to be of the form <inline-formula><mml:math id="M121" altimg="si53.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="M122" altimg="si54.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M123" altimg="si55.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are integer variables, <italic>c</italic> an integer constant, “<inline-formula><mml:math id="M124" altimg="si56.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo></mml:mrow></mml:math></inline-formula>” the integer subtraction function, and “<inline-formula><mml:math id="M125" altimg="si57.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo></mml:mrow></mml:math></inline-formula>” the usual binary ordering predicate. A theory solver decides the satisfiability of a conjunction of <italic>literals</italic>. In particular, an IDL theory solver can be implemented as the Bellman-Ford algorithm which runs in polynomial time. Incorporating a SAT solver and a theory solver, an SMT solver takes in a formula and outputs an assignment to the variables if the formula is satisfiable or otherwise reports unsatisfiability.</p>
        <p id="p0280">We observed that SMT is a natural way of encoding the Wheeler graph recognition problem. Firstly, for each node a variable is created representing the ordering of the node. Recalling the constraints, for all pairs of edges <inline-formula><mml:math id="M126" altimg="si1.gif"><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M127" altimg="si2.gif"><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msup><mml:mi>u</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math></inline-formula> labeled <italic>a</italic> and <inline-formula><mml:math id="M128" altimg="si3.gif"><mml:mrow><mml:msup><mml:mi>a</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> respectively: (i) <inline-formula><mml:math id="M129" altimg="si4.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≺</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after" stretchy="true">→</mml:mo><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, and (ii) <inline-formula><mml:math id="M130" altimg="si5.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>∧</mml:mo><mml:mi>u</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:msup><mml:mi>u</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after" stretchy="true">→</mml:mo><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>. By indexing the known labels lexicographically, we obtained an SMT formula containing constraints (i) and (ii), in which all atoms are of the form <inline-formula><mml:math id="M131" altimg="si58.gif"><mml:mrow><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> satisfying the IDL requirement. Note that the strict inequality <inline-formula><mml:math id="M132" altimg="si59.gif"><mml:mrow><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> can be rewritten using the the non-strict one as <inline-formula><mml:math id="M133" altimg="si60.gif"><mml:mrow><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:msup><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Besides constraints (i) and (ii), we also enforced all-different constraints and range constraints for all nodes, which have the form <inline-formula><mml:math id="M134" altimg="si61.gif"><mml:mrow><mml:mn>1</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>. The node orderings can be obtained from the satisfying assignment by solving the SMT formula iff it is satisfiable. In Wheelie-SMT, we used Z3<xref rid="bib19" ref-type="bibr"><sup>19</sup></xref> as the underlying SMT solver.</p>
        <p id="p0285">As the number of constraints and variables are the main factors affecting runtime, simplifying the problem or providing additional information can improve performance. We noticed that the problem can be simplified using the rough order obtained from the <italic>renaming heuristic</italic> described in Section <xref rid="sec4.3.3" ref-type="sec">wheelie and the renaming heuristic</xref>. By adding the range information to the formula, notice that constraint (i) can be removed from the formula. Moreover, the all-different constraints of nodes from different groups can also be removed. The rationale is that if the graph was not reported non-Wheeler during the <italic>renaming heuristic</italic>, the range constraints provided by the procedure must automatically imply constraint (i). The benefits are 2-fold: not only the number of constraints is reduced, the search space is also significantly pruned.</p>
      </sec>
      <sec id="sec4.3.5">
        <title>WGT’s graph generating algorithms</title>
        <p id="p0290">We implemented five generators in Python scripts to produce tries, reverse deterministic graphs,<xref rid="bib6" ref-type="bibr"><sup>6</sup></xref> De Bruijn graphs and <italic>complete</italic> and <italic>d-NFA</italic> random Wheeler graphs. The first three generators take either DNA or protein multiple sequence alignments and produce the corresponding graph structures. As for the two random generators, users can produce a Wheeler graph given its <italic>n</italic>, <italic>e</italic>, and σ, and <italic>d-NFA</italic> random generator can further take <italic>d</italic>, which controls the most number of edges coming out from a node with the same label (<italic>d</italic>-NFA) as user input.</p>
        <p id="p0295">Tries and De Bruijn graphs are Wheeler graphs by definition. These generators start by removing gap placeholders from the multiple alignments. The trie generator iterates through the prefixes of each sequence in the multiple alignment, inserts characters into the trie and creates a new node at the end of a path if a prefix cannot be traversed from the source. Edges are labeled according to the label of the parent. The De Bruijn graph generator constructs a distinct <inline-formula><mml:math id="M135" altimg="si96.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>-mer dictionary from the sequences. It connects edges between adjacent two nodes and label the edge with the first character in the <inline-formula><mml:math id="M136" altimg="si96.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>-mer of the child node. Reverse deterministic graphs are usually invalid Wheeler graphs but might be valid when the graphs are small, and once violations occur, adding more nodes and edges cannot turn them back to Wheeler graphs.</p>
        <p id="p0300">The reverse deterministic graph generator iterates through columns of a multiple sequence alignments from right to left. At a column <italic>i</italic>, it creates distinct nodes for the characters found there, connecting them to the current node with the node of the previous ungapped character with the direction pointing to the end of the alignments and the label of the previous ungapped character. This follows the procedure described in the GCSA study.<xref rid="bib6" ref-type="bibr"><sup>6</sup></xref> Last, three generators initializes the names of nodes with the breadth first search orders and outputs the constructed graph in DOT format.</p>
        <p id="p0305">We also implemented two random generators, a <italic>complete</italic> Wheeler graph generator and a <italic>d-NFA</italic> Wheeler graph generator. We first fix the ordering of nodes and then try to select edges such that both user-specified constraints and Wheeler graph properties are satisfied. Let <inline-formula><mml:math id="M137" altimg="si97.gif"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the nodes with incoming edges labeled <italic>i</italic> and <inline-formula><mml:math id="M138" altimg="si98.gif"><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the edges labeled <italic>i</italic> where <inline-formula><mml:math id="M139" altimg="si99.gif"><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1,2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>σ</mml:mi></mml:mrow></mml:math></inline-formula>, and also let <inline-formula><mml:math id="M140" altimg="si100.gif"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true">|</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M141" altimg="si101.gif"><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true">|</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. In both generated graphs, we assume that <inline-formula><mml:math id="M142" altimg="si102.gif"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">≈</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>r</mml:mi></mml:mrow><mml:mi>σ</mml:mi></mml:mfrac></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M143" altimg="si103.gif"><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">≈</mml:mo><mml:mfrac><mml:mi>e</mml:mi><mml:mi>σ</mml:mi></mml:mfrac></mml:mrow></mml:math></inline-formula> where <italic>r</italic> is the number of nodes without incoming edges.</p>
        <p id="p0310">We say a Wheeler graph <italic>G</italic> is <italic>complete</italic> if no more edges can be added to <italic>G</italic> while maintaining the Wheeler graph properties.</p>
        <p id="p0315">Property 1. Given number of nodes n and number of labels σ, the number of edges of a Wheeler graph is upper bounded by <inline-formula><mml:math id="M144" altimg="si104.gif"><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi mathvariant="italic">max</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>
<italic>where</italic><disp-formula id="fd5"><label>(Equation 5)</label><mml:math id="M145" altimg="si105.gif"><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi mathvariant="italic">max</mml:mi></mml:msub><mml:mo linebreak="badbreak">=</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak">×</mml:mo><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak">+</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak">−</mml:mo><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak">−</mml:mo><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo linebreak="goodbreak">−</mml:mo><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></disp-formula></p>
        <p id="p0320">Proof. Consider the bipartite representation of a Wheeler graph <italic>G</italic> with number of nodes <italic>n</italic> and number of labels σ. Note that<disp-formula id="fd6"><label>(Equation 6)</label><mml:math id="M146" altimg="si106.gif"><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>σ</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak">−</mml:mo><mml:mi>r</mml:mi><mml:mtext>.</mml:mtext></mml:mrow></mml:mrow></mml:math></disp-formula></p>
        <p id="p0325">Observe that for each label <italic>i</italic>, the number of edges that is labeled <italic>i</italic> is at most <inline-formula><mml:math id="M147" altimg="si107.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Taking the sum of edges of each label and applying <xref rid="fd6" ref-type="disp-formula">Equation 6</xref>, we have<disp-formula id="fd7"><label>(Equation 7)</label><mml:math id="M148" altimg="si108.gif"><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi mathvariant="italic">max</mml:mi></mml:msub><mml:mo linebreak="badbreak">=</mml:mo><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>σ</mml:mi></mml:munderover><mml:mrow><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="badbreak">−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo linebreak="badbreak">=</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="badbreak">×</mml:mo><mml:mi>σ</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>σ</mml:mi><mml:mo linebreak="badbreak">+</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>σ</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="badbreak">=</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="badbreak">×</mml:mo><mml:mi>σ</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>σ</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>r</mml:mi><mml:mtext>.</mml:mtext></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p>
        <p id="p0330">One way of generating complete Wheeler graphs is to have all nodes connect to the first node of <inline-formula><mml:math id="M149" altimg="si97.gif"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and the last node additionally connect to the rest of the nodes in <inline-formula><mml:math id="M150" altimg="si97.gif"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for each label <italic>i</italic> (the last node has <inline-formula><mml:math id="M151" altimg="si109.gif"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> outgoing edges in total). By randomly selecting <inline-formula><mml:math id="M152" altimg="si110.gif"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> nodes from <italic>N</italic> and connecting the selected nodes to consecutive nodes in <inline-formula><mml:math id="M153" altimg="si97.gif"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, a new complete Wheeler graph can be generated by appropriately shifting the destination node of each edge such that the Wheeler graph property is maintained. <xref rid="mmc1" ref-type="supplementary-material">Figure S2</xref> shows an example of a complete Wheeler graph with <inline-formula><mml:math id="M154" altimg="si111.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>,</mml:mo><mml:mi>r</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mn>7,18,2,1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. With a complete Wheeler graph of <italic>n</italic> nodes and σ labels, we are able to generate random Wheeler graphs with <inline-formula><mml:math id="M155" altimg="si112.gif"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi mathvariant="italic">max</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> edges by sampling <italic>e</italic> distinct edges from the complete Wheeler graph.</p>
        <p id="p0335">For generation of <italic>d</italic>-NFA Wheeler graphs, let <inline-formula><mml:math id="M156" altimg="si113.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the number of nodes with <italic>k</italic> outgoing edges of the same label <italic>i</italic>. Thus, given <italic>e</italic> and σ we have<disp-formula id="fd8"><label>(Equation 8)</label><mml:math id="M157" altimg="si114.gif"><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>d</mml:mi></mml:munderover><mml:mrow><mml:mi>k</mml:mi><mml:mo>⋅</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo linebreak="goodbreak">=</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></disp-formula>Also the number of nodes <inline-formula><mml:math id="M158" altimg="si109.gif"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> with incoming edges labeled <italic>i</italic> must be greater than the minimum number of nodes <inline-formula><mml:math id="M159" altimg="si115.gif"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi mathvariant="italic">min</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> needed to accommodate <inline-formula><mml:math id="M160" altimg="si116.gif"><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> edges. Thus, we have<disp-formula id="fd9"><label>(Equation 9)</label><mml:math id="M161" altimg="si117.gif"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi mathvariant="italic">min</mml:mi></mml:msub><mml:mo linebreak="badbreak">=</mml:mo><mml:mn>1</mml:mn><mml:mo linebreak="goodbreak">+</mml:mo><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">=</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mi>d</mml:mi></mml:munderover><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>⋅</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo linebreak="goodbreak">≤</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p>
        <p id="p0340">Note that any solution <inline-formula><mml:math id="M162" altimg="si113.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> that satisfies <xref rid="fd8" ref-type="disp-formula">Equations 8</xref> and <xref rid="fd9" ref-type="disp-formula">9</xref> for all edge label <italic>i</italic> represents a set of valid Wheeler graphs. To see this first notice that given <inline-formula><mml:math id="M163" altimg="si113.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we can always order the nodes such that <inline-formula><mml:math id="M164" altimg="si118.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> nodes with one outgoing edge are placed at the front, followed by <inline-formula><mml:math id="M165" altimg="si119.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> nodes with two outgoing edges, followed by <inline-formula><mml:math id="M166" altimg="si120.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> nodes with three outgoing edges and so on. By construction, this gives a valid <italic>d</italic>-NFA Wheeler graph. Moreover, by swapping the nodes and reconnecting the corresponding edges accordingly, different <italic>d</italic>-NFA Wheeler graphs can be obtained. An example is shown in <xref rid="mmc1" ref-type="supplementary-material">Figure S3</xref>.</p>
        <p id="p0345">To obtain a concrete instance, we find a valid solution for <inline-formula><mml:math id="M167" altimg="si113.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and then determine the node ordering. In our case, we set all <inline-formula><mml:math id="M168" altimg="si113.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to be the same, and if not possible assign the residual to <inline-formula><mml:math id="M169" altimg="si118.gif"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> to satisfy <xref rid="fd8" ref-type="disp-formula">Equation 8</xref>. We believe that this reflects the hardness of different benchmarks with different d’s. For node ordering, all the nodes are shuffled and edges are distributed such that each node in <inline-formula><mml:math id="M170" altimg="si97.gif"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> has at least one incoming edge while maintaining the Wheeler properties.</p>
      </sec>
    </sec>
  </sec>
</body>
<back>
  <ref-list id="cebib0010">
    <title>References</title>
    <ref id="bib1">
      <label>1</label>
      <element-citation publication-type="book" id="sref1">
        <person-group person-group-type="author">
          <name>
            <surname>Ferragina</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <part-title>Opportunistic data structures with applications</part-title>
        <source>Proceedings 41st annual symposium on foundations of computer science</source>
        <year>2000</year>
        <fpage>390</fpage>
        <lpage>398</lpage>
      </element-citation>
    </ref>
    <ref id="bib2">
      <label>2</label>
      <element-citation publication-type="journal" id="sref2">
        <person-group person-group-type="author">
          <name>
            <surname>Garrison</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Sirén</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Novak</surname>
            <given-names>A.M.</given-names>
          </name>
          <name>
            <surname>Hickey</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Eizenga</surname>
            <given-names>J.M.</given-names>
          </name>
          <name>
            <surname>Dawson</surname>
            <given-names>E.T.</given-names>
          </name>
          <name>
            <surname>Jones</surname>
            <given-names>W.</given-names>
          </name>
          <name>
            <surname>Garg</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Markello</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Lin</surname>
            <given-names>M.F.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Variation graph toolkit improves read mapping by representing genetic variation in the reference</article-title>
        <source>Nat. Biotechnol.</source>
        <volume>36</volume>
        <year>2018</year>
        <fpage>875</fpage>
        <lpage>879</lpage>
        <pub-id pub-id-type="pmid">30125266</pub-id>
      </element-citation>
    </ref>
    <ref id="bib3">
      <label>3</label>
      <element-citation publication-type="journal" id="sref3">
        <person-group person-group-type="author">
          <name>
            <surname>Sirén</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Monlong</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Chang</surname>
            <given-names>X.</given-names>
          </name>
          <name>
            <surname>Novak</surname>
            <given-names>A.M.</given-names>
          </name>
          <name>
            <surname>Eizenga</surname>
            <given-names>J.M.</given-names>
          </name>
          <name>
            <surname>Markello</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Sibbesen</surname>
            <given-names>J.A.</given-names>
          </name>
          <name>
            <surname>Hickey</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Chang</surname>
            <given-names>P.C.</given-names>
          </name>
          <name>
            <surname>Carroll</surname>
            <given-names>A.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Pangenomics enables genotyping of known structural variants in 5202 diverse genomes</article-title>
        <source>Science</source>
        <volume>374</volume>
        <year>2021</year>
        <fpage>abg8871</fpage>
        <pub-id pub-id-type="pmid">34914532</pub-id>
      </element-citation>
    </ref>
    <ref id="bib4">
      <label>4</label>
      <element-citation publication-type="book" id="sref4">
        <person-group person-group-type="author">
          <name>
            <surname>Ferragina</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Luccio</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Muthukrishnan</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <part-title>Structuring labeled trees for optimal succinctness, and beyond</part-title>
        <source>46th Annual IEEE Symposium on Foundations of Computer Science (FOCS’05)</source>
        <year>2005</year>
        <fpage>184</fpage>
        <lpage>193</lpage>
      </element-citation>
    </ref>
    <ref id="bib5">
      <label>5</label>
      <element-citation publication-type="book" id="sref5">
        <person-group person-group-type="author">
          <name>
            <surname>Bowe</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Onodera</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Sadakane</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Shibuya</surname>
            <given-names>T.</given-names>
          </name>
        </person-group>
        <part-title>Succinct de bruijn graphs</part-title>
        <source>Algorithms in Bioinformatics: 12th International Workshop, WABI 2012, Ljubljana, Slovenia, September 10-12, 2012. Proceedings 12</source>
        <year>2012</year>
        <fpage>225</fpage>
        <lpage>235</lpage>
      </element-citation>
    </ref>
    <ref id="bib6">
      <label>6</label>
      <element-citation publication-type="journal" id="sref6">
        <person-group person-group-type="author">
          <name>
            <surname>Sirén</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Välimäki</surname>
            <given-names>N.</given-names>
          </name>
          <name>
            <surname>Mäkinen</surname>
            <given-names>V.</given-names>
          </name>
        </person-group>
        <article-title>Indexing graphs for path queries with applications in genome research</article-title>
        <source>IEEE/ACM Trans. Comput. Biol. Bioinform.</source>
        <volume>11</volume>
        <year>2014</year>
        <fpage>375</fpage>
        <lpage>388</lpage>
        <pub-id pub-id-type="pmid">26355784</pub-id>
      </element-citation>
    </ref>
    <ref id="bib7">
      <label>7</label>
      <element-citation publication-type="journal" id="sref7">
        <person-group person-group-type="author">
          <name>
            <surname>Kim</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Langmead</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>S.L.</given-names>
          </name>
        </person-group>
        <article-title>Hisat: a fast spliced aligner with low memory requirements</article-title>
        <source>Nat. Methods</source>
        <volume>12</volume>
        <year>2015</year>
        <fpage>357</fpage>
        <lpage>360</lpage>
        <pub-id pub-id-type="pmid">25751142</pub-id>
      </element-citation>
    </ref>
    <ref id="bib8">
      <label>8</label>
      <element-citation publication-type="journal" id="sref8">
        <person-group person-group-type="author">
          <name>
            <surname>Muggli</surname>
            <given-names>M.D.</given-names>
          </name>
          <name>
            <surname>Bowe</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Noyes</surname>
            <given-names>N.R.</given-names>
          </name>
          <name>
            <surname>Morley</surname>
            <given-names>P.S.</given-names>
          </name>
          <name>
            <surname>Belk</surname>
            <given-names>K.E.</given-names>
          </name>
          <name>
            <surname>Raymond</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Gagie</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Puglisi</surname>
            <given-names>S.J.</given-names>
          </name>
          <name>
            <surname>Boucher</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <article-title>Succinct colored de Bruijn graphs</article-title>
        <source>Bioinformatics</source>
        <volume>33</volume>
        <year>2017</year>
        <fpage>3181</fpage>
        <lpage>3187</lpage>
        <pub-id pub-id-type="pmid">28200001</pub-id>
      </element-citation>
    </ref>
    <ref id="bib9">
      <label>9</label>
      <element-citation publication-type="journal" id="sref9">
        <person-group person-group-type="author">
          <name>
            <surname>Gibney</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Thankachan</surname>
            <given-names>S.V.</given-names>
          </name>
        </person-group>
        <article-title>On the hardness and inapproximability of recognizing wheeler graphs</article-title>
        <comment>Preprint at</comment>
        <source>arXiv</source>
        <year>2019</year>
        <pub-id pub-id-type="doi">10.48550/arXiv.1902.01960</pub-id>
      </element-citation>
    </ref>
    <ref id="bib10">
      <label>10</label>
      <element-citation publication-type="book" id="sref10">
        <person-group person-group-type="author">
          <name>
            <surname>Barrett</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Sebastiani</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Seshia</surname>
            <given-names>S.A.</given-names>
          </name>
          <name>
            <surname>Tinelli</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <part-title>Satisfiability Modulo Theories</part-title>
        <person-group person-group-type="editor">
          <name>
            <surname>Biere</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>van Maaren</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Walsh</surname>
            <given-names>T.</given-names>
          </name>
        </person-group>
        <source>Handbook of satisfiability</source>
        <year>2009</year>
        <publisher-name>IOS Press</publisher-name>
        <fpage>825</fpage>
        <lpage>885</lpage>
      </element-citation>
    </ref>
    <ref id="bib11">
      <label>11</label>
      <element-citation publication-type="journal" id="sref11">
        <person-group person-group-type="author">
          <name>
            <surname>Gagie</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Sirén</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>Wheeler graphs: a framework for bwt-based data structures</article-title>
        <source>Theor. Comput. Sci.</source>
        <volume>698</volume>
        <year>2017</year>
        <fpage>67</fpage>
        <lpage>78</lpage>
        <pub-id pub-id-type="pmid">29276331</pub-id>
      </element-citation>
    </ref>
    <ref id="bib12">
      <label>12</label>
      <element-citation publication-type="journal" id="sref12">
        <person-group person-group-type="author">
          <name>
            <surname>Cunningham</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Allen</surname>
            <given-names>J.E.</given-names>
          </name>
          <name>
            <surname>Allen</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Alvarez-Jarreta</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Amode</surname>
            <given-names>M.R.</given-names>
          </name>
          <name>
            <surname>Armean</surname>
            <given-names>I.M.</given-names>
          </name>
          <name>
            <surname>Austine- Orimoloye</surname>
            <given-names>O.</given-names>
          </name>
          <name>
            <surname>Azov</surname>
            <given-names>A.G.</given-names>
          </name>
          <name>
            <surname>Barnes</surname>
            <given-names>I.</given-names>
          </name>
          <name>
            <surname>Bennett</surname>
            <given-names>R.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Ensembl 2022</article-title>
        <source>Nucleic Acids Res.</source>
        <volume>50</volume>
        <year>2022</year>
        <fpage>D988</fpage>
        <lpage>D995</lpage>
        <pub-id pub-id-type="pmid">34791404</pub-id>
      </element-citation>
    </ref>
    <ref id="bib13">
      <label>13</label>
      <element-citation publication-type="book" id="sref13">
        <person-group person-group-type="author">
          <name>
            <surname>Ellson</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Gansner</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Koutsofios</surname>
            <given-names>L.</given-names>
          </name>
          <name>
            <surname>North</surname>
            <given-names>S.C.</given-names>
          </name>
          <name>
            <surname>Woodhull</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <part-title>Graphviz—open source graph drawing tools</part-title>
        <source>International Symposium on Graph Drawing</source>
        <year>2001</year>
        <fpage>483</fpage>
        <lpage>484</lpage>
      </element-citation>
    </ref>
    <ref id="bib14">
      <label>14</label>
      <element-citation publication-type="journal" id="sref14">
        <person-group person-group-type="author">
          <name>
            <surname>Boucher</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Gagie</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Kuhnle</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Langmead</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Mun</surname>
            <given-names>T.</given-names>
          </name>
        </person-group>
        <article-title>Prefix-free parsing for building big BWTs</article-title>
        <source>Algorithm Mol. Biol.</source>
        <volume>14</volume>
        <year>2019</year>
        <fpage>13</fpage>
      </element-citation>
    </ref>
    <ref id="bib15">
      <label>15</label>
      <element-citation publication-type="book" id="sref15">
        <person-group person-group-type="author">
          <name>
            <surname>Alanko</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>D’Agostino</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Policriti</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Prezza</surname>
            <given-names>N.</given-names>
          </name>
        </person-group>
        <part-title>Regular languages meet prefix sorting</part-title>
        <source>Proceedings of the Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms</source>
        <year>2020</year>
        <fpage>911</fpage>
        <lpage>930</lpage>
      </element-citation>
    </ref>
    <ref id="bib16">
      <label>16</label>
      <element-citation publication-type="book" id="sref16">
        <person-group person-group-type="author">
          <name>
            <surname>Biere</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Heule</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>van Maaren</surname>
            <given-names>H.</given-names>
          </name>
        </person-group>
        <series>Handbook of Satisfiability</series>
        <volume>Vol 185</volume>
        <year>2009</year>
        <publisher-name>IOS press</publisher-name>
      </element-citation>
    </ref>
    <ref id="bib17">
      <label>17</label>
      <element-citation publication-type="journal" id="sref17">
        <person-group person-group-type="author">
          <name>
            <surname>Alanko</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>D’Agostino</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Policriti</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Prezza</surname>
            <given-names>N.</given-names>
          </name>
        </person-group>
        <article-title>Wheeler languages</article-title>
        <source>Inf. Comput.</source>
        <volume>281</volume>
        <year>2021</year>
        <fpage>104820</fpage>
      </element-citation>
    </ref>
    <ref id="bib18">
      <label>18</label>
      <element-citation publication-type="book" id="sref18">
        <person-group person-group-type="author">
          <name>
            <surname>Barbosa</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Barrett</surname>
            <given-names>C.W.</given-names>
          </name>
          <name>
            <surname>Brain</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Kremer</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Lachnitt</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Mann</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Mohamed</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Mohamed</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Niemetz</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>N' otzli</surname>
            <given-names>A.</given-names>
          </name>
          <etal/>
        </person-group>
        <part-title>Cvc5: a versatile and industrial-strength SMT solver</part-title>
        <source>28th International Conference on Tools and Algorithms for the Construction and Analysis of Systems</source>
        <year>2022</year>
        <publisher-name>TACAS, 2022</publisher-name>
        <fpage>415</fpage>
        <lpage>442</lpage>
      </element-citation>
    </ref>
    <ref id="bib19">
      <label>19</label>
      <element-citation publication-type="book" id="sref19">
        <person-group person-group-type="author">
          <name>
            <surname>de Moura</surname>
            <given-names>L.M.</given-names>
          </name>
          <name>
            <surname>Bjorner</surname>
            <given-names>N.S.</given-names>
          </name>
        </person-group>
        <part-title>Z3: an efficient SMT solver</part-title>
        <source>Proc. 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems</source>
        <year>2008</year>
        <publisher-name>TACAS 2008</publisher-name>
        <fpage>337</fpage>
        <lpage>340</lpage>
      </element-citation>
    </ref>
    <ref id="bib20">
      <label>20</label>
      <element-citation publication-type="book" id="sref20">
        <person-group person-group-type="author">
          <name>
            <surname>Pimpalkhare</surname>
            <given-names>N.</given-names>
          </name>
          <name>
            <surname>Mora</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Polgreen</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Seshia</surname>
            <given-names>S.A.</given-names>
          </name>
        </person-group>
        <part-title>MedleySolver: Online SMT algorithm selection</part-title>
        <source>24th International Conference on Theory and Applications of Satisfiability Testing (SAT)</source>
        <volume>12831</volume>
        <year>2021</year>
        <fpage>453</fpage>
        <lpage>470</lpage>
      </element-citation>
    </ref>
  </ref-list>
  <sec id="appsec2" sec-type="supplementary-material">
    <title>Supplemental information</title>
    <p id="p0370">
      <supplementary-material content-type="local-data" id="mmc1">
        <caption>
          <title>Document S1. Figures S1–S3 and Table S1</title>
        </caption>
        <media xlink:href="mmc1.pdf"/>
      </supplementary-material>
    </p>
  </sec>
  <sec sec-type="data-availability" id="da0010">
    <title>Data and code availability</title>
    <p id="p0030">
      <list list-type="simple" id="ulist0015">
        <list-item id="u0030">
          <label>•</label>
          <p id="p0035">All original code has been deposited at Zenodo and is publicly available as of the date of publication. DOIs are listed in the <xref rid="sec4.1" ref-type="sec">key resources table</xref>.</p>
        </list-item>
        <list-item id="u0035">
          <label>•</label>
          <p id="p0040">The experimental datasets are listed in the <xref rid="sec4.1" ref-type="sec">key resources table</xref>.</p>
        </list-item>
        <list-item id="u0040">
          <label>•</label>
          <p id="p0045">WGT is publicly available at <ext-link ext-link-type="uri" xlink:href="https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit" id="intref0015">https://github.com/Kuanhao-Chao/Wheeler_Graph_Toolkit</ext-link>.</p>
        </list-item>
      </list>
    </p>
  </sec>
  <ack id="ack0010">
    <title>Acknowledgments</title>
    <p id="p0350">We thank Markus J. Sommer for proposing the name Wheelie. We thank Nicola Prezza, Nicola Cotumaccio, Travis Gagie, and Christina Boucher for helpful comments. Funding This research was supported in part by the <funding-source id="gs1">U.S. National Institutes of Health</funding-source> under grant R0I-HG006677 and grants R35GM139602 and R01HG011392 to B.L. This work was also supported by the <funding-source id="gs2">U.S. National Science Foundation</funding-source> under grant DBI-1759518, and by a Berkeley Fellowship.</p>
    <sec id="sec5">
      <title>Author contributions</title>
      <p id="p0355">K.C., P.C., and B.L. designed the method. K.C. and P.C. wrote the software and performed the experiments. K.C., P.C., S.A.S., and B.L. wrote the manuscript. All authors read and approved the final manuscript.</p>
    </sec>
    <sec sec-type="COI-statement" id="sec6">
      <title>Declaration of interests</title>
      <p id="p0360">The authors declare no competing interests.</p>
    </sec>
  </ack>
  <fn-group>
    <fn id="appsec1" fn-type="supplementary-material">
      <p id="p0365">Supplemental information can be found online at <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.isci.2023.107402" id="intref0065">https://doi.org/10.1016/j.isci.2023.107402</ext-link>.</p>
    </fn>
  </fn-group>
</back>
