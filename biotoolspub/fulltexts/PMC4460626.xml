<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Genomics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Genomics</journal-id>
    <journal-title-group>
      <journal-title>BMC Genomics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2164</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4460626</article-id>
    <article-id pub-id-type="publisher-id">1471-2164-16-S5-S6</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2164-16-S5-S6</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>ProCARs: Progressive Reconstruction of Ancestral Gene Orders</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" id="A1">
        <name>
          <surname>Perrin</surname>
          <given-names>Amandine</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Varré</surname>
          <given-names>Jean-Stéphane</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
      </contrib>
      <contrib contrib-type="author" id="A3">
        <name>
          <surname>Blanquart</surname>
          <given-names>Samuel</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes" id="A4">
        <name>
          <surname>Ouangraoua</surname>
          <given-names>Aïda</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>aida.ouangraoua@usherbrooke.ca</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Inria Lille Nord-Europe, LIFL UMR CNRS 8022, Université Lille 1, Lille, France</aff>
    <aff id="I2"><label>2</label>Département d'informatique, Université de Sherbrooke, Sherbrooke, Canada</aff>
    <pub-date pub-type="collection">
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>26</day>
      <month>5</month>
      <year>2015</year>
    </pub-date>
    <volume>16</volume>
    <issue>Suppl 5</issue>
    <supplement>
      <named-content content-type="supplement-title">Proceedings of the 10th International Conference of the Brazilian Association for Bioinformatics and Computational Biology (X-Meeting 2014)</named-content>
      <named-content content-type="supplement-editor">Marcelo Mendes </named-content>
      <named-content content-type="supplement-sponsor">Publication of this supplement has not been supported by sponsorship. Information about the source of funding for publication charges can be found in the individual articles. Articles have been through the journal's standard peer review process for supplements. The Supplement Editor declares that he has no competing interests.</named-content>
    </supplement>
    <fpage>S6</fpage>
    <lpage>S6</lpage>
    <permissions>
      <copyright-statement>Copyright © 2015 Perrin et al.; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2015</copyright-year>
      <copyright-holder>Perrin et al.; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/4.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0">http://creativecommons.org/licenses/by/4.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1471-2164/16/S5/S6"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>In the context of ancestral gene order reconstruction from extant genomes, there exist two main computational approaches: rearrangement-based, and homology-based methods. The rearrangement-based methods consist in minimizing a total rearrangement distance on the branches of a species tree. The homology-based methods consist in the detection of a set of potential ancestral contiguity features, followed by the assembling of these features into Contiguous Ancestral Regions (CARs).</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>In this paper, we present a new homology-based method that uses a progressive approach for both the detection and the assembling of ancestral contiguity features into CARs. The method is based on detecting a set of potential ancestral adjacencies iteratively using the current set of CARs at each step, and constructing CARs progressively using a 2-phase assembling method.</p>
      </sec>
      <sec>
        <title>Conclusion</title>
        <p>We show the usefulness of the method through a reconstruction of the boreoeutherian ancestral gene order, and a comparison with three other homology-based methods: AnGeS, InferCARs and GapAdj. The program, written in Python, and the dataset used in this paper are available at <ext-link ext-link-type="uri" xlink:href="http://bioinfo.lifl.fr/procars/">http://bioinfo.lifl.fr/procars/</ext-link>.</p>
      </sec>
    </abstract>
    <kwd-group>
      <kwd>Ancestral gene orders reconstruction</kwd>
      <kwd>Small phylogeny problem</kwd>
      <kwd>Boreoeutherian ancestor</kwd>
    </kwd-group>
    <conference>
      <conf-date>28-30 October 2014</conf-date>
      <conf-name>X-meeting 2014 - International Conference on the Brazilian Association for Bioinformatics and Computational Biology</conf-name>
      <conf-loc>Belo Horizonte, Brazil</conf-loc>
    </conference>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>The small phylogeny problem consists in reconstructing the ancestral gene orders at the internal nodes of a species tree, given the gene orders of the extant genomes at the leaves of the tree. There exist two main computational approaches for the reconstruction of ancestral gene orders from extant gene orders: rearrangement-based methods, and homology-based methods.</p>
    <p>The rearrangement-based methods require a rearrangement model, and consist in finding a rearrangement scenario that minimizes the total rearrangement distance on the branches of the species tree [<xref ref-type="bibr" rid="B1">1</xref>-<xref ref-type="bibr" rid="B3">3</xref>]. The homology-based methods consist in finding the ancestral gene orders associated with the internal nodes of the species tree, such that the total amount of homoplasy phenomenon observed in the species tree is minimized [<xref ref-type="bibr" rid="B4">4</xref>-<xref ref-type="bibr" rid="B9">9</xref>]. Homoplasy is a phenomenon by which two genomes in different lineages acquire independently a same feature that is not shared and derived from a common ancestor. For the inference of the ancestral gene order at a tagged internal node, the homology-based methods are usually composed of two steps. The first step consists in detecting a set of potential ancestral contiguity features, by comparison of pairs of extant genomes whose path goes through the ancestor in the species tree. The second step is an assembling phase that requires to compute an accurate conservation score for each potential ancestral feature, based on the species tree. Using these scores, some heuristic algorithms are then used to resolve the conflicts between the ancestral features in order to assemble them into Contiguous Ancestral Regions (CARs). A <italic>CAR </italic>of an ancestral genome is an ordered sequence of oriented blocks (genes, or synteny blocks) that potentially appear consecutively in this ancestral genome.</p>
    <p>In the absence of tangible evolution model, the homology-based methods have the convenience to reconstruct CARs that contain only reliable features inferred from a conservation signal observed in the extant genomes. However, the ancestral genomes reconstructed using homology-based methods are often not completely assembled, as some rearrangement or content-modifying events might have caused the loss of some ancestral contiguity features in the extant genomes. Thus, the homology-based methods proposed in the literature usually enlarge the condition of contiguity in order to detect more potential ancestral contiguity features, -adjacencies between two blocks [<xref ref-type="bibr" rid="B5">5</xref>,<xref ref-type="bibr" rid="B6">6</xref>,<xref ref-type="bibr" rid="B9">9</xref>], maximum common intervals of blocks [<xref ref-type="bibr" rid="B4">4</xref>,<xref ref-type="bibr" rid="B10">10</xref>,<xref ref-type="bibr" rid="B7">7</xref>], gapped adjacencies [<xref ref-type="bibr" rid="B11">11</xref>]. Hence, these different types of contiguity features can be classified according to the tightness of their definition of contiguity. The homology-based methods should then account for this classification when assembling different types of contiguity features. This approach was used in [<xref ref-type="bibr" rid="B11">11</xref>] where a method, GapAdj, was presented for iteratively detecting gapped adjacencies. GapAdj uses a progressively relaxed definition of contiguity allowing an increasing number of gaps between ancestral contiguous synteny blocks in extant genomes, and iteratively assembling these gapped adjacencies using a heuristic Traveling Salesman algorithm (TSP). The TSP is applied on a graph whose vertices are synteny blocks, and edges are potential ancestral adjacencies between these blocks.</p>
    <p>Here, we follow the same idea, and we present an homology-based method that is based on <italic>iteratively </italic>detecting and assembling ancestral adjacencies, while allowing some micro-rearrangements of synteny blocks at the extremities of the progressively assembled CARs. The method starts with a set of non-duplicated blocks as the initial set of CARs, and detects iteratively the potential ancestral adjacencies between extremities of CARs, while building up the CARs <italic>progressively </italic>by adding, at each step, new non-conflicting adjacencies that induce the less homoplasy phenomenon. The species tree is used, in some additional internal steps, to compute a score for the remaining conflicting adjacencies, and to detect other reliable adjacencies, in order to reach completely assembled ancestral genomes. The first originality of the method comes from the usage of the progressively assembled CARs for the detection of ancestral contiguity features allowing micro-rearrangements. The second originality comes from the assembling method at each iterative step that consists in adding the contiguity features gradually giving priority to the features that minimize the homoplasy phenomenon, rather than relying on a heuristic algorithm for discarding false-positive features. We discuss the usefulness of the method through a comparison with three other homology-based methods (AnGeS [<xref ref-type="bibr" rid="B12">12</xref>], InferCARs [<xref ref-type="bibr" rid="B5">5</xref>] and GapAdj [<xref ref-type="bibr" rid="B11">11</xref>]) on the same real dataset of amniote genomes for the reconstruction of the boreoeutherian genome.</p>
  </sec>
  <sec>
    <title>Preliminaries: genomes, species tree, conserved adjacencies</title>
    <p>For the reconstruction of ancestral genomes from extant ones, genomes are represented by identifying homologous conserved segments along their DNA sequences, called <italic>synteny blocks</italic>. These blocks can be relatively small, or very large fragments of chromosomes. The order and orientation of the blocks, and their distribution on chromosomes may vary in different genomes. A <italic>signed block </italic>is a block preceded by a sign + or − representing its orientation. By convention, a signed block +<italic>a </italic>is simply written <italic>a</italic>. Here we assume that all <italic>genomes </italic>contain the same set of non-duplicated blocks and consist of several circular or linear chromosomes composed of signed blocks.</p>
    <p>For example, consider the five genomes represented at the leaves of the tree in Figure <xref ref-type="fig" rid="F1">1</xref>. The bullets at the extremities of the chromosomes represent the telomeres of linear chromosomes. Genomes <italic>A </italic>and <italic>B </italic>consist of one linear chromosome each, and genomes <italic>C</italic>, <italic>D</italic>, and <italic>E </italic>consist of two linear chromosomes each.</p>
    <fig id="F1" position="float">
      <label>Figure 1</label>
      <caption>
        <p><bold>Example of a species tree</bold>. A species tree on five genomes <italic>A</italic>, <italic>B</italic>, <italic>C</italic>, <italic>D</italic>, and <italic>E</italic>. The black-colored ancestral node defines two ingroup sets each composed of a single genome, <italic>I</italic><sub>1 </sub>= {<italic>D</italic>} and <italic>I</italic><sub>2 </sub>= {<italic>E</italic>}, and an outgroup set <italic>O </italic>= {<italic>A, B, C</italic>}. The conserved adjacencies at the ancestral black-colored node are given.</p>
      </caption>
      <graphic xlink:href="1471-2164-16-S5-S6-1"/>
    </fig>
    <p>A <italic>Contiguous Ancestral Region (CAR) </italic>is defined as a potential chromosome of an ancestral genome.</p>
    <p>A <italic>segment </italic>in a genome is an ordered set of signed blocks that appear consecutively in the genome. The <italic>length </italic>of a segment is the number of blocks composing this segment. In the above example, {<italic>b c d e</italic>} is a segment of length 4 in the genome <italic>A</italic>.</p>
    <p>Two segments of two different genomes are called <italic>syntenic segments </italic>if they contain the same set of blocks. For example, the segments {<italic>h −g − f d</italic>} of genome <italic>D </italic>and {<italic>−d f g h</italic>} of genome <italic>E </italic>are syntenic.</p>
    <p>An <italic>adjacency </italic>in a genome is an ordered pair of two consecutive signed blocks. For example, in the above genomes, (<italic>a b</italic>) is an adjacency of genomes <italic>A</italic>, <italic>B</italic>, <italic>C</italic>, and <italic>E</italic>, and (<italic>a −b</italic>) is an adjacency of genome <italic>B</italic>. Since a whole chromosome or a segment can always be flipped, we have (<italic>x y</italic>) = (<italic>−y −x</italic>). For example, (<italic>g −h</italic>) = (<italic>h −g</italic>) is an adjacency shared by genomes <italic>B</italic>, <italic>C</italic>, and <italic>D</italic>.</p>
    <p>A <italic>species tree </italic>on a set of <italic>k </italic>genomes is a rooted tree with <italic>k </italic>leaves, where each genome is associated with a single leaf of the tree, and the internal nodes of the tree represent ancestral genomes. For example, Figure <xref ref-type="fig" rid="F1">1</xref> shows a species tree on genomes <italic>A</italic>, <italic>B</italic>, <italic>C</italic>, <italic>D</italic>, and <italic>E</italic>.</p>
    <p>Here, for the reconstruction of ancestral gene orders, we consider an ancestral node of the species tree that has exactly two children resulting from a speciation (black-colored node in Figure <xref ref-type="fig" rid="F1">1</xref>). The <italic>species partition defined by an ancestral node </italic>is the partition of the extant species into three sets: two ingroup sets <italic>I</italic><sub>1 </sub>and <italic>I</italic><sub>2 </sub>corresponding to the two lineages descending from the ancestor, and one outgroup set <italic>O </italic>containing all other extant genomes.</p>
    <p>A <italic>conserved adjacency </italic>at an ancestral node of the species tree is an adjacency shared by at least two genomes belonging to at least two different sets of the species partition defined by the ancestral node. Such two genomes are linked by a path that goes through the ancestral node. For example, in Figure <xref ref-type="fig" rid="F1">1</xref>, (<italic>a b</italic>) is a conserved adjacency of the black-colored ancestral node because it is shared by genomes <italic>C </italic>and <italic>E </italic>whose path goes through the ancestor. The adjacency (<italic>c −e</italic>) is also a conserved adjacency of this ancestor because of its presence in genomes <italic>D </italic>and <italic>E</italic>.</p>
    <p>A conserved adjacency at an ancestral node is considered as a potential adjacency of this ancestor. Homology-based methods for the reconstruction of ancestral gene orders usually consist in, first, detecting all the conserved adjacencies at the ancestral node, and next, assembling these conserved adjacencies into CARs. The difficulty in this assembling phase comes from the conflicts that may exist between some conserved adjacencies. Two adjacencies are called <italic>conflicting adjacencies </italic>when they involve a same block extremity, and thus they cannot be both present in the same ancestral genome. For example, in Figure <xref ref-type="fig" rid="F1">1</xref>, the conserved adjacencies (<italic>g h</italic>) and (<italic>g −h</italic>) of the black-colored node are conflicting as they both involve the right extremity of block <italic>g</italic>. Two adjacencies that are not conflicting are called <italic>compatible</italic>. A set of adjacencies is said <italic>non-conflicting (NC) </italic>if all pairs of adjacencies in the set are compatible.</p>
    <p>Here, we distinguish two types of conserved adjacency regarding their presence or absence in the three sets of species defined by the considered ancestral node: the two ingroup sets <italic>I</italic><sub>1 </sub>and <italic>I</italic><sub>2</sub>, and the outgroup set <italic>O</italic>. A <italic>fully-conserved adjacency </italic>is a conserved adjacency that is present in at least one genome of each of the three sets of species. A <italic>partly-conserved adjacency </italic>is any other conserved adjacency. For example, in Figure <xref ref-type="fig" rid="F1">1</xref>, (<italic>f g</italic>) is a fully-conserved adjacency of the black-colored ancestral node, while all other conserved adjacencies are partly-conserved adjacencies.</p>
    <p>The <italic>homoplasy cost </italic>of an adjacency at a given ancestral node <italic>A </italic>counts the number of branches linked to this ancestor on which the adjacency would have been gained (right before the ancestor) or lost (after the ancestor) if it was present in the ancestor. It is defined as follows: it is either 0 if the adjacency is fully-conserved at <italic>A</italic>, or 1 if it is partly-conserved at <italic>A</italic>, or 2 if it is present in only one of the sets <italic>I</italic><sub>1</sub>, <italic>I</italic><sub>2 </sub>and <italic>O</italic>, or 3 if it is present in none of these sets. Note that if an adjacency has an homoplasy cost of 2 or 3 at the ancestral node <italic>A</italic>, then the adjacency is not conserved at this node. For example, in Figure <xref ref-type="fig" rid="F1">1</xref>, the adjacency (<italic>f g</italic>) has a cost 0, the adjacency (<italic>a b</italic>) a cost 1, the adjacency (<italic>a −b</italic>) a cost 2, while the adjacency (<italic>a c</italic>) has a cost 3.</p>
  </sec>
  <sec sec-type="methods">
    <title>Method</title>
    <p>The homology-based problem considered in this paper for the reconstruction of ancestral gene orders can be stated as follows:</p>
    <p><italic>Problem</italic>. Given a species tree on a set of extant genomes, each composed of the same set of blocks, and given an ancestral node in this species tree, find a set of CARs at the ancestral node, with a maximum number of adjacencies, that minimizes the total homoplasy cost.</p>
    <p>Compared to other homology-based methods for the reconstruction of ancestral gene orders, the progressive method presented in the following consists in adding adjacencies progressively, as opposed to discarding false adjacencies in a single assembling step.</p>
    <p>A global description of the progressive method steps is presented in the following, and the refined descriptions are presented next.</p>
    <sec>
      <title>Inputs and start</title>
      <p>The input of the method is a phylogeny with a tagged ancestral node whose block order is to be reconstructed, and a set of <italic>n </italic>orthologous blocks that are used to describe the block orders of the genomes at the leaves of the tree. The initialization of the method consists in starting with an initial set of <italic>n </italic>CARs, each composed of a single block.</p>
    </sec>
    <sec>
      <title>Overall idea</title>
      <p>The core of the method relies on iteratively computing new block adjacencies in order to concatenate CARs progressively (see Figure <xref ref-type="fig" rid="F2">2</xref> that shows the diagram of the method steps). At each step, a set of potential adjacencies is first detected, then the method selects a subset of non-conflicting adjacencies that are added to the current CARs. The following three steps are used iteratively in order to collect the ancestral adjacencies: Step a) consists in detecting the conserved adjacencies and the homoplasy costs of these adjacencies are used to classify and select a subset of non-conflicting adjacencies to be added in current CARs; Step b) consists in resolving conflicts between adjacencies and selecting a subset of non-conflicting adjacencies to be added in current CARs; Step c) consists in detecting some adjacencies not conserved at the ancestral node, but supported by putative genome rearrangement events. In the next paragraphs, we briefly give an overview of each of these steps.</p>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p><bold>Diagram of the method steps</bold>. Overall description of the ProCARs method steps</p>
        </caption>
        <graphic xlink:href="1471-2164-16-S5-S6-2"/>
      </fig>
      <sec>
        <title>a) Adding non-conflicting conserved adjacencies</title>
        <p>This step comes after the initialization phase, or after a step a), or b) or c) that ended up with a non-empty set of added adjacencies. The step begins with the detection of the conserved adjacencies between the current CARs at the ancestral node. Next, the non-conflicting fully-conserved adjacencies are selected in a first phase. Then, the non-conflicting partly-conserved adjacencies that are compatible with all fully-conserved adjacencies are added in a second phase. The set of all conserved adjacencies added in the CARs in this step is denoted by NC. It constitutes a non-conflicting set of adjacencies. The conserved adjacencies not added in this step are stored in a set C and tagged as conflicting adjacencies for a next step b).</p>
      </sec>
      <sec>
        <title>b) Resolving conflicts between adjacencies</title>
        <p>This step comes after a step a) that ended up with an empty set NC, and a non-empty set C. It considers the set C of adjacencies tagged as conflicting in this last step a). A cost, different from the homoplasy cost, is computed for each of these adjacencies, and a non-conflicting subset C<italic><sub>m </sub></italic>of C that has a maximum size and minimizes the sum of the adjacencies costs is computed. This subset of adjacencies is added in the CARs, and the remaining adjacencies of the set C−C<italic><sub>m </sub></italic>are discarded permanently.</p>
      </sec>
      <sec>
        <title>c) Detecting DCJ-reliable adjacencies</title>
        <p>This step comes after a step a) that ended up with an empty set NC, and an empty set C. It consists in finding new potential adjacencies that are not conserved at the ancestral node (<italic>i.e</italic>. neither partly-conserved nor fully-conserved). Each of these new potential adjacencies is supported by the presence of an adjacency in the current set of CARs, and two adjacencies in an extant genome <italic>G</italic>, such that those three adjacencies completed by the new potential adjacency induce a single genome rearrangement event, specifically Double-Cut-and-Join (DCJ) events, between the ancestral genome and the genome <italic>G</italic>. A maximum size non-conflicting subset of the new potential adjacencies is added in the CARs, and the remaining adjacencies are discarded permanently.</p>
        <p>We now give the detailed descriptions of Step a), b) and c).</p>
      </sec>
    </sec>
    <sec>
      <title>Step a): Detection of non-conflicting conserved adjacencies</title>
      <p>In this section, we first explain how the conserved adjacencies are defined. Next, we describe how a subset of non-conflicting adjacencies is selected by giving priority to the fully-conserved adjacencies.</p>
      <sec>
        <title>Detection of the conserved adjacencies</title>
        <p>We begin by stating the definition of a <italic>CAR adjacency </italic>in an extant genome at a leaf of the species tree, given the set of CARs in the current step of the method.</p>
        <p>Let us recall that a <italic>CAR </italic>is an oriented sequence of signed blocks. We denote by |<italic>x</italic>| the block corresponding to a signed block <italic>x </italic>in a CAR. A <italic>signed CAR </italic>is a CAR possibly preceded by − indicating its reverse orientation. For example, if car_x = {<italic>a −b c</italic>}, then -car_x = {−<italic>c b − a</italic>}.</p>
        <p>Let car_a and car_b be two signed CARs in the current set of CARs with car_a = {<italic>a</italic><sub>1 </sub><italic>a</italic><sub>2 </sub>... <italic>a<sub>n</sub></italic>} and car_b = {<italic>b</italic><sub>1 </sub><italic>b</italic><sub>2 </sub>... <italic>b<sub>m</sub></italic>}.</p>
        <p>The ordered pair (car_a car_b) is a <italic>CAR adjacency </italic>in an extant genome <italic>G </italic>if there exists a pair of segments <italic>S<sub>a </sub></italic>and <italic>S<sub>b </sub></italic>consecutive in genome <italic>G </italic>such that the segment <italic>S<sub>a </sub></italic>(resp. <italic>S<sub>b</sub></italic>) contains only blocks from car_a (resp. car_b), and satisfies the following constraints:</p>
        <p>1. i.) <italic>S<sub>a </sub></italic>is either the segment {<italic>a<sub>n</sub></italic>}, else ii) a segment of length <italic>n<sub>a </sub></italic>&gt; 1 ending with the block |<italic>a<sub>n</sub></italic>|, else iii) a segment syntenic to a segment of car_a containing the block |<italic>a<sub>n</sub></italic>|,</p>
        <p>2. i) <italic>S<sub>b </sub></italic>is either the segment {<italic>b</italic><sub>1</sub>}, else ii) a segment of length <italic>n<sub>b </sub></italic>&gt; 1 starting with the block |<italic>b</italic><sub>1</sub>|, else iii) a segment syntenic to a segment of car_b containing the block |<italic>b</italic><sub>1</sub>|.</p>
        <p>As for the blocks, the CAR adjacency (car_a car_b) is equivalent to (−car_b - car_a).</p>
        <p>For example, consider the following three CARs composed of ten blocks:</p>
        <p>car_1 = <italic>• a b c • </italic>;</p>
        <p>car_2 = <italic>• d e f g • </italic>;</p>
        <p>car_3 = <italic>• h i j •</italic>.</p>
        <p>The genome <italic>G </italic>= <italic>• b c −d f • </italic>; <italic>• e −g i j a −h • </italic>has three CAR adjacencies: (car_1 car_2), (car_2 −car_3), and (car_3 car_1). The pair (car_1 car_2) is a CAR adjacency because of segment <italic>S</italic><sub>1 </sub>= {<italic>c</italic>} and <italic>S</italic><sub>2 </sub>= {<italic>−d f </italic>} that are consecutive in the genome <italic>G</italic>, and such that <italic>S</italic><sub>1 </sub>satisfies the constraint 1.i) and <italic>S</italic><sub>2 </sub>satisfies the constraint 2.ii). The CAR adjacency (car_2 - car_3) is supported by the segments <italic>S</italic><sub>2 </sub>= {<italic>e −g</italic>} satisfying 1.ii) and <italic>S</italic><sub>3 </sub>= {<italic>i j</italic>} = {<italic>−j −i</italic>} satisfying 2.iii). The CAR adjacency (car_3 car_1) is supported by the segments <italic>S</italic><sub>3 </sub>= {<italic>j</italic>} satisfying 1.i) and <italic>S</italic><sub>1 </sub>= {<italic>a</italic>} satisfying 2.i).</p>
        <p>The <italic>block adjacency corresponding to the CAR adjacency </italic>(car_a car_b) with car_a = {<italic>a</italic><sub>1 </sub><italic>a</italic><sub>2 </sub>... <italic>a<sub>n</sub></italic>} and car_b = {<italic>b</italic><sub>1 </sub><italic>b</italic><sub>2 </sub>... <italic>b<sub>m</sub></italic>} is the adjacency (<italic>a<sub>n </sub>b</italic><sub>1</sub>).</p>
        <p>In the previous example, the block adjacencies corresponding to (car_1 car_2), (car_2 - car_3) and (car_3 car_1) are respectively (<italic>c d</italic>), (<italic>g −j</italic>), and (<italic>j a</italic>).</p>
        <p><bold>Proposition 1 </bold><italic>Let car_a </italic>= {<italic>a</italic><sub>1 </sub><italic>a</italic><sub>2 </sub>... <italic>a<sub>n</sub></italic>} <italic>be a signed CAR in the current set of CARs. An extant genome G has at most two CAR adjacencies of the form </italic>(<italic>car_a car_x</italic>).</p>
        <p><italic>Proof </italic>Let us suppose that an extant genome <italic>G </italic>has more than two CAR adjacencies of the form (car_a car_x). Say (car_a car_x), (car_a car_y), and (car_a car_z) are three of them. These CAR adjacencies would be supported by 1) three pairs of consecutive segments on <italic>G</italic>, <inline-formula><mml:math id="M1" name="1471-2164-16-S5-S6-i1" overflow="scroll"><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-punc">,</mml:mo><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-punc">,</mml:mo><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula>, such that 2) <inline-formula><mml:math id="M2" name="1471-2164-16-S5-S6-i2" overflow="scroll"><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:math></inline-formula> contain the block |<italic>a<sub>n</sub></italic>|, and 3) <italic>S<sub>x</sub></italic>, <italic>S<sub>y </sub></italic>, <italic>S<sub>z </sub></italic>are non-intersecting segments since they belong to three different CARs. It is impossible to find an ordering of the six segments on <italic>G </italic>such that the constraints 1), 2) and 3) are all satisfied simultaneously. Thus, the genome <italic>G </italic>contains at most two CAR adjacencies of the form (car_a car_x).   □</p>
        <p><bold>Remark 1 </bold><italic>The definitions of fully or partly conserved adjacencies are naturally extended to CAR adjacencies as follows: a </italic>conserved CAR adjacency <italic>at an ancestral node of the species tree is a CAR adjacency shared by at least two extant genomes that belong to at least two different sets of the species partition defined by the ancestral node. A </italic>fully-conserved CAR adjacency <italic>is a conserved CAR adjacency belonging to at least one genome of each of the three sets of the species partition defined by the ancestral node. A </italic>partly-conserved CAR adjacency <italic>is any other conserved CAR adjacency. The homoplasy cost associated to a CAR adjacency is a natural extension of the definition given for the block adjacencies</italic>.</p>
      </sec>
      <sec>
        <title>Classification and selection of the conserved adjacencies</title>
        <p>The overall idea of this phase is to select conserved adjacencies while giving priority to the fully-conserved adjacencies, and to the adjacencies that have the less conflicts with other adjacencies.</p>
        <p>Let S be the set of block adjacencies corresponding to the conserved CAR adjacencies at the ancestral node. In the sequel, the abbreviations FS, PS, NC, C stand for <italic>Fully</italic>, <italic>Partly</italic>, <italic>Non-Conflicting</italic>, and <italic>Conflicting </italic>conserved adjacencies respectively. Figure <xref ref-type="fig" rid="F3">3</xref> shows the organization of the sets of adjacencies that are considered in this phase.</p>
        <fig id="F3" position="float">
          <label>Figure 3</label>
          <caption>
            <p><bold>Organization of the sets of adjacencies considered in Step a)</bold>. A tree whose nodes represent sets of conserved adjacencies found at the current step of the method, and edges represent the inclusion relations between the sets: the root of the tree is the set S of all conserved adjacencies. Abbreviations: FS (Fully-conserved adjacencies), PS (Partly-conserved adjacencies), NC (Non-Conflicting), C (Conflicting), R (Retained), and D (Discarded). Non-conflicting sets are represented with square nodes. The sets of non-conflicting adjacencies added at the current step are represented with black-colored nodes. The sets of conflicting adjacencies saved for the next step b) are represented with gray-colored nodes.</p>
          </caption>
          <graphic xlink:href="1471-2164-16-S5-S6-3"/>
        </fig>
        <p>Let FS and PS be the subsets of S that contain respectively the fully-conserved adjacencies and the partly-conserved adjacencies. Thus, <italic>S </italic>= FS ∪ PS and FS <italic>∩ </italic>PS = ∅.</p>
        <p>First, we consider the fully-conserved adjacencies. Let FS_NC be the subset of FS that contains the adjacencies that are compatible with all other adjacencies in FS. The corresponding set of conflicting adjacencies is FS_C = FS - FS_NC. The fully-conserved non-conflicting adjacencies contained in the set FS_NC are automatically retained to be added in the CARs. Thus, (*) in the following, any adjacency that is in conflict with some adjacencies of FS_NC will be discarded permanently.</p>
        <p>Next, we consider the partly-conserved adjacencies. Let PS_D be the subset of PS containing adjacencies that are in conflict with some adjacencies of FS_NC, and PS_R be the set of the remaining adjacencies in PS. Thus, PS_R = PS - PS_D. The adjacencies of PS_D are discarded permanently, as explained previously in (*).</p>
        <p>Let PS_NC be the subset of PS_R that contains the adjacencies that are compatible with all other adjacencies in PS_R. The corresponding set of conflicting adjacencies is PS_C = PS_R - PS_NC.</p>
        <p>Finally, since the priority is given to fully-conserved adjacencies, we want to retain only the adjacencies of PS_NC that are not in conflict with the adjacencies of the set FS. Let PS_NC<sup>2 </sup>be the subset of PS_NC that contains the adjacencies that are compatible with all the adjacencies in FS. The partly-conserved non-conflicting adjacencies contained in the set PS_NC<sup>2 </sup>are also retained automatically to be added in the CARs.</p>
        <p>It follows that the set of retained adjacencies NC = FS_NC ∪ PS_NC<sup>2 </sup>is a set of non-conflicting adjacencies.</p>
        <p>This step a) of the method adds the set of adjacencies NC to the current CARs of the ancestral genome, and updates the current set of conflicting adjacencies to the set C = S - PS_D − NC. By construction, each adjacency contained in the set C is in conflict with at least one other adjacency of C, and compatible with all the adjacencies contained in the set NC.</p>
        <p>The step a) can be recalled several times consecutively as far as the set NC of added adjacencies is not empty. We now state a proposition ensuring that the current set of conflicting adjacencies <italic>C </italic>misses no previously found conflicting adjacency (<italic>a b</italic>) such that the signed block <italic>a </italic>is the end of a signed CAR, and the signed block <italic>b </italic>is the start of a signed CAR in the current set of CARs.</p>
        <p><bold>Proposition 2 </bold><italic>Let </italic>(<italic>a b</italic>) <italic>be an adjacency corresponding to a conserved CAR adjacency found in a previous step a) of the method. The adjacency </italic>(<italic>a b</italic>) <italic>is either present in the current set of CARs, or is in conflict with an adjacency present in the current set of CARs, or is also found in the current step a) i.e </italic>(<italic>a b</italic>) ∈ <italic>S</italic>.</p>
        <p><italic>Proof </italic>Say that, in a previous step a), the adjacency (<italic>a b</italic>) was supported by the detection of a conserved CAR adjacency (car_a<sub>1 </sub>car_b<sub>1</sub>) present in a subset <italic>G </italic>of the extant genomes.</p>
        <p>1) If there exist in the current set of CARs, a signed CAR car_a<sub>2 </sub>ending with the signed block <italic>a</italic>, and a signed CAR car_b<sub>2 </sub>starting with the signed block <italic>b</italic>, then the CAR adjacency (car_a<sub>2 </sub>car_b<sub>2</sub>) is also found in the same set <inline-formula><mml:math id="M3" name="1471-2164-16-S5-S6-i3" overflow="scroll"><mml:mrow><mml:mtext> </mml:mtext><mml:mi mathvariant="script">G</mml:mi></mml:mrow></mml:math></inline-formula> of extant genomes. Thus, the adjacency (<italic>a b</italic>) is also found in the current step.</p>
        <p>2) Otherwise, either there exists an adjacency of the form (<italic>a c</italic>) or (<italic>c b</italic>) in the current set of CARs in conflict with the adjacency (<italic>a b</italic>), or the adjacency (<italic>a b</italic>) is present in the current set of CARs.   □</p>
      </sec>
    </sec>
    <sec>
      <title>Step b): Resolution of conflicts between adjacencies</title>
      <p>This step considers a conflicting set C of adjacencies obtained at the end of a previous step a), and computes a non-conflicting subset of the set C to be added in the current set of CARs.</p>
      <sec>
        <title>Definition of the cost of adjacencies</title>
        <p>We begin by stating the definition of the cost of an adjacency in this step. The <italic>mutation cost </italic>of a labeling of the nodes of a species tree on a given alphabet is the number of edges in the tree having two different labels at their extremities [<xref ref-type="bibr" rid="B13">13</xref>,<xref ref-type="bibr" rid="B14">14</xref>]. Here, the <italic>cost of an adjacency </italic>(<italic>a b</italic>) ∈ C is the minimum mutation cost of a labeling of the nodes of the species tree on a binary alphabet {0, 1} such that (i) the ancestral node is labeled with 1, (ii) the extant species nodes, where (<italic>a b</italic>) corresponds to a CAR adjacency, are labeled with 1, and (iii) the other extant species nodes are labeled with 0.</p>
        <p>In other terms, an adjacency has two possible states in a genome: present (1) or absent (0). The cost of an adjacency (<italic>a b</italic>) is the minimum number of changes of state necessary to explain the evolutionary history of the adjacency along the species tree, with the adjacency being present at the ancestral node.</p>
        <p>For example, the costs of the two conflicting conserved adjacencies (<italic>g h</italic>) and (<italic>g −h</italic>) shown in Figure <xref ref-type="fig" rid="F1">1</xref> are 3 and 2 respectively. Figure <xref ref-type="fig" rid="F4">4</xref> shows two minimum mutation cost labelings of the nodes of the species tree corresponding to both adjacencies.</p>
        <fig id="F4" position="float">
          <label>Figure 4</label>
          <caption>
            <p><bold>Examples of minimum mutation cost labelings of the nodes of a species tree</bold>. Right and left trees show two minimum mutation cost labelings of the nodes of the species tree for the adjacencies (<italic>g h</italic>) (left labeling) and (<italic>g −h</italic>) (right labeling) conserved at the ancestral node in the species tree depicted in Figure 1. For each labeling, the edges of tree with a change of state are in dashed line. The cost of the left labeling is 3, and the cost of the right labeling is 2.</p>
          </caption>
          <graphic xlink:href="1471-2164-16-S5-S6-4"/>
        </fig>
      </sec>
      <sec>
        <title>Computation of the non-conflicting subset of adjacencies</title>
        <p>The <italic>cost of a set of adjacencies </italic>is the sum of the costs of the adjacencies composing this set.</p>
        <p>Let <italic>m </italic>be the maximum size of a non-conflicting subset of the conflicting set C of adjacencies. This step b) finds a non-conflicting subset C<italic><sub>m </sub></italic>of C of size <italic>m </italic>and minimum cost. The set of adjacencies C<italic><sub>m </sub></italic>is added to the current CARs of the ancestral genome, and the remaining adjacencies in the set C − C<italic><sub>m </sub></italic>are discarded permanently.</p>
        <p><bold>Remark 2 </bold><italic>Note that the adjacencies of the set C − C<sub>m </sub>discarded in this step will never be detected again, since these adjacencies are in conflict with the adjacencies of the set C<sub>m </sub>added in the current step</italic>.</p>
      </sec>
    </sec>
    <sec>
      <title>Step c): Detection of DCJ-reliable adjacencies</title>
      <p>This step considers the current set of CARs, and computes new potential adjacencies not conserved, but supported by putative ancestral rearrangement events.</p>
      <p>A <italic>Double-Cut-and-Join (DCJ) rearrangement event </italic>on a genome consists in the cut of two adjacencies of the genome in order to glue the four exposed extremities in a different way. For example, a DCJ event on the genome <italic>A </italic>= (<italic>• a b c d •</italic>) that cuts the adjacencies (<italic>a b</italic>) and (<italic>c d</italic>) to obtain the adjacencies (<italic>a −c</italic>) and (<italic>−b d</italic>) produces the genome <italic>B </italic>= (<italic>• a −c −b d •</italic>).</p>
      <p>We now give the definition of potential ancestral adjacencies that can be inferred from putative genome rearrangements inspired from the definitions of reliable adjacencies in [<xref ref-type="bibr" rid="B15">15</xref>,<xref ref-type="bibr" rid="B16">16</xref>].</p>
      <p>Here, we add the constraint that the signal of the reliable adjacency must be conserved on a path of the species tree that goes through the ancestor.</p>
      <p>Let car_a and car_b be two signed CARs in the current set of CARs with car_a = {<italic>a</italic><sub>1 </sub><italic>a</italic><sub>2 </sub>... <italic>a<sub>n</sub></italic>} and car_b = {<italic>b</italic><sub>1 </sub><italic>b</italic><sub>2 </sub>... <italic>b<sub>m</sub></italic>}. The adjacency (<italic>a<sub>n </sub>b</italic><sub>1</sub>) is a <italic>DCJ-reliable adjacency </italic>of the ancestral node if there exists an adjacency (<italic>x y</italic>) in the current set of CARs such that the adjacencies (<italic>x b</italic><sub>1</sub>) and (<italic>a<sub>n </sub>y</italic>) are present in an extant genome <italic>G</italic><sub>1</sub>, and (car_a car_b) is a CAR adjacency in an extant genome <italic>G</italic><sub>2 </sub>such that the genomes <italic>G</italic><sub>1 </sub>and <italic>G</italic><sub>2 </sub>belong to two different sets of the species partition defined by the ancestral node.</p>
      <p>The potential presence of the adjacency (<italic>a<sub>n </sub>b</italic><sub>1</sub>) in the ancestral genome induces a DCJ event that has cut the adjacencies (<italic>a<sub>n </sub>b</italic><sub>1</sub>) and (<italic>x y</italic>) in the ancestral genome to produce the adjacencies (<italic>x b</italic><sub>1</sub>) and (<italic>a<sub>n </sub>y</italic>) in the extant genome <italic>G</italic><sub>1</sub>.</p>
      <p>An example is given in Section Results and discussion.</p>
      <p>In this step of the method, a maximum size non-conflicting subset of the DCJ-reliable adjacencies is added in the CARs, and the remaining DCJ-reliable adjacencies are discarded permanently.</p>
      <p><bold>Remark 3 </bold><italic>Note that the homoplasy cost of a DCJ reliable adjacency is always </italic>2.</p>
    </sec>
  </sec>
  <sec>
    <title>Results and discussion</title>
    <p>We used ProCARs to compute a set of CARs for the boreoeutherian ancestral genome using the block orders of twelve amniote genomes, and we compared the result with the ancestors reconstructed by three other homology-based methods: AnGeS [<xref ref-type="bibr" rid="B12">12</xref>], InferCARs [<xref ref-type="bibr" rid="B5">5</xref>] and GapAdj [<xref ref-type="bibr" rid="B11">11</xref>].</p>
    <sec>
      <title>Orthology blocks and phylogeny</title>
      <p>We chose twelve genomes completely assembled and present in a Pecan [<xref ref-type="bibr" rid="B17">17</xref>] multiple alignment of 20 amniote genomes available in the release 73 of the Ensembl Compara database [<xref ref-type="bibr" rid="B18">18</xref>]. The phylogenetic tree was directly infered from the classifications of the species obtained from the National Center for Biotechnology Information Taxonomy database [<xref ref-type="bibr" rid="B19">19</xref>] (see Additional File <xref ref-type="supplementary-material" rid="S1">1</xref>). We constructed a set of synteny blocks using the multiple alignments as seeds. We used the block construction method described in [<xref ref-type="bibr" rid="B20">20</xref>], keeping only the seeds that had an occurrence in each of the twelve genomes, removing the seeds that spanned less than 100Kb, and joining seeds collinear in all genomes. This resulted in a set of 12 genomes composed of 689 blocks for species <italic>Homo sapiens </italic>(GRCh37), <italic>Pan troglodytes </italic>(CHIMP2.1.4), <italic>Pongo abelii </italic>(PPYG2), <italic>Macaca mulatta </italic>(MMUL 1), <italic>Mus musculus </italic>(GRCm38), <italic>Rattus norvegicus </italic>(Rnor 5.0), <italic>Equus caballus </italic>(EquCab2), <italic>Canis familiaris </italic>(CanFam3.1), <italic>Bos taurus </italic>(UMD3.1), <italic>Monodelphis domestica </italic>(BROADO5), <italic>Gallus gallus </italic>(Galgal4) and <italic>Taeniopygia guttata </italic>(taeGut3.2.4).</p>
    </sec>
    <sec>
      <title>Reconstruction of the boreoeutherian ancestor</title>
      <p>ProCARs ran in 5 steps and finally returned 25 CARs with a number of blocks per CAR ranging from 2 to 68 (Table <xref ref-type="table" rid="T1">1</xref>). The total number of adjacencies computed for the boreoeutherian ancestor is 664 compared to the 666, 669, 659 adjacencies present in respectively <italic>Homo sapiens</italic>, <italic>Mus musculus </italic>and <italic>Bos taurus</italic>.</p>
      <table-wrap id="T1" position="float">
        <label>Table 1</label>
        <caption>
          <p>Steps of ProCARs.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="right">Step</th>
              <th align="right">0: init</th>
              <th align="right">1: step a)</th>
              <th align="right">2: step a)</th>
              <th align="right">3: step b)</th>
              <th align="right">4: step c)</th>
              <th align="right">5 step a)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="right">#CARs</td>
              <td align="right">689</td>
              <td align="right">45</td>
              <td align="right">32</td>
              <td align="right">30</td>
              <td align="right">27</td>
              <td align="right">25</td>
            </tr>
            <tr>
              <td colspan="7">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="right">size</td>
              <td align="right">1</td>
              <td align="right">1 - 67</td>
              <td align="right">1 - 68</td>
              <td align="right">1 - 68</td>
              <td align="right">2 - 68</td>
              <td align="right">2 - 68</td>
            </tr>
            <tr>
              <td colspan="7">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="right">#adjacencies</td>
              <td align="right">0</td>
              <td align="right">647</td>
              <td align="right">9</td>
              <td align="right">3</td>
              <td align="right">3</td>
              <td align="right">2</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Number of CARs, number of blocks per CAR, and number of new adjacencies returned at each iteration of ProCARs method.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>The numbers of blocks per CAR are detailed in Table <xref ref-type="table" rid="T2">2</xref>. The human chromosomal syntenies are 1-5, 3-21, 4-8, 8-19, 12-22, 14-15 and 16-19. In [<xref ref-type="bibr" rid="B21">21</xref>], the boreoeuthe-rian ancestor has two more human chromosomal syntenies 7-16 and 10-12-22, and all other syntenies were also found by ProCARs.</p>
      <table-wrap id="T2" position="float">
        <label>Table 2</label>
        <caption>
          <p>CARs of ProCARs.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="left">CAR</th>
              <th align="center">1</th>
              <th align="center">2</th>
              <th align="center">3</th>
              <th align="center">4</th>
              <th align="center">5</th>
              <th align="center">6</th>
              <th align="center">7</th>
              <th align="center">8</th>
              <th align="center">9</th>
              <th align="center">10</th>
              <th align="center">11</th>
              <th align="center">12</th>
              <th/>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">size</td>
              <td align="center">57</td>
              <td align="center">46</td>
              <td align="center">9</td>
              <td align="center">27</td>
              <td align="center">36</td>
              <td align="center">3</td>
              <td align="center">17</td>
              <td align="center">15</td>
              <td align="center">53</td>
              <td align="center">12</td>
              <td align="center">18</td>
              <td align="center">32</td>
              <td/>
            </tr>
            <tr>
              <td colspan="14">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">hcs</td>
              <td align="center">1</td>
              <td align="center">
                <bold>1-5</bold>
              </td>
              <td align="center">10</td>
              <td align="center">10</td>
              <td align="center">11</td>
              <td align="center">12</td>
              <td align="center">
                <bold>12-22</bold>
              </td>
              <td align="center">13</td>
              <td align="center">
                <bold>14-15</bold>
              </td>
              <td align="center">16</td>
              <td align="center">
                <bold>16-19</bold>
              </td>
              <td align="center">17</td>
              <td/>
            </tr>
            <tr>
              <td colspan="14">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">CAR</td>
              <td align="center">13</td>
              <td align="center">14</td>
              <td align="center">15</td>
              <td align="center">16</td>
              <td align="center">17</td>
              <td align="center">18</td>
              <td align="center">19</td>
              <td align="center">20</td>
              <td align="center">21</td>
              <td align="center">22</td>
              <td align="center">23</td>
              <td align="center">24</td>
              <td align="center">25</td>
            </tr>
            <tr>
              <td colspan="14">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">size</td>
              <td align="center">20</td>
              <td align="center">15</td>
              <td align="center">28</td>
              <td align="center">30</td>
              <td align="center">28</td>
              <td align="center">68</td>
              <td align="center">50</td>
              <td align="center">43</td>
              <td align="center">7</td>
              <td align="center">20</td>
              <td align="center">2</td>
              <td align="center">47</td>
              <td align="center">6</td>
            </tr>
            <tr>
              <td colspan="14">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">hcs</td>
              <td align="center">18</td>
              <td align="center">
                <bold>8-19</bold>
              </td>
              <td align="center">2</td>
              <td align="center">2</td>
              <td align="center">20</td>
              <td align="center">
                <bold>3-21</bold>
              </td>
              <td align="center">
                <bold>4-8</bold>
              </td>
              <td align="center">6</td>
              <td align="center">7</td>
              <td align="center">7</td>
              <td align="center">8</td>
              <td align="center">9</td>
              <td align="center">X</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Number of blocks and human chromosomal syntenies (hcs) for each CAR computed by ProCARs. Human chromosomal syntenies involving two human chromosomes are in bold.</p>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>Comparison with other methods</title>
      <p>All the methods (ProCARs, AnGeS [<xref ref-type="bibr" rid="B12">12</xref>], InferCARs [<xref ref-type="bibr" rid="B5">5</xref>] and GapAdj [<xref ref-type="bibr" rid="B11">11</xref>]) take as input a phylogeny with a tagged ancestral node in this phylogeny, and a set of blocks with the arrangement of the blocks in each extant genome of the phylogeny. AnGeS [<xref ref-type="bibr" rid="B12">12</xref>] first builds a set of potential ancestral features (adjacencies, and sets of contiguous blocks) by comparing pairs of species whose path goes through the tagged ancestral node. Then, an arrangement of the blocks that corresponds to a subset of these adjacencies is built in order to satisfy the consecutive ones property. This assembling phase requires the length of the branches of the phylogenetic tree. InferCARs [<xref ref-type="bibr" rid="B5">5</xref>] is based on an adaptation of the Fitch parsimony method for adjacencies. Potential neighbors of blocks are modeled through graphs at each node of the phylogenetic tree. Conflicts between potential neighboring relations are resolved using a weight function which requires the length of the branches of the phylogenetic tree. GapAdj [<xref ref-type="bibr" rid="B11">11</xref>] works iteratively, detecting new adjacencies at each step by allowing more and more gaps within adjacencies until the maximum number of gaps MAX<italic><sub>α </sub></italic>is reached. At each step, the assembling of the extended CARs is done using a TSP algorithm, and a threshold <italic>τ </italic>is required to discard the less reliable adjacencies.</p>
      <p>As GapAdj is the only method with parameters (MAX<italic><sub>α </sub></italic>and <italic>τ </italic>), we ran GapAdj on 500 sets of parameters for MAX<italic><sub>α </sub></italic>ranging from 1 to 10, and <italic>τ </italic>ranging from 0.50 to 0.99. We then selected the reconstruction that had the minimal breakpoint distance to the ancestor reconstructed by ProCARs. The breakpoint distance between two genomes is the number of blocks extremities whose neighbors are not conserved in both genomes. Among the 500 sets of parameters tested, the closest result is obtained when <italic>τ </italic>equals 0.79 and MAX<italic><sub>α </sub></italic>equals 3, giving a breakpoint distance of 32.5 between this reconstruction and the ancestor reconstructed by ProCARs. That corresponds to 4.7% of the block extremities having different neighbors in both reconstructions. Note that the reconstruction selected for GapAdj is also the closest to the ancestors reconstructed by InferCARs and AnGeS.</p>
      <p>Figure <xref ref-type="fig" rid="F5">5</xref> gives the breakpoint distances between all pairwise comparisons. This shows that GapAdj is the method which gives the most different result, while AnGeS is the method which finds the closest result to ProCARs. The distribution of the number of blocks involved in each CAR is roughly the same (Figure <xref ref-type="fig" rid="F6">6</xref>).</p>
      <fig id="F5" position="float">
        <label>Figure 5</label>
        <caption>
          <p><bold>Breakpoint distances between the sets of CARs</bold>. The label on each edge gives the breakpoint distance between the two methods in the nodes.</p>
        </caption>
        <graphic xlink:href="1471-2164-16-S5-S6-5"/>
      </fig>
      <fig id="F6" position="float">
        <label>Figure 6</label>
        <caption>
          <p><bold>Distribution of the number of blocks involved in each CAR</bold>. For each of the four methods, the number of CARs for which the number of blocks is in a given range is plotted.</p>
        </caption>
        <graphic xlink:href="1471-2164-16-S5-S6-6"/>
      </fig>
      <p>We then computed the list of adjacencies shared by all the methods and the adjacencies that are specific to a subset of the methods, as shown in Figure <xref ref-type="fig" rid="F7">7</xref>. The number of adjacencies shared by all the methods is 635. The method which infers the highest number of specific adjacencies is GapAdj (15 adjacencies), as suggested by the breakpoint distances shown in Figure <xref ref-type="fig" rid="F5">5</xref>. All adjacencies found by AnGeS are also found by ProCARs, as confirmed by the small breakpoint distance between the two methods. Finally, it is noteworthy that there is no adjacency shared by the three methods AnGeS, InferCARs and GapAdj that is not found by ProCARs.</p>
      <fig id="F7" position="float">
        <label>Figure 7</label>
        <caption>
          <p><bold>Number of adjacencies shared or exclusive for each of the four methods compared</bold>. AnGeS contains no specific adjacency. For example, 635 adjacencies are shared by all the methods, and 16 are shared between AnGeS, InferCARs and ProCARs. For ProCARs and GapAdj (in italic), we also give the number of adjacencies and the step in which they have been added. For example, there are 15 adjacencies exclusive to GapAdj, of which 9 have been added at step 1, 5 at step 2 and 1 at step 3.</p>
        </caption>
        <graphic xlink:href="1471-2164-16-S5-S6-7"/>
      </fig>
      <sec>
        <title>Justification of ProCARs specific adjacencies</title>
        <p>Adjacency (50 − 545) is found at iteration 4 of ProCARs. In the other methods, the block 50 is alone in a single-block CAR. This adjacency was detected thanks to a step c) of ProCARs method. It is then a DCJ-reliable adjacency detected as follows: at iteration 3, adjacency (535 536) was found, block 50 is at the end of CAR 2, and block 545 is at the end of CAR 20. In <italic>Bos taurus</italic>, the CAR adjacency (2 − 20) is conserved. In <italic>Mus musculus</italic>, block adcencies (545 536) and (50 − 535) are present. Hence, as the path from <italic>Bos taurus </italic>to <italic>Mus musculus </italic>goes through the ancestor, a potential DCJ rearrangement on adjacencies (50 − 545) and (535 536) in the ancestor could explain the adjacencies found in <italic>Mus musculus</italic>: (545 536) and (50 − 535). Moreover, this adjacency (50 − 545) found by ProCARs is the one supporting the human chromosomal synteny 1-5 that was also reported in [<xref ref-type="bibr" rid="B21">21</xref>] using a cytogenetic method, but not found by any of the other methods (see Table <xref ref-type="table" rid="T3">3</xref>).</p>
        <table-wrap id="T3" position="float">
          <label>Table 3</label>
          <caption>
            <p>Comparison of human chromosomal syntenies.</p>
          </caption>
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <th align="left">Human chromosomal syntenies</th>
                <th align="center">1-5</th>
                <th align="center">3-21</th>
                <th align="center">4-8</th>
                <th align="center">7-16</th>
                <th align="center">8-19</th>
                <th align="center">12-22</th>
                <th align="center">14-15</th>
                <th align="center">16-19</th>
                <th align="center">7-9</th>
                <th align="center">5-6-18</th>
                <th align="center">10-11</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">In [<xref ref-type="bibr" rid="B21">21</xref>]</td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">+10</td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">--</td>
                <td align="center">--</td>
                <td align="center">--</td>
              </tr>
              <tr>
                <td colspan="12">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td align="left">ProCARs</td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">--</td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">--</td>
                <td align="center">--</td>
                <td align="center">--</td>
              </tr>
              <tr>
                <td colspan="12">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td align="left">AnGeS</td>
                <td align="center">--</td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">--</td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">--</td>
                <td align="center">--</td>
                <td align="center">--</td>
              </tr>
              <tr>
                <td colspan="12">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td align="left">InferCARs</td>
                <td align="center">--</td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">--</td>
                <td align="center">--</td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">--</td>
                <td align="center">--</td>
                <td align="center">--</td>
                <td align="center">--</td>
                <td align="center">--</td>
              </tr>
              <tr>
                <td colspan="12">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td align="left">GapAdj</td>
                <td align="center">--</td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">+2</td>
                <td align="center">--</td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">--</td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">
                  <italic>•</italic>
                </td>
                <td align="center">
                  <italic>•</italic>
                </td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>For each method, we give which human chromosomal synteny is found. A number in a cell indicates that the synteny is found but with additionnal part of another chromosome.</p>
          </table-wrap-foot>
        </table-wrap>
        <p>Adjacency (616 618) is found at iteration 2. It is then a conserved adjacency detected as follows: at iteration 1, block 616 is alone in a CAR, and block −618 is at the end of a CAR. This adjacency (616 618) is present, on the one hand, in <italic>Mus musculus </italic>and <italic>Rattus norvegicus </italic>(ingroup <italic>I</italic><sub>2</sub>) and on the other hand in <italic>Equus caballus </italic>and <italic>Bos taurus </italic>(ingroup <italic>I</italic><sub>1</sub>). Hence, it is a partly-conserved adjacency and, as it is not in conflict with any other conserved adjacency, ProCARs joined 616 and 618 at iteration 2. In InferCARs and AnGeS, 616 is alone in a CAR while 618 is also at the begining of a CAR. Therefore, CARs found by InferCARs and AnGeS are not in conflict with the adjacency (616 618) that ProCARs added, but no signal was found by those methods to infer this adjacency. In GapAdj, 618 is alone in a CAR while 616 is in a CAR containing (−299 616 617). However, (616 617) is only present in species in the ingroup <italic>I</italic><sub>2 </sub>(<italic>Homo sapiens</italic>, <italic>Pan troglodytes</italic>, <italic>Pongo abelii </italic>and <italic>Macaca mulatta</italic>). Therefore it is not a conserved adjacency, and that is why ProCARs preferred the partly-conserved adjacency (616 618).</p>
      </sec>
      <sec>
        <title>Justification of adjacencies not found by ProCARs</title>
        <p>AnGeS contains no specific adjacency and thus ProCARs found all adjacencies detected by AnGeS. There are 2 adjacencies found by both GapAdj and InferCARs but not by ProCARs.</p>
        <p>For adjacency (67 68), InferCARs inferred a unique CAR which is the concatenation of CARs 3 and 4 of ProCARs involving respectively blocks 67 and 68. GapAdj also inferred this concatenation of the two ProCARs CARs, except a segment of the CAR involving block 68 in ProCARs which is in a separated CAR. The (67 68) adjacency is only present in <italic>Homo sapiens</italic>, <italic>Pan troglodytes</italic>, <italic>Pongo abelii </italic>and <italic>Macaca mulatta </italic>(ingroup <italic>I</italic><sub>2</sub>) and hence cannot be a partly-conserved adjacency. It is not a DCJ-reliable adjacency either.</p>
        <p>Concerning the adjacency (−657 658), ProCARs has adjacencies (−657 − 659 − 658) in CAR 24 while InferCARs (resp. GapAdj) created adjacencies (−657 658 659) in CAR 28 (resp. 27). The adjacency (−657 658) is present only in <italic>Mus musculus </italic>and <italic>Rattus norvegicus </italic>(ingroup <italic>I</italic><sub>2</sub>) and is hence not a conserved adjacency. It is not a DCJ-reliable adjacency either, otherwise this adjacency would have been detected during iteration 4.</p>
      </sec>
      <sec>
        <title>Human chromosomal syntenies</title>
        <p>Human syntenies found by other methods are: for AnGeS: 3-21, 4-8, 8-19, 12-22, 14-15, 16-19; for InferCARs: 3-21, 4-8 and 12-22; for GapAdj: 2-4-8, 3-21, 7-9, 5-6-18, 8-19, 10-11, 12-22 and 16-19. A comparison between the four methods is given in Table <xref ref-type="table" rid="T3">3</xref> and a karyotype of the ancestral genomes in Additional File <xref ref-type="supplementary-material" rid="S2">2</xref>. We can notice that ProCARs returns the closest result to the ancestor reconstructed in [<xref ref-type="bibr" rid="B21">21</xref>] using a cytogenetic method.</p>
      </sec>
    </sec>
  </sec>
  <sec sec-type="conclusions">
    <title>Conclusions</title>
    <p>InferCARs is the first method using an adaptation of the Fitch algorithm to infer ancestral gene orders based on homology instead of rearrangements. AnGeS makes use of common intervals to be able to account for micro-rearrangements. GapAdj brings the iterative approach allowing to build CARs step by step. With ProCARs, we propose a new methodology which combines the different approaches found in other methods, using a model based on adjacencies only.</p>
    <p>ProCARs has the advantage to be a parameter-free method, without the requirement of branch lengths for the phylogenetic tree. ProCARs is based on a single definition of contiguity, the CAR adjacency, that allows some micro-rearrangements under a very simple model. However, since ProCARs considers only genomes containing the same set of non-duplicated blocks, it does not allow to reconstruct ancestors in the context of duplication or loss events.</p>
    <p>In order to select the adjacencies at each step of ProCARs, the adjacencies are classified according to an homoplasy cost instead of using a heuristic assembly algorithm. ProCARs gives priority to discarding conflicting adjacencies rather than necessarily adding new adjacencies at each step.</p>
    <p>The final result of ProCARs is a set of completely resolved CARs, for which the arrangements of all the blocks are given.</p>
    <p>As for other homology-based methods, ProCARs is not suitable in the case of convergent evolution. ProCARs is also a greedy algorithm which could be seen as a disadvantage because adjacencies are added permanently at each step. However, this greediness is balanced by the fact that ProCARs works iteratively and adds only reliable non-conflicting adjacencies at each step.</p>
  </sec>
  <sec>
    <title>Availability of supporting data</title>
    <p>ProCARs is written in Python and is available at <ext-link ext-link-type="uri" xlink:href="http://bioinfo.lifl.fr/procars">http://bioinfo.lifl.fr/procars</ext-link>. The dataset used in section</p>
    <p>Results and discussion is also available from this web page.</p>
  </sec>
  <sec>
    <title>List of abbreviations</title>
    <p>TSP: Traveling Salesman Problem; CAR: Contiguous Ancestral Region; NC: Non-Conflicting adjacencies; C: Conflicting adjacencies; FS: Fully-conserved adjacencies; PS: Partly-conserved adjacencies; R: Retained adjacencies; D: Discarded adjacencies.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>AP wrote the program and its documentation, ran the experiments, and presented the results at the conference ISCB-LA'14. AP, JSV, SB and AO analyzed and interpreted the data. JSV wrote the results section. AO conceived the study and its design, wrote a prototype of the program, and drafted the manuscript. AP, JSV and SB critically revised the manuscript. All authors read and approved the final manuscript.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="S1">
      <caption>
        <title>Additional file 1</title>
        <p><bold>Phylogeny of the 12 species used in the application</bold>. A figure at the PDF format depicting the phylogeny of the 12 species used in the application. The black node in the phylogeny corresponds to the boreoeutherian ancestor.</p>
      </caption>
      <media xlink:href="1471-2164-16-S5-S6-S1.pdf">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="S2">
      <caption>
        <title>Additional file 2</title>
        <p><bold>Chromosomal syntenies with the human genome</bold>. A figure at the PDF format depicting the Human chromosomal syntenies between the boreoeutherian ancestor found by the four methods ProCARs, InferCARs, GapAdj and AnGeS.</p>
      </caption>
      <media xlink:href="1471-2164-16-S5-S6-S2.pdf">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>AP's engineer position is supported by a Région Nord-Pas-de-Calais funding (Projets Emergents). The participation of AP and AO to the conference ISCB-LA in October 2014 was funded by Inria and Université de Sherbrooke. Inria provided the funding for publication of the article.</p>
    <p>This article has been published as part of <italic>BMC Genomics </italic>Volume 16 Supplement 5, 2015: Proceedings of the 10th International Conference of the Brazilian Association for Bioinformatics and Computational Biology (X-Meeting 2014). The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/bmcgenomics/supplements/16/S5">http://www.biomedcentral.com/bmcgenomics/supplements/16/S5</ext-link>.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bourque</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Pevzner</surname>
          <given-names>PA</given-names>
        </name>
        <article-title>Genome-scale evolution: reconstructing gene orders in the ancestral species</article-title>
        <source>Genome Research</source>
        <year>2002</year>
        <volume>12</volume>
        <issue>1</issue>
        <fpage>26</fpage>
        <lpage>36</lpage>
        <?supplied-pmid 11779828?>
        <pub-id pub-id-type="pmid">11779828</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Sankoff</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Blanchette</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Multiple genome rearrangement and breakpoint phylogeny</article-title>
        <source>Journal of Computational Biology</source>
        <year>1998</year>
        <volume>5</volume>
        <fpage>555</fpage>
        <lpage>570</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.1998.5.555</pub-id>
        <?supplied-pmid 9773350?>
        <pub-id pub-id-type="pmid">9773350</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zheng</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Sankoff</surname>
          <given-names>D</given-names>
        </name>
        <article-title>On the pathgroups approach to rapid small phylogeny</article-title>
        <source>BMC Bioinformatics</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>4</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-12-4</pub-id>
        <?supplied-pmid 21208430?>
        <pub-id pub-id-type="pmid">21208430</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bergeron</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Blanchette</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Chateau</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Chauve</surname>
          <given-names>C</given-names>
        </name>
        <article-title>Reconstructing ancestral gene orders using conserved intervals</article-title>
        <source>Lecture Notes in Computer Science</source>
        <year>2004</year>
        <volume>3240</volume>
        <fpage>14</fpage>
        <lpage>25</lpage>
        <pub-id pub-id-type="doi">10.1007/978-3-540-30219-3_2</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Ma</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Suh</surname>
          <given-names>BB</given-names>
        </name>
        <name>
          <surname>Rany</surname>
          <given-names>BJ</given-names>
        </name>
        <name>
          <surname>Burhans</surname>
          <given-names>RC</given-names>
        </name>
        <name>
          <surname>Kent</surname>
          <given-names>WJ</given-names>
        </name>
        <name>
          <surname>Blanchette</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Haussler</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Miller</surname>
          <given-names>W</given-names>
        </name>
        <article-title>Reconstructing contiguous regions of an ancestral genome</article-title>
        <source>Genome Research</source>
        <year>2006</year>
        <volume>16</volume>
        <fpage>1557</fpage>
        <lpage>1565</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.5383506</pub-id>
        <?supplied-pmid 16983148?>
        <pub-id pub-id-type="pmid">16983148</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bhutkar</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Gelbart</surname>
          <given-names>WM</given-names>
        </name>
        <name>
          <surname>Smith</surname>
          <given-names>TF</given-names>
        </name>
        <article-title>Inferring genome-scale rearrangement phylogeny and ancestral gene order: a <italic>Drosophilia </italic>case study</article-title>
        <source>Genome Biology</source>
        <year>2007</year>
        <volume>8</volume>
        <fpage>236</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2007-8-11-r236</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Chauve</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Tannier</surname>
          <given-names>E</given-names>
        </name>
        <article-title>A methodological framework for the reconstruction of contiguous regions of ancestral genomes and its application to mammalian genome</article-title>
        <source>PLoS Computational Biology</source>
        <year>2008</year>
        <volume>4</volume>
        <fpage>1000234</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pcbi.1000234</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Muffato</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Louis</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Poisnel</surname>
          <given-names>C-E</given-names>
        </name>
        <name>
          <surname>Crollius</surname>
          <given-names>HR</given-names>
        </name>
        <article-title>Genomicus: a database and a browser to study gene synteny in modern and ancestral genomes</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <fpage>1119</fpage>
        <lpage>1121</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq079</pub-id>
        <?supplied-pmid 20185404?>
        <pub-id pub-id-type="pmid">20185404</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Yang</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Heath</surname>
          <given-names>LS</given-names>
        </name>
        <name>
          <surname>Setubal</surname>
          <given-names>JC</given-names>
        </name>
        <article-title>Regen: Ancestral genome reconstruction for bacteria</article-title>
        <source>Genes</source>
        <year>2012</year>
        <volume>3</volume>
        <issue>3</issue>
        <fpage>423</fpage>
        <lpage>443</lpage>
        <?supplied-pmid 24704978?>
        <pub-id pub-id-type="pmid">24704978</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Adam</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Turmel</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Lemieux</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Sankoff</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Common intervals and symmetric difference in a model-free phylogenomics, with an application to streptophyte evolution</article-title>
        <source>Journal of Computational Biology</source>
        <year>2007</year>
        <volume>14</volume>
        <fpage>436</fpage>
        <lpage>445</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2007.A005</pub-id>
        <?supplied-pmid 17572022?>
        <pub-id pub-id-type="pmid">17572022</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gagnon</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Blanchette</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>El-Mabrouk</surname>
          <given-names>N</given-names>
        </name>
        <article-title>A flexible ancestral genome reconstruction method based on gapped adjacencies</article-title>
        <source>BMC Bioinformatics</source>
        <year>2012</year>
        <volume>13</volume>
        <issue>S-19</issue>
        <fpage>4</fpage>
        <?supplied-pmid 22226192?>
        <pub-id pub-id-type="pmid">22226192</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Jones</surname>
          <given-names>BR</given-names>
        </name>
        <name>
          <surname>Rajaraman</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Tannier</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Chauve</surname>
          <given-names>C</given-names>
        </name>
        <article-title>Anges: reconstructing ancestral genomes maps</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <issue>18</issue>
        <fpage>2388</fpage>
        <lpage>2390</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts457</pub-id>
        <?supplied-pmid 22820205?>
        <pub-id pub-id-type="pmid">22820205</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Fitch</surname>
          <given-names>W</given-names>
        </name>
        <article-title>Towards defining the course of evolution: Minimum change for a specified tree topology</article-title>
        <source>Systematic Zoology</source>
        <year>1971</year>
        <volume>20</volume>
        <fpage>406</fpage>
        <lpage>416</lpage>
        <pub-id pub-id-type="doi">10.2307/2412116</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Sankoff</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Minimal mutation trees of sequences</article-title>
        <source>SIAM Journal of Applied Mathematics</source>
        <year>1975</year>
        <volume>28</volume>
        <fpage>35</fpage>
        <lpage>42</lpage>
        <pub-id pub-id-type="doi">10.1137/0128004</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zhao</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Bourque</surname>
          <given-names>G</given-names>
        </name>
        <article-title>Recovering genome rearrangements in the mammalian phylogeny</article-title>
        <source>Genome Research</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>934</fpage>
        <lpage>942</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.086009.108</pub-id>
        <?supplied-pmid 19411607?>
        <pub-id pub-id-type="pmid">19411607</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Chauve</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Gavranovic</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Ouangraoua</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Tannier</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Yeast ancestral genome reconstructions: the possibilities of computational methods II</article-title>
        <source>Journal of Computational Biology</source>
        <year>2010</year>
        <volume>17</volume>
        <fpage>1097</fpage>
        <lpage>1112</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2010.0092</pub-id>
        <?supplied-pmid 20874398?>
        <pub-id pub-id-type="pmid">20874398</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Paten</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Herrero</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Beal</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Fitzgerald</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Birney</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Enredo and pecan: genome-wide mammalian consistency-based multiple alignment with paralogs</article-title>
        <source>Genome Research</source>
        <year>2008</year>
        <volume>18</volume>
        <fpage>1814</fpage>
        <lpage>1828</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.076554.108</pub-id>
        <?supplied-pmid 18849524?>
        <pub-id pub-id-type="pmid">18849524</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kersey</surname>
          <given-names>PJ</given-names>
        </name>
        <name>
          <surname>Lawson</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Birney</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Derwent</surname>
          <given-names>PS</given-names>
        </name>
        <name>
          <surname>Haimel</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Herrero</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Keenan</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Kerhornou</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Koscielny</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Kähäri</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Kinsella</surname>
          <given-names>RJ</given-names>
        </name>
        <name>
          <surname>Kulesha</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Maheswari</surname>
          <given-names>U</given-names>
        </name>
        <name>
          <surname>Megy</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Nuhn</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Proctor</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Staines</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Valentin</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Vilella</surname>
          <given-names>AJ</given-names>
        </name>
        <name>
          <surname>Yates</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Ensembl genomes: Extending ensembl across the taxonomic space</article-title>
        <source>Nucleic Acids Research</source>
        <year>2010</year>
        <volume>38</volume>
        <issue>1</issue>
        <fpage>563</fpage>
        <lpage>569</lpage>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Federhen</surname>
          <given-names>S</given-names>
        </name>
        <article-title>The ncbi taxonomy database</article-title>
        <source>Nucleic Acids Research</source>
        <year>2012</year>
        <volume>40</volume>
        <issue>D1</issue>
        <fpage>136</fpage>
        <lpage>143</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkr1178</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Ouangraoua</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Tannier</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Chauve</surname>
          <given-names>C</given-names>
        </name>
        <article-title>Reconstructing the architecture of the ancestral amniote genome</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <issue>19</issue>
        <fpage>2664</fpage>
        <lpage>2671</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btr461</pub-id>
        <?supplied-pmid 21846735?>
        <pub-id pub-id-type="pmid">21846735</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kemkemer</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Kohn</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Cooper</surname>
          <given-names>DN</given-names>
        </name>
        <name>
          <surname>Froenicke</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Hameister</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Kehrer-Sawatzki</surname>
          <given-names>H</given-names>
        </name>
        <article-title>Gene synteny comparison between different vertebrates provide new insights into breakage and fusion events during mammalian karyotype evolution</article-title>
        <source>BMC Evolutionary Biology</source>
        <year>2009</year>
        <volume>9</volume>
        <fpage>84</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2148-9-84</pub-id>
        <?supplied-pmid 19393055?>
        <pub-id pub-id-type="pmid">19393055</pub-id>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
