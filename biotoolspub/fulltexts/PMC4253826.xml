<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4253826</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btu538</article-id>
    <article-id pub-id-type="publisher-id">btu538</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Hitseq Papers</subject>
        <subj-group subj-group-type="heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>LoRDEC: accurate and efficient long read error correction</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Salmela</surname>
          <given-names>Leena</given-names>
        </name>
        <xref ref-type="aff" rid="btu538-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="btu538-COR1">*</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Rivals</surname>
          <given-names>Eric</given-names>
        </name>
        <xref ref-type="aff" rid="btu538-AFF1">
          <sup>2</sup>
        </xref>
        <xref ref-type="corresp" rid="btu538-COR1">*</xref>
      </contrib>
      <aff id="btu538-AFF1"><sup>1</sup>Department of Computer Science and Helsinki Institute for Information Technology HIIT, FI-00014 University of Helsinki, Finland and <sup>2</sup>LIRMM and Institut de Biologie Computationelle, CNRS and Université Montpellier, 34095 Montpellier Cedex 5, France</aff>
    </contrib-group>
    <author-notes>
      <corresp id="btu538-COR1">*To whom correspondence should be addressed.</corresp>
      <fn id="btu538-FN1">
        <p>Associate Editor: Michael Brudno</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>12</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>26</day>
      <month>8</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>26</day>
      <month>8</month>
      <year>2014</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>30</volume>
    <issue>24</issue>
    <fpage>3506</fpage>
    <lpage>3514</lpage>
    <history>
      <date date-type="received">
        <day>6</day>
        <month>4</month>
        <year>2014</year>
      </date>
      <date date-type="rev-recd">
        <day>28</day>
        <month>7</month>
        <year>2014</year>
      </date>
      <date date-type="accepted">
        <day>4</day>
        <month>8</month>
        <year>2014</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author 2014. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2014</copyright-year>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/" license-type="creative-commons">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> PacBio single molecule real-time sequencing is a third-generation sequencing technique producing long reads, with comparatively lower throughput and higher error rate. Errors include numerous indels and complicate downstream analysis like mapping or <italic>de novo</italic> assembly. A hybrid strategy that takes advantage of the high accuracy of second-generation short reads has been proposed for correcting long reads. Mapping of short reads on long reads provides sufficient coverage to eliminate up to 99% of errors, however, at the expense of prohibitive running times and considerable amounts of disk and memory space.</p>
      <p><bold>Results</bold>: We present LoRDEC, a hybrid error correction method that builds a succinct de Bruijn graph representing the short reads, and seeks a corrective sequence for each erroneous region in the long reads by traversing chosen paths in the graph. In comparison, LoRDEC is at least six times faster and requires at least 93% less memory or disk space than available tools, while achieving comparable accuracy.</p>
      <p><bold>Availability and implementaion</bold>: LoRDEC is written in C++, tested on Linux platforms and freely available at <ext-link ext-link-type="uri" xlink:href="http://atgc.lirmm.fr/lordec">http://atgc.lirmm.fr/lordec</ext-link>.</p>
      <p><bold>Contact:</bold><email>lordec@lirmm.fr</email>.</p>
      <p><bold>Supplementary information:</bold><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu538/-/DC1">Supplementary data</ext-link> are available at <italic>Bioinformatics</italic> online.</p>
    </abstract>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 INTRODUCTION</title>
    <p>Sequencing, the determination of DNA or RNA sequences, now belongs to the basic experiments in life sciences. Compared with the Sanger method, the so-called next-generation sequencing technologies (of the second, third or even fourth generations) have drastically lowered its cost and increased its efficiency, making genome-wide and transcriptome-wide sequencing feasible. Numerous types of ‘omics’ experiments, beyond <italic>de novo</italic> genome sequencing and assembly, have been invented and rely on high-throughput sequencing.</p>
    <p>All currently available technologies produce reads that represent only a piece of the target molecule sequence. Processing these reads requires aligning them against other sequences: for instance, while mapping them against a reference genome, or when computing overlaps among reads during assembly. Optimal, and sometimes suboptimal, alignments are retained for further analysis. The strength of an alignment (and hence its usefulness) is mostly controlled by two factors: its percentage of identity and its length. Clearly, errors introduced during the sequencing process, sequencing errors, blur the signal in an alignment by introducing mismatches or by breaking it into shorter ones. Weaker alignments may not pass subsequent filters and are lost for downward analyses. The finer the analysis, the higher the necessity to capture the information available in all alignments: for instance, when trying to bridge a gap in a less covered region of genome during assembly, or to reconstruct the sequence of a less expressed RNA. To counteract sequencing errors, error correction algorithms have been found effective for <italic>de novo</italic> assembly (<xref rid="btu538-B23" ref-type="bibr">Salzberg <italic>et al.</italic>, 2012</xref>), and so they are often incorporated in assembly pipelines [see e.g. Euler SR (<xref rid="btu538-B6" ref-type="bibr">Chaisson and Pevzner, 2008</xref>), ALLPATHS-LG (<xref rid="btu538-B13" ref-type="bibr">Gnerre <italic>et al.</italic>, 2011</xref>) and SOAPdenovo2 (<xref rid="btu538-B16" ref-type="bibr">Luo <italic>et al.</italic>, 2012</xref>)].</p>
    <sec id="SEC1.1">
      <title>1.1 Related works for second-generation sequencing</title>
      <p>In the case of long sequences (Sanger or PacBio reads), algorithms compute multiple alignments of the reads and call a consensus sequence to correct erroneous regions. Alignment computation has the inconvenience of long running time and parameter dependency (<xref rid="btu538-B22" ref-type="bibr">Salmela and Schröder, 2011</xref>). In the case of second-generation reads, meaning larger input size and modest error rates, the key idea is to exploit the coverage of sequencing. One distinguishes erroneous from error-free substrings by counting their number of occurrences in the read set. With a sufficient coverage, it is possible to compute a minimal threshold such that, with high probability, each error-free <italic>k</italic>-mer appears at least that number of times in the read set. A <italic>k</italic>-mer above/below the threshold is qualified as solid or weak, respectively. This idea is exploited in second-generation assembly programs based on De Bruijn Graphs (DBG), where only solid <italic>k</italic>-mers form the nodes of the DBG (e.g. <xref rid="btu538-B26" ref-type="bibr">Zerbino and Birney, 2008</xref>), or during mapping against a reference to distinguish erroneous positions from biological mutations (<xref rid="btu538-B19" ref-type="bibr">Philippe <italic>et al.</italic>, 2013</xref>). Many current error correction algorithms for second-generation sequencing (Illumina, Roche, or Solid) adopt this counting strategy, also called spectral alignment (<xref rid="btu538-B5" ref-type="bibr">Chaisson <italic>et al.</italic>, 2004</xref>; <xref rid="btu538-B18" ref-type="bibr">Pevzner <italic>et al.</italic>, 2001</xref>): one computes the spectrum of solid <italic>k</italic>-mers and corrects each read by updating each weak <italic>k</italic>-mer with its closest solid <italic>k</italic>-mer. Implementation relying on hash tables is well adapted to <italic>k</italic>-mers (i.e. to substrings of fixed length), while approaches based on more flexible indexes of the reads (e.g. suffix trees or suffix arrays) can correct substrings of different lengths (<xref rid="btu538-B21" ref-type="bibr">Salmela, 2010</xref>; <xref rid="btu538-B24" ref-type="bibr">Schröder <italic>et al.</italic>, 2009</xref>). Spectral alignment-based approaches are more efficient and scalable than alignment-based ones, and adapted to low error rates. Most recent work on error correction has concentrated on correcting Illumina reads where substitutions is the dominant error type, and so the more challenging problem of correcting insertions and deletions is addressed only by a few works (<xref rid="btu538-B21" ref-type="bibr">Salmela, 2010</xref>; <xref rid="btu538-B22" ref-type="bibr">Salmela and Schröder, 2011</xref>). For a survey on error correction methods for second-generation sequencing, see <xref rid="btu538-B25" ref-type="bibr">Yang <italic>et al.</italic> (2013)</xref>.</p>
    </sec>
    <sec id="SEC1.2">
      <title>1.2 Related works for PacBio reads</title>
      <p>PacBio SMRT sequencing is characterized by much longer reads (up to 20 Kb) and much higher error rates (&gt;15% <xref rid="btu538-B14" ref-type="bibr">Koren <italic>et al.</italic>, 2012</xref>), and poses a much harder challenge for error correction. However, sequencing errors seem to be uniformly distributed, independent of the sequence context and skewed toward insertions, to a lesser extent deletions. For simplicity, we call PacBio reads, long reads (LR), and other second generation reads, short reads (SR). To address this challenge, two approaches have been proposed: <bold>self correction</bold> using only LR, or <bold>hybrid correction</bold> of LR using libraries of SR. Self correction, alike Sanger correction tools, computes local alignments between LR [with BLASR (<xref rid="btu538-B7" ref-type="bibr">Chaisson and Tesler, 2012</xref>)] for building multiple alignments and then calls a consensus. It has been implemented in a non-hybrid assembler, HGAP, and experimented on bacterial genomes (<xref rid="btu538-B9" ref-type="bibr">Chin <italic>et al.</italic>, 2013</xref>). Hybrid correction exploits the higher quality and coverage of SR libraries, which give rise to stronger alignments, to align these on LR and correct the latter by calling consensus sequence from a multiple alignment. This strategy, found in assembler AHA (<xref rid="btu538-B3" ref-type="bibr">Bashir <italic>et al.</italic>, 2012</xref>), and in correction programs LSC (<xref rid="btu538-B2" ref-type="bibr">Au <italic>et al.</italic>, 2012</xref>) and PacBioToCA (<xref rid="btu538-B14" ref-type="bibr">Koren <italic>et al.</italic>, 2012</xref>; which has been incorporated in the Celera assembler), achieves similar accuracy on bacterial genomes than a non-hybrid method, but has also proved able to operate on eukaryotic genomes and transcriptomes (<xref rid="btu538-B2" ref-type="bibr">Au <italic>et al.</italic>, 2012</xref>; <xref rid="btu538-B14" ref-type="bibr">Koren <italic>et al.</italic>, 2012</xref>).</p>
    </sec>
    <sec id="SEC1.3">
      <title>1.3 Genome finishing, scaffolding and limitations of long read correction methods</title>
      <p>Recently, two proposals [PBJelly (<xref rid="btu538-B12" ref-type="bibr">English <italic>et al.</italic>, 2012</xref>) and Cerulean (<xref rid="btu538-B10" ref-type="bibr">Deshpande <italic>et al.</italic>, 2013</xref>)] have adopted an intermediate strategy for genome scaffolding or finishing: in addition to LR, they take as input either a partially assembled genome or an assembly graph generated with SR data. Contigs are mapped to LR, which serve as the basis to complete/fill the assembly gaps or order the contigs into a scaffold. <xref rid="btu538-B10" ref-type="bibr">Deshpande <italic>et al.</italic> (2013)</xref> justify their strategy by the time, memory and disk requirements of current LR correction programs, ‘which requires high computational resources and long running time on a supercomputer even for bacterial genome datasets’. Current correction programs seem not to take full advantage of sequence indexing data structures to speed up the correction (<xref rid="btu538-B17" ref-type="bibr">Navarro and Mäkinen, 2007</xref>).</p>
    </sec>
    <sec id="SEC1.4">
      <title>1.4 Contribution</title>
      <p>Considering the limitations of LR correction programs and the high error rates in PacBio reads, we propose here a new hybrid correction algorithm aiming at more efficiency. It first builds a DBG of the SR data, and then corrects an erroneous region within an LR by searching for an optimal path within the DBG. The sequence of the overlapping <italic>k</italic>-mers along the path provides a corrected sequence for that region. Taking advantage of recent developments in compact representation of DBG [<xref ref-type="fig" rid="btu538-F1">Fig. 1</xref>, <xref rid="btu538-B8" ref-type="bibr">Chikhi and Rizk (2012)</xref>; <xref rid="btu538-B20" ref-type="bibr">Salikhov <italic>et al.</italic> (2013)</xref>], we develop a program, called LoRDEC (Long Read DBG Error Correction), that allows correcting a dataset of typical size on common computing hardware. We compare our program with state-of-the-art methods and find that it provides an equal accuracy with low memory usage and reasonable running times.
<fig id="btu538-F1" position="float"><label>Fig. 1.</label><caption><p>An example of short read DBG of order <italic>k</italic> = 3. For simplicity reverse complement <italic>k</italic>-mers are ignored</p></caption><graphic xlink:href="btu538f1p"/></fig></p>
    </sec>
  </sec>
  <sec>
    <title>2 METHODS</title>
    <sec sec-type="intro">
      <title>2.1 Overview</title>
      <p>The rationale behind a hybrid correction algorithm is to use a set of high-quality reads to correct a second set of reads suffering from a higher error rate. Typically, a reference set of Illumina, 454, or PacBio CCS SR with low error rate will help correcting long PacBio RS reads. As both sets are assumed to come from the same library, the goal is to convert the sequence of an erroneous region in a long read into the sequence that could be assembled from the SR in that region of the molecule, while keeping the length of LR. Our program, called LoRDEC, takes as input the SR, the LR and an odd integer <italic>k</italic>. Now, our approach is to find, for each erroneous region of an LR, an alternative sequence by traversing appropriate paths in the DBG of the SR. However, SR also contains errors. To avoid introducing erroneous bases during the correction, we filter out any <italic>k</italic>-long substring, termed a <italic>k</italic>-mer, that occurs less than <italic>s</italic> times within the SR [as done in second-generation assemblers (<xref rid="btu538-B8" ref-type="bibr">Chikhi and Rizk, 2012</xref>; <xref rid="btu538-B20" ref-type="bibr">Salikhov <italic>et al.</italic>, 2013</xref>; <xref rid="btu538-B26" ref-type="bibr">Zerbino and Birney, 2008</xref>)], where <italic>s</italic> is set by the user. With our terminology, we keep only solid <italic>k</italic>-mers.</p>
      <p>LoRDEC first reads the SR, builds their DBG of order <italic>k</italic> and then corrects each long read, independently, one after the other. The DBG is the graph underlying most second-generation assemblers (e.g. Velvet, Minia). Each solid <italic>k</italic>-mer found in the SR makes a node in the DBG, and a directed arc links a node <italic>f</italic> to a node <italic>g</italic> if the <italic>k</italic>-mer of node <italic>f</italic> overlaps that of <italic>g</italic> by <italic>k</italic> − 1 positions. <xref ref-type="fig" rid="btu538-F1">Figure 1</xref> shows an example of a DBG. As usual in the DBG used for assembly, because the strand of reads are unknown, a node represents a <italic>k</italic>-mer and its reverse complement <italic>k</italic>-mer, and the notion of arc is extended to ensure that two nodes/<italic>k</italic>-mers can overlap each other on the same strand. For instance, a <italic>k</italic>-mer <italic>acgta</italic> would be linked to <italic>k</italic>-mer <italic>cgtat</italic> by an arc. Clearly, a path, i.e. a series of arcs, from one node to another represents a nucleotidic sequence, and between two nodes, say <italic>f</italic> and <italic>g</italic>, there may be none, one or several paths. Typically, assembly programs output the sequence along non-branching paths as contigs. For storing the DBG, we use the memory-efficient GATB library (<ext-link ext-link-type="uri" xlink:href="http://gatb-core.gforge.inria.fr">http://gatb-core.gforge.inria.fr</ext-link>), which allows to traverse any path in the graph and to get the sequence of any node. GATB uses Bloom filters to store the DBG and additionally records those false-positive <italic>k</italic>-mers that are adjacent to <italic>k</italic>-mers in the DBG, which allows traversing only solid <italic>k</italic>-mers if the traversal starts at a solid <italic>k</italic>-mer. However, we use the DBG to determine whether a <italic>k</italic>-mer in an LR is solid and, therefore, GATB can report false positives. We found that if we additionally require that for a <italic>k</italic>-mer to be considered solid, it must also have at least one incoming and at least one outgoing arc, only a small fraction (e.g. 0.03% in the <italic>Escherichia coli</italic> dataset) of the reported solid <italic>k</italic>-mers are false positives.</p>
      <p>Consider the <italic>k</italic>-mers of a long read starting at position 1,2,3, … : some <italic>k</italic>-mers belong to the graph and are solid, while others do not and are weak. Basically, solid <italic>k</italic>-mers are expected to be correct, while weak ones suspectedly include sequencing errors and require a correction. Solid <italic>k</italic>-mers are entry points in the DBG, and LoRDEC corrects a region made of weak <italic>k</italic>-mers by finding the best path in the DBG between the solid <italic>k</italic>-mers bordering this region. Sometimes, an LR has no solid <italic>k</italic>-mer, in which case, LoRDEC marks it as such in the output and skips it. Our results show that only short erroneous reads (&lt;1500 nucleotides) completely lack solid <italic>k</italic>-mers (data not shown). As the goal of PacBio sequencing is to get long reads and thus our goal is to yield long and correct sequences, we decided to filter those reads in the present version of LoRDEC. In the remaining LR, at least one <italic>k</italic>-mer is solid: consequently, two alternative situations occur for a weak region: either it is located at one end of the LR and only one solid <italic>k</italic>-mer is bordering it, we call these a head or a tail region, or it is an inner region surrounded by a run of solid <italic>k</italic>-mers on each side. Weak regions are shown in <xref ref-type="fig" rid="btu538-F2">Figure 2</xref>a. Our algorithm uses two distinct procedures to correct a head/tail or an inner region (see below).
<fig id="btu538-F2" position="float"><label>Fig. 2.</label><caption><p>Long read correction method. (<bold>a</bold>) A long read is partitioned into weak and solid regions (respectively, lines and rectangles) according to the short read DBG. Weak regions starting or ending the long read are called the <italic>head</italic> or the <italic>tail</italic>, respectively, while other weak regions are <italic>inner regions</italic>. Circles in solid regions represent <italic>k</italic>-mers of the DBG. <italic>k</italic>-mers around a weak region serve as source and target nodes to search paths in the DBG. Several source/target pairs are used for each weak inner region. (b) On the second inner region, a <italic>bridging path</italic> between nodes <italic>s</italic><sub>1</sub> and <italic>t</italic><sub>1</sub> is found in the DBG to correct this region. On the third region, the path search fails to find a path between nodes <italic>s</italic><sub>2</sub> and <italic>t</italic><sub>2</sub>. For the tail, an <italic>extension path</italic> is sought and found from node <italic>s</italic><sub>3</sub> toward the end. Once found, the corrective sequence of the path is aligned to the tail to determine the optimal substring (thick dotted arrow)</p></caption><graphic xlink:href="btu538f2p"/></fig></p>
      <p>The algorithm for correcting one long read is illustrated in <xref ref-type="fig" rid="btu538-F2">Figure 2</xref> and summarized as follows. For each pass over a long read, we apply the head/tail correction procedure to the left-most (head) and right-most (tail) weak regions, then we loop over the sequence, select pairs of solid <italic>k</italic>-mers and, for each, launch the correction procedure for the weak region between them. Each call for a correction procedure modifies the sequence on-the-fly, and thus turns weak into solid <italic>k</italic>-mers. LoRDEC performs two passes over the read, one in each direction. First, on-the-fly correction generates new solid <italic>k</italic>-mers, which serve as starting nodes in the next pass; second, because of repeats in the sequence, the search for a path can proceed to different parts of the graph depending on which end of the region it is started from. Thus, it is worth trying two passes.</p>
    </sec>
    <sec id="SEC2.2">
      <title>2.2 Correction of inner weak regions</title>
      <p>An inner region is bordered by a run of solid <italic>k</italic>-mers on each side. The procedure takes as input the source and target solid <italic>k</italic>-mers, the region sequence and a maximal branching limit. Solid <italic>k</italic>-mers serve as source and target nodes in the DBG, and any path between these nodes encodes a sequence that first, can be assembled from the SR, and second, it starts and ends with the appropriate solid <italic>k</italic>-mers. Thus, the region sequence could be corrected with the sequence of any such path. Our criterion to choose among several such paths is to minimize the edit distance between the path and the region sequence. Now, several solid <italic>k</italic>-mers can serve as source and target for the search. The criterion of solidity with which we filter erroneous <italic>k</italic>-mer is not perfect: some solid <italic>k</italic>-mer may still be erroneous. With such <italic>k</italic>-mers the path search may fail or result in a path sequence that is far from optimal. To avoid being trapped in such local minima, we consider not only one but several pairs of (source, target) <italic>k</italic>-mers around each weak region.</p>
      <p>For this, we loop over the inner solid <italic>k</italic>-mers of the read and consider each as a source. For each possible source, we consider <italic>t</italic> downward solid <italic>k</italic>-mers as targets (by default <italic>t</italic> is set to 5), and filter out some exclusive cases, depending on whether the source and target <italic>k</italic>-mers
<list list-type="order"><list-item><p>belong to the same run of solid <italic>k</italic>-mers: the region is assumed to be correct, and no path is searched for;</p></list-item><list-item><p>overlap: a tandem repeat likely creates this overlap region or a <italic>k</italic>-mer is falsely solid, we skip this case;</p></list-item><list-item><p>are too distant from each other in the read: the dynamic programming (DP) matrix to compute the minimal edit distance would require too much memory, and the likelihood to find a path would be low: we necessarily skip this case.</p></list-item></list>
</p>
      <p>In all other cases, we search for an optimal path between a source and target solid <italic>k</italic>-mers. With this manner of selecting source/target pairs, we ensure that several pairs bordering a weak region will be considered. If a path between a source and a target is seen as a bridge over a weak region, then alternative source/target pairs may form distinct bridges that cross over that region of the read. All bridges found along the read form a directed graph: the <bold>path graph</bold>. The solid <italic>k</italic>-mers build its nodes, and each path found is an arc between the source and target <italic>k</italic>-mers. The arcs are weighted by the edit distance between the region sequence and the found path. The path graph construction is thus intermingled with the inner region correction.</p>
      <p>To seek an optimal path in the DBG for a selected source/target pair, we perform a depth-first search traversal of possible paths between the source and target, and compute at each step (node wise) its minimal edit distance with the region sequence in a DP matrix. The exploration of a path stops when reaching a dead end in the graph, the target <italic>k</italic>-mer or whenever the minimal edit distance of any extension of the path would exceed maximum allowed error rate. The overall search is aborted whenever the number of paths encountered exceeds the branching limit. In the end, if at least one path was found, we record the path and its edit distance as an arc between the two <italic>k</italic>-mers in the path graph, which we defined above. Otherwise, if the search has failed at all trials with the current source <italic>k</italic>-mer, we add a dummy arc to the path graph: an arc between the source and the next solid <italic>k</italic>-mer weighted by an edit distance equal to the region length. This ensures that a path from the first to the last solid <italic>k</italic>-mer always exists.</p>
    </sec>
    <sec id="SEC2.3">
      <title>2.3 Head or tail region correction: searching for a best extension</title>
      <p>Correcting the head or the tail of a read is a symmetrical procedure, so we describe it for the tail. A tail is a nucleotidic region made of weak <italic>k</italic>-mers, preceded by at least one solid <italic>k</italic>-mer. The procedure takes as input the solid <italic>k</italic>-mer node as a source node in the DBG, the tail sequence and a branching limit. Unlike for an inner region, we lack a target <italic>k</italic>-mer, and thus need another criterion to stop visiting a path. The procedure seeks for any path that allows correcting a prefix of the tail, and optimizes node-wise the prefix length and the edit distance between the current path and the current prefix of the tail. It uses a depth-first search and explores paths until their edit distance becomes too large, or until reaching either a dead end in the DBG or the end of the tail.</p>
      <p>Finally, because the procedure optimizes the prefix length, it tends to extend the search beyond the prefix that aligns well against the path. For this reason, the path found is reconsidered to search its prefix that optimizes an alignment score. This alignment step finds the best extension sequence starting at the solid <italic>k</italic>-mer and obtaining the maximal alignment score. This extension problem is reminiscent of the best extension search for a local alignment in BLAST (which is solved with a drop-off score limit; <xref rid="btu538-B1" ref-type="bibr">Altschul <italic>et al.</italic>, 1990</xref>).</p>
      <p>A note concerning an optimization of the inner region correction. When the path search between a source <italic>k</italic>-mer and all its targets has failed, it means that we cannot find a bridging path. Nevertheless, we can find the best extension on each side of the weak region and correct a prefix and a suffix of that region. For this, we use the same extension procedure as the head/tail correction, and adapt the graph path edge accordingly.</p>
    </sec>
    <sec id="SEC2.4">
      <title>2.4 The graph path optimization</title>
      <p>Finally, at the end of one complete pass of correction, all found inner paths have been recorded in the path graph. Here, an edge between two solid <italic>k</italic>-mers records the correction of the region dictated by the path found between those <italic>k</italic>-mers. Finally, after all inner solid <italic>k</italic>-mers have been considered, the correction of the inner region is optimized by finding a shortest path between the first and last solid <italic>k</italic>-mers of the read in the path graph using Dijkstra’s algorithm (<xref rid="btu538-B11" ref-type="bibr">Dijkstra, 1959</xref>).</p>
    </sec>
    <sec id="SEC2.5">
      <title>2.5 Trimming and splitting corrected reads</title>
      <p>In the end of the correction process, each base in a corrected read can be classified as solid if it belongs to at least one solid <italic>k</italic>-mer and weak otherwise. LoRDEC outputs the solid bases in upper case characters and weak bases in lower case. We provide two utilities for trimming and splitting the corrected reads. The first tool trims all weak bases from the beginning and the end of the reads but leaves intact regions of weak bases that are bordered by solid bases on both sides. Thus, one trimmed read is produced for each corrected read. The second tool both trims and splits the reads by extracting from the corrected reads all runs of solid bases as separate sequences.</p>
    </sec>
  </sec>
  <sec>
    <title>3 RESULTS</title>
    <sec id="SEC3.1">
      <title>3.1 Data and computing environment</title>
      <p>We used three datasets of increasing size: one from <italic>E.</italic><italic>coli</italic>, two eukaryotic ones from yeast and from the parrot. They include, respectively, 98 Mb, 1.5 and 6.8 Gb of PacBio reads, with 231, 451 Mb, and 35 Gb of Illumina reads. All details are given in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu538/-/DC1">Supplementary Table S1</ext-link>.</p>
      <p>All experiments were run on servers with 16 cores operating at 2.53 GHz and 32 GB of memory. The runtimes were recorded with the Linux/Unix time command, and the memory and disk usage was recorded by polling the operating system periodically. Because all the correction tools support parallel execution on several cores, we report both total CPU time and elapsed (wall clock) time.</p>
    </sec>
    <sec id="SEC3.2">
      <title>3.2 Evaluation approach</title>
      <p>We used two approaches to evaluate the accuracy of correction. The first approach measures how well the reads align against the reference genome. The second approach compares the differences in the alignments of the original and corrected reads against the reference to evaluate the accuracy of correction.</p>
      <p>For the <italic>E.</italic><italic>coli</italic> and yeast datasets, we used BLASR (<xref rid="btu538-B7" ref-type="bibr">Chaisson and Tesler, 2012</xref>) to align the original and corrected reads to the genome and for the parrot dataset, we used BWA-MEM (<xref rid="btu538-B15" ref-type="bibr">Li, 2013</xref>). For the smaller datasets, BLASR was used because it tends to bridge long indels better and thus reports longer alignments. For the parrot dataset, we preferred BWA-MEM because it is faster. For each read, we kept its best alignment against the genome. We then counted the size of the aligned region of the reads, the size of the aligned regions in the genome and the number of identical positions in the alignments. The identity of the alignments was then calculated as the number of identical positions divided by the length of the aligned region in the genome. The reads corrected by an error correction program were then evaluated based on the size of the region that could be aligned against the genome, and the identity of the alignments.</p>
      <p>The alignments of the original and corrected reads can be further analyzed to characterize the accuracy of correction. Consider a multiple alignment of the original read, the corrected read and the corresponding genomic region. Each position in this multiple alignment can be classified as true positive (TP), false positive (FP), true negative (TN) or false negative (FN). A position is TP if the original read has an error and it has been corrected by the error correction tool. Erroneous positions in the original read that have not been corrected are false negatives. In a FP position the error correction tool has made a correction, although there was no error in the original read, and finally, TN positions are correct in both original and corrected reads. The accuracy of correction can then be measured with several statistics:
<list list-type="bullet"><list-item><p><italic>Sensitivity</italic> = TP/(TP + FN), how well does the tool recognize erroneous positions?</p></list-item><list-item><p><italic>Gain</italic> = (TP − FP)/(TP + FN), how well does the tool remove errors without introducing new ones?</p></list-item></list>
</p>
      <p>Error Correction Toolkit (<xref rid="btu538-B25" ref-type="bibr">Yang <italic>et al.</italic>, 2013</xref>) is designed for comparing error correction results for second-generation sequencing data. As input, it requires the mapping of the original reads and of the corrected reads to the genome in SAM format. We used BLASR for the <italic>E.</italic><italic>coli</italic> and yeast data and BWA-MEM for the parrot data to produce the alignments. For each pair of original and corrected read, the toolkit computes the set of differences with the reference genome, and it compares these two sets to determine TP, FP and FN positions with regard to correction. Whereas read mappers geared toward second-generation sequencing reads report full matches of the reads against the genome, BLASR and BWA-MEM report best local alignments of the reads against the genome. We modified the toolkit so that differences between original and corrected reads are counted only within the genomic region of the local alignment of the original read against the genome.</p>
      <p>The comparison of the differences in alignments is not straightforward with large amounts of indels, as even the same differences can often produce different alignments with the same alignment score. Therefore, especially in partially corrected regions, more differences might be reported than is actually the case, and so this approach might report more FPs or FNs than are actually present in the datasets.</p>
    </sec>
    <sec id="SEC3.3">
      <title>3.3 Effect of parameters on our approach</title>
      <p>We investigated the effect of parameters on our method on the <italic>E.</italic><italic>coli</italic> dataset. We varied one parameter at a time and recorded the runtime and evaluated the accuracy of the method by computing gain. <xref ref-type="fig" rid="btu538-F3">Figure 3</xref> shows the results for this experiment when varying five parameters: the <italic>k</italic>, the threshold for a <italic>k</italic>-mer to be solid in the Illumina dataset, the maximum error rate of corrected regions, the branching limit and the number of target <italic>k</italic>-mers for path finding from a source <italic>k</italic>-mer. We see that <italic>k</italic> = 19 gives the best results for this dataset, and further experiments with the yeast data confirmed <italic>k</italic> = 19 to be optimal also for that dataset (data not shown). The solid <italic>k</italic>-mer threshold had only a modest effect on the accuracy of correction, a smaller threshold giving slightly better results. The accuracy of correction was improved by setting a higher maximum error rate of the corrected region with a slight increase in the runtime. Increasing the number of explored branches or the number of target <italic>k</italic>-mers had only a small effect on the gain, whereas runtime was increased considerably. Based on these observations, we ran our method on the <italic>E.</italic><italic>coli</italic> and yeast data with the following parameters: <italic>k</italic>, 19; threshold for solid <italic>k</italic>-mers, 3; maximum error rate, 0.4; branching limit, 200; and number of target <italic>k</italic>-mers, 5. For the parrot data, we found <italic>k</italic> = 23 to give better results both in terms of runtime and accuracy. <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu538/-/DC1">Supplementary Table S2</ext-link> provides an explanation for each parameter and its default value.
<fig id="btu538-F3" position="float"><label>Fig. 3.</label><caption><p>Effect of parameters on the runtime and gain of our method. We varied <italic>k</italic>, solid <italic>k</italic>-mer threshold, branching limit, maximum error rate and number of target <italic>k</italic>-mers one at a time, while other parameters were kept constant</p></caption><graphic xlink:href="btu538f3p"/></fig></p>
    </sec>
    <sec id="SEC3.4">
      <title>3.4 Comparison against LSC and PacBioToCA</title>
      <p>We compared LoRDEC against LSC (<xref rid="btu538-B2" ref-type="bibr">Au <italic>et al.</italic>, 2012</xref>) and PacBioToCA (<xref rid="btu538-B14" ref-type="bibr">Koren <italic>et al.</italic>, 2012</xref>). LSC was run with default parameters except that we set short read covered depth to the estimated coverage of the dataset, i.e. 50 for the <italic>E.</italic><italic>coli</italic> dataset and 38 for the yeast dataset. PacBioToCA was run with default parameters except for tuning the parameters for parallelization to be suitable for our platform. The parameters for LoRDEC were set as explained above.</p>
      <sec id="SEC3.4.1">
        <title>3.4.1 Escherichia Coli</title>
        <p>The runtime and memory and disk usage of the error correction tools are shown in <xref ref-type="table" rid="btu538-T1">Table 1</xref> (top). LoRDEC is 17 times faster and requires 88% less memory and 95% less memory than LSC, which is the more resource efficient of the two previous tools on this dataset. The right side of <xref ref-type="table" rid="btu538-T1">Table 1</xref> shows the correction statistics as reported by Error Correction Toolkit for LSC and LoRDEC, and we see that LoRDEC outperforms LSC.
<table-wrap id="btu538-T1" position="float"><label>Table 1.</label><caption><p>Runtime, memory, disk usage and accuracy statistics as reported by Error Correction Toolkit for the error correction tools on the <italic>E.coli</italic> (top), yeast (middle) and parrot (bottom) datasets</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">Data</th><th rowspan="1" colspan="1">Method</th><th rowspan="1" colspan="1">CPU time</th><th rowspan="1" colspan="1">Elapsed time</th><th rowspan="1" colspan="1">Memory</th><th rowspan="1" colspan="1">Disk</th><th rowspan="1" colspan="1">FP</th><th rowspan="1" colspan="1">TP</th><th rowspan="1" colspan="1">FN</th><th rowspan="1" colspan="1">Sensitivity</th><th rowspan="1" colspan="1">Gain</th></tr></thead><tbody align="left"><tr><td rowspan="3" colspan="1"><italic>E.coli</italic></td><td rowspan="1" colspan="1">PacBioToCA</td><td rowspan="1" colspan="1">45 h 18 min</td><td rowspan="1" colspan="1">3 h 12 min</td><td rowspan="1" colspan="1">9.91</td><td rowspan="1" colspan="1">13.59</td><td rowspan="1" colspan="1">NA</td><td rowspan="1" colspan="1">NA</td><td rowspan="1" colspan="1">NA</td><td rowspan="1" colspan="1">NA</td><td rowspan="1" colspan="1">NA</td></tr><tr><td rowspan="1" colspan="1">LSC</td><td rowspan="1" colspan="1">39 h 48 min</td><td rowspan="1" colspan="1">2 h 56 min</td><td rowspan="1" colspan="1">8.21</td><td rowspan="1" colspan="1">8.51</td><td rowspan="1" colspan="1">695773</td><td rowspan="1" colspan="1">3149629</td><td rowspan="1" colspan="1">7845597</td><td rowspan="1" colspan="1">0.2865</td><td rowspan="1" colspan="1">0.2232</td></tr><tr><td rowspan="1" colspan="1">LoRDEC</td><td rowspan="1" colspan="1">2 h 16 min</td><td rowspan="1" colspan="1">10 min</td><td rowspan="1" colspan="1">0.96</td><td rowspan="1" colspan="1">0.41</td><td rowspan="1" colspan="1">102427</td><td rowspan="1" colspan="1">9994561</td><td rowspan="1" colspan="1">1000665</td><td rowspan="1" colspan="1">0.9090</td><td rowspan="1" colspan="1">0.8997</td></tr><tr><td rowspan="3" colspan="1">Yeast</td><td rowspan="1" colspan="1">PacBioToCA<xref ref-type="table-fn" rid="btu538-TF1"><sup>a</sup></xref></td><td rowspan="1" colspan="1">792 h 41 min</td><td rowspan="1" colspan="1">21 h 57 min</td><td rowspan="1" colspan="1">13.88</td><td rowspan="1" colspan="1">214</td><td rowspan="1" colspan="1">NA</td><td rowspan="1" colspan="1">NA</td><td rowspan="1" colspan="1">NA</td><td rowspan="1" colspan="1">NA</td><td rowspan="1" colspan="1">NA</td></tr><tr><td rowspan="1" colspan="1">LSC<xref ref-type="table-fn" rid="btu538-TF1"><sup>b</sup></xref></td><td rowspan="1" colspan="1">1200 h 46 min</td><td rowspan="1" colspan="1">130 h 16 min</td><td rowspan="1" colspan="1">24.04</td><td rowspan="1" colspan="1">517</td><td rowspan="1" colspan="1">7766700</td><td rowspan="1" colspan="1">38741658</td><td rowspan="1" colspan="1">80597251</td><td rowspan="1" colspan="1">0.3246</td><td rowspan="1" colspan="1">0.2596</td></tr><tr><td rowspan="1" colspan="1">LoRDEC</td><td rowspan="1" colspan="1">56 h 8 min</td><td rowspan="1" colspan="1">3 h 37 min</td><td rowspan="1" colspan="1">0.97</td><td rowspan="1" colspan="1">1.63</td><td rowspan="1" colspan="1">2784685</td><td rowspan="1" colspan="1">100568850</td><td rowspan="1" colspan="1">18770059</td><td rowspan="1" colspan="1">0.8427</td><td rowspan="1" colspan="1">0.8194</td></tr><tr><td rowspan="1" colspan="1">Parrot</td><td rowspan="1" colspan="1">LoRDEC<xref ref-type="table-fn" rid="btu538-TF1"><sup>b</sup></xref></td><td rowspan="1" colspan="1">568 h 48 min</td><td rowspan="1" colspan="1">29 h 7 min</td><td rowspan="1" colspan="1">4.61</td><td rowspan="1" colspan="1">74.85</td><td rowspan="1" colspan="1">10591097</td><td rowspan="1" colspan="1">226996640</td><td rowspan="1" colspan="1">26296446</td><td rowspan="1" colspan="1">0.8962</td><td rowspan="1" colspan="1">0.8544</td></tr></tbody></table><table-wrap-foot><fn id="btu538-TF1"><p><italic>Note</italic>. Memory and disk usage are in gigabytes. The statistics could not be computed for reads corrected by PacBioToCA because PacBioToCA only reports trimmed and split reads.</p><p><sup>a</sup>Run parallel on six servers. Memory usage is for one server.</p><p><sup>b</sup>Run parallel on three servers. Memory usage is for one server.</p></fn></table-wrap-foot></table-wrap></p>
        <p>The statistics of aligning the reads against the reference genome are shown in <xref ref-type="table" rid="btu538-T2">Table 2</xref> (top). For LSC, we report the statistics both for the full corrected read set as reported by the tool and for the trimmed set. We note that LSC leaves out from the full read set any reads that it was not able to correct at all. Similarly, we report for LoRDEC statistics for full reads, reads trimmed at the ends and trimmed and split reads (see Section 2.5). LSC clearly performs worst of the three tools, whereas PacBioToCA and LoRDEC have similar statistics. Once corrected, trimmed and split by LoRDEC, the reads have slightly more bases, and a slightly smaller proportion of them align against the reference, but the identity of aligned regions is higher than for the reads corrected by PacBioToCA.
<table-wrap id="btu538-T2" position="float"><label>Table 2.</label><caption><p>Alignment statistics of the reads corrected by different tools on the <italic>E.coli</italic> (top), yeast (middle) and parrot (bottom) datasets</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="2" colspan="1">Data</th><th rowspan="2" colspan="1">Method</th><th rowspan="2" colspan="1">Size</th><th rowspan="2" colspan="1">Aligned</th><th rowspan="2" colspan="1">Identity</th><th align="center" colspan="2" rowspan="1">Genome coverage<hr/></th></tr><tr><th rowspan="1" colspan="1">Expected</th><th rowspan="1" colspan="1">Observed</th></tr></thead><tbody align="left"><tr><td rowspan="7" colspan="1"><italic>E.coli</italic></td><td rowspan="1" colspan="1">Original</td><td rowspan="1" colspan="1">1.0000</td><td rowspan="1" colspan="1">0.8800</td><td rowspan="1" colspan="1">0.9486</td><td rowspan="1" colspan="1">1.0000</td><td rowspan="1" colspan="1">0.9768</td></tr><tr><td rowspan="1" colspan="1">PacBioToCA</td><td rowspan="1" colspan="1">0.7759</td><td rowspan="1" colspan="1">0.9965</td><td rowspan="1" colspan="1">0.9988</td><td rowspan="1" colspan="1">1.0000</td><td rowspan="1" colspan="1">0.9936</td></tr><tr><td rowspan="1" colspan="1">LSC (full)</td><td rowspan="1" colspan="1">0.8946</td><td rowspan="1" colspan="1">0.9269</td><td rowspan="1" colspan="1">0.9579</td><td rowspan="1" colspan="1">1.0000</td><td rowspan="1" colspan="1">1.0000</td></tr><tr><td rowspan="1" colspan="1">LSC (trim)</td><td rowspan="1" colspan="1">0.6824</td><td rowspan="1" colspan="1">0.9611</td><td rowspan="1" colspan="1">0.9725</td><td rowspan="1" colspan="1">1.0000</td><td rowspan="1" colspan="1">1.0000</td></tr><tr><td rowspan="1" colspan="1">LoRDEC (full)</td><td rowspan="1" colspan="1">0.9318</td><td rowspan="1" colspan="1">0.8934</td><td rowspan="1" colspan="1">0.9952</td><td rowspan="1" colspan="1">1.0000</td><td rowspan="1" colspan="1">1.0000</td></tr><tr><td rowspan="1" colspan="1">LoRDEC (trim)</td><td rowspan="1" colspan="1">0.8692</td><td rowspan="1" colspan="1">0.9419</td><td rowspan="1" colspan="1">0.9968</td><td rowspan="1" colspan="1">1.0000</td><td rowspan="1" colspan="1">1.0000</td></tr><tr><td rowspan="1" colspan="1">LoRDEC (trim + split)</td><td rowspan="1" colspan="1">0.8184</td><td rowspan="1" colspan="1">0.9950</td><td rowspan="1" colspan="1">0.9997</td><td rowspan="1" colspan="1">1.0000</td><td rowspan="1" colspan="1">0.9979</td></tr><tr><td rowspan="8" colspan="1">Yeast</td><td rowspan="1" colspan="1">Original</td><td rowspan="1" colspan="1">1.0000</td><td rowspan="1" colspan="1">0.7900</td><td rowspan="1" colspan="1">0.9276</td><td rowspan="1" colspan="1">1.0000</td><td rowspan="1" colspan="1">0.9834</td></tr><tr><td rowspan="1" colspan="1">PacBioToCA</td><td rowspan="1" colspan="1">0.7620</td><td rowspan="1" colspan="1">0.9887</td><td rowspan="1" colspan="1">0.9934</td><td rowspan="1" colspan="1">1.0000</td><td rowspan="1" colspan="1">0.9986</td></tr><tr><td rowspan="1" colspan="1">LSC (full)</td><td rowspan="1" colspan="1">0.8760</td><td rowspan="1" colspan="1">0.8570</td><td rowspan="1" colspan="1">0.9420</td><td rowspan="1" colspan="1">1.0000</td><td rowspan="1" colspan="1">0.9988</td></tr><tr><td rowspan="1" colspan="1">LSC (trim)</td><td rowspan="1" colspan="1">0.7020</td><td rowspan="1" colspan="1">0.9277</td><td rowspan="1" colspan="1">0.9544</td><td rowspan="1" colspan="1">1.0000</td><td rowspan="1" colspan="1">0.9992</td></tr><tr><td rowspan="1" colspan="1">LoRDEC (full)</td><td rowspan="1" colspan="1">0.9771</td><td rowspan="1" colspan="1">0.8138</td><td rowspan="1" colspan="1">0.9741</td><td rowspan="1" colspan="1">1.0000</td><td rowspan="1" colspan="1">0.9995</td></tr><tr><td rowspan="1" colspan="1">LoRDEC (trim)</td><td rowspan="1" colspan="1">0.9270</td><td rowspan="1" colspan="1">0.8492</td><td rowspan="1" colspan="1">0.9758</td><td rowspan="1" colspan="1">1.0000</td><td rowspan="1" colspan="1">0.9996</td></tr><tr><td rowspan="1" colspan="1">LoRDEC (trim + split)</td><td rowspan="1" colspan="1">0.7412</td><td rowspan="1" colspan="1">0.9790</td><td rowspan="1" colspan="1">0.9928</td><td rowspan="1" colspan="1">1.0000</td><td rowspan="1" colspan="1">0.9984</td></tr><tr><td rowspan="1" colspan="1">Original</td><td rowspan="1" colspan="1">1.0000</td><td rowspan="1" colspan="1">0.5060</td><td rowspan="1" colspan="1">0.9258</td><td rowspan="1" colspan="1">0.9235</td><td rowspan="1" colspan="1">0.8406</td></tr><tr><td rowspan="3" colspan="1">Parrot</td><td rowspan="1" colspan="1">LoRDEC (full)</td><td rowspan="1" colspan="1">0.9719</td><td rowspan="1" colspan="1">0.7633</td><td rowspan="1" colspan="1">0.9826</td><td rowspan="1" colspan="1">0.9769</td><td rowspan="1" colspan="1">0.9103</td></tr><tr><td rowspan="1" colspan="1">LoRDEC (trim)</td><td rowspan="1" colspan="1">0.8423</td><td rowspan="1" colspan="1">0.8678</td><td rowspan="1" colspan="1">0.9838</td><td rowspan="1" colspan="1">0.9756</td><td rowspan="1" colspan="1">0.9085</td></tr><tr><td rowspan="1" colspan="1">LoRDEC (trim + split)</td><td rowspan="1" colspan="1">0.7453</td><td rowspan="1" colspan="1">0.9782</td><td rowspan="1" colspan="1">0.9884</td><td rowspan="1" colspan="1">0.9773</td><td rowspan="1" colspan="1">0.9042</td></tr></tbody></table><table-wrap-foot><fn id="btu538-TF4"><p><italic>Note</italic>. The first column shows the ratio between the size of the read set and the original read set, the second column shows the ratio between the size of the aligned region of the reads and the size of the read set and the third column shows the alignment identity of the aligned regions. The last two columns give the expected and observed genome coverage by aligned reads, i.e. the proportion of the reference sequence covered by at least one read.</p></fn></table-wrap-foot></table-wrap></p>
      </sec>
      <sec id="SEC3.4.2">
        <title>3.4.2 Yeast</title>
        <p>Both LSC and PacBioToCA failed to complete the correction of this dataset on a single server. We split the PacBio data and run LSC on three servers and PacBioToCA on six servers. Whereas PacBioToCA is designed to run distributed on several servers, LSC does not support distributed execution. Therefore, we chose to use as few servers as possible with LSC to minimize the effect of the distributed execution on the correction accuracy.</p>
        <p><xref ref-type="table" rid="btu538-T1">Table 1</xref> (middle) shows the runtime, memory and disk usage statistics for the yeast dataset. Also for this dataset, LoRDEC uses at least one order of magnitude less time or memory and two orders less disk than PacBioToCA and LSC. For instance, LoRDEC is six times faster and uses 93% less memory and 99% less disk space than PacBioToCA. The gain and sensitivity of LSC remain &lt;32%, while they stay &gt;80% for LoRDEC. <xref ref-type="table" rid="btu538-T2">Table 2</xref> (middle) compares the alignment statistics of the three tools: LSC (full or trim) aligns less bases with less identities than LoRDEC. PacBioToCA compared with LoRDEC (trim + split) yields slightly better alignments at a higher computational cost.</p>
      </sec>
    </sec>
    <sec id="SEC3.5">
      <title>3.5 Experiments on the parrot data</title>
      <p>We investigated the scalability of LoRDEC on a much larger eukaryotic dataset: the parrot data. As the parrot genome is a vertebrate, hence complex, genome, that is about one-third of the Human genome in length (<ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu538/-/DC1">Supplementary Table S1</ext-link>), it represents a real test for addressing both scalability and issues regarding the impact of genome organization. Given the running times of LSC and PacBioToCA on the smaller yeast data, these were not included in this experiment. The data contain three PacBio libraries, and we ran the correction of each on its own server. <xref ref-type="table" rid="btu538-T1">Table 1</xref> (bottom) shows the runtime, memory and disk usage and statistics produced by Error Correction Toolkit. Based on these results, we can conclude that LoRDEC scales sufficiently to correct reads of large eukaryotic genomes on common computing hardware. The Error Correction Toolkit in <xref ref-type="table" rid="btu538-T1">Table 1</xref> (bottom) and alignment statistics in <xref ref-type="table" rid="btu538-T2">Table 2</xref> (bottom) show that the correction accuracy is comparable with the yeast dataset, although the reference is a draft genome containing more errors, and the alignment statistics also suffer from reads aligning to the end of scaffolds having only partial alignments.</p>
    </sec>
    <sec id="SEC3.6">
      <title>3.6 Impact of the genome organization</title>
      <p>The evaluation of the correction delivered by LoRDEC indicates that it is accurate globally on all datasets. However, the genome organization, and especially the presence of repeats, could impact the quality of the correction. One could argue that in repeated regions, the solid k-mers and paths found in the DBG of SR may come from a different or from several copies of the repeat and mislead the correction process. In other words, the accuracy of the correction may vary along the genome. If this is the case, the distribution of reads with respect to the observed genome coverage should differ between raw and corrected reads. To assess this possibility, we computed the expected and observed genome coverages of the aligned raw and corrected reads (Last columns of <xref ref-type="table" rid="btu538-T2">Table 2</xref>). The coverage is computed as the number of genome positions covered by at least one alignment divided by the genome length. For the <italic>E.</italic><italic>coli</italic> and Yeast case, the PacBio sequencing depth is in theory high enough to cover the whole genome (the expected coverage is one), and the effect of correction is to improve the observed coverage beyond 99%. Hence, no bias is visible in terms of coverage for these two cases. The case of the parrot data differs. First, the PacBio sequencing depth is only 5.5×, and thus about eight points separate the expected and observed coverages for both raw and corrected aligned reads (0.92 versus 0.84; 0.98 versus 0.90). To assess a possible bias, we plotted the percentage of the genome covered by aligned reads as a function of read depth for raw and corrected reads (black squares and circles in <xref ref-type="fig" rid="btu538-F4">Fig. 4</xref>). We also plotted the same function but after randomizing the read positions, that is, as if the aligned reads where uniformly distributed over the whole genome (white squares and circles). First, both curves for real alignments depart from their randomized counterparts, showing that some bias exist in the genomic distribution of raw reads, but the same bias remains after correction. Various reasons may explain this bias including the low sequencing depth, locally wrong assembly or mapping bias. Second, the black curves have a similar shape, suggesting that the distribution in function of read depth is not affected by LoRDEC. Note that the curve of corrected reads remains above that of raw reads showing the improvement brought by LoRDEC at all read depths. Hence, even on a vertebrate genome, we conclude that LoRDEC can accurately correct PacBio reads with a small bias due to the genome organization.
<fig id="btu538-F4" position="float"><label>Fig. 4.</label><caption><p>Percentage of the parrot genome covered by raw and corrected reads in function of read depth. The percentages (<italic>y</italic>-axis in log scale) are plotted for the true alignments (in black) and when considering the alignments are uniformly distributed over the genome (in white). Raw reads are represented by square and corrected reads by circles. The curves for corrected reads dominate that of raw reads, as correction increases the number of reads mapped. The black curves adopt similar shapes, suggesting that correction is not seriously impacted by repeats; their distances to the white curves suggest that a bias related to genomic location is already present in the raw reads</p></caption><graphic xlink:href="btu538f4p"/></fig></p>
    </sec>
  </sec>
  <sec>
    <title>4 CONCLUSION</title>
    <p>Owing to their length, PacBio reads provide interesting information to connect other sequences, but this task is made considerably harder by their high error rate, which hinders alignment and similarity detection, both in terms of sensitivity and running time. As seen in our experiments, error correction with LoRDEC makes most of the sequence alignable with percentage of identity &gt;97%. Previous correction programs achieve comparable accuracy, but with prohibitive computational resources. LoRDEC provides a significant improvement in this respect, to such a point that any genomics project can afford PacBio error correction, even with eukaryotic species. Moreover, hybrid error correction shall remain useful because it is powerful to combine distinct types of sequencing in a project.</p>
    <p>Compared with other correction algorithms, LoRDEC offers a novel graph-based approach. Path searching in a DBG allows handling higher error rates. However, this search can fail if either no path or too many paths exist between the source and target <italic>k</italic>-mers. Some improvements seem reachable. When a path is missing, we plan to use the extension path search iteratively on each side of the inner region. A missing path may indicate a remaining adapter, and the local DBG structure could help identifying and removing it. In the case of too many paths, alternative values of <italic>k</italic> may help: a smaller <italic>k</italic> can introduce solid <italic>k</italic>-mers in the region and makes it shorter to solve. An algorithm to dynamically update the order (i.e. the parameter <italic>k</italic>) of the DBG would be useful in this respect (<xref rid="btu538-B4" ref-type="bibr">Cazaux <italic>et al.</italic>, 2014</xref>).</p>
    <p>Additional experiments on PacBio RNA-seq reads show that LoRDEC could also improve the sequence of maize transcripts, which eased their alignment to a reference transcript database (see <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu538/-/DC1">Supplementary data</ext-link>). LoRDEC is simple to use, scalable, can easily be incorporated in a pipeline and should adapt to other types of reads.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="PMC_1" content-type="local-data">
      <caption>
        <title>Supplementary Data</title>
      </caption>
      <media mimetype="text" mime-subtype="html" xlink:href="supp_30_24_3506__index.html"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="pdf" xlink:href="supp_btu538_acor-sm.pdf"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>ACKNOWLEDGEMENTS</title>
    <p>The authors wish to thank the GATB team for access to their library, and B. Cazaux for help with the figures.</p>
    <p><italic>Funding</italic>: This work was supported by <funding-source>Academy of Finland</funding-source> (<award-id>267591</award-id>), by <funding-source>ANR Colib’read</funding-source> (<funding-source>ANR-12-BS02-0008</funding-source>) and Défi MASTODONS SePhHaDe from <funding-source>CNRS</funding-source>, and <funding-source>Labex NumEV</funding-source>, as well as the ATGC platform, which hosts the software.</p>
    <p><italic>Conflict of interest</italic>: none declared.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="btu538-B1">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Basic local alignment search tool</article-title>
        <source>J. Mol. Biol.</source>
        <year>1990</year>
        <volume>215</volume>
        <fpage>403</fpage>
        <lpage>410</lpage>
        <pub-id pub-id-type="pmid">2231712</pub-id>
      </element-citation>
    </ref>
    <ref id="btu538-B2">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Au</surname>
            <given-names>KF</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Improving PacBio long read accuracy by short read alignment</article-title>
        <source>PLoS One</source>
        <year>2012</year>
        <volume>7</volume>
        <fpage>e46679</fpage>
        <pub-id pub-id-type="pmid">23056399</pub-id>
      </element-citation>
    </ref>
    <ref id="btu538-B3">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bashir</surname>
            <given-names>A</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A hybrid approach for the automated finishing of bacterial genomes</article-title>
        <source>Nat. Biotechnol.</source>
        <year>2012</year>
        <volume>30</volume>
        <fpage>701</fpage>
        <lpage>707</lpage>
        <pub-id pub-id-type="pmid">22750883</pub-id>
      </element-citation>
    </ref>
    <ref id="btu538-B4">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Cazaux</surname>
            <given-names>B</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>From indexing data structures to de bruijn graphs</article-title>
        <source>CPM, volume 8486 of LNCS</source>
        <year>2014</year>
        <publisher-name>Springer</publisher-name>
        <fpage>89</fpage>
        <lpage>99</lpage>
      </element-citation>
    </ref>
    <ref id="btu538-B5">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chaisson</surname>
            <given-names>M</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Fragment assembly with short reads</article-title>
        <source>Bioinformatics</source>
        <year>2004</year>
        <volume>20</volume>
        <fpage>2067</fpage>
        <lpage>2074</lpage>
        <pub-id pub-id-type="pmid">15059830</pub-id>
      </element-citation>
    </ref>
    <ref id="btu538-B6">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chaisson</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Pevzner</surname>
            <given-names>PA</given-names>
          </name>
        </person-group>
        <article-title>Short read fragment assembly of bacterial genomes</article-title>
        <source>Genome Res.</source>
        <year>2008</year>
        <volume>18</volume>
        <fpage>324</fpage>
        <lpage>330</lpage>
        <pub-id pub-id-type="pmid">18083777</pub-id>
      </element-citation>
    </ref>
    <ref id="btu538-B7">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chaisson</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Tesler</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Mapping single molecule sequencing reads using basic local alignment with successive refinement (BLASR): application and theory</article-title>
        <source>BMC Bioinformatics</source>
        <year>2012</year>
        <volume>13</volume>
        <fpage>238</fpage>
        <pub-id pub-id-type="pmid">22988817</pub-id>
      </element-citation>
    </ref>
    <ref id="btu538-B8">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Chikhi</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Rizk</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Space-efficient and exact de bruijn graph representation based on a bloom filter</article-title>
        <source>WABI, volume 7534 of LNCS</source>
        <year>2012</year>
        <publisher-name>Springer</publisher-name>
        <fpage>236</fpage>
        <lpage>248</lpage>
      </element-citation>
    </ref>
    <ref id="btu538-B9">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chin</surname>
            <given-names>CS</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Nonhybrid, finished microbial genome assemblies from long-read smrt sequencing data</article-title>
        <source>Nat. Methods</source>
        <year>2013</year>
        <volume>10</volume>
        <fpage>563</fpage>
        <lpage>569</lpage>
        <pub-id pub-id-type="pmid">23644548</pub-id>
      </element-citation>
    </ref>
    <ref id="btu538-B10">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Deshpande</surname>
            <given-names>V</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Cerulean: a hybrid assembly using high throughput short and long reads</article-title>
        <source>WABI, volume 8126 of LNCS</source>
        <year>2013</year>
        <publisher-name>Springer</publisher-name>
        <fpage>349</fpage>
        <lpage>363</lpage>
      </element-citation>
    </ref>
    <ref id="btu538-B11">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dijkstra</surname>
            <given-names>EW</given-names>
          </name>
        </person-group>
        <article-title>A note on two problems in connexion with graphs</article-title>
        <source>Numer. Math.</source>
        <year>1959</year>
        <volume>1</volume>
        <fpage>269</fpage>
        <lpage>271</lpage>
      </element-citation>
    </ref>
    <ref id="btu538-B12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>English</surname>
            <given-names>AC</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Mind the gap: upgrading genomes with pacific biosciences rs long-read sequencing technology</article-title>
        <source>PLoS One</source>
        <year>2012</year>
        <volume>7</volume>
        <fpage>e47768</fpage>
        <pub-id pub-id-type="pmid">23185243</pub-id>
      </element-citation>
    </ref>
    <ref id="btu538-B13">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gnerre</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>High-quality draft assemblies of mammalian genomes from massively parallel sequence data</article-title>
        <source>Proc. Natl Acad. Sci. USA</source>
        <year>2011</year>
        <volume>108</volume>
        <fpage>1513</fpage>
        <lpage>1518</lpage>
        <pub-id pub-id-type="pmid">21187386</pub-id>
      </element-citation>
    </ref>
    <ref id="btu538-B14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Koren</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Hybrid error correction and de novo assembly of single-molecule sequencing reads</article-title>
        <source>Nat. Biotechnol.</source>
        <year>2012</year>
        <volume>30</volume>
        <fpage>693</fpage>
        <lpage>700</lpage>
        <pub-id pub-id-type="pmid">22750884</pub-id>
      </element-citation>
    </ref>
    <ref id="btu538-B15">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Aligning sequence reads, clone sequences and assembly contigs with BWA-MEM</article-title>
        <year>2013</year>
        <comment><italic>arXiv preprint arXiv</italic>:1303.3997</comment>
      </element-citation>
    </ref>
    <ref id="btu538-B16">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Luo</surname>
            <given-names>R</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>SOAPdenovo2: an empirically improved memory-efficient short-read de novo assembler</article-title>
        <source>Gigascience</source>
        <year>2012</year>
        <volume>1</volume>
        <fpage>18</fpage>
        <pub-id pub-id-type="pmid">23587118</pub-id>
      </element-citation>
    </ref>
    <ref id="btu538-B17">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Navarro</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Mäkinen</surname>
            <given-names>V</given-names>
          </name>
        </person-group>
        <article-title>Compressed full-text indexes</article-title>
        <source>ACM Comput. Surv.</source>
        <year>2007</year>
        <volume>39</volume>
        <fpage>500</fpage>
      </element-citation>
    </ref>
    <ref id="btu538-B18">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pevzner</surname>
            <given-names>PA</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>An Eulerian path approach to DNA fragment assembly</article-title>
        <source>Proc. Natl Acad. Sci. USA</source>
        <year>2001</year>
        <volume>98</volume>
        <fpage>9748</fpage>
        <lpage>9753</lpage>
        <pub-id pub-id-type="pmid">11504945</pub-id>
      </element-citation>
    </ref>
    <ref id="btu538-B19">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Philippe</surname>
            <given-names>N</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>CRAC: an integrated approach to the analysis of RNA-seq reads</article-title>
        <source>Genome Biol.</source>
        <year>2013</year>
        <volume>14</volume>
        <fpage>R30</fpage>
        <pub-id pub-id-type="pmid">23537109</pub-id>
      </element-citation>
    </ref>
    <ref id="btu538-B20">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Salikhov</surname>
            <given-names>K</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Using cascading bloom filters to improve the memory usage for de brujin graphs</article-title>
        <source>WABI, volume 8126 of LNCS</source>
        <year>2013</year>
        <fpage>364</fpage>
        <lpage>376</lpage>
      </element-citation>
    </ref>
    <ref id="btu538-B21">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Salmela</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Correction of sequencing errors in a mixed set of reads</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <fpage>1284</fpage>
        <lpage>1290</lpage>
        <pub-id pub-id-type="pmid">20378555</pub-id>
      </element-citation>
    </ref>
    <ref id="btu538-B22">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Salmela</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Schröder</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Correcting errors in short reads by multiple alignments</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <fpage>1455</fpage>
        <lpage>1461</lpage>
        <pub-id pub-id-type="pmid">21471014</pub-id>
      </element-citation>
    </ref>
    <ref id="btu538-B23">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>GAGE: a critical evaluation of genome assemblies and assembly algorithms</article-title>
        <source>Genome Res.</source>
        <year>2012</year>
        <volume>22</volume>
        <fpage>557</fpage>
        <lpage>567</lpage>
        <pub-id pub-id-type="pmid">22147368</pub-id>
      </element-citation>
    </ref>
    <ref id="btu538-B24">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schröder</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>SHREC: a short-read error correction method</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>2157</fpage>
        <lpage>2163</lpage>
        <pub-id pub-id-type="pmid">19542152</pub-id>
      </element-citation>
    </ref>
    <ref id="btu538-B25">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Yang</surname>
            <given-names>X</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A survey of error-correction methods for next-generation sequencing</article-title>
        <source>Brief. Bioinform.</source>
        <year>2013</year>
        <volume>14</volume>
        <fpage>56</fpage>
        <lpage>66</lpage>
        <pub-id pub-id-type="pmid">22492192</pub-id>
      </element-citation>
    </ref>
    <ref id="btu538-B26">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zerbino</surname>
            <given-names>DR</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Velvet: algorithms for de novo short read assembly using de Bruijn graphs</article-title>
        <source>Genome Res.</source>
        <year>2008</year>
        <volume>18</volume>
        <fpage>821</fpage>
        <lpage>829</lpage>
        <pub-id pub-id-type="pmid">18349386</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
