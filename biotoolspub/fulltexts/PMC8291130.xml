<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName nlm2jats3.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Front Neuroinform</journal-id>
    <journal-id journal-id-type="iso-abbrev">Front Neuroinform</journal-id>
    <journal-id journal-id-type="publisher-id">Front. Neuroinform.</journal-id>
    <journal-title-group>
      <journal-title>Frontiers in Neuroinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1662-5196</issn>
    <publisher>
      <publisher-name>Frontiers Media S.A.</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8291130</article-id>
    <article-id pub-id-type="doi">10.3389/fninf.2021.614881</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Neuroscience</subject>
        <subj-group>
          <subject>Technology and Code</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>MIIND : A Model-Agnostic Simulator of Neural Populations</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Osborne</surname>
          <given-names>Hugh</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
        <uri xlink:type="simple" xlink:href="http://loop.frontiersin.org/people/283685/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Lai</surname>
          <given-names>Yi Ming</given-names>
        </name>
        <xref ref-type="aff" rid="aff2">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Lepperød</surname>
          <given-names>Mikkel Elle</given-names>
        </name>
        <xref ref-type="aff" rid="aff3">
          <sup>3</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Sichau</surname>
          <given-names>David</given-names>
        </name>
        <xref ref-type="aff" rid="aff4">
          <sup>4</sup>
        </xref>
        <uri xlink:type="simple" xlink:href="http://loop.frontiersin.org/people/1283685/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Deutz</surname>
          <given-names>Lukas</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>de Kamps</surname>
          <given-names>Marc</given-names>
        </name>
        <xref ref-type="aff" rid="aff5">
          <sup>5</sup>
        </xref>
        <xref ref-type="corresp" rid="c001">
          <sup>*</sup>
        </xref>
        <uri xlink:type="simple" xlink:href="http://loop.frontiersin.org/people/1657/overview"/>
      </contrib>
    </contrib-group>
    <aff id="aff1"><sup>1</sup><institution>Institute for Artificial Intelligence and Biological Computation, School of Computing, University of Leeds</institution>, <addr-line>Leeds</addr-line>, <country>United Kingdom</country></aff>
    <aff id="aff2"><sup>2</sup><institution>School of Medicine, University of Nottingham</institution>, <addr-line>Nottingham</addr-line>, <country>United Kingdom</country></aff>
    <aff id="aff3"><sup>3</sup><institution>Centre for Integrative Neuroplasticity, University of Oslo</institution>, <addr-line>Oslo</addr-line>, <country>Norway</country></aff>
    <aff id="aff4"><sup>4</sup><institution>Department of Computer Science, Eidgenössische Technische Hochschule Zurich</institution>, <addr-line>Zurich</addr-line>, <country>Switzerland</country></aff>
    <aff id="aff5"><sup>5</sup><institution>School of Computing and Leeds Institute for Data Analytics, University of Leeds</institution>, <addr-line>Leeds</addr-line>, <country>United Kingdom</country></aff>
    <author-notes>
      <fn fn-type="edited-by">
        <p>Edited by: Andrew P. Davison, UMR9197 Institut des Neurosciences Paris Saclay (Neuro-PSI), France</p>
      </fn>
      <fn fn-type="edited-by">
        <p>Reviewed by: Padraig Gleeson, University College London, United Kingdom; Sandra Diaz Pier, Julich-Forschungszentrum, Helmholtz-Verband Deutscher Forschungszentren (HZ), Germany</p>
      </fn>
      <corresp id="c001">*Correspondence: Marc de Kamps <email>m.dekamps@leeds.ac.uk</email></corresp>
    </author-notes>
    <pub-date pub-type="epub">
      <day>06</day>
      <month>7</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2021</year>
    </pub-date>
    <volume>15</volume>
    <elocation-id>614881</elocation-id>
    <history>
      <date date-type="received">
        <day>07</day>
        <month>10</month>
        <year>2020</year>
      </date>
      <date date-type="accepted">
        <day>24</day>
        <month>5</month>
        <year>2021</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2021 Osborne, Lai, Lepperød, Sichau, Deutz and de Kamps.</copyright-statement>
      <copyright-year>2021</copyright-year>
      <copyright-holder>Osborne, Lai, Lepperød, Sichau, Deutz and de Kamps</copyright-holder>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License (CC BY). The use, distribution or reproduction in other forums is permitted, provided the original author(s) and the copyright owner(s) are credited and that the original publication in this journal is cited, in accordance with accepted academic practice. No use, distribution or reproduction is permitted which does not comply with these terms.</license-p>
      </license>
    </permissions>
    <abstract>
      <p>MIIND is a software platform for easily and efficiently simulating the behaviour of interacting populations of point neurons governed by any 1D or 2D dynamical system. The simulator is entirely agnostic to the underlying neuron model of each population and provides an intuitive method for controlling the amount of noise which can significantly affect the overall behaviour. A network of populations can be set up quickly and easily using MIIND's XML-style simulation file format describing simulation parameters such as how populations interact, transmission delays, post-synaptic potentials, and what output to record. During simulation, a visual display of each population's state is provided for immediate feedback of the behaviour and population activity can be output to a file or passed to a Python script for further processing. The Python support also means that MIIND can be integrated into other software such as The Virtual Brain. MIIND's population density technique is a geometric and visual method for describing the activity of each neuron population which encourages a deep consideration of the dynamics of the neuron model and provides insight into how the behaviour of each population is affected by the behaviour of its neighbours in the network. For 1D neuron models, MIIND performs far better than direct simulation solutions for large populations. For 2D models, performance comparison is more nuanced but the population density approach still confers certain advantages over direct simulation. MIIND can be used to build neural systems that bridge the scales between an individual neuron model and a population network. This allows researchers to maintain a plausible path back from mesoscopic to microscopic scales while minimising the complexity of managing large numbers of interconnected neurons. In this paper, we introduce the MIIND system, its usage, and provide implementation details where appropriate.</p>
    </abstract>
    <kwd-group>
      <kwd>simulator</kwd>
      <kwd>neural population</kwd>
      <kwd>population density</kwd>
      <kwd>software</kwd>
      <kwd>Python</kwd>
      <kwd>dynamical systems</kwd>
      <kwd>network</kwd>
      <kwd>GPU</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source id="cn001">Horizon 2020<named-content content-type="fundref-id">10.13039/501100007601</named-content></funding-source>
        <award-id rid="cn001">Grant Agreement No. 720270 (HBP SGA1)</award-id>
        <award-id rid="cn001">Specific Grant Agreement No. 785907 (Human Brain Project SGA2)</award-id>
      </award-group>
      <award-group>
        <funding-source id="cn002">Engineering and Physical Sciences Research Council<named-content content-type="fundref-id">10.13039/501100000266</named-content></funding-source>
        <award-id rid="cn002">2042636</award-id>
      </award-group>
    </funding-group>
    <counts>
      <fig-count count="14"/>
      <table-count count="5"/>
      <equation-count count="8"/>
      <ref-count count="43"/>
      <page-count count="29"/>
      <word-count count="19135"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec sec-type="intro" id="s1">
    <title>1. Introduction</title>
    <sec>
      <title>1.1. Population-Level Modeling</title>
      <p>Structures in the brain at various scales can be approximated by simple neural population networks based on commonly observed neural connections. There are a great number of techniques to simulate the behaviour of neural populations with varying degrees of granularity and computational efficiency. At the highest detail, individual neurons can be modelled with multiple compartments, transport mechanisms, and other biophysical attributes. Simulators such as GENESIS (Wilson et al., <xref rid="B42" ref-type="bibr">1988</xref>; Bower and Beeman, <xref rid="B2" ref-type="bibr">2012</xref>) and NEURON (Hines and Carnevale, <xref rid="B19" ref-type="bibr">2001</xref>) have been used for investigations of the cerebellar microcircuit (D'Angelo et al., <xref rid="B7" ref-type="bibr">2016</xref>) and a thalamocortical network model (Traub et al., <xref rid="B38" ref-type="bibr">2005</xref>). Techniques which simulate the individual behaviour of point neurons such as in NEST (Gewaltig and Diesmann, <xref rid="B17" ref-type="bibr">2007</xref>), or the neuromorphic system SpiNNaker (Furber et al., <xref rid="B15" ref-type="bibr">2014</xref>), allow neurons to be individually parameterised and connections to be heterogeneous. This is particularly useful for analysing information transfer such as edge detection in the visual cortex. They can also be used to analyse so called finite-size effects where population behaviour only occurs as a result of a specific realisation of individual neuron behaviour. There are, however, performance limitations on very large populations in terms of both computation speed and memory requirements for storing the spike history of each neuron.</p>
      <p>At a less granular level, rate-based techniques are a widely used practice of modeling neural activity with a single variable, whose evolution is often described by first-order ordinary differential equations, which goes back to Wilson and Cowan (<xref rid="B41" ref-type="bibr">1972</xref>). The Virtual Brain (TVB) uses these types of models to represent activity of large regions (nodes) in whole brain networks to generate efficient simulations (Sanz Leon et al., <xref rid="B37" ref-type="bibr">2013</xref>; Jirsa et al., <xref rid="B23" ref-type="bibr">2014</xref>). TVB demonstrates the benefits of a rate based approach with the Epileptor neural population model yielding impressive clinical results (Proix et al., <xref rid="B36" ref-type="bibr">2017</xref>). The Epileptor model is based on the well-known Hindmarsh-Rose neuron model (Hindmarsh and Rose, <xref rid="B18" ref-type="bibr">1984</xref>). However, the behaviour of this and other rate based models is defined at the population level instead of behaviour emerging from a definition of the underlying neurons. Therefore, these models have less power to explain simulated behaviours at the microscopic level.</p>
      <p>Between these two extremes of granularity is a research area which bridges the scales by deriving population level behaviour from the behaviour of the underlying neurons. So called population density techniques (PDTs) have been used for many years (Knight, <xref rid="B25" ref-type="bibr">1972</xref>; Knight et al., <xref rid="B26" ref-type="bibr">1996</xref>; Omurtag et al., <xref rid="B33" ref-type="bibr">2000</xref>) to describe a population of neurons in terms of a probability density function. The transfer function of a neuron model or even an experimental neural recording can be used to approximate the response from a population using this technique (Wilson and Cowan, <xref rid="B41" ref-type="bibr">1972</xref>; El Boustani and Destexhe, <xref rid="B12" ref-type="bibr">2009</xref>; Carlu et al., <xref rid="B6" ref-type="bibr">2020</xref>). However, analytical solutions are often limited to regular spiking behaviour with constant or slowly changing input. The software we present here, MIIND, provides a numerical solution for populations of neurons with potentially complex behaviours (for example bursting) receiving rapidly changing noisy input with arbitrary jump sizes. The noise is usually assumed to be shot noise, but MIIND can also be used with other renewal processes such as Gamma distributed input (Lai and de Kamps, <xref rid="B27" ref-type="bibr">2017</xref>). It contains a number of features that make it particularly suitable for dynamical systems representing neuronal dynamics, such as an adequate handling of boundary conditions that emerge from the presence of thresholds and reset mechanisms, but is not restricted to neural systems. The dynamical systems can be grouped in large networks, which can be seen as the model of a neural circuit at the population level.</p>
      <p>The key idea behind MIIND is shown in <xref ref-type="fig" rid="F1">Figure 1A</xref>. Here, a population of neurons is simulated. In this case, the neurons are defined by a conductance based leaky-integrate-and-fire neuron model with membrane potential and state of the conductance as the two variables. The neuron's evolution through state space is given by a two-dimensional dynamical system described by Equation (1).</p>
      <disp-formula id="E1">
        <label>(1)</label>
        <mml:math id="M1">
          <mml:mtable class="eqnarray" columnalign="left left left">
            <mml:mtr>
              <mml:mtd>
                <mml:mtable style="text-align:axis;" equalrows="false" columnlines="none" equalcolumns="false" class="array">
                  <mml:mtr>
                    <mml:mtd columnalign="left">
                      <mml:mtext>    </mml:mtext>
                      <mml:mi>τ</mml:mi>
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mi>d</mml:mi>
                          <mml:mi>V</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>d</mml:mi>
                          <mml:mi>t</mml:mi>
                        </mml:mrow>
                      </mml:mfrac>
                      <mml:mo>=</mml:mo>
                      <mml:mo>-</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>g</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>l</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mrow>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mrow>
                          <mml:mi>V</mml:mi>
                          <mml:mo>-</mml:mo>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>E</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>l</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                      <mml:mo>-</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>g</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>e</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mrow>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mrow>
                          <mml:mi>t</mml:mi>
                        </mml:mrow>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                      <mml:mi>V</mml:mi>
                      <mml:mo>,</mml:mo>
                    </mml:mtd>
                  </mml:mtr>
                  <mml:mtr>
                    <mml:mtd columnalign="left">
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>τ</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>e</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mi>d</mml:mi>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>g</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>e</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>d</mml:mi>
                          <mml:mi>t</mml:mi>
                        </mml:mrow>
                      </mml:mfrac>
                      <mml:mo>=</mml:mo>
                      <mml:mo>-</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>g</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>e</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo>+</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>I</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>s</mml:mi>
                          <mml:mi>y</mml:mi>
                          <mml:mi>n</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mrow>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mrow>
                          <mml:mi>t</mml:mi>
                        </mml:mrow>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                    </mml:mtd>
                  </mml:mtr>
                </mml:mtable>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p><italic>V</italic> is the membrane potential and <italic>g</italic><sub><italic>e</italic></sub> is the conductance variable. <italic>E</italic><sub><italic>l</italic></sub> (set to −65 mV in this example) is the reversal potential and τ (20 ms) and τ<sub><italic>e</italic></sub> (5 ms) represent the time scales for <italic>V</italic> and <italic>g</italic><sub><italic>e</italic></sub>, respectively. <italic>I</italic><sub><italic>syn</italic></sub> represents changes to the conductance variable due to incoming spikes. If <italic>V</italic> is raised above a specified threshold value (−55 mV), it is reset to a specified reset membrane potential (−65 mV). The positions of individual neurons change in state space, both under the influence of the neuron's endogenous dynamics as determined by the dynamical system and of spike trains arriving from neurons in other populations, which cause rapid transitions in state space that are modeled as instantaneous jumps. For the simulation techniques mentioned earlier involving a large number of individual model neuron instances, a practice that we will refer to as Monte Carlo simulation, the population can be represented as a cloud of points in state space. The approach in MIIND, known as a population density technique (PDT), models the probability density of the cloud (shown in <xref ref-type="fig" rid="F1">Figure 1</xref> as a heat map) rather than the behaviour of individual neurons. The threshold and reset values of the underlying neuron model are visible in the hard vertical edges of the density in <xref ref-type="fig" rid="F1">Figure 1A</xref>. In <xref ref-type="fig" rid="F1">Figure 1B</xref>, the same simulation approach is used for a population of Fitzhugh-Nagumo neurons (FitzHugh, <xref rid="B13" ref-type="bibr">1961</xref>; Nagumo et al., <xref rid="B31" ref-type="bibr">1962</xref>). The dynamical system is defined in Equation (2).</p>
      <disp-formula id="E2">
        <label>(2)</label>
        <mml:math id="M2">
          <mml:mtable class="eqnarray" columnalign="left left left">
            <mml:mtr>
              <mml:mtd>
                <mml:mtable style="text-align:axis;" equalrows="false" columnlines="" equalcolumns="false" class="array">
                  <mml:mtr>
                    <mml:mtd columnalign="left">
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mi>d</mml:mi>
                          <mml:mi>V</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>d</mml:mi>
                          <mml:mi>t</mml:mi>
                        </mml:mrow>
                      </mml:mfrac>
                      <mml:mo>=</mml:mo>
                      <mml:mi>V</mml:mi>
                      <mml:mo>-</mml:mo>
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:msup>
                            <mml:mrow>
                              <mml:mi>V</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mn>3</mml:mn>
                            </mml:mrow>
                          </mml:msup>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mn>3</mml:mn>
                        </mml:mrow>
                      </mml:mfrac>
                      <mml:mo>-</mml:mo>
                      <mml:mi>W</mml:mi>
                      <mml:mo>,</mml:mo>
                    </mml:mtd>
                  </mml:mtr>
                  <mml:mtr>
                    <mml:mtd columnalign="left">
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mi>d</mml:mi>
                          <mml:mi>W</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>d</mml:mi>
                          <mml:mi>t</mml:mi>
                        </mml:mrow>
                      </mml:mfrac>
                      <mml:mo>=</mml:mo>
                      <mml:mn>0</mml:mn>
                      <mml:mo>.</mml:mo>
                      <mml:mn>08</mml:mn>
                      <mml:mrow>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mrow>
                          <mml:mi>V</mml:mi>
                          <mml:mo>+</mml:mo>
                          <mml:mn>0</mml:mn>
                          <mml:mo>.</mml:mo>
                          <mml:mn>7</mml:mn>
                          <mml:mo>-</mml:mo>
                          <mml:mn>0</mml:mn>
                          <mml:mo>.</mml:mo>
                          <mml:mn>8</mml:mn>
                          <mml:mi>W</mml:mi>
                        </mml:mrow>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                    </mml:mtd>
                  </mml:mtr>
                </mml:mtable>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p><italic>V</italic> represents the membrane potential and <italic>W</italic> is a recovery variable. The Fitzhugh-Nagumo model has no threshold-reset mechanism and so there are no vertical boundaries to the density. As well as the density function being informative in itself, common population metrics such as average firing rate and average membrane potential can be quickly derived. The MIIND model archive, available in the code repository, contains example simulation files for populations of both conductance based neurons and Fitzhugh-Nagumo neurons (<italic>examples/model_archive/Conductance2D</italic> and <italic>examples/model_archive/FitzhughNagumo</italic>).</p>
      <fig id="F1" position="float">
        <label>Figure 1</label>
        <caption>
          <p><bold>(A)</bold> The state space of a conductance based point model neuron. It is spanned by two variables: the membrane potential and a variable representing how open the channel is. This channel has an equilibrium potential that is positive. The green dots represent the state of individual neurons in a population. They are the result of the direct simulation of a group of neurons. MIIND, however, produces the heat plot representing a density (normalised to the maximum density value) which predicts where neurons in the population are likely to be: most likely in the white areas, least likely in the red areas and not at all in the black areas. The sharp vertical cut of the coloured area at −55 mV represents the threshold at which neurons are removed from state space. They are subsequently inserted at the reset potential, at their original conductance state value. <bold>(B)</bold> The state space of a Fitzhugh-Nagumo neuron model. The axes have arbitrary units for variables <italic>V</italic> and <italic>W</italic>. There is no threshold-reset mechanism and the density follows a limit cycle. After a certain amount of simulation time, neurons can be found at all points along the limit cycle as shown here by a consistently high brightness.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-g0001"/>
      </fig>
    </sec>
    <sec>
      <title>1.2. The Case for Population Density Techniques</title>
      <p>Why use this technique? Nykamp and Tranchina (<xref rid="B32" ref-type="bibr">2000</xref>), Omurtag et al. (<xref rid="B33" ref-type="bibr">2000</xref>), Kamps (<xref rid="B24" ref-type="bibr">2003</xref>), Iyer et al. (<xref rid="B20" ref-type="bibr">2013</xref>) have demonstrated that PDTs are much faster than Monte Carlo simulation for 1D models; De Kamps et al. (<xref rid="B10" ref-type="bibr">2019</xref>) have shown that while speed is comparable between 2D models and Monte Carlo, memory usage is orders of magnitude lower because no spikes need to be buffered, which accounts for significant memory use in large-scale simulations. In practice, this may make the difference between running a simulation on an HPC cluster or a single PC equipped with a general purpose graphics processing unit (GPGPU).</p>
      <p>Apart from simulation speed, PDTs have been important in understanding population level behaviour analytically. Important questions, such as “why are cortical networks stable?” (Amit and Brunel, <xref rid="B1" ref-type="bibr">1997</xref>), “how can a population be oscillatory when its constituent neurons fire sporadically?” (Brunel and Hakim, <xref rid="B4" ref-type="bibr">1999</xref>), “how does spike shape influence the transmission spectrum of a population?” (Fourcaud-Trocmé et al., <xref rid="B14" ref-type="bibr">2003</xref>) have been analysed in the context of population density techniques, providing insights that cannot be obtained from merely running simulations. A particularly important question, which has not been answered in full is: “how do rate-based equations emerge from populations of spiking neurons and when is their use appropriate?” There are many situations where such rate-based equations are appropriate, but some where they are not and their correspondence to the underlying spiking neural dynamics is not always clear (de Kamps, <xref rid="B8" ref-type="bibr">2013</xref>; Montbrió et al., <xref rid="B30" ref-type="bibr">2015</xref>). There is a body of work suggesting that some rate-based equations can be seen as the lowest order of perturbations of a stationary state, and much of this work is PDT-based (Wilson and Cowan, <xref rid="B41" ref-type="bibr">1972</xref>; Gerstner, <xref rid="B16" ref-type="bibr">1998</xref>; Mattia and Del Giudice, <xref rid="B28" ref-type="bibr">2002</xref>, <xref rid="B29" ref-type="bibr">2004</xref>; Montbrió et al., <xref rid="B30" ref-type="bibr">2015</xref>). MIIND opens the possibility to incorporate these theoretical insights into large-scale network models. For example, we can demonstrate the prediction from Brunel and Hakim (<xref rid="B4" ref-type="bibr">1999</xref>) that inhibitory feedback on a population can cause a bifurcation and produce resonance. Finally, for a steady state input, the firing rate prediction of a PDT model converges to a transfer function which can be used in artifical spiking neural networks (De Kamps et al., <xref rid="B9" ref-type="bibr">2008</xref>).</p>
    </sec>
    <sec>
      <title>1.3. Population-Level Modeling</title>
      <p>For the population density approach we take with MIIND, the time evolution of the probability density function is described by a partial integro-differential equation. We give it here to highlight some of its features, but for an in depth introduction to the formalism and a derivation of the central equations we refer to Omurtag et al. (<xref rid="B33" ref-type="bibr">2000</xref>).</p>
      <disp-formula id="E3">
        <label>(3)</label>
        <mml:math id="M3">
          <mml:mtable class="eqnarray" columnalign="left left left">
            <mml:mtr>
              <mml:mtd>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:mi>∂</mml:mi>
                    <mml:mi>ρ</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>∂</mml:mi>
                    <mml:mi>t</mml:mi>
                  </mml:mrow>
                </mml:mfrac>
                <mml:mo>+</mml:mo>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:mi>∂</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>∂</mml:mi>
                    <mml:mover accent="true">
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                      </mml:mrow>
                      <mml:mo>→</mml:mo>
                    </mml:mover>
                  </mml:mrow>
                </mml:mfrac>
                <mml:mo>·</mml:mo>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:mover accent="true">
                          <mml:mrow>
                            <mml:mi>F</mml:mi>
                          </mml:mrow>
                          <mml:mo>→</mml:mo>
                        </mml:mover>
                        <mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mrow>
                            <mml:mover accent="true">
                              <mml:mrow>
                                <mml:mi>v</mml:mi>
                              </mml:mrow>
                              <mml:mo>→</mml:mo>
                            </mml:mover>
                          </mml:mrow>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                        <mml:mi>ρ</mml:mi>
                        <mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mrow>
                            <mml:mover accent="true">
                              <mml:mrow>
                                <mml:mi>v</mml:mi>
                              </mml:mrow>
                              <mml:mo>→</mml:mo>
                            </mml:mover>
                            <mml:mo>,</mml:mo>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>τ</mml:mi>
                      </mml:mrow>
                    </mml:mfrac>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:mstyle displaystyle="true">
                  <mml:msub>
                    <mml:mrow>
                      <mml:mo>∫</mml:mo>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>M</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mstyle>
                <mml:mi>d</mml:mi>
                <mml:msup>
                  <mml:mrow>
                    <mml:mover accent="true">
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                      </mml:mrow>
                      <mml:mo>→</mml:mo>
                    </mml:mover>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>′</mml:mi>
                  </mml:mrow>
                </mml:msup>
                <mml:mrow>
                  <mml:mo>{</mml:mo>
                  <mml:mrow>
                    <mml:mi>W</mml:mi>
                    <mml:mrow>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mrow>
                        <mml:mover accent="true">
                          <mml:mrow>
                            <mml:mi>v</mml:mi>
                          </mml:mrow>
                          <mml:mo>→</mml:mo>
                        </mml:mover>
                        <mml:mo>∣</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mover accent="true">
                              <mml:mrow>
                                <mml:mi>v</mml:mi>
                              </mml:mrow>
                              <mml:mo>→</mml:mo>
                            </mml:mover>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>′</mml:mi>
                          </mml:mrow>
                        </mml:msup>
                      </mml:mrow>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                    <mml:mi>ρ</mml:mi>
                    <mml:mrow>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mrow>
                        <mml:mover accent="true">
                          <mml:mrow>
                            <mml:msup>
                              <mml:mrow>
                                <mml:mi>v</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>′</mml:mi>
                              </mml:mrow>
                            </mml:msup>
                          </mml:mrow>
                          <mml:mo>→</mml:mo>
                        </mml:mover>
                      </mml:mrow>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                    <mml:mo>-</mml:mo>
                    <mml:mi>W</mml:mi>
                    <mml:mrow>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mover accent="true">
                              <mml:mrow>
                                <mml:mi>v</mml:mi>
                              </mml:mrow>
                              <mml:mo>→</mml:mo>
                            </mml:mover>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>′</mml:mi>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>∣</mml:mo>
                        <mml:mover accent="true">
                          <mml:mrow>
                            <mml:mi>v</mml:mi>
                          </mml:mrow>
                          <mml:mo>→</mml:mo>
                        </mml:mover>
                      </mml:mrow>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                    <mml:mi>ρ</mml:mi>
                    <mml:mrow>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mrow>
                        <mml:mover accent="true">
                          <mml:mrow>
                            <mml:mi>v</mml:mi>
                          </mml:mrow>
                          <mml:mo>→</mml:mo>
                        </mml:mover>
                      </mml:mrow>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mo>}</mml:mo>
                </mml:mrow>
                <mml:mo>,</mml:mo>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>ρ is the probability density function defined over a volume of state space, <italic>M</italic>, in terms of time, <italic>t</italic>, and time-dependent variables, <inline-formula><mml:math id="M4"><mml:mover accent="true"><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mo>→</mml:mo></mml:mover></mml:math></inline-formula>, under the assumption that the neuronal dynamics of a point model neuron is given by:</p>
      <disp-formula id="E4">
        <label>(4)</label>
        <mml:math id="M5">
          <mml:mtable class="eqnarray" columnalign="left left left">
            <mml:mtr>
              <mml:mtd>
                <mml:mi>τ</mml:mi>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:mi>d</mml:mi>
                    <mml:mover accent="true">
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                      </mml:mrow>
                      <mml:mo>→</mml:mo>
                    </mml:mover>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>d</mml:mi>
                    <mml:mi>t</mml:mi>
                  </mml:mrow>
                </mml:mfrac>
                <mml:mo>=</mml:mo>
                <mml:mover accent="true">
                  <mml:mrow>
                    <mml:mi>F</mml:mi>
                  </mml:mrow>
                  <mml:mo>→</mml:mo>
                </mml:mover>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:mover accent="true">
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                      </mml:mrow>
                      <mml:mo>→</mml:mo>
                    </mml:mover>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>,</mml:mo>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>where τ is the neuron's membrane time constant. Simple models are one-dimensional (1D). For the leaky-integrate-and-fire (LIF) neuron:</p>
      <disp-formula id="E5">
        <label>(5)</label>
        <mml:math id="M6">
          <mml:mtable class="eqnarray" columnalign="left left left">
            <mml:mtr>
              <mml:mtd>
                <mml:mi>F</mml:mi>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:mo>-</mml:mo>
                <mml:mi>v</mml:mi>
                <mml:mo>,</mml:mo>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>For a quadratic-integrate-and-fire (QIF) neuron:</p>
      <disp-formula id="E6">
        <label>(6)</label>
        <mml:math id="M7">
          <mml:mtable class="eqnarray" columnalign="left left left">
            <mml:mtr>
              <mml:mtd>
                <mml:mi>F</mml:mi>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>2</mml:mn>
                  </mml:mrow>
                </mml:msup>
                <mml:mo>+</mml:mo>
                <mml:mi>I</mml:mi>
                <mml:mo>,</mml:mo>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>where <italic>v</italic> is the membrane potential, and <italic>I</italic> can be interpreted as a bifurcation parameter. More complex models require a higher dimensional state space. Since such a space is hard to visualise and understand, considerable effort has been invested in the creation of effective models. In particular two-dimensional (2D) models are considered to be a compromise that allows considerably more biological realism than LIF or QIF neurons, but which remain amenable to visualisation and analysis, and can often be interpreted geometrically (Izhikevich, <xref rid="B22" ref-type="bibr">2007</xref>). Examples are the Izhikevich simple neuron (Izhikevich, <xref rid="B21" ref-type="bibr">2003</xref>), the Fitzhugh-Nagumo neuron (FitzHugh, <xref rid="B13" ref-type="bibr">1961</xref>; Nagumo et al., <xref rid="B31" ref-type="bibr">1962</xref>), and the adaptive-exponential-integrate-and-fire neuron (Brette and Gerstner, <xref rid="B3" ref-type="bibr">2005</xref>), incorporating phenomena such as bursting, bifurcations, adaptation, and others that cannot be accounted for in a one dimensional model.</p>
      <p><italic>W</italic>(<italic>v</italic>∣<italic>v</italic>′) in Equation (3) represents a transition probability rate function. The right hand side of Equation (3) makes it a Master equation. Any Markovian process can be represented by a suitable choice of <italic>W</italic>. For example, for shot noise, we have</p>
      <disp-formula id="E7">
        <label>(7)</label>
        <mml:math id="M8">
          <mml:mtable class="eqnarray" columnalign="left left left">
            <mml:mtr>
              <mml:mtd>
                <mml:mi>W</mml:mi>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>′</mml:mi>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mo>∣</mml:mo>
                    <mml:mi>v</mml:mi>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:mi>ν</mml:mi>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:mi>δ</mml:mi>
                    <mml:mrow>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi>v</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>′</mml:mi>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>-</mml:mo>
                        <mml:mi>v</mml:mi>
                        <mml:mo>-</mml:mo>
                        <mml:mi>h</mml:mi>
                      </mml:mrow>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                    <mml:mo>-</mml:mo>
                    <mml:mi>δ</mml:mi>
                    <mml:mrow>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mo>-</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi>v</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>′</mml:mi>
                          </mml:mrow>
                        </mml:msup>
                      </mml:mrow>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>,</mml:mo>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>where ν is the rate of the Poisson process generating spike events. The delta functions reflect that an incoming spike causes a rapid change in state space, modeled as an instantaneous jump, <italic>h</italic>. It depends on the particular neural model in what variable the jumps take place. Often models use a so-called delta synapse, such that the jump is in membrane potential. In conductance based models, the incoming spike causes a jump in the conductance variable (<xref ref-type="fig" rid="F1">Figure 1A</xref>), and the influence of the incoming spike on the potential is then indirect, given by the dynamical system's response to the sudden change in the conductance state.</p>
      <p>MIIND produces a numerical solution to Equation (3) for arbitrary 1D or 2D versions of <inline-formula><mml:math id="M9"><mml:mover accent="true"><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mo>→</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (support for 3D versions is in development), under a broad variety of noise processes. Indeed, the right hand side of Equation (3) can be generalised to other renewal processes which cannot simply be formulated in terms of a transition probability rate function <italic>W</italic>. It is possible to introduce a right hand side that entails an integration over a past history of the density using a kernel whose shape is determined by a Gamma distribution or other renewal process (Lai and de Kamps, <xref rid="B27" ref-type="bibr">2017</xref>).</p>
    </sec>
    <sec>
      <title>1.4. Quick Start Guide</title>
      <p>Before describing the implementation details of MIIND, this section demonstrates how to quickly set up a simulation for a simple E-I network of populations of conductance based neurons using the MIIND Python library. A rudimentary level of Python experience is needed to run the simulation. In most cases, MIIND can be installed via Python pip. Detailed installation instructions can be found via the <italic>README.md</italic> file of the MIIND repository and in the MIIND documentation (Osborne and De Kamps, <xref rid="B34" ref-type="bibr">2021</xref>). For this example, we will use a pre-written script, <italic>generateCondFiles.py</italic>, to generate the required simulation files which can be found in the <italic>examples/quick_start</italic> directory of the MIIND repository or can be loaded into a working directory using the following python command.</p>
      <preformat>
  $ python -m miind.loadExamples
</preformat>
      <p>In the <italic>examples/quick_start</italic> directory, the <italic>generateCondFiles.py</italic> script generates the simulation files, <italic>cond.model</italic> and <italic>cond.tmat</italic>.</p>
      <preformat>
  $ python generateCondFiles.py
</preformat>
      <p>The contents of <italic>generateCondFiles.py</italic> is given in Listing 1. The two important parts of the script are the neuron model function, in this case named <italic>cond()</italic>, and the call to the MIIND function <italic>grid_generate.generate()</italic> which takes a number of parameters which are discussed in detail later.</p>
      <table-wrap id="d31e927" position="float">
        <label>Listing 1</label>
        <caption>
          <p><italic>generateCondFiles.py</italic>.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0001"/>
      </table-wrap>
      <p>The <italic>cond()</italic> function should be familiar to those who have used Python numerical integration frameworks such as <italic>scipy.integrate</italic>. It takes the two time dependent variables defined by <italic>y</italic>[0] and <italic>y</italic>[1] and a placeholder parameter, <italic>t</italic>, for performing a numerical integration. In the function, the user may define how the derivatives of each variable are to be calculated. The <italic>generate()</italic> function requires a suitable time step, values for a threshold and reset if needed, and a description of the extent of the state space to be simulated. With this structure, the user may define any two dimensional neuron model. The generated files are then referenced in a second file which describes a network of populations to be simulated. Listing 2 shows the contents of <italic>cond.xml</italic> describing an E-I network which uses the generated files from <italic>generateCondFiles.py</italic>.</p>
      <table-wrap id="d31e953" position="float">
        <label>Listing 2</label>
        <caption>
          <p><italic>cond.xml</italic>.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0002"/>
      </table-wrap>
      <p>The full syntax documentation for MIIND XML files is given in section 4. Though more compact or flexible formats are available, XML was chosen as a formatting style due to its ubiquity ensuring the majority of users will already be familiar with the syntax. The <italic>Algorithms</italic> section is used to declare specific simulation methods for one or more populations in the network. In this case, a GridAlgorithm named <italic>COND</italic> is set up which references the <italic>cond.model</italic> and <italic>cond.tmat</italic> files. A RateFunctor algorithm produces a constant firing rate. In the <italic>Nodes</italic> section, two instances of <italic>COND</italic> are created: one for the excitatory and inhibitory populations, respectively. Two <italic>ExcitatoryInput</italic> nodes are also defined. The <italic>Connections</italic> section allows us to connect the input nodes to the two conductance populations. The populations are connected to each other and to themselves with a 1ms transmission delay. The remaining sections are used to define how the output of the simulation is to be recorded, and to provide important simulation parameters such as the simulation time. By running the following python command, the simulation can be run.</p>
      <table-wrap id="d31e979" position="float">
        <label>Listing 3</label>
        <caption>
          <p>Run the cond.xml simulation.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0003"/>
      </table-wrap>
      <p>The probability density plots for both populations will be displayed in separate windows as the simulation progresses. The firing rate of the excitatory population can be plotted using the following commands. <xref ref-type="fig" rid="F2">Figure 2</xref> shows the probability density plots for both populations and average firing rate of population E.</p>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p>The display output of a running E-I population network simulation of conductance based neurons. <bold>(A)</bold> The probability density heat map (normalised to the maximum density value) of the excitatory population. <bold>(B)</bold> The probability density heat map of the inhibitory population. Brighter colours indicate a larger probability mass. The axes are unlabelled in the simulation windows as the software is agnostic to the underlying model. However, the membrane potential and conductance labels have been added for clarity. <bold>(C)</bold> The average firing rate of the excitatory population.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-g0002"/>
      </fig>
      <table-wrap id="d31e1002" position="float">
        <label>Listing 4</label>
        <caption>
          <p>Load the cond.xml simulation and plot the average firing rate of population E.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0004"/>
      </table-wrap>
      <p>Finally, the density function of each population can be plotted as a heat map for a given time in the simulation.</p>
      <table-wrap id="d31e1008" position="float">
        <label>Listing 5</label>
        <caption>
          <p>Plot the probability density of population I at time 0.12s.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0005"/>
      </table-wrap>
      <p>Later sections will show how the MIIND simulation can be imported into a user defined Python script so that input can be dynamically set during simulation and population activity can be captured for further processing.</p>
    </sec>
  </sec>
  <sec id="s2">
    <title>2. The MIIND Grid Algorithm</title>
    <p>MIIND allows the user to simulate populations of any 1D or 2D neuron model. Although much of MIIND's architecture is agnostic to the integration technique used to simulate each population, the system is primarily designed to make use of its novel population density techniques, grid algorithm and mesh algorithm. Both algorithms use a discretisation of the underlying neuron model's state space such that each discrete “cell,” which covers a small area of state space, is considered to hold a uniform distribution of probability mass. In both algorithms, MIIND performs three important steps for each iteration. First, probability mass is transferred from each cell to one or more other cells according to the dynamics of the underlying neuron model in the absence of any input. The probability mass is then spread across multiple other cells due to incoming random spikes. Finally, if the underlying neuron model has a threshold-reset mechanic, such as an integrate and fire model, probability mass which has passed the threshold is transferred to cells along the reset potential. As it is the most practically convenient method for the user, we will first introduce the grid algorithm. We will discuss its benefits and weaknesses, indicating where it may be appropriate to use the mesh algorithm instead.</p>
    <sec>
      <title>2.1. Generating the Grid and Transition Matrix</title>
      <p>To discretise the state space in the grid method, the user can specify the size and <italic>M</italic> × <italic>N</italic> resolution of a rectangular grid which results in <italic>MN</italic> identical rectangular cells, each of which will hold probability mass. In the grid algorithm, a transition matrix lists the proportion of mass which moves from each cell to (usually) adjacent cells in one time step due to the deterministic dynamics of the underlying neural model. To pre-calculate the transitions for each cell, MIIND first translates the vertices of every cell by integrating each point forward by one time step according to the dynamics of the underlying neuron model as shown in <xref ref-type="fig" rid="F3">Figure 3A</xref>. As the time step is small, a single Euler step is usually all that is required to avoid large errors (although other integration schemes can be used if required). Each transformed cell is no longer guaranteed to be a rectangle and is compared to the original non-transformed grid to ascertain which cells overlap with the newly generated quadrilateral. An overlap indicates that some proportion of neurons in the original cell will move to the overlapping cell after one time step. In order to calculate the overlap, the algorithm in Listing 6 is employed. This algorithm is also used in the geometric method of generating transition matrices for the mesh algorithm shown later.</p>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p>The state space of a neuron model (shown here as a vector field) is discretised into a regular grid of cells. <bold>(A)</bold> The transition matrix for solving the deterministic dynamics of the population is generated by applying a single time step of the underlying neuron model to each vertex of each cell in the grid and calculating the proportion by area to each overlapping cell. Once the vertices of a grid cell have been translated, the resulting polygon is recursively triangulated according to intersections with the original grid. Once complete, all triangles can be assigned to a cell and the area proportions can be summed. <bold>(B)</bold> For a single incoming spike (with constant efficacy), all cells are translated by the same amount and therefore have the same resulting transition which can be used to solve the Poisson master equation. In fact, the transition will always involve at most two target cells and the proportions can be calculated knowing only the grid cell width and the efficacy.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-g0003"/>
      </fig>
      <table-wrap id="d31e1040" position="float">
        <label>Listing 6</label>
        <caption>
          <p>A pseudo-code representation of the algorithm used to calculate the overlapping areas between transformed grid cells and the original grid (or for translated cells of a mesh). The proportion of the area of the original cell gives the proportion of probability mass to be moved in each transition.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0006"/>
      </table-wrap>
      <p>Though the pseudo-code algorithm is order <italic>N</italic><sup>2</sup>, there are many ways that the efficiency of the algorithm is improved in the implementation. The number of non-transformed cells checked for overlap can be limited to only those which lie underneath each given triangle. Furthermore, the outer loop is parallelisable. Finally, as the non-transformed cells are axis-aligned rectangles, the calculation to find edge intersections is trivial. <xref ref-type="fig" rid="F3">Figure 3A</xref> shows a fully translated and triangulated cell at the end of the algorithm. Once the transition matrix has been generated, it is stored in a file with the extension <italic>.tmat</italic>. Although the regular grid can be described with only four parameters (the width, height, X, and Y resolutions), to more closely match the behaviour of mesh algorithm, the vertices of the grid are stored in a <italic>.model</italic> file. To simulate a population using the grid algorithm, the <italic>.tmat</italic> and <italic>.model</italic> files must be generated and referenced in the XML simulation file.</p>
      <p>As demonstrated in the quick start guide (section 1.4), to generate a <italic>.model</italic> and <italic>.tmat</italic> file, the user must write a short Python script which defines the underlying neuron model and makes a call to the MIIND API to run the algorithm in listing 6. In the <italic>python</italic> directory of the MIIND source repository (see Supplementary Section 1 in the <xref ref-type="supplementary-material" rid="SM1">Supplementary Material</xref>), there are a number of examples of these short scripts. The script used to generate a grid for the Izhikevich simple model is listed in the <xref ref-type="supplementary-material" rid="SM1">Supplementary Section 9.1</xref>. The required definition of the neuron model function is similar to those used by many numerical integration libraries. The function takes a parameter, <italic>y</italic>, which represents a list which holds the two time dependent variables and a parameter, <italic>t</italic>, which is a placeholder for use in integration. The function must return the first time derivatives of each variable as a list in the same order as in <italic>y</italic>. Once the function has been written, a call to <italic>grid_generate.generate</italic> is made which takes the parameters listed in <xref rid="T1" ref-type="table">Table 1</xref>.</p>
      <table-wrap id="T1" position="float">
        <label>Table 1</label>
        <caption>
          <p>Parameters for the <italic>grid_generate.generate</italic> function.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th valign="top" align="left" rowspan="1" colspan="1">
                <bold>Parameter name</bold>
              </th>
              <th valign="top" align="left" rowspan="1" colspan="1">
                <bold>Notes</bold>
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>func</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The underlying neuron model function.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>timestep</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The desired time step for the neuron model</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>timescale</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">A scale factor for the timescale of the underlying neuron model to convert the time step into seconds.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>tolerance</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">An error tolerance for solving a single time step of the neuron model.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>basename</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The base name with which all output files will be named.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>threshold_v</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The spike threshold value for integrate and fire neuron models.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>reset_v</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The reset value for integrate and fire neuron models.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>reset_shift_h</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">A value for increasing the second variable during reset for integrate and fire neuron models with some adaptive shift or similar function.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>grid_v_min</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The minimum value for the first dimension of the grid (usually membrane potential).</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>grid_v_max</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The maximum value for the first dimension of the grid.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>grid_h_min</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The minimum value for the second dimension of the grid.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>grid_h_max</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The maximum value for the second dimension of the grid.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>grid_v_res</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The number of columns in the grid.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>grid_h_res</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The number of rows in the grid.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>efficacy_orientation</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The direction, “v” or “h,” in which incoming spikes cause an instantaneous change.</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>When the user runs the script, the required <italic>.model</italic> and <italic>.tmat</italic> files will be generated for use in a simulation. In the quick start guide, the conductance based neuron model requires that <italic>efficacy_orientation</italic> is set to “h” because incoming spikes cause an instantaneous change in the conductance variable instead of the membrane potential. By default, however, this parameter is set to “v.” When choosing values for the grid bounds (<italic>grid_v_min, grid_v_max, grid_h_min</italic>, and <italic>grid_h_max</italic>), the aim is to estimate where in state space the population density function might be non-zero during a simulation. In the conductance based neuron model, because of the threshold-reset mechanic, the <italic>grid_v_max</italic> parameter need only be slightly above the threshold to ensure that there is at least one column of cells on or above threshold to allow probability mass to be reset. The <italic>grid_v_min</italic> value should be below the resting potential and reset potential. However, we must also consider that the neurons could receive inhibitory spikes which would cause the neurons to hyperpolarise. <italic>grid_v_min</italic> should therefore be set to a value beyond the lowest membrane potential expected during the simulation. Similarly for the conductance variable, space should be provided for reasonable positive and negative values. If it is known beforehand that no inhibition will occur, however, then the state space bounds can be set tighter in order to improve the accuracy of the simulation using the same grid resolution (<italic>grid_v_res</italic> and <italic>grid_h_res</italic>). If, during the simulation, probability mass is pushed beyond the lower bounds of the grid, it will be pinned at those lower bounds which will produce incorrect behaviour and results. If the probability mass is pushed beyond the upper bounds, it will be wrapped around to the lower bounds which will also produce incorrect results. The choice of grid resolution is a balance between speed of simulation and accuracy. However, even very coarse grids can produce representative firing rates and behaviours. Typical grid resolutions range between 100 × 100 and 500 × 500. It can also be beneficial to experiment with different <italic>M</italic> and <italic>N</italic> values as the accuracy of each dimension can have unbalanced influence over the population level metrics.</p>
    </sec>
    <sec>
      <title>2.2. The Effect of Random Incoming Spikes</title>
      <p>The transition matrix in the <italic>.tmat</italic> file describes how probability mass moves to other cells due to the deterministic dynamics of the underlying neuron model. The transition matrix is sparse as probability mass is often only transferred to nearby cells. Solving the deterministic dynamics is therefore very efficient. The mesh algorithm is even faster and, as demonstrated later, is significantly quicker than direct simulation for this part of the algorithm. Another benefit to the modeler is that by rendering the grid with each cell coloured according to its mass, the resultant heat map gives an excellent visualisation of the state of the population as a whole at each time step of the simulation as shown in <xref ref-type="fig" rid="F2">Figure 2</xref>. This provides particularly useful insight into the sub-threshold behaviour of neurons in the population.</p>
      <p>The second step of the grid algorithm, which must be performed every iteration, is to solve the change in the probability density function due to random incoming spikes. It is assumed that a spike causes an instantaneous change in the state of a neuron, usually a step wise jump in membrane potential corresponding to a constant synaptic efficacy. In the conductance based neuron example, this jump is in the conductance. When considering each cell in the grid, a single incoming spike will cause some proportion of the probability mass to shift to at most, two other cells as shown in <xref ref-type="fig" rid="F3">Figure 3</xref>. Because all cells in the grid are equally distributed and the same size, the relative transition of probability mass caused by a single spike is the same for them all. A sparse transition matrix, <italic>M</italic>, can be generated from this single transition so that applying <italic>M</italic> to the probability density grid applies the transition to all cells. MIIND calculates a different <italic>M</italic> for each incoming connection to the population based on the user defined instantaneous jump, which we refer to as the efficacy. In the mesh algorithm, the relative transitions are different for each cell and so a transition matrix (similar to that of the <italic>.tmat</italic> file) is required to describe the effect of a single spike. As with many other population density techniques, MIIND assumes that incoming spikes are Poisson distributed, although it is possible to approximate other distributions. MIIND uses <italic>M</italic> to calculate the change to the probability density function, ρ, due solely to the non-deterministic dynamics as described by Equation 8.</p>
      <disp-formula id="E8">
        <label>(8)</label>
        <mml:math id="M10">
          <mml:mtable class="eqnarray" columnalign="left left left">
            <mml:mtr>
              <mml:mtd>
                <mml:mi>d</mml:mi>
                <mml:mi>ρ</mml:mi>
                <mml:mo>/</mml:mo>
                <mml:mi>d</mml:mi>
                <mml:mi>t</mml:mi>
                <mml:mo>=</mml:mo>
                <mml:mo>λ</mml:mo>
                <mml:mi>M</mml:mi>
                <mml:mi>ρ</mml:mi>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>λ is the incoming Poisson firing rate. The boost numeric library is used to integrate <italic>dρ</italic>/<italic>dt</italic>. The solution to this equation describes the spread of the probability density due to Poisson spikes. This “master process” step amounts to multiple applications of the transition matrix <italic>M</italic> and is where the majority of time is taken computationally. However, OpenMP is available in MIIND to parallelise the matrix multiplication. If multiple cores are available, the OpenMP implementation significantly improves performance of the master process step. More information covering this technique can be found in de Kamps (<xref rid="B8" ref-type="bibr">2013</xref>), De Kamps et al. (<xref rid="B10" ref-type="bibr">2019</xref>).</p>
    </sec>
    <sec>
      <title>2.3. Threshold-Reset Dynamics</title>
      <p>Many neuron models include a “threshold-reset” process such that neurons which pass a certain membrane potential value are shifted back to a defined reset potential to approximate repolarisation during an action potential. To facilitate this in MIIND, after each iteration, probability mass in cells which lie across the threshold potential is relocated to cells which lie across the reset potential according to a pre-calculated mapping. Often, a refractory period is used to hold neurons at the reset potential before allowing them to again receive incoming spikes. In MIIND this is implemented using a queue for each threshold cell as shown in <xref ref-type="fig" rid="F4">Figure 4</xref>. The queues are set to the length of the refractory period divided by the time step, rounded up to the nearest integer value. During each iteration, probability mass is shifted one position along the queue. A linear interpolation of the final two places in the queue is made and this value is passed to the mapped reset cell. The interpolation is required in case the refractory period is not an integer multiple of the time step. The total probability mass in the threshold cells each iteration is used to calculate the average population firing rate. For models which do not require threshold-reset dynamics, setting the threshold value to the maximal membrane potential of the grid, and the reset to the minimal membrane potential ensures that no resetting of probability mass will occur.</p>
      <fig id="F4" position="float">
        <label>Figure 4</label>
        <caption>
          <p>For each time step, probability mass in the cells which lie across the threshold (threshold cells) is pushed onto the beginning of the refractory queue. There is one queue per threshold cell. During each subsequent time step, the probability mass is shifted one place along the queue until it reaches the penultimate place. A proportion of the mass, calculated according to the modulo of the refractory time and the time step, is transferred to the appropriate reset cell. The remaining mass is shifted to the final place in the queue. During the next time step, that remaining mass is transferred to the reset cell.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-g0004"/>
      </fig>
    </sec>
    <sec>
      <title>2.4. How MIIND Facilitates Interacting Populations</title>
      <p>The grid algorithm describes how the behaviour of a single population is simulated. The MIIND software platform as a whole provides a way for many populations with possibly many different integration algorithms to interact in a network. The basic process of simulating a network is as follows. The user must write an XML file which describes the whole simulation. This includes defining the population nodes of the network and how they are connected; which integration technique each population uses (grid algorithm, mesh algorithm etc.); external inputs to the network; how the activity of each population will be recorded and displayed; the length and time step of the simulation. As shown in the quick start guide, the XML file can be passed as a parameter to the <italic>miind.run</italic> module in Python. When the simulation is run, a population network is instantiated and the simulation loop is started. For each iteration, the output activity of each population node is recorded. By default, the activity is assumed to be an average firing rate but other options are available such as average membrane potential. The outputs are passed as inputs to each population node according to the connectivity defined in the XML file. Each population is evolved forward by one time step and the simulation loop repeats until the simulation time is up. The Python front end, <italic>miind.miindio</italic>, provides the user with tools to analyse the output from the simulation. A custom <italic>run</italic> script can also be written by the user to perform further analysis and processing.</p>
      <p>The simplicity of the XML file means that a user can set up a large network of populations with very little effort. The model archive in the code repository holds a set of example simulations demonstrating the range of MIIND's functionality and includes an example which simulates the Potjans-Diesmann model of a cortical microcircuit (Potjans and Diesmann, <xref rid="B35" ref-type="bibr">2014</xref>), which is made up of eight populations of leaky integrate and fire neurons. <xref ref-type="fig" rid="F5">Figure 5</xref> shows a representation of the model with embedded density plots for each population.</p>
      <fig id="F5" position="float">
        <label>Figure 5</label>
        <caption>
          <p><bold>(A)</bold> A representation of the connectivity between populations in the Potjans-Diesmann microcircuit model. Each population shows the probability density at an early point in the simulation before all populations have reached a steady state. All populations are of leaky-integrate-and-fire neurons and so the density plots show membrane potential in the horizontal axis. The vertical axis has no meaning (probability mass values are the same at all points along the vertical). <bold>(B)</bold> The firing rate outputs from MIIND (crosses) in comparison to those from DiPDE for the same model (solid lines).</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-g0005"/>
      </fig>
    </sec>
    <sec>
      <title>2.5. Running MIIND Simulations</title>
      <p>The quick start guide demonstrated the simplest way to run a simulation given that the required <italic>.model, .tmat</italic>, and <italic>.XML</italic> files have been generated. The <italic>miind.run</italic> script imports the <italic>miind.miindsim</italic> Python extension module which can also be imported into any user written Python script. Section 6 details the functions which are exposed by <italic>miind.miindsim</italic> for use in a python script. The benefit of this method is that the outputs from populations can be recorded after each iteration and inputs can be dynamic allowing the python script to perform its own logic on the simulation based on the current state.</p>
      <p>There is also a command line interface (CLI) program provided by the Python module, <italic>miind.miindio</italic>. The CLI can be used for many simple work flow tasks such as generating models and displaying results. Each command which is available in the CLI, can also be called from the MIIND Python API, upon which the CLI is built. A full list of the available commands in the CLI is given in section 9.3 of the <xref ref-type="supplementary-material" rid="SM1">Supplementary Material</xref> and a worked example using common CLI commands is provided in section 7.</p>
    </sec>
    <sec>
      <title>2.6. When Not to Use the Grid Algorithm</title>
      <p>For many underlying neuron models, the grid algorithm will produce results showing good agreement with direct simulation to a greater or lesser extent depending on the resolution of the grid (see <xref ref-type="fig" rid="F6">Figure 6</xref>). However, for models such as exponential integrate and fire, a significantly higher grid resolution is required than might be expected because of the speed of the dynamics across the threshold (beyond which, neurons perform the action potential). When the input rate is high enough to generate tonic spiking in an exponential integrate and fire model, the rate of depolarisation of each neuron reduces as it approaches the threshold potential then once it is beyond the threshold, quickly increases producing a spike. Because the grid discretises the state space into regular cells, if cells are large due to a low resolution, only a small number of cells will span the threshold, as shown in <xref ref-type="fig" rid="F7">Figure 7A</xref>. When the transition matrix is applied each time step, probability mass is distributed uniformly across each cell. Probability mass can therefore artificially cross the threshold much faster than it should leading to a higher than expected average firing rate for the population. Using the grid algorithm for such models where the firing rate itself is dependent on sharp changes in the speed of the dynamics should be avoided if high accuracy is required. Other neuron models, like the busting Izhikevich simple model, also have sharp changes in speed when neurons transition from bursting to quiescent periods. However, the bursting firing rate is unaffected by these dynamics and the oscillation frequency is affected only negligibly due to the difference in timescales. The grid algorithm is therefore still appropriate in cases such as this. For exponential integrate and fire models, however, MIIND provides a second algorithm which can more accurately capture the deterministic dynamics: mesh algorithm.</p>
      <fig id="F6" position="float">
        <label>Figure 6</label>
        <caption>
          <p>Comparison of average firing rates from four simulations of a single population of conductance based neurons. The black solid and dashed lines indicate MIIND simulations using the grid algorithm with different grid resolutions. The red crosses show the average firing rate of a direct simulation of 10,000 neurons.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-g0006"/>
      </fig>
      <fig id="F7" position="float">
        <label>Figure 7</label>
        <caption>
          <p><bold>(A)</bold> In the grid algorithm, large cells cause probability mass to be distributed further than it should. This error is expressed most clearly in models where the average firing rate of the population is highly dependent on the amount of probability mass passing through an area of slow dynamics. <bold>(B)</bold> In the mesh algorithm, when cells become shear, probability mass which is pushed to the right due to incoming spikes also moves laterally (downwards) because it is spread evenly across each cell.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-g0007"/>
      </fig>
    </sec>
  </sec>
  <sec id="s3">
    <title>3. The MIIND Mesh Algorithm</title>
    <p>Instead of a regular grid to discretise the state space of the underlying neuron model, the mesh algorithm requires a two dimensional mesh which describes the dynamics of the neuron model itself in the absence of incoming spikes. A mesh is constructed from strips which follow the trajectories of neurons in state space (<xref ref-type="fig" rid="F8">Figure 8</xref>). The trajectories form so-called characteristic curves of the neuron model from which this method is inspired (de Kamps, <xref rid="B8" ref-type="bibr">2013</xref>; De Kamps et al., <xref rid="B10" ref-type="bibr">2019</xref>).</p>
    <fig id="F8" position="float">
      <label>Figure 8</label>
      <caption>
        <p><bold>(A)</bold> A vector field of the FitzHugh-Nagumo neuron model (FitzHugh, <xref rid="B13" ref-type="bibr">1961</xref>). Arrows show the direction of motion of states through the field according to the dynamics of the model. The red broken dashed nullcline indicates where the change in <italic>V</italic> is zero. The blue dashed nullcline indicates where the change in <italic>W</italic> is zero. The green solid line shows a potential path (trajectory) of a neuron in the state space. <bold>(B)</bold> A vector field for the adaptive exponential integrate and fire neuron model (Brette and Gerstner, <xref rid="B3" ref-type="bibr">2005</xref>). Two strips are shown which follow the dynamics of the model and approach the stationary point where the nullclines cross. A strip is constructed between two trajectories in state space. Each time step of the two trajectories is used to segment the strip into cells. Because the strips approach a stationary point, they get thinner as the trajectories converge to the same point and cells get closer together as the distance in state space travelled reduces per time step (neurons slow down as they approach a stationary point). Per time step, probability mass is shifted from one cell to the next along the strip. <bold>(C)</bold> The state space of the Izhikevich simple neuron model (Izhikevich, <xref rid="B21" ref-type="bibr">2003</xref>) which has been fully discretised into strips and cells.</p>
      </caption>
      <graphic xlink:href="fninf-15-614881-g0008"/>
    </fig>
    <p>These trajectories are computed as part of a one-time preprocessing step using an appropriate integration technique and time step. Strips will often approach or recede from nullclines and stationary points and their width may shrink or expand according to their proximity to such elements. Each strip is split into cells. Each cell represents how far along the strip neurons will move in a single time step. As with the width of the strips, cells will become more dense or more sparse as the dynamics slow down and speed up, respectively. The result of covering the state space with strips is a precomputed description of the model dynamics such that the state of a neuron in one cell of the mesh is guaranteed to be in the next cell along the strip after a single time step. Depending on the underlying neuron model, it can be difficult to get full coverage without cells becoming too small or shear. However, once built, the deterministic dynamics have effectively been “pre-solved” and baked into the mesh.</p>
    <p>As with the grid algorithm, when the simulation is running, each cell is associated with a probability mass value which represents the probability of finding a neuron from the population with a state in that cell. When a probability density function (PDF) is defined across the mesh, computing the change to the PDF due to the deterministic dynamics of the neurons is simply a matter of shifting each cell's probability mass value along its strip. In the C++ implementation, this requires no more than a pointer update and is therefore quicker than the grid algorithm for solving the deterministic dynamics as no transition matrix is applied to the cells.</p>
    <p>Mesh algorithm does, however, still require a transition matrix to implement the effect of incoming spikes on the PDF. This transition matrix describes how the state of neurons in each cell are translated in the event of a single incoming spike. Unlike the grid algorithm, cells are unevenly distributed across the mesh and are different sizes and shapes. What proportion of probability mass is transferred to which cells with a single incoming spike is, therefore, different for all cells. During simulation, the total change in the PDF is calculated by shifting probability mass one cell down each strip and using the transition matrix to solve the master equation every time step. The combined effect can be seen in <xref ref-type="fig" rid="F9">Figure 9</xref>. The method of solving the master equation is explained in detail in de Kamps (<xref rid="B8" ref-type="bibr">2013</xref>).</p>
    <fig id="F9" position="float">
      <label>Figure 9</label>
      <caption>
        <p>Heat plots for the probability density functions of two populations in MIIND. Brightness (more yellow) indicates a higher probability mass. Scales have been omitted as the underlying neuron models are arbitrary. <bold>(A)</bold> When the Poisson master equation is solved, probability mass is pushed to the right (higher membrane potential) in discrete steps. As time passes, the discrete steps are smoothed out due to the movement of mass according to the deterministic dynamics (following the strip). <bold>(B)</bold> A combination of mass travelling along strips and being spread across the state space by noisy input produces the behaviour of the population.</p>
      </caption>
      <graphic xlink:href="fninf-15-614881-g0009"/>
    </fig>
    <sec>
      <title>3.1. When Not to Use the Mesh Algorithm</title>
      <p>Just as with the grid algorithm, certain neuron models are better suited to an alternative algorithm. In the mesh algorithm, very little error is introduced for the deterministic dynamics. Probability mass flows down each strip as it would without the discretisation and error is limited only to the size of the cells. When the master equation is solved, however, probability mass can spread to parts of state space which would see less or no mass. <xref ref-type="fig" rid="F7">Figure 7B</xref> demonstrates how in the mesh algorithm, as probability mass is pushed horizontally, very shear cells can allow mass to be incorrectly transferred vertically as well. In the grid algorithm, error is introduced in the opposite way. Solving the master equation pushes probability mass along horizontal rows of the grid and error is limited to the width of the row. The grid algorithm is preferable over the mesh algorithm for populations of neurons with one fast variable and one slow variable which can produce very shear cells in a mesh, e.g., in the Fitzhugh-Nagumo model (De Kamps et al., <xref rid="B10" ref-type="bibr">2019</xref>). In both algorithms, the error can be reduced by increasing the density of cells (by increasing the resolution of the grid, or by reducing the timestep and strip width of the mesh). However, better efficiency is achieved by using the appropriate algorithm.</p>
    </sec>
    <sec>
      <title>3.2. Building a Mesh for the Mesh Algorithm</title>
      <p>Before a simulation can be run for a population which uses the mesh algorithm, the pre-calculation steps of generating a mesh and transition matrices must be performed. <xref ref-type="fig" rid="F10">Figure 10</xref> shows the full pre-processing pipeline for mesh algorithm. The mesh is a collection of strips made up of quadrilateral cells. As mentioned earlier, probability mass moves along a strip from one cell to the next each time step which describes the deterministic dynamics of the model. Defining the cells and strips of a 2D mesh is not generally a fully automated process and the points of each quadrilateral must be defined by the mesh developer and stored in a .<italic>mesh</italic> file. When creating the mesh, the aim is to cover as much of the state space as possible without allowing cells to get too small or misshapen. An example of a full mesh generation script for the Izhikevich simple neuron model (Izhikevich, <xref rid="B21" ref-type="bibr">2003</xref>) is available in Supplementary Section 9.1 of the <xref ref-type="supplementary-material" rid="SM1">Supplementary Material</xref>. MIIND provides <italic>miind.miind_api.LifMeshGenerator, miind.miind_api.QifMeshGenerator</italic>, and <italic>miind.miind_api.EifMeshGenerator</italic> scripts to automatically build the 1D leaky integrate and fire, quadratic integrate and fire, and exponential integrate and fire neuron meshes, respectively. They can be called from the CLI. The scripts generate the three output files which any mesh generator script must produce: a <italic>.mesh</italic> file, a <italic>.stat</italic> file which defines extra cells in the mesh to hold probability mass that has settled at a stationary point, and a <italic>.rev</italic> file which defines a “reversal mapping” indicating how probability mass is transferred from strips in the mesh to the stationary cells. More information on <italic>.mesh, .stat</italic>, and <italic>.rev</italic> files is provided in the <xref ref-type="supplementary-material" rid="SM1">Supplementary Section 6</xref>.</p>
      <fig id="F10" position="float">
        <label>Figure 10</label>
        <caption>
          <p>The MIIND processes and generated files required at each stage of pre-processing for the mesh algorithm. The shaded green rectangles represent automated processes run <italic>via</italic> the MIIND CLI.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-g0010"/>
      </fig>
      <p>Once the <italic>.mesh, .stat</italic>, and <italic>.rev</italic> files have been generated by the user or by one of the automated 1D scripts, the Python command line interface, <italic>miind.miindio</italic>, provides commands to convert the three files into a single <italic>.model</italic> file and generate transition matrices stored in <italic>.mat</italic> files. The model file is what will be referenced and read by MIIND to load a mesh for a simulation. To generate this file, use the CLI command, <bold>generate-model</bold>. The command parameters are shown in <xref rid="T2" ref-type="table">Table 2</xref>. All input files must have the same base name, for example: <italic>lif.mesh, lif.stat</italic>, and <italic>lif.rev</italic>. If the command runs successfully, a new file will be created: <italic>basename.model</italic>. A number of pre-generated models are available in the <italic>examples</italic> directory of the MIIND repository to be used “out of the box” including the adaptive exponential integrate and fire and conductance based neuron models.</p>
      <table-wrap id="T2" position="float">
        <label>Table 2</label>
        <caption>
          <p>Parameters for the <bold>generate-model</bold> command in the CLI.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th valign="top" align="left" rowspan="1" colspan="1">
                <bold>Parameter name</bold>
              </th>
              <th valign="top" align="left" rowspan="1" colspan="1">
                <bold>Notes</bold>
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>basename</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The shared name of the <italic>.mesh, .stat, .rev</italic> and generated <italic>.model</italic> files.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>reset</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The value (usually representing membrane potential) which probability mass will be transferred to having passed the threshold.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>threshold</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The value (usually representing membrane potential) beyond which probability mass will be transferred to the reset value.</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <table-wrap id="d31e1515" position="float">
        <label>Listing 7</label>
        <caption>
          <p>Generate a Model in the CLI</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0007"/>
      </table-wrap>
      <p>The generated <italic>.model</italic> file contains the mesh vertices, some summary information such as the time step used to generate the mesh and the threshold and reset values, and a mapping of threshold cells to reset cells.</p>
      <p>In the mesh algorithm, transition matrices are used to solve the Poisson master equation which describes the movement of probability mass due to incoming random spikes. In the mesh algorithm, one transition matrix is required for each post synaptic efficacy that will be needed in the simulation. So if a population is going to receive spikes which cause jumps of 0.1 and 0.5 mV, two transition matrices are required. It is demonstrated later how the efficacy can be made dependent on the membrane potential or other variables. Each transition matrix is stored in a <italic>.mat</italic> file and contains a list of source cells, target cells, and proportions of probability mass to be transferred to each. For a given cell in the mesh, neurons with a state inside that cell which receive a single external spike will shift their location in state space by the value of the efficacy. Neurons from the same cell could therefore end up in many other different cells, though often ones which are nearby. It is assumed that neurons are distributed uniformly across the source cell. Therefore, the proportion of neurons which end up in each of the other cells can be calculated. MIIND performs this calculation in two ways, the choice for which is given to the user.</p>
      <p>The first method is to use a Monte Carlo approach such that a number of points are randomly placed in the source cell then translated according to the efficacy. A search takes place to find which cells the points were translated to and the proportions are calculated from the number of points in each. For many meshes, a surprisingly small number of points, around 10, is required in each cell to get a good approximation for the transition matrix and the process is therefore quite efficient. As shown in <xref ref-type="fig" rid="F10">Figure 10</xref>, an additional process is required when generating transition matrices using Monte Carlo which includes two further intermediate files, <italic>.fid</italic> and <italic>.lost</italic>. All points must be accounted for when performing the search and in cases where points are translated outside of the mesh, an exhaustive search must be made to find the closest cell. The <bold>lost</bold> command allows the user to speed up this process which is covered in detail in Supplementary Section 6.1 of the <xref ref-type="supplementary-material" rid="SM1">Supplementary Material</xref>.</p>
      <p>The second method translates the actual vertices of each cell according to the efficacy and calculates the exact overlapping area with other cells. The method by which this is achieved is the same as that used to generate the transition matrix of the grid algorithm, described in section 2.1. This method provides much higher accuracy than Monte Carlo but is one order of magnitude slower (it takes a similar amount of time to perform Monte Carlo with 100 points per cell). For some meshes, it is crucial to include very small transitions between cells to properly capture the dynamics which justifies the need for the slower method. It also benefits from requiring no additional user input in contrast to the Monte Carlo method.</p>
      <p>In <italic>miind.miindio</italic>, the command <bold>generate-matrix</bold> can be used to automatically generate each <italic>.mat</italic> file. In order to work, there must be a <italic>basename.model</italic> file in the working directory. The <bold>generate-matrix</bold> command takes six parameters which are described in <xref rid="T3" ref-type="table">Table 3</xref>. Listing 8 shows an example of the <bold>generate-matrix</bold> command. If successful, two files are generated: <italic>basename</italic>.<italic>mat</italic> and <italic>basename</italic>.<italic>lost</italic>.</p>
      <table-wrap id="T3" position="float">
        <label>Table 3</label>
        <caption>
          <p>Parameters for the <bold>generate-matrix</bold> command in the CLI.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th valign="top" align="left" rowspan="1" colspan="1">
                <bold>Parameter name</bold>
              </th>
              <th valign="top" align="left" rowspan="1" colspan="1">
                <bold>Notes</bold>
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>basename</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The shared name of the <italic>.model, .fid</italic> (if required), and generated <italic>.mat</italic> files.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>v_efficacy</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The efficacy value in the <italic>v</italic> (membrane potential) direction. If the parameter <italic>h_efficacy</italic> is used, this should be zero.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>points / precision</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">For Monte Carlo, this gives the number of points per cell to use for approximating the transition matrix. For the geometric method, transitions are stored in the <italic>.mat</italic> file to the nearest <inline-formula><mml:math id="M12"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>c</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math></inline-formula></td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>h_efficacy</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The efficacy value in the <italic>h</italic> direction. If the parameter <italic>v_efficacy</italic> is used, this should be zero.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>reset-shift</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The shift in the <italic>h</italic> direction which neurons take when being reset.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>use_geometric</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">A boolean flag set to “true” if the geometric method is used and “false” for Monte Carlo.</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <table-wrap id="d31e1646" position="float">
        <label>Listing 8</label>
        <caption>
          <p>The <italic>miind.miindio</italic> command to generate a matrix using the adex.model file with an efficacy of 0.1 in <italic>v</italic> and a jump of 5.0 in <italic>w</italic> when a neuron spikes. The Monte Carlo method has been chosen with 10 points per cell.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0008"/>
      </table-wrap>
      <p>Once <bold>generate-matrix</bold> has completed, a <italic>.mat</italic> file will have been generated and the <italic>.model</italic> file will have been amended to include a <italic>&lt;Reset Mapping&gt;</italic> section. Similar to the reversal mapping in the <italic>.rev</italic> file, the reset mapping describes movement of probability mass from the cells which lie across the threshold potential to cells which lie across the reset potential. If the threshold or reset values are changed but no other change is made to the mesh, it can be helpful to re-run the mapping calculation without having to completely re-calculate the transition matrix. <italic>miind.miindio</italic> provides the command <bold>regenerate-reset</bold> which takes the base name and any new reset shift value (0 if not required) as parameters. This will quickly replace the reset mapping in the <italic>.model</italic> file.</p>
      <table-wrap id="d31e1677" position="float">
        <label>Listing 9</label>
        <caption>
          <p>The user may change the <italic>&lt;Threshold&gt;</italic> and <italic>&lt;Reset&gt;</italic> values in the <italic>.model</italic> file (or re-call <bold>generate-model</bold> with different threshold and reset values) then update the existing Reset Mapping. In this case, the adex.model was updated with a reset <italic>w</italic> shift value of 7.0.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0009"/>
      </table-wrap>
      <p>With all required files generated, a simulation using the mesh algorithm can now be run in MIIND.</p>
    </sec>
    <sec>
      <title>3.3. Jump Files</title>
      <p>In some models, it is helpful to be able to set the efficacy as a function of the state. For example, to approximate adaptive behaviour where the post synaptic efficacy lowers as the membrane potential increases. Jump files have been used in MIIND to simulate the Tsodyks-Markram (Tsodyks and Markram, <xref rid="B39" ref-type="bibr">1997</xref>) synapse model as described in De Kamps et al. (<xref rid="B10" ref-type="bibr">2019</xref>). In the model, one variable/dimension is required to represent the membrane potential, <italic>V</italic>, of the post-synaptic neuron and the second to represent the synaptic contribution, <italic>G</italic>. <italic>G</italic> and <italic>V</italic> are then used to derive the post-synaptic potential caused by an incoming spike. Before generating the transition matrix, each cell can be assigned its own efficacy for which the transitions will be calculated. During generation, Monte Carlo points will be translated according to that value instead of a constant across the entire mesh. When calling the <bold>generate-matrix</bold> command, a separate set of three parameters is required to use this feature. The base name of the model file, the number of Monte Carlo points per cell, and a reference to a <italic>.jump</italic> file which stores the efficacy values for each cell in the mesh.</p>
      <table-wrap id="d31e1717" position="float">
        <label>Listing 10</label>
        <caption>
          <p>Generate a transition matrix with a jump file in the CLI</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0010"/>
      </table-wrap>
      <p>As with the files required to build the mesh, the jump file must be user generated as the efficacy values may be non-linear and involve one or both of the dimensions of the model. The format of a jump file is shown in listing 11. The <italic>&lt;Efficacy&gt;</italic> element of the XML file gives an efficacy value for both dimensions of the model and is how the resulting transition matrix will be referenced in the simulation. The <italic>&lt;Translations&gt;</italic> element lists the efficacy in both dimensions for each cell in the mesh.</p>
      <table-wrap id="d31e1728" position="float">
        <label>Listing 11</label>
        <caption>
          <p>The format of the jump file. Each line in the <italic>&lt;Translations&gt;</italic> block gives the strip,cell coordinates of the cell followed by the <italic>h</italic> efficacy then the <italic>v</italic> efficacy. The <italic>&lt;Efficacy&gt;</italic> element gives a reference efficacy which will be used to reference the transition matrix built with this jump file. It must therefore be unique among jump files used for the same model.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0011"/>
      </table-wrap>
      <p>After calling <bold>generate-matrix</bold>, as before, the <italic>.mat</italic> file will be created with the quoted values in the <italic>&lt;Efficacy&gt;</italic> element of the jump file. As with the vanilla Monte Carlo generation, the additional process of tracking lost points must be performed.</p>
    </sec>
  </sec>
  <sec id="s4">
    <title>4. Writing the XML File</title>
    <p>MIIND provides an intuitive XML style language to describe a simulation and its parameters. This includes descriptions of populations, neuron models, integration techniques, and connectivity as well as general parameters such as time step and duration. The XML file is split into sections which are sub elements of the XML root node, <italic>&lt;Simulation&gt;</italic>. They are Algorithms, Nodes, Connections, Reporting, and SimulationRunParameter. These elements make up the major components of a MIIND simulation.</p>
    <sec>
      <title>4.1. Algorithms</title>
      <p>An <italic>&lt;Algorithm&gt;</italic> in the XML code describes the simulation method for a population in the network. The nodes of the network represent separate instances of these algorithm elements. Therefore, many nodes can use the same algorithm. Each algorithm has different parameters or supporting files but as a minimum, all algorithms must declare a type and a name. Each algorithm is also implicitly associated with a “weight type.” All algorithms used in a single simulation must be compatible with the weight type as it describes the way that populations interact. The <italic>&lt;WeightType&gt;</italic> element of the XML file can take the values, “double,” “DelayedConnection,” or “CustomConnectionParameters.” Which value the weight type element takes influences which algorithms are available in the simulation and how the connections between populations will be defined. The following sections cover all Algorithm types currently supported in MIIND. <xref rid="T4" ref-type="table">Table 4</xref> lists these algorithms and their compatible weight types.</p>
      <table-wrap id="T4" position="float">
        <label>Table 4</label>
        <caption>
          <p>Compatible weight types for each algorithm type defined in the simulation XML file.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th valign="top" align="left" rowspan="1" colspan="1">
                <bold>Algorithm name</bold>
              </th>
              <th valign="top" align="center" rowspan="1" colspan="1">
                <bold>Double</bold>
              </th>
              <th valign="top" align="center" rowspan="1" colspan="1">
                <bold>DelayedConnection</bold>
              </th>
              <th valign="top" align="center" rowspan="1" colspan="1">
                <bold>CustomConnectionParameters</bold>
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>RateAlgorithm</italic>
              </td>
              <td valign="top" align="center" rowspan="1" colspan="1">✓</td>
              <td valign="top" align="center" rowspan="1" colspan="1">✓</td>
              <td valign="top" align="center" rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>MeshAlgorithm</italic>
              </td>
              <td rowspan="1" colspan="1"/>
              <td valign="top" align="center" rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>MeshAlgorithmCustom</italic>
              </td>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td valign="top" align="center" rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>GridAlgorithm</italic>
              </td>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td valign="top" align="center" rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>GridJumpAlgorithm</italic>
              </td>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td valign="top" align="center" rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>OUAlgorithm</italic>
              </td>
              <td rowspan="1" colspan="1"/>
              <td valign="top" align="center" rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>WilsonCowanAlgorithm</italic>
              </td>
              <td valign="top" align="center" rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>RateFunctor</italic>
              </td>
              <td valign="top" align="center" rowspan="1" colspan="1">✓</td>
              <td valign="top" align="center" rowspan="1" colspan="1">✓</td>
              <td valign="top" align="center" rowspan="1" colspan="1">✓</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <sec>
        <title>4.1.1. RateAlgorithm</title>
        <p>RateAlgorithm is used to supply a Poisson distributed input (with a given average firing rate) to other nodes in the simulation. It is typically used for simulating external input. The <italic>&lt;rate&gt;</italic> sub-element is used to define the activity value which is usually a firing rate.</p>
        <table-wrap id="d31e1849" position="float">
          <label>Listing 12</label>
          <caption>
            <p>A RateAlgorithm definition with a constant rate of 100 Hz.</p>
          </caption>
          <graphic xlink:href="fninf-15-614881-i0012"/>
        </table-wrap>
      </sec>
      <sec>
        <title>4.1.2. MeshAlgorithm and MeshAlgorithmCustom</title>
        <p>In section 3.2, we saw how to generate <italic>.model</italic> and <italic>.mat</italic> files. These are required to simulate a population using the mesh algorithm. Algorithm type=MeshAlgorithm tells MIIND to use this technique. The model file is referenced as an attribute to the Algorithm definition. The <italic>TimeStep</italic> child element must match that which was used to generate the mesh. This value is quoted in the model file. As many <italic>MatrixFile</italic> elements can be declared as are required for the simulation, each with an associated .mat file reference.</p>
        <table-wrap id="d31e1866" position="float">
          <label>Listing 13</label>
          <caption>
            <p>A MeshAlgorithm definition with two matrix files.</p>
          </caption>
          <graphic xlink:href="fninf-15-614881-i0013"/>
        </table-wrap>
        <p>MeshAlgorithm provides two further optional attributes in addition to <italic>modelfile</italic>. The first is <italic>tau_refractive</italic> which enables a refractory period and the second is <italic>ratemethod</italic> which takes the value “AvgV” if the activity of the population is to be represented by the average membrane potential. Any other value for <italic>ratemethod</italic> will set the activity to the default average firing rate. The activity value is what will be passed to other populations in the network as well as what will be recorded as the activity for any populations using this algorithm.</p>
        <p>When the weight type is set to CustomConnectionParameters, the type of this algorithm definition should be changed to MeshAlgorithmCustom. No other changes to the definition are required.</p>
      </sec>
      <sec>
        <title>4.1.3. GridAlgorithm and GridJumpAlgorithm</title>
        <p>For populations which use the grid algorithm, the following listing is required. Similar to the MeshAlgorithm, the model file is referenced as an attribute. However, there are no matrix files required as the transition matrix for solving the Poisson master equation is calculated at run time. The transition matrix for the deterministic dynamics, stored in the <italic>.tmat</italic> file, is referenced as an attribute as well. Attributes for <italic>tau_refractive</italic> and <italic>ratemethod</italic> are also available with the same effects as for MeshAlgorithm.</p>
        <table-wrap id="d31e1892" position="float">
          <label>Listing 14</label>
          <caption>
            <p>A GridAlgorithm definition using the AvgV (membrane potential) rate method.</p>
          </caption>
          <graphic xlink:href="fninf-15-614881-i0014"/>
        </table-wrap>
        <p>GridAlgorithm also provides additional attributes <italic>start_v</italic> and <italic>start_w</italic> which allows the user to set the starting state of all neurons in the population which creates an initial probability mass of 1.0 in the corresponding grid cell at the start of the simulation.</p>
        <p>GridJumpAlgorithm provides a similar functionality as MeshAlgorithm when the transition matrix is generated using a jump file. That is, the efficacy applied to each cell when calculating transitions differs from cell to cell. In GridJumpAlgorithm, the efficacy at each cell is multiplied by the distance between the central <italic>v</italic> value of the cell and a user defined “stationary” value. The initial efficacy and the stationary values are defined by the user in the XML <italic>&lt;Connection&gt;</italic> elements. GridJumpAlgorithm is useful for approximating populations of neurons with a voltage dependent synapse.</p>
        <table-wrap id="d31e1909" position="float">
          <label>Listing 15</label>
          <caption>
            <p>A GridJumpAlgorithm definition and corresponding Connection with a “stationary” attribute. The efficacy at each grid cell will equal the original efficacy value (−0.05) multiplied by the difference between each cell's central v value and the given stationary value (−65)</p>
          </caption>
          <graphic xlink:href="fninf-15-614881-i0015"/>
        </table-wrap>
      </sec>
      <sec>
        <title>4.1.4. Additional Algorithms</title>
        <p>MIIND also provides OUAlgorithm and WilsonCowanAlgorithm. The OUAlgorithm generates an Ornstein–Uhlenbeck process (Uhlenbeck and Ornstein, <xref rid="B40" ref-type="bibr">1930</xref>) for simulating a population of LIF neurons. The WilsonCowanAlgorithm implements the Wilson-Cowan model for simulating population activity (Wilson and Cowan, <xref rid="B41" ref-type="bibr">1972</xref>). Examples of these algorithms are provided in the examples directory of the MIIND repository (<italic>examples/twopop</italic> and <italic>examples/model_archive/WilsonCowan</italic>).</p>
        <p>One final algorithm, RateFunctor, behaves similarly to RateAlgorithm. However, instead of a rate value, the child value defines the activity using a C++ expression in terms of variable, <italic>t</italic>, representing the simulation time.</p>
        <table-wrap id="d31e1932" position="float">
          <label>Listing 16</label>
          <caption>
            <p>A RateFunctor algorithm definition in which the firing rate linearly increases to 100 Hz over 0.1 s and remains at 100 Hz thereafter.</p>
          </caption>
          <graphic xlink:href="fninf-15-614881-i0016"/>
        </table-wrap>
        <p>A CDATA expression is not permitted when using MIIND in Python or when calling <italic>miind.run</italic>. However, RateFunctor can still be used with a constant expression (although this has no benefit beyond what RateAlgorithm already provides). CDATA should only be used when MIIND is built from source (not installed using pip) and the MIIND API is used to generate C++ code from an XML file.</p>
      </sec>
    </sec>
    <sec>
      <title>4.2. Nodes</title>
      <p>The <italic>&lt;Node&gt;</italic> block lists instances of the Algorithms defined above. Each node represents a single population in the network. To create a node, the user must provide the name of one of the algorithms defined in the algorithm block which will be instantiated. A name must also be given to uniquely identify this node. The type describes the population as wholey inhibitory, excitatory, or neutral. The type dictates the sign of the post synaptic efficacy caused by spikes from this population. Setting the type to neutral allows the population to produce both excitatory and inhibitory (positive and negative) synaptic efficacies. For most algorithms, the valid types for a node are <italic>EXCITATORY, INHIBITORY</italic>, and <italic>NEUTRAL</italic>. <italic>EXCITATORY_DIRECT</italic> and <italic>INHIBITORY_DIRECT</italic> are also available but mean the same as <italic>EXCITATORY</italic> and <italic>INHIBITORY</italic>, respectively.</p>
      <table-wrap id="d31e1960" position="float">
        <label>Listing 17</label>
        <caption>
          <p>Three nodes defined in the Nodes section using the types <italic>NEUTRAL, INHIBITORY</italic>, and <italic>EXCITATORY</italic>, respectively.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0017"/>
      </table-wrap>
      <p>Many nodes can reference the same algorithm to use the same population model but they will behave independently based on their individual inputs.</p>
    </sec>
    <sec>
      <title>4.3. Connections</title>
      <p>The connections between the nodes are defined in the <italic>&lt;Connections&gt;</italic> sub-element. Each connection can be thought of as a conduit which passes the output activity from the “In” population node to the “Out” population node. The format used to define the connections is dependent on the choice of <italic>WeightType</italic>. When the type is <italic>double</italic>, connections require a single value which represents the connection weight. This will be multiplied by the output activity of the In population and passed to the Out population. The sign of the weight must match the In node's type definition (<italic>EXCITATORY, INHIBITORY, NEUTRAL</italic>).</p>
      <table-wrap id="d31e1983" position="float">
        <label>Listing 18</label>
        <caption>
          <p>A simple double WeightType Connection with a single rate multiplier.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0018"/>
      </table-wrap>
      <p>Many algorithms use the <italic>DelayedConnection</italic> weight type which requires three values to define each connection. The first is the number of incoming connections each neuron in the Out population receives from the In population. This number is effectively a weight and is multiplied by the output activity of the In population. For example, if the output firing rate of an In population is 10 Hz and the number of incoming connections is set to 10, the effective average incoming spike rate to each neuron in the Out population will be 100 Hz. The second value is the post synaptic efficacy whose sign must match the type of the In population. If the Out population is an instance of MeshAlgorithm, the efficacy must also match one of the provided <italic>.mat</italic> files. The third value is the connection delay in seconds. The delay is implemented in the same way as the refractory period in the mesh and grid algorithms. The output activity of the In population is placed at the beginning of the queue and shifted toward the end of the queue over subsequent iterations. The input to the Out population is taken as the linear interpolation between the final two values in the queue.</p>
      <table-wrap id="d31e1994" position="float">
        <label>Listing 19</label>
        <caption>
          <p>A DelayedConnection with number of connections = 10, efficacy = 0.1, and delay of 1ms.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0019"/>
      </table-wrap>
      <p>With the addition of GridAlgorithm, there was a need for a more flexible connection type which would allow custom parameters to be applied to each connection. When using the <italic>CustomConnectionParameters</italic> weight type, the key-value attributes of the connections are passed as strings to the C++ implementation. By default, custom connections require the same three values as <italic>DelayedConnection</italic>: <italic>num_connections, efficacy</italic>, and <italic>delay</italic>. <italic>CustomConnectionParameters</italic> can therefore be used with mesh algorithm nodes as well as grid algorithm nodes although MeshAlgorithm definitions must have the type attribute set to MeshAlgorithmCustom instead.</p>
      <table-wrap id="d31e2011" position="float">
        <label>Listing 20</label>
        <caption>
          <p>A MeshAlgorithmCustom definition for use with WeightType=CustomConnectionParameters and a Connection using the num_connections, efficacy, and delay attributes.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0020"/>
      </table-wrap>
      <p>Other combinations of attributes for connections using CustomConnectionParameters are available for use with specific specialisations of the grid algorithm which are discussed in Supplementary Section 4 of the <xref ref-type="supplementary-material" rid="SM1">Supplementary Material</xref>. Any number of attributes are permitted but they will only be used if there is an algorithm specialisation implemented in the MIIND code base.</p>
    </sec>
    <sec>
      <title>4.4. SimulationRunParameter</title>
      <p>The <italic>&lt;SimulationRunParameter&gt;</italic> block contains parameter settings for the simulation as a whole. The sub-elements listed in <xref rid="T5" ref-type="table">Table 5</xref> are required for a full definition. Although most of the sub-elements are self explanatory, <italic>t_step</italic> has the limitation that it must match or be an integer multiple of all time steps defined by any MeshAlgorithm and GridAlgorithm instances. <italic>master_steps</italic> is used only for the GPGPU implementation of MIIND (section 5). It allows the user to set the number of Euler iterations per time step to solve the master equation. By default, the value is 10. However, to improve accuracy or to avoid blow-up in the case where the time step is too large or the local dynamics are unstable, <italic>master_steps</italic> should be increased.</p>
      <table-wrap id="T5" position="float">
        <label>Table 5</label>
        <caption>
          <p>The required sub-elements for the <italic>SimulationRunParameter</italic> section of the XML simulation file.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th valign="top" align="left" rowspan="1" colspan="1">
                <bold>Element</bold>
              </th>
              <th valign="top" align="left" rowspan="1" colspan="1">
                <bold>Notes</bold>
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>SimulationName</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The name of the simulation.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>t_end</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The simulation end time.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>t_step</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The time step of the simulation.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>name_log</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">A file name for logging. The file is stored in the output directory of the simulation.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>master_steps</italic>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">The number of Euler iterations per time step used to solve the mater equation in the GPGPU implementation.</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
    <sec>
      <title>4.5. Reporting</title>
      <p>The <italic>&lt;Reporting&gt;</italic> block is used to describe how output is displayed and recorded from the simulation. There are three ways to record output from the simulation: Density, Rate, and Display. The <italic>&lt;Rate&gt;</italic> element takes the node <italic>name</italic> and <italic>t_interval</italic> as attributes and creates a single file in the output directory. <italic>t_interval</italic> must be greater than or equal to the simulation time step. At each <italic>t_interval</italic> of the simulation, the output activity of the population is recorded on a new line of the generated file. Although the element is called “Rate,” if average membrane potential has been chosen as the activity of this population, this is what will be recorded here. <italic>&lt;Density&gt;</italic> is used to record the full probability density of the given population node. As density is only relevant for the population density technique, it can only be recorded from nodes which instantiate the mesh or grid algorithm types. The attributes are the node <italic>name, t_start, t_end</italic>, and <italic>t_interval</italic> which define the simulation times to start and end recording the density at the given interval. A file which holds the probability mass values for each cell in the mesh or grid will be created in the output directory for each <italic>t_interval</italic> between <italic>t_start</italic> and <italic>t_end</italic>. Finally, the <italic>&lt;Display&gt;</italic> element can be used to observe the evolution of the probability density function as the simulation is running. If a <italic>Display</italic> element is added in the XML file for a specific node, when the simulation is run, a graphical window will open and display the probability density for each time step. Again, display is only applicable to algorithms involving densities. Enabling the display can significantly slow the simulation down. However, it is useful for debugging the simulation and furthermore, each displayed frame is stored in the output directory so that a movie can be made of the node's behaviour. How to generate this movie is discussed later in section 7.1.</p>
      <table-wrap id="d31e2110" position="float">
        <label>Listing 21</label>
        <caption>
          <p>A set of reporting definitions to record the probability densities and rates of two populations, S and D. The densities will also be displayed during simulation.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0021"/>
      </table-wrap>
    </sec>
    <sec>
      <title>4.6. Variables</title>
      <p>The <italic>&lt;Simulation&gt;</italic> element can contain multiple <italic>&lt;Variable&gt;</italic> sub-elements each with a unique name and value. Variables are provided for the convenience of the user and can replace any values in the XML file. For example, a variable named <italic>TIME_END</italic> can be defined to replace the value in the <italic>t_end</italic> element of the <italic>SimulationRunParameter</italic> block. When the simulation is run, the value of <italic>t_end</italic> will be replaced with the default value provided in the Variable definition. Using variables makes it easy to perform parameter sweeps where the same simulation is run multiple times and only the variable's value is changed. How parameter sweeps are performed is covered in the <xref ref-type="supplementary-material" rid="SM1">Supplementary Section 8</xref>. All values in a MIIND XML script can be set with a variable name. The type of the Variable is implicit and an error will be thrown if, say, a non-numerical value is passed to the tau_refractive attribute of a MeshAlgorithm object.</p>
      <table-wrap id="d31e2135" position="float">
        <label>Listing 22</label>
        <caption>
          <p>A Variable definition. TIME_END has a default value of 18.0 and is used in the <italic>t_end</italic> parameter definition.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0022"/>
      </table-wrap>
    </sec>
  </sec>
  <sec id="s5">
    <title>5. MIIND on the GPU</title>
    <p>The population density techniques of the mesh and grid algorithms rely on multiple applications of the transition matrix which can be performed on each cell in parallel. This makes the algorithms prime candidates for parallelisation on the graphics card. In the CPU versions, the probability mass is stored in separate arrays, one for each population/node in the simulation. For the GPGPU version, these are concatenated into one large probability mass vector so all cells in all populations can be processed in parallel. From the user's perspective, switching between CPU and GPU implementations is trivial. In the XML file for a simulation which uses MeshAlgorithm or GridAlgoirithm, to switch to the vectorised GPU version, the Algorithm types must be changed to MeshAlgorithmGroup and GridAlgorithmGroup. All other attributes remain the same. Only MeshAlgorithmGroup, GridAlgorithmGroup, and RateFunctor/RateAlgorithm types can be used for a vectorised simulation. When running a MIIND simulation containing a group algorithm from a Python script, instead of importing <italic>miind.miindsim, miind.miindsimv</italic> should be used. The Python module <italic>miind.run</italic> is agnostic to the use of group algorithms so can be used as shown previously.</p>
    <table-wrap id="d31e2151" position="float">
      <label>Listing 23</label>
      <caption>
        <p>A MeshAlgorithmGroup definition is identical to a MeshAlgorithm definition except for the type.</p>
      </caption>
      <graphic xlink:href="fninf-15-614881-i0023"/>
    </table-wrap>
    <p>The GPGPU implementation uses the Euler method to solve the master process during each iteration. It is, therefore, susceptible to blow-up if the time step is large or if the local dynamics of the model are stiff. The user has the option to set the number of euler steps taken each iteration using the <italic>master_steps</italic> value of the SimulationRunParameter block in the XML file. A higher value reduces the likelihood of blow-up but increases the simulation time.</p>
    <p>In order to run the vectorised simulations, MIIND must be running on a CUDA enabled machine and have CUDA enabled in the installation (CUDA is supported in the Windows and Linux python installations). Supplementary Section 3 in the <xref ref-type="supplementary-material" rid="SM1">Supplementary Material</xref> goes into greater detail about the systems architecture differences between the CPU and GPU versions of the MIIND code. Using the “Group” algorithms is recommended if possible as it provides a significant performance increase. As shown in De Kamps et al. (<xref rid="B10" ref-type="bibr">2019</xref>), with the use of the GPGPU, a population of conductance based neurons in MIIND performs comparably to a NEST simulation of 10,000 individual neurons but using an order of magnitude less memory. This allows MIIND to simulate many thousands of populations on a single PC.</p>
  </sec>
  <sec id="s6">
    <title>6. Running a MIIND Simulation in Python</title>
    <p>As demonstrated in the quick start guide, the command <bold>python -m miind.run</bold> takes a simulation XML file as a parameter and runs the simulation. A similar script may be written by the user to give more control over what happens during a simulation and how output activity is recorded and processed. It even allows MIIND simulations to be integrated into other Python applications such as TVB (Sanz Leon et al., <xref rid="B37" ref-type="bibr">2013</xref>) so the population density technique can be used to solve the behaviour of nodes in a brain-scale network (see section 9.2). To run a MIIND simulation in a Python script, the module <italic>miind.miindsim</italic> must be imported (or <italic>miind.miindsimv</italic> if the simulation uses MeshAlgorithmGroup or GridAlgorithmGroup and therefore requires CUDA support). Listing 24 shows an example script which uses the following available functions to control the simulation.</p>
    <table-wrap id="d31e2181" position="float">
      <label>Listing 24</label>
      <caption>
        <p>A simple python script for running a MIIND simulation and plotting the results.</p>
      </caption>
      <graphic xlink:href="fninf-15-614881-i0024"/>
    </table-wrap>
    <sec>
      <title>6.1. init(node_count,simulation_xml_file,…)</title>
      <p>The <italic>init</italic> function should be called first once the MIIND library has been imported. This sets up the simulation ready to be started. The <italic>node_count</italic> parameter allows for multiple instantiations of the simulation to be run simultaneously. The Nodes, Connections, and Reporting blocks from the simulation file will be duplicated, effectively running the same model <italic>node_count</italic> times simultaneously in the same simulation. This functionality was included to allow TVB to run the simulation defined in the XML file multiple times (see section 9.2). The <italic>simulation_xml_file</italic> parameter gives the name of the simulation xml file to be run. If the file has any variables defined, these are made available in Python as additional parameters to the <italic>init</italic> function. In this way, the use of XML variables can be used for parameter sweeps. All variables must be passed as strings. If a variable is not set in the call to <italic>init</italic>, the default value defined in the XML file will be used.</p>
      <table-wrap id="d31e2203" position="float">
        <label>Listing 25</label>
        <caption>
          <p>Calling init for a MIIND simulation lif.xml with the Variable SIM_TIME set to 0.4.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0025"/>
      </table-wrap>
    </sec>
    <sec>
      <title>6.2. getTimeStep() and getSimulationLength()</title>
      <p>Once <italic>init</italic> has been called, the functions <italic>getTimeStep</italic> and <italic>getSimulationLength</italic> can be used to extract the time step and simulation length in seconds from the simulation, respectively. The Python script controls when each iteration of the MIIND simulation is called and so it needs to know the total number of iterations to make. Furthermore, it can be useful for integration with other systems to know these values.</p>
    </sec>
    <sec>
      <title>6.3. startSimulation()</title>
      <p><italic>startSimulation</italic> indicates in the Python script that the simulation should be initialised ready for the simulation loop to be called.</p>
    </sec>
    <sec>
      <title>6.4. evolveSingleStep(input)</title>
      <p>By calling <italic>evolveSingleStep</italic> in the Python script, the MIIND simulation will move forward one time step. This function takes a list of numbers as a parameter. The list corresponds to inputs to the population nodes in the MIIND simulation. In this way, the user may control the behaviour of the simulation from the Python script during the simulation. The <italic>evolveSingleStep</italic> function also returns a list of numbers which are the output activities of the population nodes. Section 6.6 provides more information about how to use the input and output of this function. <italic>evolveSingleStep</italic> should be called in a loop which will run the same number of iterations as would be expected if the XML file were run in MIIND directly, that is, the simulation length divided by the time step.</p>
    </sec>
    <sec>
      <title>6.5. endSimulation()</title>
      <p>It is good practice to call <italic>endSimulation</italic> once all iterations of the simulation have been performed. This allows MIIND to clean up and to print the performance statistics to the console.</p>
    </sec>
    <sec>
      <title>6.6. Additional XML Code for Python Support</title>
      <p>Although it is still possible to use <italic>RateFunctor</italic> or <italic>RateAlgorithm</italic> to set input rates to populations in a Python MIIND simulation, <italic>evolveSingleStep()</italic> provides a means to pass the input rates as a parameter so that more complex input patterns can be used. In order to indicate that a population will receive input externally from the Python script [via the list input to <italic>evolveSingleStep()</italic>] a special connection type must be defined in the <italic>&lt;Connections&gt;</italic> section of the XML.</p>
      <table-wrap id="d31e2253" position="float">
        <label>Listing 26</label>
        <caption>
          <p>Special connection types for use in Python.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0026"/>
      </table-wrap>
      <p>Listing 26 defines an input to node E which will be interpreted as a DelayedConnection with the number of connections equal to 1 and a post synaptic efficacy of 0.01. No delay is defined here although it is permitted. OutgoingConnections are used to declare which nodes in the population network will pass their activity back to the Python script after each iteration. If the two connections in the listing are the only instances of IncomingConnection and OutgoingConnection, then the <italic>evolveSingleStep</italic> function will expect as a parameter, a list with one numeric value to represent the incoming rate to node E. <italic>evolveSingleStep</italic> will return a list with a single numeric value representing the activity of node E. In cases where there are more than one IncomingConnection, the order of values in the Python list parameter to <italic>evolveSingleStep</italic> is the same as the order of IncomingConnections defined in the XML. Similarly with OutgoingConnections, the order of the list of activities returned from <italic>evolveSingleStep</italic> is the same as the order of declaration in the XML file.</p>
    </sec>
  </sec>
  <sec id="s7">
    <title>7. Using the CLI to Quickly View Results</title>
    <p>Once a simulation has been run, either using <italic>miind.run</italic> or from a user written Python script, the <italic>miind.miindio</italic> CLI can be used to quickly plot the recorded results. As mentioned, the commands used in <italic>miindio</italic> are based on the module <italic>miind.miind_api</italic> and are reproducible in a Python script. However, it can be convenient to be able to run them directly from the command line to aid fast prototyping and bug fixing of models and simulations. The following section lists some common commands in the CLI and their usage. The accompanying files for this example are in the <italic>examples/cli_plots</italic> directory. The following command starts the CLI and presets the user with a prompt:</p>
    <table-wrap id="d31e2282" position="float">
      <label>Listing 27</label>
      <caption>
        <p>Run the CLI.</p>
      </caption>
      <graphic xlink:href="fninf-15-614881-i0027"/>
    </table-wrap>
    <p>When <italic>miind.miindio</italic> is called for the first time in a working directory, the user must identify the XML file which will describe the current working simulation. MIIND stores a reference to this file in a settings file in the working directory so that all subsequent commands will reference this simulation. Even if <italic>miind.miindio</italic> is quit and restarted, the current working simulation will be used as the context for commands until a new current working simulation is defined or if it is called in a different directory. The user can set the current working simulation with the <bold>sim</bold> command.</p>
    <table-wrap id="d31e2295" position="float">
      <label>Listing 28</label>
      <caption>
        <p>Load a simulation file in the CLI.</p>
      </caption>
      <graphic xlink:href="fninf-15-614881-i0028"/>
    </table-wrap>
    <p>Calling <bold>sim</bold> without a parameter will list information about the current working simulation such as the output directory, XML file name and provide a list of the defined variables and nodes.</p>
    <p>During the simulation, MIIND generates output files according to the requirements of the <italic>&lt;Recording&gt;</italic> object of the XML file which could include the average firing rate of population nodes or their densities at each time interval. The average firing rate can be plotted from the CLI using the <bold>rate</bold> command followed by the name of the population node. To be reminded of the node names, the user can call <bold>sim</bold> or <bold>rate</bold> without parameters.</p>
    <table-wrap id="d31e2314" position="float">
      <label>Listing 29</label>
      <caption>
        <p>Plot the rate of population POP1 in the CLI.</p>
      </caption>
      <graphic xlink:href="fninf-15-614881-i0029"/>
    </table-wrap>
    <p>Even while a simulation is running, calling <bold>rate</bold> in the CLI will plot the recorded activity up to the latest simulated time point. This is useful to keep an eye on the simulation as it progresses without waiting for completion. An example of the plots produced by <bold>rate</bold> is shown in <xref ref-type="fig" rid="F11">Figure 11A</xref>.</p>
    <fig id="F11" position="float">
      <label>Figure 11</label>
      <caption>
        <p><bold>(A)</bold> The average firing rate of a population produced by calling the <bold>rate</bold> command. <bold>(B)</bold> A density plot (normalised to the maximum density value) of the population produced by calling the <bold>plot-density</bold> command. <bold>(C)</bold> The marginal density plots produced by calling the <bold>plot-marginals</bold> command.</p>
      </caption>
      <graphic xlink:href="fninf-15-614881-g0011"/>
    </fig>
    <p>For populations using the grid or mesh algorithms, the user can call the <bold>plot-density</bold> command with parameters identifying the required node name and simulation time.</p>
    <table-wrap id="d31e2350" position="float">
      <label>Listing 30</label>
      <caption>
        <p>Plot the probability density of population POP1 at time 0.42 s in the CLI.</p>
      </caption>
      <graphic xlink:href="fninf-15-614881-i0030"/>
    </table-wrap>
    <p>This command renders the mesh or grid and its population density at the given simulation time. When reading the simulation time parameter in the command, MIIND expects the time to be an integer multiple of the time step and to be expressed up to its least significant figure (for example, 0.1 instead of 0.10). Again, this command can be run during a simulation providing the time has been simulated. An example of a density plot is shown in <xref ref-type="fig" rid="F11">Figure 11B</xref>.</p>
    <p>Similar to <bold>plot-density</bold>, <bold>plot-marginals</bold> can be used to display the marginal densities of a given population at a given time. Both marginals are plotted next to each other. The details of how marginal densities are calculated are explained in the <xref ref-type="supplementary-material" rid="SM1">Supplementary Section 5</xref>. <xref ref-type="fig" rid="F11">Figure 11C</xref> shows an example of a marginal density plot.</p>
    <table-wrap id="d31e2372" position="float">
      <label>Listing 31</label>
      <caption>
        <p>Plot the marginal distributions of population POP1 at time 0.42s in the CLI.</p>
      </caption>
      <graphic xlink:href="fninf-15-614881-i0031"/>
    </table-wrap>
    <sec>
      <title>7.1. Generate a Density Movie</title>
      <p>If, in the XML file <italic>&lt;Recording&gt;</italic> section, the <italic>&lt;Display&gt;</italic> element is added for a given population, the output directory will be populated with still images of density plots at each time step. Once the simulation is complete, calling <bold>generate-density-movie</bold> in the CLI will produce an MP4 movie file made from the still images. The parameters are the node name followed by the size of the square video frame in pixels. The third parameter is the desired time to display each image (every time step of the simulation) in seconds. If the video should be the same length as the simulation time, then this parameter should match the time step of the simulation. By changing the value, the video time can be altered. For example, if the parameter is set to 0.01 for a simulation with time step 0.001, then the video length will be 10 times the length of the simulation. Finally, a name for the video file must be given.</p>
      <table-wrap id="d31e2387" position="float">
        <label>Listing 32</label>
        <caption>
          <p>Generate a movie from the display images of population POP1 with a size of 512 pixels at a simulation replay time step of 0.1 s.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0032"/>
      </table-wrap>
      <p>The movie file will be created in the working directory of the simulation. A movie of the marginal density plots can also be created using the <bold>generate-marginal-movie</bold> command which takes the same parameters. As each marginal plot must be generated from the density output, this takes a considerably longer time than for the density movie.</p>
      <table-wrap id="d31e2396" position="float">
        <label>Listing 33</label>
        <caption>
          <p>Generate a marginals movie from the density files of population POP1 with a size of 512 pixels at a simulation replay time step of 0.1 s.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-i0033"/>
      </table-wrap>
    </sec>
  </sec>
  <sec id="s8">
    <title>8. Description of MIIND's Architecture and Functionality</title>
    <p>The main architectural concerns in MIIND relate to the two C++ libraries, MPILib and TwoDLib. MPILib is responsible for instantiating and running the simulation. TwoDLib contains the CPU implementations of the grid and mesh algorithms. It is also responsible for generating transition matrices. Of the remaining libraries, GeomLib contains a population density technique implementation of neuron models with one time dependent variable, although it is also possible and indeed preferable to use the TwoDLib code for one dimensional models. EPFLLib and NumtoolsLib contain helper classes and type definitions. <xref ref-type="fig" rid="F12">Figure 12</xref> shows a reduced UML diagram of the MIIND C++ architecture. The aim of this section is to give a brief overview of the C++ MIIND code as a starting point for developers. The CUDA implementation of MIIND is similar in structure to the CPU solution and is available in the CudaTwoDLib and MiindLib libraries. A description of the differences is given in Supplementary Section 3 of the <xref ref-type="supplementary-material" rid="SM1">Supplementary Material</xref>.</p>
    <fig id="F12" position="float">
      <label>Figure 12</label>
      <caption>
        <p>A minimal UML diagram of MIIND. The two major libraries, MPILib and TwoDLib, are represented.</p>
      </caption>
      <graphic xlink:href="fninf-15-614881-g0012"/>
    </fig>
    <sec>
      <title>8.1. MPILib</title>
      <p>The MPINetwork class in MPILib represents a simulation as a whole and is instantiated in the <italic>init</italic> function of the SimulationParserCPU class which is a specialisation of MiindTvbModelAbstract. <italic>init</italic> is called from the Python module and, as the name suggests, MiindTvbModelAbstract was originally written with the aim of Python integration into TVB. MPINetwork exposes member functions for building a network of nodes where each node is an instance of a neuron population which can be connected together so that the output activity from one population is input to another. The class also contains all of the simulation parameters such as the simulation length and time step. Finally, the MPINetwork class exposes a function to run the simulation in its entirety or take a single evolve step for use in an external control loop.</p>
      <p>Each node in the population network is represented by an instance of the MPINode class. A node has a name and an ID which is used to uniquely identify it in the simulation. A node also contains an implementation of AlgorithmInterface performing the integration technique required for this population (for example, GridAlgorithm or MeshAlgorithm). The <italic>NodeType</italic> describes whether a population should be thought of as excitatory or inhibitory. As discussed earlier, MIIND performs a validation check that the synaptic efficacy from a node is positive or negative, respectively (or neutral). During each iteration, each node is responsible for consolidating the activity of all input connections, calling the integration step in the AlgorithmInterface implementation, and reporting the density and output activity (the average firing rate or membrane potential).</p>
      <p>In MPILib, a number of implementations of AlgorithmInterface are defined which can be instantiated in a node. Implementations of AlgorithmInterface are responsible for the lion's share of the computation in MIIND as this is where the integration of the model is performed. The interface is extremely simple, providing a function to set parameters, an optional function for a preamble before each iteration, and the <italic>evolveNodeState</italic> function to be called every time step. GridAlgorithm and MeshAlgorithm are implementations of this interface defined in TwoDLib. MPILib and GeomLib hold the implementations of the remaining algorithms available to the user which were discussed in section 4. Finally, the weight types, DelayedConnection and CustomConnectionParameters are also defined in MPILib. All classes are C++ templates which take the weight type as a parameter to avoid code duplication and to enforce that only algorithms with the same weight type can be used together.</p>
    </sec>
    <sec>
      <title>8.2. TwoDLib</title>
      <p>As with the population models in MPILib and GeomLib, GridAlgorithm and MeshAlgorithm are implementations of the AlgorithmInterface. We will focus here on the grid algorithm implementation although the mesh algorithm uses the same structures or specialisations of those structures to perform similar tasks as set out in section 3. GridAlgorithm is supported by two important classes. <bold>Ode2DSystem</bold> transfers probability mass according to the reset mapping of the <italic>.model</italic> file and calculates the average firing rate of the population. In MeshAlgorithm, Ode2DSystem also performs the pointer update for shifting probability mass down the strips of the mesh. <bold>MasterGrid</bold> is responsible for solving the Poisson master equation using a transition matrix calculated at simulation time based on the desired efficacy and grid cell size. For each iteration, the function <italic>evolveNodeState</italic> is called which performs the main steps of the population density algorithm.</p>
      <p>First, in GridAlgorithm, the deterministic dynamics are solved by applying the pre-generated transition matrix once. The second step is a call to <italic>Ode2DSystem.RedistributeProbability()</italic> to perform any reset mappings for probability mass which appeared in the threshold cells last iteration. This step is useful for neuron models, such as leaky integrate and fire, which contain an instruction to reset one or more variables to a different value upon reaching a threshold.</p>
      <p>The third step calls on the MasterGrid class to solve the master equation for the incoming Poisson spike rates from every incident node. MasterGrid begins with the current state of the probability mass distribution across the grid, that is, the probability mass values of each cell in the grid. As described in section 2, every cell has the same relative transition of probability mass due to a single incoming spike. For the whole grid, this single transition is duplicated into a transition matrix which can be applied to the full probability mass vector. Because there are at most two cells into which probability mass is transferred, this matrix is extremely sparse and can be stored efficiently in a compressed sparse row (CSR) matrix. In the mesh algorithm, this matrix is loaded from the <italic>.mat</italic> file.</p>
      <p>MeshAlgorithm requires a fourth step to transfer probability mass from the ends of strips to stationary cells subject to a reversal mapping generated during the pre-processing phase. This is discussed in the <xref ref-type="supplementary-material" rid="SM1">Supplementary Section 6</xref>.</p>
      <p>Finally, SimulationParserCPU is an extension of the MiindTvbModelAbstract class used to parse the simulation XML file and instantiate an MPINetwork object with the appropriate nodes and connections. Its extensions of the functions declared in MiindTvbModelAbstract are exposed to the Python module to be called from a Python script.</p>
    </sec>
  </sec>
  <sec sec-type="discussion" id="s9">
    <title>9. Discussion</title>
    <sec>
      <title>9.1. MIIND Fulfills a Need for Insight Into Neural Behaviour at Mesoscopic Scales</title>
      <p>The MIIND population density technique allows researchers to simulate population level behaviour by defining the behaviour of the underlying neurons. This is in contrast to many rate based models which describe the population behaviour directly. An example of how population behaviour can differ from the underlying neuron model can be seen in the behaviour of a population of bursting neurons such as the Izhikevich simple model. A single Izhikevich neuron with a constant input current or input spike rate oscillates between a bursting period of repeated firing and a quiescent period of no firing. The average behaviour of a population of Izhikevich neurons is different. Initially, all neurons are synchronised, they burst and quiesce at the same time producing an oscillatory pattern of average firing rate in the population. However, due to the random nature of Poisson input spikes, the neurons de-synchronise over time and the average firing rate of the whole population damps to a constant value because only a subset of neurons are bursting at any one time. <xref ref-type="fig" rid="F11">Figure 11A</xref> shows the damping of the output firing rate oscillations and the “desynchronised” density of a population of Izhikevich simple neurons.</p>
    </sec>
    <sec>
      <title>9.2. TVB Integration</title>
      <p>The Virtual Brain (Sanz Leon et al., <xref rid="B37" ref-type="bibr">2013</xref>) and MIIND are both systems which facilitate the development of neural mass or mean field population models with explicit descriptions of how multiple populations are connected. Using these systems, the complex dynamics arising from the interaction of populations can be studied. TVB provides a framework to describe a network of nodes (the connectivity) which, while it can be abstract, generally represents regions of the human or primate brain. Connections between nodes represent white matter tracts which transfer signals from one node to the next based on length and propagation speed. TVB also allows the description of “coupling” functions which modulate these signals as they pass from one node to another. Typically, the number of nodes is in the order of 100 or so. However, TVB also allows for the definition of a “surface” which can be associated with 10s of thousands of nodes to simulate output from common medical recording techniques such as EEG and BOLD fMRI. TVB has impressive clinical relevance as well as supporting more theoretical neuroscience research. Users can build simulations using the graphical user interface or directly using the Python source code.</p>
      <p>While MIIND and TVB have many functional similarities, both have differing strengths with respect to the underlying simulation techniques and surrounding infrastructure. It was therefore clear that integrating the smaller system, MIIND, into the more developed infrastructure of TVB might yield benefits from both.</p>
      <p>Although it is possible to model delayed connections and synaptic dynamics between populations in MIIND, TVB provides a comprehensive method of defining such structures and behaviours through the connectivity network and coupling functions. Some users of MIIND may find it useful and appropriate to house their simulations in such a structure.</p>
      <p>TVB uses a number of model classes to describe the behaviour of the nodes in a network. When the simulation is run, an instantiation of a specified model class takes the signals which have passed through the network to arrive at each node and integrates forward by one time step (depending on the integration method). In order to use MIIND nodes in TVB, a specialised model class was created to import the MIIND Python library, instantiate it, then make a call to <italic>evolveSingleStep()</italic> in place of the integration function. The inputs and outputs of <italic>evolveSingleStep()</italic> are treated by TVB as any other model. As the MIIND Python library takes a simulation file name as a parameter to its <italic>init</italic> function, a single additional model class is all that is required to expose any MIIND simulation to TVB. <xref ref-type="fig" rid="F13">Figure 13</xref> shows the results from a simulation of the TVB default whole-brain connectivity with populations of Izhikevich simple neurons in MIIND. The script and simulation files are available in the <italic>examples/miind_tvb</italic> directory of the MIIND repository. Both TVB and MIIND must be installed to successfully run the example.</p>
      <fig id="F13" position="float">
        <label>Figure 13</label>
        <caption>
          <p>The firing rates of 76 nodes from the default TVB connectivity simulation. Each node is a population of Izhikevich simple neurons simulated using MIIND. The majority of nodes produce oscillations which decay to a constant average firing rate. However, a subset of nodes remain in an oscillating state.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-g0013"/>
      </fig>
    </sec>
    <sec>
      <title>9.3. Reasoning About Probability Density Instead of Populations of Individual Neurons Simplifies Output Analysis</title>
      <p>The output firing rate or membrane potential of a MIIND population which uses the mesh algorithm or grid algorithm is devoid of any variation which you would see from a population of individual neurons. This is because the effect of Poisson generated input spike trains is applied to a probability density function, effectively an infinite population of neurons. Spike train inputs to a finite population of neurons produces variation in how individual neurons move through state space resulting in noisy output rates at the population level. While this can be mitigated using a larger number of neurons, the use of smoothing techniques, or curve fitting, MIIND requires none of these methods to produce an output which is immediately clear to interpret. For example, MIIND was used to build and simulate a spinal circuit model using populations of integrate and fire neurons (York et al., <xref rid="B43" ref-type="bibr">2021</xref>). The average firing rates of the populations were used to compare patterns of activity with results from an EMG experiment. As the patterns to be observed were on the order of seconds, there was no need to capture faster variation in activity from the simulation and indeed, a direct simulation would have produced output which may have obscured these patterns.</p>
      <p>MIIND has also been used to simulate central pattern generator models which rely on mutually inhibiting populations of bursting neurons. The interaction of the two populations significantly influences their sub-threshold dynamics. In particular, it can be difficult to identify the dynamics responsible for the swapping of states from bursting to quiescent (escape or release). Observing the changing probability density function during the simulation makes it very clear how the two populations are behaving.</p>
    </sec>
    <sec>
      <title>9.4. Handling Noise</title>
      <p>A major benefit of MIIND's population density technique is the ability to observe the effect of noise on a population, and to manipulate noise in an intuitive way. For a given simulation, the Poisson distributed input to a population causes a spread of probability mass across the state space as some neurons receive many spikes, and some receive fewer. It is explained in de Kamps (<xref rid="B8" ref-type="bibr">2013</xref>) how the Poisson input causes a mean increase in membrane potential equal to the product of the post synaptic efficacy, <italic>h</italic>, and the average input rate, ν. It causes a variance equal to ν<italic>h</italic><sup>2</sup>. <italic>h</italic> and ν can therefore be set such that the mean remains the same but the variance changes to observe the effect of noise on the population.</p>
      <p>Another simple way to increase the variance of the population is to introduce two additional inputs with equal rates and opposite post-synaptic efficacies. Again, the mean increase caused by the input remains unchanged but the variance can be increased significantly and this requires only a small change to the XML simulation file.</p>
    </sec>
    <sec>
      <title>9.5. A Model Agnostic System at the Population Level Makes Prototyping Quick and Intuitive</title>
      <p>Because MIIND provides insight of how a neuron model produces behaviour at the population level, it is beneficial that the grid algorithm enables the user to quickly reproduce the <italic>.model</italic> and <italic>.tmat</italic> files if the underlying neuron model needs to be changed. An example of this can be observed in a half-centre oscillator made of a pair of mutually inhibiting populations of bursting neurons. The frequency of oscillation can be made dependent or independent of the input spike rate by including a limit on the slow excitability variable of the underlying neuron model. To make this change, the user can alter the neuron model then rebuild the <italic>.model</italic> and <italic>.tmat</italic> file and no change to the population level network is required.</p>
    </sec>
    <sec>
      <title>9.6. DiPDE</title>
      <p>DiPDE (Iyer et al., <xref rid="B20" ref-type="bibr">2013</xref>; DiPDE, <xref rid="B11" ref-type="bibr">2015</xref>) is an alternative implementation of the population density technique for one dimensional neuron models. It does not employ the “mesh” discretisation method used in the MIIND mesh algorithm and has primarily been used with populations of leaky integrate and fire neurons. DiPDE can be used to simulate the Potjans-Diesmann microcircuit model (Cain et al., <xref rid="B5" ref-type="bibr">2016</xref>) which shows good agreement with MIIND (<xref ref-type="fig" rid="F5">Figure 5</xref>). MIIND is a much larger application than DiPDE because it allows users to design their own underlying neuron models for each population using either the mesh or grid algorithms.</p>
    </sec>
    <sec>
      <title>9.7. Future Work</title>
      <p>A limitation on the MIIND population density technique is that a maximum of two time-dependent variables can be used to describe the underlying neuron model of each population. In the mesh algorithm, for higher dimensions, mesh building would need to be automated but this is not a trivial problem to solve. The grid algorithm, however, is entirely automated and work has been done to extend MIIND for 3D neuron models. <xref ref-type="fig" rid="F14">Figure 14</xref> shows the 3D density plot of a population of Hindmarsh-Rose neurons in MIIND. The technique used to generate the 2D transition matrices outlined in section 2 extends to N dimensions so there is theoretically no limit to the dimensionality of the underlying neuron model in the grid algorithm. However, both the grid algorithm and mesh algorithm suffer from “the curse of dimensionality” such that with each additional variable, the number of cells to cover the state space increases to the point where the memory and processing requirements are too high. Luckily, a great number of neuron behaviours can be captured with only two or three time-dependent variables with appropriate approximations.</p>
      <fig id="F14" position="float">
        <label>Figure 14</label>
        <caption>
          <p>A density plot of a population of Hindmarsh-Rose neurons. The density is contained in a three dimensional volume such that each axis represents one of the time-dependent variables of the model. The volume has been rendered from a rotated and elevated position to more easily visualise the density.</p>
        </caption>
        <graphic xlink:href="fninf-15-614881-g0014"/>
      </fig>
      <p>Large networks can be built up quickly in MIIND. To add a node to a simulation file requires just a single line. Integrating the node into the rest of the network with requisite connections is equally convenient. As mentioned, the Potjans-Diesmann model has been implemented as a single cortical column but this is by no means the limit of the size of network which can be built. It is feasible that a patch of cortex made of perhaps hundreds of cortical columns can be simulated efficiently in MIIND. The benefit of such a network would be to demonstrate how cortical columns interact together under different connectivity regimes and inputs as well as providing the ability to quickly and easily “swap out” the underlying neuron model of each population. Typically, LIF is used but adaptive integrate and fire would be a closer approximation to pyramidal neurons in cortex.</p>
    </sec>
  </sec>
  <sec sec-type="conclusions" id="s10">
    <title>10. Conclusion</title>
    <p>We have presented the mesh and grid algorithms, MIIND's population density techniques for simulating populations of neurons, and given a full account of the software features available to users. While the mesh algorithm was developed some time ago, the grid algorithm which was added to MIIND recently has precipitated a more accessible, user friendly software package. We hope that the explanations given here along with a lower technical barrier to entry will encourage researchers to make use of the tool.</p>
  </sec>
  <sec sec-type="data-availability" id="s11">
    <title>Data Availability Statement</title>
    <p>The original contributions presented in the study are included in the article/<xref ref-type="sec" rid="s13">Supplementary Material</xref>. The MIIND source code and installation packages are available as a github repository at <ext-link ext-link-type="uri" xlink:href="https://github.com/dekamps/miind">https://github.com/dekamps/miind</ext-link>. MIIND can be installed for use in Python using “pip install miind” on many Linux, MacOS, and Windows machines with python versions &gt;= 3.6. Documentation is available at <ext-link ext-link-type="uri" xlink:href="https://miind.readthedocs.io/">https://miind.readthedocs.io/</ext-link>.</p>
  </sec>
  <sec id="s12">
    <title>Author Contributions</title>
    <p>HO and MK contributed to the text of this article. YL, ML, DS, and LD contributed to the development of the population density technique and MIIND software. All authors contributed to the article and approved the submitted version.</p>
  </sec>
  <sec sec-type="COI-statement" id="conf1">
    <title>Conflict of Interest</title>
    <p>The authors declare that the research was conducted in the absence of any commercial or financial relationships that could be construed as a potential conflict of interest.</p>
  </sec>
</body>
<back>
  <ack>
    <p>The authors wish to thank Frank van der Velde and Martin Perez-Guevara for their continued support of the MIIND project.</p>
  </ack>
  <fn-group>
    <fn fn-type="financial-disclosure">
      <p><bold>Funding.</bold> This project received funding from the European Union's Horizon 2020 research and innovation programme under Grant Agreement No. 720270 (HBP SGA1) and Specific Grant Agreement No. 785907 (Human Brain Project SGA2) (MK; YL). HO was funded by EPSRC (EP/N509681/1). The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</p>
    </fn>
  </fn-group>
  <sec sec-type="supplementary-material" id="s13">
    <title>Supplementary Material</title>
    <p>The Supplementary Material for this article can be found online at: <ext-link ext-link-type="uri" xlink:href="https://www.frontiersin.org/articles/10.3389/fninf.2021.614881/full#supplementary-material">https://www.frontiersin.org/articles/10.3389/fninf.2021.614881/full#supplementary-material</ext-link></p>
    <supplementary-material content-type="local-data" id="SM1">
      <media xlink:href="Data_Sheet_1.PDF">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
  <ref-list>
    <title>References</title>
    <ref id="B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Amit</surname><given-names>D. J.</given-names></name><name><surname>Brunel</surname><given-names>N.</given-names></name></person-group> (<year>1997</year>). <article-title>Model of global spontaneous activity and local structured activity during delay periods in the cerebral cortex</article-title>. <source>Cere. Cortex</source>
<volume>7</volume>, <fpage>237</fpage>–<lpage>252</lpage>. <pub-id pub-id-type="doi">10.1093/cercor/7.3.237</pub-id><?supplied-pmid 9143444?><pub-id pub-id-type="pmid">9143444</pub-id></mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Bower</surname><given-names>J. M.</given-names></name><name><surname>Beeman</surname><given-names>D.</given-names></name></person-group> (<year>2012</year>). <source>The Book of GENESIS: Exploring Realistic Neural Models With the GEneral NEural SImulation System</source>. <publisher-loc>New York, NY</publisher-loc>: <publisher-name>Springer Science &amp; Business Media New York</publisher-name>.</mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Brette</surname><given-names>R.</given-names></name><name><surname>Gerstner</surname><given-names>W.</given-names></name></person-group> (<year>2005</year>). <article-title>Adaptive exponential integrate-and-fire model as an effective description of neuronal activity</article-title>. <source>J. Neurophysiol</source>. <volume>94</volume>, <fpage>3637</fpage>–<lpage>3642</lpage>. <pub-id pub-id-type="doi">10.1152/jn.00686.2005</pub-id><?supplied-pmid 16014787?><pub-id pub-id-type="pmid">16014787</pub-id></mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Brunel</surname><given-names>N.</given-names></name><name><surname>Hakim</surname><given-names>V.</given-names></name></person-group> (<year>1999</year>). <article-title>Fast global oscillations in networks of integrate-and-fire neurons with low firing rates</article-title>. <source>Neural Comput</source>. <volume>11</volume>, <fpage>1621</fpage>–<lpage>1671</lpage>. <pub-id pub-id-type="doi">10.1162/089976699300016179</pub-id><?supplied-pmid 10490941?><pub-id pub-id-type="pmid">10490941</pub-id></mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Cain</surname><given-names>N.</given-names></name><name><surname>Iyer</surname><given-names>R.</given-names></name><name><surname>Koch</surname><given-names>C.</given-names></name><name><surname>Mihalas</surname><given-names>S.</given-names></name></person-group> (<year>2016</year>). <article-title>The computational properties of a simplified cortical column model</article-title>. <source>PLoS Comput. Biol</source>. <volume>12</volume>:<fpage>e1005045</fpage>. <pub-id pub-id-type="doi">10.1371/journal.pcbi.1005045</pub-id><?supplied-pmid 27617444?><pub-id pub-id-type="pmid">27617444</pub-id></mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Carlu</surname><given-names>M.</given-names></name><name><surname>Chehab</surname><given-names>O.</given-names></name><name><surname>Dalla Porta</surname><given-names>L.</given-names></name><name><surname>Depannemaecker</surname><given-names>D.</given-names></name><name><surname>Héricé</surname><given-names>C.</given-names></name><name><surname>Jedynak</surname><given-names>M.</given-names></name><etal/></person-group>. (<year>2020</year>). <article-title>A mean-field approach to the dynamics of networks of complex neurons, from nonlinear integrate-and-fire to hodgkin-huxley models</article-title>. <source>J. Neurophysiol</source>. <volume>123</volume>, <fpage>1042</fpage>–<lpage>1051</lpage>. <pub-id pub-id-type="doi">10.1152/jn.00399.2019</pub-id><?supplied-pmid 31851573?><pub-id pub-id-type="pmid">31851573</pub-id></mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>D'Angelo</surname><given-names>E.</given-names></name><name><surname>Antonietti</surname><given-names>A.</given-names></name><name><surname>Casali</surname><given-names>S.</given-names></name><name><surname>Casellato</surname><given-names>C.</given-names></name><name><surname>Garrido</surname><given-names>J. A.</given-names></name><name><surname>Luque</surname><given-names>N. R.</given-names></name><etal/></person-group>. (<year>2016</year>). <article-title>Modeling the cerebellar microcircuit: new strategies for a long-standing issue</article-title>. <source>Front/ Cell. Neurosci</source>. <volume>10</volume>:<fpage>176</fpage>. <pub-id pub-id-type="doi">10.3389/fncel.2016.00176</pub-id><?supplied-pmid 27458345?><pub-id pub-id-type="pmid">27458345</pub-id></mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>de Kamps</surname><given-names>M.</given-names></name></person-group> (<year>2013</year>). <article-title>A generic approach to solving jump diffusion equations with applications to neural populations</article-title>. <source>arXiv</source> [Preprint] arXiv:1309.1654.</mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>De Kamps</surname><given-names>M.</given-names></name><name><surname>Baier</surname><given-names>V.</given-names></name><name><surname>Drever</surname><given-names>J.</given-names></name><name><surname>Dietz</surname><given-names>M.</given-names></name><name><surname>Mösenlechner</surname><given-names>L.</given-names></name><name><surname>Van Der Velde</surname><given-names>F.</given-names></name></person-group> (<year>2008</year>). <article-title>The state of MIIND</article-title>. <source>Neural Netw</source>. <volume>21</volume>, <fpage>1164</fpage>–<lpage>1181</lpage>. <pub-id pub-id-type="doi">10.1016/j.neunet.2008.07.006</pub-id><pub-id pub-id-type="pmid">18783918</pub-id></mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>De Kamps</surname><given-names>M.</given-names></name><name><surname>Lepperød</surname><given-names>M.</given-names></name><name><surname>Lai</surname><given-names>Y. M.</given-names></name></person-group> (<year>2019</year>). <article-title>Computational geometry for modeling neural populations: from visualization to simulation</article-title>. <source>PLoS Comput. Biol</source>. <volume>15</volume>:<fpage>e1006729</fpage>. <pub-id pub-id-type="doi">10.1371/journal.pcbi.1006729</pub-id><?supplied-pmid 30830903?><pub-id pub-id-type="pmid">30830903</pub-id></mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="webpage"><person-group person-group-type="author"><collab>Di,PD. E</collab></person-group>. (<year>2015</year>). <article-title>2015 Allen Institute for Brain Science</article-title>. DiPDE Simulator. Available online at: <ext-link ext-link-type="uri" xlink:href="https://github.com/AllenInstitute/dipde">https://github.com/AllenInstitute/dipde</ext-link></mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>El Boustani</surname><given-names>S.</given-names></name><name><surname>Destexhe</surname><given-names>A.</given-names></name></person-group> (<year>2009</year>). <article-title>A master equation formalism for macroscopic modeling of asynchronous irregular activity states</article-title>. <source>Neural Comput</source>. <volume>21</volume>, <fpage>46</fpage>–<lpage>100</lpage>. <pub-id pub-id-type="doi">10.1162/neco.2009.02-08-710</pub-id><?supplied-pmid 19210171?><pub-id pub-id-type="pmid">19210171</pub-id></mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>FitzHugh</surname><given-names>R.</given-names></name></person-group> (<year>1961</year>). <article-title>Impulses and physiological states in theoretical models of nerve membrane</article-title>. <source>Biophys. J</source>. <volume>1</volume>:<fpage>445</fpage>. <pub-id pub-id-type="doi">10.1016/S0006-3495(61)86902-6</pub-id><?supplied-pmid 19431309?><pub-id pub-id-type="pmid">19431309</pub-id></mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fourcaud-Trocmé</surname><given-names>N.</given-names></name><name><surname>Hansel</surname><given-names>D.</given-names></name><name><surname>Van Vreeswijk</surname><given-names>C.</given-names></name><name><surname>Brunel</surname><given-names>N.</given-names></name></person-group> (<year>2003</year>). <article-title>How spike generation mechanisms determine the neuronal response to fluctuating inputs</article-title>. <source>J. Neurosci</source>. <volume>23</volume>, <fpage>11628</fpage>–<lpage>11640</lpage>. <pub-id pub-id-type="doi">10.1523/JNEUROSCI.23-37-11628.2003</pub-id><?supplied-pmid 14684865?><pub-id pub-id-type="pmid">14684865</pub-id></mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Furber</surname><given-names>S.</given-names></name><name><surname>Galluppi</surname><given-names>F.</given-names></name><name><surname>Temple</surname><given-names>S.</given-names></name><name><surname>Plana</surname><given-names>L.</given-names></name></person-group> (<year>2014</year>). <article-title>The spinnaker project</article-title>. <source>IEEE Proc</source>. <volume>102</volume>, <fpage>652</fpage>–<lpage>665</lpage>. <pub-id pub-id-type="doi">10.1109/JPROC.2014.2304638</pub-id></mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gerstner</surname><given-names>W.</given-names></name></person-group> (<year>1998</year>). <source>Spiking Neurons</source>. Technical report, MIT-Press.</mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gewaltig</surname><given-names>M.-O.</given-names></name><name><surname>Diesmann</surname><given-names>M.</given-names></name></person-group> (<year>2007</year>). <article-title>Nest (neural simulation tool)</article-title>. <source>Scholarpedia</source>
<volume>2</volume>:<fpage>1430</fpage>. <pub-id pub-id-type="doi">10.4249/scholarpedia.1430</pub-id></mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hindmarsh</surname><given-names>J. L.</given-names></name><name><surname>Rose</surname><given-names>R.</given-names></name></person-group> (<year>1984</year>). <article-title>A model of neuronal bursting using three coupled first order differential equations</article-title>. <source>Proc. R. Soc. Lond. Ser. B Biol. Sci</source>. <volume>221</volume>, <fpage>87</fpage>–<lpage>102</lpage>. <pub-id pub-id-type="doi">10.1098/rspb.1984.0024</pub-id><?supplied-pmid 6144106?><pub-id pub-id-type="pmid">6144106</pub-id></mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hines</surname><given-names>M. L.</given-names></name><name><surname>Carnevale</surname><given-names>N. T.</given-names></name></person-group> (<year>2001</year>). <article-title>Neuron: a tool for neuroscientists</article-title>. <source>Neuroscientist</source>
<volume>7</volume>, <fpage>123</fpage>–<lpage>135</lpage>. <pub-id pub-id-type="doi">10.1177/107385840100700207</pub-id><pub-id pub-id-type="pmid">11496923</pub-id></mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Iyer</surname><given-names>R.</given-names></name><name><surname>Menon</surname><given-names>V.</given-names></name><name><surname>Buice</surname><given-names>M.</given-names></name><name><surname>Koch</surname><given-names>C.</given-names></name><name><surname>Mihalas</surname><given-names>S.</given-names></name></person-group> (<year>2013</year>). <article-title>The influence of synaptic weight distribution on neuronal population dynamics</article-title>. <source>PLoS Comput. Biol</source>. <volume>9</volume>:<fpage>e1003248</fpage>. <pub-id pub-id-type="doi">10.1371/journal.pcbi.1003248</pub-id><?supplied-pmid 24204219?><pub-id pub-id-type="pmid">24204219</pub-id></mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Izhikevich</surname><given-names>E. M.</given-names></name></person-group> (<year>2003</year>). <article-title>Simple model of spiking neurons</article-title>. <source>IEEE Trans. Neural Netw</source>. <volume>14</volume>, <fpage>1569</fpage>–<lpage>1572</lpage>. <pub-id pub-id-type="doi">10.1109/TNN.2003.820440</pub-id><pub-id pub-id-type="pmid">18244602</pub-id></mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Izhikevich</surname><given-names>E. M.</given-names></name></person-group> (<year>2007</year>). <source>Dynamical Systems in Neuroscience: The Geometry of Excitability and Bursting</source>. <publisher-loc>Cambridge, MA</publisher-loc>: <publisher-name>MIT Press</publisher-name>.</mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Jirsa</surname><given-names>V. K.</given-names></name><name><surname>Stacey</surname><given-names>W. C.</given-names></name><name><surname>Quilichini</surname><given-names>P. P.</given-names></name><name><surname>Ivanov</surname><given-names>A. I.</given-names></name><name><surname>Bernard</surname><given-names>C.</given-names></name></person-group> (<year>2014</year>). <article-title>On the nature of seizure dynamics</article-title>. <source>Brain</source>
<volume>137</volume>, <fpage>2210</fpage>–<lpage>2230</lpage>. <pub-id pub-id-type="doi">10.1093/brain/awu133</pub-id><pub-id pub-id-type="pmid">24919973</pub-id></mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kamps</surname><given-names>M. d</given-names></name></person-group>. (<year>2003</year>). <article-title>A simple and stable numerical solution for the population density equation</article-title>. <source>Neural Comput</source>. <volume>15</volume>, <fpage>2129</fpage>–<lpage>2146</lpage>. <pub-id pub-id-type="doi">10.1162/089976603322297322</pub-id><?supplied-pmid 12959669?><pub-id pub-id-type="pmid">12959669</pub-id></mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Knight</surname><given-names>B. W.</given-names></name></person-group> (<year>1972</year>). <article-title>Dynamics of encoding in a population of neurons</article-title>. <source>J. Gen. Physiol</source>. <volume>59</volume>, <fpage>734</fpage>–<lpage>766</lpage>. <pub-id pub-id-type="doi">10.1085/jgp.59.6.734</pub-id><?supplied-pmid 5025748?><pub-id pub-id-type="pmid">5025748</pub-id></mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Knight</surname><given-names>B. W.</given-names></name><name><surname>Manin</surname><given-names>D.</given-names></name><name><surname>Sirovich</surname><given-names>L.</given-names></name></person-group> (<year>1996</year>). <article-title>Dynamical models of interacting neuron populations in visual cortex</article-title>. <source>Robot Cybern</source>
<volume>54</volume>, <fpage>4</fpage>–<lpage>8</lpage>.</mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lai</surname><given-names>Y. M.</given-names></name><name><surname>de Kamps</surname><given-names>M.</given-names></name></person-group> (<year>2017</year>). <article-title>Population density equations for stochastic processes with memory kernels</article-title>. <source>Phys. Rev. E</source>
<volume>95</volume>:<fpage>062125</fpage>. <pub-id pub-id-type="doi">10.1103/PhysRevE.95.062125</pub-id><?supplied-pmid 28709222?><pub-id pub-id-type="pmid">28709222</pub-id></mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mattia</surname><given-names>M.</given-names></name><name><surname>Del Giudice</surname><given-names>P.</given-names></name></person-group> (<year>2002</year>). <article-title>Population dynamics of interacting spiking neurons</article-title>. <source>Phys. Rev. E</source>
<volume>66</volume>:<fpage>051917</fpage>. <pub-id pub-id-type="doi">10.1103/PhysRevE.66.051917</pub-id><?supplied-pmid 12513533?><pub-id pub-id-type="pmid">12513533</pub-id></mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mattia</surname><given-names>M.</given-names></name><name><surname>Del Giudice</surname><given-names>P.</given-names></name></person-group> (<year>2004</year>). <article-title>Finite-size dynamics of inhibitory and excitatory interacting spiking neurons</article-title>. <source>Phys. Rev. E</source>
<volume>70</volume>:<fpage>052903</fpage>. <pub-id pub-id-type="doi">10.1103/PhysRevE.70.052903</pub-id><?supplied-pmid 15600672?><pub-id pub-id-type="pmid">15600672</pub-id></mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Montbrió</surname><given-names>E.</given-names></name><name><surname>Pazó</surname><given-names>D.</given-names></name><name><surname>Roxin</surname><given-names>A.</given-names></name></person-group> (<year>2015</year>). <article-title>Macroscopic description for networks of spiking neurons</article-title>. <source>Phys. Rev. X</source>
<volume>5</volume>:<fpage>021028</fpage>. <pub-id pub-id-type="doi">10.1103/PhysRevX.5.021028</pub-id></mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Nagumo</surname><given-names>J.</given-names></name><name><surname>Arimoto</surname><given-names>S.</given-names></name><name><surname>Yoshizawa</surname><given-names>S.</given-names></name></person-group> (<year>1962</year>). <article-title>An active pulse transmission line simulating nerve axon</article-title>. <source>Proc. IRE</source>
<volume>50</volume>, <fpage>2061</fpage>–<lpage>2070</lpage>. <pub-id pub-id-type="doi">10.1109/JRPROC.1962.288235</pub-id></mixed-citation>
    </ref>
    <ref id="B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Nykamp</surname><given-names>D. Q.</given-names></name><name><surname>Tranchina</surname><given-names>D.</given-names></name></person-group> (<year>2000</year>). <article-title>A population density approach that facilitates large-scale modeling of neural networks: analysis and an application to orientation tuning</article-title>. <source>J. Comput. Neurosci</source>. <volume>8</volume>, <fpage>19</fpage>–<lpage>50</lpage>. Nykamp, D. Q., and Tranchina, D. (2000). A population density approach that facilitates large-scale modeling of neural networks: analysis and an application to orientation tuning. <italic>J. Comput. Neurosci</italic>. 8, 9–50. <pub-id pub-id-type="doi">10.1023/A:1008912914816</pub-id><?supplied-pmid 10798498?><pub-id pub-id-type="pmid">10798498</pub-id></mixed-citation>
    </ref>
    <ref id="B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Omurtag</surname><given-names>A.</given-names></name><name><surname>Knight</surname><given-names>B. W.</given-names></name><name><surname>Sirovich</surname><given-names>L.</given-names></name></person-group> (<year>2000</year>). <article-title>On the simulation of large populations of neurons</article-title>. <source>J. Comput. Neurosci</source>. <volume>8</volume>, <fpage>51</fpage>–<lpage>63</lpage>. <pub-id pub-id-type="doi">10.1023/A:1008964915724</pub-id><?supplied-pmid 10798499?><pub-id pub-id-type="pmid">10798499</pub-id></mixed-citation>
    </ref>
    <ref id="B34">
      <mixed-citation publication-type="webpage"><person-group person-group-type="author"><name><surname>Osborne</surname><given-names>H.</given-names></name><name><surname>De Kamps</surname><given-names>M.</given-names></name></person-group> (<year>2021</year>). <source>MIIND Documentation</source>. Available online at: <ext-link ext-link-type="uri" xlink:href="https://miind.readthedocs.io">https://miind.readthedocs.io</ext-link></mixed-citation>
    </ref>
    <ref id="B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Potjans</surname><given-names>T. C.</given-names></name><name><surname>Diesmann</surname><given-names>M.</given-names></name></person-group> (<year>2014</year>). <article-title>The cell-type specific cortical microcircuit: relating structure and activity in a full-scale spiking network model</article-title>. <source>Cereb. Cortex</source>
<volume>24</volume>, <fpage>785</fpage>–<lpage>806</lpage>. <pub-id pub-id-type="doi">10.1093/cercor/bhs358</pub-id><?supplied-pmid 23203991?><pub-id pub-id-type="pmid">23203991</pub-id></mixed-citation>
    </ref>
    <ref id="B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Proix</surname><given-names>T.</given-names></name><name><surname>Bartolomei</surname><given-names>F.</given-names></name><name><surname>Guye</surname><given-names>M.</given-names></name><name><surname>Jirsa</surname><given-names>V. K.</given-names></name></person-group> (<year>2017</year>). <article-title>Individual brain structure and modelling predict seizure propagation</article-title>. <source>Brain</source>
<volume>140</volume>, <fpage>641</fpage>–<lpage>654</lpage>. <pub-id pub-id-type="doi">10.1093/brain/awx004</pub-id><?supplied-pmid 28364550?><pub-id pub-id-type="pmid">28364550</pub-id></mixed-citation>
    </ref>
    <ref id="B37">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sanz Leon</surname><given-names>P.</given-names></name><name><surname>Knock</surname><given-names>S. A.</given-names></name><name><surname>Woodman</surname><given-names>M. M.</given-names></name><name><surname>Domide</surname><given-names>L.</given-names></name><name><surname>Mersmann</surname><given-names>J.</given-names></name><name><surname>McIntosh</surname><given-names>A. R.</given-names></name><etal/></person-group>. (<year>2013</year>). <article-title>The virtual brain: a simulator of primate brain network dynamics</article-title>. <source>Front. Neuroinform</source>. <volume>7</volume>:<fpage>10</fpage>. <pub-id pub-id-type="doi">10.3389/fninf.2013.00010</pub-id><?supplied-pmid 23781198?><pub-id pub-id-type="pmid">23781198</pub-id></mixed-citation>
    </ref>
    <ref id="B38">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Traub</surname><given-names>R. D.</given-names></name><name><surname>Contreras</surname><given-names>D.</given-names></name><name><surname>Cunningham</surname><given-names>M. O.</given-names></name><name><surname>Murray</surname><given-names>H.</given-names></name><name><surname>LeBeau</surname><given-names>F. E.</given-names></name><name><surname>Roopun</surname><given-names>A.</given-names></name><etal/></person-group>. (<year>2005</year>). <article-title>Single-column thalamocortical network model exhibiting gamma oscillations, sleep spindles, and epileptogenic bursts</article-title>. <source>J. Neurophysiol</source>. <volume>93</volume>, <fpage>2194</fpage>–<lpage>2232</lpage>. <pub-id pub-id-type="doi">10.1152/jn.00983.2004</pub-id><?supplied-pmid 15525801?><pub-id pub-id-type="pmid">15525801</pub-id></mixed-citation>
    </ref>
    <ref id="B39">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Tsodyks</surname><given-names>M. V.</given-names></name><name><surname>Markram</surname><given-names>H.</given-names></name></person-group> (<year>1997</year>). <article-title>The neural code between neocortical pyramidal neurons depends on neurotransmitter release probability</article-title>. <source>Proc. Natl. Acad. Sci. U.S.A</source>. <volume>94</volume>, <fpage>719</fpage>–<lpage>723</lpage>. <pub-id pub-id-type="doi">10.1073/pnas.94.2.719</pub-id><?supplied-pmid 9012851?><pub-id pub-id-type="pmid">9012851</pub-id></mixed-citation>
    </ref>
    <ref id="B40">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Uhlenbeck</surname><given-names>G. E.</given-names></name><name><surname>Ornstein</surname><given-names>L. S.</given-names></name></person-group> (<year>1930</year>). <article-title>On the theory of the brownian motion</article-title>. <source>Phys. Rev</source>. <volume>36</volume>:<fpage>823</fpage>. <pub-id pub-id-type="doi">10.1103/PhysRev.36.823</pub-id></mixed-citation>
    </ref>
    <ref id="B41">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wilson</surname><given-names>H. R.</given-names></name><name><surname>Cowan</surname><given-names>J. D.</given-names></name></person-group> (<year>1972</year>). <article-title>Excitatory and inhibitory interactions in localized populations of model neurons</article-title>. <source>Biophys. J</source>. <volume>12</volume>, <fpage>1</fpage>–<lpage>24</lpage>. <pub-id pub-id-type="doi">10.1016/S0006-3495(72)86068-5</pub-id><?supplied-pmid 4332108?><pub-id pub-id-type="pmid">4332108</pub-id></mixed-citation>
    </ref>
    <ref id="B42">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Wilson</surname><given-names>M. A.</given-names></name><name><surname>Bhalla</surname><given-names>U. S.</given-names></name><name><surname>Uhley</surname><given-names>J. D.</given-names></name><name><surname>Bower</surname><given-names>J. M.</given-names></name></person-group> (<year>1988</year>). <article-title>GENESIS: a system for simulating neural networks,</article-title> in <source>Proceedings of the 1st International Conference on Neural Information Processing Systems</source> (<publisher-loc>Morgan Kaufmann</publisher-loc>), <fpage>485</fpage>–<lpage>492</lpage>.</mixed-citation>
    </ref>
    <ref id="B43">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>York</surname><given-names>G.</given-names></name><name><surname>Osborne</surname><given-names>H.</given-names></name><name><surname>Sriya</surname><given-names>P.</given-names></name><name><surname>Astill</surname><given-names>S.</given-names></name><name><surname>De Kamps</surname><given-names>M.</given-names></name><name><surname>Chakrabarty</surname><given-names>S.</given-names></name></person-group> (<year>2021</year>). <article-title>Muscles recruited during an isometric knee extension task is defined by proprioceptive feedback</article-title>. <source>BioRxiv</source>. <pub-id pub-id-type="doi">10.1101/802736</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
