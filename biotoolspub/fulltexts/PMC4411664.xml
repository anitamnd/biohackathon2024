<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4411664</article-id>
    <article-id pub-id-type="pmid">25928589</article-id>
    <article-id pub-id-type="publisher-id">557</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-015-0557-5</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>ContextMap 2: fast and accurate context-based RNA-seq mapping</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Bonfert</surname>
          <given-names>Thomas</given-names>
        </name>
        <address>
          <email>thomas.bonfert@bio.ifi.lmu.de</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Kirner</surname>
          <given-names>Evelyn</given-names>
        </name>
        <address>
          <email>evelyn.kirner@campus.lmu.de</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Csaba</surname>
          <given-names>Gergely</given-names>
        </name>
        <address>
          <email>gergely.csaba@bio.ifi.lmu.de</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Zimmer</surname>
          <given-names>Ralf</given-names>
        </name>
        <address>
          <email>ralf.zimmer@bio.ifi.lmu.de</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Friedel</surname>
          <given-names>Caroline C</given-names>
        </name>
        <address>
          <email>caroline.friedel@bio.ifi.lmu.de</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <aff id="Aff1"><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 1936 973X</institution-id><institution-id institution-id-type="GRID">grid.5252.0</institution-id><institution>Institute for Informatics, </institution><institution>Ludwig-Maximilians-Universität München, </institution></institution-wrap>Amalienstr. 17, Munich, 80333 Germany </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>17</day>
      <month>4</month>
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2015</year>
    </pub-date>
    <volume>16</volume>
    <elocation-id>122</elocation-id>
    <history>
      <date date-type="received">
        <day>23</day>
        <month>1</month>
        <year>2015</year>
      </date>
      <date date-type="accepted">
        <day>30</day>
        <month>3</month>
        <year>2015</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© Bonfert et al.; licensee BioMed Central. 2015</copyright-statement>
      <license license-type="open-access">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0">http://creativecommons.org/licenses/by/4.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly credited. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p>Mapping of short sequencing reads is a crucial step in the analysis of RNA sequencing (RNA-seq) data. ContextMap is an RNA-seq mapping algorithm that uses a context-based approach to identify the best alignment for each read and allows parallel mapping against several reference genomes.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>In this article, we present ContextMap 2, a new and improved version of ContextMap. Its key novel features are: (i) a plug-in structure that allows easily integrating novel short read alignment programs with improved accuracy and runtime; (ii) context-based identification of insertions and deletions (indels); (iii) mapping of reads spanning an arbitrary number of exons and indels. ContextMap 2 using Bowtie, Bowtie 2 or BWA was evaluated on both simulated and real-life data from the recently published RGASP study.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>We show that ContextMap 2 generally combines similar or higher recall compared to other state-of-the-art approaches with significantly higher precision in read placement and junction and indel prediction. Furthermore, runtime was significantly lower than for the best competing approaches. ContextMap 2 is freely available at http://www.bio.ifi.lmu.de/ContextMap.</p>
      </sec>
      <sec>
        <title>Electronic supplementary material</title>
        <p>The online version of this article (doi:10.1186/s12859-015-0557-5) contains supplementary material, which is available to authorized users.</p>
      </sec>
    </abstract>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2015</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p>Sequencing of RNA using next generation sequencing technology (RNA-seq) has become the standard approach for analyzing the transcriptomic landscape of a cell [<xref ref-type="bibr" rid="CR1">1</xref>,<xref ref-type="bibr" rid="CR2">2</xref>]. The first step in RNA-seq data analysis generally consists in determining the transcriptomic origin of the sequenced reads (= read mapping) [<xref ref-type="bibr" rid="CR3">3</xref>], i.e. the best alignment of each read against a transcript. Here, the major challenge results from the fact that even for well-annotated species not all transcripts, in particular rare or non-coding transcripts [<xref ref-type="bibr" rid="CR4">4</xref>], are known. Thus, alignment against known transcript sequences using short read alignment programs such as Bowtie [<xref ref-type="bibr" rid="CR5">5</xref>] cannot identify reads from novel transcripts, in particular spliced reads crossing novel exon-exon junctions. Unspliced reads, in contrast, are easily mapped using genome alignments.</p>
    <p>Currently, many different RNA-seq mapping algorithms are available, such as TopHat [<xref ref-type="bibr" rid="CR6">6</xref>], TopHat2 [<xref ref-type="bibr" rid="CR7">7</xref>], or MapSplice [<xref ref-type="bibr" rid="CR8">8</xref>] (see also [<xref ref-type="bibr" rid="CR9">9</xref>] for an overview). In most cases, these approaches combine alignment against reference sequences (i.e. a genome and/or transcriptome) using short read aligners, such as Bowtie [<xref ref-type="bibr" rid="CR5">5</xref>] or Bowtie 2 [<xref ref-type="bibr" rid="CR10">10</xref>], with sophisticated strategies for identifying spliced reads crossing exon-exon junctions. A common strategy for this purpose involves splitting reads into smaller segments before aligning and is used e.g. by TopHat2 and MapSplice. Other mapping approaches, such as STAR [<xref ref-type="bibr" rid="CR11">11</xref>] or GSNAP [<xref ref-type="bibr" rid="CR12">12</xref>], use their own alignment methods to identify spliced reads without fragmenting read sequences.</p>
    <p>Independent of the strategy for identifying spliced reads, existing RNA-seq mapping approaches were implemented to use only specific short read alignment programs, in most cases Bowtie. Thus, they cannot be easily extended to make use of novel developments in short read alignment, e.g. Bowtie 2 [<xref ref-type="bibr" rid="CR10">10</xref>] or BWA [<xref ref-type="bibr" rid="CR13">13</xref>], which improve alignment speed, recall or precision [<xref ref-type="bibr" rid="CR14">14</xref>]. Furthermore, they generally identify the best alignment for each read based only on the number of mismatches and do not take into account information provided by alignments of other reads. We recently proposed a different approach, ContextMap, to identify the most likely mapping for a read based on all reads aligned to the same general location, the so-called context [<xref ref-type="bibr" rid="CR15">15</xref>]. This approach also has the advantage that it allows parallel mapping against several reference genomes in a straightforward way [<xref ref-type="bibr" rid="CR16">16</xref>].</p>
    <p>In this article, we present ContextMap 2, an extension of the ContextMap strategy, which among other improvements addresses the problem of integrating different short read alignment programs. The key novel features of ContextMap 2 are:</p>
    <p>(i) It provides an easy-to-use plug-in interface for integrating different short read alignment programs into the mapping workflow. This flexibility guarantees that ContextMap can be quickly adapted to newly developed read alignment algorithms.</p>
    <p>(ii) It extensively uses local read alignment options of novel short read alignment programs such as Bowtie 2 or BWA to accurately detect spliced reads.</p>
    <p>(iii) It precisely predicts the exact position of deletions or insertions (indels) by using the information provided by all reads in the same context.</p>
    <p>We evaluated the performance of ContextMap 2 using Bowtie, Bowtie 2 and BWA as integrated alignment programs on both simulated and real-life RNA-seq data used by the RGASP consortium in a recent evaluation of RNA-seq mapping programs [<xref ref-type="bibr" rid="CR17">17</xref>]. The comparison of ContextMap 2 to the best performers of this study showed that it combined high recall with high precision on read placement, splice junctions, multi-junction reads and indels. While individual competing RNA-seq mapping programs outperformed ContextMap 2 on some of these tasks, none was consistently better or performed comparably well in all of them. Furthermore, ContextMap 2 was generally at least twice as fast as the best competing methods.</p>
  </sec>
  <sec id="Sec2">
    <title>Implementation</title>
    <sec id="Sec3">
      <title>Overview of ContextMap 2</title>
      <p>ContextMap 2 is based on the ContextMap approach for RNA-seq read mapping [<xref ref-type="bibr" rid="CR15">15</xref>]. Here, the central concept is the so-called read context, which is defined as a set of reads all originating from the same stretch of the genome and likely corresponding to transcripts of the same or overlapping genes. The first implementation of ContextMap was focused on improving initial mappings provided by other RNA-seq mapping programs, but has more recently been extended into a standalone version that also allows parallel mapping against several reference genomes [<xref ref-type="bibr" rid="CR16">16</xref>].</p>
      <p>Similar to other mapping approaches, this first ContextMap implementation used a modified version of Bowtie for alignment. Thus, it suffered from the same problem as most state-of-the-art mapping approaches that newly developed short read alignment programs could not be easily integrated to replace the used Bowtie version. Furthermore, variable read lengths were not supported and reads crossing multiple exon-exon junctions or containing indels were not mapped. All of these problems are addressed by ContextMap 2.</p>
      <p>In the following, an overview of the five steps of the ContextMap 2 workflow is presented (see Figure <xref rid="Fig1" ref-type="fig">1</xref>). The details of each step are described following this overview and in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Supplementary methods.
<fig id="Fig1"><label>Figure 1</label><caption><p>Workflow of ContextMap 2.<bold>(A)</bold> Reads are aligned to the reference sequence(s) using the integrated short read alignment program and the resulting alignments are classified into 4 different categories (top box, right side: full alignment, candidate single-split alignment, candidate multi-split alignment, and partial alignment). Dashed lines indicate unaligned sequence parts resulting from local alignments. Candidate single- and multi-split alignments are extended to split alignments using the sliding window approach (Figure <xref rid="Fig2" ref-type="fig">2</xref>). <bold>(B)</bold> Alignments less than <italic>d</italic>
<sub><italic>min</italic></sub> apart are assigned to the same context. The maximum context size <italic>d</italic>
<sub><italic>max</italic></sub> can be defined by the user (default is the average length of a mammalian mRNA). <bold>(C)</bold> Alignment extension of full (green box) and split alignments (see Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Supplementary methods) to determine all valid alignments for a read. <bold>(D)</bold> + <bold>(E)</bold> Resolution of the best alignment for each read first within each context (D, local resolution) and then between all contexts (E, global resolution). For this purpose, a support score is calculated based on closely located alignments of other reads (bottom box, right side, and Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Supplementary methods).</p></caption><graphic xlink:href="12859_2015_557_Fig1_HTML" id="MO1"/></fig>
<fig id="Fig2"><label>Figure 2</label><caption><p>Detection of single-split and multi-split alignments in ContextMap 2.<bold>(A)</bold> Detection of single-split alignments as part of step 1. First, reads are aligned to the genome and candidate split alignments (<italic>A</italic>
<sub>1</sub>) are identified. Second, reads with candidate split alignments are re-aligned within a window around the initial alignment to determine a completing alignment (<italic>A</italic>
<sub>2</sub>). The use of smaller seed lengths than in the initial alignment allows recovering completing alignments shorter than the seed length used for the initial alignment. Finally, the alignments are combined to a complete split alignment. <bold>(B)</bold> Detection of multi-split alignments. For every candidate multi-split alignment, ContextMap 2 creates two fragments of the respective read sequence (i.e. <italic>f</italic>
<sub>1</sub> and <italic>f</italic>
<sub>2</sub> for <italic>A</italic>
<sub>1</sub> and <italic>f</italic>
<sub>3</sub> and <italic>f</italic>
<sub>4</sub> for <italic>A</italic>
<sub>2</sub>). Subsequently, single-split alignments are detected for these fragments. Finally, overlaps of single-split alignments are combined to obtain a complete multi-split alignment after first identifying the best splice site for each split alignment as part of the resolution of overlapping splice sites in step 4 of ContextMap 2.</p></caption><graphic xlink:href="12859_2015_557_Fig2_HTML" id="MO2"/></fig>
</p>
      <sec id="Sec4">
        <title>Step 1: Determination of initial alignments</title>
        <p>This step includes both the determination of ungapped read alignments against one or several genomes using the integrated short read alignment program, e.g. BWA, as well as the extension of these alignments to alignments containing a splice junction (= split read alignments, see Figure <xref rid="Fig1" ref-type="fig">1</xref>A). For this purpose, ContextMap 2 first performs a seeded alignment of all reads against the reference sequences with user defined seed values of 20-30 nt. Here, ContextMap 2 can use programs that determine only end-to-end alignments (e.g. Bowtie) as well as programs that also determine local alignments (e.g. Bowtie 2 and BWA). An end-to-end alignment starts at the read start and ends with the read end. In contrast, a local alignment allows unaligned prefixes or suffixes of the read if this improves the alignment score. In case an alignment program allows alignment of the seed only at the start of the read, such as Bowtie, a “backward” alignment with the reversed read is also performed for reads for which no alignment beginning at the read start could be found.</p>
        <p>Parameters of the underlying alignment program are set such that all alignments for which the seed can be aligned are retained, allowing for multiple alignments of each read. The resulting alignments are then classified into four categories:
<list list-type="order"><list-item><p><italic>Full alignment:</italic> if the read could be aligned end-to-end to the genome with a maximum number of mismatches (defined by the user).</p></list-item><list-item><p><italic>Candidate single-split alignment:</italic> if the seed could be aligned at the start or end of the read, the end-to-end alignment of the read contains more than the allowed number of mismatches and the last allowed mismatch is at least a predefined distance from the end of the alignment. If the integrated short read alignment program also produces local alignments, unaligned read positions are counted as mismatches for this classification.</p></list-item><list-item><p><italic>Partial alignment:</italic> if the same criteria apply as in (2) but the last allowed mismatch is less than the predefined distance from the alignment end.</p></list-item><list-item><p><italic>Candidate multi-split alignment:</italic> if only a local alignment could be determined with both a prefix and suffix of the read unaligned.</p></list-item></list>
</p>
        <p>Following this classification, candidate single-split and multi-split alignments are extended to complete split alignments as described further below.</p>
      </sec>
      <sec id="Sec5">
        <title>Step 2: Context definition</title>
        <p>The alignments identified in the previous step are used to define contexts. For this purpose, read alignments are clustered into a context if their start or end positions on the genome are at most a maximum distance apart (Figure <xref rid="Fig1" ref-type="fig">1</xref>B). Contexts are treated independently of each other until step 5. This allows both mapping read sequences against several reference genomes, e.g. of the human host and infecting pathogens [<xref ref-type="bibr" rid="CR16">16</xref>], as well as efficient parallelization of steps 3 and 4. Here, multiple alignments of each read to the same context or different contexts are allowed, which will be resolved in steps 4 and 5.</p>
      </sec>
      <sec id="Sec6">
        <title>Step 3: Alignment extension</title>
        <p>Once contexts have been defined, additional alignments are determined for each read based on the alignments found in the first step (Figure <xref rid="Fig1" ref-type="fig">1</xref>C). This alignment extension is performed in parallel for different contexts. Its objective is to identify all valid alignments for each read with a maximum number of mismatches, such that the best supported alignment can be selected in the subsequent steps.</p>
        <p>For this purpose, full and partial read alignments are checked for an overlap with split alignments of other reads. If overlaps are found, additional split alignments are created for the corresponding reads using the splice junctions indicated by the overlapping split alignments. Furthermore, all possible split alignments are generated for each read for which at least one split alignment was identified in step 1 (see Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Supplementary methods for details). In both cases, only alignments are used that do not exceed the maximum mismatch criterion. At the end of this step, several different alignments have been created for each read, resulting in multiple alignments both within and between contexts.</p>
      </sec>
      <sec id="Sec7">
        <title>Step 4: Local resolution of alignments within contexts</title>
        <p>In this step, the best alignment for each read is determined within each context by taking other read alignments into account (Figure <xref rid="Fig1" ref-type="fig">1</xref>D). For this purpose, the three best supported splice sites among overlapping splice sites are determined first. For this purpose, the following evidence score for each splice site is used:
<disp-formula id="Equ1"><label>(1)</label><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ evidence = \sum\limits_{i=0}^{m} \left(w^{i} \cdot n_{i}\right)  $$ \end{document}</tex-math><mml:math id="M2"><mml:mtext mathvariant="italic">evidence</mml:mtext><mml:mo>=</mml:mo><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:msup><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>·</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math><graphic xlink:href="12859_2015_557_Equ1.gif" position="anchor"/></alternatives></disp-formula>
</p>
        <p>Here, <italic>n</italic>
<sub><italic>i</italic></sub> is the number of reads (full, split or partial) with <italic>i</italic> mismatches supporting the splice site, <italic>m</italic> the maximum number of mismatches allowed and <italic>w</italic> a value &lt;1 (default <italic>w</italic>=0.3) (see Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Supplementary methods for details).</p>
        <p>Split read alignments not using any of the best supported splice sites are discarded. Subsequently, a support score is calculated for the remaining read alignments based on the number of reads aligned within and around the read alignment. In principle, the support score is a weighted sum of maximum read coverages in predefined windows around the read alignment (see Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Supplementary methods for details). Among several alternative alignments for the same read within each context, the one with the largest support score is then chosen.</p>
      </sec>
      <sec id="Sec8">
        <title>Step 5: Global resolution of alignments between contexts</title>
        <p>In this final step, multiple read alignments to several different contexts are resolved as in step 4 after recalculating support scores based on the read alignments chosen for each context (Figure <xref rid="Fig1" ref-type="fig">1</xref>E). Thus, at the end of each step, each read is aligned to only one position in (at most) one context. If more than one reference sequence was provided, this will also automatically result in the choice of one reference sequence of origin for each read.</p>
      </sec>
    </sec>
    <sec id="Sec9">
      <title>Plug-in structure of ContextMap 2</title>
      <p>ContextMap 2 provides a plug-in interface which allows integrating any short read alignment program without modification if it meets the following requirements:
<list list-type="order"><list-item><p>The alignment program has to support seeded alignments with adjustable seed lengths to allow use of different seed lengths in different steps of ContextMap 2.</p></list-item><list-item><p>The alignment program has to provide a tool to prepare an index of any reference sequence. Indexing reference sequences is a common strategy of all state-of-the-art short read alignment programs to speed up alignment.</p></list-item><list-item><p>If the read alignment program includes an option to identify indels, it must be possible to deactivate this option. ContextMap 2 uses its own context-based strategy for predicting the exact position of indels.</p></list-item><list-item><p>The output has to be in SAM format [<xref ref-type="bibr" rid="CR18">18</xref>].</p></list-item></list>
</p>
      <p>The interface for plugging in a short read alignment program into ContextMap 2 is composed of three methods, two for performing alignments at different steps of ContextMap 2 and one for indexing reference sequences.</p>
      <p>Implementing the interface requires implementing methods for managing the external program calls. In addition, the alignment methods have to collect the determined alignments. For this purpose, two classes can be reused that perform these tasks for Bowtie, Bowtie 2 and BWA, which have already been integrated in ContextMap 2.</p>
    </sec>
    <sec id="Sec10">
      <title>Detection of single-split alignments</title>
      <p>As part of step 1, ContextMap 2 extends candidate split alignments to single-split alignments, i.e. alignments crossing one exon-exon junction only, using a so-called sliding window approach (Figure <xref rid="Fig2" ref-type="fig">2</xref>A). This sliding window approach works in the following way: The sliding window is initiated at the left-most candidate split alignment on a chromosome and is extended to contain any overlapping alignment until a pre-defined maximum window length is exceeded. All candidate single-split alignments within this window are then extended to complete split alignments as described below. Afterwards, the current window is discarded and the next window is determined starting at the next candidate split alignment not completely contained in the previous window. This is repeated until all candidate split-alignments have been processed.</p>
      <p>To determine the complete split alignments within each window, an index is built for the used short read alignment program covering the part of the reference sequence within the current window. This sequence is extended by <italic>x</italic> nucleotides (<italic>x</italic>= average intron size, can be defined by the user) downstream of the window if a candidate split alignment with the seed at the read start ends too close to the window end (i.e. the distance is less than the average intron size <italic>x</italic>). This allows finding split alignments that start within the window but end downstream of the window end. Similarly, an upstream sequence is added to the index if a candidate split alignment with the seed at the read end begins too close to the window start.</p>
      <p>Using this dynamically built index and the corresponding short read alignment program, completing alignments of the unaligned read part are determined for each candidate split alignment within the sliding window (Figure <xref rid="Fig2" ref-type="fig">2</xref>A). This restricts the search space to a region covering only one or very few genes, allowing the use of smaller seed lengths of 10-15 nt. Since the window is very small and only a relatively small number of reads is covered by the window, this step is very fast. The original candidate split alignment and the completing alignment for each read are then combined into one split alignment and included in the set of initial alignments in addition to the full and partial alignments.</p>
    </sec>
    <sec id="Sec11">
      <title>Detection of multi-split alignments</title>
      <p>The detection of multi-split alignments, i.e. alignments crossing more than one exon-exon junction, is a novel feature of ContextMap 2. It is based on local alignment options of recently developed alignment programs such as Bowtie 2 or BWA. Essentially, the local alignments are used to fragment the reads into smaller segments for which single-split alignments are then determined (see Figure <xref rid="Fig2" ref-type="fig">2</xref>B). In contrast to other approaches that fragment all reads into smaller equal-sized segments, only reads for which a local alignment was determined, i.e. candidate multi-split alignments, are fragmented by ContextMap 2.</p>
      <p>For this purpose, candidate multi-split alignments (= local alignments with suffix and prefix of the read not aligned) to the same genomic region are collected using the same sliding window approach used for the single-split alignment detection. In fact, ContextMap uses a single run of the sliding window approach to process single- as well as multi-split alignments.</p>
      <p>For each candidate multi-split alignment in the current sliding window, two fragments of the read sequence are generated. If read <italic>r</italic>=<italic>r</italic>
<sub>1</sub>…<italic>r</italic>
<sub><italic>l</italic></sub> (<italic>l</italic>= read length) has been aligned at positions <italic>r</italic>
<sub><italic>i</italic></sub>…<italic>r</italic>
<sub><italic>j</italic></sub>, the first fragment consists of the subsequence <italic>f</italic>
<sub>1</sub>=<italic>r</italic>
<sub><italic>i</italic>−<italic>e</italic></sub>…<italic>r</italic>
<sub><italic>i</italic>−1</sub>
<italic>r</italic>
<sub><italic>i</italic></sub>…<italic>r</italic>
<sub><italic>j</italic></sub>, where <italic>e</italic> is the predefined minimum exon size (default 20 nt). If the unaligned prefix (<italic>r</italic>
<sub>1</sub>…<italic>r</italic>
<sub><italic>i</italic>−1</sub>) of the read is smaller than the minimum exon size <italic>e</italic>, <italic>f</italic>
<sub>1</sub>=<italic>r</italic>
<sub>1</sub>…<italic>r</italic>
<sub><italic>j</italic></sub>. Similarly, the second fragment is defined as <italic>f</italic>
<sub>2</sub>=<italic>r</italic>
<sub><italic>i</italic></sub>…<italic>r</italic>
<sub><italic>j</italic></sub>
<italic>r</italic>
<sub><italic>j</italic>+1</sub>…<italic>r</italic>
<sub><italic>j</italic>+<italic>e</italic></sub>. If the unaligned suffix of the read (<italic>r</italic>
<sub><italic>j</italic>+1</sub>…<italic>r</italic>
<sub><italic>l</italic></sub>) is shorter than <italic>e</italic>, <italic>f</italic>
<sub>2</sub>=<italic>r</italic>
<sub><italic>i</italic></sub>…<italic>r</italic>
<sub><italic>l</italic></sub>.</p>
      <p>The original local alignment then provides candidate split alignments for <italic>f</italic>
<sub>1</sub> and <italic>f</italic>
<sub>2</sub>. The completing alignments to these candidate split alignments are found within the sliding window as described in the previous section. This results in single-split alignments for the fragments, which are added to the list of initial alignments determined in step 1 of ContextMap 2 and extended to all valid single-split alignments of the fragments in step 3.</p>
      <p>The complete multi-split alignment of the whole read is determined in step 4 by merging overlaps of the single-split alignments for fragments of the same read after the resolution of pairwise overlapping splice sites. Thus, the precise location of the splice sites is first determined for the single-split alignments of the fragments before combining them to the complete multi-split alignments.</p>
    </sec>
    <sec id="Sec12">
      <title>Detection of indels</title>
      <p>Essentially, the prediction of reads containing a deletion to the reference is the same as detecting spliced reads with a very small intron size (see Figure <xref rid="Fig3" ref-type="fig">3</xref>A). Similarly, a read containing an insertion to the reference can be considered as a special case of a spliced read spanning an intron with negative length (see Figure <xref rid="Fig3" ref-type="fig">3</xref>B). Thus, detection of deletions and insertions could be incorporated seamlessly into the single- and multi-split alignment detection procedure of ContextMap 2 by allowing both small and negative intron lengths, respectively. Conveniently, this also allows the mapping of reads containing both indels and splice sites by finding the corresponding multi-split alignment.
<fig id="Fig3"><label>Figure 3</label><caption><p>Deletions and insertions in reads as special cases of spliced reads.<bold>(A)</bold> Example of a read with a deletion compared to the reference sequence. In this case, the alignment length <italic>d</italic> is larger than the read length <italic>l</italic> and the gap size is positive. <bold>(B)</bold> Example of a read with an insertion compared to the reference sequence. Here, the alignment length <italic>d</italic> on the reference sequence is smaller than the read length <italic>l</italic> and the gap size is negative.</p></caption><graphic xlink:href="12859_2015_557_Fig3_HTML" id="MO3"/></fig>
</p>
      <p>The distinction between indels and splice sites is only applied when preparing the output at the very end of the ContextMap 2 run. At this point, the gap size is determined for each split position in a single- or multi-split alignment (see Figure <xref rid="Fig3" ref-type="fig">3</xref>). The gap size is defined as <italic>d</italic>−<italic>l</italic>, where <italic>d</italic> is the alignment length on the reference genome and <italic>l</italic> is the read length. If the gap size is negative and its absolute value at most a user defined maximum insertion size (default = 10 nt), this split position is classified as an insertion. If the gap size is between 1 and a user defined maximum deletion size (default = 10 nt), it is classified as a deletion. If the gap size is between a user defined minimum intron size (default = 50 nt) and a user defined maximum intron size (default = 300,000 nt), the split is classified as an intron. Split alignments with gap sizes that do not fall into these ranges are not determined when detecting single- and multi-split alignments.</p>
    </sec>
  </sec>
  <sec id="Sec13">
    <title>Results and discussion</title>
    <sec id="Sec14">
      <title>Data sets and methods for evaluation</title>
      <p>Evaluation of ContextMap 2 was performed on simulated and real data previously used by the RGASP consortium for the systematic evaluation of RNA-seq mapping programs [<xref ref-type="bibr" rid="CR17">17</xref>] (see Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Table S1 for a summary). The simulated data was generated using the simulation program BEERS, which is provided with the RUM pipeline [<xref ref-type="bibr" rid="CR19">19</xref>]. Two data sets were simulated, each containing 80 million 76-nucleotide paired-end reads (= 40 million read pairs). The second data set is more challenging than the first as higher rates of substitution errors, indel polymorphisms and reads from unannotated isoforms were simulated. The real data consists of RNA-seq data of the human K562 cell line (whole cell, cytoplasmic and nuclear fraction) from the ENCODE project [<xref ref-type="bibr" rid="CR20">20</xref>] (2 replicates each, resulting in 6 samples). Each sample consisted of ∼200 million 76-nucleotide paired-end reads (∼100 million read pairs).</p>
      <p>We compared ContextMap 2 against the best performing RNA-seq mapping approaches identified in the RGASP study. These included MapSplice [<xref ref-type="bibr" rid="CR8">8</xref>], STAR [<xref ref-type="bibr" rid="CR11">11</xref>], and GSNAP [<xref ref-type="bibr" rid="CR12">12</xref>]. We also included TopHat [<xref ref-type="bibr" rid="CR6">6</xref>] (denoted as TopHat1 in the following) and Tophat2 [<xref ref-type="bibr" rid="CR7">7</xref>] as these are the most commonly used RNA-seq mapping programs. Mapping results of these programs on the used data sets as well as evaluation scripts were provided by the authors of the RGASP study (<ext-link ext-link-type="uri" xlink:href="https://github.com/RGASP-consortium/">https://github.com/RGASP-consortium/</ext-link>). For all programs, we evaluated the performance without and with an annotation (indicated by “ann”). For STAR, we evaluated both the 1- and 2-pass version. In the 2-pass version of STAR, splice junctions detected in the first run (1-pass) are taken as an input for a second run to improve mapping.</p>
      <p>We applied the same evaluation scripts to evaluate ContextMap 2 mapping runs using Bowtie (version 0.12.7), Bowtie 2 (version 2.1.0), or BWA (version 0.7.8) as internal short read alignment programs. Additionally, we evaluated the performance of ContextMap 2 using BWA and an annotation. Here, the annotation is only used for scoring splice junctions when resolving overlapping splice sites (see Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Supplementary methods). As for the RGASP evaluation, the annotation was taken from Ensembl version 62. Although we also performed evaluation of the original ContextMap implementation, we did not include it in the article as it performed worse in all evaluated metrics than ContextMap 2.</p>
      <p>For runtime comparison, we applied all RNA-seq mapping programs with the same parameter settings as described in the RGASP study. The only exception was MapSplice. In this case, an internal version of MapSplice was used in the RGASP study, which is not available for download. Most likely it was an unfinished predecessor of MapSplice 2, which has since been made publicly available (http://www.netlab.uky.edu/p/bioinfo/MapSplice2). It was not the published MapSplice 1.x version as options were used (e.g. detection of indels with length &gt;3) that this version does not support. We thus included an evaluation of MapSplice 2 in this article by applying it to all data sets using default parameters. Since MapSplice 2 uses the annotation only to detect fusion junctions between different genes, which was not simulated in the RGASP data sets, MapSplice 2 was only applied without annotation.</p>
    </sec>
    <sec id="Sec15">
      <title>Alignment yield</title>
      <p>As a first metric, we evaluated the fraction of mapped reads for both simulated data sets (see Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Table S2). This showed significant differences between RNA-seq mapping programs with GSNAP having the highest mapping rates (∼99% and 98% of the reads for simulation 1 and 2) and TopHat1/2 and ContextMap 2 having lowest mapping rates (89-96% of reads mapped in simulation 1 and 78-88% in simulation 2).</p>
      <p>When investigating the fraction of reads mapped either perfectly, part correctly or with no base correct (Figure <xref rid="Fig4" ref-type="fig">4</xref> and Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Table S2), it became apparent that mapping rates alone are not meaningful for comparing the performance of algorithms. Despite GSNAP’s high overall mapping rate, the fraction of perfectly mapped reads was only 89% and 76% of reads of simulation 1 and 2, respectively. In contrast, ContextMap 2 using BWA mapped almost 95% and 87% of reads perfectly, which was better than for all other evaluated methods except MapSplice 2. Consistently, both the fraction of part correctly mapped reads and reads with no base mapped correctly were lower than for all other methods (see also Figure <xref rid="Fig4" ref-type="fig">4</xref>). Thus, the higher mapping rates of other programs came at the cost of higher error rates.
<fig id="Fig4"><label>Figure 4</label><caption><p>Fraction of perfectly mapped, part correctly mapped and incorrectly mapped reads for simulated unspliced <bold>(A)</bold> and spliced <bold>(B)</bold> reads of simulation 1 and 2, respectively. “CM Bwt1”, “CM Bwt2”, “CM Bwa” denote ContextMap 2 used with Bowtie, Bowtie 2, and BWA as underlying alignment program, respectively. If a gene annotation was provided, “ann” was added to the name of the respective program.</p></caption><graphic xlink:href="12859_2015_557_Fig4_HTML" id="MO4"/></fig>
</p>
      <p>To investigate whether performance differed between unspliced and spliced reads, mapping rates were also calculated separately for both types of reads (Figure <xref rid="Fig4" ref-type="fig">4</xref> and Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Tables S3 and S4). Indeed, the evaluated programs differed considerably in performance between spliced and unspliced reads but not in any consistent fashion. For ContextMap 2 using Bowtie, MapSplice, STAR 1-pass, TopHat1 and GSNAP (and TopHat2 on simulation 1), the fraction of reads mapped completely wrong increased by more than 0.5 percentage points for spliced reads compared to unspliced reads. In contrast, this fraction did increase less for ContextMap 2 using Bowtie 2 or BWA (and TopHat2 on simulation 2) and even decreased for the remaining tools. In all cases, however, the number of part correctly mapped reads increased for spliced reads, but least for ContextMap 2 and TopHat2. This was likely due to a part of the read on one side of the splice junction not being mapped correctly or not at all (e.g. in case of STAR, which can also output clipped alignments). In particular for STAR and GSNAP, this lead to 10-50% part correctly mapped reads.</p>
      <p>In summary, these results show that ContextMap 2 using BWA had the lowest rate of incorrectly mapped reads among all evaluated programs. Furthermore, it mapped more reads perfectly than any of the other programs except MapSplice 2. However, MapSplice 2 had ∼2-fold higher rates of incorrectly mapped reads.</p>
      <p>Interestingly, we observed that the choice of the underlying alignment program had a significant influence on the performance in RNA-seq mapping. Both rates of perfectly and incorrectly mapped reads are improved significantly when using BWA within ContextMap 2 instead of either Bowtie or Bowtie 2. The reduced number of perfectly mapped reads for Bowtie is mostly due to its lower overall recall [<xref ref-type="bibr" rid="CR14">14</xref>] and the fact that it does not determine local alignments and thus does not support the detection of multi-split read alignments and indels within ContextMap 2. The higher number of incorrectly mapped spliced reads results from spliced reads for which the seed at the read start cannot be aligned at the correct position, e.g. because the splice site in the read is closer to the read start than the seed length, but the seed can be aligned to a wrong position. In this case, no backward alignment is performed for the read in order to reduce runtime and only the incorrect alignments are further analyzed.</p>
      <p>The lower mapping quality using Bowtie 2 compared to BWA resulted from the fact that – in contrast to Bowtie and BWA – Bowtie 2 has a dramatically increased runtime if the maximum number of valid alignments reported per read (-k option) is set to even moderately high values. Thus, per default we used a relatively low value of <italic>k</italic>=3. Using a value of <italic>k</italic>=10 resulted in comparable mapping quality to ContextMap 2 with BWA (see Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Tables S2, S3 and S4) but runtime increased by at least 8 h compared to BWA or Bowtie 2 with <italic>k</italic>=3 (Table <xref rid="Tab1" ref-type="table">1</xref>).
<table-wrap id="Tab1"><label>Table 1</label><caption><p><bold>Runtime in CPU hours for each program on simulation 1 and 2</bold></p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left"><bold>Program</bold></th><th align="left"><bold>Simulation 1</bold></th><th align="left"><bold>Simulation 2</bold></th></tr></thead><tbody><tr><td align="left">ContextMap Bwt1</td><td align="left">11.67</td><td align="left">11.02</td></tr><tr><td align="left">ContextMap Bwt2 (<italic>k</italic>=3, default)</td><td align="left">16.47</td><td align="left">15.58</td></tr><tr><td align="left">ContextMap Bwt2 (<italic>k</italic>=10)</td><td align="left">24.98</td><td align="left">24.55</td></tr><tr><td align="left">ContextMap Bwa</td><td align="left">11.58</td><td align="left">14.00</td></tr><tr><td align="left">ContextMap Bwa ann</td><td align="left">11.92</td><td align="left">14.15</td></tr><tr><td align="left">MapSplice 2</td><td align="left">31.43</td><td align="left">28.62</td></tr><tr><td align="left">STAR 1-pass</td><td align="left">0.82</td><td align="left">1.28</td></tr><tr><td align="left">STAR 1-pass ann</td><td align="left">1.05</td><td align="left">1.58</td></tr><tr><td align="left">STAR 2-pass</td><td align="left">9.60</td><td align="left">10.28</td></tr><tr><td align="left">STAR 2-pass ann</td><td align="left">9.57</td><td align="left">10.80</td></tr><tr><td align="left">TopHat1</td><td align="left">20.1</td><td align="left">28.43</td></tr><tr><td align="left">TopHat1 ann</td><td align="left">20.53</td><td align="left">29.03</td></tr><tr><td align="left">TopHat2</td><td align="left">25.17</td><td align="left">27.23</td></tr><tr><td align="left">TopHat2 ann</td><td align="left">34.32</td><td align="left">39.68</td></tr><tr><td align="left">GSNAP</td><td align="left">147.73</td><td align="left">128.15</td></tr><tr><td align="left">GSNAP ann</td><td align="left">160.78</td><td align="left">140.27</td></tr></tbody></table><table-wrap-foot><p>All methods were run using 8 cores on the same machines and with the same parameter settings as in the RGASP evaluation [<xref ref-type="bibr" rid="CR17">17</xref>]. ContextMap 2 with Bowtie 2 was run with the maximum number of alignments reported per read (<italic>k</italic>) set to 3 (default setting used for evaluating mapping quality) and 10, respectively. Runtime of STAR 2-pass includes the time required for running STAR 1-pass, indexing the genome with splice sites found in the first STAR run and re-running STAR.</p></table-wrap-foot></table-wrap>
</p>
    </sec>
    <sec id="Sec16">
      <title>Alignment yield on real-life RNA-seq data</title>
      <p>Consistent with evaluation results on simulated data, alignment yield of ContextMap 2 was lower on all samples for the K562 cell line than for MapSplice 2, STAR or GSNAP, but similar or slightly higher than for TopHat1/2 (Figure <xref rid="Fig5" ref-type="fig">5</xref> and Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S4). This was only partly due to the relatively small number of mismatches (= 4) allowed per default in ContextMap 2.
<fig id="Fig5"><label>Figure 5</label><caption><p>Percentage of mapped reads and mismatch distribution for the mapped reads for both replicates of the K562 whole cell RNA-seq samples. Results for all real-life samples are shown in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S4.</p></caption><graphic xlink:href="12859_2015_557_Fig5_HTML" id="MO5"/></fig>
</p>
      <p>Nevertheless, the ranking of algorithms with regard to the number of mapped reads is quite similar to the ranking on the simulated data. Thus, if we also extrapolate the results on perfectly and incorrectly mapped reads from the simulation to the real-life data, this would suggest that the difference in mapped reads between ContextMap 2 and most other mapping programs are to a large extent due to incorrect mappings identified by the other programs.</p>
    </sec>
    <sec id="Sec17">
      <title>Spliced alignment</title>
      <p>Since performance on spliced reads showed the largest differences among the mapping approaches, these were analyzed in more detail (Figure <xref rid="Fig6" ref-type="fig">6</xref>A and Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S5). For this purpose, splice recall and false discovery rate (FDR) were calculated as in the original RGASP study. Here, splice recall is defined as
<disp-formula id="Equ2"><label>(2)</label><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ \begin{aligned} \text{recall}&amp;=\frac{\# \textrm{true positive splices}}{\# \textrm{simulated splices}} \\ &amp;=\frac{\# \textrm{true positive splices}}{\# \textrm{true pos. splices} + \# \textrm{false neg. splices}}. \end{aligned}  $$ \end{document}</tex-math><mml:math id="M4"><mml:mtable><mml:mtr><mml:mtd><mml:mtext>recall</mml:mtext></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>#</mml:mi><mml:mtext>true positive splices</mml:mtext></mml:mrow><mml:mrow><mml:mi>#</mml:mi><mml:mtext>simulated splices</mml:mtext></mml:mrow></mml:mfrac></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>#</mml:mi><mml:mtext>true positive splices</mml:mtext></mml:mrow><mml:mrow><mml:mi>#</mml:mi><mml:mtext>true pos. splices</mml:mtext><mml:mo>+</mml:mo><mml:mi>#</mml:mi><mml:mtext>false neg. splices</mml:mtext></mml:mrow></mml:mfrac><mml:mi>.</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="12859_2015_557_Equ2.gif" position="anchor"/></alternatives></disp-formula>
<fig id="Fig6"><label>Figure 6</label><caption><p>Evaluation of splice junction prediction.<bold>(A)</bold> Comparison of splice recall (y-axis) versus splice false discovery rate (FDR=1-precision, x-axis) on simulation 1 and 2 (see equations <xref rid="Equ2" ref-type="">2</xref> and <xref rid="Equ3" ref-type="">3</xref> for definitions). For the human data sets, the frequency of predicted novel splices was compared to the frequency of annotated splices for the Ensembl annotation (see text for definitions, Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S5 for results for all real-life data sets). Furthermore, the number of identified annotated and novel junctions was evaluated (see Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S6 for results for all data sets). To obtain receiver operation characteristic (ROC)-like curves, numbers were also calculated at increasing thresholds on the number of supporting reads for each junction. <bold>(B)</bold> Number of correctly predicted (true) and incorrectly (false) junctions were compared for all junctions and annotated and novel junctions separately. In contrast to the RGASP evaluation, we also included junctions covered by only 1 read. ROC-like curves were calculated as in <bold>A</bold>. <bold>(A-B)</bold> For ContextMap 2 only results using BWA are shown, results for Bowtie and Bowtie 2 can be found in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figures S5 and S6 (for <bold>A</bold>) and S7 (for <bold>B</bold>).</p></caption><graphic xlink:href="12859_2015_557_Fig6_HTML" id="MO6"/></fig>
</p>
      <p>In this case, a splice is defined as one junction in one particular read. Thus, if a simulated junction within a read is recovered by the alignment for this read, it is considered a true positive splice. If it is not recovered, it is a false negative splice. If the alignment contains a junction that was not simulated for this read, it is considered a false positive splice. FDR is then defined as 1 - precision, with
<disp-formula id="Equ3"><label>(3)</label><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ \begin{aligned} \text{precision}&amp;=\frac{\# \textrm{true positive splices}}{\# \textrm{predicted splices}} \\ &amp;=\frac{\# \textrm{true positive splices}}{\# \textrm{true pos. splices} + \# \textrm{false pos. splices}}. \end{aligned}  $$ \end{document}</tex-math><mml:math id="M6"><mml:mtable><mml:mtr><mml:mtd><mml:mtext>precision</mml:mtext></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>#</mml:mi><mml:mtext>true positive splices</mml:mtext></mml:mrow><mml:mrow><mml:mi>#</mml:mi><mml:mtext>predicted splices</mml:mtext></mml:mrow></mml:mfrac></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>#</mml:mi><mml:mtext>true positive splices</mml:mtext></mml:mrow><mml:mrow><mml:mi>#</mml:mi><mml:mtext>true pos. splices</mml:mtext><mml:mo>+</mml:mo><mml:mi>#</mml:mi><mml:mtext>false pos. splices</mml:mtext></mml:mrow></mml:mfrac><mml:mi>.</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="12859_2015_557_Equ3.gif" position="anchor"/></alternatives></disp-formula>
</p>
      <p>For the real data, recall and FDR could not be calculated as the correct mapping was not known. Instead, the fraction of reads mapping to an annotated splice junction (=: frequency of annotated splices) was compared to the fraction of reads mapping to a novel splice junction (=: frequency of novel splices).</p>
      <p>Consistent with the evaluation of alignment yield, this analysis showed that ContextMap 2 combined low FDR with high recall. Again the combination with BWA performed best. Although some of the other mapping programs showed higher recall, this was always accompanied by significantly higher FDR. Generally, the increase in recall compared to ContextMap 2 was only modest with the exception of annotation-based GSNAP on simulation 2.</p>
      <p>The analysis of known and novel splices identified in the real data set showed that ContextMap 2 mapped reads to novel splices with similar frequency as most other programs except STAR 2-pass (Figure <xref rid="Fig6" ref-type="fig">6</xref>A and Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S5). In contrast, reads were mapped to known splice junctions less frequently compared to most programs using an annotation and more frequently than most programs without annotation. Unfortunately, these results are difficult to interpret as alignments to novel junctions are not necessarily wrong and alignments to annotated junctions not necessarily right.</p>
      <p>To address this problem we also compared the number of novel and annotated junctions predicted by all methods between the simulations and the real data sets (Figure <xref rid="Fig6" ref-type="fig">6</xref>A and Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S6). Here, the same junction (in terms of the genomic coordinates) identified for several reads was counted only once. This consistently showed that ContextMap 2 predicted significantly fewer novel junctions than STAR and GSNAP (&gt;50% less). Here, ContextMap 2 using BWA or Bowtie 2 and MapSplice showed quite similar performance, whereas annotation-based ContextMap 2 using BWA and, in particular, annotation-based TopHat2 predicted significantly more annotated junctions. Interestingly, annotation-based ContextMap 2 identified almost precisely the correct number of annotated and novel junctions for both simulations. The high similarity of the results between simulation and real data indicates that recall and FDR from the simulations can again be extrapolated to the real data sets. This would suggest that ContextMap 2 using BWA (both with and without an annotation) correctly identifies more reads with known junctions than programs not using an annotation but is less biased towards annotated junctions than other programs using an annotation.</p>
      <p>This conclusion is also supported by the comparison of the number of correctly predicted junctions to false junctions (Figure <xref rid="Fig6" ref-type="fig">6</xref>B and Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S7). This again shows that ContextMap 2 (in particular when using BWA) predicts much fewer false junctions than approaches using an annotation, while missing relatively few of the true junctions. For novel junctions ContextMap 2 is only outperformed in terms of recall and FDR by MapSplice 2, but the difference in performance is relatively small. For annotated junctions, the ContextMap 2 version without annotation performs almost as good as MapSplice 2, which has the lowest FDR, whereas the version using the annotation has a significantly higher recall but also predicts more false junctions. Again, this highlights the problem in using an annotation, which might bias the results towards known junctions. Nevertheless, ContextMap 2 appears to be less biased by the annotation than STAR, GSNAP or Tophat2.</p>
    </sec>
    <sec id="Sec18">
      <title>Detection of multi-junction reads</title>
      <p>Since ContextMap 2 now also supports mapping of reads crossing multiple junctions, we calculated recall and precision separately for reads containing different number of junctions (Table <xref rid="Tab2" ref-type="table">2</xref> and Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Table S5). For this purpose, a read was considered a true positive if all junctions in this read were identified correctly and no additional junctions were predicted. If a different number of junctions were predicted than correct, it was considered a false negative for this junction number and a false positive for the junction number predicted by the alignment. If the correct number of junctions were predicted for the read, but some of the junctions were wrong, it was considered a false positive for this junction number. To evaluate the trade-off between precision and recall, we calculated F-measure values defined as
<disp-formula id="Equ4"><label>(4)</label><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ F-measure= 2\cdot \frac{precision \cdot recall}{precision +recall}.  $$ \end{document}</tex-math><mml:math id="M8"><mml:mi>F</mml:mi><mml:mo>−</mml:mo><mml:mtext mathvariant="italic">measure</mml:mtext><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>·</mml:mo><mml:mfrac><mml:mrow><mml:mtext mathvariant="italic">precision</mml:mtext><mml:mo>·</mml:mo><mml:mtext mathvariant="italic">recall</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">precision</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">recall</mml:mtext></mml:mrow></mml:mfrac><mml:mi>.</mml:mi></mml:math><graphic xlink:href="12859_2015_557_Equ4.gif" position="anchor"/></alternatives></disp-formula>
<table-wrap id="Tab2"><label>Table 2</label><caption><p><bold>F-measure [in %] for spliced reads with different number of spanned junctions for simulation 1</bold></p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left"><bold>Program</bold></th><th align="left" colspan="5"><bold>Number of junctions spanned</bold></th></tr><tr><th align="left"/><th align="left"><bold>1 (13808336)</bold></th><th align="left"><bold>2 (598297)</bold></th><th align="left"><bold>3 (11781)</bold></th><th align="left"><bold>2* (548382)</bold></th><th align="left"><bold>3* (6908)</bold></th></tr></thead><tbody><tr><td align="left">CM Bwt1</td><td align="center">91.47</td><td align="center">14.24</td><td align="center">-</td><td align="center">15.16</td><td align="center">-</td></tr><tr><td align="left">CM Bwt2</td><td align="center">94.03</td><td align="center">78.47</td><td align="center">50.21</td><td align="center">82.37</td><td align="center">72.66</td></tr><tr><td align="left">CM Bwa</td><td align="center">95.03</td><td align="center">82.73</td><td align="center">53.33</td><td align="center">86.67</td><td align="center">76.46</td></tr><tr><td align="left">CM Bwa ann</td><td align="center">95.74</td><td align="center">84.65</td><td align="center">53.9</td><td align="center">88.47</td><td align="center">76.79</td></tr><tr><td align="left">MapSplice 2</td><td align="center">92.42</td><td align="center">79.18</td><td align="center">27.27</td><td align="center">80.65</td><td align="center">3.44</td></tr><tr><td align="left">STAR 1-pass</td><td align="center">77.63</td><td align="center">30.91</td><td align="center">5.01</td><td align="center">31.91</td><td align="center">1.49</td></tr><tr><td align="left">STAR 1-pass ann</td><td align="center">93.55</td><td align="center">81.65</td><td align="center">75.71</td><td align="center">82.57</td><td align="center">82.17</td></tr><tr><td align="left">STAR 2-pass</td><td align="center">95.0</td><td align="center">85.55</td><td align="center">82.07</td><td align="center">86.59</td><td align="center">87.29</td></tr><tr><td align="left">STAR 2-pass ann</td><td align="center">95.07</td><td align="center">86.28</td><td align="center">82.55</td><td align="center">87.02</td><td align="center">86.49</td></tr><tr><td align="left">TopHat1</td><td align="center">87.83</td><td align="center">77.51</td><td align="center">63.57</td><td align="center">80.42</td><td align="center">75.56</td></tr><tr><td align="left">TopHat1 ann</td><td align="center">88.02</td><td align="center">78.99</td><td align="center">68.13</td><td align="center">81.06</td><td align="center">76.1</td></tr><tr><td align="left">TopHat2</td><td align="center">91.71</td><td align="center">87.0</td><td align="center">76.92</td><td align="center">89.66</td><td align="center">88.51</td></tr><tr><td align="left">TopHat2 ann</td><td align="center">94.84</td><td align="center">90.79</td><td align="center">85.92</td><td align="center">92.05</td><td align="center">90.35</td></tr><tr><td align="left">GSNAP</td><td align="center">83.13</td><td align="center">43.45</td><td align="center">18.52</td><td align="center">42.35</td><td align="center">12.29</td></tr><tr><td align="left">GSNAP ann</td><td align="center">96.47</td><td align="center">88.59</td><td align="center">79.51</td><td align="center">89.86</td><td align="center">84.67</td></tr></tbody></table><table-wrap-foot><p><sup>*</sup>The last two columns show results only for reads for which all exons except the first and last exon had length ≥ 20 nt. For this evaluation, read alignments were only considered a true positive if all simulated splice junctions in the read were recovered and no additional splice junctions were identified. Indels were ignored for this purpose. Recall and precision values for both simulations can be found in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Table S5.</p></table-wrap-foot></table-wrap>
</p>
      <p>This showed that ContextMap 2 using BWA (both with and without annotation) outperformed all other programs on reads containing only one junction except STAR 2-pass and annotation-based GSNAP. This includes the vast majority of all spliced reads. Here, only annotation-based GSNAP performed significantly better, at least on simulation 2. In general, F-measure decreased with increasing number of junctions for all programs, mostly due to lower recall values. Precision generally remained above 90%. For reads with two junctions, ContextMap 2 with BWA was still only outperformed by STAR 2-pass, annotation-based GSNAP and now also annotation-based Tophat2, but the difference in recall to these programs increased.</p>
      <p>For three junctions, however, recall and thus F-measure of ContextMap 2 using BWA or Bowtie 2 dropped dramatically, such that only MapSplice 2, STAR 1-pass and GSNAP (both without annotation) performed worse. Since Bowtie does not perform local alignment, ContextMap using Bowtie cannot identify multi-split alignments and therefore had zero recall on three-junction reads. A small number of two-junction reads were mapped as single-split alignments are extended to multi-split alignments in step 3 of ContextMap 2 if they overlap an additional splice site.</p>
      <p>Since ContextMap 2 by default only determines multi-split alignments for which internal exons are at least 20 nt long (= minimum exon size <italic>e</italic>), we repeated the analysis only for multi-junction reads fulfilling this condition. The results of this analysis are shown in the last two columns of Table <xref rid="Tab2" ref-type="table">2</xref> and Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Table S5. Here, ContextMap 2 using BWA showed a significant improvement, resulting in similar or better performance for two-junction reads than all programs except TopHat2 on simulation 1 and annotation-based GSNAP. For three-junction reads, recall of ContextMap 2 was almost doubled, whereas for other programs improvements were less pronounced and recall of MapSplice 2 actually decreased to &lt;2%. In addition, ContextMap 2 using BWA generally showed a significantly higher precision than the programs with particularly high recall.</p>
    </sec>
    <sec id="Sec19">
      <title>Indel accuracy</title>
      <p>Precision, recall and F-measure values were also calculated separately for reads containing insertions and deletions (Figure <xref rid="Fig7" ref-type="fig">7</xref>, Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S8, and Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Tables S6 and S7). These results show that ContextMap 2 using BWA outperforms all other approaches on both insertions and deletions except for GSNAP (both with and without annotation) and annotation-based TopHat2. Furthermore, the latter programs only performed comparably well to ContextMap 2 on reads with small indel size (1-4, depending on the method). In almost all cases, precision of ContextMap 2 using BWA was above 90% and higher than for the best competing programs. Similar to multi-junction reads, the integration of Bowtie or Bowtie 2 in ContextMap 2 resulted in worse performance on indels than for BWA, in particular for longer insertions.
<fig id="Fig7"><label>Figure 7</label><caption><p>F-Measure [in %] for insertion and deletions identified by all programs on simulation 1. NaN indicates that no insertion or deletion of that size was identified. Insertion and deletion size are shown below each column of the heatmap. The numbers in parentheses indicate the number of simulated reads for each insertion or deletion size. Results for simulation 2 are shown in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S8. Recall and precision values are listed in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Tables S6 and S7.</p></caption><graphic xlink:href="12859_2015_557_Fig7_HTML" id="MO7"/></fig>
</p>
      <p>Numbers of detected indels and indel length were also evaluated on the real-life sequencing data (Figure <xref rid="Fig8" ref-type="fig">8</xref> and Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figures S9 and S10). Consistent with their higher recall on the simulations, ContextMap 2 using BWA, TopHat2 and GSNAP mapped at least twice as many reads with insertions than the other programs. Interestingly, numbers of mapped insertions generally decreased significantly for TopHat2 and GSNAP when not using an annotation, while there were hardly changed for ContextMap 2 using BWA. Since simulation results showed higher precision for annotation-based GSNAP and TopHat2 compared to the runs without annotation but not lower recall, this indicates that the lost mappings were largely false positive results. Furthermore, even compared to annotation-based GSNAP and TopHat2, precision of ContextMap 2 was higher on the simulations (in particular for long insertions, which were enriched among TopHat2 results) indicating that many of the insertions additionally identified by these competing tools were not correct.
<fig id="Fig8"><label>Figure 8</label><caption><p>Fraction of mapped reads with different indel sizes among all reads with indels for the first replicate of the K562 whole cell sample. Numbers next to the barplots indicate the number of mapped reads with indels divided by 10<sup>5</sup> (i.e. number of reads per 100,000). Results for all samples are shown in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figures S9 and S10.</p></caption><graphic xlink:href="12859_2015_557_Fig8_HTML" id="MO8"/></fig>
</p>
      <p>With regard to deletions, only GSNAP consistently recovered more reads with deletions than ContextMap 2 using BWA and again numbers decreased for annotation-based GSNAP. As the latter had both higher recall and precision on the simulations than GSNAP alone, this again suggests that the difference in mapped reads between GSNAP with and without annotation were false positives. Compared to ContextMap 2, annotation-based GSNAP identified a higher fraction of longer deletions. As the simulations showed a significantly lower precision, in particular on long deletions, for GSNAP, this again indicates that a significant fraction of the additional reads with deletions identified by annotation-based GSNAP are incorrectly mapped.</p>
    </sec>
    <sec id="Sec20">
      <title>Runtime comparison</title>
      <p>Finally, we compared runtime between all evaluated programs on the simulated data sets (Table <xref rid="Tab1" ref-type="table">1</xref>). Here, ContextMap 2 was much faster than all evaluated programs except STAR 1- and 2-pass. Here, STAR 1-pass was extremely fast, whereas STAR 2-pass was only ∼20-24% faster than ContextMap 2. However, the evaluation on the RGASP data showed that this improved runtime came at the cost of both lower precision and recall for all STAR variants, in particular STAR 1-pass, compared to ContextMap 2.</p>
      <p>Highest runtime of all evaluated approaches was observed for GSNAP with &gt;128 CPU hours, i.e. more than 5 days. Thus, although it performed well on the detection of multi-junction reads and indels, runtime is too large for practical purposes. Among the remaining competing approaches, MapSplice 2 performed best in the evaluation of alignment quality, but not consistently better than ContextMap 2 using BWA. With regard to runtime, however, it performed significantly worse with ∼30 CPU hours on both simulations compared to 11-16 CPU hours used by ContextMap 2. Here, lowest runtime was observed when using Bowtie and highest using Bowtie 2, in particular when increasing the maximum number of reported alignments <italic>k</italic> to 10. Thus, BWA is the best choice as integral alignment algorithm for ContextMap 2 taking into account mapping quality and runtime.</p>
    </sec>
  </sec>
  <sec id="Sec21" sec-type="conclusion">
    <title>Conclusion</title>
    <p>In this article, we presented ContextMap 2, a new and improved version of the context-based RNA-seq mapping program ContextMap. The key novel features of ContextMap 2 are the plug-in structure, which allows integrating new developments in short read alignment, as well as the detection of multi-split alignments, insertions and deletions. Performance of ContextMap 2 integrating either Bowtie, Bowtie 2 or BWA was evaluated on data sets from the recent RGASP evaluation of RNA-seq mapping programs and compared to the best performers of this study.</p>
    <p>This showed that performance of RNA-seq mapping can be improved substantially by replacing the internal short read alignment program by more recent methods or versions. In this case, the use of BWA as integral alignment program generally improved recall and precision of ContextMap 2 compared to Bowtie and Bowtie 2 at only slightly higher or even lower runtime, respectively. Here, the plug-in structure of ContextMap 2 allows the extension to future versions of these alignment programs or even newly developed short read alignment programs with improved accuracy or runtime. Furthermore, this extension can also be performed by developers of such programs or other users of ContextMap 2 by simply implementing the interface. In contrast, other existing RNA-seq alignment programs are limited to one or at most two short read alignment programs. For instance, MapSplice 2 still uses only Bowtie and TopHat2 only supports Bowtie and Bowtie 2.</p>
    <p>ContextMap 2 with BWA performed similarly well or better than other state-of-the-art RNA-seq mapping programs with regard to perfectly mapped reads on simulated data, while having at least ∼2-fold lower rates of reads mapped only part correctly or at completely wrong positions. Thus, reduced mapping rates of ContexMap 2 on both simulated and real data can be mostly explained by lower rates of incorrectly mapped reads. ContextMap 2 using BWA showed high precision and recall on all evaluated tasks, in particular on the detection of long insertions and deletions. Furthermore, runtime was generally at least 50% lower than for the best competing programs. Only STAR 1- and 2-pass were faster, but showed significantly lower precision, in particular on spliced reads and splice junctions, and low recall on reads containing indels.</p>
  </sec>
  <sec id="Sec22">
    <title>Availability and requirements</title>
    <p><bold>Project name:</bold> ContextMap 2 <bold>Project home page:</bold>
http://www.bio.ifi.lmu.de/ContextMap
<bold>Operating system(s):</bold> Platform independent <bold>Programming language:</bold> Java <bold>Other requirements:</bold> Java 7 or higher; one of the following: Bowtie version 0.12.7 or higher, Bowtie 2 version 2.1.0 or higher, BWA version 0.7.8 or higher <bold>License:</bold> Artistic License <bold>Any restrictions to use by non-academics:</bold> none</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Additional file</title>
    <sec id="Sec23">
      <p>
        <supplementary-material content-type="local-data" id="MOESM1">
          <media xlink:href="12859_2015_557_MOESM1_ESM.pdf">
            <label>Additional file 1</label>
            <caption>
              <p><bold>Supplementary material.</bold> Supplementary material contains Supplementary methods, Figures and Tables.</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
    </sec>
  </sec>
</body>
<back>
  <fn-group>
    <fn>
      <p>
        <bold>Competing interests</bold>
      </p>
      <p>The authors declare that they have no competing interests.</p>
    </fn>
    <fn>
      <p>
        <bold>Authors’ contributions</bold>
      </p>
      <p>TB implemented ContextMap 2 based on the original ContextMap prototype developed by GC and performed evaluation of all programs. TB and CCF analyzed and discussed the results. EK implemented the user interface and prepared the user manual. TB and CCF drafted the manuscript and GC and RZ helped in manuscript revision. All authors read and approved the final manuscript.</p>
    </fn>
  </fn-group>
  <ack>
    <title>Acknowledgements</title>
    <p>This work is supported by the Deutsche Forschungsgesellschaft (DFG) under grants FR2938/1-1 and FR2938/1-2 to CCF.</p>
  </ack>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Gerstein</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Snyder</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>RNA-Seq: a revolutionary tool for transcriptomics</article-title>
        <source>Nat Rev Genet</source>
        <year>2009</year>
        <volume>10</volume>
        <issue>1</issue>
        <fpage>57</fpage>
        <lpage>63</lpage>
        <pub-id pub-id-type="doi">10.1038/nrg2484</pub-id>
        <pub-id pub-id-type="pmid">19015660</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ozsolak</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Milos</surname>
            <given-names>PM</given-names>
          </name>
        </person-group>
        <article-title>RNA sequencing: advances, challenges and opportunities</article-title>
        <source>Nat Rev Genet</source>
        <year>2011</year>
        <volume>12</volume>
        <issue>2</issue>
        <fpage>87</fpage>
        <lpage>98</lpage>
        <pub-id pub-id-type="doi">10.1038/nrg2934</pub-id>
        <pub-id pub-id-type="pmid">21191423</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Garber</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Grabherr</surname>
            <given-names>MG</given-names>
          </name>
          <name>
            <surname>Guttman</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Trapnell</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Computational methods for transcriptome annotation and quantification using RNA-seq</article-title>
        <source>Nat Methods</source>
        <year>2011</year>
        <volume>8</volume>
        <issue>6</issue>
        <fpage>469</fpage>
        <lpage>77</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.1613</pub-id>
        <pub-id pub-id-type="pmid">21623353</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Djebali</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Davis</surname>
            <given-names>CA</given-names>
          </name>
          <name>
            <surname>Merkel</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Dobin</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Lassmann</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Mortazavi</surname>
            <given-names>A</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Landscape of transcription in human cells</article-title>
        <source>Nature</source>
        <year>2012</year>
        <volume>489</volume>
        <issue>7414</issue>
        <fpage>101</fpage>
        <lpage>8</lpage>
        <pub-id pub-id-type="doi">10.1038/nature11233</pub-id>
        <pub-id pub-id-type="pmid">22955620</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Langmead</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Trapnell</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Pop</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</article-title>
        <source>Genome Biol</source>
        <year>2009</year>
        <volume>10</volume>
        <issue>3</issue>
        <fpage>25</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2009-10-3-r25</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Trapnell</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Pachter</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>TopHat: discovering splice junctions with RNA-Seq</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>9</issue>
        <fpage>1105</fpage>
        <lpage>11</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp120</pub-id>
        <pub-id pub-id-type="pmid">19289445</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kim</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Pertea</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Trapnell</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Pimentel</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Kelley</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>TopHat2: accurate alignment of transcriptomes in the presence of insertions, deletions and gene fusions</article-title>
        <source>Genome Biol</source>
        <year>2013</year>
        <volume>14</volume>
        <issue>4</issue>
        <fpage>36</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2013-14-4-r36</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Singh</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Zeng</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Coleman</surname>
            <given-names>SJ</given-names>
          </name>
          <name>
            <surname>Huang</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Savich</surname>
            <given-names>GL</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>MapSplice: accurate mapping of RNA-seq reads for splice junction discovery</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2010</year>
        <volume>38</volume>
        <issue>18</issue>
        <fpage>178</fpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkq622</pub-id>
        <pub-id pub-id-type="pmid">20817676</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Alamancos</surname>
            <given-names>GP</given-names>
          </name>
          <name>
            <surname>Agirre</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Eyras</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Methods to study splicing from high-throughput RNA sequencing data</article-title>
        <source>Methods Mol Biol.</source>
        <year>2014</year>
        <volume>1126</volume>
        <fpage>357</fpage>
        <lpage>97</lpage>
        <pub-id pub-id-type="doi">10.1007/978-1-62703-980-2_26</pub-id>
        <pub-id pub-id-type="pmid">24549677</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Langmead</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>Fast gapped-read alignment with Bowtie 2</article-title>
        <source>Nat Methods</source>
        <year>2012</year>
        <volume>9</volume>
        <issue>4</issue>
        <fpage>357</fpage>
        <lpage>9</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.1923</pub-id>
        <pub-id pub-id-type="pmid">22388286</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dobin</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Davis</surname>
            <given-names>CA</given-names>
          </name>
          <name>
            <surname>Schlesinger</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Drenkow</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Zaleski</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Jha</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>STAR: ultrafast universal RNA-seq aligner</article-title>
        <source>Bioinformatics</source>
        <year>2013</year>
        <volume>29</volume>
        <issue>1</issue>
        <fpage>15</fpage>
        <lpage>21</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts635</pub-id>
        <pub-id pub-id-type="pmid">23104886</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wu</surname>
            <given-names>TD</given-names>
          </name>
          <name>
            <surname>Nacu</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Fast and SNP-tolerant detection of complex variants and splicing in short reads</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <issue>7</issue>
        <fpage>873</fpage>
        <lpage>81</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq057</pub-id>
        <pub-id pub-id-type="pmid">20147302</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Fast and accurate short read alignment with Burrows-Wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>14</issue>
        <fpage>1754</fpage>
        <lpage>60</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp324</pub-id>
        <pub-id pub-id-type="pmid">19451168</pub-id>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lindner</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Friedel</surname>
            <given-names>CC</given-names>
          </name>
        </person-group>
        <article-title>A comprehensive evaluation of alignment algorithms in the context of RNA-seq</article-title>
        <source>PLoS One</source>
        <year>2012</year>
        <volume>7</volume>
        <issue>12</issue>
        <fpage>52403</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0052403</pub-id>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bonfert</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Csaba</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Zimmer</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Friedel</surname>
            <given-names>CC</given-names>
          </name>
        </person-group>
        <article-title>A context-based approach to identify the most likely mapping for RNA-seq experiments</article-title>
        <source>BMC Bioinf.</source>
        <year>2012</year>
        <volume>13 Suppl 6</volume>
        <fpage>9</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-13-S6-S9</pub-id>
      </element-citation>
    </ref>
    <ref id="CR16">
      <label>16</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bonfert</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Csaba</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Zimmer</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Friedel</surname>
            <given-names>CC</given-names>
          </name>
        </person-group>
        <article-title>Mining RNA-seq data for infections and contaminations</article-title>
        <source>PLoS One</source>
        <year>2013</year>
        <volume>8</volume>
        <issue>9</issue>
        <fpage>73071</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0073071</pub-id>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Engstrom</surname>
            <given-names>PG</given-names>
          </name>
          <name>
            <surname>Steijger</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Sipos</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Grant</surname>
            <given-names>GR</given-names>
          </name>
          <name>
            <surname>Kahles</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Ratsch</surname>
            <given-names>G</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Systematic evaluation of spliced alignment programs for RNA-seq data</article-title>
        <source>Nat Methods</source>
        <year>2013</year>
        <volume>10</volume>
        <issue>12</issue>
        <fpage>1185</fpage>
        <lpage>91</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.2722</pub-id>
        <pub-id pub-id-type="pmid">24185836</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Handsaker</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Wysoker</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Fennell</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Ruan</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Homer</surname>
            <given-names>N</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>1000 Genome Project Data Processing Subgroup. The Sequence Alignment/Map format and SAMtools</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>16</issue>
        <fpage>2078</fpage>
        <lpage>9</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp352</pub-id>
        <pub-id pub-id-type="pmid">19505943</pub-id>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Grant</surname>
            <given-names>GR</given-names>
          </name>
          <name>
            <surname>Farkas</surname>
            <given-names>MH</given-names>
          </name>
          <name>
            <surname>Pizarro</surname>
            <given-names>AD</given-names>
          </name>
          <name>
            <surname>Lahens</surname>
            <given-names>NF</given-names>
          </name>
          <name>
            <surname>Schug</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Brunk</surname>
            <given-names>BP</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Comparative analysis of RNA-Seq alignment algorithms and the RNA-Seq unified mapper (RUM)</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <issue>18</issue>
        <fpage>2518</fpage>
        <lpage>28</lpage>
        <pub-id pub-id-type="pmid">21775302</pub-id>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <collab>ENCODE Project Consortium</collab>
        </person-group>
        <article-title>An integrated encyclopedia of DNA elements in the human genome</article-title>
        <source>Nature</source>
        <year>2012</year>
        <volume>489</volume>
        <issue>7414</issue>
        <fpage>57</fpage>
        <lpage>74</lpage>
        <pub-id pub-id-type="doi">10.1038/nature11247</pub-id>
        <pub-id pub-id-type="pmid">22955616</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
