<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d3 20150301//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 39.96?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">PLoS One</journal-id>
    <journal-id journal-id-type="iso-abbrev">PLoS ONE</journal-id>
    <journal-id journal-id-type="publisher-id">plos</journal-id>
    <journal-id journal-id-type="pmc">plosone</journal-id>
    <journal-title-group>
      <journal-title>PLoS ONE</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1932-6203</issn>
    <publisher>
      <publisher-name>Public Library of Science</publisher-name>
      <publisher-loc>San Francisco, CA USA</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6913930</article-id>
    <article-id pub-id-type="publisher-id">PONE-D-19-11677</article-id>
    <article-id pub-id-type="doi">10.1371/journal.pone.0225900</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Simulation and Modeling</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Computer and Information Sciences</subject>
        <subj-group>
          <subject>Network Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Computer and Information Sciences</subject>
        <subj-group>
          <subject>Neural Networks</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Neuroscience</subject>
          <subj-group>
            <subject>Neural Networks</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Physiology</subject>
          <subj-group>
            <subject>Electrophysiology</subject>
            <subj-group>
              <subject>Membrane Potential</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Medicine and Health Sciences</subject>
        <subj-group>
          <subject>Physiology</subject>
          <subj-group>
            <subject>Electrophysiology</subject>
            <subj-group>
              <subject>Membrane Potential</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Cell Biology</subject>
          <subj-group>
            <subject>Cellular Types</subject>
            <subj-group>
              <subject>Animal Cells</subject>
              <subj-group>
                <subject>Neurons</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Neuroscience</subject>
          <subj-group>
            <subject>Cellular Neuroscience</subject>
            <subj-group>
              <subject>Neurons</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Bioassays and Physiological Analysis</subject>
          <subj-group>
            <subject>Electrophysiological Techniques</subject>
            <subj-group>
              <subject>Brain Electrophysiology</subject>
              <subj-group>
                <subject>Electroencephalography</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Physiology</subject>
          <subj-group>
            <subject>Electrophysiology</subject>
            <subj-group>
              <subject>Neurophysiology</subject>
              <subj-group>
                <subject>Brain Electrophysiology</subject>
                <subj-group>
                  <subject>Electroencephalography</subject>
                </subj-group>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Medicine and Health Sciences</subject>
        <subj-group>
          <subject>Physiology</subject>
          <subj-group>
            <subject>Electrophysiology</subject>
            <subj-group>
              <subject>Neurophysiology</subject>
              <subj-group>
                <subject>Brain Electrophysiology</subject>
                <subj-group>
                  <subject>Electroencephalography</subject>
                </subj-group>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Neuroscience</subject>
          <subj-group>
            <subject>Neurophysiology</subject>
            <subj-group>
              <subject>Brain Electrophysiology</subject>
              <subj-group>
                <subject>Electroencephalography</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Neuroscience</subject>
          <subj-group>
            <subject>Brain Mapping</subject>
            <subj-group>
              <subject>Electroencephalography</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Medicine and Health Sciences</subject>
        <subj-group>
          <subject>Clinical Medicine</subject>
          <subj-group>
            <subject>Clinical Neurophysiology</subject>
            <subj-group>
              <subject>Electroencephalography</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Imaging Techniques</subject>
          <subj-group>
            <subject>Neuroimaging</subject>
            <subj-group>
              <subject>Electroencephalography</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Neuroscience</subject>
          <subj-group>
            <subject>Neuroimaging</subject>
            <subj-group>
              <subject>Electroencephalography</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Anatomy</subject>
          <subj-group>
            <subject>Nervous System</subject>
            <subj-group>
              <subject>Synapses</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Medicine and Health Sciences</subject>
        <subj-group>
          <subject>Anatomy</subject>
          <subj-group>
            <subject>Nervous System</subject>
            <subj-group>
              <subject>Synapses</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Physiology</subject>
          <subj-group>
            <subject>Electrophysiology</subject>
            <subj-group>
              <subject>Neurophysiology</subject>
              <subj-group>
                <subject>Synapses</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Medicine and Health Sciences</subject>
        <subj-group>
          <subject>Physiology</subject>
          <subj-group>
            <subject>Electrophysiology</subject>
            <subj-group>
              <subject>Neurophysiology</subject>
              <subj-group>
                <subject>Synapses</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Neuroscience</subject>
          <subj-group>
            <subject>Neurophysiology</subject>
            <subj-group>
              <subject>Synapses</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Computer and Information Sciences</subject>
        <subj-group>
          <subject>Data Visualization</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>PyRates—A Python framework for rate-based neural simulations</article-title>
      <alt-title alt-title-type="running-head">PyRates—A neural simulation framework</alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" equal-contrib="yes">
        <contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-4445-0340</contrib-id>
        <name>
          <surname>Gast</surname>
          <given-names>Richard</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Conceptualization</role>
        <role content-type="http://credit.casrai.org/">Data curation</role>
        <role content-type="http://credit.casrai.org/">Formal analysis</role>
        <role content-type="http://credit.casrai.org/">Investigation</role>
        <role content-type="http://credit.casrai.org/">Methodology</role>
        <role content-type="http://credit.casrai.org/">Software</role>
        <role content-type="http://credit.casrai.org/">Validation</role>
        <role content-type="http://credit.casrai.org/">Visualization</role>
        <role content-type="http://credit.casrai.org/">Writing – original draft</role>
        <role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff001">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="aff002">
          <sup>2</sup>
        </xref>
        <xref ref-type="aff" rid="aff003">
          <sup>3</sup>
        </xref>
        <xref ref-type="corresp" rid="cor001">*</xref>
      </contrib>
      <contrib contrib-type="author" equal-contrib="yes">
        <name>
          <surname>Rose</surname>
          <given-names>Daniel</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Conceptualization</role>
        <role content-type="http://credit.casrai.org/">Investigation</role>
        <role content-type="http://credit.casrai.org/">Methodology</role>
        <role content-type="http://credit.casrai.org/">Software</role>
        <role content-type="http://credit.casrai.org/">Validation</role>
        <role content-type="http://credit.casrai.org/">Visualization</role>
        <role content-type="http://credit.casrai.org/">Writing – original draft</role>
        <role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff003">
          <sup>3</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Salomon</surname>
          <given-names>Christoph</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Data curation</role>
        <role content-type="http://credit.casrai.org/">Formal analysis</role>
        <role content-type="http://credit.casrai.org/">Software</role>
        <role content-type="http://credit.casrai.org/">Validation</role>
        <role content-type="http://credit.casrai.org/">Visualization</role>
        <xref ref-type="aff" rid="aff001">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="aff004">
          <sup>4</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Möller</surname>
          <given-names>Harald E.</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Funding acquisition</role>
        <role content-type="http://credit.casrai.org/">Project administration</role>
        <role content-type="http://credit.casrai.org/">Resources</role>
        <role content-type="http://credit.casrai.org/">Supervision</role>
        <role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff002">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Weiskopf</surname>
          <given-names>Nikolaus</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Funding acquisition</role>
        <role content-type="http://credit.casrai.org/">Project administration</role>
        <role content-type="http://credit.casrai.org/">Resources</role>
        <role content-type="http://credit.casrai.org/">Supervision</role>
        <role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff003">
          <sup>3</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Knösche</surname>
          <given-names>Thomas R.</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Conceptualization</role>
        <role content-type="http://credit.casrai.org/">Methodology</role>
        <role content-type="http://credit.casrai.org/">Project administration</role>
        <role content-type="http://credit.casrai.org/">Resources</role>
        <role content-type="http://credit.casrai.org/">Supervision</role>
        <role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff001">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="aff004">
          <sup>4</sup>
        </xref>
      </contrib>
    </contrib-group>
    <aff id="aff001">
      <label>1</label>
      <addr-line>MEG and Cortical Networks Group, Max Planck Institute for Human Cognitive and Brain Sciences, Leipzig, Saxony, Germany</addr-line>
    </aff>
    <aff id="aff002">
      <label>2</label>
      <addr-line>Nuclear Magnetic Resonance Group, Max Planck Institute for Human Cognitive and Brain Sciences, Leipzig, Saxony, Germany</addr-line>
    </aff>
    <aff id="aff003">
      <label>3</label>
      <addr-line>Neurophysics Department, Max Planck Institute for Human Cognitive and Brain Sciences, Leipzig, Saxony, Germany</addr-line>
    </aff>
    <aff id="aff004">
      <label>4</label>
      <addr-line>Institute for Biomedical Engineering and Informatics, TU Ilmenau, Ilmenau, Thuringia, Germany</addr-line>
    </aff>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Lytton</surname>
          <given-names>William W</given-names>
        </name>
        <role>Editor</role>
        <xref ref-type="aff" rid="edit1"/>
      </contrib>
    </contrib-group>
    <aff id="edit1">
      <addr-line>SUNY Downstate MC, UNITED STATES</addr-line>
    </aff>
    <author-notes>
      <fn fn-type="COI-statement" id="coi001">
        <p><bold>Competing Interests: </bold>The authors have declared that no competing interests exist.</p>
      </fn>
      <corresp id="cor001">* E-mail: <email>rgast@cbs.mpg.de</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>16</day>
      <month>12</month>
      <year>2019</year>
    </pub-date>
    <volume>14</volume>
    <issue>12</issue>
    <elocation-id>e0225900</elocation-id>
    <history>
      <date date-type="received">
        <day>24</day>
        <month>4</month>
        <year>2019</year>
      </date>
      <date date-type="accepted">
        <day>14</day>
        <month>11</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2019 Gast et al</copyright-statement>
      <copyright-year>2019</copyright-year>
      <copyright-holder>Gast et al</copyright-holder>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
      </license>
    </permissions>
    <self-uri content-type="pdf" xlink:href="pone.0225900.pdf"/>
    <abstract>
      <p>In neuroscience, computational modeling has become an important source of insight into brain states and dynamics. A basic requirement for computational modeling studies is the availability of efficient software for setting up models and performing numerical simulations. While many such tools exist for different families of neural models, there is a lack of tools allowing for both a generic model definition and efficiently parallelized simulations. In this work, we present PyRates, a Python framework that provides the means to build a large variety of rate-based neural models. PyRates provides intuitive access to and modification of all mathematical operators in a graph, thus allowing for a highly generic model definition. For computational efficiency and parallelization, the model is translated into a compute graph. Using the example of two different neural models belonging to the family of rate-based population models, we explain the mathematical formalism, software structure and user interfaces of PyRates. We show via numerical simulations that the behavior of the PyRates model implementations is consistent with the literature. Finally, we demonstrate the computational capacities and scalability of PyRates via a number of benchmark simulations of neural networks differing in size and connectivity.</p>
    </abstract>
    <funding-group>
      <award-group id="award001">
        <funding-source>
          <institution>European Research Council (FP7/2007-2013)</institution>
        </funding-source>
        <award-id>616905</award-id>
        <principal-award-recipient>
          <name>
            <surname>Weiskopf</surname>
            <given-names>Nikolaus</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
      <award-group id="award002">
        <funding-source>
          <institution>BMBF (01EW1711A &amp; B) in the framework of ERA-NET NEURON</institution>
        </funding-source>
        <principal-award-recipient>
          <name>
            <surname>Weiskopf</surname>
            <given-names>Nikolaus</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
      <award-group id="award003">
        <funding-source>
          <institution>European Union’s Horizon 2020 research and innovation programme</institution>
        </funding-source>
        <award-id>681094</award-id>
        <principal-award-recipient>
          <name>
            <surname>Weiskopf</surname>
            <given-names>Nikolaus</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
      <funding-statement>Nikolaus Weiskopf is supported by the European Research Council under the European Union’s Seventh Framework Programme (FP7/2007-2013) / ERC grant agreement no. 616905, the BMBF (01EW1711A &amp; B) in the framework of ERA-NET NEURON, the European Union’s Horizon 2020 research and innovation programme under the grant agreement No 681094. Richard Gast has been supported by Max Planck Society and Studienstiftung des Deutschen Volkes. Daniel Rose is supported by the International Max Planck Research School NeuroCom. The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement>
    </funding-group>
    <counts>
      <fig-count count="4"/>
      <table-count count="0"/>
      <page-count count="26"/>
    </counts>
    <custom-meta-group>
      <custom-meta id="data-availability">
        <meta-name>Data Availability</meta-name>
        <meta-value>All documentation files for replication of the results figures are available from the public repository <ext-link ext-link-type="uri" xlink:href="https://github.com/pyrates-neuroscience/PyRates/tree/master/documentation">https://github.com/pyrates-neuroscience/PyRates/tree/master/documentation</ext-link>.</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
  <notes>
    <title>Data Availability</title>
    <p>All documentation files for replication of the results figures are available from the public repository <ext-link ext-link-type="uri" xlink:href="https://github.com/pyrates-neuroscience/PyRates/tree/master/documentation">https://github.com/pyrates-neuroscience/PyRates/tree/master/documentation</ext-link>.</p>
  </notes>
</front>
<body>
  <sec sec-type="intro" id="sec001">
    <title>Introduction</title>
    <p>In the last decades, computational neuroscience has become an integral part of neuroscientific research. A major factor in this development has been the difficulty in gaining mechanistic insights into neural processes and structures from recordings of brain activity, without additional computational models. This problem is strongly linked to the actual signals recorded with non-invasive brain imaging techniques such as magneto- and electroencephalography (MEG/EEG) or functional magnetic resonance imaging (fMRI). Even though the spatiotemporal resolution of these techniques has improved throughout the years, they are still limited with respect to the state variables of the brain they can detect. Spatial resolution in fMRI has been pushed to the sub-millimeter range [<xref rid="pone.0225900.ref001" ref-type="bibr">1</xref>, <xref rid="pone.0225900.ref002" ref-type="bibr">2</xref>], whereas EEG and MEG offer a temporal resolution thought to be sufficient to capture all electrophysiological signaling processes in the brain [<xref rid="pone.0225900.ref003" ref-type="bibr">3</xref>]. On the EEG/MEG side, the measured signal is thought to arise mainly from the superposition of primary and secondary currents resulting from post-synaptic polarization of a large number of cells with similarly oriented dendrites [<xref rid="pone.0225900.ref004" ref-type="bibr">4</xref>]. Therefore, the activity of cell-types that do not show a clear orientation preference (like most inhibitory interneurons [<xref rid="pone.0225900.ref005" ref-type="bibr">5</xref>]) are difficult to detect, even though they might play a crucial role for the underlying neural dynamics. Further issues of EEG/MEG acquisitions are their limited sensitivity to sub-cortical signal sources and the inverse problem one faces when trying to locate the source of a signal within the brain [<xref rid="pone.0225900.ref006" ref-type="bibr">6</xref>]. On the other hand, fMRI measures hemodynamic signals of the brain related to local blood flow, blood volume, and blood oxygenation levels and thus delivers only an indirect, strongly blurred view of the dynamic state of the brain [<xref rid="pone.0225900.ref007" ref-type="bibr">7</xref>]. These limitations create the need for additional models and assumptions that link the recorded signals to the underlying neural activity. Computational models of neural dynamics (called neural models henceforth) are particularly important for interpreting neuroimaging data and understanding the neural mechanisms involved in their generation [<xref rid="pone.0225900.ref008" ref-type="bibr">8</xref>–<xref rid="pone.0225900.ref010" ref-type="bibr">10</xref>]. Such models have been developed for various spatial and temporal scales of the brain, ranging from highly detailed models of a single neuron to models that represent the combined activity of thousands of neurons. In any case, they provide observation and control over all state variables included in a given model, thus offering mechanistic insights into their dynamics.</p>
    <p>Numerical simulations are the primary method used to investigate neural models beyond pure mathematical analyses and to link model variables with experimental data. Such numerical simulations can be highly computationally expensive and scale with the model size, simulation time, and temporal resolution of the simulation. Different software tools have been developed for neural modeling that offer various solutions to render numerical simulations more efficient (e.g. TVB [<xref rid="pone.0225900.ref011" ref-type="bibr">11</xref>], DCM [<xref rid="pone.0225900.ref012" ref-type="bibr">12</xref>], Nengo [<xref rid="pone.0225900.ref013" ref-type="bibr">13</xref>], NEST [<xref rid="pone.0225900.ref014" ref-type="bibr">14</xref>], ANNarchy [<xref rid="pone.0225900.ref015" ref-type="bibr">15</xref>], Brian [<xref rid="pone.0225900.ref016" ref-type="bibr">16</xref>], and NEURON [<xref rid="pone.0225900.ref017" ref-type="bibr">17</xref>]). Since the brain is a highly parallelized information processing system (i.e. all of its <inline-formula id="pone.0225900.e001"><alternatives><graphic xlink:href="pone.0225900.e001.jpg" id="pone.0225900.e001g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M1"><mml:mrow><mml:mover accent="true"><mml:mn>1</mml:mn><mml:mo stretchy="true">˜</mml:mo></mml:mover><mml:mn>00</mml:mn></mml:mrow></mml:math></alternatives></inline-formula> billion cells can transform and propagate signals in parallel), most models of the brain have a high degree of structural parallelism as well. This means that they involve calculations that can be evaluated in parallel, such as the updating of the firing rate of each cell population inside a neural model. One obvious way of optimizing numerical simulations of neural models is to distribute these calculations on parallel hardware, such as the central and graphical processing units (CPUs and GPUs) of a computer. Neural simulation tools that implement such mechanisms include Nengo [<xref rid="pone.0225900.ref013" ref-type="bibr">13</xref>], ANNarchy [<xref rid="pone.0225900.ref015" ref-type="bibr">15</xref>], Brian [<xref rid="pone.0225900.ref016" ref-type="bibr">16</xref>], NEURON [<xref rid="pone.0225900.ref018" ref-type="bibr">18</xref>], and PCSIM [<xref rid="pone.0225900.ref019" ref-type="bibr">19</xref>], for example. Each of these tools has been built for neural models of certain families. For example, the setup and simulation of complex multi-compartment models of single spiking neurons is supported by NEURON, Nest, and Brian. Tools dedicated to networks of point neurons, on the other hand, include ANNarchy, Nengo, and PCSIM (though NEURON, Nest, and Brian support point neuron models as well). Finally, neural population models are the focus of TVB and DCM. For most of these tools, a pool of pre-implemented models of the given families are available that the user can choose from. However, often it is not possible to add new models or modeling mechanisms to this pool without considerable effort. This holds true especially if one wants to benefit from the parallelization and optimization features of the respective software. Exceptions are tools like ANNarchy and Brian that include code generation mechanisms. These allow the user to define the mathematical equations that certain parts of the model will be governed by and will automatically translate them into the same representations that the pre-implemented models follow. Unfortunately, the tools that provide such code generation mechanisms are limited with regards to the model parts that can be customized in such a way and concerning the families of neural models they can express. It should be mentioned that NEURON allows one to build custom, multi-compartment neuron models that can be used in network models without any impact on the parallelization mechanisms. This enables the setup of heterogeneous, multi-scale models of single cells without loss of parallelization efficiency via high-level interfaces to NEURON such as BioNet or NetPyNE [<xref rid="pone.0225900.ref020" ref-type="bibr">20</xref>, <xref rid="pone.0225900.ref021" ref-type="bibr">21</xref>]. However, these mechanisms do not allow the modification of the underlying equations of the state variables in the model.</p>
    <p>To summarize, we believe that the increasing number of computational models and numerical simulations in neuroscientific research necessitates the development of neural simulation tools that:
<list list-type="bullet"><list-item><p>follow a well-defined mathematical formalism in their model configurations,</p></list-item><list-item><p>are flexible enough so that scientists can implement custom models that go beyond pre-implemented models in both the mathematical equations and network structure,</p></list-item><list-item><p>are structured in such a way that models are easily understood, set up, and shared with other scientists,</p></list-item><list-item><p>enable efficient numerical simulations on parallel computing hardware.</p></list-item></list></p>
    <p>To address these needs, we present PyRates, an open-source Python framework for rate-based neural modeling (freely available at <ext-link ext-link-type="uri" xlink:href="https://www.cbs.mpg.de/departments/neurophysics/software/pyrates">https://www.cbs.mpg.de/departments/neurophysics/software/pyrates</ext-link> and <ext-link ext-link-type="uri" xlink:href="https://github.com/pyrates-neuroscience/PyRates">https://github.com/pyrates-neuroscience/PyRates</ext-link>). The basic aim behind PyRates is to provide a well-documented, thoroughly tested, and computationally powerful framework for neural modeling and simulations. In PyRates, both the model configuration and simulation can be performed with a few lines of code. Each model is represented by a graph of nodes and edges, with the former representing the model units (i.e. single cells, cell populations, …) and the latter the information transfer between them. Further, as we will explain in more detail below, the user has full control over the mathematical equations that define the nodes and edges. To enable an efficient parallelization, the underlying model equations are translated into a compute graph, specifying which parts of the equations have to be evaluated serially and which parts can be processed in parallel. Parallel hardware that PyRates can employ for this purpose includes central processing units (CPUs), graphical processing units (GPUs), and compute clusters with multiple machines. In principle this will allow the implementation of any kind of dynamic neural system that can be expressed as a graph. For the remainder of this article we will focus on a specific family of neural models, namely rate-based population models (hence the name PyRates).</p>
    <p>The focus on population models is (i) in accordance with the expertise of the authors and (ii) serves the purpose of keeping the article concise. However, the emphasis of the paper lies on introducing the features and capacities of the framework, how to define a model in PyRates, and how to use the software to perform and analyze neural simulations. Therefore, we first introduce the mathematical syntax used for all of our models, followed by an explanation how single mathematical equations are structured in PyRates to form a neural network model. To this end, we provide a step-by-step example of how to configure and simulate a particular neural population model. We continue with a section dedicated to the evaluation of different numerical simulation scenarios. First, we validate the implementation of two exemplary neural population models in PyRates by replicating key behaviors of the models reported in their original publications. Second, we demonstrate the computational efficiency and scalability of PyRates via a number of benchmarks that constitute realistic numerical simulation scenarios. Finally, we discuss the strengths and limitations of PyRates for developing and simulating neural models.</p>
  </sec>
  <sec id="sec002">
    <title>Neural population models</title>
    <p>Investigating the human brain via EEG/MEG or fMRI means working with signals that are assumed to represent changes in the average activity of large cell populations. While these signals can be explained by detailed models of single cell processes, such models come with a state space of much higher dimensionality than the measured signals. Indeed, several approaches exist that employ this strategy to model the neural processes underlying macroscopic brain signals [<xref rid="pone.0225900.ref022" ref-type="bibr">22</xref>, <xref rid="pone.0225900.ref023" ref-type="bibr">23</xref>] via tools such as the <italic>Human Neocortical Neurosolver</italic> or <italic>LFPy</italic> [<xref rid="pone.0225900.ref024" ref-type="bibr">24</xref>, <xref rid="pone.0225900.ref025" ref-type="bibr">25</xref>]. As an alternative approach, neural mass models have widely been used to model the dynamics of the macroscopic brain signals of interest [<xref rid="pone.0225900.ref026" ref-type="bibr">26</xref>]. That is, they describe the average activity of large cell populations in the brain via a mean-field approach, rendering their investigation computationally much less expensive than single cell approaches [<xref rid="pone.0225900.ref008" ref-type="bibr">8</xref>, <xref rid="pone.0225900.ref027" ref-type="bibr">27</xref>, <xref rid="pone.0225900.ref028" ref-type="bibr">28</xref>]. As a downside, all information about the underlying single cell activity, except for the mean of their probability distribution is lost. Thus, their application is limited to neurodynamic questions addressing changes in those macroscopic state variables. Often, neural mass models express the state of each neural population by an average membrane potential and an average firing rate. The dynamics and transformations of these state variables can typically be formulated via three mathematical operators. The first two describe the input-output structure of a single population: While the rate-to-potential operator (RPO) transforms synaptic inputs into average membrane potential changes, the potential-to-rate operator (PRO) transforms the average membrane potential into an average firing rate output. Widely used forms for these operators are a convolution operation with an exponential kernel for the RPO (e.g. [<xref rid="pone.0225900.ref029" ref-type="bibr">29</xref>, <xref rid="pone.0225900.ref030" ref-type="bibr">30</xref>, <xref rid="pone.0225900.ref032" ref-type="bibr">32</xref>]) and a sigmoidal, instantaneous transformation for the PRO (e.g. [<xref rid="pone.0225900.ref028" ref-type="bibr">28</xref>, <xref rid="pone.0225900.ref033" ref-type="bibr">33</xref>, <xref rid="pone.0225900.ref034" ref-type="bibr">34</xref>]). The third operator is the coupling operator (CO) that transforms outgoing into incoming firing rates and is thus used to establish connections across populations. By describing the dynamics of large neural population networks via three basic transforms (RPO, PRO &amp; CO), neural mass models combine computational feasibility with biophysical interpretability. Due to these desirable qualities, neural mass models have become an attractive method for studying neural dynamics on a meso- and macroscopic scale [<xref rid="pone.0225900.ref008" ref-type="bibr">8</xref>, <xref rid="pone.0225900.ref010" ref-type="bibr">10</xref>, <xref rid="pone.0225900.ref026" ref-type="bibr">26</xref>]. They have been established as one of the most popular methods for modeling EEG/MEG and fMRI measurements and have been able to account for various dynamic properties of experimentally observed neural activity [<xref rid="pone.0225900.ref031" ref-type="bibr">31</xref>, <xref rid="pone.0225900.ref032" ref-type="bibr">32</xref>, <xref rid="pone.0225900.ref035" ref-type="bibr">35</xref>–<xref rid="pone.0225900.ref040" ref-type="bibr">40</xref>].</p>
    <p>A particular neural mass model that we will use repeatedly in later sections is the three-population circuit introduced by Jansen and Rit [<xref rid="pone.0225900.ref029" ref-type="bibr">29</xref>]. The Jansen-Rit circuit (JRC) was originally proposed as a mechanistic model of the EEG signal generated by the visual cortex [<xref rid="pone.0225900.ref029" ref-type="bibr">29</xref>, <xref rid="pone.0225900.ref041" ref-type="bibr">41</xref>]. Historically, however, it has been used as a canonical model of cell population interactions in a cortical column [<xref rid="pone.0225900.ref035" ref-type="bibr">35</xref>, <xref rid="pone.0225900.ref036" ref-type="bibr">36</xref>, <xref rid="pone.0225900.ref040" ref-type="bibr">40</xref>]. Its basic structure can be seen in <xref ref-type="fig" rid="pone.0225900.g001">Fig 1B</xref>, which can be thought of as a single cortical column. The signal generated by this column is the result of dynamic interactions between a projection cell population of pyramidal cells (PC), an excitatory interneuron population (EIN) and an inhibitory interneuron population (IIN). For certain parametrizations, the JRC has been shown to be able to produce key features of a typical EEG signal, such as the waxing-and-waning alpha oscillations [<xref rid="pone.0225900.ref029" ref-type="bibr">29</xref>, <xref rid="pone.0225900.ref030" ref-type="bibr">30</xref>, <xref rid="pone.0225900.ref042" ref-type="bibr">42</xref>]. A detailed account of the model’s mathematical description will be given in the next section, where we will demonstrate how to implement models in PyRates, using the example of the JRC equations. We chose to employ the JRC as an exemplary population model in this article since it is an established model used in numerous publications that the reader can compare with our report.</p>
    <fig id="pone.0225900.g001" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.1371/journal.pone.0225900.g001</object-id>
      <label>Fig 1</label>
      <caption>
        <title>Model structure in PyRates.</title>
        <p>The largest organizational unit of a network model is the <italic>Circuit</italic>. Any circuit may also consist of multiple hierarchical layers of subcircuits. Panel (A) depicts an imaginary circuit that encompasses four subcircuits that represent one brain region each. One of these local circuits is a Jansen-Rit circuit (B), consisting of three neural populations (PC, EIN, IIN) and the connections between them. One node (C) may consist of multiple operators containing the mathematical equations. Here, two rate-to-potential operators (RPO) convolute incoming firing rates with an alpha kernel to produce post-synaptic potentials. These are summed into a combined membrane potential <italic>V</italic>. The potential-to-rate operator (PRO) transforms <italic>V</italic> into an outgoing firing rate <italic>m</italic><sub><italic>out</italic></sub> via a sigmoid function. Inset graphs give a qualitative representation of the operators and evolution of the membrane potential. Edges (lines in A and B) represent information transfer between nodes. As panel (D) shows, edges may also contain operators. By default, edges apply a multiplicative weighting constant and can optionally delay the information passage with respect to time. The equation shown in panel (D) depicts this default behavior.</p>
      </caption>
      <graphic xlink:href="pone.0225900.g001"/>
    </fig>
    <p>Another neural population model that we will make use of in this paper is the one described by Montbrió and colleagues [<xref rid="pone.0225900.ref043" ref-type="bibr">43</xref>]. It has been mentioned as one of the next generation neural mass models that provide a more precise mean-field description than classic neural population models like the JRC [<xref rid="pone.0225900.ref044" ref-type="bibr">44</xref>]. The model proposed by Montbrió and colleagues represents a mathematically exact mean-field derivation of a network of globally coupled quadratic integrate-and-fire neurons [<xref rid="pone.0225900.ref043" ref-type="bibr">43</xref>]. It can thus represent every macroscopic state the single cell network may fall into. This distinguishes it from the JRC, since it has no such correspondence between a single-cell network and the population descriptions. Furthermore, the macroscopic states (average membrane potential and average firing rate) of the Montbrió model can be linked directly to the synchronicity of the underlying single-cell network, a property that benefits the investigation of EEG phenomena such as event-related (de-)synchronization. We chose this model as our second example case due to its novelty and its potential importance for future neural population studies. Within the domain of rate-based neural population models, we found these two models sufficiently distinct to demonstrate the ability of PyRates to implement different model structures.</p>
  </sec>
  <sec id="sec003">
    <title>The framework</title>
    <p>PyRates requires an installation of Python 3.6 or newer and can be installed via the package manager <italic>pip</italic>, simply by calling <monospace>pip install pyrates</monospace> from the command line. The core goal of PyRates is to let scientists focus on the model definition, <italic>i.e</italic>. working out the equation structure, while the software takes care of transforming them into computationally efficient network structures and numerical simulations thereof.</p>
    <p>This goal is reflected in the modular software design and user interface. Model configuration and simulation are realized as separate software layers as depicted in <xref ref-type="fig" rid="pone.0225900.g002">Fig 2</xref>. The <italic>frontend</italic> features multiple user interfaces for different levels of programming expertise and allows scientists to flexibly implement custom models. The models are then transformed into a graph-based <italic>intermediate representation</italic> that the <italic>backend</italic> interprets to perform efficient computations. We employ a custom mathematical syntax and domain specific model definition language. Both focus on readability and are much reduced in comparison to general-purpose languages. The following paragraphs explain the user interfaces and how to define models and run simulations. More details on implementation and installation can be found in the online documentation (see <ext-link ext-link-type="uri" xlink:href="https://pyrates.readthedocs.io">pyrates.readthedocs.io</ext-link>).</p>
    <fig id="pone.0225900.g002" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.1371/journal.pone.0225900.g002</object-id>
      <label>Fig 2</label>
      <caption>
        <title>Schematic of software layers.</title>
        <p>PyRates is separated into frontend, intermediate representation (IR) and backend. The frontend features a set of interfaces to define network models. These are then translated into a standardized structure, called the IR. Simulations are realized via the backend, which transforms the high-level IR into lower-level representations for efficient computations. The frontend can easily be extended with new interfaces, while the backend can be swapped out to target a different computation framework.</p>
      </caption>
      <graphic xlink:href="pone.0225900.g002"/>
    </fig>
    <sec id="sec004">
      <title>Mathematical syntax</title>
      <p>Neural network models are usually defined by a set of (differential) equations and corresponding parameters. In PyRates, researchers can define computational models in terms of algebraic equations and relations between different equations. The mathematical syntax strongly follows the conventions used in Python, though in some cases common alternatives are allowed as well. For example, the equation <inline-formula id="pone.0225900.e002"><alternatives><graphic xlink:href="pone.0225900.e002.jpg" id="pone.0225900.e002g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M2"><mml:mrow><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>5</mml:mn><mml:mo>·</mml:mo><mml:mo>(</mml:mo><mml:mi>b</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msup><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula> can be written as <monospace>a = 5 * (b + c) / d**2</monospace>. Here, the power operator is a double asterisk <monospace>**</monospace> as used in Python. However, the commonly used caret ^ symbol is implemented as a synonym. Parentheses, for example <monospace>(b + c)</monospace> indicate grouping. Arguments to a function are also grouped using parenthesis, e.g. <monospace>exp(2)</monospace> or <monospace>sin(4 + 3)</monospace>.</p>
      <p>Currently, PyRates does not include a full computer algebra system. By convention, the variable of interest is positioned on the left-hand-side of the equality sign and all other variables and operations on the right-hand-side. First-order differential equations are allowed as an exception: The expression <monospace>d/dt * a</monospace> is treated as a new variable and can thus be positioned as the variable of interest on the left-hand-side as in
<disp-formula id="pone.0225900.e003"><alternatives><graphic xlink:href="pone.0225900.e003.jpg" id="pone.0225900.e003g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M3"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtext mathvariant="monospace">d</mml:mtext><mml:mo mathvariant="monospace">/</mml:mo><mml:mtext mathvariant="monospace">dt</mml:mtext><mml:mo mathvariant="monospace">*</mml:mo><mml:mtext mathvariant="monospace">a</mml:mtext><mml:mo mathvariant="monospace">=</mml:mo><mml:mtext mathvariant="monospace">a</mml:mtext><mml:mo mathvariant="monospace">+</mml:mo><mml:mtext mathvariant="monospace">d</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(1)</label></disp-formula>
As a short-hand synonym, the expression <monospace>a’</monospace> may be used as well (e.g. <italic>a</italic>′ = <italic>a</italic> + <italic>d</italic>). Higher order differential equations must be given as a set of coupled first-order differential equations. For example the equation
<disp-formula id="pone.0225900.e004"><alternatives><graphic xlink:href="pone.0225900.e004.jpg" id="pone.0225900.e004g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M4"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mfrac><mml:mrow><mml:msup><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:msup><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mi>b</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(2)</label></disp-formula>
can be reformulated as the following set of two coupled first-order differential equations:
<disp-formula id="pone.0225900.e005"><alternatives><graphic xlink:href="pone.0225900.e005.jpg" id="pone.0225900.e005g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M5"><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>⇔</mml:mo><mml:mtext mathvariant="monospace">d</mml:mtext><mml:mo mathvariant="monospace">/</mml:mo><mml:mtext mathvariant="monospace">dt</mml:mtext><mml:mo mathvariant="monospace">*</mml:mo><mml:mtext mathvariant="monospace">a</mml:mtext><mml:mo mathvariant="monospace">=</mml:mo><mml:mtext mathvariant="monospace">x</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(3)</label></disp-formula>
<disp-formula id="pone.0225900.e006"><alternatives><graphic xlink:href="pone.0225900.e006.jpg" id="pone.0225900.e006g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M6"><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mi>b</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo>−</mml:mo><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:mi>a</mml:mi></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>⇔</mml:mo><mml:mtext mathvariant="monospace">d</mml:mtext><mml:mo mathvariant="monospace">/</mml:mo><mml:mtext mathvariant="monospace">dt</mml:mtext><mml:mo mathvariant="monospace">*</mml:mo><mml:mtext mathvariant="monospace">x</mml:mtext><mml:mo mathvariant="monospace">=</mml:mo><mml:mtext mathvariant="monospace">b</mml:mtext><mml:mo mathvariant="monospace">+</mml:mo><mml:mtext mathvariant="monospace">c</mml:mtext><mml:mo mathvariant="monospace">−</mml:mo><mml:mtext mathvariant="monospace">x</mml:mtext><mml:mo mathvariant="monospace">−</mml:mo><mml:mtext mathvariant="monospace">a</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(4)</label></disp-formula>
In simulations, this type of equation will be integrated for each time step of size <italic>dt</italic>. The following is an example for equations of a single neural mass in the classic Jansen-Rit model [<xref rid="pone.0225900.ref041" ref-type="bibr">41</xref>], which will be reused in later examples: 
<disp-formula id="pone.0225900.e007"><alternatives><graphic xlink:href="pone.0225900.e007.jpg" id="pone.0225900.e007g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M7"><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mtext mathvariant="monospace">RPO</mml:mtext><mml:mo mathvariant="monospace">:</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext mathvariant="monospace">d</mml:mtext><mml:mo mathvariant="monospace">/</mml:mo><mml:mtext mathvariant="monospace">dt</mml:mtext><mml:mo mathvariant="monospace">*</mml:mo><mml:mtext mathvariant="monospace">V</mml:mtext><mml:mo mathvariant="monospace">_</mml:mo><mml:mtext mathvariant="monospace">t</mml:mtext><mml:mo mathvariant="monospace">=</mml:mo><mml:mtext mathvariant="monospace">h</mml:mtext><mml:mo mathvariant="monospace">/</mml:mo><mml:mtext mathvariant="monospace">tau</mml:mtext><mml:mo mathvariant="monospace">*</mml:mo><mml:mtext mathvariant="monospace">r</mml:mtext><mml:mo mathvariant="monospace">_</mml:mo><mml:mtext mathvariant="monospace">in</mml:mtext><mml:mo mathvariant="monospace">−</mml:mo><mml:mn mathvariant="monospace">1</mml:mn><mml:mo mathvariant="monospace">/</mml:mo><mml:mtext mathvariant="monospace">tau</mml:mtext><mml:mo mathvariant="monospace">*</mml:mo><mml:mo mathvariant="monospace">*</mml:mo><mml:mn mathvariant="monospace">2</mml:mn><mml:mo mathvariant="monospace">*</mml:mo><mml:mtext mathvariant="monospace">V</mml:mtext><mml:mo mathvariant="monospace">−</mml:mo><mml:mn mathvariant="monospace">2</mml:mn><mml:mo mathvariant="monospace">*</mml:mo><mml:mn mathvariant="monospace">1</mml:mn><mml:mo mathvariant="monospace">/</mml:mo><mml:mtext mathvariant="monospace">tau</mml:mtext><mml:mo mathvariant="monospace">*</mml:mo><mml:mtext mathvariant="monospace">V_t</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(5)</label></disp-formula>
<disp-formula id="pone.0225900.e008"><alternatives><graphic xlink:href="pone.0225900.e008.jpg" id="pone.0225900.e008g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M8"><mml:mtext mathvariant="monospace">d</mml:mtext><mml:mo mathvariant="monospace">/</mml:mo><mml:mtext mathvariant="monospace">dt</mml:mtext><mml:mo mathvariant="monospace">*</mml:mo><mml:mtext mathvariant="monospace">V</mml:mtext><mml:mo mathvariant="monospace">=</mml:mo><mml:mtext mathvariant="monospace">V</mml:mtext><mml:mo mathvariant="monospace">_</mml:mo><mml:mtext mathvariant="monospace">t</mml:mtext></mml:math></alternatives><label>(6)</label></disp-formula>
<disp-formula id="pone.0225900.e009"><alternatives><graphic xlink:href="pone.0225900.e009.jpg" id="pone.0225900.e009g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M9"><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mtext mathvariant="monospace">PRO</mml:mtext><mml:mo mathvariant="monospace">:</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext mathvariant="monospace">r_out</mml:mtext><mml:mo mathvariant="monospace">=</mml:mo><mml:mtext mathvariant="monospace">r_max</mml:mtext><mml:mo mathvariant="monospace">/</mml:mo><mml:mrow><mml:mo mathvariant="monospace">(</mml:mo><mml:mrow><mml:mn mathvariant="monospace">1</mml:mn><mml:mo mathvariant="monospace">+</mml:mo><mml:mtext mathvariant="monospace">exp</mml:mtext><mml:mrow><mml:mo mathvariant="monospace">(</mml:mo><mml:mrow><mml:mtext mathvariant="monospace">s</mml:mtext><mml:mo mathvariant="monospace">*</mml:mo><mml:mrow><mml:mo mathvariant="monospace">(</mml:mo><mml:mrow><mml:mtext mathvariant="monospace">V_thr</mml:mtext><mml:mspace width="1pt"/><mml:mo mathvariant="monospace">−</mml:mo><mml:mspace width="1pt"/><mml:mtext mathvariant="monospace">V</mml:mtext></mml:mrow><mml:mo mathvariant="monospace">)</mml:mo></mml:mrow></mml:mrow><mml:mo mathvariant="monospace">)</mml:mo></mml:mrow></mml:mrow><mml:mo mathvariant="monospace">)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(7)</label></disp-formula>
<xref ref-type="disp-formula" rid="pone.0225900.e009">Eq (7)</xref> represents the transformation of the population-average membrane potential <italic>V</italic> to an outgoing firing rate <italic>r</italic><sub><italic>out</italic></sub> via a sigmoidal transformation with slope <italic>s</italic>, maximum firing rate <italic>r</italic><sub><italic>max</italic></sub> and firing threshold <italic>V</italic><sub><italic>thr</italic></sub>. This formulation contains a function call to the exponential function via <monospace>exp(…)</monospace>. Using the pre-implemented <monospace>sigmoid</monospace> function, <xref ref-type="disp-formula" rid="pone.0225900.e009">Eq (7)</xref> can be shortened to
<disp-formula id="pone.0225900.e010"><alternatives><graphic xlink:href="pone.0225900.e010.jpg" id="pone.0225900.e010g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M10"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi mathvariant="monospace">r</mml:mi><mml:mo mathvariant="monospace">_</mml:mo><mml:mtext mathvariant="monospace">out</mml:mtext><mml:mo mathvariant="monospace">=</mml:mo><mml:mi mathvariant="monospace">r</mml:mi><mml:mo mathvariant="monospace">_</mml:mo><mml:mtext mathvariant="monospace">max</mml:mtext><mml:mo mathvariant="monospace">*</mml:mo><mml:mtext mathvariant="monospace">sigmoid</mml:mtext><mml:mrow><mml:mo mathvariant="monospace">(</mml:mo><mml:mi mathvariant="monospace">s</mml:mi><mml:mo mathvariant="monospace">*</mml:mo><mml:mrow><mml:mo mathvariant="monospace">(</mml:mo><mml:mi mathvariant="monospace">V</mml:mi><mml:mo mathvariant="monospace">−</mml:mo><mml:mi mathvariant="monospace">V</mml:mi><mml:mo mathvariant="monospace">_</mml:mo><mml:mtext mathvariant="monospace">thr</mml:mtext><mml:mo mathvariant="monospace">)</mml:mo></mml:mrow><mml:mo mathvariant="monospace">)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(8)</label></disp-formula>
Multiple arguments to a function call are comma separated, e.g. in the sum along the first axis of matrix <italic>A</italic> which would be: <monospace>sum(A, 0)</monospace>. Using comparison operators as function arguments, it is also possible to encode events, e.g. a spike, when the membrane potential <italic>V</italic> exceeds the threshold <italic>V</italic><sub><italic>thr</italic></sub>:
<disp-formula id="pone.0225900.e011"><alternatives><graphic xlink:href="pone.0225900.e011.jpg" id="pone.0225900.e011g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M11"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtext mathvariant="monospace">spike</mml:mtext><mml:mo mathvariant="monospace">=</mml:mo><mml:mtext mathvariant="monospace">float</mml:mtext><mml:mo mathvariant="monospace">(</mml:mo><mml:mi mathvariant="monospace">V</mml:mi><mml:mo mathvariant="monospace">&gt;</mml:mo><mml:mi mathvariant="monospace">V</mml:mi><mml:mo mathvariant="monospace">_</mml:mo><mml:mtext mathvariant="monospace">thr</mml:mtext><mml:mo mathvariant="monospace">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(9)</label></disp-formula>
The variable <monospace>spike</monospace> takes the decimal value <monospace>1.0</monospace> in case of a spike event and <monospace>0.0</monospace> otherwise.</p>
      <p>The above examples assumed scalar variables, but vectors and higher-dimensional variables may also be used in PyRates. In particular, indexing is possible via square brackets <monospace>[…]</monospace> and mostly follows the conventions of <italic>numpy</italic> [<xref rid="pone.0225900.ref045" ref-type="bibr">45</xref>], the <italic>de facto</italic> standard for numerics in Python. Supported indexing methods include single element indexing <monospace>a[3]</monospace>, slicing <monospace>[1:5]</monospace>, slicing along multiple axes separated by commas [0:5, 3:7], multi-element indexing <monospace>a[[3], [4]]</monospace>, and slicing via Boolean masks <monospace>a[a&gt;5]</monospace> for variable <monospace>a</monospace> of suitable dimensions. For more detailed explanations, please refer to the numpy documentation. A full list of supported mathematical symbols and pre-implemented functions can be found in the supporting information (<xref ref-type="supplementary-material" rid="pone.0225900.s001">S1</xref> and <xref ref-type="supplementary-material" rid="pone.0225900.s002">S2</xref> Tables).</p>
    </sec>
    <sec id="sec005">
      <title>Components of a network model</title>
      <p>In contrast to most other neural simulation frameworks, PyRates treats network models as network graphs rather than matrices. This works well for densely connected graphs, but gives the most computational benefit for sparse networks. <xref ref-type="fig" rid="pone.0225900.g001">Fig 1</xref> gives an overview of the different components that make up a model. A network graph is called a <italic>circuit</italic> and is spanned by <italic>nodes</italic> and <italic>edges</italic>. For a neural population model, one node may correspond to one neural population with the edges encoding coupling between populations. In addition, circuits may be nested arbitrarily within other circuits. Small, self-contained network models can thus easily be reused in larger networks with a clear and intuitive hierarchy. <xref ref-type="fig" rid="pone.0225900.g001">Fig 1A</xref> illustrates this feature with a fictional large-scale circuit which comprises four brain areas and connections between them. Each area may consist of a single node or a more complex <italic>sub-circuit</italic>. Edges between areas are depicted as lines. <xref ref-type="fig" rid="pone.0225900.g001">Fig 1B</xref> zooms in on one brain area containing a three-node sub-circuit. This local model corresponds to the previously defined Jansen-Rit model [<xref rid="pone.0225900.ref029" ref-type="bibr">29</xref>, <xref rid="pone.0225900.ref041" ref-type="bibr">41</xref>].</p>
      <p>An individual network node consists of <italic>operators</italic>. One operator defines a scope, in which a set of equations and related variables are uniquely defined. It also acts as an isolated computational unit that transforms any number of input variables into one output. Whether an equation belongs to one operator or another decides the order in which equations are evaluated. Equations belonging to the same operator will be evaluated simultaneously, whereas equations in different operators can be evaluated in sequence. As an example, <xref ref-type="fig" rid="pone.0225900.g001">Fig 1C</xref> shows the operator structure of a pyramidal cell population in the Jansen-Rit model. There are two rate-to-potential operators (Eqs (<xref ref-type="disp-formula" rid="pone.0225900.e007">5</xref>) and (<xref ref-type="disp-formula" rid="pone.0225900.e008">6</xref>)), one for inhibitory synapses (RPO<sub>i</sub>) and one for excitatory synapses (RPO<sub>e</sub>). The two RPOs contain identical equations but different values assigned to the parameters. The subsequent potential-to-rate operator (PRO, <xref ref-type="disp-formula" rid="pone.0225900.e009">Eq (7)</xref>) sums both synaptic contributions into one membrane potential that is transformed into an outgoing firing rate. In this configuration, the two synaptic contributions are evaluated independently, but possibly in parallel. The equation in the PRO on the other hand will only be evaluated after the synaptic RPOs. The exact order of operators is determined based on the respective input and output variables.</p>
      <p>Apart from nodes, edges may also contain coupling operators. An example is shown in <xref ref-type="fig" rid="pone.0225900.g001">Fig 1D</xref>. Each edge propagates information from a <italic>source</italic> node to a <italic>target</italic> node. In between, one or more operators can transform the relevant variable, representing coupling dynamics between source and target nodes. This could represent an axon or bundle of axons that propagates firing rates between neural masses. Depending on distance, location or myelination, these axons may behave differently, which is encoded in operators. Note that edges can read any one variable from a source population and can thus be used to represent dramatically different coupling dynamics than those described above.</p>
      <p>The described distinction between circuits, nodes, edges and operators is meant to provide an intuitive understanding of a model while giving the user many degrees of freedom in defining custom models.</p>
    </sec>
    <sec id="sec006">
      <title>Model definition language</title>
      <p>PyRates provides multiple interfaces to define a network model (see <xref ref-type="fig" rid="pone.0225900.g002">Fig 2</xref>). <italic>Templates</italic> are building blocks that can be reused at multiple scales. Complex heterogeneous networks will consist of many different templates whereas large homogeneous networks may reuse a few templates many times. For brevity, we will focus on the <italic>YAML</italic>-based template interface which is most suitable for users with little programming expertise. <italic>YAML</italic> is a data serialization standard using a syntax that is reduced to the absolute necessities and focuses on readability (version 1.2, [<xref rid="pone.0225900.ref046" ref-type="bibr">46</xref>]).</p>
      <p>All examples in this section are based on the popular Jansen-Rit model [<xref rid="pone.0225900.ref029" ref-type="bibr">29</xref>]. Additionally, we will briefly discuss the implementation of the Montbrió model [<xref rid="pone.0225900.ref043" ref-type="bibr">43</xref>] for completeness. The Jansen-Rit model is a three-population neural mass model whose basic structure is illustrated in <xref ref-type="fig" rid="pone.0225900.g001">Fig 1</xref>. The model is formulated in two state-variables: Average membrane potential <italic>V</italic> and average firing rate <italic>r</italic>. Incoming presynaptic firing rates <italic>r</italic><sub><italic>in</italic></sub> are converted to post-synaptic potentials via the rate-to-potential operator (RPO). In the Jansen-Rit model, this is a second-order, linear, ordinary differential equation:
<disp-formula id="pone.0225900.e012"><alternatives><graphic xlink:href="pone.0225900.e012.jpg" id="pone.0225900.e012g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M12"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtext>RPO</mml:mtext><mml:mo>:</mml:mo><mml:mspace width="1.em"/><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mfrac><mml:mi>d</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac></mml:mstyle><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>τ</mml:mi></mml:mfrac><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mi>V</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mi>h</mml:mi><mml:mi>τ</mml:mi></mml:mfrac><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(10)</label></disp-formula>
with synaptic gain <italic>h</italic> and lumped time constant <italic>τ</italic>. The population-average membrane potential is then transformed into a mean outgoing firing rate <italic>r</italic><sub><italic>out</italic></sub> via the potential-to-rate operator (PRO)
<disp-formula id="pone.0225900.e013"><alternatives><graphic xlink:href="pone.0225900.e013.jpg" id="pone.0225900.e013g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M13"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtext>PRO</mml:mtext><mml:mo>:</mml:mo><mml:mspace width="1.em"/><mml:mspace width="1.em"/><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mi>V</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(11)</label></disp-formula>
which is an instantaneous logistic function with maximum firing rate <italic>r</italic><sub><italic>max</italic></sub>, maximum slope <italic>s</italic>, and average firing threshold <italic>V</italic><sub><italic>thr</italic></sub>. The equations above define a neural mass with a single synapse type. Multiple sets of these equations are coupled to form a model with three coupled neural populations. For the two interneuron populations, <xref ref-type="disp-formula" rid="pone.0225900.e012">Eq (10)</xref> represents synaptic excitation. The pyramidal cell population uses this equation twice with two different parametrizations, representing synaptic excitation and inhibition, respectively. This model can be extended to include more populations or to model multiple cortical columns or areas that interact with each other. For such use-cases PyRates allows for the definition of templates that can be reused and adapted on-the-fly. The following defines a <italic>YAML</italic>-template for a rate-to-potential operator that contains <xref ref-type="disp-formula" rid="pone.0225900.e012">Eq (10)</xref>:</p>
      <p specific-use="line"><bold>JansenRitSynapse</bold>: <italic># name of the template</italic></p>
      <p specific-use="line"> <bold>description</bold>: … <italic># optional descriptive text</italic></p>
      <p specific-use="line"> <bold>base</bold>: OperatorTemplate <italic># parent template or Python class to use</italic></p>
      <p specific-use="line"> <bold>equations</bold>: <italic># unordered list of equations</italic></p>
      <p specific-use="line">  - ’d/dt * V = V_t’</p>
      <p specific-use="line">  - ’d/dt * V_t = h/tau * r_in − (1./tau)^2 * V − 2.*1./tau*V_t’</p>
      <p specific-use="line"> <bold>variables</bold>:</p>
      <p specific-use="line">  <italic># additional information to define variables in equations</italic></p>
      <p specific-use="line">  <bold>r_in</bold>:</p>
      <p specific-use="line">   <bold>default</bold>: input <italic># defines variable type</italic></p>
      <p specific-use="line">  <bold>V</bold>:</p>
      <p specific-use="line">   <bold>default</bold>: output</p>
      <p specific-use="line">  <bold>V_t</bold>:</p>
      <p specific-use="line">   <bold>description</bold>: integration variable <italic># optional</italic></p>
      <p specific-use="line">   <bold>default</bold>: variable</p>
      <p specific-use="line">  <bold>tau</bold>:</p>
      <p specific-use="line">   <bold>description</bold>: Synaptic time constant</p>
      <p specific-use="line">   <bold>default</bold>: constant</p>
      <p specific-use="line">  <bold>h</bold>:</p>
      <p specific-use="line">   <bold>default</bold>: constant</p>
      <p>Similar to Python, <italic>YAML</italic> structures information using indentation to improve readability. The <italic>base</italic> attribute may either refer to the Python class that is used to load the template or a parent template. Using the <italic>equations</italic> attribute, an unsorted list of string-based equations should be provided. These equations will be evaluated simultaneously during simulations and need to follow the above defined mathematical syntax. The <italic>variables</italic> attribute gives additional information regarding the variables used within <italic>equations</italic>. The only mandatory attribute of variables is <italic>default</italic> which defines the variable type, data type and initial value. Additional attributes can be defined, e.g. a <italic>description</italic> may help users to understand the template itself or variables in the equations.</p>
      <p>For the Jansen-Rit model, it is useful to define sub-templates for excitatory and inhibitory synapses. These share the same equations, but have different values for the constants <italic>τ</italic> and <italic>h</italic> which can be set in sub-templates, e.g. (values based on [<xref rid="pone.0225900.ref041" ref-type="bibr">41</xref>]):</p>
      <p specific-use="line"><bold>ExcitatorySynapse</bold>:</p>
      <p specific-use="line"> <bold>base</bold>: JansenRitSynapse <italic># parent template</italic></p>
      <p specific-use="line"> <bold>variables</bold>:</p>
      <p specific-use="line">  <bold>h</bold>:</p>
      <p specific-use="line">   <bold>default</bold>: 3.25e−3</p>
      <p specific-use="line">  <bold>tau</bold>:</p>
      <p specific-use="line">   <bold>default</bold>: 10e−3</p>
      <p>Above, the <italic>JansenRitSynapse</italic> template is reused as the <italic>base</italic> template and only the relevant variables are adapted. A single neural mass in the Jansen-Rit model may be implemented as a network node with one or more synapse operators and one operator that the transforms average membrane potential to the average firing rate (PRO, <xref ref-type="disp-formula" rid="pone.0225900.e013">Eq (11)</xref>/<xref ref-type="disp-formula" rid="pone.0225900.e009">Eq (7)</xref>):</p>
      <p specific-use="line"><bold>PyramidalCellPopulation</bold>:</p>
      <p specific-use="line"> <bold>base</bold>: NodeTemplate <italic># Python class for node templates</italic></p>
      <p specific-use="line"> <bold>operators</bold>:</p>
      <p specific-use="line">  - <bold>ExcitatorySynapse</bold> <italic># output: V</italic></p>
      <p specific-use="line">  - <bold>InhibitorySynapse</bold> <italic># output: V</italic></p>
      <p specific-use="line">  - <bold>PotentialToRateOperator</bold> <italic># input: V</italic></p>
      <p>This node template represents the neural population of pyramidal projection cells as depicted in <xref ref-type="fig" rid="pone.0225900.g001">Fig 1C</xref>. PyRates internally orders operators based on their input and output variables. This way, complex operator hierarchies can be built without any additional syntax as long as input and output variable names are consistent across all operators. In this example, two synapse operators receive input from other neural masses (or external sources), transforming firing rates <italic>r</italic> into membrane potentials <italic>V</italic> (rate-to-potential operators, RPO). The synapse operators are independent and on the same hierarchical level. Equations in these two operators can thus be evaluated in parallel. Both synapse operators define the membrane potential <italic>V</italic> as output. The potential-to-rate (PRO) operator on the other hand, receives <italic>V</italic> as input. This is recognised as a dependency and the PRO will be evaluated after the synapse operators have been processed.</p>
      <p>Note that cyclic operator dependencies are not allowed. If necessary, self-edges can be used to connect variables to each other within one node, to implement cyclic dependencies.</p>
      <p>As described earlier, circuits are used in PyRates to represent one or more nodes and their connecting edges. The following circuit template represents the Jansen-Rit model as depicted in <xref ref-type="fig" rid="pone.0225900.g001">Fig 1B</xref>:</p>
      <p specific-use="line"><bold>JansenRitCircuit</bold>:</p>
      <p specific-use="line"> <bold>base</bold>: CircuitTemplate</p>
      <p specific-use="line"> <bold>nodes</bold>: <italic># list nodes and label them</italic></p>
      <p specific-use="line">  <bold>EIN</bold>: ExcitatoryInterneurons</p>
      <p specific-use="line">  <bold>IIN</bold>: InhibitoryInterneurons</p>
      <p specific-use="line">  <bold>PC</bold>: PyramidalCellPopulation</p>
      <p specific-use="line"> <bold>edges</bold>: <italic># assign edges between nodes</italic></p>
      <p specific-use="line">  <italic># − [&lt;source&gt;, &lt;target&gt;, &lt;template_or_operators&gt;, &lt;values&gt;]</italic></p>
      <p specific-use="line">  - <bold>[PC/PRO/r_out, IIN/RPO_e/r_in, null, {weight</bold>: 33.75}]</p>
      <p specific-use="line">  - <bold>[PC/PRO/r_out, EIN/RPO_e/r_in, null, {weight</bold>: 135.}]</p>
      <p specific-use="line">  - <bold>[EIN/PRO/r_out, PC/RPO_e/r_in, null, {weight</bold>: 108.}]</p>
      <p specific-use="line">  - <bold>[IIN/PRO/r_out, PC/RPO_i/r_in, null, {weight</bold>: 33.75}]</p>
      <p>The <italic>nodes</italic> attribute specifies which node templates to use and assigns labels to them. These labels are used in <italic>edges</italic> to define source and target, respectively. Each edge is defined by a list (square brackets) of up to four elements: (1) source specifier, (2) target specifier, (3) template (containing operators), and (4) additional named values or attributes. The format for source and target is <monospace>&lt;node_label&gt;/&lt;operator&gt;/&lt;variable&gt;</monospace>, i.e. an edge establishes a link to a specific variable in a specific operator within a node. Multiple edges can thus interact with different variables on the same node. Note that for brevity the operators were abbreviated here in contrast to the definitions above. In addition to source and target, it is possible to also include operators inside an edge that allow additional transformations specific to the coupling between the source and target variables. These operators can be defined in a separate edge template that is referred to in the third list entry. In this particular example, the entry is left empty (“null”). The fourth list entry contains named attributes, which are saved on the edge. Two default attributes exist: <monospace>weight</monospace> scales the output variable of the edge before it is projected to the target and defaults to <monospace>1.0</monospace>; <monospace>delay</monospace> determines whether the information passing through the edge is applied instantaneously (i.e. in the next simulation time step) or after a discrete delay (defined in seconds). By default, no delays are set. Additional attributes may be defined, e.g. to adapt values of operators inside the edge.</p>
      <p>In the above example, all edges project the outgoing firing rate <italic>r</italic><sub><italic>out</italic></sub> from one node to the incoming firing rate <italic>r</italic><sub><italic>in</italic></sub> of a different node, rescaled by an edge-specific weight. Values of the latter are taken from the original paper by Jansen and Rit [<xref rid="pone.0225900.ref029" ref-type="bibr">29</xref>]. This example with the given values can be used to simulate alpha activity in EEG or MEG.</p>
      <p>Jansen and Rit also investigated how more complex components of visual evoked potentials arise from the interaction of two circuits, one representing visual cortex and one prefrontal cortex [<xref rid="pone.0225900.ref029" ref-type="bibr">29</xref>]. In PyRates, circuits can be inserted into other circuits alongside nodes. A template for the two-circuit example from [<xref rid="pone.0225900.ref029" ref-type="bibr">29</xref>] could look like this:</p>
      <p specific-use="line"><bold>DoubleJRCircuit</bold>:</p>
      <p specific-use="line"> <bold>base</bold>: CircuitTemplate</p>
      <p specific-use="line"> <bold>circuits</bold>: <italic># define sub−circuits and their labels</italic></p>
      <p specific-use="line">  <bold>JRC1</bold>: JansenRitCircuit</p>
      <p specific-use="line">  <bold>JRC2</bold>: JansenRitCircuit</p>
      <p specific-use="line"> <bold>edges</bold>: <italic># assign edges between nodes in sub−circuits</italic></p>
      <p specific-use="line">  - <bold>[JRC1/PC/PRO/r_out, JRC2/PC/RPO_e/r_in, null, {weight</bold>: 10.,</p>
      <p specific-use="line">                        <bold>delay</bold>: 0.0}]</p>
      <p specific-use="line">  - <bold>[JRC2/PC/PRO/r_out, JRC1/PC/RPO_e/r_in, null, {weight</bold>: 10.,</p>
      <p specific-use="line">                        <bold>delay</bold>: 0.0}]</p>
      <p>Circuits are added to the template in the same way as nodes, the only difference being the attribute name <italic>circuits</italic>. Edges are also defined similarly. Source and target keys start with the assigned sub-circuit label, followed by the label of the population within that circuit and so on. For heterogeneous or small networks it makes sense to build the entire circuit hierarchy with templates. For large-scale networks, PyRates also allows the loading of a connectivity matrix from which to build the network. This is realized via the Python interface. Assuming that a JRC template has been set up containing the 3 nodes (PC, EIN, IIN), the syntax for adding edges from a matrix is:</p>
      <p specific-use="line">jrc = circuit_template.<bold>apply</bold>()</p>
      <p specific-use="line">jrc.add_edges_from_matrix(source_var=’RPO/m_out’,</p>
      <p specific-use="line">            target_var=’RPO_e_pc/m_in’,</p>
      <p specific-use="line">            nodes=[’PC’, ’EIN’, ’IIN’],</p>
      <p specific-use="line">            weight = C)</p>
      <p>Here, <italic>C</italic> refers to a 3 x 3 matrix containing the connection strengths. It is also possible to define entire models (or even templates) using mere Python. Similar to YAML templates, templates defined in Python can also be adapted when they are referenced, to perform minor tweaks instead of defining multiple templates for small variations. For more information on alternative ways to set up a network and further examples, we refer the interested reader to the online documentation at <ext-link ext-link-type="uri" xlink:href="https://pyrates.readthedocs.io">pyrates.readthedocs.io</ext-link>.</p>
    </sec>
    <sec id="sec007">
      <title>From model to simulation</title>
      <p>All frontend interfaces translate a user-defined model into a set of Python objects that we call the <italic>intermediate representation</italic> (IR, middle layer in <xref ref-type="fig" rid="pone.0225900.g002">Fig 2</xref>). This paragraph will give more details on the IR and explain how a simulation can be started and evaluated based on the previously defined model. A model circuit is represented by the <monospace>CircuitIR</monospace> class, which builds a network graph representation of the model using the software package <italic>networkx</italic> [<xref rid="pone.0225900.ref047" ref-type="bibr">47</xref>]. The package is commonly used for graph-based data representation in Python and provides many interfaces to manipulate, analyze and visualize graphs. The <monospace>CircuitIR</monospace> contains additional convenience methods to plot a network graph or access and manipulate its content. The following lines of code load the <monospace>JansenRitCircuit</monospace> template that was defined above and transforms the template into a <monospace>CircuitIR</monospace> instance:</p>
      <p specific-use="line"><bold>from</bold> pyrates.frontend <bold>import</bold> CircuitTemplate</p>
      <p specific-use="line"># read YAML template and convert to Python object</p>
      <p specific-use="line">template = CircuitTemplate.from_yaml(“path/to/file/JansenRitCircuit”)</p>
      <p specific-use="line"># transform template object to intermediate representation</p>
      <p specific-use="line">circuit_ir = template.<bold>apply</bold>()</p>
      <p>The <monospace>apply</monospace> method also accepts additional arguments to change parameter values while applying the template.</p>
      <p>Actual simulations take place in the compute backend (see <xref ref-type="fig" rid="pone.0225900.g002">Fig 2</xref>). Currently, the user can choose between two backend implementations. The default backend is based on <italic>NumPy</italic> and provides particularly fast simulations on single CPUs and, in combination with the Python distribution provided by Intel, on multiple CPUs. The alternative backend is based on <italic>tensorflow 2.0</italic> [<xref rid="pone.0225900.ref048" ref-type="bibr">48</xref>], which makes use of dataflow graphs to run parallel computations on CPUs and GPUs. For optimal parallelization of network representations, PyRates can summarize identical sets of (scalar) mathematical operations into more efficient vector operations. Automatic vectorization can be enabled via the <monospace>vectorization</monospace> keyword argument of the <monospace>compile</monospace> method:</p>
      <p specific-use="line">net = circuit_ir.<bold>compile</bold>(vectorization = True, dt = 0.0001, solver=’euler’)</p>
      <p>where <monospace>vectorization = False</monospace> indicates that the model should be processed as is, while <monospace>vectorization = True</monospace> reduces identical nodes to one vectorized node. <monospace>dt</monospace> refers to the (integration) time step in seconds used during simulations. By default, differential equations are integrated using an explicit Euler algorithm which is the most common algorithm used in stochastic network simulations. In addition, PyRates provides two alternative numerical solvers that can be chosen via the <monospace>solver</monospace> argument. They implement the midpoint method (<monospace>solver=’midpoint’</monospace>) and a 2/3 Runge-Kutta algorithm (<monospace>solver=’rk23’</monospace>). The unit of <monospace>dt</monospace> and the choice of a suitable value depends on time constants defined in the model. Here, we chose a value of 0.1<italic>ms</italic>, which is consistent with the numerical integration schemes reported in the literature (e.g. [<xref rid="pone.0225900.ref040" ref-type="bibr">40</xref>, <xref rid="pone.0225900.ref043" ref-type="bibr">43</xref>]). A simulation can be executed by calling the <monospace>run</monospace> method, e.g.:</p>
      <p specific-use="line">results, time = net.run(simulation_time = 10.0, <italic># in seconds</italic></p>
      <p specific-use="line">          outputs={’V’: ‘PC/PRO/V’},</p>
      <p specific-use="line">          sampling_step_size = 0.01) <italic># in seconds</italic></p>
      <p>This example defines a total <italic>simulation time</italic> of 10 seconds and specifies that only the membrane voltage from <italic>PC</italic> (pyramidal cell) nodes should be observed. Note that variable histories will only be stored for variables defined as output. All other data is overwritten as soon as possible to save memory. Along this line, a sampling step-size can be defined that determines the distance in time between observation points of the output variable histories. Collected data is formatted as a <monospace>DataFrame</monospace> from the <italic>pandas</italic> package [<xref rid="pone.0225900.ref049" ref-type="bibr">49</xref>], a powerful data structure for serial data that comes with a lot of convenience methods, e.g. for plotting or statistics. To gain any meaningful results from this implementation of a JRC, it needs to be provided input in a biologically plausible range. External inputs can be included via <italic>input</italic> variables. To allow for external input being applied pre-synaptically to the excitatory synapse of the pyramidal cells, one would have to modify the <monospace>JansenRitSynapse</monospace> as follows:</p>
      <p specific-use="line"><bold>JansenRitSynapse_with_input</bold>:</p>
      <p specific-use="line"> <bold>base</bold>: JansenRitSynapse</p>
      <p specific-use="line"> <bold>equations</bold>:</p>
      <p specific-use="line">  <bold>replace</bold>: <italic># insert u by replacing m_in by a sum</italic></p>
      <p specific-use="line">   <bold>r_in</bold>: (r_in + u)</p>
      <p specific-use="line"> <bold>variables</bold>:</p>
      <p specific-use="line">  <bold>u</bold>: <italic># adding the new additional variable u</italic></p>
      <p specific-use="line">   <bold>default</bold>: input</p>
      <p>We reused the previously defined <monospace>JansenRitSynapse</monospace> template and added the variable <monospace>u</monospace> as an input variable by replacing occurrences of <monospace>r_in</monospace> by <monospace>(r_in + u)</monospace> using string replacement. The previously defined equation
<disp-formula id="pone.0225900.e014"><alternatives><graphic xlink:href="pone.0225900.e014.jpg" id="pone.0225900.e014g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M14"><mml:mrow><mml:mtext mathvariant="monospace">d</mml:mtext><mml:mo mathvariant="monospace">/</mml:mo><mml:mtext mathvariant="monospace">dt</mml:mtext><mml:mo mathvariant="monospace">*</mml:mo><mml:mtext mathvariant="monospace">V</mml:mtext><mml:mo mathvariant="monospace">_</mml:mo><mml:mtext mathvariant="monospace">t</mml:mtext><mml:mo mathvariant="monospace">=</mml:mo><mml:mtext mathvariant="monospace">h</mml:mtext><mml:mo mathvariant="monospace">/</mml:mo><mml:mtext mathvariant="monospace">tau</mml:mtext><mml:mo mathvariant="monospace">*</mml:mo><mml:mtext mathvariant="monospace">r</mml:mtext><mml:mo mathvariant="monospace">_</mml:mo><mml:mtext mathvariant="monospace">in</mml:mtext><mml:mo mathvariant="monospace">−</mml:mo><mml:mrow><mml:mo mathvariant="monospace">(</mml:mo><mml:mn mathvariant="monospace">1</mml:mn><mml:mo mathvariant="monospace">.</mml:mo><mml:mo mathvariant="monospace">/</mml:mo><mml:mtext mathvariant="monospace">tau</mml:mtext><mml:mo mathvariant="monospace">)</mml:mo></mml:mrow><mml:mo mathvariant="monospace">^</mml:mo><mml:mn mathvariant="monospace">2</mml:mn><mml:mo mathvariant="monospace">*</mml:mo><mml:mtext mathvariant="monospace">V</mml:mtext><mml:mo mathvariant="monospace">−</mml:mo><mml:mn mathvariant="monospace">2</mml:mn><mml:mo mathvariant="monospace">.</mml:mo><mml:mo mathvariant="monospace">*</mml:mo><mml:mn mathvariant="monospace">1</mml:mn><mml:mo mathvariant="monospace">.</mml:mo><mml:mo mathvariant="monospace">/</mml:mo><mml:mtext mathvariant="monospace">tau</mml:mtext><mml:mo mathvariant="monospace">*</mml:mo><mml:mtext mathvariant="monospace">V</mml:mtext><mml:mo mathvariant="monospace">_</mml:mo><mml:mtext mathvariant="monospace">t</mml:mtext></mml:mrow></mml:math></alternatives></disp-formula>
thus turns into
<disp-formula id="pone.0225900.e015"><alternatives><graphic xlink:href="pone.0225900.e015.jpg" id="pone.0225900.e015g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M15"><mml:mrow><mml:mtext mathvariant="monospace">d</mml:mtext><mml:mo mathvariant="monospace">/</mml:mo><mml:mtext mathvariant="monospace">dt</mml:mtext><mml:mo mathvariant="monospace">*</mml:mo><mml:mtext mathvariant="monospace">V</mml:mtext><mml:mo mathvariant="monospace">_</mml:mo><mml:mtext mathvariant="monospace">t</mml:mtext><mml:mo mathvariant="monospace">=</mml:mo><mml:mtext mathvariant="monospace">h</mml:mtext><mml:mo mathvariant="monospace">/</mml:mo><mml:mtext mathvariant="monospace">tau</mml:mtext><mml:mo mathvariant="monospace">*</mml:mo><mml:mrow><mml:mo mathvariant="monospace">(</mml:mo><mml:mtext mathvariant="monospace">r</mml:mtext><mml:mo mathvariant="monospace">_</mml:mo><mml:mtext mathvariant="monospace">in</mml:mtext><mml:mo mathvariant="monospace">+</mml:mo><mml:mtext mathvariant="monospace">u</mml:mtext><mml:mo mathvariant="monospace">)</mml:mo></mml:mrow><mml:mo mathvariant="monospace">−</mml:mo><mml:mrow><mml:mo mathvariant="monospace">(</mml:mo><mml:mn mathvariant="monospace">1</mml:mn><mml:mo mathvariant="monospace">.</mml:mo><mml:mo mathvariant="monospace">/</mml:mo><mml:mtext mathvariant="monospace">tau</mml:mtext><mml:mo mathvariant="monospace">)</mml:mo></mml:mrow><mml:mo mathvariant="monospace">^</mml:mo><mml:mn mathvariant="monospace">2</mml:mn><mml:mo mathvariant="monospace">*</mml:mo><mml:mtext mathvariant="monospace">V</mml:mtext><mml:mo mathvariant="monospace">−</mml:mo><mml:mn mathvariant="monospace">2</mml:mn><mml:mo mathvariant="monospace">.</mml:mo><mml:mo mathvariant="monospace">*</mml:mo><mml:mn mathvariant="monospace">1</mml:mn><mml:mo mathvariant="monospace">.</mml:mo><mml:mo mathvariant="monospace">/</mml:mo><mml:mtext mathvariant="monospace">tau</mml:mtext><mml:mo mathvariant="monospace">*</mml:mo><mml:mtext mathvariant="monospace">V</mml:mtext><mml:mo mathvariant="monospace">_</mml:mo><mml:mtext mathvariant="monospace">t</mml:mtext></mml:mrow></mml:math></alternatives></disp-formula>
This modification enables the user to apply arbitrary input to the excitatory synapse of the pyramidal cells, using the <monospace>inputs</monospace> parameter of the <monospace>run</monospace> method:</p>
      <p specific-use="line">results, time = net.run(simulation_time = 10.0,</p>
      <p specific-use="line">          outputs={’V’: ‘PC/PRO/V’},</p>
      <p specific-use="line">          inputs={’PC/RPO_e/u’: ext_input})</p>
      <p>In this example, <monospace>ext_input</monospace> would be an array defining the input value for each simulation step. This subsumes a working implementation of a single Jansen-Rit model that can be used as a base unit to construct models of cortico-cortical networks. By using the above defined <italic>YAML</italic> templates, all simulations described in the next section that are based on Jansen-Rit models can be replicated.</p>
    </sec>
    <sec id="sec008">
      <title>Implementing the Montbrió model</title>
      <p>The neural mass model recently proposed by Montbrió and colleagues is a single-population model that is derived from all-to-all coupled quadratic integrate-and-fire (QIF) neurons [<xref rid="pone.0225900.ref043" ref-type="bibr">43</xref>]. It establishes a mathematically exact correspondence between macroscopic (population level) and microscopic (single cell level) states and equations. The model consists of two coupled differential equations that describe the dynamics of mean membrane potential <italic>V</italic> and mean firing rate <italic>r</italic>:
<disp-formula id="pone.0225900.e016"><alternatives><graphic xlink:href="pone.0225900.e016.jpg" id="pone.0225900.e016g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M16"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mo>Δ</mml:mo><mml:mrow><mml:mi>π</mml:mi><mml:msup><mml:mi>τ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>r</mml:mi><mml:mi>V</mml:mi></mml:mrow><mml:mi>τ</mml:mi></mml:mfrac></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(12)</label></disp-formula>
<disp-formula id="pone.0225900.e017"><alternatives><graphic xlink:href="pone.0225900.e017.jpg" id="pone.0225900.e017g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M17"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>τ</mml:mi></mml:mfrac><mml:mo>(</mml:mo><mml:msup><mml:mi>V</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mover><mml:mi>η</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>+</mml:mo><mml:mi>I</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>J</mml:mi><mml:mi>r</mml:mi><mml:mo>-</mml:mo><mml:mi>τ</mml:mi><mml:msup><mml:mi>π</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:msup><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(13)</label></disp-formula>
with intrinsic coupling <italic>J</italic> and input current <italic>I</italic>(<italic>t</italic>). Δ and <inline-formula id="pone.0225900.e018"><alternatives><graphic xlink:href="pone.0225900.e018.jpg" id="pone.0225900.e018g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M18"><mml:mover><mml:mi>η</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula> may be interpreted as the spread and mean of the distribution of excitability levels within the population. Note that the time constant <italic>τ</italic> was set to 1 and hence omitted in the derivation by Montbrió and colleagues [<xref rid="pone.0225900.ref043" ref-type="bibr">43</xref>]. The following operator template implements these equations in PyRates:</p>
      <p specific-use="line"><bold>MontbrioOperator</bold>:</p>
      <p specific-use="line"> <bold>base</bold>: OperatorTemplate</p>
      <p specific-use="line"> <bold>equations</bold>:</p>
      <p specific-use="line">  - “d/dt * r = delta/(PI * tau**2) + 2.*r*V/tau”</p>
      <p specific-use="line">  - “d/dt * V = (V**2 + eta + inp) / tau + J*r − tau*(PI*r)**2”</p>
      <p specific-use="line"> <bold>variables</bold>:</p>
      <p specific-use="line">  …</p>
      <p>Variable definitions are omitted in the above template for brevity. Since a single population in the Montbrió model is already capable of oscillations, a meaningful network can be set up with a single neural mass as follows:</p>
      <p specific-use="line"><bold>MontbrioPopulation</bold>:</p>
      <p specific-use="line"> <bold>base</bold>: NodeTemplate</p>
      <p specific-use="line"> <bold>operators</bold>:</p>
      <p specific-use="line">  - <bold>MontbrioOperator</bold></p>
      <p specific-use="line"><bold>MontbrioNetwork</bold>:</p>
      <p specific-use="line"> <bold>base</bold>: CircuitTemplate</p>
      <p specific-use="line"> <bold>nodes</bold>:</p>
      <p specific-use="line">  <bold>Pop1</bold>: MontbrioPopulation</p>
      <p specific-use="line"> <bold>edges</bold>:</p>
      <p>This template can be used to replicate the simulation results presented in the next section that were obtained from the Montbrió model.</p>
    </sec>
    <sec id="sec009">
      <title>Exploring model parameter spaces</title>
      <p>When setting up computational models, it is often important to explore the relationship between model behavior and model parametrization. PyRates offers a simple but efficient mechanism to run many such simulations on parallel computation hardware. The function <monospace>pyrates.utility.grid_search</monospace> takes a single model template along with a specification of the parameter grid to sample sets of parameters from. It then constructs multiple model instances with differing parameters and adds them to the same circuit, but without edges between individual instances. All model instances can thus be computed efficiently in parallel on the same parallel hardware instead of executing them consecutively. How many instances can be simulated on a single piece of hardware depends on the memory capacities and number of parallel compute units. Additionally, PyRates provides an interface for deploying large parameter grid searches across multiple work stations. This allows the splitting of large parameter grids into smaller grids that can be run in parallel on multiple machines. For a tutorial on how to use those functionalities, we refer the interested reader to the jupyter notebooks that can be found at <ext-link ext-link-type="uri" xlink:href="https://github.com/pyrates-neuroscience/PyRates/tree/master/documentation">https://github.com/pyrates-neuroscience/PyRates/tree/master/documentation</ext-link> which contain various examples of parameter grid searches.</p>
    </sec>
    <sec id="sec010">
      <title>Visualization and data analysis</title>
      <p>PyRates features built-in functions for quick data analysis and visualization as well as native support for external libraries due to its commonly used data structures. On the one hand, network graphs are based on <italic>networkx</italic> Graph objects [<xref rid="pone.0225900.ref047" ref-type="bibr">47</xref>]. Hence, the entire toolset of networkx is natively supported, including an interface to the <italic>graphviz</italic> [<xref rid="pone.0225900.ref050" ref-type="bibr">50</xref>] library. Additionally, we provide functions for quick visualization of a network model within PyRates. On the other hand, simulation results are returned as a <italic>pandas.DataFrame</italic> which is a widely adopted structure for tabular data with powerful built-in analysis methods [<xref rid="pone.0225900.ref049" ref-type="bibr">49</xref>]. While this data structure already allows for an intuitive interface to the <italic>seaborn</italic> plotting library by itself, we also provide a number of visualization functions such as time-series plots, heat maps, and polar plots in PyRates. Most of those provide direct interfaces to plotting functions from <italic>seaborn</italic> and <italic>MNE-Python</italic>, the latter being an analysis toolbox for EEG and MEG data [<xref rid="pone.0225900.ref051" ref-type="bibr">51</xref>, <xref rid="pone.0225900.ref052" ref-type="bibr">52</xref>].</p>
    </sec>
  </sec>
  <sec sec-type="results" id="sec011">
    <title>Results</title>
    <p>The aim of this section is to (1) demonstrate that numerical simulations of models implemented in PyRates show the expected results and (2) analyze the computational capabilities and scalability of PyRates on a number of benchmarks. As explained previously, we chose the models proposed by Jansen and Rit and Montbrió and colleagues as exemplary models for these demonstrations. We will replicate the basic model dynamics under extrinsic input as reported in the original publications. To this end, we will compare the relationship between changes in the model parametrization and the model dynamics with the relationship reported in the literature. For this purpose, we will use the grid search functionality of PyRates, allowing evaluation of the model behavior for multiple parametrizations in parallel. Having validated the model implementations in PyRates, we will use the JRC as base model for a number of benchmark simulations. All simulations performed throughout this section use an explicit Euler integration scheme with a simulation step size of 0.1 ms. They have been run on a custom Linux machine with an NVidia Geforce Titan XP GPU with 12GB G-DDR5 graphic memory, a 3.5 GHz Intel Core i7 (4th generation) and 16 GB DDR3 working memory. Note that we provide Python scripts that can be used to replicate all of the simulation results reported below. They are available at <ext-link ext-link-type="uri" xlink:href="https://github.com/pyrates-neuroscience/PyRates/tree/master/documentation">https://github.com/pyrates-neuroscience/PyRates/tree/master/documentation</ext-link>.</p>
    <sec id="sec012">
      <title>Validation of model implementations</title>
      <sec id="sec013">
        <title>Jansen-Rit circuit</title>
        <p>The Jansen-Rit circuit has been shown to be able to produce a variety of steady-state responses [<xref rid="pone.0225900.ref029" ref-type="bibr">29</xref>, <xref rid="pone.0225900.ref030" ref-type="bibr">30</xref>, <xref rid="pone.0225900.ref042" ref-type="bibr">42</xref>]. In other words, the JRC has a number of bifurcation parameters that can lead to qualitative changes in the model’s state dynamics. In their original publication, Jansen and Rit delivered random synaptic input between 120 and 320 Hz to the projection cells while changing the scaling of the internal connectivities <italic>C</italic> [<xref rid="pone.0225900.ref029" ref-type="bibr">29</xref>] (reflected by the parameters <italic>C</italic><sub><italic>xy</italic></sub> in <xref ref-type="fig" rid="pone.0225900.g001">Fig 1B</xref>). As visualized in Fig 3 of [<xref rid="pone.0225900.ref029" ref-type="bibr">29</xref>], the model produced (noisy) sinusoidal oscillations in the alpha band for connectivity scalings <italic>C</italic> = 128 and <italic>C</italic> = 135, thus reflecting a major component of the EEG signal in primary visual cortex. For other scalings, it produced either random noise (<italic>C</italic> = 68 and <italic>C</italic> = 1350) or large-amplitude spiking behavior (<italic>C</italic> = 270 and <italic>C</italic> = 675). We chose to replicate this figure with our implementation of the JRC in PyRates. We simulated 2 s of JRC behavior for each internal connectivity scaling <italic>C</italic> ∈ {68, 128, 135, 270, 675, 1350}. All other model parameters were set according to the parameters chosen in [<xref rid="pone.0225900.ref029" ref-type="bibr">29</xref>]. The average membrane potential of the projection cell population (depicted as <italic>PC</italic> in <xref ref-type="fig" rid="pone.0225900.g001">Fig 1B</xref>) is depicted in the left panel of <xref ref-type="fig" rid="pone.0225900.g003">Fig 3A</xref> for each condition.</p>
        <fig id="pone.0225900.g003" orientation="portrait" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pone.0225900.g003</object-id>
          <label>Fig 3</label>
          <caption>
            <title>Jansen-Rit and Montbrió model validations.</title>
            <p><bold>A</bold> Shows the simulation results obtained from a single Jansen-Rit model. On the left hand side, the average membrane potentials of the pyramidal cell population are depicted for different connectivity scalings C. On the right hand side, the dominant oscillation frequency of the pyramidal cell membrane potentials (evaluated over a simulation period of 60 seconds) is depicted for different synaptic time-scales <italic>τ</italic><sub><italic>e</italic></sub> and <italic>τ</italic><sub><italic>i</italic></sub>. The frequencies are categorized into the following bands: <italic>δ</italic> (1-4 Hz), <italic>θ</italic> (4-8 Hz), <italic>α</italic> (8-12 Hz), <italic>β</italic> (12–30 Hz), <italic>γ</italic> (&gt; 30 Hz) and h.s. (hyper signal) for signals not representative of any EEG component. <bold>B</bold> Shows the simulation results obtained from a single Montbrió model. The average membrane potentials <italic>v</italic>, average firing rates <italic>r</italic> and input currents are depicted for constant and oscillatory input on the left and right hand side, respectively. Time-dependent variables are reported in units of <italic>τ</italic>, which was set to <italic>τ</italic> = 1.0 in accordance with the simulations performed by Montbrió and colleagues. Following the definitions of Montbrió and colleagues, membrane potential and input are reported as unit-less variables.</p>
          </caption>
          <graphic xlink:href="pone.0225900.g003"/>
        </fig>
        <p>Results are in line with our expectations, showing random noise for both the highest and the lowest value of <italic>C</italic>, alpha oscillations for <italic>C</italic> = 128 and <italic>C</italic> = 135, and large-amplitude spiking behavior for the remaining conditions. Furthermore, the membrane potential amplitudes were in the same range as reported in [<xref rid="pone.0225900.ref029" ref-type="bibr">29</xref>] in each condition. Next to the connectivity scaling, the synaptic time scales <italic>τ</italic> of the JRC are further bifurcation parameters that have been shown to be useful to tune the model to represent different frequency bands of the brains’ EEG signal [<xref rid="pone.0225900.ref030" ref-type="bibr">30</xref>]. As demonstrated by David and Friston [<xref rid="pone.0225900.ref030" ref-type="bibr">30</xref>], varying these time scales between 1 and 60 ms leads to JRC dynamics that are representative of the delta, theta, alpha, beta and gamma frequency bands in the EEG. Due to its practical importance, we chose to replicate this parameter study as well. We systematically varied the excitatory and inhibitory synaptic timescales (<italic>τ</italic><sub><italic>e</italic></sub> and <italic>τ</italic><sub><italic>i</italic></sub>) between 1 and 60 ms. For each condition, we adjusted the excitatory and inhibitory synaptic efficacies, such that the product <italic>Hτ</italic> was held constant. All other parameters were chosen as reported in [<xref rid="pone.0225900.ref030" ref-type="bibr">30</xref>] for the respective simulation. We then simulated the JRC behavior for 1 min and evaluated the maximum frequency of the power spectral density of the pyramidal cells membrane potential fluctuations. The results of this procedure are visualized in the right panel of <xref ref-type="fig" rid="pone.0225900.g003">Fig 3A</xref>. They are in accordance with the results reported in [<xref rid="pone.0225900.ref030" ref-type="bibr">30</xref>], showing response frequencies that range from the delta (1-4 Hz) to the gamma (&gt; 30 Hz) range, as well as the hyper signal not representative of any EEG signal for too high ratios of <inline-formula id="pone.0225900.e019"><alternatives><graphic xlink:href="pone.0225900.e019.jpg" id="pone.0225900.e019g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M19"><mml:mfrac><mml:msub><mml:mi>τ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>τ</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:mfrac></mml:math></alternatives></inline-formula>. Together, we are confident that our implementation of the JRC in PyRates accurately resembles the originally proposed model within the investigated dynamical regimes. Note, however, that faster synaptic time-constants or extrinsic input fluctuations should be handled carefully. For such cases, we recommend either reducing the above reported integration step size or choosing a more elaborate numerical solver (midpoint or Runge-Kutta 2/3) in order to avoid numerical instabilities.</p>
      </sec>
      <sec id="sec014">
        <title>Montbrió model</title>
        <p>Even though the Montbrió model is only a single-population model, it has been shown to have a rich dynamic profile with bi-stable and even chaotic regimes [<xref rid="pone.0225900.ref043" ref-type="bibr">43</xref>, <xref rid="pone.0225900.ref053" ref-type="bibr">53</xref>]. To investigate the response of the model to non-stationary inputs, Montbrió and colleagues initialized the model in a bi-stable dynamic regime and applied (1) constant and (2) sinusoidal extrinsic forcing within a short time-window. In the constant forcing condition they were able to show that the two different stable dynamic regimes of the model (stable focus and stable fixed point) could be switched between via a simple, transient step-function input. In the oscillatory forcing condition, on the other hand, they demonstrated that smooth changes in the extrinsic input was also able to cause the same state transitions in the model. This behavior can be observed in Fig 2 in [<xref rid="pone.0225900.ref043" ref-type="bibr">43</xref>] and we chose to replicate it with our implementation of the Montbrió model in PyRates. With all model parameters set to the values reported in [<xref rid="pone.0225900.ref043" ref-type="bibr">43</xref>] for this experiment, we simulated the model’s behavior for the constant and periodic forcing conditions. For both conditions, the external forcing strength was chosen as <italic>I</italic> = 30, while the frequency of the oscillatory forcing was chosen as <inline-formula id="pone.0225900.e020"><alternatives><graphic xlink:href="pone.0225900.e020.jpg" id="pone.0225900.e020g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M20"><mml:mrow><mml:mi>ω</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mi>π</mml:mi><mml:mn>20</mml:mn></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula>. Note that in accordance with the model definition of Montbrió and colleagues, time-dependent variables are reported in units of <italic>τ</italic> (which was set to <italic>τ</italic> = 1), while all other variables such as <italic>v</italic> and <italic>I</italic> are unit-less [<xref rid="pone.0225900.ref043" ref-type="bibr">43</xref>]. As shown in <xref ref-type="fig" rid="pone.0225900.g003">Fig 3B</xref>, we were able to replicate the above described model behavior. Constant forcing led to damped oscillatory responses of different frequency and amplitude at both onset and offset of the stimulus, whereas oscillatory forcing led to damped oscillatory responses around the peaks of the sinusoidal stimulus. Again, we take this as strong evidence for the correct representation of the Montbrió model by PyRates.</p>
      </sec>
    </sec>
    <sec id="sec015">
      <title>Benchmarks</title>
      <p>Neural simulation studies can differ substantially in the size and structure of the networks they investigate, leading to different computational loads. In PyRates, a number of backends and parallelization strategies are available for numerical simulations and their optimal choice may depend on the network architecture. In this paragraph, we describe how simulation durations in PyRates scale as a function of network size and connectivity and how this scaling behavior differs between different backends and parallelization types. For this purpose, we considered parallelization on a single machine vs. parallelized computations on multiple machines and simulations using the NumPy backend (CPU-based, version 1.17.2) vs. simulations using the tensorflow backend (supporting GPU parallelization, version 2.0.0-rc0).</p>
      <p>In a first benchmark, we simulated the behavior of different JRC networks using either the NumPy or the tensorflow backend. Each network consisted of <italic>N</italic> ∈ {2<sup>0</sup>, 2<sup>1</sup>, 2<sup>2</sup>, …, 2<sup>11</sup>} randomly coupled JRCs with a coupling density of <italic>p</italic> ∈ {0.0, 0.25, 0.5, 0.75, 1.00}. Here, the latter refers to the relative number of pairwise connections between all pairs of JRCs that were established. Each JRC was parametrized such that it expressed waxing-and-waning alpha oscillations (<italic>C</italic> = 135.0; for all other parameters see [<xref rid="pone.0225900.ref029" ref-type="bibr">29</xref>]). The behavior of these networks was evaluated for a total of 1 s, leading to an overall number of 10<sup>4</sup> simulation steps to be performed in each condition (given a step-size of 0.1 ms). To make the benchmark comparable to realistic simulation scenarios, we applied extrinsic input to each JRC and tracked the average membrane potential of every JRC’s projection cell population with a time resolution of 1 ms as output. Thus, the number of input and output operations also scaled with the network size. We assessed the time in seconds needed by PyRates to execute the run method of its backend in each condition, thus excluding the model initiation time. This was done via the Python internal package <italic>time</italic>. To account for random fluctuations due to background processes, we chose to report average simulation durations over <italic>N</italic><sub><italic>R</italic></sub> = 10 repetitions of each condition. To provide an estimate of these fluctuations, we calculated the average variation in the simulation duration <italic>d</italic> over conditions as <inline-formula id="pone.0225900.e021"><alternatives><graphic xlink:href="pone.0225900.e021.jpg" id="pone.0225900.e021g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M21"><mml:mrow><mml:mi>σ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>d</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:msub><mml:mi>N</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mfrac><mml:mo>∑</mml:mo><mml:mi>c</mml:mi><mml:mfrac><mml:mrow><mml:mo form="prefix" movablelimits="true">max</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>-</mml:mo><mml:mo form="prefix" movablelimits="true">min</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:mo>〉</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula>, with <italic>c</italic> being the condition index and 〈<italic>d</italic>〉 representing the expectation of <italic>d</italic>. We found average variations of <italic>σ</italic>(<italic>d</italic>) = 0.42<italic>s</italic> and <italic>σ</italic>(<italic>d</italic>) = 1.55<italic>s</italic> for the NumPy and tensorflow backend, respectively, which reflects the slightly stronger noise in the simulation duration we found for the tensorflow backend. The average simulation durations over conditions are visualized in <xref ref-type="fig" rid="pone.0225900.g004">Fig 4A and 4B</xref> for the NumPy and tensorflow backend, respectively. The average run times of the NumPy and tensorflow backend ranged between 2.5 and 18.1 seconds, and 13.2 and 20.3 seconds, respectively. Thus, the NumPy backend (running merely on the CPU) outperformed the tensorflow backend (running on CPU and GPU) on all considered network configurations. However, on large and densely connected networks, the tensorflow and NumPy backend expressed nearly the same simulation duration. This reflects the stronger parallelization capacities of the tensorflow backend, which is visible in its weaker scaling of the simulation duration with network size and coupling density. We expect this trend to lead to an advantage of the tensorflow backend for even larger networks. However, simulations of larger network sizes exceeded the working memory capacities of the machine we ran our benchmarks on. Together, these results demonstrate the effectiveness of PyRates’ backends in parallelizing network computations on CPUs and GPUs. While the NumPy backend showed the shortest run times for this benchmark, the tensorflow backend expressed less scaling behavior with the problem size. Thus, the latter might be superior in large-scale neural model simulations performed on a machine with better hardware configurations.</p>
      <fig id="pone.0225900.g004" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0225900.g004</object-id>
        <label>Fig 4</label>
        <caption>
          <title>PyRates benchmarks.</title>
          <p>Benchmark results for 1 s simulations run in PyRates with a simulation step-size of 0.1 ms. <bold>A</bold> and <bold>B</bold> Show average simulation durations over 10 independent simulations for networks with different numbers of Jansen-Rit circuits (N) and differently dense coupling between the JRCs (p), performed on the NumPy (CPU) and tensorflow (CPU+GPU) backend, respectively. <bold>C</bold> Shows the average simulation durations for parameter sweeps over N different parametrizations of a network of 2 bidirectionally, delay-coupled Jansen-Rit circuits. Averages were again calculated over 10 independent runs of each parameter sweep.</p>
        </caption>
        <graphic xlink:href="pone.0225900.g004"/>
      </fig>
      <p>In a second benchmark, we examined the simulation time scaling in parameter sweeps performed via the grid search functionalities of PyRates on a single machine and on a cluster of 3 machines. The hardware specifications of each of those 3 machines were comparable to the ones reported in the beginning of this section. As an exemplary parameter sweep, we explored a parameter set which is prototypically investigated within the fields of connectomics and coupled oscillators, i.e. the connectivity scaling and propagation delay. To this end, we set up a network of 2 JRCs, with bidirectional coupling between their pyramidal cell populations. The bidirectional coupling was parametrized via a homogeneous coupling strength <italic>κ</italic> and a homogeneous propagation delay <italic>τ</italic> (in seconds). In each benchmark condition a parameter sweep was performed across all combinations of <italic>κ</italic> and <italic>τ</italic>. Thereby, the parameters were always varied within the ranges of <italic>κ</italic> ∈ [0.0, 200.0] and <italic>τ</italic> ∈ [0.0, 0.01], and only the number of steps between the limits of those ranges was varied across benchmark conditions. For example, a benchmark condition with 10 steps, would translate into a parameter sweep across all combinations of 10 different values of <italic>κ</italic> and <italic>τ</italic> and would hence result in <italic>N</italic> = 100 differently parametrized versions of the 2 coupled JRCs. All other parameters of the JRCs were the same as in the first benchmark. In each benchmark condition, 10 numerical simulation were performed for every network parametrization with a simulation time of <italic>T</italic> = 1<italic>s</italic>. Their average duration in dependence of <italic>N</italic> is visualized in <xref ref-type="fig" rid="pone.0225900.g004">Fig 4C</xref> for simulations performed on a single machine and on a 3-machine cluster, either using the NumPy or the tensorflow backend. Note that we also plotted the standard deviations across the 10 repetitions in each condition as error bars. However, those deviations were too small to be visible in <xref ref-type="fig" rid="pone.0225900.g004">Fig 4C</xref>. Also, these durations were in general larger than the ones reported in the first benchmark, because they include both the time to build the network and the time to perform the actual simulation. Since the network building process is not yet parallelized in PyRates, its duration shows stronger scaling behavior with the network size than the mere simulation times. As can be seen, the single machine outperformed the cluster for <italic>N</italic> &lt; 900. Again, this can be explained by the overhead generated by the distribution of parameter chunks across the different machines and the collection of results from those machines after they finished their simulations. However, with increasing <italic>N</italic>, the benefit of parallelized simulations on multiple machines started to outweigh those costs, until reaching a maximum speed-up at <italic>N</italic> = 10000, where the 3-machine cluster was approximately 3 times faster than the single machine. This demonstrates that the maximal speed-up of parameter sweeps performed on compute clusters directly scales with the size of the cluster, which is a beneficial property for investigations of high-dimensional parameter spaces. In addition, <xref ref-type="fig" rid="pone.0225900.g004">Fig 4C</xref> shows that the speed-ups that resulted from different choices of backends were relatively small in comparison to the speed-ups achieved by running a parameter sweep on a single machine or on a cluster. This reflects the strong influence of the time it takes PyRates to build the network on the overall simulation duration <italic>T</italic>. Since these network building times do not differ between backends, we found a relatively small difference between NumPy and tensorflow backends in those parameter sweeps. Nonetheless, the tensorflow backend eventually outperformed the NumPy backend on large parameter sweeps (<italic>N</italic> ≥ 2500).</p>
    </sec>
  </sec>
  <sec sec-type="conclusions" id="sec016">
    <title>Discussion</title>
    <p>In this work we have presented PyRates, a novel Python framework for designing neural models and performing numerical simulations of their dynamic behavior. We introduced the frontend, including its user interfaces, structure, and mathematical syntax, and demonstrated how to build neural models, run numerical simulations, and perform parameter sweeps in PyRates. For validation purposes, we implemented the neural population models proposed by Jansen and Rit [<xref rid="pone.0225900.ref029" ref-type="bibr">29</xref>] and Montbrió and colleagues [<xref rid="pone.0225900.ref043" ref-type="bibr">43</xref>] and successfully replicated their key dynamic features. These results strongly suggest that both the model configurations produced by our frontend and their translation into compute graphs by our backend are accurate. Additionally, we tested the computational power of our backend on a number of different benchmarks. Those benchmarks consisted of simulations of JRC networks that differed in the number of their nodes and edges. We demonstrated that the CPU-based NumPy backend is most efficient for simulations of networks with up to a few thousand nodes, whereas the tensorflow backend (which can make use of GPUs) simulation durations showed the best scaling behavior with the problem size. The latter suggests an advantage of the tensorflow backend over the NumPy backend on large-scale neural network simulations with more than 10000 nodes. Indeed, we found the tensorflow backend to be more efficient on parameter sweeps over <italic>N</italic> ≥ 2500 parametrizations. Furthermore, we have shown how model parameter sweeps can benefit from parallelization on multiple machines.</p>
    <p>From these results, we conclude that PyRates is a powerful simulation framework that enables highly efficient neural network simulations. The main questions we will address in the following discussion are (1) why is PyRates a valuable addition to established neural simulation software, and (2) in which cases can researchers benefit from using it.</p>
    <sec id="sec017">
      <title>PyRates in the context of existing neural simulation frameworks</title>
      <p>Within the domain of neural simulation frameworks, PyRates belongs to the family of graph-based neural simulators. In both its frontend and backend, it represents a neural model as a network of nodes connected by edges. PyRates makes no inherent assumptions concerning the spatial scale of nodes and edges in its networks, thus rendering it feasible for neural networks of any type. Additionally, PyRates allows for merging and hierarchical organization of neural networks by building graphs from sub-graphs. Hence, our tool can also be used to build multi-scale models, <italic>e.g</italic>. a macroscopic network of connected neural populations, with some populations of interest being represented by sub-networks of single neurons.</p>
      <p>This being said, PyRates has only been systematically tested on rate-based population models. These differ qualitatively from spiking neuron models in terms of output variable, which is continuous for rate-based models but discrete for spiking neuron models. While it is in principle possible to implement such discrete spiking mechanisms, the compute engine is not optimized for it, since it projects output variables at each time-step to their targets in the network. This means that the projection operation will be performed regardless of whether a spike is produced or not, leading to considerable increases in computation time for large, densely connected, single cell networks. Hence, when dealing with neuroscientific questions that implicate the use of spiking neuron models, we currently recommend to use simulation tools such as Nengo [<xref rid="pone.0225900.ref013" ref-type="bibr">13</xref>], NEST [<xref rid="pone.0225900.ref014" ref-type="bibr">14</xref>], ANNarchy [<xref rid="pone.0225900.ref015" ref-type="bibr">15</xref>], Brian [<xref rid="pone.0225900.ref016" ref-type="bibr">16</xref>], NEURON [<xref rid="pone.0225900.ref017" ref-type="bibr">17</xref>], BioNet [<xref rid="pone.0225900.ref020" ref-type="bibr">20</xref>] or NetPyNE [<xref rid="pone.0225900.ref021" ref-type="bibr">21</xref>]. Such questions may involve problems where specific spike-timings have a non-negligible influence, where dendritic tree architectures are important or, more generally, where the variable of interest loses its meaning when averaged over time or over many neurons.</p>
      <p>Of course, all of the above listed tools can be applied in other scenarios as well, even for macroscopic neural network simulations. However, if the variable of interest in a given model can be expressed as an average over many cells and single cell dynamics can be neglected, mean-field approaches such as the neural population models used throughout this article will be considerably faster and thus allow for the investigation of larger networks and parameter spaces. In general, most frameworks that feature generic code generation should allow the implementation of such models. From the above mentioned tools, Brian and ANNarchy belong to that category. Brian is strictly aimed at spike-based simulations and thus not optimized for continuous output variables like firing rates, whereas ANNarchy provides features for spike- and rate-based neural simulations. Nonetheless, it is designed for single-cell network simulations, so most of the templates it provides for neurons or populations are not necessarily applicable to mean-field models. Other simulation frameworks that provide explicit mean-field modeling mechanisms include TVB [<xref rid="pone.0225900.ref054" ref-type="bibr">54</xref>], DCM [<xref rid="pone.0225900.ref012" ref-type="bibr">12</xref>], DiPDE [<xref rid="pone.0225900.ref055" ref-type="bibr">55</xref>] and MIIND [<xref rid="pone.0225900.ref056" ref-type="bibr">56</xref>]. Among these, the latter two focus strongly on so-called population density techniques, which can describe the full voltage probability distribution of a population of neurons, instead of merely the mean. Both DiPDE and MIIND focus on the leaky integrate-and-fire neuron as the underlying model to derive the voltage probability distribution from. The advantage of this technique is the more direct and precise relationship between the single cell activity and the population level as compared to mean-field approaches. However, this advantage is payed for by higher computational demands, since a discretized probability distribution is computed at each simulation step instead of a mere point-estimate (i.e. the mean). TVB and DCM, on the other hand, focus on the same mathematical group of neurodynamic models as currently implemented in PyRates, i.e. neural population models. The focus of TVB lies in the simulation of large-scale brain networks via established, preferably homogeneous, local population models. DCM is explicitly designed to infer parameters of a fixed set of pre-implemented models based on a given measure of brain activity. While being the optimal choice for their respective use-cases, both tools lack functionalities that help when implementing custom models.</p>
      <p>We consider the core strengths of PyRates to be its highly generic model definition (comparable to a pure code generation approach) and its two graph-based backends. The former distinguishes PyRates from other simulation frameworks, since it allows the customization of every part of a neural network, as long as a network structure with nodes and edges defined by mathematical operators is maintained. Every single computation that is performed in a PyRates simulation, and every variable that it uses, is defined in the frontend and can be accessed and edited by the user. This allows, for example, the addition of custom synapse types, plasticity mechanisms, complex somatic integration mechanisms, or even axonal cable properties. In addition, edges can access and connect all variables existing pre- or post-node, thus enabling the implementation of projections or plasticity mechanisms that depend on population variables other than firing rates. This generic approach makes PyRates particularly valuable for neuroscientists interested in developing novel neural models or extending existing ones.</p>
      <p>A notion of caution should be added here. The degrees of freedom we provide for setting up models and simulations in PyRates imply that we do not provide safeguards for questionable model definitions. Except for their syntactical correctness, model equations and their hierarchical relationships will not be questioned further by PyRates. Also, inputs and outputs to the model will be added exactly as defined by the user. In other words, while PyRates does provide a considerable number of convenience functions to quickly set up and simulate large neural networks, it still requires users to be aware of potential numerical issues they could run into, if the model or simulation would not be set up correctly. Typical pitfalls include numerical overflows if variables become to large or small for the chosen data type, simulation step sizes that were chosen too large for the internal timescales of a given model, and random variables that are sampled at each simulation step without taking into account the dependency between sampling frequency and simulation step size. We tested numerical solvers providing adaptive time steps as an alternative to our fixed step size solvers to handle the problem of choosing an appropriate integration step size. However, we found those algorithms to be unsuited for network simulations in PyRates, since handling asynchronicity between network nodes created significant computational overhead.</p>
      <p>Regarding PyRates’ second core strength, its backends, we have demonstrated its computational power in various scenarios. It provides optimized representations of large neural networks for simulations on CPUs and GPUs. Parallel execution of network simulations are particularly efficient when its nodes and edges are similar in their mathematical operators, since those similarities are exploited by the automatic vectorization mechanisms of PyRates. In turn, this means that the effectiveness of the parallelization scales negatively with the relative amount of heterogeneity or sequentiality of the network. Networks that consist of highly diverse neural units governed by many, hierarchically dependent operators will show considerably longer simulation durations than networks with very similar elements and a flat operator hierarchy. Thus, PyRates is particularly suited for simulating large, homogeneous networks or conducting parameter studies on small- to medium sized networks. For the latter, PyRates scales particularly well, since the size of the parameter sweep that can be computed in parallel grows with the size of the compute cluster among which our cluster distribution mechanism can distribute the different parametrizations.</p>
    </sec>
    <sec id="sec018">
      <title>Integrating PyRates into neuroscientific work-flows</title>
      <p>Neural population models such as the Jansen-Rit model [<xref rid="pone.0225900.ref029" ref-type="bibr">29</xref>] were originally conceived to understand or predict physical measures of brain activity such as LFPs, EEG/MEG or BOLD-fMRI. Modern neuroscientific workflows, however, go beyond forward simulations of brain activity. For example, The Virtual Brain [<xref rid="pone.0225900.ref054" ref-type="bibr">54</xref>] allows the use of structural (including diffusion-weighted) MRI scans to specify 3-dimensional structure and connectivity of a network design. Dynamic Causal Modeling [<xref rid="pone.0225900.ref012" ref-type="bibr">12</xref>] on the other hand can make use of measured brain activity to infer model parameters (e.g. connectivity constants) that best fit the given data. Both approaches have in common, that brain network models are adapted to individual subjects based on measured data.</p>
      <p>PyRates integrates well with this concept for two reasons. (1) It is designed to provide an easy-to-use interface to construct and adapt network models with more flexibility than comparable tools. (2) Due to its modular software structure, PyRates can easily be extended to interface with existing tools. While the intermediate representation serves as a standard interface, the front- and backends can be exchanged to integrate with other software. For example, PyRates could be extended with a frontend that makes use of structural MRI data via tools provided by TVB. At the same time, the current backend could be extended to generate region-specific models compatible with TVB’s node model interface.</p>
      <p>Currently, PyRates already provides a number of useful interfaces to tools that can be used for setting up models, subsequent analyses of simulated timeseries or model optimization. Two of those interfaces come with the graph representations PyRates uses for networks. As mentioned before, every PyRates network can either be translated into a NumPy- or tensorflow-based compute graph. This enables the usage of every NumPy or tensorflow function that could come in handy for setting up a model in PyRates, be it mathematical functions like <italic>sine</italic> or <italic>max</italic>, variable manipulation methods like <italic>reshape</italic> or <italic>squeeze</italic> or higher-level functions like error measurements or learning-rate decays. For the future, we also plan to provide interfaces to <italic>tensorflow’s</italic> model training features, which would allow to optimize parameters of neural models via gradient-descent based algorithms [<xref rid="pone.0225900.ref048" ref-type="bibr">48</xref>]. As an experimental feature, model parameter optimization is already possible via genetic algorithms, for which an interface is provided in the utility module of PyRates. They allow the definition of an arbitrary objective function for a given model and optimization of that function via subsequent model parameter updates employing mechanisms such as parameter re-combinations and mutations [<xref rid="pone.0225900.ref057" ref-type="bibr">57</xref>]. As with parameter sweeps, these algorithms can be executed either on a single or on multiple machines.</p>
      <p>Since the intermediate representation fully builds on <italic>networkx</italic> graphs, the networkx API can be used to create, modify, analyze or visualize models. This includes interoperability with explicit graph visualization tools like Graphviz [<xref rid="pone.0225900.ref049" ref-type="bibr">49</xref>] or Cytoscape [<xref rid="pone.0225900.ref058" ref-type="bibr">58</xref>] that contain more elaborate features for visualizing complex biological networks. For the processing, analysis and visualization of simulation results, we provide a number of tools that mostly wrap <italic>MNE-Python</italic> [<xref rid="pone.0225900.ref051" ref-type="bibr">51</xref>, <xref rid="pone.0225900.ref052" ref-type="bibr">52</xref>] and <italic>seaborn</italic> [<xref rid="pone.0225900.ref059" ref-type="bibr">59</xref>] functions. For extended use of <italic>MNE-Python</italic>, we also provide a wrapper that allows the translation of every output of a PyRates simulation into an <italic>MNE-Python</italic> object. This is particularly useful for forward simulations of EEG/MEG data, since <italic>MNE-Python</italic> comes with an extensive range of methods for the processing, analysis and visualization of such data. Finally, PyRates can also be used in combination with <italic>pygpc</italic>, a generalized polynomial chaos (GPC) toolbox for uncertainty quantification and sensitivity analysis publicly available under <ext-link ext-link-type="uri" xlink:href="https://github.com/konstantinweise/pygpc">https://github.com/konstantinweise/pygpc</ext-link>. Via this interface it is possible to define a model plus a set of model parameters, including their respective uncertainties, and estimate how sensitive the model behavior is to changes in these parameters. It is important to note however, that the GPC cannot replace a proper bifurcation analysis and should currently only be used for parameter ranges where no bifurcations or multi-stabilities occur.</p>
      <p>In summary, PyRates is readily integrated into complex neuroscientific workflows as a tool for bottom-up neural simulations. It provides interfaces to other Python tools that have been specifically designed to manage other parts of such workflows (e.g. data processing or visualization). More interfaces can easily be implemented due to the modular structure of the framework. This is further aided by the widely used data structures PyRates is built upon, like YAML-based configuration files, networkx graphs or pandas DataFrames. PyRates can thus be included as one independent component of larger neuroscientific workflows that can handle the definition, setup, numerical simulation and optimization of neural models.</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material" id="sec019">
    <title>Supporting information</title>
    <supplementary-material content-type="local-data" id="pone.0225900.s001">
      <label>S1 Table</label>
      <caption>
        <title>Overview of mathematical syntax.</title>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pone.0225900.s001.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="pone.0225900.s002">
      <label>S2 Table</label>
      <caption>
        <title>Overview of preimplemented mathematical functions.</title>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pone.0225900.s002.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <p>Richard Gast has been supported by Max Planck Society and Studienstiftung des Deutschen Volkes. Daniel Rose is supported by the International Max Planck Research School NeuroCom.</p>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="pone.0225900.ref001">
      <label>1</label>
      <mixed-citation publication-type="journal"><name><surname>Goense</surname><given-names>J</given-names></name>, <name><surname>Merkle</surname><given-names>H</given-names></name>, <name><surname>Logothetis</surname><given-names>N</given-names></name>. <article-title>High-Resolution fMRI Reveals Laminar Differences in Neurovascular Coupling between Positive and Negative BOLD Responses</article-title>. <source>Neuron</source>. <year>2012</year>;<volume>76</volume>(<issue>3</issue>):<fpage>629</fpage>–<lpage>639</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuron.2012.09.019</pub-id><?supplied-pmid 23141073?><pub-id pub-id-type="pmid">23141073</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref002">
      <label>2</label>
      <mixed-citation publication-type="journal"><name><surname>Huber</surname><given-names>L</given-names></name>, <name><surname>Uludağ</surname><given-names>K</given-names></name>, <name><surname>Möller</surname><given-names>HE</given-names></name>. <article-title>Non-BOLD contrast for laminar fMRI in humans: CBF, CBV, and CMRO2</article-title>. <source>NeuroImage</source>. <year>2017</year><pub-id pub-id-type="doi">10.1016/j.neuroimage.2017.07.041</pub-id><?supplied-pmid 28736310?><pub-id pub-id-type="pmid">28736310</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref003">
      <label>3</label>
      <mixed-citation publication-type="book"><name><surname>Niedermeyer</surname><given-names>E</given-names></name>, <name><surname>Silva</surname><given-names>FHLd</given-names></name>. <source>Electroencephalography: Basic Principles, Clinical Applications, and Related Fields</source>. <publisher-name>Lippincott Williams &amp; Wilkins</publisher-name>; <year>2005</year>.</mixed-citation>
    </ref>
    <ref id="pone.0225900.ref004">
      <label>4</label>
      <mixed-citation publication-type="journal"><name><surname>Baillet</surname><given-names>S</given-names></name>, <name><surname>Mosher</surname><given-names>J C</given-names></name>, <name><surname>Leahy</surname><given-names>R M</given-names></name>. <article-title>Electromagnetic brain mapping</article-title>. <source>IEEE Signal Processing Magazine</source>. <year>2001</year>;<volume>18</volume>(<issue>6</issue>):<fpage>14</fpage>–<lpage>30</lpage>. <pub-id pub-id-type="doi">10.1109/79.962275</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref005">
      <label>5</label>
      <mixed-citation publication-type="journal"><name><surname>Markram</surname><given-names>H</given-names></name>, <name><surname>Toledo-Rodriguez</surname><given-names>M</given-names></name>, <name><surname>Wang</surname><given-names>Y</given-names></name>, <name><surname>Gupta</surname><given-names>A</given-names></name>, <name><surname>Silberberg</surname><given-names>G</given-names></name>, <name><surname>Wu</surname><given-names>C</given-names></name>. <article-title>Interneurons of the neocortical inhibitory system</article-title>. <source>Nature Reviews Neuroscience</source>. <year>2004</year>;<volume>5</volume>:<fpage>793</fpage><pub-id pub-id-type="doi">10.1038/nrn1519</pub-id><?supplied-pmid 15378039?><pub-id pub-id-type="pmid">15378039</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref006">
      <label>6</label>
      <mixed-citation publication-type="journal"><name><surname>Attal</surname><given-names>Y</given-names></name>, <name><surname>Schwartz</surname><given-names>D</given-names></name>. <article-title>Assessment of Subcortical Source Localization Using Deep Brain Activity Imaging Model with Minimum Norm Operators: A MEG Study</article-title>. <source>PLOS ONE</source>. <year>2013</year>;<volume>8</volume>(<issue>3</issue>):<fpage>e59856</fpage><pub-id pub-id-type="doi">10.1371/journal.pone.0059856</pub-id><?supplied-pmid 23527277?><pub-id pub-id-type="pmid">23527277</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref007">
      <label>7</label>
      <mixed-citation publication-type="journal"><name><surname>Logothetis</surname><given-names>NK</given-names></name>, <name><surname>Wandell</surname><given-names>BA</given-names></name>. <article-title>Interpreting the BOLD Signal</article-title>. <source>Annual Review of Physiology</source>. <year>2004</year>;<volume>66</volume>(<issue>1</issue>):<fpage>735</fpage>–<lpage>769</lpage>. <pub-id pub-id-type="doi">10.1146/annurev.physiol.66.082602.092845</pub-id><?supplied-pmid 14977420?><pub-id pub-id-type="pmid">14977420</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref008">
      <label>8</label>
      <mixed-citation publication-type="journal"><name><surname>Deco</surname><given-names>G</given-names></name>, <name><surname>Jirsa</surname><given-names>VK</given-names></name>, <name><surname>Robinson</surname><given-names>PA</given-names></name>, <name><surname>Breakspear</surname><given-names>M</given-names></name>, <name><surname>Friston</surname><given-names>K</given-names></name>. <article-title>The Dynamic Brain: From Spiking Neurons to Neural Masses and Cortical Fields</article-title>. <source>PLOS Computational Biology</source>. <year>2008</year>;<volume>4</volume>(<issue>8</issue>):<fpage>e1000092</fpage><pub-id pub-id-type="doi">10.1371/journal.pcbi.1000092</pub-id><?supplied-pmid 18769680?><pub-id pub-id-type="pmid">18769680</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref009">
      <label>9</label>
      <mixed-citation publication-type="journal"><name><surname>Friston</surname><given-names>KJ</given-names></name>, <name><surname>Dolan</surname><given-names>RJ</given-names></name>. <article-title>Computational and dynamic models in neuroimaging</article-title>. <source>NeuroImage</source>. <year>2010</year>;<volume>52</volume>(<issue>3</issue>):<fpage>752</fpage>–<lpage>765</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2009.12.068</pub-id><?supplied-pmid 20036335?><pub-id pub-id-type="pmid">20036335</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref010">
      <label>10</label>
      <mixed-citation publication-type="journal"><name><surname>Breakspear</surname><given-names>M</given-names></name>. <article-title>Dynamic models of large-scale brain activity</article-title>. <source>Nat Neurosci</source>. <year>2017</year>;<volume>20</volume>(<issue>3</issue>):<fpage>340</fpage>–<lpage>352</lpage>. <pub-id pub-id-type="doi">10.1038/nn.4497</pub-id><?supplied-pmid 28230845?><pub-id pub-id-type="pmid">28230845</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref011">
      <label>11</label>
      <mixed-citation publication-type="journal"><name><surname>Sanz-Leon</surname><given-names>P</given-names></name>, <name><surname>Knock</surname><given-names>SA</given-names></name>, <name><surname>Spiegler</surname><given-names>A</given-names></name>, <name><surname>Jirsa</surname><given-names>VK</given-names></name>. <article-title>Mathematical framework for large-scale brain network modeling in The Virtual Brain</article-title>. <source>NeuroImage</source>. <year>2015</year>;<volume>111</volume>:<fpage>385</fpage>–<lpage>430</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2015.01.002</pub-id><?supplied-pmid 25592995?><pub-id pub-id-type="pmid">25592995</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref012">
      <label>12</label>
      <mixed-citation publication-type="journal"><name><surname>Friston</surname><given-names>KJ</given-names></name>, <name><surname>Harrison</surname><given-names>L</given-names></name>, <name><surname>Penny</surname><given-names>W</given-names></name>. <article-title>Dynamic causal modelling</article-title>. <source>NeuroImage</source>. <year>2003</year>;<volume>19</volume>(<issue>4</issue>):<fpage>1273</fpage>–<lpage>1302</lpage>. <pub-id pub-id-type="doi">10.1016/s1053-8119(03)00202-7</pub-id><?supplied-pmid 12948688?><pub-id pub-id-type="pmid">12948688</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref013">
      <label>13</label>
      <mixed-citation publication-type="journal"><name><surname>Bekolay</surname><given-names>T</given-names></name>, <name><surname>Bergstra</surname><given-names>J</given-names></name>, <name><surname>Hunsberger</surname><given-names>E</given-names></name>, <name><surname>DeWolf</surname><given-names>T</given-names></name>, <name><surname>Stewart</surname><given-names>TC</given-names></name>, <name><surname>Rasmussen</surname><given-names>D</given-names></name>, <etal>et al</etal><article-title>Nengo: a Python tool for building large-scale functional brain models</article-title>. <source>Frontiers in Neuroinformatics</source>. <year>2014</year>;<volume>7</volume><pub-id pub-id-type="doi">10.3389/fninf.2013.00048</pub-id><?supplied-pmid 24431999?><pub-id pub-id-type="pmid">24431999</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref014">
      <label>14</label>
      <mixed-citation publication-type="journal"><name><surname>Gewaltig</surname><given-names>MO</given-names></name>, <name><surname>Diesmann</surname><given-names>M</given-names></name>. <article-title>NEST (NEural Simulation Tool)</article-title>. <source>Scholarpedia</source>. <year>2007</year>;<volume>2</volume>(<issue>4</issue>):<fpage>1430</fpage><pub-id pub-id-type="doi">10.4249/scholarpedia.1430</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref015">
      <label>15</label>
      <mixed-citation publication-type="journal"><name><surname>Vitay</surname><given-names>J</given-names></name>, <name><surname>Dinkelbach</surname><given-names>HU</given-names></name>, <name><surname>Hamker</surname><given-names>FH</given-names></name>. <article-title>ANNarchy: a code generation approach to neural simulations on parallel hardware</article-title>. <source>Frontiers in Neuroinformatics</source>. <year>2015</year>;<volume>9</volume><pub-id pub-id-type="doi">10.3389/fninf.2015.00019</pub-id><?supplied-pmid 26283957?><pub-id pub-id-type="pmid">26283957</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref016">
      <label>16</label>
      <mixed-citation publication-type="journal"><name><surname>Goodman</surname><given-names>DFM</given-names></name>, <name><surname>Brette</surname><given-names>R</given-names></name>. <article-title>The Brian simulator</article-title>. <source>Frontiers in Neuroscience</source>. <year>2009</year>;<volume>3</volume><pub-id pub-id-type="doi">10.3389/neuro.01.026.2009</pub-id><?supplied-pmid 20011141?><pub-id pub-id-type="pmid">20011141</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref017">
      <label>17</label>
      <mixed-citation publication-type="journal"><name><surname>Hines</surname><given-names>ML</given-names></name>, <name><surname>Carnevale</surname><given-names>NT</given-names></name>. <article-title>The NEURON Simulation Environment</article-title>. <source>Neural Computation</source>. <year>1997</year>;<volume>9</volume>(<issue>6</issue>):<fpage>1179</fpage>–<lpage>1209</lpage>. <pub-id pub-id-type="doi">10.1162/neco.1997.9.6.1179</pub-id><?supplied-pmid 9248061?><pub-id pub-id-type="pmid">9248061</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref018">
      <label>18</label>
      <mixed-citation publication-type="journal"><name><surname>Migliore</surname><given-names>M</given-names></name>, <name><surname>Cannia</surname><given-names>C</given-names></name>, <name><surname>Lytton</surname><given-names>WW</given-names></name>, <name><surname>Markram</surname><given-names>H</given-names></name>, <name><surname>Hines</surname><given-names>ML</given-names></name>. <article-title>Parallel network simulations with NEURON</article-title>. <source>Journal of Computational Neuroscience</source>. <year>2006</year>;<volume>21</volume>(<issue>2</issue>):<fpage>119</fpage><pub-id pub-id-type="doi">10.1007/s10827-006-7949-5</pub-id><?supplied-pmid 16732488?><pub-id pub-id-type="pmid">16732488</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref019">
      <label>19</label>
      <mixed-citation publication-type="journal"><name><surname>Pecevski</surname><given-names>D</given-names></name>, <name><surname>Natschläger</surname><given-names>T</given-names></name>, <name><surname>Schuch</surname><given-names>K</given-names></name>. <article-title>PCSIM: a parallel simulation environment for neural circuits fully integrated with Python</article-title>. <source>Frontiers in Neuroinformatics</source>. <year>2009</year>;<volume>3</volume><pub-id pub-id-type="doi">10.3389/neuro.11.011.2009</pub-id><?supplied-pmid 19543450?><pub-id pub-id-type="pmid">19543450</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref020">
      <label>20</label>
      <mixed-citation publication-type="journal"><name><surname>Gratiy</surname><given-names>SL</given-names></name>, <name><surname>Billeh</surname><given-names>YN</given-names></name>, <name><surname>Dai</surname><given-names>K</given-names></name>, <name><surname>Mitelut</surname><given-names>C</given-names></name>, <name><surname>Feng</surname><given-names>D</given-names></name>, <name><surname>Gouwens</surname><given-names>NW</given-names></name>, <etal>et al</etal><article-title>BioNet: A Python interface to NEURON for modeling large-scale networks</article-title>. <source>PLOS ONE</source>. <year>2018</year>;<volume>13</volume>(<issue>8</issue>):<fpage>e0201630</fpage><pub-id pub-id-type="doi">10.1371/journal.pone.0201630</pub-id><?supplied-pmid 30071069?><pub-id pub-id-type="pmid">30071069</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref021">
      <label>21</label>
      <mixed-citation publication-type="journal"><name><surname>Dura-Bernal</surname><given-names>S</given-names></name>, <name><surname>Suter</surname><given-names>BA</given-names></name>, <name><surname>Gleeson</surname><given-names>P</given-names></name>, <name><surname>Cantarelli</surname><given-names>M</given-names></name>, <name><surname>Quintana</surname><given-names>A</given-names></name>, <name><surname>Rodriguez</surname><given-names>F</given-names></name>, <etal>et al</etal><article-title>NetPyNE, a tool for data-driven multiscale modeling of brain circuits</article-title>. <source>eLife</source>. <year>2019</year>;<volume>8</volume>:<fpage>e44494</fpage><pub-id pub-id-type="doi">10.7554/eLife.44494</pub-id><?supplied-pmid 31025934?><pub-id pub-id-type="pmid">31025934</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref022">
      <label>22</label>
      <mixed-citation publication-type="journal"><name><surname>Jensen</surname><given-names>O</given-names></name>, <name><surname>Goel</surname><given-names>P</given-names></name>, <name><surname>Kopell</surname><given-names>N</given-names></name>, <name><surname>Pohja</surname><given-names>M</given-names></name>, <name><surname>Hari</surname><given-names>R</given-names></name>, <name><surname>Ermentrout</surname><given-names>B</given-names></name>. <article-title>On the human sensorimotor-cortex beta rhythm: Sources and modeling</article-title>. <source>NeuroImage</source>. <year>2005</year>;<volume>26</volume>(<issue>2</issue>):<fpage>347</fpage>–<lpage>355</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2005.02.008</pub-id><?supplied-pmid 15907295?><pub-id pub-id-type="pmid">15907295</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref023">
      <label>23</label>
      <mixed-citation publication-type="journal"><name><surname>Sherman</surname><given-names>MA</given-names></name>, <name><surname>Lee</surname><given-names>S</given-names></name>, <name><surname>Law</surname><given-names>R</given-names></name>, <name><surname>Haegens</surname><given-names>S</given-names></name>, <name><surname>Thorn</surname><given-names>CA</given-names></name>, <name><surname>Hämäläinen</surname><given-names>MS</given-names></name>, <etal>et al</etal><article-title>Neural mechanisms of transient neocortical beta rhythms: Converging evidence from humans, computational modeling, monkeys, and mice</article-title>. <source>Proceedings of the National Academy of Sciences of the USA</source>. <year>2016</year>;<volume>113</volume>(<issue>33</issue>):<fpage>E4885</fpage>–<lpage>E4894</lpage>. <pub-id pub-id-type="doi">10.1073/pnas.1604135113</pub-id><?supplied-pmid 27469163?><pub-id pub-id-type="pmid">27469163</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref024">
      <label>24</label>
      <mixed-citation publication-type="other">Neymotin SA, Daniels DS, Caldwell B, Peled N, McDougal RA, Carnevale NT, et al. Human Neocortical Neurosolver; 2018.</mixed-citation>
    </ref>
    <ref id="pone.0225900.ref025">
      <label>25</label>
      <mixed-citation publication-type="journal"><name><surname>Hagen</surname><given-names>E</given-names></name>, <name><surname>Naess</surname><given-names>S</given-names></name>, <name><surname>Ness</surname><given-names>TV</given-names></name>, <name><surname>Einevoll</surname><given-names>GT</given-names></name>. <article-title>Multimodal Modeling of Neural Network Activity: Computing LFP, ECoG, EEG, and MEG Signals With LFPy 2.0</article-title>. <source>Frontiers in Neuroinformatics</source>. <year>2018</year>;<volume>12</volume><pub-id pub-id-type="doi">10.3389/fninf.2018.00092</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref026">
      <label>26</label>
      <mixed-citation publication-type="journal"><name><surname>Coombes</surname><given-names>S</given-names></name>. <article-title>Large-scale neural dynamics: simple and complex</article-title>. <source>NeuroImage</source>. <year>2010</year>;<volume>52</volume>(<issue>3</issue>):<fpage>731</fpage>–<lpage>739</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2010.01.045</pub-id><?supplied-pmid 20096791?><pub-id pub-id-type="pmid">20096791</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref027">
      <label>28</label>
      <mixed-citation publication-type="journal"><name><surname>Freeman</surname><given-names>WJ</given-names></name>. <article-title>Models of the dynamics of neural populations</article-title>. <source>Electroencephalography and clinical neurophysiology</source>. <year>1978</year>;<volume>34</volume>:<fpage>9</fpage>–<lpage>18</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0225900.ref028">
      <label>27</label>
      <mixed-citation publication-type="journal"><name><surname>da Silva</surname><given-names>FHL</given-names></name>, <name><surname>Hoeks</surname><given-names>A</given-names></name>, <name><surname>Smits</surname><given-names>H</given-names></name>, <name><surname>Zetterberg</surname><given-names>LH</given-names></name>. <article-title>Model of brain rhythmic activity</article-title>. <source>Biological cybernetics</source>. <year>1974</year>;<volume>15</volume>(<issue>1</issue>):<fpage>27</fpage>–<lpage>37</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0225900.ref029">
      <label>29</label>
      <mixed-citation publication-type="journal"><name><surname>Jansen</surname><given-names>BH</given-names></name>, <name><surname>Rit</surname><given-names>VG</given-names></name>. <article-title>Electroencephalogram and visual evoked potential generation in a mathematical model of coupled cortical columns</article-title>. <source>Biol Cybern</source>. <year>1995</year>;<volume>73</volume>(<issue>4</issue>):<fpage>357</fpage>–<lpage>366</lpage>. <pub-id pub-id-type="doi">10.1007/bf00199471</pub-id><?supplied-pmid 7578475?><pub-id pub-id-type="pmid">7578475</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref030">
      <label>30</label>
      <mixed-citation publication-type="journal"><name><surname>David</surname><given-names>O</given-names></name>, <name><surname>Friston</surname><given-names>KJ</given-names></name>. <article-title>A neural mass model for MEG/EEG:: coupling and neuronal dynamics</article-title>. <source>NeuroImage</source>. <year>2003</year>;<volume>20</volume>(<issue>3</issue>):<fpage>1743</fpage>–<lpage>1755</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2003.07.015</pub-id><?supplied-pmid 14642484?><pub-id pub-id-type="pmid">14642484</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref031">
      <label>31</label>
      <mixed-citation publication-type="journal"><name><surname>Babajani</surname><given-names>A</given-names></name>, <name><surname>Soltanian-Zadeh</surname><given-names>H</given-names></name>. <article-title>Integrated MEG/EEG and fMRI model based on neural masses</article-title>. <source>IEEE Transactions on Biomedical Engineering</source>. <year>2006</year>;<volume>53</volume>(<issue>9</issue>):<fpage>1794</fpage>–<lpage>1801</lpage>. <pub-id pub-id-type="doi">10.1109/TBME.2006.873748</pub-id><?supplied-pmid 16941835?><pub-id pub-id-type="pmid">16941835</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref032">
      <label>32</label>
      <mixed-citation publication-type="journal"><name><surname>Cona</surname><given-names>F</given-names></name>, <name><surname>Zavaglia</surname><given-names>M</given-names></name>, <name><surname>Massimini</surname><given-names>M</given-names></name>, <name><surname>Rosanova</surname><given-names>M</given-names></name>, <name><surname>Ursino</surname><given-names>M</given-names></name>. <article-title>A neural mass model of interconnected regions simulates rhythm propagation observed via TMS-EEG</article-title>. <source>NeuroImage</source>. <year>2011</year>;<volume>57</volume>(<issue>3</issue>):<fpage>1045</fpage>–<lpage>1058</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2011.05.007</pub-id><?supplied-pmid 21600291?><pub-id pub-id-type="pmid">21600291</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref033">
      <label>33</label>
      <mixed-citation publication-type="journal"><name><surname>Moran</surname><given-names>RJ</given-names></name>, <name><surname>Kiebel</surname><given-names>SJ</given-names></name>, <name><surname>Stephan</surname><given-names>KE</given-names></name>, <name><surname>Reilly</surname><given-names>RB</given-names></name>, <name><surname>Daunizeau</surname><given-names>J</given-names></name>, <name><surname>Friston</surname><given-names>KJ</given-names></name>. <article-title>A neural mass model of spectral responses in electrophysiology</article-title>. <source>NeuroImage</source>. <year>2007</year>;<volume>37</volume>(<issue>3</issue>):<fpage>706</fpage>–<lpage>720</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2007.05.032</pub-id><?supplied-pmid 17632015?><pub-id pub-id-type="pmid">17632015</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref034">
      <label>34</label>
      <mixed-citation publication-type="journal"><name><surname>Wang</surname><given-names>P</given-names></name>, <name><surname>Knösche</surname><given-names>TR</given-names></name>. <article-title>A Realistic Neural Mass Model of the Cortex with Laminar-Specific Connections and Synaptic Plasticity—Evaluation with Auditory Habituation</article-title>. <source>PLOS ONE</source>. <year>2013</year>;<volume>8</volume>(<issue>10</issue>):<fpage>e77876</fpage><pub-id pub-id-type="doi">10.1371/journal.pone.0077876</pub-id><?supplied-pmid 24205009?><pub-id pub-id-type="pmid">24205009</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref035">
      <label>35</label>
      <mixed-citation publication-type="journal"><name><surname>David</surname><given-names>O</given-names></name>, <name><surname>Kiebel</surname><given-names>SJ</given-names></name>, <name><surname>Harrison</surname><given-names>LM</given-names></name>, <name><surname>Mattout</surname><given-names>J</given-names></name>, <name><surname>Kilner</surname><given-names>JM</given-names></name>, <name><surname>Friston</surname><given-names>KJ</given-names></name>. <article-title>Dynamic causal modeling of evoked responses in EEG and MEG</article-title>. <source>NeuroImage</source>. <year>2006</year>;<volume>30</volume>(<issue>4</issue>):<fpage>1255</fpage>–<lpage>1272</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2005.10.045</pub-id><?supplied-pmid 16473023?><pub-id pub-id-type="pmid">16473023</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref036">
      <label>36</label>
      <mixed-citation publication-type="journal"><name><surname>Sotero</surname><given-names>RC</given-names></name>, <name><surname>Trujillo-Barreto</surname><given-names>NJ</given-names></name>, <name><surname>Iturria-Medina</surname><given-names>Y</given-names></name>, <name><surname>Carbonell</surname><given-names>F</given-names></name>, <name><surname>Jimenez</surname><given-names>JC</given-names></name>. <article-title>Realistically Coupled Neural Mass Models Can Generate EEG Rhythms</article-title>. <source>Neural Computation</source>. <year>2007</year>;<volume>19</volume>(<issue>2</issue>):<fpage>478</fpage>–<lpage>512</lpage>. <pub-id pub-id-type="doi">10.1162/neco.2007.19.2.478</pub-id><?supplied-pmid 17206872?><pub-id pub-id-type="pmid">17206872</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref037">
      <label>37</label>
      <mixed-citation publication-type="journal"><name><surname>Bojak</surname><given-names>I</given-names></name>, <name><surname>Oostendorp</surname><given-names>TF</given-names></name>, <name><surname>Reid</surname><given-names>AT</given-names></name>, <name><surname>Kötter</surname><given-names>R</given-names></name>. <article-title>Connecting Mean Field Models of Neural Activity to EEG and fMRI Data</article-title>. <source>Brain Topography</source>. <year>2010</year>;<volume>23</volume>(<issue>2</issue>):<fpage>139</fpage>–<lpage>149</lpage>. <pub-id pub-id-type="doi">10.1007/s10548-010-0140-3</pub-id><?supplied-pmid 20364434?><pub-id pub-id-type="pmid">20364434</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref038">
      <label>38</label>
      <mixed-citation publication-type="journal"><name><surname>Spiegler</surname><given-names>A</given-names></name>, <name><surname>Knösche</surname><given-names>TR</given-names></name>, <name><surname>Schwab</surname><given-names>K</given-names></name>, <name><surname>Haueisen</surname><given-names>J</given-names></name>, <name><surname>Atay</surname><given-names>FM</given-names></name>. <article-title>Modeling Brain Resonance Phenomena Using a Neural Mass Model</article-title>. <source>PLOS Computational Biology</source>. <year>2011</year>;<volume>7</volume>(<issue>12</issue>):<fpage>e1002298</fpage><pub-id pub-id-type="doi">10.1371/journal.pcbi.1002298</pub-id><?supplied-pmid 22215992?><pub-id pub-id-type="pmid">22215992</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref039">
      <label>39</label>
      <mixed-citation publication-type="journal"><name><surname>Onslow</surname><given-names>ACE</given-names></name>, <name><surname>Jones</surname><given-names>MW</given-names></name>, <name><surname>Bogacz</surname><given-names>R</given-names></name>. <article-title>A Canonical Circuit for Generating Phase-Amplitude Coupling</article-title>. <source>PLOS ONE</source>. <year>2014</year>;<volume>9</volume>(<issue>8</issue>):<fpage>e102591</fpage><pub-id pub-id-type="doi">10.1371/journal.pone.0102591</pub-id><?supplied-pmid 25136855?><pub-id pub-id-type="pmid">25136855</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref040">
      <label>40</label>
      <mixed-citation publication-type="journal"><name><surname>Kunze</surname><given-names>T</given-names></name>, <name><surname>Hunold</surname><given-names>A</given-names></name>, <name><surname>Haueisen</surname><given-names>J</given-names></name>, <name><surname>Jirsa</surname><given-names>V</given-names></name>, <name><surname>Spiegler</surname><given-names>A</given-names></name>. <article-title>Transcranial direct current stimulation changes resting state functional connectivity: A large-scale brain network modeling study</article-title>. <source>NeuroImage</source>. <year>2016</year>;<volume>140</volume>:<fpage>174</fpage>–<lpage>187</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2016.02.015</pub-id><?supplied-pmid 26883068?><pub-id pub-id-type="pmid">26883068</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref041">
      <label>41</label>
      <mixed-citation publication-type="journal"><name><surname>Jansen</surname><given-names>BH</given-names></name>, <name><surname>Zouridakis</surname><given-names>G</given-names></name>, <name><surname>Brandt</surname><given-names>ME</given-names></name>. <article-title>A neurophysiologically-based mathematical model of flash visual evoked potentials</article-title>. <source>Biological Cybernetics</source>. <year>1993</year>;<volume>68</volume>(<issue>3</issue>):<fpage>275</fpage>–<lpage>283</lpage>. <pub-id pub-id-type="doi">10.1007/bf00224863</pub-id><?supplied-pmid 8452897?><pub-id pub-id-type="pmid">8452897</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref042">
      <label>42</label>
      <mixed-citation publication-type="journal"><name><surname>Spiegler</surname><given-names>A</given-names></name>, <name><surname>Kiebel</surname><given-names>SJ</given-names></name>, <name><surname>Atay</surname><given-names>FM</given-names></name>, <name><surname>Knösche</surname><given-names>TR</given-names></name>. <article-title>Bifurcation analysis of neural mass models: Impact of extrinsic inputs and dendritic time constants</article-title>. <source>NeuroImage</source>. <year>2010</year>;<volume>52</volume>(<issue>3</issue>):<fpage>1041</fpage>–<lpage>1058</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2009.12.081</pub-id><?supplied-pmid 20045068?><pub-id pub-id-type="pmid">20045068</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref043">
      <label>43</label>
      <mixed-citation publication-type="journal"><name><surname>Montbrió</surname><given-names>E</given-names></name>, <name><surname>Pazó</surname><given-names>D</given-names></name>, <name><surname>Roxin</surname><given-names>A</given-names></name>. <article-title>Macroscopic Description for Networks of Spiking Neurons</article-title>. <source>Physical Review X</source>. <year>2015</year>;<volume>5</volume>(<issue>2</issue>):<fpage>021028</fpage>.</mixed-citation>
    </ref>
    <ref id="pone.0225900.ref044">
      <label>44</label>
      <mixed-citation publication-type="book"><name><surname>Coombes</surname><given-names>S</given-names></name>, <name><surname>Byrne</surname><given-names>A</given-names></name>. <chapter-title>Next Generation Neural Mass Models</chapter-title> In: <name><surname>Corinto</surname><given-names>F</given-names></name>, <name><surname>Torcini</surname><given-names>A</given-names></name>, editors. <source>Nonlinear Dynamics in Computational Neuroscience. PoliTO Springer Series</source>. <publisher-loc>Cham</publisher-loc>: <publisher-name>Springer International Publishing</publisher-name>; <year>2019</year> p. <fpage>1</fpage>–<lpage>16</lpage>. Available from: <pub-id pub-id-type="doi">10.1007/978-3-319-71048-8_1</pub-id>.</mixed-citation>
    </ref>
    <ref id="pone.0225900.ref045">
      <label>45</label>
      <mixed-citation publication-type="other">Oliphant TE. A guide to NumPy. USA: Trelgol Publishing; 2006.</mixed-citation>
    </ref>
    <ref id="pone.0225900.ref046">
      <label>46</label>
      <mixed-citation publication-type="other">Ben-Kiki O, Evans C, döt Net I. YAML Ain’t Markup Language (YAML™) Version 1.2; 2009. Available from: <ext-link ext-link-type="uri" xlink:href="https://yaml.org/spec/1.2/spec.html">https://yaml.org/spec/1.2/spec.html</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0225900.ref047">
      <label>47</label>
      <mixed-citation publication-type="other">Hagberg AA, Schult DA, Swart PJ. Exploring Network Structure, Dynamics, and Function using NetworkX. In: Varoquaux G, Vaught T, Millman J, editors. Proceedings of the 7th Python in Science Conference. Pasadena, CA USA; 2008. p. 11–15.</mixed-citation>
    </ref>
    <ref id="pone.0225900.ref048">
      <label>48</label>
      <mixed-citation publication-type="other">Abadi M, Agarwal A, Barham P, Brevdo E, Chen Z, Citro C, et al. TensorFlow: Large-Scale Machine Learning on Heterogeneous Systems; 2015. Available from: <ext-link ext-link-type="uri" xlink:href="http://tensorflow.org/">http://tensorflow.org/</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0225900.ref049">
      <label>49</label>
      <mixed-citation publication-type="other">McKinney W. Data Structures for Statistical Computing in Python. In: van der Walt S, Millman J, editors. Proceedings of the 9th Python in Science Conference; 2010. p. 51–56.</mixed-citation>
    </ref>
    <ref id="pone.0225900.ref050">
      <label>50</label>
      <mixed-citation publication-type="journal"><name><surname>Gansner</surname><given-names>ER</given-names></name>, <name><surname>North</surname><given-names>SC</given-names></name>. <article-title>An open graph visualization system and its applications to software engineering</article-title>. <source>Software—Practice and Experience</source>. <year>2000</year>;<volume>30</volume>(<issue>11</issue>):<fpage>1203</fpage>–<lpage>1233</lpage>. <pub-id pub-id-type="doi">10.1002/1097-024X(200009)30:11&lt;1203::AID-SPE338&gt;3.0.CO;2-N</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref051">
      <label>51</label>
      <mixed-citation publication-type="journal"><name><surname>Gramfort</surname><given-names>A</given-names></name>, <name><surname>Luessi</surname><given-names>M</given-names></name>, <name><surname>Larson</surname><given-names>E</given-names></name>, <name><surname>Engemann</surname><given-names>DA</given-names></name>, <name><surname>Strohmeier</surname><given-names>D</given-names></name>, <name><surname>Brodbeck</surname><given-names>C</given-names></name>, <etal>et al</etal><article-title>MEG and EEG data analysis with MNE-Python</article-title>. <source>Front Neurosci</source>. <year>2013</year>;<volume>7</volume><pub-id pub-id-type="doi">10.3389/fnins.2013.00267</pub-id><?supplied-pmid 24431986?><pub-id pub-id-type="pmid">24431986</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref052">
      <label>52</label>
      <mixed-citation publication-type="journal"><name><surname>Gramfort</surname><given-names>A</given-names></name>, <name><surname>Luessi</surname><given-names>M</given-names></name>, <name><surname>Larson</surname><given-names>E</given-names></name>, <name><surname>Engemann</surname><given-names>DA</given-names></name>, <name><surname>Strohmeier</surname><given-names>D</given-names></name>, <name><surname>Brodbeck</surname><given-names>C</given-names></name>, <etal>et al</etal><article-title>MNE software for processing MEG and EEG data</article-title>. <source>NeuroImage</source>. <year>2014</year>;<volume>86</volume>:<fpage>446</fpage>–<lpage>460</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2013.10.027</pub-id><?supplied-pmid 24161808?><pub-id pub-id-type="pmid">24161808</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref053">
      <label>53</label>
      <mixed-citation publication-type="journal"><name><surname>Ratas</surname><given-names>I</given-names></name>, <name><surname>Pyragas</surname><given-names>K</given-names></name>. <article-title>Macroscopic self-oscillations and aging transition in a network of synaptically coupled quadratic integrate-and-fire neurons</article-title>. <source>Physical Review E</source>. <year>2016</year>;<volume>94</volume>(<issue>3</issue>):<fpage>032215</fpage><pub-id pub-id-type="doi">10.1103/PhysRevE.94.032215</pub-id><?supplied-pmid 27739712?><pub-id pub-id-type="pmid">27739712</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref054">
      <label>54</label>
      <mixed-citation publication-type="journal"><name><surname>Ritter</surname><given-names>P</given-names></name>, <name><surname>Schirner</surname><given-names>M</given-names></name>, <name><surname>McIntosh</surname><given-names>AR</given-names></name>, <name><surname>Jirsa</surname><given-names>VK</given-names></name>. <article-title>The Virtual Brain Integrates Computational Modeling and Multimodal Neuroimaging</article-title>. <source>Brain Connectivity</source>. <year>2013</year>;<volume>3</volume>(<issue>2</issue>):<fpage>121</fpage>–<lpage>145</lpage>. <pub-id pub-id-type="doi">10.1089/brain.2012.0120</pub-id><?supplied-pmid 23442172?><pub-id pub-id-type="pmid">23442172</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref055">
      <label>55</label>
      <mixed-citation publication-type="other">Website: © Allen Institute for Brain Science. DiPDE Simulator [Internet]. Available from: <ext-link ext-link-type="uri" xlink:href="https://github.com/AllenInstitute/dipde">https://github.com/AllenInstitute/dipde</ext-link>.; 2015.</mixed-citation>
    </ref>
    <ref id="pone.0225900.ref056">
      <label>56</label>
      <mixed-citation publication-type="other">Kamps Md, Baier V. Multiple Interacting Instantiations of Neuronal Dynamics (MIIND): a Library for Rapid Prototyping of Models in Cognitive Neuroscience. In: 2007 International Joint Conference on Neural Networks; 2007. p. 2829–2834.</mixed-citation>
    </ref>
    <ref id="pone.0225900.ref057">
      <label>57</label>
      <mixed-citation publication-type="journal"><name><surname>Bäck</surname><given-names>T</given-names></name>, <name><surname>Schwefel</surname><given-names>HP</given-names></name>. <article-title>An Overview of Evolutionary Algorithms for Parameter Optimization</article-title>. <source>Evolutionary Computation</source>. <year>1993</year>;<volume>1</volume>(<issue>1</issue>):<fpage>1</fpage>–<lpage>23</lpage>. <pub-id pub-id-type="doi">10.1162/evco.1993.1.1.1</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref058">
      <label>58</label>
      <mixed-citation publication-type="journal"><name><surname>Shannon</surname><given-names>P</given-names></name>, <name><surname>Markiel</surname><given-names>A</given-names></name>, <name><surname>Ozier</surname><given-names>O</given-names></name>, <name><surname>Baliga</surname><given-names>NS</given-names></name>, <name><surname>Wang</surname><given-names>JT</given-names></name>, <name><surname>Ramage</surname><given-names>D</given-names></name>, <etal>et al</etal><article-title>Cytoscape: a software environment for integrated models of biomolecular interaction networks</article-title>. <source>Genome Res</source>. <year>2003</year>;<volume>13</volume>(<issue>11</issue>):<fpage>2498</fpage>–<lpage>2504</lpage>. <pub-id pub-id-type="doi">10.1101/gr.1239303</pub-id><?supplied-pmid 14597658?><pub-id pub-id-type="pmid">14597658</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0225900.ref059">
      <label>59</label>
      <mixed-citation publication-type="other">Waskom M. seaborn: statistical data visualization, URL: <ext-link ext-link-type="uri" xlink:href="https://seaborn.pydata.org/">https://seaborn.pydata.org/</ext-link>; 2012.</mixed-citation>
    </ref>
  </ref-list>
</back>
