<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8371904</article-id>
    <article-id pub-id-type="publisher-id">4318</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-021-04318-x</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>NOREC4DNA: using near-optimal rateless erasure codes for DNA storage</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0001-8763-1507</contrib-id>
        <name>
          <surname>Schwarz</surname>
          <given-names>Peter Michael</given-names>
        </name>
        <address>
          <email>schwarzk@uni-marburg.de</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Freisleben</surname>
          <given-names>Bernd</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <aff id="Aff1"><institution-wrap><institution-id institution-id-type="GRID">grid.10253.35</institution-id><institution-id institution-id-type="ISNI">0000 0004 1936 9756</institution-id><institution>Department of Mathematics and Computer Science, </institution><institution>Philipps-Universität Marburg, </institution></institution-wrap>35032 Marburg, Germany </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>17</day>
      <month>8</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>17</day>
      <month>8</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2021</year>
    </pub-date>
    <volume>22</volume>
    <elocation-id>406</elocation-id>
    <history>
      <date date-type="received">
        <day>14</day>
        <month>4</month>
        <year>2021</year>
      </date>
      <date date-type="accepted">
        <day>5</day>
        <month>8</month>
        <year>2021</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2021</copyright-statement>
      <license>
        <ali:license_ref specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p><bold>Open Access</bold>This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons licence, and indicate if changes were made. The images or other third party material in this article are included in the article's Creative Commons licence, unless indicated otherwise in a credit line to the material. If material is not included in the article's Creative Commons licence and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this licence, visit <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated in a credit line to the data.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p id="Par1">DNA is a promising storage medium for high-density long-term digital data storage. Since DNA synthesis and sequencing are still relatively expensive tasks, the coding methods used to store digital data in DNA should correct errors and avoid unstable or error-prone DNA sequences. Near-optimal rateless erasure codes, also called fountain codes, are particularly interesting codes to realize high-capacity and low-error DNA storage systems, as shown by Erlich and Zielinski in their approach based on the Luby transform (LT) code. Since LT is the most basic fountain code, there is a large untapped potential for improvement in using near-optimal erasure codes for DNA storage.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p id="Par2">We present <italic>NOREC4DNA</italic>, a software framework to use, test, compare, and improve near-optimal rateless erasure codes (NORECs) for DNA storage systems. These codes can effectively be used to store digital information in DNA and cope with the restrictions of the DNA medium. Additionally, they can adapt to possible variable lengths of DNA strands and have nearly zero overhead. We describe the design and implementation of <italic>NOREC4DNA</italic>. Furthermore, we present experimental results demonstrating that <italic>NOREC4DNA</italic> can flexibly be used to evaluate the use of NORECs in DNA storage systems. In particular, we show that NORECs that apparently have not yet been used for DNA storage, such as Raptor and Online codes, can achieve significant improvements over LT codes that were used in previous work. <italic>NOREC4DNA</italic> is available on <ext-link ext-link-type="uri" xlink:href="https://github.com/umr-ds/NOREC4DNA">https://github.com/umr-ds/NOREC4DNA</ext-link>.</p>
      </sec>
      <sec>
        <title>Conclusion</title>
        <p id="Par3"><italic>NOREC4DNA</italic> is a flexible and extensible software framework for using, evaluating, and comparing NORECs for DNA storage systems.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>DNA storage</kwd>
      <kwd>Erasure code</kwd>
      <kwd>Near-optimal rateless erasure code</kwd>
      <kwd>Raptor code</kwd>
      <kwd>Online code</kwd>
      <kwd>LT code</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution>HMWK LOEWE MOSLA Research Cluster (DE)</institution>
        </funding-source>
      </award-group>
    </funding-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution>Philipps-Universität Marburg (1009)</institution>
        </funding-source>
      </award-group>
      <open-access>
        <p>Open Access funding enabled and organized by Projekt DEAL.</p>
      </open-access>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2021</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p id="Par12">Due to its very high storage density of theoretically 455 exabytes per gram (using 2 bits per nucleotide) [<xref ref-type="bibr" rid="CR1">1</xref>] and its extraordinary longevity, deoxyribonucleic acid (DNA) is a promising medium for long-term and high-density storage of important data. However, since DNA as a biological medium is susceptible to a variety of mutations and read/write errors, and the cost for synthesizing and sequencing DNA is still a decisive factor, it is essential to use adequate coding schemes to correct errors and avoid unstable or error-prone DNA sequences when digital data is stored in DNA.</p>
    <p id="Par13">Several coding schemes were proposed to correct read/write errors and avoid error-prone DNA sequences. For example, Church et al. [<xref ref-type="bibr" rid="CR1">1</xref>] as well as Goldman et al. [<xref ref-type="bibr" rid="CR2">2</xref>] used different overlapping strategies to map digital data into DNA strands and support error correction. In these coding schemes, the bits 0 and 1 are mapped to two DNA bases each and thus error-prone combinations like long repeats of one base (called homopolymers) are avoided. Heckel et al. [<xref ref-type="bibr" rid="CR3">3</xref>] proposed an index-based coding scheme, mapping data annotated with the corresponding index, without further modification of these data packets. Furthermore, near-optimal rateless erasure code (NOREC), also called <italic>fountain codes</italic>, are particularly interesting coding methods for DNA storage. For example, Erlich and Zielinski used the Luby transform (LT) code to achieve high-capacity and low-error DNA storage [<xref ref-type="bibr" rid="CR4">4</xref>]. In their work, they leveraged the special property of fountain codes to be able to generate theoretically infinitely many different packets for a given input to find packets that satisfy the restrictions defined for their DNA storage approach. Since LT is the most basic NOREC, there is a large untapped potential for improvement in using NORECs for DNA storage.</p>
    <p id="Par14">Ping et al. [<xref ref-type="bibr" rid="CR5">5</xref>] developed Chamaeleo, a framework that provides multiple DNA storage codes. While Ping et al. focus on a variety of conventional (non-fountain) codes presented in the literature, they also include the LT implementation used by Erlich and Zielinski. In contrast to our work, Chamaeleo does not include means to change, adapt, and integrate modified or new error rules. Furthermore, the missing framework-wide error simulation does not permit an extensive comparison of the usability of the implemented methods for real DNA storage.</p>
    <p id="Par15">In this paper, we present <italic>NOREC4DNA</italic>, a software framework to use, test, compare, and improve coding schemes for DNA storage. While <italic>NOREC4DNA</italic> focuses on fountain codes, regular coding schemes can be compared as well. Besides multiple extensible restriction rules, we implemented the three most common fountain codes, namely LT [<xref ref-type="bibr" rid="CR6">6</xref>], Online [<xref ref-type="bibr" rid="CR7">7</xref>], and Raptor [<xref ref-type="bibr" rid="CR8">8</xref>]. The contributions of this paper are as follows:<list list-type="bullet"><list-item><p id="Par16">We present a novel framework based on NORECs, called <italic>NOREC4DNA</italic>, to flexibly generate sequences for DNA storage that satisfy user-defined restrictions.</p></list-item><list-item><p id="Par17"><italic>NOREC4DNA</italic> allows detailed comparisons of various coding schemes for storing data in DNA.</p></list-item><list-item><p id="Par18">We show that NORECs belong to the most suitable codes for DNA storage; Raptor codes yield the best results across all tested metrics.</p></list-item></list>The paper is organized as follows. “<xref rid="Sec2" ref-type="sec">Near-optimal rateless erasure codes</xref>” section gives an overview of the fountain codes and technologies used in <italic>NOREC4DNA</italic>. “<xref rid="Sec7" ref-type="sec">Implementation</xref>” section presents the design and implementation of <italic>NOREC4DNA</italic>. We present experimental results generated using <italic>NOREC4DNA</italic> in “<xref rid="Sec21" ref-type="sec">Results</xref>” section. Finally, “<xref rid="Sec27" ref-type="sec">Conclusion</xref>” section concludes the paper and outlines areas of future work.</p>
    <sec id="Sec2">
      <title>Near-optimal rateless erasure codes</title>
      <p id="Par19">NORECs can be used to generate theoretically infinitely many coding symbols (in practice, some limitations apply). Furthermore, only a small number of <inline-formula id="IEq1"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$(1+\epsilon ) * n$$\end{document}</tex-math><mml:math id="M2"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>ϵ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow/><mml:mo>∗</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq1.gif"/></alternatives></inline-formula> encoded symbols have to be correctly received to fully reconstruct the original information. Since it does not matter which (and in which order) symbols are received as long as a sufficient number of symbols is received - just like a bucket under a fountain that does not care about which drops of water it collects—these codes are also known as <italic>fountain codes</italic>.</p>
      <p id="Par20">Typically, fountain codes are applied as follows. First, a distribution function is used to determine a degree for each data packet. These packets are filled with random chunks using XOR according to their degree and then transmitted to the recipient over an erasure channel. After receiving a sufficient subset of the transmitted packets, the receiver computes the original data using the received packets and an indication of the chunks contained in them. To reconstruct the encoded data, the receiver either has to know the list of chunks mixed into a given packet (e.g., as part of the transmission) or has to know the distribution function as well as the seed used to initialize the random number generator used during encoding.</p>
      <sec id="Sec3">
        <title>Luby transform codes</title>
        <p id="Par21">The LT code [<xref ref-type="bibr" rid="CR6">6</xref>] proposed by Luby is considered to be the most fundamental and pioneering fountain code. LT divides the original file into <italic>n</italic> equally long ‘chunks’ that are then combined into packets using the XOR operator, as shown in Fig. <xref rid="Fig1" ref-type="fig">1</xref>.<fig id="Fig1"><label>Fig. 1</label><caption><p>Encoding using LT</p></caption><graphic xlink:href="12859_2021_4318_Fig1_HTML" id="MO1"/></fig></p>
        <p id="Par22">The encoding process can be summarized as follows:<list list-type="bullet"><list-item><p id="Par23">Choose the degree <italic>d</italic> from the probability distribution function <italic>p</italic>(.).</p></list-item><list-item><p id="Par24">Select <italic>d</italic> evenly random distributed different chunks.</p></list-item><list-item><p id="Par25">Generate the resulting packet <inline-formula id="IEq2"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$t_i$$\end{document}</tex-math><mml:math id="M4"><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq2.gif"/></alternatives></inline-formula> by combining all selected chunks using the XOR operator.</p></list-item><list-item><p id="Par26">Add reconstruction information (selected chunk number or seed) to the packet.</p></list-item></list>Luby presents two distribution functions for his LT coding schemes [<xref ref-type="bibr" rid="CR6">6</xref>]. The first distribution function, called ‘IdealSoliton’ distribution, was proven by Luby to be mathematically ideal. It operates on integers from 1 to <italic>N</italic>, with <italic>N</italic> as the only parameter of the function. It is defined as follows:<disp-formula id="Equ1"><label>1</label><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\begin{aligned} \begin{aligned} \displaystyle \rho (1)&amp;={\frac{1}{N}},\\ \displaystyle \rho (k)&amp;=\frac{1}{k(k-1)}\qquad (k=2,3, \ldots ,N).\, \end{aligned} \end{aligned}$$\end{document}</tex-math><mml:math id="M6" display="block"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow/><mml:mi>ρ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mi>k</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mspace width="2em"/><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>.</mml:mo><mml:mspace width="0.166667em"/></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="12859_2021_4318_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula>As shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref>a, this function has a single mode and then flattens down to the specified value <italic>N</italic>. Since only the parameter <italic>N</italic> can be selected, the position of the mode <inline-formula id="IEq3"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\rho (2) = 0.5$$\end{document}</tex-math><mml:math id="M8"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq3.gif"/></alternatives></inline-formula> as well as its value cannot be changed.<fig id="Fig2"><label>Fig. 2</label><caption><p>Soliton distributions</p></caption><graphic xlink:href="12859_2021_4318_Fig2_HTML" id="MO3"/></fig></p>
        <p id="Par27">According to Luby, this function is quite fragile and thus not suitable for practical applications. Therefore, he proposed a robust form of this distribution function, called ‘RobustSoliton’ distribution, which uses a set of elements <inline-formula id="IEq4"><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\tau (i)$$\end{document}</tex-math><mml:math id="M10"><mml:mrow><mml:mi>τ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq4.gif"/></alternatives></inline-formula> to extend the IdealSoliton distribution (see Eq. (<xref rid="Equ2" ref-type="">2</xref>)), adding a spike to the mode at degree 1. In addition to the parameter <italic>N</italic> already defined in the IdealSoliton distribution, two additional parameters <italic>K</italic> and <inline-formula id="IEq5"><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\delta$$\end{document}</tex-math><mml:math id="M12"><mml:mi>δ</mml:mi></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq5.gif"/></alternatives></inline-formula> are introduced. While <italic>K</italic> with <inline-formula id="IEq6"><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$K &lt; N$$\end{document}</tex-math><mml:math id="M14"><mml:mrow><mml:mi>K</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq6.gif"/></alternatives></inline-formula> defines the integer position of the additional peak, <inline-formula id="IEq7"><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\delta$$\end{document}</tex-math><mml:math id="M16"><mml:mi>δ</mml:mi></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq7.gif"/></alternatives></inline-formula> describes the expected (real-valued) error probability.<disp-formula id="Equ2"><label>2</label><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\begin{aligned} \begin{aligned} \displaystyle \tau (i)&amp;={\frac{1}{iK}},\qquad \qquad (i=1,2, \ldots ,K-1),\,\\ \displaystyle \tau (i)&amp;={\frac{\ln (R/\delta )}{K}},\qquad (i=K),\,\\ \displaystyle \tau (i)&amp;=0,\qquad \qquad \quad (i=K+1, \ldots ,N).\,\\ \displaystyle \text {with }&amp;R = N/K\,\\ \end{aligned} \end{aligned}$$\end{document}</tex-math><mml:math id="M18" display="block"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mi>τ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mi mathvariant="italic">iK</mml:mi></mml:mrow></mml:mfrac><mml:mo>,</mml:mo><mml:mspace width="2em"/><mml:mspace width="2em"/><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>K</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mspace width="0.166667em"/></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow/><mml:mi>τ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>ln</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>δ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>K</mml:mi></mml:mfrac><mml:mo>,</mml:mo><mml:mspace width="2em"/><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>K</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mspace width="0.166667em"/></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow/><mml:mi>τ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mspace width="2em"/><mml:mspace width="2em"/><mml:mspace width="1em"/><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo><mml:mspace width="0.166667em"/></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow/><mml:mtext>with</mml:mtext><mml:mspace width="0.333333em"/></mml:mrow></mml:mstyle></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>K</mml:mi><mml:mspace width="0.166667em"/></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mrow/></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="12859_2021_4318_Article_Equ2.gif" position="anchor"/></alternatives></disp-formula>Finally, as shown in Eq. (<xref rid="Equ3" ref-type="">3</xref>), the values for <inline-formula id="IEq8"><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\tau (i)$$\end{document}</tex-math><mml:math id="M20"><mml:mrow><mml:mi>τ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq8.gif"/></alternatives></inline-formula> are added to <inline-formula id="IEq9"><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\rho (i)$$\end{document}</tex-math><mml:math id="M22"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq9.gif"/></alternatives></inline-formula> and normalized afterwards.<disp-formula id="Equ3"><label>3</label><alternatives><tex-math id="M23">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\begin{aligned} \begin{aligned} \mu (i) = \dfrac{\rho (i)+\tau (i)}{\sum _{j=1}^{N}(\rho (j)+\tau (j))} \end{aligned} \end{aligned}$$\end{document}</tex-math><mml:math id="M24" display="block"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>μ</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mfrac><mml:mrow><mml:mi>ρ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>τ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ρ</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>τ</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="12859_2021_4318_Article_Equ3.gif" position="anchor"/></alternatives></disp-formula>Figure <xref rid="Fig2" ref-type="fig">2</xref>b shows the influence of the individual parameters on the two distribution functions. While the choice of <italic>N</italic> determines the maximum degree, the parameter <italic>K</italic> determines the position of the additional peak. With increasing <inline-formula id="IEq10"><alternatives><tex-math id="M25">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\delta$$\end{document}</tex-math><mml:math id="M26"><mml:mi>δ</mml:mi></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq10.gif"/></alternatives></inline-formula>, the probabilities shift towards degree 2. Therefore, from the second peak and from all other degrees <inline-formula id="IEq11"><alternatives><tex-math id="M27">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$i &gt; 2$$\end{document}</tex-math><mml:math id="M28"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq11.gif"/></alternatives></inline-formula>, small values of probability decrease to the mode at degree 2.</p>
        <p id="Par28">The decoding of the packets generated during the encoding can take place without prior sorting. For decoding, packets are first collected and combined (as far as possible) in such a way that the degree of these packets is reduced in each case. An illustration of decoding a file with three chunks is shown in Fig. <xref rid="Fig3" ref-type="fig">3</xref>. As shown in Fig. <xref rid="Fig4" ref-type="fig">4</xref>, the decoder can still reconstruct the information if packet 2 gets lost.<fig id="Fig3"><label>Fig. 3</label><caption><p>Decoding a file divided into three chunks</p></caption><graphic xlink:href="12859_2021_4318_Fig3_HTML" id="MO6"/></fig><fig id="Fig4"><label>Fig. 4</label><caption><p>Decoding with packet loss</p></caption><graphic xlink:href="12859_2021_4318_Fig4_HTML" id="MO7"/></fig></p>
        <p id="Par29">Thanks to the special construction of fountain codes based on the XOR operator, it is possible to represent the decoding of all NOREC methods in the form of a linear equation
system <inline-formula id="IEq12"><alternatives><tex-math id="M29">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$Ax = b$$\end{document}</tex-math><mml:math id="M30"><mml:mrow><mml:mi>A</mml:mi><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq12.gif"/></alternatives></inline-formula>, as shown in Fig. <xref rid="Fig5" ref-type="fig">5</xref>. This ensures that ambiguities during the decoding process, as shown in the previous example, can be avoided and thus the packets can be optimally reduced to the original message.<fig id="Fig5"><label>Fig. 5</label><caption><p>Decoding matrix after <italic>m</italic> received packets</p></caption><graphic xlink:href="12859_2021_4318_Fig5_HTML" id="MO8"/></fig></p>
        <p id="Par30">In <italic>A</italic>, all 1’s of a line <italic>i</italic> describe which chunks in the packet <italic>i</italic> were combined by the XOR operation. An example is shown in Eq. (<xref rid="Equ4" ref-type="">4</xref>).<disp-formula id="Equ4"><label>4</label><alternatives><tex-math id="M31">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\begin{aligned} \begin{aligned} A[i]&amp;= \begin{pmatrix} 0&amp;1&amp;0&amp;0&amp;1&amp;1 \end{pmatrix}&amp;\Leftrightarrow \\ b[i]&amp;= {{{\veebar }}}_{j = 0}^{|A[i]|} A[i,j] \cdot Chunk[j] = Chunk[1] \veebar Chunk[4] \veebar Chunk[5] \end{aligned} \end{aligned}$$\end{document}</tex-math><mml:math id="M32" display="block"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:mrow></mml:mtd><mml:mtd columnalign="right"><mml:mo stretchy="false">⇔</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mrow/><mml:mi>b</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:msubsup><mml:mo>⊻</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:msubsup><mml:mi>A</mml:mi><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>·</mml:mo><mml:mi>C</mml:mi><mml:mi>h</mml:mi><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>k</mml:mi><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:mi>h</mml:mi><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>k</mml:mi><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>⊻</mml:mo><mml:mi>C</mml:mi><mml:mi>h</mml:mi><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>k</mml:mi><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>⊻</mml:mo><mml:mi>C</mml:mi><mml:mi>h</mml:mi><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>k</mml:mi><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>5</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="12859_2021_4318_Article_Equ4.gif" position="anchor"/></alternatives></disp-formula></p>
      </sec>
      <sec id="Sec4">
        <title>Online codes</title>
        <p id="Par31"><italic>Online Codes</italic> proposed by Maymounkov [<xref ref-type="bibr" rid="CR7">7</xref>] improve LT codes. Online codes address the main problem with LT codes, which is that LT codes cannot guarantee that after <inline-formula id="IEq13"><alternatives><tex-math id="M33">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$(1+\epsilon )*n$$\end{document}</tex-math><mml:math id="M34"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>ϵ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow/><mml:mo>∗</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq13.gif"/></alternatives></inline-formula> generated packets, all <italic>n</italic> parts of the original message were encoded in a sufficient manner. This problem is a manifestation of the coupon collector’s problem [<xref ref-type="bibr" rid="CR9">9</xref>]. If a chunk of the original message has been encoded less frequently (e.g., only once or even zero times), these parts are much more vulnerable during decoding, since a loss of the packets containing these chunks cannot be compensated. Since fountain codes pseudo-randomly combine several chunks to packets, it can also happen that the lack of a single packet prevents numerous chunks from being reconstructed. To prevent this problem from occurring, Online codes follow a two-staged approach. First, auxiliary blocks are created in the so-called outer-encoding. Then, together with the message chunks, they are finally encoded into packets during the inner-encoding step. In particular, during the outer-encoding process, <inline-formula id="IEq14"><alternatives><tex-math id="M35">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$M = \lceil 0.55 \cdot q \cdot \epsilon \cdot F\rceil$$\end{document}</tex-math><mml:math id="M36"><mml:mrow><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:mo>⌈</mml:mo><mml:mn>0.55</mml:mn><mml:mo>·</mml:mo><mml:mi>q</mml:mi><mml:mo>·</mml:mo><mml:mi>ϵ</mml:mi><mml:mo>·</mml:mo><mml:mi>F</mml:mi><mml:mo>⌉</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq14.gif"/></alternatives></inline-formula> auxiliary packets are created. Then, each chunk is randomly mixed into <italic>q</italic> different AUX packets using XOR [<xref ref-type="bibr" rid="CR7">7</xref>]. Like the chunks of the file, the resulting <italic>M</italic> AUX packets are considered as regular inputs in the inner-encoding step. In this phase, a packet is generated by randomly selecting a degree <italic>n</italic> from the distribution function. As a result, selected from the union of the set of chunks and AUX blocks, <italic>n</italic> unique and equally distributed elements are mixed into this packet. This step is repeated infinitely or until a predefined condition occurs. Such a condition could be, e.g., reaching a certain number of created packets or successfully decoding with a decoder running simultaneously.</p>
        <p id="Par32">The process of decoding encoded content in Online codes is similar to the one described for LT codes. However, the decoding phases must be carried out in the reverse order of the encoding process.<fig id="Fig6"><label>Fig. 6</label><caption><p>Online decoding of a file divided into three chunks with 5 generated packets and <inline-formula id="IEq15"><alternatives><tex-math id="M37">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$q=1$$\end{document}</tex-math><mml:math id="M38"><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq15.gif"/></alternatives></inline-formula></p></caption><graphic xlink:href="12859_2021_4318_Fig6_HTML" id="MO10"/></fig></p>
        <p id="Par33">If the mapping of the chunks originally used per AUX packet are already available at the beginning of the decoding (e.g., after the first packet), the decoder can reduce the AUX packets and perform a mapping with the correct chunks during the actual transmission. A reduction of the example shown in Fig. <xref rid="Fig6" ref-type="fig">6</xref> is illustrated in Fig. <xref rid="Fig7" ref-type="fig">7</xref>.<fig id="Fig7"><label>Fig. 7</label><caption><p>Reduction of the AUX packets</p></caption><graphic xlink:href="12859_2021_4318_Fig7_HTML" id="MO11"/></fig></p>
      </sec>
      <sec id="Sec5">
        <title>Raptor codes</title>
        <p id="Par34"><italic>Raptor</italic> codes developed by Shokrollahi [<xref ref-type="bibr" rid="CR8">8</xref>] are the first fountain codes with (theoretically) linear encoding and decoding time. As the name Raptor codes (for rapid tornado) suggests, they are based on tornado codes, which can correct erasures with a fixed error rate. These codes require a constant number of blocks more than the Reed–Solomon codes [<xref ref-type="bibr" rid="CR10">10</xref>], but are much faster in encoding and decoding. Meanwhile, there are several variants of the original method, e.g., R10 [<xref ref-type="bibr" rid="CR11">11</xref>] or the RaptorQ code [<xref ref-type="bibr" rid="CR12">12</xref>]. Depending on the procedure, purpose and area of use, various patents may apply [<xref ref-type="bibr" rid="CR13">13</xref>, <xref ref-type="bibr" rid="CR14">14</xref>].</p>
        <p id="Par35">Similar to the previously mentioned Online codes, the Raptor encoding is based on a two-step process consisting of an outer- and an inner-encoding. While the inner-encoding (just like the inner-decoding) consists of an LT code, the outer-encoding of the Raptor code consists of one or a series of erasure codes with a fixed rate. A possible procedure of this outer-encoding phase is the encoding using a Gray sequence followed by an low density parity check (LDPC) code. Alternatively, a Hamming code or any other erasure code with a fixed rate can be used or combined. This approach combines the advantages of fixed rate coding with codes of the NOREC class.</p>
        <p id="Par36">In contrast to the fountain codes described so far, the Raptor encoding has a (theoretical) fixed upper limit of the number of possible chunks. This upper limit also limits the maximum degree of a packet. For this reason, Raptor codes use a fixed (parameter free) distribution function shown in Eq. (<xref rid="Equ5" ref-type="">5</xref>). This function uses a random number of the given range <inline-formula id="IEq16"><alternatives><tex-math id="M39">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$[1, 2^{20} = 1048576]$$\end{document}</tex-math><mml:math id="M40"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mn>20</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mn>1048576</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq16.gif"/></alternatives></inline-formula> to determine the degree of each packet.<disp-formula id="Equ5"><label>5</label><alternatives><tex-math id="M41">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\begin{aligned} \begin{aligned} f(x)= {\left\{ \begin{array}{ll} 1 &amp;{} \text {for } x&lt; 10241\\ 2 &amp;{} \text {for } x&lt; 491582\\ 3 &amp;{} \text {for } x&lt; 712794\\ 4 &amp;{} \text {for } x&lt; 831695\\ 10 &amp;{} \text {for } x&lt; 948446\\ 11 &amp;{} \text {for } x &lt; 1032189\\ 40 &amp;{} \text {else} \end{array}\right. } \end{aligned} \end{aligned}$$\end{document}</tex-math><mml:math id="M42" display="block"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfenced open="{"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:mn>1</mml:mn></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>for</mml:mtext><mml:mspace width="0.333333em"/><mml:mi>x</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>10241</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mn>2</mml:mn></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>for</mml:mtext><mml:mspace width="0.333333em"/><mml:mi>x</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>491582</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mn>3</mml:mn></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>for</mml:mtext><mml:mspace width="0.333333em"/><mml:mi>x</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>712794</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mn>4</mml:mn></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>for</mml:mtext><mml:mspace width="0.333333em"/><mml:mi>x</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>831695</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mn>10</mml:mn></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>for</mml:mtext><mml:mspace width="0.333333em"/><mml:mi>x</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>948446</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mn>11</mml:mn></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>for</mml:mtext><mml:mspace width="0.333333em"/><mml:mi>x</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>1032189</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mn>40</mml:mn></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>else</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="12859_2021_4318_Article_Equ5.gif" position="anchor"/></alternatives></disp-formula>Data is encoded in two steps. First, the original data is used to create additional information for reconstruction using codes with a fixed rate. Second, the information generated is encoded into many packets using the LT coding technique. Although in practice various erasure codes exist for the first step, the Gray code combined with a subsequent LDPC code is mainly encountered. This can be explained by the simplicity of the Gray code and the properties of LDPC. With this combination (and especially since LDPC codes operate at the Shannon capacity), it is possible to successfully reconstruct a message with a very small overhead of packets (for 1000 chunks, approximately 1-2 additional packets are created using the non systematic approach) with a nearly 100% chance. The number of intermediate blocks to be generated in the first step of the Raptor code is calculated by the formulas shown in Eq. (<xref rid="Equ6" ref-type="">6</xref>) and depends on the number of chunks.<disp-formula id="Equ6"><label>6</label><alternatives><tex-math id="M43">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\begin{aligned} \begin{aligned} f(k) =&amp;x \in {\mathbb {N}} \text { with } x \cdot (x-1) \ge 2 \cdot k \text { and }\\&amp;\exists ! j&lt; x \text { with } j \cdot (j-1) \ge 2k\\ g(k) =&amp;x \in {\mathbb {N}} \text { with } x \text { is prime and }\\&amp;x \ge \lceil 0.01 \cdot k + f(k) \rceil \text { and }\\&amp;\exists ! j \text { with } j \text { is prime and }\\&amp;j&lt; x \text { and } j \ge \lceil 0.01 \cdot k + f(k) \rceil \\ h(k) =&amp;x \in {\mathbb {N}} \text { with } \left( {\begin{array}{c}x\\ \lceil \frac{x}{2}\rceil \end{array}}\right) \ge f(k) + g(k) \text { and }\\&amp;\exists ! j \text { with } j &lt; x \text { and } \left( {\begin{array}{c}j\\ \lceil \frac{j}{2}\rceil \end{array}}\right) \ge f(k) + g(k)\\ \end{aligned} \end{aligned}$$\end{document}</tex-math><mml:math id="M44" display="block"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">N</mml:mi><mml:mspace width="0.333333em"/><mml:mtext>with</mml:mtext><mml:mspace width="0.333333em"/><mml:mi>x</mml:mi><mml:mo>·</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo><mml:mn>2</mml:mn><mml:mo>·</mml:mo><mml:mi>k</mml:mi><mml:mspace width="0.333333em"/><mml:mtext>and</mml:mtext><mml:mspace width="0.333333em"/></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>∃</mml:mo><mml:mo>!</mml:mo><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>x</mml:mi><mml:mspace width="0.333333em"/><mml:mtext>with</mml:mtext><mml:mspace width="0.333333em"/><mml:mi>j</mml:mi><mml:mo>·</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mrow/><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">N</mml:mi><mml:mspace width="0.333333em"/><mml:mtext>with</mml:mtext><mml:mspace width="0.333333em"/><mml:mi>x</mml:mi><mml:mspace width="0.333333em"/><mml:mtext>is prime and</mml:mtext><mml:mspace width="0.333333em"/></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mi>x</mml:mi><mml:mo>≥</mml:mo><mml:mo>⌈</mml:mo><mml:mn>0.01</mml:mn><mml:mo>·</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⌉</mml:mo><mml:mspace width="0.333333em"/><mml:mtext>and</mml:mtext><mml:mspace width="0.333333em"/></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>∃</mml:mo><mml:mo>!</mml:mo><mml:mi>j</mml:mi><mml:mspace width="0.333333em"/><mml:mtext>with</mml:mtext><mml:mspace width="0.333333em"/><mml:mi>j</mml:mi><mml:mspace width="0.333333em"/><mml:mtext>is prime and</mml:mtext><mml:mspace width="0.333333em"/></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>x</mml:mi><mml:mspace width="0.333333em"/><mml:mtext>and</mml:mtext><mml:mspace width="0.333333em"/><mml:mi>j</mml:mi><mml:mo>≥</mml:mo><mml:mo>⌈</mml:mo><mml:mn>0.01</mml:mn><mml:mo>·</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⌉</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mrow/><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">N</mml:mi><mml:mspace width="0.333333em"/><mml:mtext>with</mml:mtext><mml:mspace width="0.333333em"/><mml:mfenced close=")" open="("><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mi>x</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mrow/><mml:mo>⌈</mml:mo><mml:mfrac><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:mfrac><mml:mo>⌉</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>≥</mml:mo><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>g</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mspace width="0.333333em"/><mml:mtext>and</mml:mtext><mml:mspace width="0.333333em"/></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>∃</mml:mo><mml:mo>!</mml:mo><mml:mi>j</mml:mi><mml:mspace width="0.333333em"/><mml:mtext>with</mml:mtext><mml:mspace width="0.333333em"/><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>x</mml:mi><mml:mspace width="0.333333em"/><mml:mtext>and</mml:mtext><mml:mspace width="0.333333em"/><mml:mfenced close=")" open="("><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mi>j</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mrow/><mml:mo>⌈</mml:mo><mml:mfrac><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:mfrac><mml:mo>⌉</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>≥</mml:mo><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>g</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mrow/></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="12859_2021_4318_Article_Equ6.gif" position="anchor"/></alternatives></disp-formula>While <italic>f</italic>(<italic>k</italic>) is only an auxiliary function for <italic>g</italic>(<italic>k</italic>), the function <italic>g</italic>(<italic>k</italic>) calculates the number of intermediate blocks to be created using the Gray code. The function <italic>h</italic>(<italic>k</italic>) computes the number of intermediate blocks to be generated by LDPC. The sum <inline-formula id="IEq17"><alternatives><tex-math id="M45">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$l = k+g(k)+h(k)$$\end{document}</tex-math><mml:math id="M46"><mml:mrow><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq17.gif"/></alternatives></inline-formula> indicates the total quantity of intermediate blocks after the first step. These <inline-formula id="IEq18"><alternatives><tex-math id="M47">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$k+g(k)$$\end{document}</tex-math><mml:math id="M48"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq18.gif"/></alternatives></inline-formula> blocks are then used as inputs to generate the <italic>h</italic>(<italic>k</italic>) LDPC encoded blocks. This ensures that all chunks and previously generated blocks in intermediate steps are captured during LDPC encoding. If the first phase of the implemented Raptor encoding consists of more than two fixed-rate codes, the number of intermediate blocks to be generated must be determined for each of these codes and then, according to the desired order, the chunks together with the preceding intermediate blocks serve as input for the following code.</p>
        <p id="Par37">The <inline-formula id="IEq19"><alternatives><tex-math id="M49">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$h(k)+g(k)$$\end{document}</tex-math><mml:math id="M50"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq19.gif"/></alternatives></inline-formula> intermediate blocks generated in the first step are then encoded into packets using the LT code. The standard procedure is to select the degree of the packets with the predefined distribution function. In contrast to the fountain codes used so far, the final choice of chunks for a packet to use is not distributed equally, but depends on a particular algorithm. Thus, the function may vary depending on the version of the Raptor code.</p>
        <p id="Par38">Figure <xref rid="Fig8" ref-type="fig">8</xref> shows the result of a run of this rateless encoding. The first packet consists of <inline-formula id="IEq20"><alternatives><tex-math id="M51">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$d=4, a=5, b=1$$\end{document}</tex-math><mml:math id="M52"><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq20.gif"/></alternatives></inline-formula> of the first chunk (<inline-formula id="IEq21"><alternatives><tex-math id="M53">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$b = 1$$\end{document}</tex-math><mml:math id="M54"><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq21.gif"/></alternatives></inline-formula>), the fifth chunk (<inline-formula id="IEq22"><alternatives><tex-math id="M55">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$b = 1 + a\% 11 = 5$$\end{document}</tex-math><mml:math id="M56"><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>a</mml:mi><mml:mo>%</mml:mo><mml:mn>11</mml:mn><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq22.gif"/></alternatives></inline-formula>), the fourth chunk (<inline-formula id="IEq23"><alternatives><tex-math id="M57">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$b = ((1 + a)\% 11 + a\% 11) + a\% 11 = 4$$\end{document}</tex-math><mml:math id="M58"><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>%</mml:mo><mml:mn>11</mml:mn><mml:mo>+</mml:mo><mml:mi>a</mml:mi><mml:mo>%</mml:mo><mml:mn>11</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>a</mml:mi><mml:mo>%</mml:mo><mml:mn>11</mml:mn><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq23.gif"/></alternatives></inline-formula>) and the second chunk (<inline-formula id="IEq24"><alternatives><tex-math id="M59">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$b = (((((1 + a)\% 11 + a\% 11) + a\% 11) + a\% 11) + a\% 11) + a\% 11 = 2$$\end{document}</tex-math><mml:math id="M60"><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>%</mml:mo><mml:mn>11</mml:mn><mml:mo>+</mml:mo><mml:mi>a</mml:mi><mml:mo>%</mml:mo><mml:mn>11</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>a</mml:mi><mml:mo>%</mml:mo><mml:mn>11</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>a</mml:mi><mml:mo>%</mml:mo><mml:mn>11</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>a</mml:mi><mml:mo>%</mml:mo><mml:mn>11</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>a</mml:mi><mml:mo>%</mml:mo><mml:mn>11</mml:mn><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq24.gif"/></alternatives></inline-formula>).<fig id="Fig8"><label>Fig. 8</label><caption><p>Generation of a Raptor packet with d = 4, a = 5, and b = 1</p></caption><graphic xlink:href="12859_2021_4318_Fig8_HTML" id="MO14"/></fig></p>
        <p id="Par39">This procedure limits the size of allowed input chunks (and thus also the final size of the individual packets) to <inline-formula id="IEq25"><alternatives><tex-math id="M61">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$2^{20} - x$$\end{document}</tex-math><mml:math id="M62"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mn>20</mml:mn></mml:msup><mml:mo>-</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq25.gif"/></alternatives></inline-formula>, where <italic>x</italic> is the number of intermediate blocks to be generated in the first step. To avoid this limitation, in RFC 5053 [<xref ref-type="bibr" rid="CR11">11</xref>] the authors of the Raptor encoding suggest generating ‘sub-blocks’ in addition to chunks (referred to as ‘source blocks’). These are evaluated in the algorithm as a separate run. To enable decoding, only the current chunk number and the number of sub-chunks used must be known. This allows us to encode each chunk separately, offering a selection of almost any number of subdivisions.</p>
        <p id="Par40">The reconstruction of the packets encoded by Raptor codes is quite similar to the Online decoding. The mapping of each intermediate block must be generated exactly in the same way as during encoding. The decoder has to know the number of chunks, the fixed rate codes, and their order. While the number and sequence of most implementation steps is standardized and can therefore be treated as given, a sender must transmit the number of original chunks (or sub-blocks). If the corresponding information is known, the decoding of the Raptor code can also be reduced to a linear equation system and solved using either the Gaussian elimination method [<xref ref-type="bibr" rid="CR15">15</xref>, <xref ref-type="bibr" rid="CR16">16</xref>] or belief propagation [<xref ref-type="bibr" rid="CR17">17</xref>, <xref ref-type="bibr" rid="CR18">18</xref>].</p>
      </sec>
      <sec id="Sec6">
        <title>Common errors in DNA storage systems</title>
        <p id="Par41">To leverage the rateless property of the described codes, <italic>NOREC4DNA</italic> includes a variety of rules defining error probabilities of DNA sequences.</p>
        <p id="Par42"><italic>Mutations</italic> Depending on the synthesis or storage method, the individual DNA strands are subject to different mutations and mutation probabilities depending on their characteristics. Although all four bases are susceptible to simple mutations, there are differences in the effect, recoverability, and frequency of these mutations. One of the most common mutations is the formation of uracil from cytosine, which, like thymine, would complement adenine and thus would produce a different sequence if sequenced later. A similar defect exists in the oxidation of guanine and the associated formation of 8-oxoguanine. This can bind to both cytosine and adenine and can therefore possibly lead to an error. In addition to a one-by-one mutation, insertions and deletions might lead to further modifications of a DNA sequence.</p>
        <p id="Par43"><italic>Homopolymers</italic> Polymers that contain longer repetitions of the same base are referred to as homopolymers. These fragments are highly unstable during synthesis, polymerase chain reaction (PCR), and subsequent sequencing. On the one hand, due to how next-generation sequencing systems detect the presence of a nucleotide, homopolymers are difficult to correctly sequence [<xref ref-type="bibr" rid="CR19">19</xref>]. On the other hand, a so-called ‘slippage’ of the enzyme in the region of the homopolymer might occur during PCR (and thus during synthesis and sequencing). Longer homopolymers greatly increase the probability of such an error and thus should be avoided.</p>
        <p id="Par44"><italic>GC Content</italic> The GC content of a DNA strand as shown in Eq. (<xref rid="Equ7" ref-type="">7</xref>) indicates the proportion (i.e., frequency) of the bases guanine and cytosine with respect to the length of the full strand:<disp-formula id="Equ7"><label>7</label><alternatives><tex-math id="M63">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\begin{aligned} \begin{aligned} \text {GC Content} = \dfrac{|G|+|C|}{|G|+|C|+|A|+|T|} \cdot 100\% \text {, }&amp;\text {where |}\star \text {| is the frequency of} \\&amp;\text {base} \star \text {in a given sequence.} \end{aligned} \end{aligned}$$\end{document}</tex-math><mml:math id="M64" display="block"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtext>GC Content</mml:mtext><mml:mo>=</mml:mo><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mfrac><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mfrac></mml:mstyle><mml:mo>·</mml:mo><mml:mn>100</mml:mn><mml:mo>%</mml:mo><mml:mtext>,</mml:mtext><mml:mspace width="0.333333em"/></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>where |</mml:mtext><mml:mo>⋆</mml:mo><mml:mtext>| is the frequency of</mml:mtext></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>base</mml:mtext><mml:mo>⋆</mml:mo><mml:mtext>in a given sequence.</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="12859_2021_4318_Article_Equ7.gif" position="anchor"/></alternatives></disp-formula>Since the base pairs A and T always form two hydrogen bonds, whereas the pairs G and C always form three hydrogen bonds, and GC pairs tend to be thermodynamically more stable due to a stack interaction, statistically more frequent errors such as abortions and mutations occur in sequences with low GC content [<xref ref-type="bibr" rid="CR20">20</xref>, <xref ref-type="bibr" rid="CR21">21</xref>]. This effect can be observed in nature, where thermophilic organisms have a significantly higher GC content than comparable species. In nature, depending on the organism, the GC content varies between approximately 20% and almost 80%. To design a stable, synthesizable and sequenceable DNA storage, a balanced GC content of 40–60% is advantageous. This applies to both the overall sequence and the GC content per window.</p>
        <p id="Par45"><italic>Micro-satellites</italic> Also known as ‘short tandem repeats’, two to six base pairs long sequences that are frequently repeated in a DNA sequence are called micro-satellites. Although micro-satellites occur approximately one million times in human DNA, they are still considered unstable due to problems during the sequencing and reproduction process. The most common forms of these error sources are di- and trinucleotide repeats.</p>
        <p id="Par46">Belonging to the class of micro-satellites, dinucleotide repeats consist of a long repetition of two base pairs. The reason for a mutation is the high chance of ‘slippage’ during a PCR process. This causes the newly synthesized strand to form a loop, which is not cut out during the repair attempt but leads to an extension of the strand. Since these locations are not recognized by proof-reading (as correction), they often lead to unrecoverable errors. The more frequently a sequence repeats itself, the higher the probability that during PCR a formation of loops occurs, which then changes the DNA.</p>
        <p id="Par47">Similar to the dinucleotide repeats, this type of error is also based on a repetition of nucleotide sequences. However, as the name implies, repetitions of three nucleotides are considered.</p>
      </sec>
    </sec>
  </sec>
  <sec id="Sec7">
    <title>Implementation</title>
    <p id="Par48"><italic>NOREC4DNA</italic> is written in Python 3 using multiprocessing and a fast C implementation of the most important functions. Additionally, some methods are implemented as CUDA kernels and thus can optionally be executed on GPUs. <italic>NOREC4DNA</italic> is based on an object-oriented approach, i.e., it flexibly supports extensions regarding new methods, coding schemes, metrics, and mutation rules.</p>
    <sec id="Sec8">
      <title>Workflow</title>
      <p id="Par49">The steps to store information in DNA are as follows. First, a number of packets is generated from a chosen (binary) erasure code. A binary-quaternary converter generates a quaternary representation using the bases A, C, G, and T for each packet. The resulting DNA sequences are then synthesized and stored using any suitable method. At a later point in time, these DNA strands are sequenced, translated using the quaternary-binary converter and passed to the decoder as individual packets. The decoder then reconstructs the original file using <inline-formula id="IEq26"><alternatives><tex-math id="M65">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$(1+\epsilon )*n$$\end{document}</tex-math><mml:math id="M66"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>ϵ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow/><mml:mo>∗</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq26.gif"/></alternatives></inline-formula> packets. Figure <xref rid="Fig9" ref-type="fig">9</xref> shows the described workflow. It should be noted that the number of DNA strands and thus the number of binary packets received may be smaller than the originally encoded number of DNA strands. We describe the components of the workflow in more detail below.<fig id="Fig9"><label>Fig. 9</label><caption><p>Workflow for storing/retrieving data in/from DNA</p></caption><graphic xlink:href="12859_2021_4318_Fig9_HTML" id="MO16"/></fig></p>
    </sec>
    <sec id="Sec9">
      <title>Encoder</title>
      <p id="Par50">The encoder divides files into a freely selectable number of chunks (or packets with a selected chunk size) and allows to create an unlimited number of packets. It is possible to either create individual packets or generate a fixed number of packets at once. Furthermore, we added an interface to the decoder implementations. This way, it is possible to generate packets until the selected decoder signals that decoding is possible. The use of a static overhead in combination with a decoder is also possible.</p>
      <p id="Par51">To store additional information about a given file, the encoder allows an optional header chunk to be added during encoding. This artificial chunk can store information such as the file name and the correct length of the padded last chunk.</p>
      <p id="Par52">As an additional feature, a direct enumeration of the contained chunks can be stored per packet. This allows the encoder to operate in an unequal error protection mode [<xref ref-type="bibr" rid="CR22">22</xref>, <xref ref-type="bibr" rid="CR23">23</xref>]. Since the determination of prioritized packets makes a simple reconstruction of the encoded chunks using a seed impossible, an explicit enumeration of the chunk numbers used per packet is required here. This allows a user to specify a list of chunks to decode with high priority while initializing the encoder. These packets can either be encoded into individual packets with degree 1 or have a higher chance to be mixed into packets with a smaller degree (e.g., <inline-formula id="IEq27"><alternatives><tex-math id="M67">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\le 4$$\end{document}</tex-math><mml:math id="M68"><mml:mrow><mml:mo>≤</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq27.gif"/></alternatives></inline-formula>).</p>
      <p id="Par53">Besides directly using the encoder, <italic>NOREC4DNA</italic> includes multiple scripts to create packets based on full parallel execution. This includes the generation of all possible packets by iterating over all possible seeds in a given seed range. This supports finding the best overall packets for a given input.</p>
      <p id="Par54">Currently, <italic>NOREC4DNA</italic> provides implementations of the following NORECs: LT, Online, and Raptor. The implemented distribution functions are: RobustSoliton, IdealSoliton, as well as the default implementations for Online and Raptor together with a custom ‘adaptable distribution’ that allows a programmatic modification of the distribution function.</p>
    </sec>
    <sec id="Sec10">
      <title>Packet structure</title>
      <p id="Par55">Since the mentioned prioritized packets require an explicit specification of the chunks used, but the LT implementation without prioritization achieves a higher efficiency by specifying the seed, different storage structures are defined for both versions.<table-wrap id="Tab1"><label>Table 1</label><caption><p>Structure of the different LT packets</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" colspan="5">(a) <italic>Without explicit specification of chunks</italic></th></tr><tr><th align="left">#Chunks</th><th align="left" colspan="2">Id (Seed)</th><th align="left">Data</th><th align="left">Checksum</th></tr></thead><tbody><tr><td align="left">I (4 byte)</td><td align="left" colspan="2">I</td><td align="left">...</td><td align="left">L (4 byte)</td></tr></tbody></table><table frame="hsides" rules="groups"><thead><tr><th align="left" colspan="5">(b) <italic>With explicit specification of the chunks</italic></th></tr><tr><th align="left">#Chunks</th><th align="left">Degree</th><th align="left">Used chunks</th><th align="left">Data</th><th align="left">Checksum</th></tr></thead><tbody><tr><td align="left">I (4 byte)</td><td align="left">I</td><td align="left">|Packets| <inline-formula id="IEq28"><alternatives><tex-math id="M69">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\cdot$$\end{document}</tex-math><mml:math id="M70"><mml:mo>·</mml:mo></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq28.gif"/></alternatives></inline-formula> H (2 byte)</td><td align="left">...</td><td align="left">L (4 byte)</td></tr></tbody></table></table-wrap></p>
      <p id="Par56">While the packet structure shown in Table <xref rid="Tab1" ref-type="table">1</xref> may be used as a default setting, the length of each field can be modified. This can be useful if the total number of chunks or the maximum seed fits into a smaller number of bytes (or needs more space). Additionally, static information, such as the total number of chunks the file has been split into, can be omitted during packet creation. While the latter greatly decreases the total and per-packet overhead, this information has to be transmitted out-of-band for a successful decoding. If this information gets lost, the decoding has to test all possible combinations (e.g., all possible number of splits).</p>
      <p id="Par57">The explicit specification of the degree is necessary if the distribution function used and its parameters are not known during decoding. Alternatively, information about the distribution and its configuration could be stored instead.</p>
      <p id="Par58">The function used to generate data for the ‘checksum’ field in Table <xref rid="Tab1" ref-type="table">1</xref> can be replaced by a (lambda) function. <italic>NOREC4DNA</italic> includes the following pre-defined codes: ‘nocode’, ‘crc8’, ‘crc32’ as well as ‘Reed–Solomon’ with a freely configurable repair symbol size.</p>
      <p id="Par59">While ‘nocode’ works as an identity function and supplies no integrity check for a packet and therefore decreases the overhead, ‘crc8’ and ‘crc32’ introduce overhead, but also provide corresponding integrity checks. Although using a simple checksum might be sufficient to emulate an erasure channel over the DNA medium and thus ensures that only intact packets are decoded, this approach would increase the number of invalid packets even if a single base mutates. Erlich and Zielinski [<xref ref-type="bibr" rid="CR4">4</xref>] have shown that using a Reed–Solomon code to check integrity and repair errors increases the number of correct packets even if small mutations occur. Since the error probability in a DNA storage system depends on various factors, the number of repair symbols can be chosen freely.</p>
    </sec>
    <sec id="Sec11">
      <title>Bin-quat converter</title>
      <p id="Par60">There are several approaches for encoding binary data using four bases. One variant is the simple conversion and direct storage of the binary data in a quaternary form, i.e., a mapping system as shown in Table <xref rid="Tab2" ref-type="table">2</xref>. The concrete assignment of the bit pairs to the individual bases can be chosen freely.<table-wrap id="Tab2"><label>Table 2</label><caption><p>Mapping of two bits into quaternary form or DNA base</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Bitpair</th><th align="left">Quaternary representation</th><th align="left">Base</th></tr></thead><tbody><tr><td align="left">00</td><td align="left">0</td><td align="left">A</td></tr><tr><td align="left">01</td><td align="left">1</td><td align="left">C</td></tr><tr><td align="left">10</td><td align="left">2</td><td align="left">G</td></tr><tr><td align="left">11</td><td align="left">3</td><td align="left">T</td></tr></tbody></table></table-wrap><table-wrap id="Tab3"><label>Table 3</label><caption><p>Mapping: One bit can be encoded into two different DNA bases</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Bit</th><th align="left">Base</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">A or C</td></tr><tr><td align="left">1</td><td align="left">G or T</td></tr></tbody></table></table-wrap></p>
      <p id="Par61">In addition to these obvious approaches, other concepts were studied in the literature. For example, Church et al. [<xref ref-type="bibr" rid="CR1">1</xref>] stored one bit per base pair, similar to the mapping shown in Table <xref rid="Tab3" ref-type="table">3</xref>. Although this yields a lower information density, it achieves more robustness with regard to mutations and read errors as well as homopolymers. Other methods, such as the approach presented by Limbachiya et al. [<xref ref-type="bibr" rid="CR24">24</xref>], use only two or three of the four possible bases per block in order to avoid error-prone sequences.</p>
      <p id="Par62">While these mappings can be easily integrated into our framework, <italic>NOREC4DNA</italic> uses the direct mapping approach shown in Table <xref rid="Tab2" ref-type="table">2</xref>. This is due to the ideal information density and the fact that the described fountain codes are used to prevent error-prone sequences. This transformation has been widely used in related work (e.g., [<xref ref-type="bibr" rid="CR4">4</xref>, <xref ref-type="bibr" rid="CR25">25</xref>, <xref ref-type="bibr" rid="CR26">26</xref>]).</p>
    </sec>
    <sec id="Sec12">
      <title>Biological rules</title>
      <p id="Par63">To leverage the benefits of NORECs, we introduce a metric ‘error probability’ per packet. This metric represents the probability that a given packet is readable after a full cycle of storing to and reading from DNA. For a flexible and still accurate assessment of these error probabilities, we implemented multiple rule sets. As a reference rule set, the rules as defined by Erlich and Zielinski [<xref ref-type="bibr" rid="CR4">4</xref>] were implemented. While these rules only focus on homopolymers and the GC content, the remaining implementations add various other rules that can be configured and enabled as required. For example, we offer a fast and reliable C-extension of the most important rules to accelerate the encoding, and a parser-based approach to allow users to easily modify rules without deeper knowledge of Python programming.</p>
      <p id="Par64">Due to the reduction of errors to deletions in the erasure channel, a simulation of mutations over one or more generations (as in [<xref ref-type="bibr" rid="CR27">27</xref>]) is not necessary. Therefore, it is sufficient to multiply the probability of a mutation of a packet with the number of generations to obtain the probability whether it should be discarded or not.</p>
      <p id="Par65">The following errors were considered and implemented as possible reasons for mutation: homopolymers, unique X-mers, di- and trinucleotide runs, length based errors, A, C, G and T mutation probabilities, (windowed) GC content, illegal symbols, random mutations as well as options for the reverse and reverse complement. Care has been taken to ensure that the errors of synthesis, storage, and sequencing are considered. The used rules for homopolymers, di- and trinucleotides were adapted from the literature [<xref ref-type="bibr" rid="CR28">28</xref>, <xref ref-type="bibr" rid="CR29">29</xref>]. The mutation and error probabilities for the individual bases (e.g., base ‘C’ becomes ‘T’) are mainly chosen based on the work of Grass et al. [<xref ref-type="bibr" rid="CR29">29</xref>]. Statements about the general random occurrence of errors were compiled from several publications [<xref ref-type="bibr" rid="CR30">30</xref>, <xref ref-type="bibr" rid="CR31">31</xref>].</p>
      <p id="Par66">Equation (<xref rid="Equ8" ref-type="">8</xref>) shows one of the default functions for GC rules. While this distribution for mutation probabilities was roughly adopted from related work [<xref ref-type="bibr" rid="CR21">21</xref>, <xref ref-type="bibr" rid="CR28">28</xref>, <xref ref-type="bibr" rid="CR30">30</xref>], these distributions can be replaced during construction of the rule system. This equation returns 0 for all values between 40 and 60 and 1 for all values between 0 and 30 as well as 70 and 100. For the values between 30 and 40 and 60 to 70 this will return a near linear value between 0 and 1.<disp-formula id="Equ8"><label>8</label><alternatives><tex-math id="M71">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\begin{aligned} \begin{aligned} \displaystyle f&amp;= \frac{1}{100} \left( - \frac{x^4}{7200} + \frac{x^3}{36} - \frac{121 x^2}{72} + \frac{175 x}{6} + 100\right) ,\\ \displaystyle err_{gc}&amp;= max(\min (f, 1), 0)\\ \end{aligned} \end{aligned}$$\end{document}</tex-math><mml:math id="M72" display="block"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mi>f</mml:mi></mml:mstyle></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>100</mml:mn></mml:mfrac><mml:mfenced close=")" open="("><mml:mo>-</mml:mo><mml:mfrac><mml:msup><mml:mi>x</mml:mi><mml:mn>4</mml:mn></mml:msup><mml:mn>7200</mml:mn></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:msup><mml:mi>x</mml:mi><mml:mn>3</mml:mn></mml:msup><mml:mn>36</mml:mn></mml:mfrac><mml:mo>-</mml:mo><mml:mfrac><mml:mrow><mml:mn>121</mml:mn><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mn>72</mml:mn></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mn>175</mml:mn><mml:mi>x</mml:mi></mml:mrow><mml:mn>6</mml:mn></mml:mfrac><mml:mo>+</mml:mo><mml:mn>100</mml:mn></mml:mfenced><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mrow/><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi mathvariant="italic">gc</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo movablelimits="true">min</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mrow/></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="12859_2021_4318_Article_Equ8.gif" position="anchor"/></alternatives></disp-formula></p>
      <sec id="Sec13">
        <title>MESA implementation</title>
        <p id="Par67">The highest customizability is obtained by using the MESA [<xref ref-type="bibr" rid="CR32">32</xref>] API. Since MESA as a web tool for the automated assessment of synthetic DNA fragments and simulation of DNA synthesis, storage, sequencing, and PCR errors does not only allow user-defined configurations but also offers a REST-API, MESA allows a fine-grained and correct assessment of error probabilities per packet. The downside of this approach is the decreased speed introduced through the API.</p>
      </sec>
      <sec id="Sec14">
        <title>Error prediction accuracy</title>
        <p id="Par68">Since the mutation probabilities of the individual error sources in different scientific studies vary considerably, the implemented default rules have been overestimated in such a way that they create a close upper bound for the actual probability of mutation with the same distribution.</p>
        <p id="Par69">The complexity of finding a universal and accurate error prediction is further increased by the fact that there are various synthesis, amplification, and sequencing methods, all of which are susceptible to different errors and therefore have different mutation and error probabilities. Furthermore, the error probability depends on the duration and the conditions of the information that is stored in DNA. Implemented in this way, long-term storage can be simulated by increasing the probability of errors.</p>
        <p id="Par70">The application of all rules in the default rule set to randomly generated DNA sequences results in an average error probability of about 23% for sequences of length 50 nt (std: 33%, var: 11%, 25-percentile: 0%, 75-percentile: 21%) and about 50% for 164 nt (std: 44%, var: 19%, 25%-percentile: 21%, 75%-percentile: 80%), whereas various articles suggest an error probability of 1-15% (depending on the synthesis, storage, sequencing methods used and most of all, the length of the sequence). However, since we adopted the ratio or distribution of mutations from published data, this overestimation can be adjusted by scaling the error probabilities as required. Additionally, packet-level error correction ensures that small mutations will be repaired and thus will not affect the decoding.</p>
      </sec>
      <sec id="Sec15">
        <title>Error avoidance during coding</title>
        <p id="Par71">To allow a fast and reliable assessment of the created packets, this metric can be calculated during encoding. All encoders allow the creation of packets based of a strict or weak upper bound. While a strict upper bound simply limits the maximum calculated error probability a generated packet might have, the weak upper bound allows even higher error rates. The weak upper bound might be useful if the given rules are too strict, resulting in all packets to be close to or above the set limit. In detail, this function calculates the error probability and then (equally distributed) draws a number between 0 and 1. If the drawn number is equal or higher than the estimated error probability, the packet is considered valid and will be used, otherwise the packet is discarded. While this approach might yield less optimal packets, this mode will work even when all created packets have high error probability.</p>
      </sec>
    </sec>
    <sec id="Sec16">
      <title>Preprocessing sequenced data</title>
      <p id="Par72">Prior clustering performed in a DNA sequencing pipeline improves the results, since it helps to detect low coverage strands and thus sequences with a higher chance of misreads or mutations. Since <italic>NOREC4DNA</italic> reads FASTA files line by line, sorting the clustered sequences by how often the sequences have been sequenced will allow NOREC4DNA to work more reliably. While most modern sequencing pipelines perform these steps accordingly, we use the Snakemake-based pipeline ‘Natrix’ [<xref ref-type="bibr" rid="CR33">33</xref>].</p>
    </sec>
    <sec id="Sec17">
      <title>Decoder</title>
      <p id="Par73">Two base classes are provided as implementations of the decoder interface. Apart from the previously mentioned reduction to a Gaussian-solvable linear equation system, we implemented a belief propagation decoder.</p>
      <sec id="Sec18">
        <title>Gaussian decoder</title>
        <p id="Par74">We implemented a version of Gauss elimination with partial pivoting to achieve a system that is as uniform, fast, and flexible as possible. Since all implemented NORECs work in GF(2)-space and therefore only use the XOR operation, we adjusted and thus accelerated Gaussian elimination. To further increase the decoding speed, we implemented the algorithm in C using Python C-extensions. All developed decoders allow choosing whether decoding should take place after each incoming packet or only after the reception of the last packet using a separate command.</p>
      </sec>
      <sec id="Sec19">
        <title>Belief propagation decoder</title>
        <p id="Par75">While not particularly needed for a non time-crucial task like the decoding of a file stored in DNA, <italic>NOREC4DNA</italic> includes a belief propagation decoder which might further reduce the decoding time. The algorithm propagates each incoming packet to the already processed packets to both reduce the degree of the new packet and all existing ones. This approach can then transitively propagate changes of reduced packets. The advantage over the Gaussian variant is that the speed of decoding is improved by the temporal distribution of the computations and the possible partial parallelization of this approach.</p>
      </sec>
      <sec id="Sec20">
        <title>Pseudo decoder</title>
        <p id="Par76">To speed up the use of decoders during encoding, we developed an additional constructor for each decoder, which, taking into account some premises, significantly accelerates this decoding. The idea is to work only on the set of chunks used per packet and ignore the payload of the packets. This is possible because during encoding it is only necessary to determine whether a valid reduction to the identity matrix exists.</p>
        <p id="Par77">For the Gaussian decoder this means that the right side <italic>b</italic> of the equation <inline-formula id="IEq29"><alternatives><tex-math id="M73">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$Ax = b$$\end{document}</tex-math><mml:math id="M74"><mml:mrow><mml:mi>A</mml:mi><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq29.gif"/></alternatives></inline-formula> does not have to be solved. It is sufficient to check whether the matrix <italic>A</italic> can be converted into the identity matrix (or the first <italic>n</italic> lines of a <inline-formula id="IEq30"><alternatives><tex-math id="M75">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$m \times n$$\end{document}</tex-math><mml:math id="M76"><mml:mrow><mml:mi>m</mml:mi><mml:mo>×</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq30.gif"/></alternatives></inline-formula> matrix). The belief propagation decoder can reduce the individual packets to Python sets containing the numbers of the chunks used. This makes it possible to map the individual packet reductions using efficient set operators.</p>
      </sec>
    </sec>
  </sec>
  <sec id="Sec21">
    <title>Results</title>
    <p id="Par78"><italic>NOREC4DNA</italic> provides several simulators to compare different codes under various aspects. An illustration of a simulation run is shown in Fig. <xref rid="Fig10" ref-type="fig">10</xref>. The freely modifiable and extensible elements that can influence the results of a simulation are highlighted in yellow. The different coding methods have a uniform set of functions in form of a well-defined interface so that they can be exchanged without changing the system.<fig id="Fig10"><label>Fig. 10</label><caption><p>A simulation run</p></caption><graphic xlink:href="12859_2021_4318_Fig10_HTML" id="MO18"/></fig></p>
    <sec id="Sec22">
      <title>Uniformly distributed random error</title>
      <p id="Par79">To show that DNA storage introduces severe restrictions to the possible sequences, we use our default rule set as defined in the class ‘FastDNARules’ to calculate the error prediction of uniformly distributed randomly generated sequences. Figure <xref rid="Fig11" ref-type="fig">11</xref> shows the cumulative density function (CDF) and the probability density function (PDF) of the error prediction for 500.000 uniformly random DNA sequences with a length of 120 bp. The PDF has a peak at an error value of 1.0, i.e., the majority of all sequences have a high error prediction (and thus violate at least one rule). The CDF shows that almost no sequence has an error value of less than 0.5. Thus, most random sequences produce a high error rate for a DNA storage system. This indicates the benefits of NORECs, since they can generate only sequences that yield a low error rate. The rule set can be used to specify user-defined rules and is thus not limited to a maximum of 100%. While each rule on its own may define an exclusion criteria on its own, applying multiple rules on a given sequence will yield an accumulated error value that in some cases will exceed 1.0 (100%). While all sequences with an error value greater than 1.0 violate at least one rule, a higher error prediction indicates that multiple rules were violated for the given sequence. The rule system can (optionally) return an error value per rule to provide more detailed insights.<fig id="Fig11"><label>Fig. 11</label><caption><p>CDF (orange) and PDF (blue) of the error value for 500.000 uniformly random DNA sequences with a length of 120 bp</p></caption><graphic xlink:href="12859_2021_4318_Fig11_HTML" id="MO19"/></fig></p>
    </sec>
    <sec id="Sec23">
      <title>Impact of the rules on the packet structure</title>
      <p id="Par80">To test the effects of different encodings (together with additional preselection of packets) on the generated DNA sequences, we encoded an image (the logo of the department as a .jpg file) into packets of the same length of 465 nt using different codes and selected random samples from these created packets.</p>
      <p id="Par81">In the first run, the packets were created without replacing those with a high error value. In addition, to facilitate a comparison with the implemented NORECs, we analyzed the distribution of the bases for a randomly selected packet of the same length generated by a Reed–Solomon algorithm. Using a sliding window of 32 bases, Fig. <xref rid="Fig12" ref-type="fig">12</xref> shows the relative frequency of the four bases in the generated sequence (0%: start of the sequence; 100%: end of the sequence). Here, the distribution of the individual bases of a Reed–Solomon packet is extremely unfavorable for DNA storage. Compared to the other bases, the relative frequency of base A is well above the majority of the sequence and thus indicates an unfavorable GC content as well as a high chance of homopolymers. This is due to the fact that Reed–Solomon is a systematic code, which in our case means that the encoded file has an unfavorable distribution regarding the selected rules. It has to be mentioned that the image as the chosen input file has longer sequences of the same symbols, which results in a corresponding distribution in the generated DNA strand.<fig id="Fig12"><label>Fig. 12</label><caption><p>Distribution of bases in a Reed–Solomon packet</p></caption><graphic xlink:href="12859_2021_4318_Fig12_HTML" id="MO20"/></fig></p>
      <p id="Par82">This also shows that an implementation of the Raptor code in the form of a systematic code would not have a positive impact on the created packets. In previous DNA storage approaches (e.g., [<xref ref-type="bibr" rid="CR2">2</xref>, <xref ref-type="bibr" rid="CR31">31</xref>]), this problem is combatted by intermediary codes with appropriate substitutions (using Huffman coding, scrambling, or others). However, these mitigations require more computing effort and usually reduce the storage density by inserting additional symbols or lack generalization.<fig id="Fig13"><label>Fig. 13</label><caption><p>Distribution of bases in LT packets (Robust Soliton)</p></caption><graphic xlink:href="12859_2021_4318_Fig13_HTML" id="MO21"/></fig></p>
      <p id="Par83">Figure <xref rid="Fig13" ref-type="fig">13</xref> shows the distribution of the individual bases in a randomly selected LT packet with Robust Soliton distribution. While the distribution of packets without preselection (<xref rid="Fig13" ref-type="fig">13</xref>a, b) shows strong fluctuations for the individual bases, the randomly selected packet generation with preselection (<xref rid="Fig13" ref-type="fig">13</xref>c, d) shows significant improvements. The distribution of the bases shows that the selected packet has a nearly optimal distribution of 25% per base (Fig. <xref rid="Fig13" ref-type="fig">13</xref>d). Only for the start and end of the DNA sequence there are major differences in the frequency of the individual bases. However, this can be attributed to the random seed and the error detection/correction attached at the beginning and the end of the sequence. The desired 25% are motivated by the ideal distribution of the nucleotides in each window. By having an equal distribution of 25%, the sequence is less likely to contain homopolymers and will also have a balanced GC content of around 50%.</p>
      <p id="Par84">For the Online encoding, this analysis delivers similar results. The <inline-formula id="IEq31"><alternatives><tex-math id="M77">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\delta$$\end{document}</tex-math><mml:math id="M78"><mml:mi>δ</mml:mi></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq31.gif"/></alternatives></inline-formula> parameter was chosen such that the packets have the same size as the LT and Raptor encoding. While the improvement between the two variants (Fig. <xref rid="Fig14" ref-type="fig">14</xref>a, c) is not apparent at first glance, the boxplots (Fig. <xref rid="Fig14" ref-type="fig">14</xref>b, d) of the distribution of the four bases show that the version with preselection has a much smaller variance.<fig id="Fig14"><label>Fig. 14</label><caption><p>Distribution of bases in online packets (quality = 5)</p></caption><graphic xlink:href="12859_2021_4318_Fig14_HTML" id="MO22"/></fig><fig id="Fig15"><label>Fig. 15</label><caption><p>Distribution of bases in Raptor packets</p></caption><graphic xlink:href="12859_2021_4318_Fig15_HTML" id="MO23"/></fig></p>
      <p id="Par85">For the Raptor encoding shown in Fig. <xref rid="Fig15" ref-type="fig">15</xref>, preselection apparently has the slightest impact. This is due to the fact that Raptor already achieves good results with the non-optimized packets. Thus, apart from the beginning of the DNA sequence, the occurrence of all bases is between 13% and 36%. However, except for base A, after preselection all bases average at the optimum of 25% (Fig. <xref rid="Fig15" ref-type="fig">15</xref>d).</p>
      <p id="Par86">The very low C content, which can be clearly recognized at the beginning of all examined packets, can be explained by the fact that the header is stored here. Since the header contains the parameters ‘Number of Chunks’ and ‘Seed’, and the number of chunks is the same for all packets, the same value is stored at this location. To mitigate the formation of homopolymers for the number of chunks field, we can apply a mask or reduce the size of the field. Another solution could be to make a different choice for the number of chunks or not to write them into the header but to transmit them out of band. Using a more work-intensive decoding, this information could even be omitted completely. Alternatively, this field could be encoded using regular codes for DNA storage. This would reduce the information density by a small percentage but would guarantee that all inputs satisfy the DNA storage requirements.</p>
      <p id="Par87">We want to emphasize that the selected packets in our evaluations, without loss of generality, were drawn at random. Graphs for other packets of this experiment can be found in the Github repository or generated using the scripts provided.</p>
    </sec>
    <sec id="Sec24">
      <title>Estimated error probabilities of the codes</title>
      <p id="Par88">To further analyze the ability to create sequences with low error probabilities, we created all possible sequences for a given file with a fixed sequence size. As an input we used a text file containing the German fairytale ‘Sleeping Beauty’ to create 163 nt long sequences. With a 2 byte seed (and a 2 byte Reed–Solomon code at the end of each sequence), we created 65,536 sequences using each code and analyzed these sequences with the default rule set.<fig id="Fig16"><label>Fig. 16</label><caption><p>Distribution of the error probability of created sequences</p></caption><graphic xlink:href="12859_2021_4318_Fig16_HTML" id="MO24"/></fig></p>
      <p id="Par89">Figure <xref rid="Fig16" ref-type="fig">16</xref>a shows the distribution of the error probabilities of all 16,538 sequences that have an error probability of less than 40%. With a mean value (black ‘X’) of nearly 20% error probability and a tight lower and upper quartile of 17% and 23%, respectively, we see that LT performs worst. For LT, the cumulative kernel density estimate (red) shows that not even 33% of the packets have an error probability of less than 20%. Figure <xref rid="Fig16" ref-type="fig">16</xref>b shows that the Online code generates only 13,590 sequences in the specified range, but does not only have a slightly lower mean error probability (and lower quartile) of 19% (and 2%) but also yields nearly 40% sequences with an error probability below 20%.</p>
      <p id="Par90">The distribution of the sequences generated using the Raptor code, as shown in Fig. <xref rid="Fig16" ref-type="fig">16</xref>c, shows a further improvement. While the basic distribution is similar to the sequences created using the Online code, there are major differences: (a) the number of sequences with an error probability of less than 40% is 16,097 and thus higher than for the Online code, and (b) there are more sequences with a low error probability (and especially 0%). In more detail, the mean value is 18%, and the lower and upper quartiles are 1% and 22%, respectively. By looking at the cumulative kernel density estimate, we can see that 45% of the sequences in this range have an error probability below 20%.</p>
      <p id="Par91">While the given file was split into 163 (196 for Online, due to the larger header) chunks and thus <inline-formula id="IEq32"><alternatives><tex-math id="M79">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$(1+\epsilon )*163$$\end{document}</tex-math><mml:math id="M80"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>ϵ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow/><mml:mo>∗</mml:mo><mml:mn>163</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq32.gif"/></alternatives></inline-formula> (<inline-formula id="IEq33"><alternatives><tex-math id="M81">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$(1+\epsilon )*196$$\end{document}</tex-math><mml:math id="M82"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>ϵ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow/><mml:mo>∗</mml:mo><mml:mn>196</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq33.gif"/></alternatives></inline-formula> for Online) sequences would be sufficient to decode the reconstructed the file, a large number of sequences with a low error probability is crucial for larger files with an equal or smaller sequence length. Since the seed is usually stored in a 2 byte field, we are limited to 65,535 different packets. If the code generally produces many low error sequences, we can use the 2 byte field for larger files than for a code that produces more high error sequences. While we could and might have to increase the size of the seed field to 4 (or even 8) bytes, this will introduce an overhead and thus will decrease the storage density (and will increase the cost). Since LT and Online (to some extent) are more susceptible to the coupon collector’s problem, these codes will generally require a larger <inline-formula id="IEq34"><alternatives><tex-math id="M83">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\epsilon$$\end{document}</tex-math><mml:math id="M84"><mml:mi>ϵ</mml:mi></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq34.gif"/></alternatives></inline-formula> than Raptor.</p>
    </sec>
    <sec id="Sec25">
      <title>Susceptibility to the coupon collector’s problem</title>
      <p id="Par92">The coupon collector’s problem indicates the complexity of finding all pieces required to own a complete set of pieces (i.e., decoded source symbols). Using it, we can analyze how well the codes perform regarding the (average) overhead required to successfully decode the original data. For the LT code, Luby states that an average of <inline-formula id="IEq35"><alternatives><tex-math id="M85">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$k + O(\sqrt{k}\ln ^2(k/\delta ))$$\end{document}</tex-math><mml:math id="M86"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msqrt><mml:mi>k</mml:mi></mml:msqrt><mml:msup><mml:mo>ln</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>δ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq35.gif"/></alternatives></inline-formula> encoded symbols are required to decode a file that was split into <italic>k</italic> chunks with a probability of <inline-formula id="IEq36"><alternatives><tex-math id="M87">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$1-\delta$$\end{document}</tex-math><mml:math id="M88"><mml:mrow><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mi>δ</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq36.gif"/></alternatives></inline-formula> [<xref ref-type="bibr" rid="CR6">6</xref>]. Online [<xref ref-type="bibr" rid="CR7">7</xref>] as well as Raptor [<xref ref-type="bibr" rid="CR8">8</xref>] achieve a theoretical linear complexity and thus require a flat <inline-formula id="IEq37"><alternatives><tex-math id="M89">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$(1+\epsilon )*k$$\end{document}</tex-math><mml:math id="M90"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>ϵ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow/><mml:mo>∗</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq37.gif"/></alternatives></inline-formula> (with <inline-formula id="IEq38"><alternatives><tex-math id="M91">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\epsilon \rightarrow 0$$\end{document}</tex-math><mml:math id="M92"><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq38.gif"/></alternatives></inline-formula> when <inline-formula id="IEq39"><alternatives><tex-math id="M93">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$k \rightarrow \infty$$\end{document}</tex-math><mml:math id="M94"><mml:mrow><mml:mi>k</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mi>∞</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="12859_2021_4318_Article_IEq39.gif"/></alternatives></inline-formula>) sequences to reconstruct the input file. This is due to the precoding applied in both codes.<fig id="Fig17"><label>Fig. 17</label><caption><p>Number of packets containing each chunk (based on 500 packets each)</p></caption><graphic xlink:href="12859_2021_4318_Fig17_HTML" id="MO25"/></fig></p>
      <p id="Par93">Figure <xref rid="Fig17" ref-type="fig">17</xref> shows the number of times each chunk of the input files is present in a created packet. Although we analyzed 500 packets for an encoding with only 196 chunks, for LT almost no chunk is included into more than 25 packets. This means that there is (a) a higher chance of a chunk missing due to errors and mutations (a chunk might have a high error rate and propagate this error probability to created packets including this chunk), and (b) a higher susceptibility to the coupon collector’s problem. Since each packet includes only a few chunks, the probability of a chunk not being included into any packet already read increases. In contrast, Online and Raptor with a minimum of 50 and a maximum of over 110 occurrences per chunk (75 and 175 for Online) are less likely to suffer from these problems. It should be noted that due to the larger header used for Online and the decision to use the same chunk size instead of the same number of chunks (for the comparisons described earlier), the input file for the Online code was split into 196 chunks and thus cannot be compared directly. The Online code calculates the number of auxiliary blocks based on the number of chunks and thus has a higher average number of packets containing each chunk than Raptor.</p>
      <p id="Par94">Figure <xref rid="Fig17" ref-type="fig">17</xref> illustrates why the Online and Raptor codes yield better results regarding the impact of the rules on the packet structure, as already described in “<xref rid="Sec23" ref-type="sec">Impact of the rules on the packet structure</xref>” section. Since both codes combine more chunks to create packets, they are more likely to combine different symbols using XOR and thus create an equal distribution of all nucleotides. Logically, this effect only occurs if the input file is not perfectly random (otherwise, the LT code would also yield packets with a nearly perfect 25% distribution for each base).</p>
    </sec>
    <sec id="Sec26">
      <title>Encoding speed</title>
      <p id="Par95">In this section, we evaluate the encoding speed of <italic>NOREC4DNA</italic>. To reduce the encoding speed, we applied various techniques including multi-threading and Python’s C-extensions. All following experiments were performed using a server with 2x Intel(R) Xeon(R) CPU E5-2698 v4 @ 2.20GHz (40 Cores, 80 Threads) and a total of 252 GB RAM.</p>
      <p id="Par96">Since the entire process of storing data in DNA is still expensive and error-prone, it is well advised to generate all possible sequences for a given input file using the whole seed range. By sorting these sequences according to the estimated error values, we can guarantee that we synthesize the best possible sequences.</p>
      <p id="Par97">In a first experiment, we used the “find_minium_packets” script with the RU10 encoder to create packets. Each file was split into chunks of 34 bytes each, and a header chunk was added. Additionally, for all packets, a Reed–Solomon (RS) code of 4 (6) bytes was added to detect and repair inner packet errors. This resulted in sequences of length 160 nt (168 nt for the experiments with a 6 bytes Reed–Solomon code). After we created and tested all packets, we merged the results and sorted them according to their error values. For our error prediction, the default rules defined in the framework were used. Each experiment was repeated 50 times.<fig id="Fig18"><label>Fig. 18</label><caption><p>Time required to create 65,536 packets and sorting them according to the error predictions for different configurations</p></caption><graphic xlink:href="12859_2021_4318_Fig18_HTML" id="MO26"/></fig><table-wrap id="Tab4"><label>Table 4</label><caption><p>Configurations as shown in Fig. <xref rid="Fig18" ref-type="fig">18</xref></p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Config 1</th><th align="left">Config 2</th><th align="left">Config 3</th><th align="left">Config 4</th></tr></thead><tbody><tr><td align="left">1 kb Lorem—4 RS</td><td align="left">1 kb Lorem—6 RS</td><td align="left">4.9 kb fairytale—4 RS</td><td align="left">4.9 kb fairytale—6 RS</td></tr></tbody></table><table frame="hsides" rules="groups"><thead><tr><th align="left">Config 5</th><th align="left">Config 6</th><th align="left">Config 7</th><th align="left">Config 8</th></tr></thead><tbody><tr><td align="left">34 kb LICENSE—4 RS</td><td align="left">34 kb LICENSE—6 RS</td><td align="left">72kb logo—4 RS</td><td align="left">72 kb logo—6 RS</td></tr></tbody></table><table frame="hsides" rules="groups"><thead><tr><th align="left" colspan="2">Config 9</th><th align="left" colspan="2">Config 10</th></tr></thead><tbody><tr><td align="left" colspan="2">100 kb Lorem—4 RS</td><td align="left" colspan="2">100 kb Lorem—6 RS</td></tr></tbody></table><table-wrap-foot><p>All files can be accessed in the source repository</p></table-wrap-foot></table-wrap></p>
      <p id="Par98">As shown in Fig. <xref rid="Fig18" ref-type="fig">18</xref> (and Table <xref rid="Tab4" ref-type="table">4</xref>), the time needed for small files (Configurations 1 - 4) does not increase significantly. Both the 1 kb “Lorem Ipsum” text file and the 4.9 kb “Sleeping Beauty” fairytale file take nearly the same time to encode and only differ when the number of Reed–Solomon symbols increases. This is due to the increased size of the sequences and thus more effort for error calculation.</p>
      <p id="Par99">For the AGPL-LICENSE file (Configurations 5–6; 34 kb) and the image “logo.jpg” (Configurations 7–8; 72 kb), we obtained a higher encoding time for an increased file size and a higher number of Reed–Solomon symbols. For the 100 kb version of “Lorem Ipsum” (Configurations 9–10, 100 kb), there is nearly no difference between the 6 bytes Reed–Solomon version of the “logo.jpg” and the 4 bytes Reed–Solomon version (Configuration 8 vs. Configuration 9). However, the average encoding time for the version with 6 bytes of Reed–Solomon per packet (Configuration 10) increases to about 22 seconds. By comparing the 1 kb Lorem Ipsum file with the 100 kb version (Configuration 1 and Configuration 9), we see that with an increase from an average of 4.5 s for the 1 kb file and 17.5 seconds for the 100 kb file, the time required for encoding does not significantly increase with the input file size. We additionally conducted this experiment with a 1 Mb file containing random ASCII characters using 4 Reed–Solomon symbols per packet. It took an average of 127 s to finish.</p>
      <p id="Par100">To investigate the encoding speed further, we profiled the multi-threaded encoding process. This showed that across all files tested, approximately 76% of the computation time is used for sorting and merging the created packets. Thus, optimizations of sorting and merging could greatly reduce the encoding time. To reduce the speed impact of sorting and merging, a user should define the required packets and the maximum tolerated error before calculating all possible packets.</p>
      <p id="Par101">A further possibility to improve the encoding speed is to use cloud services to take advantage of the highly parallel nature of the encoding scheme (given the same input, the encoding could easily be performed using multiple computers in a parallel or distributed manner.)</p>
      <p id="Par102">Thus, there are several options for improving the encoding speed. However, taking the price and required time for synthesis and sequencing into account, the current speed is already sufficient for real-world usage. Even for larger files, <italic>NOREC4DNA</italic> can generate sequences in a timely fashion in the order of seconds or minutes.</p>
    </sec>
  </sec>
  <sec id="Sec27">
    <title>Conclusion</title>
    <p id="Par103">We presented <italic>NOREC4DNA</italic>, a software framework to use, test, compare, and improve NORECs for DNA storage systems. We showed that such fountain coding schemes can effectively be used to satisfy the restrictions associated with the DNA medium. Additionally, these codes can adapt to the possible variable lengths of DNA strands and have nearly zero overhead. Therefore, using NORECs in DNA storage systems helps to achieve the goal of building a robust and high capacity long term storage.</p>
    <p id="Par104">Although our experimental comparisons only approximate storing data in synthesized DNA, the obtained results are very promising. Our evaluations showed that especially Raptor codes that have not yet been used for DNA storage systems yield excellent results. In addition, Online codes are quite useful for DNA storage systems. Both codes show better results than LT codes that were already used for storing data in DNA by Erlich and Zielinski [<xref ref-type="bibr" rid="CR4">4</xref>]. Since these authors have obtained good results with LT codes for DNA storage, it is likely that Raptor and Online codes will achieve significant improvements over LT codes for such storage systems.</p>
    <p id="Par105">There are several areas for future work. For example, we plan to improve the distribution functions for the used NORECs to tailor them to the DNA specific error channel. Furthermore, we will investigate how enforced rules can be used to improve the error correcting abilities of codes during DNA sequencing. Finally, we intend to create novel NORECs that are optimized for the special restrictions and limitations of DNA storage.</p>
  </sec>
  <sec id="Sec28">
    <title>Availability and requirements</title>
    <p id="Par106">
      <list list-type="bullet">
        <list-item>
          <p id="Par107">Project name: NOREC4DNA</p>
        </list-item>
        <list-item>
          <p id="Par108">Project home page: <ext-link ext-link-type="uri" xlink:href="https://github.com/umr-ds/NOREC4DNA">https://github.com/umr-ds/NOREC4DNA</ext-link></p>
        </list-item>
        <list-item>
          <p id="Par109">Operating system(s): Platform independent</p>
        </list-item>
        <list-item>
          <p id="Par110">Programming language: Python 3.6 or above, C</p>
        </list-item>
        <list-item>
          <p id="Par111">Other requirements: Python3, Python3-dev or Docker</p>
        </list-item>
        <list-item>
          <p id="Par112">License: AGPL v3.0</p>
        </list-item>
        <list-item>
          <p id="Par113">Any restrictions to use by non-academics: N/A</p>
        </list-item>
      </list>
    </p>
  </sec>
</body>
<back>
  <glossary>
    <title>Abbreviations</title>
    <def-list>
      <def-item>
        <term>DNA</term>
        <def>
          <p id="Par4">Deoxyribonucleic acid</p>
        </def>
      </def-item>
      <def-item>
        <term>NOREC</term>
        <def>
          <p id="Par5">Near-optimal rateless erasure code</p>
        </def>
      </def-item>
      <def-item>
        <term>LT</term>
        <def>
          <p id="Par6">Luby transform</p>
        </def>
      </def-item>
      <def-item>
        <term>LDPC</term>
        <def>
          <p id="Par7">Low density parity check</p>
        </def>
      </def-item>
      <def-item>
        <term>PCR</term>
        <def>
          <p id="Par8">Polymerase chain reaction</p>
        </def>
      </def-item>
      <def-item>
        <term>RS</term>
        <def>
          <p id="Par9">Reed–Solomon</p>
        </def>
      </def-item>
      <def-item>
        <term>CDF</term>
        <def>
          <p id="Par10">Cumulative density function</p>
        </def>
      </def-item>
      <def-item>
        <term>PDF</term>
        <def>
          <p id="Par11">Probability density function</p>
        </def>
      </def-item>
    </def-list>
  </glossary>
  <fn-group>
    <fn>
      <p>
        <bold>Publisher's Note</bold>
      </p>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
  </fn-group>
  <ack>
    <title>Acknowledgements</title>
    <p>Not applicable</p>
  </ack>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>PMS and BF conceived the project and wrote the paper. PMS developed the software. BF supervised the research. Both authors read and approved the final manuscript.</p>
  </notes>
  <notes notes-type="funding-information">
    <title>Funding</title>
    <p>Open Access funding enabled and organized by Projekt DEAL. This work is financially supported by the LOEWE program of the State of Hesse (Germany) in the MOSLA research cluster. The funding body did not influence any aspect of this work.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Availability of data and materials</title>
    <p>The code is released with an open source license and can be accessed at: <ext-link ext-link-type="uri" xlink:href="https://github.com/umr-ds/NOREC4DNA">https://github.com/umr-ds/NOREC4DNA</ext-link></p>
  </notes>
  <notes>
    <title>Declarations</title>
    <notes id="FPar2">
      <title>Ethics approval and consent to participate</title>
      <p id="Par114">Not applicable</p>
    </notes>
    <notes id="FPar3">
      <title>Consent for publication</title>
      <p id="Par115">Not applicable</p>
    </notes>
    <notes id="FPar4" notes-type="COI-statement">
      <title>Competing interests</title>
      <p id="Par116">The authors declare that they have no competing interests.</p>
    </notes>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Church</surname>
            <given-names>GM</given-names>
          </name>
          <name>
            <surname>Gao</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Kosuri</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Next-generation digital information storage in DNA</article-title>
        <source>Science</source>
        <year>2012</year>
        <volume>337</volume>
        <issue>6102</issue>
        <fpage>1628</fpage>
        <pub-id pub-id-type="doi">10.1126/science.1226355</pub-id>
        <?supplied-pmid 22903519?>
        <pub-id pub-id-type="pmid">22903519</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Goldman</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Bertone</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Dessimoz</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>LeProust</surname>
            <given-names>EM</given-names>
          </name>
          <name>
            <surname>Sipos</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Towards practical, high-capacity, low-maintenance information storage in synthesized DNA</article-title>
        <source>Nature</source>
        <year>2013</year>
        <volume>494</volume>
        <issue>7435</issue>
        <fpage>77</fpage>
        <pub-id pub-id-type="doi">10.1038/nature11875</pub-id>
        <?supplied-pmid 23354052?>
        <pub-id pub-id-type="pmid">23354052</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3.</label>
      <mixed-citation publication-type="other">Heckel R, Shomorony I, Ramchandran K, Tse DNC. Fundamental limits of DNA storage systems. In: 2017 IEEE International Symposium on Information Theory (ISIT), 2017;pp. 3130–3134. 10.1109/ISIT.2017.8007106</mixed-citation>
    </ref>
    <ref id="CR4">
      <label>4.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Erlich</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Zielinski</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>DNA fountain enables a robust and efficient storage architecture</article-title>
        <source>Science</source>
        <year>2017</year>
        <volume>355</volume>
        <issue>6328</issue>
        <fpage>950</fpage>
        <lpage>954</lpage>
        <pub-id pub-id-type="doi">10.1126/science.aaj2038</pub-id>
        <?supplied-pmid 28254941?>
        <pub-id pub-id-type="pmid">28254941</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5.</label>
      <mixed-citation publication-type="other">Ping Z, Zhang H, Chen S, Zhuang Q, Zhu SJ, Shen Y. Chamaeleo: a robust library for DNA storage coding schemes. bioRxiv. 2020. 10.1101/2020.01.02.892588</mixed-citation>
    </ref>
    <ref id="CR6">
      <label>6.</label>
      <mixed-citation publication-type="other">Luby M. LT codes. In: 43rd Annual IEEE Symposium on Foundations of Computer Science, 2002;pp. 271–280. 10.1109/SFCS.2002.1181950</mixed-citation>
    </ref>
    <ref id="CR7">
      <label>7.</label>
      <mixed-citation publication-type="other">Maymounkov P. Online codes. Technical report, New York University. 2002.</mixed-citation>
    </ref>
    <ref id="CR8">
      <label>8.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Shokrollahi</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Raptor codes</article-title>
        <source>IEEE Trans Inf Theory</source>
        <year>2006</year>
        <volume>52</volume>
        <issue>6</issue>
        <fpage>2551</fpage>
        <lpage>2567</lpage>
        <pub-id pub-id-type="doi">10.1109/TIT.2006.874390</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Flajolet</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Gardy</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Thimonier</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Birthday paradox, coupon collectors, caching algorithms and self-organizing search</article-title>
        <source>Discret Appl Math</source>
        <year>1992</year>
        <volume>39</volume>
        <issue>3</issue>
        <fpage>207</fpage>
        <lpage>229</lpage>
        <pub-id pub-id-type="doi">10.1016/0166-218X(92)90177-C</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Reed</surname>
            <given-names>IS</given-names>
          </name>
          <name>
            <surname>Solomon</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Polynomial codes over certain finite fields</article-title>
        <source>J Soc Ind Appl Math</source>
        <year>1960</year>
        <volume>8</volume>
        <issue>2</issue>
        <fpage>300</fpage>
        <lpage>304</lpage>
        <pub-id pub-id-type="doi">10.1137/0108018</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11.</label>
      <mixed-citation publication-type="other">Luby M, Shokrollahi A, Watson M, Stockhammer T. RFC 5053 - Raptor Forward Error Correction Scheme for Object Delivery. Technical report, RFC Editor (2007)</mixed-citation>
    </ref>
    <ref id="CR12">
      <label>12.</label>
      <mixed-citation publication-type="other">Luby M, Shokrollahi A, Watson M, Stockhammer T, Minder L. RaptorQ Forward Error Correction Scheme for Object Delivery. RFC 6330, RFC Editor (2011).</mixed-citation>
    </ref>
    <ref id="CR13">
      <label>13.</label>
      <mixed-citation publication-type="other">Qualcomm Incorporated, Digital Fountain Inc.: Systems And Processes For Decoding Chain Reaction Codes Through Inactivation. 6856263, February 2005.</mixed-citation>
    </ref>
    <ref id="CR14">
      <label>14.</label>
      <mixed-citation publication-type="other">Luby M. Digital Fountain Inc.: Information Additive Code Generator And Decoder For Communication Systems. 6307487 B1, October 2001.</mixed-citation>
    </ref>
    <ref id="CR15">
      <label>15.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schreiber</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>A new implementation of sparse Gaussian elimination</article-title>
        <source>ACM Trans Math Softw (TOMS)</source>
        <year>1982</year>
        <volume>8</volume>
        <issue>3</issue>
        <fpage>256</fpage>
        <lpage>276</lpage>
        <pub-id pub-id-type="doi">10.1145/356004.356006</pub-id>
      </element-citation>
    </ref>
    <ref id="CR16">
      <label>16.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>MacKay</surname>
            <given-names>DJ</given-names>
          </name>
        </person-group>
        <article-title>Fountain codes</article-title>
        <source>IEE Proc Commun</source>
        <year>2005</year>
        <volume>152</volume>
        <issue>6</issue>
        <fpage>1062</fpage>
        <lpage>1068</lpage>
        <pub-id pub-id-type="doi">10.1049/ip-com:20050237</pub-id>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17.</label>
      <mixed-citation publication-type="other">Chen S, Zhang Z, Zhang L, Yao C. Belief propagation with gradual edge removal for Raptor codes over AWGN channel. In: 2013 IEEE 24th Annual International Symposium on Personal, Indoor, and Mobile Radio Communications (PIMRC), 2013;pp. 380–385. 10.1109/PIMRC.2013.6666165</mixed-citation>
    </ref>
    <ref id="CR18">
      <label>18.</label>
      <mixed-citation publication-type="other">Yedidia JS, Freeman WT, Weiss Y, et al. Generalized belief propagation In: NIPS. 2000;13:689–95.</mixed-citation>
    </ref>
    <ref id="CR19">
      <label>19.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Margulies</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Egholm</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Altman</surname>
            <given-names>WE</given-names>
          </name>
          <name>
            <surname>Attiya</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Bader</surname>
            <given-names>JS</given-names>
          </name>
          <name>
            <surname>Bemben</surname>
            <given-names>LA</given-names>
          </name>
          <name>
            <surname>Berka</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Braverman</surname>
            <given-names>MS</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>Y-J</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Dewell</surname>
            <given-names>SB</given-names>
          </name>
          <name>
            <surname>Du</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Fierro</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Gomes</surname>
            <given-names>XV</given-names>
          </name>
          <name>
            <surname>Godwin</surname>
            <given-names>BC</given-names>
          </name>
          <name>
            <surname>He</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Helgesen</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Ho</surname>
            <given-names>CH</given-names>
          </name>
          <name>
            <surname>Irzyk</surname>
            <given-names>GP</given-names>
          </name>
          <name>
            <surname>Jando</surname>
            <given-names>SC</given-names>
          </name>
          <name>
            <surname>Alenquer</surname>
            <given-names>MLI</given-names>
          </name>
          <name>
            <surname>Jarvie</surname>
            <given-names>TP</given-names>
          </name>
          <name>
            <surname>Jirage</surname>
            <given-names>KB</given-names>
          </name>
          <name>
            <surname>Kim</surname>
            <given-names>J-B</given-names>
          </name>
          <name>
            <surname>Knight</surname>
            <given-names>JR</given-names>
          </name>
          <name>
            <surname>Lanza</surname>
            <given-names>JR</given-names>
          </name>
          <name>
            <surname>Leamon</surname>
            <given-names>JH</given-names>
          </name>
          <name>
            <surname>Lefkowitz</surname>
            <given-names>SM</given-names>
          </name>
          <name>
            <surname>Lei</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Lohman</surname>
            <given-names>KL</given-names>
          </name>
          <name>
            <surname>Lu</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Makhijani</surname>
            <given-names>VB</given-names>
          </name>
          <name>
            <surname>McDade</surname>
            <given-names>KE</given-names>
          </name>
          <name>
            <surname>McKenna</surname>
            <given-names>MP</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>EW</given-names>
          </name>
          <name>
            <surname>Nickerson</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Nobile</surname>
            <given-names>JR</given-names>
          </name>
          <name>
            <surname>Plant</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Puc</surname>
            <given-names>BP</given-names>
          </name>
          <name>
            <surname>Ronan</surname>
            <given-names>MT</given-names>
          </name>
          <name>
            <surname>Roth</surname>
            <given-names>GT</given-names>
          </name>
          <name>
            <surname>Sarkis</surname>
            <given-names>GJ</given-names>
          </name>
          <name>
            <surname>Simons</surname>
            <given-names>JF</given-names>
          </name>
          <name>
            <surname>Simpson</surname>
            <given-names>JW</given-names>
          </name>
          <name>
            <surname>Srinivasan</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Tartaro</surname>
            <given-names>KR</given-names>
          </name>
          <name>
            <surname>Tomasz</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Vogt</surname>
            <given-names>KA</given-names>
          </name>
          <name>
            <surname>Volkmer</surname>
            <given-names>GA</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>SH</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Weiner</surname>
            <given-names>MP</given-names>
          </name>
          <name>
            <surname>Yu</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Begley</surname>
            <given-names>RF</given-names>
          </name>
          <name>
            <surname>Rothberg</surname>
            <given-names>JM</given-names>
          </name>
        </person-group>
        <article-title>Genome sequencing in microfabricated high-density picolitre reactors</article-title>
        <source>Nature</source>
        <year>2005</year>
        <volume>437</volume>
        <issue>7057</issue>
        <fpage>376</fpage>
        <lpage>380</lpage>
        <pub-id pub-id-type="doi">10.1038/nature03959</pub-id>
        <?supplied-pmid 16056220?>
        <pub-id pub-id-type="pmid">16056220</pub-id>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Jensen</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Fukushima</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Davis</surname>
            <given-names>RW</given-names>
          </name>
        </person-group>
        <article-title>DMSO and betaine greatly improve amplification of GC-rich constructs in de novo synthesis</article-title>
        <source>PLoS ONE</source>
        <year>2010</year>
        <volume>5</volume>
        <issue>6</issue>
        <fpage>11024</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0011024</pub-id>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Yakovchuk</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Protozanova</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Frank-Kamenetskii</surname>
            <given-names>MD</given-names>
          </name>
        </person-group>
        <article-title>Base-stacking and base-pairing contributions into thermal stability of the DNA double helix</article-title>
        <source>Nucl Acids Res</source>
        <year>2006</year>
        <volume>34</volume>
        <issue>2</issue>
        <fpage>564</fpage>
        <lpage>574</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkj454</pub-id>
        <?supplied-pmid 16449200?>
        <pub-id pub-id-type="pmid">16449200</pub-id>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Jiao</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Yang</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Feng</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Wu</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>Q</given-names>
          </name>
        </person-group>
        <article-title>Distributed rateless codes with unequal error protection property for space information networks</article-title>
        <source>Entropy</source>
        <year>2017</year>
        <pub-id pub-id-type="doi">10.3390/e19010038</pub-id>
      </element-citation>
    </ref>
    <ref id="CR23">
      <label>23.</label>
      <mixed-citation publication-type="other">Woo SS, Cheng MK. Prioritized LT codes. In: 2008 42nd Annual Conference on Information Sciences and Systems, 2008;pp. 568–573. 10.1109/CISS.2008.4558589</mixed-citation>
    </ref>
    <ref id="CR24">
      <label>24.</label>
      <mixed-citation publication-type="other">Limbachiya D, Dhameliya V, Khakhar M, Gupta MK. On optimal family of codes for archival DNA storage. In: 2015 Seventh International Workshop on Signal Design and Its Applications in Communications (IWSDA), 2015;pp. 123–127. 10.1109/IWSDA.2015.7458386</mixed-citation>
    </ref>
    <ref id="CR25">
      <label>25.</label>
      <mixed-citation publication-type="other">Ullah AMMS, D’Addona D, Arai N. DNA based computing for understanding complex shapes. Biosystems. 2014;117:40–53. 10.1016/j.biosystems.2014.01.003.</mixed-citation>
    </ref>
    <ref id="CR26">
      <label>26.</label>
      <mixed-citation publication-type="other">Haughton D, Balado F. Repetition coding as an effective error correction code for information encoded in dna. In: 2011 IEEE 11th International Conference on Bioinformatics and Bioengineering, 2011;pp. 253–260. 10.1109/BIBE.2011.45</mixed-citation>
    </ref>
    <ref id="CR27">
      <label>27.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Akhmetov</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Ellington</surname>
            <given-names>AD</given-names>
          </name>
          <name>
            <surname>Marcotte</surname>
            <given-names>EM</given-names>
          </name>
        </person-group>
        <article-title>A highly parallel strategy for storage of digital information in living cells</article-title>
        <source>BMC Biotechnol</source>
        <year>2018</year>
        <volume>18</volume>
        <issue>1</issue>
        <fpage>1</fpage>
        <lpage>19</lpage>
        <pub-id pub-id-type="doi">10.1186/s12896-018-0476-4</pub-id>
        <pub-id pub-id-type="pmid">29316906</pub-id>
      </element-citation>
    </ref>
    <ref id="CR28">
      <label>28.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lang</surname>
            <given-names>G.I</given-names>
          </name>
          <name>
            <surname>Parsons</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Gammie</surname>
            <given-names>A.E</given-names>
          </name>
        </person-group>
        <article-title>Mutation rates, spectra, and genome-wide distribution of spontaneous mutations in mismatch repair deficient yeast</article-title>
        <source>G3 Genes Genomes Genetics</source>
        <year>2013</year>
        <volume>3</volume>
        <issue>9</issue>
        <fpage>1453</fpage>
        <lpage>1465</lpage>
        <pub-id pub-id-type="doi">10.1534/g3.113.006429</pub-id>
        <?supplied-pmid 23821616?>
        <pub-id pub-id-type="pmid">23821616</pub-id>
      </element-citation>
    </ref>
    <ref id="CR29">
      <label>29.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Grass</surname>
            <given-names>RN</given-names>
          </name>
          <name>
            <surname>Heckel</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Puddu</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Paunescu</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Stark</surname>
            <given-names>WJ</given-names>
          </name>
        </person-group>
        <article-title>Robust chemical preservation of digital information on DNA in silica with error-correcting codes</article-title>
        <source>Angew Chem Int Ed</source>
        <year>2015</year>
        <volume>54</volume>
        <issue>8</issue>
        <fpage>2552</fpage>
        <lpage>2555</lpage>
        <pub-id pub-id-type="doi">10.1002/anie.201411378</pub-id>
      </element-citation>
    </ref>
    <ref id="CR30">
      <label>30.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Walser</surname>
            <given-names>J-C</given-names>
          </name>
          <name>
            <surname>Ponger</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Furano</surname>
            <given-names>AV</given-names>
          </name>
        </person-group>
        <article-title>CpG dinucleotides and the mutation rate of non-CpG DNA</article-title>
        <source>Genome Res</source>
        <year>2008</year>
        <volume>18</volume>
        <issue>9</issue>
        <fpage>1403</fpage>
        <lpage>1414</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.076455.108</pub-id>
        <?supplied-pmid 18550801?>
        <pub-id pub-id-type="pmid">18550801</pub-id>
      </element-citation>
    </ref>
    <ref id="CR31">
      <label>31.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bornholt</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Lopez</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Carmean</surname>
            <given-names>DM</given-names>
          </name>
          <name>
            <surname>Ceze</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Seelig</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Strauss</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>A DNA-based archival storage system</article-title>
        <source>SIGPLAN Not</source>
        <year>2016</year>
        <volume>51</volume>
        <issue>4</issue>
        <fpage>637</fpage>
        <lpage>649</lpage>
        <pub-id pub-id-type="doi">10.1145/2954679.2872397</pub-id>
      </element-citation>
    </ref>
    <ref id="CR32">
      <label>32.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schwarz</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Welzel</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Kabdullayeva</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Becker</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Freisleben</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Heider</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>MESA: automated assessment of synthetic DNA fragments and simulation of DNA synthesis, storage, sequencing and PCR errors</article-title>
        <source>Bioinformatics</source>
        <year>2020</year>
        <volume>36</volume>
        <issue>11</issue>
        <fpage>3322</fpage>
        <lpage>3326</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btaa140</pub-id>
        <?supplied-pmid 32129840?>
        <pub-id pub-id-type="pmid">32129840</pub-id>
      </element-citation>
    </ref>
    <ref id="CR33">
      <label>33.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Welzel</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Lange</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Heider</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Schwarz</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Freisleben</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Jensen</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Boenigk</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Beisser</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Natrix: a Snakemake-based workflow for processing, clustering, and taxonomically assigning amplicon sequencing reads</article-title>
        <source>BMC Bioinformatics</source>
        <year>2020</year>
        <volume>21</volume>
        <issue>1</issue>
        <fpage>526</fpage>
        <pub-id pub-id-type="doi">10.1186/s12859-020-03852-4</pub-id>
        <?supplied-pmid 33198651?>
        <pub-id pub-id-type="pmid">33198651</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
