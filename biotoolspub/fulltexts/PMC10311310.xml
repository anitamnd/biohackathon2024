<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10311310</article-id>
    <article-id pub-id-type="pmid">37387134</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad250</article-id>
    <article-id pub-id-type="publisher-id">btad250</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Genome Sequence Analysis</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>PlasBin-flow: a flow-based MILP algorithm for plasmid contigs binning</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Mane</surname>
          <given-names>Aniket</given-names>
        </name>
        <aff><institution>Department of Mathematics, Simon Fraser University</institution>, Burnaby V5A 1S6, <country country="CA">Canada</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Faizrahnemoon</surname>
          <given-names>Mahsa</given-names>
        </name>
        <aff><institution>Department of Mathematics, Simon Fraser University</institution>, Burnaby V5A 1S6, <country country="CA">Canada</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Vinař</surname>
          <given-names>Tomáš</given-names>
        </name>
        <aff><institution>Department of Applied Informatics, Comenius University</institution>, Bratislava 84248, <country country="SK">Slovakia</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Brejová</surname>
          <given-names>Broňa</given-names>
        </name>
        <aff><institution>Department of Computer Science, Comenius University</institution>, Bratislava 84248, <country country="SK">Slovakia</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-9837-1878</contrib-id>
        <name>
          <surname>Chauve</surname>
          <given-names>Cedric</given-names>
        </name>
        <aff><institution>Department of Mathematics, Simon Fraser University</institution>, Burnaby V5A 1S6, <country country="CA">Canada</country></aff>
        <xref rid="btad250-cor1" ref-type="corresp"/>
        <!--cchauve@sfu.ca-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad250-cor1">Corresponding author. Department of Mathematics, Simon Fraser University, Burnaby V5A 1S6, Canada. E-mail: <email>cchauve@sfu.ca</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-06-30">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB/ECCB 2023 Proceedings</issue-title>
    <fpage>i288</fpage>
    <lpage>i296</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad250.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>The analysis of bacterial isolates to detect plasmids is important due to their role in the propagation of antimicrobial resistance. In short-read sequence assemblies, both plasmids and bacterial chromosomes are typically split into several contigs of various lengths, making identification of plasmids a challenging problem. In plasmid contig binning, the goal is to distinguish short-read assembly contigs based on their origin into plasmid and chromosomal contigs and subsequently sort plasmid contigs into bins, each bin corresponding to a single plasmid. Previous works on this problem consist of <italic toggle="yes">de novo</italic> approaches and reference-based approaches. <italic toggle="yes">De novo</italic> methods rely on contig features such as length, circularity, read coverage, or GC content. Reference-based approaches compare contigs to databases of known plasmids or plasmid markers from finished bacterial genomes.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>Recent developments suggest that leveraging information contained in the assembly graph improves the accuracy of plasmid binning. We present PlasBin-flow, a hybrid method that defines contig bins as subgraphs of the assembly graph. PlasBin-flow identifies such plasmid subgraphs through a mixed integer linear programming model that relies on the concept of network flow to account for sequencing coverage, while also accounting for the presence of plasmid genes and the GC content that often distinguishes plasmids from chromosomes. We demonstrate the performance of PlasBin-flow on a real dataset of bacterial samples.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p><ext-link xlink:href="https://github.com/cchauve/PlasBin-flow" ext-link-type="uri">https://github.com/cchauve/PlasBin-flow</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Slovak Research Agency VEGA</institution>
          </institution-wrap>
        </funding-source>
        <award-id>1/0538/22</award-id>
        <award-id>1/0463/20</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>European Union’s Horizon 2020</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Marie Skłodowska-Curie</institution>
          </institution-wrap>
        </funding-source>
        <award-id>872539</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Natural Sciences and Engineering Research Council of Canada</institution>
            <institution-id institution-id-type="DOI">10.13039/501100000038</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>RGPIN-03986</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Antimicrobial resistance (AMR) has emerged to become a major threat to public health. AMR is developed in bacteria through the propagation of AMR genes, often facilitated by mobile genetic elements (MGEs), which can be exchanged between bacteria through horizontal gene transfer (HGT; <xref rid="btad250-B15" ref-type="bibr">Partridge et al. 2018</xref>; <xref rid="btad250-B8" ref-type="bibr">De Oliveira et al. 2020</xref>). Plasmids are short circular extra-chromosomal MGEs known to be a major vector for the spread of AMR through HGT (<xref rid="btad250-B7" ref-type="bibr">Carattoli 2013</xref>). Thus, the detection of plasmids in bacterial genomes is an important problem in microbial genomics, with applications in environmental ecology and public health surveillance.</p>
    <p>With the advent of DNA sequencing technologies, it is now possible to obtain whole-genome sequencing (WGS) data at a low cost, and the analysis of WGS data for public health surveillance is now common (<xref rid="btad250-B10" ref-type="bibr">Gerner-Smidt et al. 2019</xref>; <xref rid="btad250-B20" ref-type="bibr">Struelens and Sintchenko 2020</xref>). Despite the increasing availability of long-read sequencing data (<xref rid="btad250-B21" ref-type="bibr">Tedersoo et al. 2021</xref>), most surveillance approaches in microbial genomics rely on the analysis of short-read WGS datasets. Such datasets are generally assembled using assemblers such as Unicycler (<xref rid="btad250-B23" ref-type="bibr">Wick et al. 2017</xref>), SKESA (<xref rid="btad250-B19" ref-type="bibr">Souvorov et al. 2018</xref>), or SPAdes (<xref rid="btad250-B5" ref-type="bibr">Bankevich et al. 2012</xref>). It is typically impossible to assemble full sequences of chromosomes and plasmids using short-read WGS data, and consequently, a short-read assembly contains a mixture of contigs coming from the chromosome and individual plasmids present in the sample.</p>
    <p>The problem of detecting plasmids from a short-read assembly can be considered at three different levels: classification, binning, and assembly. At the classification level, the aim is to classify the origin of a contig, which is either a plasmid or the chromosome. Current state-of-the-art tools rely on machine-learning approaches and include mlplasmids (<xref rid="btad250-B4" ref-type="bibr">Arredondo-Alonso et al. 2018</xref>), PlasClass (<xref rid="btad250-B16" ref-type="bibr">Pellow et al. 2020</xref>), Deeplasmid (<xref rid="btad250-B1" ref-type="bibr">Andreopoulos et al. 2022</xref>), and RFPlasmid (<xref rid="btad250-B22" ref-type="bibr">van der Graaf-van Bloois et al. 2021</xref>). However, a bacterial genome can contain several plasmids, and contigs classification does not provide a precise view of the plasmid content of a genome. This is addressed by the plasmid binning problem, where the aim is to group plasmid contigs into bins, such that the contigs in a bin are likely to originate from the same plasmid. Lastly, plasmid assembly aims to order and orient contigs in a plasmid bin into a fully assembled plasmid sequence.</p>
    <p>In this work, we focus on the binning problem, motivated by the observation that, for downstream analysis, the most useful information is groups of genes belonging to a given plasmid. While the order and orientation of these genes along the plasmid sequence can yield interesting insights, important tasks such as plasmid typing can be done from the gene content without considering contigs or gene order (<xref rid="btad250-B9" ref-type="bibr">Dewar et al. 2021</xref>; <xref rid="btad250-B11" ref-type="bibr">Luo et al. 2021</xref>). Two main methodological avenues have been used in developing plasmid binning methods: reference-based and <italic toggle="yes">de-novo</italic> binning. Reference-based methods, such as MOB-recon (<xref rid="btad250-B17" ref-type="bibr">Robertson and Nash 2018</xref>), map contigs to a reference database of plasmids or plasmid gene sequences, clustered into families of plasmids. Contigs are then binned together if they match with plasmids belonging to the same reference cluster. The reliance on a reference database can potentially hinder the ability of reference-based methods to identify novel plasmids. <italic toggle="yes">De-novo</italic> binning methods, such as Recycler (<xref rid="btad250-B18" ref-type="bibr">Rozov et al. 2017</xref>), PlasmidSPAdes (<xref rid="btad250-B2" ref-type="bibr">Antipov et al. 2016</xref>), and gplas (<xref rid="btad250-B3" ref-type="bibr">Arredondo-Alonso et al. 2020</xref>), bypass the requirement of reference sequences and rely instead on contig features assumed to be specific to different plasmids present in a bacterial cell. A feature central to many plasmid binning methods is contig read coverage. Different plasmids occur in the genome isolate in varying number (sometimes hundreds) of copies. Thus, the coverage of plasmid contigs is expected to be significantly different between the plasmids and chromosomes, as well as between different plasmids. Another feature used to detect plasmids in a bacterial assembly is the GC content, which is often slightly different in plasmids, especially short ones, as compared to the chromosome (<xref rid="btad250-B14" ref-type="bibr">Nishida 2012</xref>). Recent plasmid binning methods HyAsP (<xref rid="btad250-B13" ref-type="bibr">Müller and Chauve 2019</xref>) and PlasBin (<xref rid="btad250-B12" ref-type="bibr">Mane et al. 2022</xref>) combine ideas from both reference-based and <italic toggle="yes">de-novo</italic> binning.</p>
    <p>Several methods do leverage information from the assembly graph, a graph containing contigs as nodes and possible connections between them supported by sequencing data as edges; widely used bacterial genomes assemblers such as SPAdes, Unicycler, and SKESA generate such a graph as a complement to the contigs assembly. The rationale for using the assembly graph is that individual molecules, such as chromosomes or plasmids, ideally correspond to walks in this graph. However, spurious edges and contigs encoding repeats may form densely connected graphs that are difficult to analyse. On the other hand, some edges from such walks can be missing due to low sequencing coverage of the corresponding loci. Nevertheless, our approach assumes that sequencing data is provided at sufficient sequencing depth, resulting in plasmids corresponding to connected subgraphs, often cycles or closed walks, in the assembly graph. This assumption is also central in several other plasmid binning methods. For example, Recycler (<xref rid="btad250-B18" ref-type="bibr">Rozov et al. 2017</xref>) peels off cycles from the assembly graph assuming uniform coverage of sequenced plasmids; PlasmidSPAdes (<xref rid="btad250-B2" ref-type="bibr">Antipov et al. 2016</xref>) estimates the chromosomal coverage from the whole assembly, removes contigs with similar coverage as that of the chromosome and then computes putative plasmid bins from the connected components of the remaining graph. Gplas (<xref rid="btad250-B3" ref-type="bibr">Arredondo-Alonso et al. 2020</xref>) constructs a plasmidome network by defining a set of walks in the assembly graph. Each walk is initialized with a contig i.e. classified as plasmidic using mlplasmids (<xref rid="btad250-B4" ref-type="bibr">Arredondo-Alonso et al. 2018</xref>). It uses a heuristic that extends a walk one contig at a time, based on a score that accounts for similarity between the contig read coverage and the mean coverage of the currently assembled walk. Putative plasmid bins are selected from the network using graph partitioning algorithms. HyAsP (<xref rid="btad250-B13" ref-type="bibr">Müller and Chauve 2019</xref>) uses a greedy walk-building heuristic that aims to iteratively extract walks from the assembly graph. The algorithm relies on a walk-extension objective function defined in terms of coverage consistency, Guanine-Cytosine (GC) content consistency, and high plasmid gene density (from a database of reference plasmid genes) of contigs included in the walk. PlasBin (<xref rid="btad250-B12" ref-type="bibr">Mane et al. 2022</xref>) extends the approach used in HyAsP into a Mixed Integer Linear Programming (MILP) formulation that defines plasmid bins as connected subgraphs of the assembly graph that optimize an objective function similar to the HyAsP one.</p>
    <p>In this work, we introduce a new optimization algorithm for the plasmid binning problem. The main novelty of our work is to state the problem as a network flow problem, where the flow accounts for the expected uniform coverage of the sequenced plasmid, while also considering the GC content and the density of reference plasmid genes in a plasmid bin. Our work improves upon PlasBin in several ways, including a method for scoring GC content based on a probabilistic model. We compare our method PlasBin-flow against PlasBin, HyAsP, plasmidSPAdes, MOB-recon, and gplas on a dataset of 133 bacterial samples.</p>
  </sec>
  <sec>
    <title>2 Method</title>
    <p>Here we present PlasBin-flow, a network flow-based MILP formulation for the plasmid binning problem. It extracts putative plasmid bins as connected components of uniform coverage from an assembly graph. PlasBin-flow is a hybrid method that relies on a reference database of closed genome assemblies including plasmids.</p>
    <sec>
      <title>2.1 Input: Contigs and the assembly graph</title>
      <p>The input of the PlasBin-flow consists of the contigs and the assembly graph from a short-read assembly of a bacterial isolate. In this work, we use Unicycler (<xref rid="btad250-B23" ref-type="bibr">Wick et al. 2017</xref>) to generate the assembly, but any other assembler that provides an assembly graph (such as PlasmidSPAdes (<xref rid="btad250-B2" ref-type="bibr">Antipov et al. 2016</xref>) or SKESA (<xref rid="btad250-B19" ref-type="bibr">Souvorov et al. 2018</xref>)) can be used, as PlasBin-flow does not depend on a specific assembler.</p>
      <p>The set of all contigs in the short-read assembly is denoted by <italic toggle="yes">C</italic>. Every contig <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula> has two extremeties: head <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and tail <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Pairs of contigs potentially adjacent in the genome sequence are connected via edges of the assembly graph, each edge linking two specific contig extremities. We denote the set of edges in the assembly graph by <italic toggle="yes">E</italic>. Each undirected edge <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:math></inline-formula> connects two extremities <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (<inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> being either a head or a tail of contigs <italic toggle="yes">c</italic> and <italic toggle="yes">d</italic>, respectively) and is represented as an unordered pair <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>The PlasBin-flow input also contains a reference database of plasmid genes. In a practical application, the reference database would contain all known plasmid genes; however, since an exact match to the reference database would indicate a strong determination of the contig origin, we have taken care in our experiments to withdraw information from samples used for testing from the database used (see Section 3.1 for further description).</p>
      <sec>
        <title>2.1.1 Contig features</title>
        <p>PlasBin-flow considers several features associated to a contig <italic toggle="yes">c</italic>, namely its GC content <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, length <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, sequencing coverage <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and plasmid gene density <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. The sequencing coverage is the normalized coverage provided by Unicycler for each contig, i.e. the average base coverage of the contig normalized by the median coverage of the contigs in the whole assembly; chromosomal contigs are thus expected to have a normalized coverage close to 1. To obtain the plasmid gene density, we map each contig against the reference database of plasmid genes using blastn (version 2.6.0) (<xref rid="btad250-B6" ref-type="bibr">Camacho et al. 2009</xref>), discarding any match with identity below 95% or a match that covers ˂95% of a gene. The plasmid gene density <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the fraction of the sequence length of contig <italic toggle="yes">c</italic> covered by these matches.</p>
        <p>Contigs passing certain thresholds related to length and gene density are referred to as seed contigs. These contigs are more likely to be part of a plasmid than others. We describe how to determine corresponding thresholds using the reference database in Section 2.4. The set of all seed contigs is denoted as <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and we also use a boolean feature <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
    </sec>
    <sec>
      <title>2.2 PlasBin-flow overview</title>
      <p>PlasBin-flow works iteratively, identifying one plasmid bin in each iteration by solving a MILP, described in Section 2.3. In each iteration, the identified bin is required to contain at least one seed contig. After each iteration, PlasBin-flow updates the assembly graph (contigs, edges, and contig read coverage) to account for the removal of the plasmid bin. The modified assembly graph is then used as input for the next iteration. This process is repeated until the modified assembly graph does not contain any seed contig.</p>
      <p>PlasBin-flow defines a plasmid bin as a connected subgraph of a network defined from the assembly graph, while enforcing that this subgraph contains at least one seed contig and assigning to this subgraph (i) a flow value defined in terms of the coverage of contigs it contains, that serves as a proxy for the copy number of the plasmid (bin) defined by the subgraph and (ii) a GC content value. This subgraph is chosen as the one optimizing an objective function defined as a linear combination of several terms: (i) the flow value, (ii) a GC content term penalizing contigs whose GC content does not agree with the GC content assigned to the subgraph, and (iii) a plasmid gene density term penalizing contigs with a low plasmid gene density. An important and novel feature of PlasBin-flow is that it assigns a multiplicity to each contig in a plasmid bin, with repeated contigs having multiplicity ˃1.</p>
      <p>The GC content assigned to a solution is defined as a discrete category, each of the <italic toggle="yes">k</italic> categories corresponding to a GC content interval. This set <italic toggle="yes">K</italic> of <italic toggle="yes">k</italic> intervals is pre-defined through a preliminary analysis of the reference database. For each contig <italic toggle="yes">c</italic> and each GC content interval <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>, we pre-compute a GC content penalty <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:mi>c</mml:mi><mml:mo>_</mml:mo><mml:mi>p</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> defined in terms of the likelihood that a sequence of length <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and GC content <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> would be observed in a plasmid whose GC content is in interval <italic toggle="yes">b</italic>. We provide a detailed description of <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:mi>c</mml:mi><mml:mo>_</mml:mo><mml:mi>p</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> in Section 2.5.</p>
    </sec>
    <sec>
      <title>2.3 MILP formulation</title>
      <sec>
        <title>2.3.1 Network and flow</title>
        <p>The MILP implemented in PlasBin-flow takes as an input network <italic toggle="yes">N</italic> obtained by modifying the original assembly graph. Using contigs <italic toggle="yes">C</italic> and edges <italic toggle="yes">E</italic> in the undirected assembly graph, we define a directed network <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo>∪</mml:mo><mml:msup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The new set of nodes is composed of <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, the set of all contig extremities and <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, the source and sink nodes of the network. The new set of edges is composed of two subsets, <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>. Set <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is obtained by (i) doubling each edge <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>}</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:math></inline-formula> into two directed edges <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, (ii) adding edges <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for every seed contig <italic toggle="yes">c</italic> and (iii) adding edge <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for every contig <italic toggle="yes">d</italic> (regardless of its seed status). Set <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is composed of directed edges that connect extremities within each contig, i.e. for each contig <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> contains edges <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>The choice of the subgraph, whose contigs will form a plasmid bin, is guided by a flow through the network. Expanding the set of undirected edges <italic toggle="yes">E</italic> to the set of directed edges <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is necessary to allow the flow to account for the orientation of contigs in the flow computed by the MILP. Moreover, every edge <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> has a capacity <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mi>a</mml:mi><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:mi>r</mml:mi><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>r</mml:mi><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>d</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> that provides an upper-bound to the total amount of flow that can go through <italic toggle="yes">e</italic>, while if <italic toggle="yes">e</italic> links a contig extremity <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to the source <italic toggle="yes">s</italic> or sink <italic toggle="yes">t</italic>, its capacity is <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. We define a flow as a map <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mi>f</mml:mi><mml:mo>:</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo>→</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow></mml:math></inline-formula> that satisfies the following constraints:</p>
        <list list-type="bullet">
          <list-item>
            <p>Source and sink constraints<italic toggle="yes">.</italic> Exactly one edge outgoing from <italic toggle="yes">s</italic> and incoming to <italic toggle="yes">t</italic> has a non-zero flow value.</p>
          </list-item>
          <list-item>
            <p>Capacity constraints for edges: The flow through an edge cannot exceed its capacity.</p>
          </list-item>
          <list-item>
            <p>Conservation constraints: The cumulative flow into a contig extremity (sum of the flow of the edges from <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> into this contig extremity) should be equal to the cumulative flow out of the other extremity of the same contig (sum of the flow of the edges from <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> out of this contig extremity).</p>
          </list-item>
          <list-item>
            <p>Capacity constraints for nodes: The cumulative flow into and out of a contig extremity cannot exceed the read coverage of the contig.</p>
          </list-item>
        </list>
        <p>The value of the flow <italic toggle="yes">F</italic> is thus equal to the quantity flowing out of <italic toggle="yes">s</italic>. By the conservation constraints, this is also equal to the quantity flowing into <italic toggle="yes">t</italic>. The flow value can be considered as a proxy for the copy number of the plasmid represented by the bin defined by the subgraph induced by the non-zero flow edges. A contig from this subgraph can represent a sequence that has been repeated in the plasmid. To account for such instances, the flow through a contig can be higher than the overall flow <italic toggle="yes">F</italic>. However, this does not imply that the flow through a contig will be an integer multiple of <italic toggle="yes">F</italic>.</p>
      </sec>
      <sec>
        <title>2.3.2 Decision variables</title>
        <p>The MILP decision variables define a solution to the optimal plasmid bin problem, composed of a subgraph of <italic toggle="yes">N</italic>, GC content value associated to it and a flow value. To each element of <italic toggle="yes">N</italic>, we wish to associate a decision binary variable to indicate whether it is part of the solution subgraph <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> associated with a plasmid bin <italic toggle="yes">p</italic>. <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is defined by a set of edges from <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, a set of contig extremities from <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> and a set contig edges from <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>. If an extremity <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (resp.<inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) belongs to <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, so should the other extremity <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (resp. <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>). Additionally, at least one internal edge <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> has to be selected to facilitate the flow within contig <italic toggle="yes">c</italic>. Thus, instead of having a variable each associated with extremities <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> as well as internal edges <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, it suffices to have a variable <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> associated with contig <italic toggle="yes">c</italic>. Thus, <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> will mean that both extremities of <italic toggle="yes">c</italic> and at least one internal edge of <italic toggle="yes">c</italic> will be part of <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. We also associate binary decision variables to each edge <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, denoted respectively <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, indicating whether it is a part of the solution subgraph <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. We call the edges and contigs included in the solution active.</p>
        <p>We associate to every edge <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> a continuous decision variable <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> that encodes the quantity <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> flowing through the edge. The overall flow value (flowing out of the source <italic toggle="yes">s</italic> and into the sink <italic toggle="yes">t</italic>) is encoded by a continuous decision variable <italic toggle="yes">F</italic>. The flow <italic toggle="yes">F</italic> also helps in determining the multiplicity for each contig in the plasmid bin defined by a solution. Let <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> be the set of edges incoming into extremity <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi><mml:mo>−</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> be the set of edges outgoing from <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. The multiplicity of a contig <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> in the plasmid bin is related to the flow value as <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi><mml:mo>+</mml:mo></mml:msubsup><mml:mo>∪</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>/</mml:mo><mml:mi>F</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
        <p>The GC content of the solution subgraph is chosen as one of the <italic toggle="yes">k</italic> pre-defined intervals and is encoded by binary decision variables: for every pre-defined GC content interval <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>, the decision variable <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is assigned value 1 if <italic toggle="yes">b</italic> is the chosen GC content interval and 0 otherwise.</p>
        <p>The total number of decision variables defining a solution to the plasmid bin finding problem (subgraph, associated flow, and GC content) is thus <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>C</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>K</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Note that the subgraph of <italic toggle="yes">N</italic> defined as above may not be connected. However, we aim to define a plasmid bin by a connected subgraph. We describe later how we handle this problem through delayed constraints generation.</p>
      </sec>
      <sec>
        <title>2.3.3 Objective function</title>
        <p>We formulate the MILP as a maximization problem with objective function <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:mi>F</mml:mi><mml:mo>+</mml:mo><mml:mi>G</mml:mi><mml:mi>C</mml:mi><mml:mo>+</mml:mo><mml:mi>G</mml:mi><mml:mi>D</mml:mi></mml:mrow></mml:math></inline-formula>. Here, <italic toggle="yes">F</italic> represents the overall flow value from <italic toggle="yes">s</italic> to <italic toggle="yes">t</italic>, <italic toggle="yes">GC</italic> is a penalty for active contigs whose GC content differs significantly from the overall bin GC content and <italic toggle="yes">GD</italic> is a term penalizing inclusion of contigs with low plasmid gene density and rewarding contigs with a high gene density. In particular,
and
</p>
        <disp-formula id="E1">
          <mml:math id="M1" display="block" overflow="scroll">
            <mml:mrow>
              <mml:mi>G</mml:mi>
              <mml:mi>C</mml:mi>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>c</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi>C</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>b</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi>K</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mo>−</mml:mo>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>g</mml:mi>
              <mml:mi>c</mml:mi>
              <mml:mo>_</mml:mo>
              <mml:mi>p</mml:mi>
              <mml:mi>e</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>n</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>c</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>⋅</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mi>c</mml:mi>
              </mml:msub>
              <mml:mo>⋅</mml:mo>
              <mml:mi>G</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>C</mml:mi>
                </mml:mrow>
                <mml:mi>b</mml:mi>
              </mml:msub>
              <mml:mo>,</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <disp-formula id="E2">
          <mml:math id="M2" display="block" overflow="scroll">
            <mml:mrow>
              <mml:mi>G</mml:mi>
              <mml:mi>D</mml:mi>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>c</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi>C</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mrow>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>g</mml:mi>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>d</mml:mi>
                  </mml:mrow>
                  <mml:mi>c</mml:mi>
                </mml:msub>
                <mml:mo>−</mml:mo>
                <mml:mn>0.5</mml:mn>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
              <mml:mo>⋅</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mi>c</mml:mi>
              </mml:msub>
              <mml:mo>.</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p>Note that the term <italic toggle="yes">GC</italic> is not linear as it involves the product of two binary decision variables. Such a product can be linearized by addition of a single auxiliary binary decision variable and three associated linear constraints (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Material Section S1</xref>). The gene density in the objective function is used in a similar manner as probability. Thus, the MILP is discouraged from choosing contigs with gene density ˂0.5 as part of the solution.</p>
        <p>The rationale for this objective function is as follows: by maximizing the flow value <italic toggle="yes">F</italic>, we aim to identify a high copy-number plasmid i.e. more likely to be reliable. The two penalty terms aim to assign to the plasmid bin a GC content that reflects the GC content of the selected contigs (we refer to Section 2.5 for a more detailed discussion) and prefer contigs that have a higher plasmid genes density and are thus more likely to originate from actual plasmids. Our approach that seeks a plasmid bin through optimization improves upon greedy heuristics (such as HyAsP) in that it will include contigs that impact negatively the objective function if this inclusion allows to connect to other contigs whose positive contribution to the objective function will be beneficial overall. In contrast, HyAsP, being based on a greedy walk extension approach, may stop a walk extension simply because all neighboring contigs have a negative impact on the objective function. Advantage of the optimization approach over this greedy heuristic is illustrated by the results shown in Section 3.3, <xref rid="btad250-T1" ref-type="table">Tables 1</xref> and <xref rid="btad250-T2" ref-type="table">2</xref>.</p>
        <table-wrap position="float" id="btad250-T1">
          <label>Table 1.</label>
          <caption>
            <p>Comparison of tool accuracy on 41 bacterial isolates.<xref rid="tblfn1" ref-type="table-fn"><sup>a</sup></xref></p>
          </caption>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col valign="top" align="left" span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th rowspan="1" colspan="1"/>
                <th colspan="3" rowspan="1">Basepair level</th>
                <th colspan="3" rowspan="1">Contig level</th>
              </tr>
              <tr>
                <th rowspan="1" colspan="1"/>
                <th colspan="3" rowspan="1">(weighted)<hr/></th>
                <th colspan="3" rowspan="1">(unweighted)<hr/></th>
              </tr>
              <tr>
                <th rowspan="1" colspan="1">Tool</th>
                <th rowspan="1" colspan="1">Precision</th>
                <th rowspan="1" colspan="1">Recall</th>
                <th rowspan="1" colspan="1">F1</th>
                <th rowspan="1" colspan="1">Precision</th>
                <th rowspan="1" colspan="1">Recall</th>
                <th rowspan="1" colspan="1">F1</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">PlasBin-flow</td>
                <td rowspan="1" colspan="1">0.75</td>
                <td rowspan="1" colspan="1">0.71</td>
                <td rowspan="1" colspan="1">0.67</td>
                <td rowspan="1" colspan="1">0.79</td>
                <td rowspan="1" colspan="1">0.63</td>
                <td rowspan="1" colspan="1">0.64</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">PlasBin</td>
                <td rowspan="1" colspan="1">0.59</td>
                <td rowspan="1" colspan="1">0.57</td>
                <td rowspan="1" colspan="1">0.55</td>
                <td rowspan="1" colspan="1">0.59</td>
                <td rowspan="1" colspan="1">0.56</td>
                <td rowspan="1" colspan="1">0.54</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">HyAsP</td>
                <td rowspan="1" colspan="1">0.74</td>
                <td rowspan="1" colspan="1">0.48</td>
                <td rowspan="1" colspan="1">0.55</td>
                <td rowspan="1" colspan="1">0.74</td>
                <td rowspan="1" colspan="1">0.40</td>
                <td rowspan="1" colspan="1">0.48</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">plasmidSPAdes</td>
                <td rowspan="1" colspan="1">0.54</td>
                <td rowspan="1" colspan="1">0.68</td>
                <td rowspan="1" colspan="1">0.54</td>
                <td rowspan="1" colspan="1">0.47</td>
                <td rowspan="1" colspan="1">0.70</td>
                <td rowspan="1" colspan="1">0.50</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">MOB-recon</td>
                <td rowspan="1" colspan="1">0.83</td>
                <td rowspan="1" colspan="1">
                  <bold>0.91</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>0.85</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>0.81</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>0.83</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>0.81</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">gplas</td>
                <td rowspan="1" colspan="1">
                  <bold>0.84</bold>
                </td>
                <td rowspan="1" colspan="1">0.74</td>
                <td rowspan="1" colspan="1">0.76</td>
                <td rowspan="1" colspan="1">0.79</td>
                <td rowspan="1" colspan="1">0.58</td>
                <td rowspan="1" colspan="1">0.64</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <fn id="tblfn1">
              <label>a</label>
              <p>The table shows the mean values of precision, recall, and F1 statistics, considering only contigs of length at least 1000 bp, over 41 testing samples from <italic toggle="yes">E. coli</italic>, <italic toggle="yes">E. faecium</italic>, and <italic toggle="yes">K. pneumoniae</italic>, the species supported by gplas.</p>
            </fn>
            <fn id="tblfn2">
              <p>Bold values indicate the highest values in the respective columns.</p>
            </fn>
          </table-wrap-foot>
        </table-wrap>
        <table-wrap position="float" id="btad250-T2">
          <label>Table 2.</label>
          <caption>
            <p>Comparison of tool accuracy on 25 bacterial isolates.<xref rid="tblfn2" ref-type="table-fn"><sup>a</sup></xref></p>
          </caption>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col valign="top" align="left" span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th rowspan="1" colspan="1"/>
                <th colspan="3" rowspan="1">Basepair level</th>
                <th colspan="3" rowspan="1">Contig level</th>
              </tr>
              <tr>
                <th rowspan="1" colspan="1"/>
                <th colspan="3" rowspan="1">(weighted)<hr/></th>
                <th colspan="3" rowspan="1">(unweighted)<hr/></th>
              </tr>
              <tr>
                <th rowspan="1" colspan="1">Tool</th>
                <th rowspan="1" colspan="1">Precision</th>
                <th rowspan="1" colspan="1">Recall</th>
                <th rowspan="1" colspan="1">F1</th>
                <th rowspan="1" colspan="1">Precision</th>
                <th rowspan="1" colspan="1">Recall</th>
                <th rowspan="1" colspan="1">F1</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">PlasBin-flow</td>
                <td rowspan="1" colspan="1">
                  <bold>0.98</bold>
                </td>
                <td rowspan="1" colspan="1">0.90</td>
                <td rowspan="1" colspan="1">
                  <bold>0.93</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>0.96</bold>
                </td>
                <td rowspan="1" colspan="1">0.66</td>
                <td rowspan="1" colspan="1">
                  <bold>0.76</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">PlasBin</td>
                <td rowspan="1" colspan="1">0.72</td>
                <td rowspan="1" colspan="1">0.57</td>
                <td rowspan="1" colspan="1">0.57</td>
                <td rowspan="1" colspan="1">0.64</td>
                <td rowspan="1" colspan="1">0.58</td>
                <td rowspan="1" colspan="1">0.58</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">HyAsP</td>
                <td rowspan="1" colspan="1">0.96</td>
                <td rowspan="1" colspan="1">0.85</td>
                <td rowspan="1" colspan="1">0.89</td>
                <td rowspan="1" colspan="1">0.90</td>
                <td rowspan="1" colspan="1">
                  <bold>0.70</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>0.76</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">plasmidSPAdes</td>
                <td rowspan="1" colspan="1">0.47</td>
                <td rowspan="1" colspan="1">0.61</td>
                <td rowspan="1" colspan="1">0.49</td>
                <td rowspan="1" colspan="1">0.35</td>
                <td rowspan="1" colspan="1">0.54</td>
                <td rowspan="1" colspan="1">0.34</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">MOB-recon</td>
                <td rowspan="1" colspan="1">0.92</td>
                <td rowspan="1" colspan="1">
                  <bold>0.97</bold>
                </td>
                <td rowspan="1" colspan="1">0.91</td>
                <td rowspan="1" colspan="1">0.94</td>
                <td rowspan="1" colspan="1">
                  <bold>0.70</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>0.76</bold>
                </td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <fn id="tblfn3">
              <label>a</label>
              <p>The table shows mean values of precision, recall, and F1 statistics for the remaining 25 testing samples from species not supported by gplas.</p>
            </fn>
            <fn id="tblfn4">
              <p>Bold values indicate the highest values in the respective columns.</p>
            </fn>
          </table-wrap-foot>
        </table-wrap>
      </sec>
      <sec>
        <title>2.3.4 Constraints</title>
        <p>We now describe the constraints used in the formulation:</p>
        <list list-type="order">
          <list-item>
            <p>Exactly one edge out of <italic toggle="yes">s</italic> is part of the solution:
<disp-formula id="E3"><mml:math id="M3" display="block" overflow="scroll"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi>h</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1.</mml:mn></mml:mrow></mml:math></disp-formula></p>
            <p>This also ensures that every solution contains at least one seed contig.</p>
          </list-item>
          <list-item>
            <p>The flow through an edge <italic toggle="yes">e</italic> is non-zero only if <italic toggle="yes">e</italic> was selected in the solution subgraph and cannot exceed its capacity:
<disp-formula id="E4"><mml:math id="M4" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>a</mml:mi><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
          </list-item>
          <list-item>
            <p>For any contig <italic toggle="yes">c</italic>, the cumulative flow through <italic toggle="yes">c</italic> cannot exceed its read coverage:
<disp-formula id="E5"><mml:math id="M5" display="block" overflow="scroll"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi><mml:mo>+</mml:mo></mml:msubsup><mml:mo>∪</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>≤</mml:mo><mml:mi>r</mml:mi><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
          </list-item>
          <list-item>
            <p>For any contig <italic toggle="yes">c</italic>, the cumulative flow into <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> should be equal to the cumulative flow out of <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and conversely:
<disp-formula id="E6"><mml:math id="M6" display="block" overflow="scroll"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msubsup></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo></mml:msubsup></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
          </list-item>
          <list-item>
            <p>Flow value <italic toggle="yes">F</italic> should be equal to the flow out of <italic toggle="yes">s</italic> and into <italic toggle="yes">t</italic>:
<disp-formula id="E7"><mml:math id="M7" display="block" overflow="scroll"><mml:mrow><mml:mi>F</mml:mi><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>F</mml:mi><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula></p>
          </list-item>
          <list-item>
            <p>If an edge <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi>h</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> is in the solution (<inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>), then the contigs <italic toggle="yes">c</italic> and <italic toggle="yes">d</italic> should also be in the solution. Note that the converse need not be true. In other words, contigs <italic toggle="yes">c</italic> and <italic toggle="yes">d</italic> may be part of the solution due to other edges. In that case, <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> should be 0. To implement this, we use the following constraints:
<disp-formula id="E8"><mml:math id="M8" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>d</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></disp-formula></p>
          </list-item>
          <list-item>
            <p>A contig <italic toggle="yes">c</italic> is active (selected in the solution) if and only if at least one edge incident to one of its extremities is active.
<disp-formula id="E9"><mml:math id="M9" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi><mml:mo>+</mml:mo></mml:msubsup><mml:mo>∪</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></disp-formula></p>
          </list-item>
          <list-item>
            <p>Each active edge has flow at least <italic toggle="yes">F</italic>. To implement this condition, we introduce an auxiliary variable <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><disp-formula id="E10"><mml:math id="M10" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>F</mml:mi><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
            <p>We further add the constraint:
<disp-formula id="E11"><mml:math id="M11" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math></disp-formula></p>
          </list-item>
        </list>
        <p>Thus, if there is no flow through edge <italic toggle="yes">e</italic>, <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is forced to be 0 and in turn <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. To handle the fact that <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the product of a binary variable and a continuous variable, we use the same approach as for the <italic toggle="yes">GC</italic> term of the objective function.</p>
      </sec>
      <sec>
        <title>2.3.5 Ensuring connectivity</title>
        <p>A solution that satisfies the above constraints may not be connected. It will contain a connected component with <italic toggle="yes">s</italic> and <italic toggle="yes">t</italic>, but may also contain other components disconnected from <italic toggle="yes">s</italic> and <italic toggle="yes">t</italic>. Such disconnected components have a closed flow circulating within the component without violating any of the initial constraints.</p>
        <p>If the proposed solution contains disconnected components, we mute the edges in the disconnected component. For each edge <italic toggle="yes">e</italic> in the disconnected component, we add a constraint <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and run the MILP again. This process is repeated until the MILP returns a solution with a single component connected to <italic toggle="yes">s</italic> and <italic toggle="yes">t</italic>. While in theory, this delayed constraint generation process could involve a large number of iterations, in practice we observe that it requires a small number of iterations. It is possible that this process may force the MILP to overlook solutions containing some of the muted edges even if the solutions have a greater flow. We discuss more effective ways to handle disconnected components in Section 4.</p>
      </sec>
    </sec>
    <sec>
      <title>2.4 Determining seeds</title>
      <p>Similarly to HyAsP and PlasBin, PlasBin-flow enforces that every plasmid bin contains at least one seed contig under the assumption that such contigs were identified as likely to belong to a plasmid due to their sequence features (length and plasmid gene density). We used the reference database for which closed assemblies with annotated plasmids were available, to obtain the thresholds determining seed contigs. Using Unicycler, we assembled the reads datasets for each sample in the reference database. We explored a grid of pairs of values <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, respectively, for the contig length and plasmid gene density, with <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula> ranging from 50 to 5000 bp in increments of 50 and <italic toggle="yes">gd</italic> ranging from 0.01 to 1 in increments of 0.01. For each pair <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> we considered as a seed every contig <italic toggle="yes">c</italic> such that <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mi>g</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>; then mapping the contigs onto the closed assemblies of the reference dataset, for which plasmids are known, we counted (i) the number <italic toggle="yes">SP</italic> of plasmids onto which at least one seed contig was mapped to (seeded plasmids), and (ii) the number <italic toggle="yes">NPS</italic> of seed contigs that mapped to the chromosome (non-plasmid seeds). We then determined the pair of thresholds that maximized the expression <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mi>P</mml:mi><mml:mo>−</mml:mo><mml:mi mathvariant="italic">NPS</mml:mi></mml:mrow></mml:math></inline-formula> and used them as thresholds defining seed contigs in our experiments. The pair of thresholds thus obtained was <inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2650</mml:mn><mml:mo>,</mml:mo><mml:mn>0.58</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>2.5 Determining GC content intervals and penalties</title>
      <p>For each contig <italic toggle="yes">c</italic>, we associate a penalty relating the observed GC content of <italic toggle="yes">c</italic> to the GC content interval <inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula> associated to a solution to the MILP. This penalty is based on a probabilistic model in which we can compute the likelihood that a contig of a particular length and GC content will belong to a plasmid whose GC content is in a particular interval <italic toggle="yes">b</italic>. In this section, we first define the model and describe how we define the GC content penalty term. Subsequently, we describe the set of intervals <italic toggle="yes">K</italic> used in our experiments.</p>
      <sec>
        <title>2.5.1 Probabilistic model</title>
        <p>If a given contig <italic toggle="yes">c</italic> of length <inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula> has GC content <inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we model the observed number <italic toggle="yes">n</italic> of GC nucleotides within this contig by the binomial distribution with parameters <italic toggle="yes">x</italic> and <inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula>. However, GC content within a plasmid may fluctuate for various biological reasons, and therefore we model contig-level GC content <italic toggle="yes">x</italic> as a random variable sampled from a beta distribution with parameters <inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo>=</mml:mo><mml:mi>p</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the true GC content of the whole plasmid and <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> is a fixed parameter. This results in <italic toggle="yes">n</italic> being sampled from the beta-binomial distribution with parameters <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula>, <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula> and <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mo>β</mml:mo></mml:math></inline-formula>; namely, <inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>|</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>ℓ</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>n</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mo>α</mml:mo><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mo>β</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>α</mml:mo><mml:mo>,</mml:mo><mml:mo>β</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> where <italic toggle="yes">B</italic> is the beta function. Values <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula> and <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mo>β</mml:mo></mml:math></inline-formula> represent pseudocounts added to the observed counts of GC and non-GC nucleotides, respectively. We use <inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula> for the overall pseudocount.</p>
        <p>In our scenario, <italic toggle="yes">p</italic> is an unknown value coming from GC content interval <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, and we assume a uniform prior on <italic toggle="yes">p</italic>. The overall probability of <italic toggle="yes">b</italic> being the true source interval for observed count <italic toggle="yes">n</italic> is thus <inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mi>P</mml:mi></mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>|</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>|</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∝</mml:mo><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>|</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is obtained by the Bayes theorem. We normalize these probabilities over all intervals in <italic toggle="yes">K</italic> to obtain the likelihood <inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:mi>c</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">pro</mml:mi><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> that contig <italic toggle="yes">c</italic> originates from a molecule with GC content in interval <italic toggle="yes">b</italic>.</p>
      </sec>
      <sec>
        <title>2.5.2 Penalty term</title>
        <p>For contig <italic toggle="yes">c</italic> and interval <italic toggle="yes">b</italic>, the MILP uses penalty <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:mi>c</mml:mi><mml:mo>_</mml:mo><mml:mi>p</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, which is incurred if <italic toggle="yes">c</italic> is part of a plasmid whose GC content belongs to <italic toggle="yes">b</italic>. This penalty is computed as
</p>
        <disp-formula id="E12">
          <mml:math id="M12" display="block" overflow="scroll">
            <mml:mrow>
              <mml:mi>g</mml:mi>
              <mml:mi>c</mml:mi>
              <mml:mo>_</mml:mo>
              <mml:mi>p</mml:mi>
              <mml:mi>e</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>n</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>c</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mi>max</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>b</mml:mi>
                    </mml:mrow>
                    <mml:mo>′</mml:mo>
                  </mml:msup>
                  <mml:mo>∈</mml:mo>
                  <mml:mi>K</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mo>{</mml:mo>
              <mml:mi>g</mml:mi>
              <mml:mi>c</mml:mi>
              <mml:mo>_</mml:mo>
              <mml:mi mathvariant="italic">pro</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>c</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>b</mml:mi>
                    </mml:mrow>
                    <mml:mo>′</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:msub>
              <mml:mo>}</mml:mo>
              <mml:mo>−</mml:mo>
              <mml:mi>g</mml:mi>
              <mml:mi>c</mml:mi>
              <mml:mo>_</mml:mo>
              <mml:mi mathvariant="italic">pro</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>c</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>.</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p>The penalty is thus zero for the interval <italic toggle="yes">b</italic> where the likelihood of <italic toggle="yes">c</italic> achieves maximum. The penalty increases with the gap between the proposed GC content interval <italic toggle="yes">b</italic> and the most likely interval for contig <italic toggle="yes">c</italic>. For very short contigs, probabilities of different GC content intervals are closer to each other, and thus the resulting penalties are smaller compared to longer contigs.</p>
      </sec>
      <sec>
        <title>2.5.3 Pre-defining GC content intervals</title>
        <p>The GC content intervals considered were pre-determined prior to running experiments based on an analysis of the reference dataset. The GC content of most plasmids and chromosomes in the reference dataset was observed to be between 0.4 and 0.6. The interval [0.4, 0.6] was subdivided into 4 equal intervals resulting in <inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:math></inline-formula> intervals <inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0.4</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0.4</mml:mn><mml:mo>,</mml:mo><mml:mn>0.45</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0.45</mml:mn><mml:mo>,</mml:mo><mml:mn>0.5</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0.5</mml:mn><mml:mo>,</mml:mo><mml:mn>0.55</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0.55</mml:mn><mml:mo>,</mml:mo><mml:mn>0.6</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0.6</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>3 Experimental results</title>
    <sec>
      <title>3.1 Datasets and tools</title>
      <p>We evaluated the following methods: our new tool PlasBin-flow, HyAsP (<xref rid="btad250-B13" ref-type="bibr">Müller and Chauve 2019</xref>), MOB-recon (<xref rid="btad250-B17" ref-type="bibr">Robertson and Nash 2018</xref>), plasmidSPAdes (<xref rid="btad250-B2" ref-type="bibr">Antipov et al. 2016</xref>), and gplas (<xref rid="btad250-B3" ref-type="bibr">Arredondo-Alonso et al. 2020</xref>). PlasmidSPAdes and gplas are <italic toggle="yes">de-novo</italic> binning methods, while MOB-recon, HyASP, and PlasBin-flow rely on a reference database of plasmid genes.</p>
      <p>Our dataset consists of 133 bacterial genomes and 377 plasmids from a collection of real bacterial isolates with closed genome assemblies compiled by <xref rid="btad250-B17" ref-type="bibr">Robertson and Nash (2018)</xref>. To simulate the use of a realistic reference database, we split our data into a reference set and a test set; the samples released before 19 December 2015 were used to build the reference database and those released after that date formed the test set. The reference set consists of 67 bacterial isolates with 230 plasmids containing 10 685 plasmid genes.</p>
      <p>The remaining test set consists of 66 samples with 147 plasmids. For the test set, Illumina sequencing data was re-assembled using Unicycler to provide contigs and assembly graphs, except in case of plasmidSPAdes. PlasmidSPAdes takes raw reads as input and constructs its own assembly graph using the SPAdes assembler. Gplas requires the use of mlplasmids (<xref rid="btad250-B4" ref-type="bibr">Arredondo-Alonso et al. 2018</xref>) to compute the probability of contigs to originate from a plasmid. Since mlplasmids is a species-specific tool, it currently supports only four species, three of which feature in our test dataset (<italic toggle="yes">Escherichia coli</italic>, <italic toggle="yes">Enterococcus faecium</italic>, and <italic toggle="yes">Klebsiella pneumoniae</italic>). From the test dataset, 41 samples with 88 plasmids belong to these three species.</p>
    </sec>
    <sec>
      <title>3.2 Evaluation metrics</title>
      <p>To evaluate predictions of individual tools on a particular testing sample, we need to compare them to the ground truth determined from annotated finished assembly of the sample as given by Robertson and Nash (<xref rid="btad250-B17" ref-type="bibr">2018</xref>). We consider two sets of measures: weighted or base-pair level statistics, which consider accuracy of bin predictions weighted by the lengths of individual contigs (effectively counting how many base pairs were involved in correct predictions), and unweighted or contig-level statistics, which only consider accuracy of predictions for individual contigs, disregarding contig lengths.</p>
      <p>Each short-read contig in the isolate assembly is mapped against the plasmids from the corresponding finished assembly (ground truth) using BLAST+ (<xref rid="btad250-B6" ref-type="bibr">Camacho et al. 2009</xref>). Matches that span ˂95% of the contig length are discarded. Thus for each bin <italic toggle="yes">u</italic> predicted by a particular tool, we have a set of contigs <inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> included in the bin <italic toggle="yes">u</italic>, and for each ground-truth plasmid <italic toggle="yes">v</italic>, we have a set of contigs <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> that match (via BLAST+) to the ground-truth plasmid <italic toggle="yes">v</italic>. It should be noted that plasmidSPAdes is run on a different set of contigs than the other five methods. Thus, the sets of contigs representing the ground truth plasmids are different in case of plasmidSPAdes.</p>
      <p>For the two sets of contigs <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE124"><mml:math id="IM124" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we define <inline-formula id="IE125"><mml:math id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:mtext>overlap</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as either <inline-formula id="IE126"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> (in case of unweighted statistics) or the cumulative size in base pairs of all contigs in <inline-formula id="IE127"><mml:math id="IM127" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (in case of weighted statistics). Similarly, we define <inline-formula id="IE128"><mml:math id="IM128" display="inline" overflow="scroll"><mml:mrow><mml:mtext>size</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for a set of contigs <italic toggle="yes">X</italic> as either <inline-formula id="IE129"><mml:math id="IM129" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>X</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> (in case of unweighted statistics) or the cumulative size in base pairs of all contigs in <italic toggle="yes">X</italic> (in case of weighted statistics).</p>
      <p>In order to compute the precision, we assign to each predicted plasmid bin <italic toggle="yes">v</italic> one of the true plasmids <inline-formula id="IE130"><mml:math id="IM130" display="inline" overflow="scroll"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE131"><mml:math id="IM131" display="inline" overflow="scroll"><mml:mtext>overlap</mml:mtext><mml:mo>(</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>v</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:math></inline-formula> is maximized. The precision is then computed as <inline-formula id="IE132"><mml:math id="IM132" display="inline" overflow="scroll"><mml:mtext>overlap</mml:mtext><mml:mo>(</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>v</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>/</mml:mo><mml:mtext>size</mml:mtext><mml:mo>(</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>v</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:math></inline-formula>. Similarly, to compute the recall, we assign to each true plasmid <italic toggle="yes">u</italic> one of the predicted plasmid bins <inline-formula id="IE133"><mml:math id="IM133" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE134"><mml:math id="IM134" display="inline" overflow="scroll"><mml:mrow><mml:mtext>overlap</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is maximized. The recall is then computed as <inline-formula id="IE135"><mml:math id="IM135" display="inline" overflow="scroll"><mml:mrow><mml:mtext>overlap</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mtext>size</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>For a sample with a set <inline-formula id="IE136"><mml:math id="IM136" display="inline" overflow="scroll"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula> of predicted plasmid bins and <inline-formula id="IE137"><mml:math id="IM137" display="inline" overflow="scroll"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> of true plasmids, the mean precision for the sample is then computed as:
</p>
      <disp-formula id="E13">
        <mml:math id="M13" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mfrac>
              <mml:mrow>
                <mml:munder>
                  <mml:mo>∑</mml:mo>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mo>∈</mml:mo>
                    <mml:mi mathvariant="script">P</mml:mi>
                  </mml:mrow>
                </mml:munder>
                <mml:mrow>
                  <mml:mtext>overlap</mml:mtext>
                </mml:mrow>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>P</mml:mi>
                  </mml:mrow>
                  <mml:mi>v</mml:mi>
                </mml:msub>
                <mml:mo>,</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>T</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>f</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>v</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:munder>
                  <mml:mo>∑</mml:mo>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mo>∈</mml:mo>
                    <mml:mi mathvariant="script">P</mml:mi>
                  </mml:mrow>
                </mml:munder>
                <mml:mrow>
                  <mml:mtext>size</mml:mtext>
                </mml:mrow>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>P</mml:mi>
                  </mml:mrow>
                  <mml:mi>v</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
            </mml:mfrac>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>The mean recall for the sample is computed as:
</p>
      <disp-formula id="E14">
        <mml:math id="M14" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mfrac>
              <mml:mrow>
                <mml:munder>
                  <mml:mo>∑</mml:mo>
                  <mml:mrow>
                    <mml:mi>u</mml:mi>
                    <mml:mo>∈</mml:mo>
                    <mml:mi mathvariant="script">T</mml:mi>
                  </mml:mrow>
                </mml:munder>
                <mml:mrow>
                  <mml:mtext>overlap</mml:mtext>
                </mml:mrow>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>P</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>g</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>u</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>,</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>T</mml:mi>
                  </mml:mrow>
                  <mml:mi>u</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:munder>
                  <mml:mo>∑</mml:mo>
                  <mml:mrow>
                    <mml:mi>u</mml:mi>
                    <mml:mo>∈</mml:mo>
                    <mml:mi mathvariant="script">T</mml:mi>
                  </mml:mrow>
                </mml:munder>
                <mml:mrow>
                  <mml:mtext>size</mml:mtext>
                </mml:mrow>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>T</mml:mi>
                  </mml:mrow>
                  <mml:mi>u</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
            </mml:mfrac>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>The F1 measure for a sample is computed as a harmonic mean of mean precision and mean recall for that sample.</p>
    </sec>
    <sec>
      <title>3.3 Results</title>
      <p>For the set of 41 samples from species supported by gplas, we only consider contigs of length at least 1000 bp for our evaluation in order to be fair to gplas that has been evaluated with such a restriction in (<xref rid="btad250-B3" ref-type="bibr">Arredondo-Alonso et al. 2020</xref>). All contigs, irrespective of length, are considered for the evaluation of the remaining 25 samples.</p>
      <p><xref rid="btad250-T1" ref-type="table">Table 1</xref> shows both unweighted and weighted accuracy measures (mean precision, mean recall, and mean F1) for all considered tools averaged over the 41 testing samples, whereas <xref rid="btad250-F1" ref-type="fig">Figs 1</xref> and <xref rid="btad250-F2" ref-type="fig">2</xref> show the full distribution of these measures. We can observe that in the case of weighted measures, that consider only contigs of length at least 1000 bp, the accuracy of PlasBin-flow lags behind gplas as well as MOB-recon, which ranks as the best tool. PlasBin-flow show significant improvement over its HyAsP, PlasBin. and plasmidSPAdes and a comparable recall to gplas.</p>
      <fig position="float" id="btad250-F1">
        <label>Figure 1.</label>
        <caption>
          <p>Distribution of the unweighted precision, recall, and F1-score statistics for samples from three species supported by gplas.</p>
        </caption>
        <graphic xlink:href="btad250f1" position="float"/>
      </fig>
      <fig position="float" id="btad250-F2">
        <label>Figure 2.</label>
        <caption>
          <p>Distribution of the weighted precision, recall, and F1-score statistics for samples from three species supported by gplas.</p>
        </caption>
        <graphic xlink:href="btad250f2" position="float"/>
      </fig>
      <p>Unweighted (contig level) accuracy is a challenging measure, since short contigs have a higher contribution to these measures. Depending on the exact down-stream application, correct binning of shorter contigs may or may not be important. Shorter contigs are more difficult to classify and bin because corresponding sequence-based statistics have a higher variance and homology-based statistics are often non-informative. When considering unweighted accuracy measures, PlasBin-flow shows higher recall than gplas, which is especially selective in the choice of contigs. PlasmidSPAdes also shows high recall, but it suffers from many false predictions (low precision). MOB-suite performs the best overall.</p>
      <p><xref rid="btad250-T2" ref-type="table">Table 2</xref> compares both unweighted and weighted accuracy measures for the 25 testing samples that could not be analysed with gplas because they are from unsupported species. Unlike in the analysis of the first 41 samples, we consider all contigs in the evaluation as we do not evaluate gplas on these 25 samples. <xref rid="btad250-F3" ref-type="fig">Figures 3</xref> and <xref rid="btad250-F4" ref-type="fig">4</xref> show the full distribution of these measures. In the case of weighted accuracy measures, PlasBin-flow shows the best accuracy, but in terms of recall where it ranks second-best behind MOB-recon but shows a better combined F1 accuracy. A similar trend is observed for unweighted accuracy measures.</p>
      <fig position="float" id="btad250-F3">
        <label>Figure 3.</label>
        <caption>
          <p>Distribution of the unweighted precision, recall, and F1-score statistics for remaining 25 samples.</p>
        </caption>
        <graphic xlink:href="btad250f3" position="float"/>
      </fig>
      <fig position="float" id="btad250-F4">
        <label>Figure 4.</label>
        <caption>
          <p>Distribution of the weighted precision, recall, and F1-score statistics for remaining 25 samples.</p>
        </caption>
        <graphic xlink:href="btad250f4" position="float"/>
      </fig>
      <p>The performance of PlasBin-flow shows a marked improvement on the latter 25 samples. Compared to other methods, PlasBin-flow is able to leverage the information from the assembly graph and as a result, is able to bin short contigs with higher accuracy than other tools. Since the comparison of the 41 samples from the three species supported by gplas has only been done on contigs longer than 1000 bp (due to inability of gplas to classify shorter contigs), this illustrates that one of the main advantages of PlasBin-flow is how it handles short contigs, that are often numerous in a short-read assembly. In fact, when considering all contigs, PlasBin-flow (F1 accuracy 0.55) outperforms MOB-recon (F1 accuracy 0.45) even on the first 41 samples (refer to <xref rid="sup1" ref-type="supplementary-material">Supplementary Material Fig. S1</xref>).</p>
      <p>We provide in <xref rid="sup1" ref-type="supplementary-material">Supplementary Material Section S3</xref> additional figures that show the results of the considered tools for various thresholds of contigs minimum length.</p>
    </sec>
    <sec>
      <title>3.4 Computational footprint</title>
      <p>We ran our experiments on a standard laptop computer, with a quad-core processor and 16GB of memory. PlasBin-flow relies on an MILP, that typically requires large computing resources (time and memory), however, we could observe that PlasBin-flow has a very reasonable computational footprint. In terms of median and mean running times, the method was comparable to other methods such as HyAsP, MOB-recon, and gplas. Excluding a handful of samples that required around 2 hours of computation time, PlasBin-flow usually completed within a few minutes. Over all considered samples, PlasBin-flow had a maximum running time close to 2 h, with a memory footprint close to 6 GB (maximum 10 GB). Running time details are provided in <xref rid="btad250-T3" ref-type="table">Table 3</xref>.</p>
      <table-wrap position="float" id="btad250-T3">
        <label>Table 3.</label>
        <caption>
          <p>Running time statistics.<xref rid="tblfn3" ref-type="table-fn"><sup>a</sup></xref></p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Tool</th>
              <th rowspan="1" colspan="1">Minimum</th>
              <th rowspan="1" colspan="1">Maximum</th>
              <th rowspan="1" colspan="1">Median</th>
              <th rowspan="1" colspan="1">Mean</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">PlasBin-flow</td>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">120</td>
              <td rowspan="1" colspan="1">6</td>
              <td rowspan="1" colspan="1">6</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">PlasBin</td>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">473</td>
              <td rowspan="1" colspan="1">22</td>
              <td rowspan="1" colspan="1">117</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">HyAsP</td>
              <td rowspan="1" colspan="1">1</td>
              <td rowspan="1" colspan="1">19</td>
              <td rowspan="1" colspan="1">3</td>
              <td rowspan="1" colspan="1">4</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MOB-recon</td>
              <td rowspan="1" colspan="1">3</td>
              <td rowspan="1" colspan="1">15</td>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">8</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">gplas</td>
              <td rowspan="1" colspan="1">2</td>
              <td rowspan="1" colspan="1">12</td>
              <td rowspan="1" colspan="1">3</td>
              <td rowspan="1" colspan="1">4</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">plasmidSPAdes</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">363</td>
              <td rowspan="1" colspan="1">16</td>
              <td rowspan="1" colspan="1">43</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn5">
            <label>a</label>
            <p>Median, mean, minimum, and maximum running time (in minutes) recorded over the 66 test samples.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
  </sec>
  <sec>
    <title>4 Conclusion</title>
    <p>In this work, we presented PlasBin-flow, an MILP algorithm that uses network flows for grouping contigs into putative plasmid bins. We compared the results of PlasBin-flow against other state-of-the-art plasmid binning methods: HyAsP, plasmidSPAdes, MOB-recon, and gplas using two sets of metrics: weighted (basepair level) and unweighted (contig level). In both cases, PlasBin-flow consistently performed reasonably well in precision statistics. For samples belonging to <italic toggle="yes">E. coli</italic>, <italic toggle="yes">E. faecium</italic>, and <italic toggle="yes">K. pneumoniae</italic>, PlasBin-flow ranked behind MOB-recon and gplas in the average F1 scores. Gplas in particular had a distinct advantage over PlasBin-flow due to its use of species specific training sets. The performance of PlasBin-flow was markedly better on samples belonging to other species. PlasBin-flow was especially useful in binning contigs of short length, which are typically difficult to bin correctly.</p>
    <p>The objective function in PlasBin-flow is significantly changed from that used in PlasBin. The uniformity of %GC content along the contigs in a putative plasmid bin is achieved using a probabilistic model. The use of %GC content penalties discourages the choice of contigs disparate %GC content to be selected in the same bin. Another salient features of this method are the use of flow values as a proxy for read coverage used in a solution. The conditions necessary to maintain a consistent flow ensure the uniform read coverage in a plasmid bin without the need to explicitly compute the mean read coverage of the bin. The objective function used in our experiments assigned the same weight to the three terms it contains. This was a choice guided by a limited exploration of possible weights for each term (<xref rid="sup1" ref-type="supplementary-material">Supplementary Material Section S2</xref>). However, given the importance of the tuning dataset, e.g. to obtain the gene density of contigs, a different choice might be relevant for other datasets, that should result from exploring a grid of possible weights.</p>
    <p>In some instances, PlasBin-flow shows low recall. There are two possible explanations for low recall: misidentification and misbinning. In case of misidentification, PlasBin-flow may have failed to identify the contigs belonging to a true plasmid as part of any plasmid bin, e.g. due to the low gene density of a contig. On the other hand, misbinning occurs when a true plasmid is split into multiple bins output by PlasBin-flow. As a result, even if PlasBin-flow manages to identify relevant plasmid contigs, the recall statistics will only consider contigs placed in one of the bins, the contigs in other bins will not contribute toward recall. We further discuss splitting bins as a cause of low recall in (<xref rid="sup1" ref-type="supplementary-material">Supplementary Material Section S4</xref>).</p>
    <p>Through an exploration of the results obtained on our test dataset, we have determined that splitting of bins often occurs when groups of contigs belonging to the same plasmid are connected by a bridge of contigs with low plasmid gene densities. In future work, we will investigate possible remedies for this problem, including: (i) merging bins with similar GC content and coverage depth in post-processing; (ii) modifying the optimization function to provide positive rewards from more sources (at present, only contigs with high plasmid gene densities bring positive rewards); and (iii) building a more comprehensive database of plasmid genes. We expect such changes to further improve overall performance of PlasBin-flow.</p>
    <p>The method currently used for delayed constraint generation in the MILP may in some cases disregard the true optimal solution of the underlying optimization problem. We plan to refine the delayed constraint generation so that the added constraints would prevent flow in the disconnected components, rather than forbidding edges previously involved in disconnected components completely. This will guarantee that the optimal solution to the original optimization problem is found and may further help to prevent unnecessary bin splitting; on the other hand, such modification may require more iterations and may negatively affect the running time.</p>
    <p>It should be noted that bins generated by PlasBin-flow might not be walks. Ideally, a plasmid, or plasmid segment, should appear as a walk in the assembly graph. However PlasBin-flow computes connected subgraphs without looking explicitly for walks. The flow through the subgraph representing a bin can be seen as a proxy for a walk; however, the problem of extracting walks from a bin subgraph relates more to the actual assembly of plasmids than to the problem of binning and requires further attention.</p>
    <p>Our MILP formulation could also accommodate other contig features in its objective function such as including a probabilistic value from plasmid contig classification methods such as mlplasmids, or accounting for the presence of plasmid-specific genes (replicon genes e.g.). This avenue is among the ones we plan to explore further in order to improve the PlasBin-flow model.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad250_Supplementary_Data</label>
      <media xlink:href="btad250_supplementary_data.zip">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>PlasBin-Flow is open-source and available at <ext-link xlink:href="https://github.com/cchauve/PlasBin-flow" ext-link-type="uri">https://github.com/cchauve/PlasBin-flow</ext-link>. The database used in the experiments is also available in the same repository. The accession details for the samples as well as the output of all the methods used in the experiments can be accessed at <ext-link xlink:href="https://doi.org/10.5281/zenodo.7807303" ext-link-type="uri">https://doi.org/10.5281/zenodo.7807303</ext-link>.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This research was funded in part by the grants from (i) Slovak Research Agency VEGA [1/0538/22] (TV), and [1/0463/20] (BB), (ii) the European Union’s Horizon 2020 program under the Marie Skłodowska-Curie [grant agreement No. 872539] PANGAIA (TV, BB), and (iii) Genome Canada and the Natural Sciences and Engineering Research Council of Canada [RGPIN-03986] (CC).</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad250-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Andreopoulos</surname><given-names>WB</given-names></string-name>, <string-name><surname>Geller</surname><given-names>AM</given-names></string-name>, <string-name><surname>Lucke</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Deeplasmid: deep learning accurately separates plasmids from bacterial chromosomes</article-title>. <source>Nucleic Acids Res</source><year>2022</year>;<volume>50</volume>:<fpage>e17</fpage>–<lpage>e17</lpage>.<pub-id pub-id-type="pmid">34871418</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Antipov</surname><given-names>D</given-names></string-name>, <string-name><surname>Hartwick</surname><given-names>N</given-names></string-name>, <string-name><surname>Shen</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>plasmidSPAdes: assembling plasmids from whole genome sequencing data</article-title>. <source>Bioinformatics</source><year>2016</year>;<volume>32</volume>:<fpage>3380</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">27466620</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Arredondo-Alonso</surname><given-names>S</given-names></string-name>, <string-name><surname>Bootsma</surname><given-names>M</given-names></string-name>, <string-name><surname>Hein</surname><given-names>Y</given-names></string-name></person-group><etal>et al</etal><article-title>gplas: a comprehensive tool for plasmid analysis using short-read graphs</article-title>. <source>Bioinformatics</source><year>2020</year>;<volume>36</volume>:<fpage>3874</fpage>–<lpage>6</lpage>.<pub-id pub-id-type="pmid">32271863</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Arredondo-Alonso</surname><given-names>S</given-names></string-name>, <string-name><surname>Rogers</surname><given-names>MRC</given-names></string-name>, <string-name><surname>Braat</surname><given-names>JC</given-names></string-name></person-group><etal>et al</etal><article-title>Mlplasmids: a user-friendly tool to predict plasmid- and chromosome-derived sequences for single species</article-title>. <source>Microbial Genomics</source><year>2018</year>;<volume>4</volume>:<fpage>e000224</fpage>.<pub-id pub-id-type="pmid">30383524</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bankevich</surname><given-names>A</given-names></string-name>, <string-name><surname>Nurk</surname><given-names>S</given-names></string-name>, <string-name><surname>Antipov</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>Spades: a new genome assembly algorithm and its applications to single-cell sequencing</article-title>. <source>J Comput Biol</source><year>2012</year>;<volume>19</volume>:<fpage>455</fpage>–<lpage>77</lpage>.<pub-id pub-id-type="pmid">22506599</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Camacho</surname><given-names>C</given-names></string-name>, <string-name><surname>Coulouris</surname><given-names>G</given-names></string-name>, <string-name><surname>Avagyan</surname><given-names>V</given-names></string-name></person-group><etal>et al</etal><article-title>BLAST+: architecture and applications</article-title>. <source>BMC Bioinformatics</source><year>2009</year>;<volume>10</volume>:<fpage>421</fpage>.<pub-id pub-id-type="pmid">20003500</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Carattoli</surname><given-names>A.</given-names></string-name></person-group><article-title>Plasmids and the spread of resistance</article-title>. <source>Int J Med Microbiol</source><year>2013</year>;<volume>303</volume>:<fpage>298</fpage>–<lpage>304</lpage>.<pub-id pub-id-type="pmid">23499304</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>De Oliveira</surname><given-names>DMP</given-names></string-name>, <string-name><surname>Forde</surname><given-names>BM</given-names></string-name>, <string-name><surname>Kidd</surname><given-names>TJ</given-names></string-name></person-group><etal>et al</etal><article-title>Antimicrobial resistance in ESKAPE pathogens</article-title>. <source>Clin Microbiol Rev</source><year>2020</year>;<volume>33</volume>:<fpage>e00181</fpage>–<lpage>19</lpage>.<pub-id pub-id-type="pmid">32404435</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Dewar</surname><given-names>AE</given-names></string-name>, <string-name><surname>Thomas</surname><given-names>JL</given-names></string-name>, <string-name><surname>Scott</surname><given-names>TW</given-names></string-name></person-group><etal>et al</etal><article-title>Plasmids do not consistently stabilize cooperation across bacteria but may promote broad pathogen host-range</article-title>. <source>Nat Ecol Evol</source><year>2021</year>;<volume>5</volume>:<fpage>1624</fpage>–<lpage>36</lpage>.<pub-id pub-id-type="pmid">34750532</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gerner-Smidt</surname><given-names>P</given-names></string-name>, <string-name><surname>Besser</surname><given-names>J</given-names></string-name>, <string-name><surname>Concepción-Acevedo</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>Whole genome sequencing: bridging One-Health surveillance of foodborne diseases</article-title>. <source>Front Public Health</source><year>2019</year>;<volume>7</volume>:<fpage>172</fpage>.<pub-id pub-id-type="pmid">31316960</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Luo</surname><given-names>L</given-names></string-name>, <string-name><surname>Wang</surname><given-names>H</given-names></string-name>, <string-name><surname>Payne</surname><given-names>MJ</given-names></string-name></person-group><etal>et al</etal><article-title>Comparative genomics of Chinese and international isolates of <italic toggle="yes">Escherichia albertii</italic>: population structure and evolution of virulence and antimicrobial resistance</article-title>. <source>Microbial Genomics</source><year>2021</year>;<volume>7</volume>:<fpage>000710</fpage>.<pub-id pub-id-type="pmid">34882085</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B12">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Mane</surname><given-names>AC, Faizrahnemoon M, Chauve C.</given-names></string-name></person-group><part-title>A mixed integer linear programming algorithm for plasmid binning</part-title>. In: <person-group person-group-type="editor"><string-name><surname>Jin</surname><given-names>L.</given-names></string-name>, <string-name><surname>Durand</surname><given-names>D</given-names></string-name></person-group> (eds.), <source>Comparative Genomics - 19th International Conference, RECOMB-CG 2022, La Jolla, CA, USA, May 20–21, 2022, Proceedings</source>, Lecture Notes in Computer Science, Vol. <volume>13234</volume>. <publisher-loc>Berlin, Germany</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>2022</year>, <fpage>279</fpage>–<lpage>292</lpage>.</mixed-citation>
    </ref>
    <ref id="btad250-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Müller</surname><given-names>R</given-names></string-name>, <string-name><surname>Chauve</surname><given-names>C.</given-names></string-name></person-group><article-title>HyAsP, a greedy tool for plasmids identification</article-title>. <source>Bioinformatics</source><year>2019</year>;<volume>35</volume>:<fpage>4436</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">31116364</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Nishida</surname><given-names>H.</given-names></string-name></person-group><article-title>Comparative analyses of base compositions, DNA sizes, and dinucleotide frequency profiles in archaeal and bacterial chromosomes and plasmids</article-title>. <source>Int J Evol Biol</source><year>2012</year>;<volume>2012</volume>:<fpage>342482</fpage>.<pub-id pub-id-type="pmid">22536540</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Partridge</surname><given-names>SR</given-names></string-name>, <string-name><surname>Kwong</surname><given-names>SM</given-names></string-name>, <string-name><surname>Firth</surname><given-names>N</given-names></string-name></person-group><etal>et al</etal><article-title>Mobile genetic elements associated with antimicrobial resistance</article-title>. <source>Clin Microbiol Rev</source><year>2018</year>;<volume>31</volume>:<fpage>e00088</fpage>–<lpage>17</lpage>.<pub-id pub-id-type="pmid">30068738</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Pellow</surname><given-names>D</given-names></string-name>, <string-name><surname>Mizrahi</surname><given-names>I</given-names></string-name>, <string-name><surname>Shamir</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Plasclass improves plasmid sequence classification</article-title>. <source>PLoS Comput Biol</source><year>2020</year>;<volume>16</volume>:<fpage>e1007781</fpage>.<pub-id pub-id-type="pmid">32243433</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Robertson</surname><given-names>J</given-names></string-name>, <string-name><surname>Nash</surname><given-names>J.</given-names></string-name></person-group><article-title>MOB-suite: software tools for clustering, reconstruction and typing of plasmids from draft assemblies</article-title>. <source>Microbial Genomics</source><year>2018</year>;<volume>4</volume>:<fpage>e000206</fpage>.<pub-id pub-id-type="pmid">30052170</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rozov</surname><given-names>R</given-names></string-name>, <string-name><surname>Brown Kav</surname><given-names>A</given-names></string-name>, <string-name><surname>Bogumil</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>Recycler: an algorithm for detecting plasmids from de novo assembly graphs</article-title>. <source>Bioinformatics</source><year>2017</year>;<volume>33</volume>:<fpage>475</fpage>–<lpage>82</lpage>.<pub-id pub-id-type="pmid">28003256</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Souvorov</surname><given-names>A</given-names></string-name>, <string-name><surname>Agarwala</surname><given-names>R</given-names></string-name>, <string-name><surname>Lipman</surname><given-names>DJ</given-names></string-name></person-group><etal>et al</etal><article-title>SKESA: strategic k-mer extension for scrupulous assemblies</article-title>. <source>Genome Biol</source><year>2018</year>;<volume>19</volume>:<fpage>153</fpage>.<pub-id pub-id-type="pmid">30286803</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Struelens</surname><given-names>MJ</given-names></string-name>, <string-name><surname>Sintchenko</surname><given-names>V.</given-names></string-name></person-group><article-title>Editorial: pathogen genomics: empowering infectious disease surveillance and outbreak investigations</article-title>. <source>Front Public Health</source><year>2020</year>;<volume>8</volume>:<fpage>179</fpage>.<pub-id pub-id-type="pmid">32509718</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tedersoo</surname><given-names>L</given-names></string-name>, <string-name><surname>Albertsen</surname><given-names>M</given-names></string-name>, <string-name><surname>Anslan</surname><given-names>S</given-names></string-name></person-group><etal>et al</etal><article-title>Perspectives and benefits of high-throughput long-read sequencing in microbial ecology</article-title>. <source>Appl Environ Microbiol</source><year>2021</year>;<volume>87</volume>:<fpage>e0062621</fpage>.<pub-id pub-id-type="pmid">34132589</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>van der Graaf-van Bloois</surname><given-names>L</given-names></string-name>, <string-name><surname>Wagenaar</surname><given-names>JA</given-names></string-name>, <string-name><surname>Zomer</surname><given-names>AL</given-names></string-name></person-group><etal>et al</etal><article-title>RFPlasmid: predicting plasmid sequences from short-read assembly data using machine learning</article-title>. <source>Microbial Genomics</source><year>2021</year>;<volume>7</volume>:<fpage>000683</fpage>.<pub-id pub-id-type="pmid">34846288</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wick</surname><given-names>RR</given-names></string-name>, <string-name><surname>Judd</surname><given-names>LM</given-names></string-name>, <string-name><surname>Gorrie</surname><given-names>CL</given-names></string-name></person-group><etal>et al</etal><article-title>Unicycler: resolving bacterial genome assemblies from short and long sequencing reads</article-title>. <source>PLoS Comput Biol</source><year>2017</year>;<volume>13</volume>:<fpage>e1005595</fpage>.<pub-id pub-id-type="pmid">28594827</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10311310</article-id>
    <article-id pub-id-type="pmid">37387134</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad250</article-id>
    <article-id pub-id-type="publisher-id">btad250</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Genome Sequence Analysis</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>PlasBin-flow: a flow-based MILP algorithm for plasmid contigs binning</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Mane</surname>
          <given-names>Aniket</given-names>
        </name>
        <aff><institution>Department of Mathematics, Simon Fraser University</institution>, Burnaby V5A 1S6, <country country="CA">Canada</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Faizrahnemoon</surname>
          <given-names>Mahsa</given-names>
        </name>
        <aff><institution>Department of Mathematics, Simon Fraser University</institution>, Burnaby V5A 1S6, <country country="CA">Canada</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Vinař</surname>
          <given-names>Tomáš</given-names>
        </name>
        <aff><institution>Department of Applied Informatics, Comenius University</institution>, Bratislava 84248, <country country="SK">Slovakia</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Brejová</surname>
          <given-names>Broňa</given-names>
        </name>
        <aff><institution>Department of Computer Science, Comenius University</institution>, Bratislava 84248, <country country="SK">Slovakia</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-9837-1878</contrib-id>
        <name>
          <surname>Chauve</surname>
          <given-names>Cedric</given-names>
        </name>
        <aff><institution>Department of Mathematics, Simon Fraser University</institution>, Burnaby V5A 1S6, <country country="CA">Canada</country></aff>
        <xref rid="btad250-cor1" ref-type="corresp"/>
        <!--cchauve@sfu.ca-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad250-cor1">Corresponding author. Department of Mathematics, Simon Fraser University, Burnaby V5A 1S6, Canada. E-mail: <email>cchauve@sfu.ca</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-06-30">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB/ECCB 2023 Proceedings</issue-title>
    <fpage>i288</fpage>
    <lpage>i296</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad250.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>The analysis of bacterial isolates to detect plasmids is important due to their role in the propagation of antimicrobial resistance. In short-read sequence assemblies, both plasmids and bacterial chromosomes are typically split into several contigs of various lengths, making identification of plasmids a challenging problem. In plasmid contig binning, the goal is to distinguish short-read assembly contigs based on their origin into plasmid and chromosomal contigs and subsequently sort plasmid contigs into bins, each bin corresponding to a single plasmid. Previous works on this problem consist of <italic toggle="yes">de novo</italic> approaches and reference-based approaches. <italic toggle="yes">De novo</italic> methods rely on contig features such as length, circularity, read coverage, or GC content. Reference-based approaches compare contigs to databases of known plasmids or plasmid markers from finished bacterial genomes.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>Recent developments suggest that leveraging information contained in the assembly graph improves the accuracy of plasmid binning. We present PlasBin-flow, a hybrid method that defines contig bins as subgraphs of the assembly graph. PlasBin-flow identifies such plasmid subgraphs through a mixed integer linear programming model that relies on the concept of network flow to account for sequencing coverage, while also accounting for the presence of plasmid genes and the GC content that often distinguishes plasmids from chromosomes. We demonstrate the performance of PlasBin-flow on a real dataset of bacterial samples.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p><ext-link xlink:href="https://github.com/cchauve/PlasBin-flow" ext-link-type="uri">https://github.com/cchauve/PlasBin-flow</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Slovak Research Agency VEGA</institution>
          </institution-wrap>
        </funding-source>
        <award-id>1/0538/22</award-id>
        <award-id>1/0463/20</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>European Union’s Horizon 2020</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Marie Skłodowska-Curie</institution>
          </institution-wrap>
        </funding-source>
        <award-id>872539</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Natural Sciences and Engineering Research Council of Canada</institution>
            <institution-id institution-id-type="DOI">10.13039/501100000038</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>RGPIN-03986</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Antimicrobial resistance (AMR) has emerged to become a major threat to public health. AMR is developed in bacteria through the propagation of AMR genes, often facilitated by mobile genetic elements (MGEs), which can be exchanged between bacteria through horizontal gene transfer (HGT; <xref rid="btad250-B15" ref-type="bibr">Partridge et al. 2018</xref>; <xref rid="btad250-B8" ref-type="bibr">De Oliveira et al. 2020</xref>). Plasmids are short circular extra-chromosomal MGEs known to be a major vector for the spread of AMR through HGT (<xref rid="btad250-B7" ref-type="bibr">Carattoli 2013</xref>). Thus, the detection of plasmids in bacterial genomes is an important problem in microbial genomics, with applications in environmental ecology and public health surveillance.</p>
    <p>With the advent of DNA sequencing technologies, it is now possible to obtain whole-genome sequencing (WGS) data at a low cost, and the analysis of WGS data for public health surveillance is now common (<xref rid="btad250-B10" ref-type="bibr">Gerner-Smidt et al. 2019</xref>; <xref rid="btad250-B20" ref-type="bibr">Struelens and Sintchenko 2020</xref>). Despite the increasing availability of long-read sequencing data (<xref rid="btad250-B21" ref-type="bibr">Tedersoo et al. 2021</xref>), most surveillance approaches in microbial genomics rely on the analysis of short-read WGS datasets. Such datasets are generally assembled using assemblers such as Unicycler (<xref rid="btad250-B23" ref-type="bibr">Wick et al. 2017</xref>), SKESA (<xref rid="btad250-B19" ref-type="bibr">Souvorov et al. 2018</xref>), or SPAdes (<xref rid="btad250-B5" ref-type="bibr">Bankevich et al. 2012</xref>). It is typically impossible to assemble full sequences of chromosomes and plasmids using short-read WGS data, and consequently, a short-read assembly contains a mixture of contigs coming from the chromosome and individual plasmids present in the sample.</p>
    <p>The problem of detecting plasmids from a short-read assembly can be considered at three different levels: classification, binning, and assembly. At the classification level, the aim is to classify the origin of a contig, which is either a plasmid or the chromosome. Current state-of-the-art tools rely on machine-learning approaches and include mlplasmids (<xref rid="btad250-B4" ref-type="bibr">Arredondo-Alonso et al. 2018</xref>), PlasClass (<xref rid="btad250-B16" ref-type="bibr">Pellow et al. 2020</xref>), Deeplasmid (<xref rid="btad250-B1" ref-type="bibr">Andreopoulos et al. 2022</xref>), and RFPlasmid (<xref rid="btad250-B22" ref-type="bibr">van der Graaf-van Bloois et al. 2021</xref>). However, a bacterial genome can contain several plasmids, and contigs classification does not provide a precise view of the plasmid content of a genome. This is addressed by the plasmid binning problem, where the aim is to group plasmid contigs into bins, such that the contigs in a bin are likely to originate from the same plasmid. Lastly, plasmid assembly aims to order and orient contigs in a plasmid bin into a fully assembled plasmid sequence.</p>
    <p>In this work, we focus on the binning problem, motivated by the observation that, for downstream analysis, the most useful information is groups of genes belonging to a given plasmid. While the order and orientation of these genes along the plasmid sequence can yield interesting insights, important tasks such as plasmid typing can be done from the gene content without considering contigs or gene order (<xref rid="btad250-B9" ref-type="bibr">Dewar et al. 2021</xref>; <xref rid="btad250-B11" ref-type="bibr">Luo et al. 2021</xref>). Two main methodological avenues have been used in developing plasmid binning methods: reference-based and <italic toggle="yes">de-novo</italic> binning. Reference-based methods, such as MOB-recon (<xref rid="btad250-B17" ref-type="bibr">Robertson and Nash 2018</xref>), map contigs to a reference database of plasmids or plasmid gene sequences, clustered into families of plasmids. Contigs are then binned together if they match with plasmids belonging to the same reference cluster. The reliance on a reference database can potentially hinder the ability of reference-based methods to identify novel plasmids. <italic toggle="yes">De-novo</italic> binning methods, such as Recycler (<xref rid="btad250-B18" ref-type="bibr">Rozov et al. 2017</xref>), PlasmidSPAdes (<xref rid="btad250-B2" ref-type="bibr">Antipov et al. 2016</xref>), and gplas (<xref rid="btad250-B3" ref-type="bibr">Arredondo-Alonso et al. 2020</xref>), bypass the requirement of reference sequences and rely instead on contig features assumed to be specific to different plasmids present in a bacterial cell. A feature central to many plasmid binning methods is contig read coverage. Different plasmids occur in the genome isolate in varying number (sometimes hundreds) of copies. Thus, the coverage of plasmid contigs is expected to be significantly different between the plasmids and chromosomes, as well as between different plasmids. Another feature used to detect plasmids in a bacterial assembly is the GC content, which is often slightly different in plasmids, especially short ones, as compared to the chromosome (<xref rid="btad250-B14" ref-type="bibr">Nishida 2012</xref>). Recent plasmid binning methods HyAsP (<xref rid="btad250-B13" ref-type="bibr">Müller and Chauve 2019</xref>) and PlasBin (<xref rid="btad250-B12" ref-type="bibr">Mane et al. 2022</xref>) combine ideas from both reference-based and <italic toggle="yes">de-novo</italic> binning.</p>
    <p>Several methods do leverage information from the assembly graph, a graph containing contigs as nodes and possible connections between them supported by sequencing data as edges; widely used bacterial genomes assemblers such as SPAdes, Unicycler, and SKESA generate such a graph as a complement to the contigs assembly. The rationale for using the assembly graph is that individual molecules, such as chromosomes or plasmids, ideally correspond to walks in this graph. However, spurious edges and contigs encoding repeats may form densely connected graphs that are difficult to analyse. On the other hand, some edges from such walks can be missing due to low sequencing coverage of the corresponding loci. Nevertheless, our approach assumes that sequencing data is provided at sufficient sequencing depth, resulting in plasmids corresponding to connected subgraphs, often cycles or closed walks, in the assembly graph. This assumption is also central in several other plasmid binning methods. For example, Recycler (<xref rid="btad250-B18" ref-type="bibr">Rozov et al. 2017</xref>) peels off cycles from the assembly graph assuming uniform coverage of sequenced plasmids; PlasmidSPAdes (<xref rid="btad250-B2" ref-type="bibr">Antipov et al. 2016</xref>) estimates the chromosomal coverage from the whole assembly, removes contigs with similar coverage as that of the chromosome and then computes putative plasmid bins from the connected components of the remaining graph. Gplas (<xref rid="btad250-B3" ref-type="bibr">Arredondo-Alonso et al. 2020</xref>) constructs a plasmidome network by defining a set of walks in the assembly graph. Each walk is initialized with a contig i.e. classified as plasmidic using mlplasmids (<xref rid="btad250-B4" ref-type="bibr">Arredondo-Alonso et al. 2018</xref>). It uses a heuristic that extends a walk one contig at a time, based on a score that accounts for similarity between the contig read coverage and the mean coverage of the currently assembled walk. Putative plasmid bins are selected from the network using graph partitioning algorithms. HyAsP (<xref rid="btad250-B13" ref-type="bibr">Müller and Chauve 2019</xref>) uses a greedy walk-building heuristic that aims to iteratively extract walks from the assembly graph. The algorithm relies on a walk-extension objective function defined in terms of coverage consistency, Guanine-Cytosine (GC) content consistency, and high plasmid gene density (from a database of reference plasmid genes) of contigs included in the walk. PlasBin (<xref rid="btad250-B12" ref-type="bibr">Mane et al. 2022</xref>) extends the approach used in HyAsP into a Mixed Integer Linear Programming (MILP) formulation that defines plasmid bins as connected subgraphs of the assembly graph that optimize an objective function similar to the HyAsP one.</p>
    <p>In this work, we introduce a new optimization algorithm for the plasmid binning problem. The main novelty of our work is to state the problem as a network flow problem, where the flow accounts for the expected uniform coverage of the sequenced plasmid, while also considering the GC content and the density of reference plasmid genes in a plasmid bin. Our work improves upon PlasBin in several ways, including a method for scoring GC content based on a probabilistic model. We compare our method PlasBin-flow against PlasBin, HyAsP, plasmidSPAdes, MOB-recon, and gplas on a dataset of 133 bacterial samples.</p>
  </sec>
  <sec>
    <title>2 Method</title>
    <p>Here we present PlasBin-flow, a network flow-based MILP formulation for the plasmid binning problem. It extracts putative plasmid bins as connected components of uniform coverage from an assembly graph. PlasBin-flow is a hybrid method that relies on a reference database of closed genome assemblies including plasmids.</p>
    <sec>
      <title>2.1 Input: Contigs and the assembly graph</title>
      <p>The input of the PlasBin-flow consists of the contigs and the assembly graph from a short-read assembly of a bacterial isolate. In this work, we use Unicycler (<xref rid="btad250-B23" ref-type="bibr">Wick et al. 2017</xref>) to generate the assembly, but any other assembler that provides an assembly graph (such as PlasmidSPAdes (<xref rid="btad250-B2" ref-type="bibr">Antipov et al. 2016</xref>) or SKESA (<xref rid="btad250-B19" ref-type="bibr">Souvorov et al. 2018</xref>)) can be used, as PlasBin-flow does not depend on a specific assembler.</p>
      <p>The set of all contigs in the short-read assembly is denoted by <italic toggle="yes">C</italic>. Every contig <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula> has two extremeties: head <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and tail <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Pairs of contigs potentially adjacent in the genome sequence are connected via edges of the assembly graph, each edge linking two specific contig extremities. We denote the set of edges in the assembly graph by <italic toggle="yes">E</italic>. Each undirected edge <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:math></inline-formula> connects two extremities <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (<inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> being either a head or a tail of contigs <italic toggle="yes">c</italic> and <italic toggle="yes">d</italic>, respectively) and is represented as an unordered pair <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>The PlasBin-flow input also contains a reference database of plasmid genes. In a practical application, the reference database would contain all known plasmid genes; however, since an exact match to the reference database would indicate a strong determination of the contig origin, we have taken care in our experiments to withdraw information from samples used for testing from the database used (see Section 3.1 for further description).</p>
      <sec>
        <title>2.1.1 Contig features</title>
        <p>PlasBin-flow considers several features associated to a contig <italic toggle="yes">c</italic>, namely its GC content <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, length <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, sequencing coverage <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and plasmid gene density <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. The sequencing coverage is the normalized coverage provided by Unicycler for each contig, i.e. the average base coverage of the contig normalized by the median coverage of the contigs in the whole assembly; chromosomal contigs are thus expected to have a normalized coverage close to 1. To obtain the plasmid gene density, we map each contig against the reference database of plasmid genes using blastn (version 2.6.0) (<xref rid="btad250-B6" ref-type="bibr">Camacho et al. 2009</xref>), discarding any match with identity below 95% or a match that covers ˂95% of a gene. The plasmid gene density <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the fraction of the sequence length of contig <italic toggle="yes">c</italic> covered by these matches.</p>
        <p>Contigs passing certain thresholds related to length and gene density are referred to as seed contigs. These contigs are more likely to be part of a plasmid than others. We describe how to determine corresponding thresholds using the reference database in Section 2.4. The set of all seed contigs is denoted as <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and we also use a boolean feature <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
    </sec>
    <sec>
      <title>2.2 PlasBin-flow overview</title>
      <p>PlasBin-flow works iteratively, identifying one plasmid bin in each iteration by solving a MILP, described in Section 2.3. In each iteration, the identified bin is required to contain at least one seed contig. After each iteration, PlasBin-flow updates the assembly graph (contigs, edges, and contig read coverage) to account for the removal of the plasmid bin. The modified assembly graph is then used as input for the next iteration. This process is repeated until the modified assembly graph does not contain any seed contig.</p>
      <p>PlasBin-flow defines a plasmid bin as a connected subgraph of a network defined from the assembly graph, while enforcing that this subgraph contains at least one seed contig and assigning to this subgraph (i) a flow value defined in terms of the coverage of contigs it contains, that serves as a proxy for the copy number of the plasmid (bin) defined by the subgraph and (ii) a GC content value. This subgraph is chosen as the one optimizing an objective function defined as a linear combination of several terms: (i) the flow value, (ii) a GC content term penalizing contigs whose GC content does not agree with the GC content assigned to the subgraph, and (iii) a plasmid gene density term penalizing contigs with a low plasmid gene density. An important and novel feature of PlasBin-flow is that it assigns a multiplicity to each contig in a plasmid bin, with repeated contigs having multiplicity ˃1.</p>
      <p>The GC content assigned to a solution is defined as a discrete category, each of the <italic toggle="yes">k</italic> categories corresponding to a GC content interval. This set <italic toggle="yes">K</italic> of <italic toggle="yes">k</italic> intervals is pre-defined through a preliminary analysis of the reference database. For each contig <italic toggle="yes">c</italic> and each GC content interval <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>, we pre-compute a GC content penalty <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:mi>c</mml:mi><mml:mo>_</mml:mo><mml:mi>p</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> defined in terms of the likelihood that a sequence of length <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and GC content <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> would be observed in a plasmid whose GC content is in interval <italic toggle="yes">b</italic>. We provide a detailed description of <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:mi>c</mml:mi><mml:mo>_</mml:mo><mml:mi>p</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> in Section 2.5.</p>
    </sec>
    <sec>
      <title>2.3 MILP formulation</title>
      <sec>
        <title>2.3.1 Network and flow</title>
        <p>The MILP implemented in PlasBin-flow takes as an input network <italic toggle="yes">N</italic> obtained by modifying the original assembly graph. Using contigs <italic toggle="yes">C</italic> and edges <italic toggle="yes">E</italic> in the undirected assembly graph, we define a directed network <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo>∪</mml:mo><mml:msup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The new set of nodes is composed of <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, the set of all contig extremities and <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, the source and sink nodes of the network. The new set of edges is composed of two subsets, <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>. Set <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is obtained by (i) doubling each edge <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>}</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:math></inline-formula> into two directed edges <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, (ii) adding edges <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for every seed contig <italic toggle="yes">c</italic> and (iii) adding edge <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for every contig <italic toggle="yes">d</italic> (regardless of its seed status). Set <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is composed of directed edges that connect extremities within each contig, i.e. for each contig <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> contains edges <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>The choice of the subgraph, whose contigs will form a plasmid bin, is guided by a flow through the network. Expanding the set of undirected edges <italic toggle="yes">E</italic> to the set of directed edges <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is necessary to allow the flow to account for the orientation of contigs in the flow computed by the MILP. Moreover, every edge <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> has a capacity <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mi>a</mml:mi><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:mi>r</mml:mi><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>r</mml:mi><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>d</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> that provides an upper-bound to the total amount of flow that can go through <italic toggle="yes">e</italic>, while if <italic toggle="yes">e</italic> links a contig extremity <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to the source <italic toggle="yes">s</italic> or sink <italic toggle="yes">t</italic>, its capacity is <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. We define a flow as a map <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mi>f</mml:mi><mml:mo>:</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo>→</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow></mml:math></inline-formula> that satisfies the following constraints:</p>
        <list list-type="bullet">
          <list-item>
            <p>Source and sink constraints<italic toggle="yes">.</italic> Exactly one edge outgoing from <italic toggle="yes">s</italic> and incoming to <italic toggle="yes">t</italic> has a non-zero flow value.</p>
          </list-item>
          <list-item>
            <p>Capacity constraints for edges: The flow through an edge cannot exceed its capacity.</p>
          </list-item>
          <list-item>
            <p>Conservation constraints: The cumulative flow into a contig extremity (sum of the flow of the edges from <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> into this contig extremity) should be equal to the cumulative flow out of the other extremity of the same contig (sum of the flow of the edges from <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> out of this contig extremity).</p>
          </list-item>
          <list-item>
            <p>Capacity constraints for nodes: The cumulative flow into and out of a contig extremity cannot exceed the read coverage of the contig.</p>
          </list-item>
        </list>
        <p>The value of the flow <italic toggle="yes">F</italic> is thus equal to the quantity flowing out of <italic toggle="yes">s</italic>. By the conservation constraints, this is also equal to the quantity flowing into <italic toggle="yes">t</italic>. The flow value can be considered as a proxy for the copy number of the plasmid represented by the bin defined by the subgraph induced by the non-zero flow edges. A contig from this subgraph can represent a sequence that has been repeated in the plasmid. To account for such instances, the flow through a contig can be higher than the overall flow <italic toggle="yes">F</italic>. However, this does not imply that the flow through a contig will be an integer multiple of <italic toggle="yes">F</italic>.</p>
      </sec>
      <sec>
        <title>2.3.2 Decision variables</title>
        <p>The MILP decision variables define a solution to the optimal plasmid bin problem, composed of a subgraph of <italic toggle="yes">N</italic>, GC content value associated to it and a flow value. To each element of <italic toggle="yes">N</italic>, we wish to associate a decision binary variable to indicate whether it is part of the solution subgraph <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> associated with a plasmid bin <italic toggle="yes">p</italic>. <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is defined by a set of edges from <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, a set of contig extremities from <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> and a set contig edges from <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>. If an extremity <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (resp.<inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) belongs to <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, so should the other extremity <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (resp. <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>). Additionally, at least one internal edge <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> has to be selected to facilitate the flow within contig <italic toggle="yes">c</italic>. Thus, instead of having a variable each associated with extremities <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> as well as internal edges <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, it suffices to have a variable <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> associated with contig <italic toggle="yes">c</italic>. Thus, <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> will mean that both extremities of <italic toggle="yes">c</italic> and at least one internal edge of <italic toggle="yes">c</italic> will be part of <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. We also associate binary decision variables to each edge <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, denoted respectively <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, indicating whether it is a part of the solution subgraph <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. We call the edges and contigs included in the solution active.</p>
        <p>We associate to every edge <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> a continuous decision variable <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> that encodes the quantity <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> flowing through the edge. The overall flow value (flowing out of the source <italic toggle="yes">s</italic> and into the sink <italic toggle="yes">t</italic>) is encoded by a continuous decision variable <italic toggle="yes">F</italic>. The flow <italic toggle="yes">F</italic> also helps in determining the multiplicity for each contig in the plasmid bin defined by a solution. Let <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> be the set of edges incoming into extremity <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi><mml:mo>−</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> be the set of edges outgoing from <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. The multiplicity of a contig <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> in the plasmid bin is related to the flow value as <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi><mml:mo>+</mml:mo></mml:msubsup><mml:mo>∪</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>/</mml:mo><mml:mi>F</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
        <p>The GC content of the solution subgraph is chosen as one of the <italic toggle="yes">k</italic> pre-defined intervals and is encoded by binary decision variables: for every pre-defined GC content interval <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>, the decision variable <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is assigned value 1 if <italic toggle="yes">b</italic> is the chosen GC content interval and 0 otherwise.</p>
        <p>The total number of decision variables defining a solution to the plasmid bin finding problem (subgraph, associated flow, and GC content) is thus <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>C</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>K</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Note that the subgraph of <italic toggle="yes">N</italic> defined as above may not be connected. However, we aim to define a plasmid bin by a connected subgraph. We describe later how we handle this problem through delayed constraints generation.</p>
      </sec>
      <sec>
        <title>2.3.3 Objective function</title>
        <p>We formulate the MILP as a maximization problem with objective function <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:mi>F</mml:mi><mml:mo>+</mml:mo><mml:mi>G</mml:mi><mml:mi>C</mml:mi><mml:mo>+</mml:mo><mml:mi>G</mml:mi><mml:mi>D</mml:mi></mml:mrow></mml:math></inline-formula>. Here, <italic toggle="yes">F</italic> represents the overall flow value from <italic toggle="yes">s</italic> to <italic toggle="yes">t</italic>, <italic toggle="yes">GC</italic> is a penalty for active contigs whose GC content differs significantly from the overall bin GC content and <italic toggle="yes">GD</italic> is a term penalizing inclusion of contigs with low plasmid gene density and rewarding contigs with a high gene density. In particular,
and
</p>
        <disp-formula id="E1">
          <mml:math id="M1" display="block" overflow="scroll">
            <mml:mrow>
              <mml:mi>G</mml:mi>
              <mml:mi>C</mml:mi>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>c</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi>C</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>b</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi>K</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mo>−</mml:mo>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>g</mml:mi>
              <mml:mi>c</mml:mi>
              <mml:mo>_</mml:mo>
              <mml:mi>p</mml:mi>
              <mml:mi>e</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>n</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>c</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>⋅</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mi>c</mml:mi>
              </mml:msub>
              <mml:mo>⋅</mml:mo>
              <mml:mi>G</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>C</mml:mi>
                </mml:mrow>
                <mml:mi>b</mml:mi>
              </mml:msub>
              <mml:mo>,</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <disp-formula id="E2">
          <mml:math id="M2" display="block" overflow="scroll">
            <mml:mrow>
              <mml:mi>G</mml:mi>
              <mml:mi>D</mml:mi>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>c</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi>C</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mrow>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>g</mml:mi>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>d</mml:mi>
                  </mml:mrow>
                  <mml:mi>c</mml:mi>
                </mml:msub>
                <mml:mo>−</mml:mo>
                <mml:mn>0.5</mml:mn>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
              <mml:mo>⋅</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mi>c</mml:mi>
              </mml:msub>
              <mml:mo>.</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p>Note that the term <italic toggle="yes">GC</italic> is not linear as it involves the product of two binary decision variables. Such a product can be linearized by addition of a single auxiliary binary decision variable and three associated linear constraints (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Material Section S1</xref>). The gene density in the objective function is used in a similar manner as probability. Thus, the MILP is discouraged from choosing contigs with gene density ˂0.5 as part of the solution.</p>
        <p>The rationale for this objective function is as follows: by maximizing the flow value <italic toggle="yes">F</italic>, we aim to identify a high copy-number plasmid i.e. more likely to be reliable. The two penalty terms aim to assign to the plasmid bin a GC content that reflects the GC content of the selected contigs (we refer to Section 2.5 for a more detailed discussion) and prefer contigs that have a higher plasmid genes density and are thus more likely to originate from actual plasmids. Our approach that seeks a plasmid bin through optimization improves upon greedy heuristics (such as HyAsP) in that it will include contigs that impact negatively the objective function if this inclusion allows to connect to other contigs whose positive contribution to the objective function will be beneficial overall. In contrast, HyAsP, being based on a greedy walk extension approach, may stop a walk extension simply because all neighboring contigs have a negative impact on the objective function. Advantage of the optimization approach over this greedy heuristic is illustrated by the results shown in Section 3.3, <xref rid="btad250-T1" ref-type="table">Tables 1</xref> and <xref rid="btad250-T2" ref-type="table">2</xref>.</p>
        <table-wrap position="float" id="btad250-T1">
          <label>Table 1.</label>
          <caption>
            <p>Comparison of tool accuracy on 41 bacterial isolates.<xref rid="tblfn1" ref-type="table-fn"><sup>a</sup></xref></p>
          </caption>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col valign="top" align="left" span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th rowspan="1" colspan="1"/>
                <th colspan="3" rowspan="1">Basepair level</th>
                <th colspan="3" rowspan="1">Contig level</th>
              </tr>
              <tr>
                <th rowspan="1" colspan="1"/>
                <th colspan="3" rowspan="1">(weighted)<hr/></th>
                <th colspan="3" rowspan="1">(unweighted)<hr/></th>
              </tr>
              <tr>
                <th rowspan="1" colspan="1">Tool</th>
                <th rowspan="1" colspan="1">Precision</th>
                <th rowspan="1" colspan="1">Recall</th>
                <th rowspan="1" colspan="1">F1</th>
                <th rowspan="1" colspan="1">Precision</th>
                <th rowspan="1" colspan="1">Recall</th>
                <th rowspan="1" colspan="1">F1</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">PlasBin-flow</td>
                <td rowspan="1" colspan="1">0.75</td>
                <td rowspan="1" colspan="1">0.71</td>
                <td rowspan="1" colspan="1">0.67</td>
                <td rowspan="1" colspan="1">0.79</td>
                <td rowspan="1" colspan="1">0.63</td>
                <td rowspan="1" colspan="1">0.64</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">PlasBin</td>
                <td rowspan="1" colspan="1">0.59</td>
                <td rowspan="1" colspan="1">0.57</td>
                <td rowspan="1" colspan="1">0.55</td>
                <td rowspan="1" colspan="1">0.59</td>
                <td rowspan="1" colspan="1">0.56</td>
                <td rowspan="1" colspan="1">0.54</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">HyAsP</td>
                <td rowspan="1" colspan="1">0.74</td>
                <td rowspan="1" colspan="1">0.48</td>
                <td rowspan="1" colspan="1">0.55</td>
                <td rowspan="1" colspan="1">0.74</td>
                <td rowspan="1" colspan="1">0.40</td>
                <td rowspan="1" colspan="1">0.48</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">plasmidSPAdes</td>
                <td rowspan="1" colspan="1">0.54</td>
                <td rowspan="1" colspan="1">0.68</td>
                <td rowspan="1" colspan="1">0.54</td>
                <td rowspan="1" colspan="1">0.47</td>
                <td rowspan="1" colspan="1">0.70</td>
                <td rowspan="1" colspan="1">0.50</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">MOB-recon</td>
                <td rowspan="1" colspan="1">0.83</td>
                <td rowspan="1" colspan="1">
                  <bold>0.91</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>0.85</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>0.81</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>0.83</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>0.81</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">gplas</td>
                <td rowspan="1" colspan="1">
                  <bold>0.84</bold>
                </td>
                <td rowspan="1" colspan="1">0.74</td>
                <td rowspan="1" colspan="1">0.76</td>
                <td rowspan="1" colspan="1">0.79</td>
                <td rowspan="1" colspan="1">0.58</td>
                <td rowspan="1" colspan="1">0.64</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <fn id="tblfn1">
              <label>a</label>
              <p>The table shows the mean values of precision, recall, and F1 statistics, considering only contigs of length at least 1000 bp, over 41 testing samples from <italic toggle="yes">E. coli</italic>, <italic toggle="yes">E. faecium</italic>, and <italic toggle="yes">K. pneumoniae</italic>, the species supported by gplas.</p>
            </fn>
            <fn id="tblfn2">
              <p>Bold values indicate the highest values in the respective columns.</p>
            </fn>
          </table-wrap-foot>
        </table-wrap>
        <table-wrap position="float" id="btad250-T2">
          <label>Table 2.</label>
          <caption>
            <p>Comparison of tool accuracy on 25 bacterial isolates.<xref rid="tblfn2" ref-type="table-fn"><sup>a</sup></xref></p>
          </caption>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col valign="top" align="left" span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th rowspan="1" colspan="1"/>
                <th colspan="3" rowspan="1">Basepair level</th>
                <th colspan="3" rowspan="1">Contig level</th>
              </tr>
              <tr>
                <th rowspan="1" colspan="1"/>
                <th colspan="3" rowspan="1">(weighted)<hr/></th>
                <th colspan="3" rowspan="1">(unweighted)<hr/></th>
              </tr>
              <tr>
                <th rowspan="1" colspan="1">Tool</th>
                <th rowspan="1" colspan="1">Precision</th>
                <th rowspan="1" colspan="1">Recall</th>
                <th rowspan="1" colspan="1">F1</th>
                <th rowspan="1" colspan="1">Precision</th>
                <th rowspan="1" colspan="1">Recall</th>
                <th rowspan="1" colspan="1">F1</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">PlasBin-flow</td>
                <td rowspan="1" colspan="1">
                  <bold>0.98</bold>
                </td>
                <td rowspan="1" colspan="1">0.90</td>
                <td rowspan="1" colspan="1">
                  <bold>0.93</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>0.96</bold>
                </td>
                <td rowspan="1" colspan="1">0.66</td>
                <td rowspan="1" colspan="1">
                  <bold>0.76</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">PlasBin</td>
                <td rowspan="1" colspan="1">0.72</td>
                <td rowspan="1" colspan="1">0.57</td>
                <td rowspan="1" colspan="1">0.57</td>
                <td rowspan="1" colspan="1">0.64</td>
                <td rowspan="1" colspan="1">0.58</td>
                <td rowspan="1" colspan="1">0.58</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">HyAsP</td>
                <td rowspan="1" colspan="1">0.96</td>
                <td rowspan="1" colspan="1">0.85</td>
                <td rowspan="1" colspan="1">0.89</td>
                <td rowspan="1" colspan="1">0.90</td>
                <td rowspan="1" colspan="1">
                  <bold>0.70</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>0.76</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">plasmidSPAdes</td>
                <td rowspan="1" colspan="1">0.47</td>
                <td rowspan="1" colspan="1">0.61</td>
                <td rowspan="1" colspan="1">0.49</td>
                <td rowspan="1" colspan="1">0.35</td>
                <td rowspan="1" colspan="1">0.54</td>
                <td rowspan="1" colspan="1">0.34</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">MOB-recon</td>
                <td rowspan="1" colspan="1">0.92</td>
                <td rowspan="1" colspan="1">
                  <bold>0.97</bold>
                </td>
                <td rowspan="1" colspan="1">0.91</td>
                <td rowspan="1" colspan="1">0.94</td>
                <td rowspan="1" colspan="1">
                  <bold>0.70</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>0.76</bold>
                </td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <fn id="tblfn3">
              <label>a</label>
              <p>The table shows mean values of precision, recall, and F1 statistics for the remaining 25 testing samples from species not supported by gplas.</p>
            </fn>
            <fn id="tblfn4">
              <p>Bold values indicate the highest values in the respective columns.</p>
            </fn>
          </table-wrap-foot>
        </table-wrap>
      </sec>
      <sec>
        <title>2.3.4 Constraints</title>
        <p>We now describe the constraints used in the formulation:</p>
        <list list-type="order">
          <list-item>
            <p>Exactly one edge out of <italic toggle="yes">s</italic> is part of the solution:
<disp-formula id="E3"><mml:math id="M3" display="block" overflow="scroll"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi>h</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1.</mml:mn></mml:mrow></mml:math></disp-formula></p>
            <p>This also ensures that every solution contains at least one seed contig.</p>
          </list-item>
          <list-item>
            <p>The flow through an edge <italic toggle="yes">e</italic> is non-zero only if <italic toggle="yes">e</italic> was selected in the solution subgraph and cannot exceed its capacity:
<disp-formula id="E4"><mml:math id="M4" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mi>a</mml:mi><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
          </list-item>
          <list-item>
            <p>For any contig <italic toggle="yes">c</italic>, the cumulative flow through <italic toggle="yes">c</italic> cannot exceed its read coverage:
<disp-formula id="E5"><mml:math id="M5" display="block" overflow="scroll"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi><mml:mo>+</mml:mo></mml:msubsup><mml:mo>∪</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>≤</mml:mo><mml:mi>r</mml:mi><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
          </list-item>
          <list-item>
            <p>For any contig <italic toggle="yes">c</italic>, the cumulative flow into <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> should be equal to the cumulative flow out of <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and conversely:
<disp-formula id="E6"><mml:math id="M6" display="block" overflow="scroll"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msubsup></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo></mml:msubsup></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
          </list-item>
          <list-item>
            <p>Flow value <italic toggle="yes">F</italic> should be equal to the flow out of <italic toggle="yes">s</italic> and into <italic toggle="yes">t</italic>:
<disp-formula id="E7"><mml:math id="M7" display="block" overflow="scroll"><mml:mrow><mml:mi>F</mml:mi><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>F</mml:mi><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula></p>
          </list-item>
          <list-item>
            <p>If an edge <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi>h</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> is in the solution (<inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>), then the contigs <italic toggle="yes">c</italic> and <italic toggle="yes">d</italic> should also be in the solution. Note that the converse need not be true. In other words, contigs <italic toggle="yes">c</italic> and <italic toggle="yes">d</italic> may be part of the solution due to other edges. In that case, <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> should be 0. To implement this, we use the following constraints:
<disp-formula id="E8"><mml:math id="M8" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>d</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></disp-formula></p>
          </list-item>
          <list-item>
            <p>A contig <italic toggle="yes">c</italic> is active (selected in the solution) if and only if at least one edge incident to one of its extremities is active.
<disp-formula id="E9"><mml:math id="M9" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>h</mml:mi><mml:mo>+</mml:mo></mml:msubsup><mml:mo>∪</mml:mo><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></disp-formula></p>
          </list-item>
          <list-item>
            <p>Each active edge has flow at least <italic toggle="yes">F</italic>. To implement this condition, we introduce an auxiliary variable <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><disp-formula id="E10"><mml:math id="M10" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>F</mml:mi><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
            <p>We further add the constraint:
<disp-formula id="E11"><mml:math id="M11" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math></disp-formula></p>
          </list-item>
        </list>
        <p>Thus, if there is no flow through edge <italic toggle="yes">e</italic>, <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is forced to be 0 and in turn <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. To handle the fact that <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the product of a binary variable and a continuous variable, we use the same approach as for the <italic toggle="yes">GC</italic> term of the objective function.</p>
      </sec>
      <sec>
        <title>2.3.5 Ensuring connectivity</title>
        <p>A solution that satisfies the above constraints may not be connected. It will contain a connected component with <italic toggle="yes">s</italic> and <italic toggle="yes">t</italic>, but may also contain other components disconnected from <italic toggle="yes">s</italic> and <italic toggle="yes">t</italic>. Such disconnected components have a closed flow circulating within the component without violating any of the initial constraints.</p>
        <p>If the proposed solution contains disconnected components, we mute the edges in the disconnected component. For each edge <italic toggle="yes">e</italic> in the disconnected component, we add a constraint <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and run the MILP again. This process is repeated until the MILP returns a solution with a single component connected to <italic toggle="yes">s</italic> and <italic toggle="yes">t</italic>. While in theory, this delayed constraint generation process could involve a large number of iterations, in practice we observe that it requires a small number of iterations. It is possible that this process may force the MILP to overlook solutions containing some of the muted edges even if the solutions have a greater flow. We discuss more effective ways to handle disconnected components in Section 4.</p>
      </sec>
    </sec>
    <sec>
      <title>2.4 Determining seeds</title>
      <p>Similarly to HyAsP and PlasBin, PlasBin-flow enforces that every plasmid bin contains at least one seed contig under the assumption that such contigs were identified as likely to belong to a plasmid due to their sequence features (length and plasmid gene density). We used the reference database for which closed assemblies with annotated plasmids were available, to obtain the thresholds determining seed contigs. Using Unicycler, we assembled the reads datasets for each sample in the reference database. We explored a grid of pairs of values <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, respectively, for the contig length and plasmid gene density, with <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula> ranging from 50 to 5000 bp in increments of 50 and <italic toggle="yes">gd</italic> ranging from 0.01 to 1 in increments of 0.01. For each pair <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> we considered as a seed every contig <italic toggle="yes">c</italic> such that <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mi>g</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>; then mapping the contigs onto the closed assemblies of the reference dataset, for which plasmids are known, we counted (i) the number <italic toggle="yes">SP</italic> of plasmids onto which at least one seed contig was mapped to (seeded plasmids), and (ii) the number <italic toggle="yes">NPS</italic> of seed contigs that mapped to the chromosome (non-plasmid seeds). We then determined the pair of thresholds that maximized the expression <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mi>P</mml:mi><mml:mo>−</mml:mo><mml:mi mathvariant="italic">NPS</mml:mi></mml:mrow></mml:math></inline-formula> and used them as thresholds defining seed contigs in our experiments. The pair of thresholds thus obtained was <inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2650</mml:mn><mml:mo>,</mml:mo><mml:mn>0.58</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>2.5 Determining GC content intervals and penalties</title>
      <p>For each contig <italic toggle="yes">c</italic>, we associate a penalty relating the observed GC content of <italic toggle="yes">c</italic> to the GC content interval <inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula> associated to a solution to the MILP. This penalty is based on a probabilistic model in which we can compute the likelihood that a contig of a particular length and GC content will belong to a plasmid whose GC content is in a particular interval <italic toggle="yes">b</italic>. In this section, we first define the model and describe how we define the GC content penalty term. Subsequently, we describe the set of intervals <italic toggle="yes">K</italic> used in our experiments.</p>
      <sec>
        <title>2.5.1 Probabilistic model</title>
        <p>If a given contig <italic toggle="yes">c</italic> of length <inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula> has GC content <inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we model the observed number <italic toggle="yes">n</italic> of GC nucleotides within this contig by the binomial distribution with parameters <italic toggle="yes">x</italic> and <inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula>. However, GC content within a plasmid may fluctuate for various biological reasons, and therefore we model contig-level GC content <italic toggle="yes">x</italic> as a random variable sampled from a beta distribution with parameters <inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo>=</mml:mo><mml:mi>p</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the true GC content of the whole plasmid and <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> is a fixed parameter. This results in <italic toggle="yes">n</italic> being sampled from the beta-binomial distribution with parameters <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula>, <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula> and <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mo>β</mml:mo></mml:math></inline-formula>; namely, <inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>|</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>ℓ</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>n</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mo>α</mml:mo><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mo>β</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>α</mml:mo><mml:mo>,</mml:mo><mml:mo>β</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> where <italic toggle="yes">B</italic> is the beta function. Values <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula> and <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mo>β</mml:mo></mml:math></inline-formula> represent pseudocounts added to the observed counts of GC and non-GC nucleotides, respectively. We use <inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula> for the overall pseudocount.</p>
        <p>In our scenario, <italic toggle="yes">p</italic> is an unknown value coming from GC content interval <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, and we assume a uniform prior on <italic toggle="yes">p</italic>. The overall probability of <italic toggle="yes">b</italic> being the true source interval for observed count <italic toggle="yes">n</italic> is thus <inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mi>P</mml:mi></mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>|</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>|</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∝</mml:mo><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>|</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⋅</mml:mo><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is obtained by the Bayes theorem. We normalize these probabilities over all intervals in <italic toggle="yes">K</italic> to obtain the likelihood <inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:mi>c</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">pro</mml:mi><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> that contig <italic toggle="yes">c</italic> originates from a molecule with GC content in interval <italic toggle="yes">b</italic>.</p>
      </sec>
      <sec>
        <title>2.5.2 Penalty term</title>
        <p>For contig <italic toggle="yes">c</italic> and interval <italic toggle="yes">b</italic>, the MILP uses penalty <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:mi>c</mml:mi><mml:mo>_</mml:mo><mml:mi>p</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, which is incurred if <italic toggle="yes">c</italic> is part of a plasmid whose GC content belongs to <italic toggle="yes">b</italic>. This penalty is computed as
</p>
        <disp-formula id="E12">
          <mml:math id="M12" display="block" overflow="scroll">
            <mml:mrow>
              <mml:mi>g</mml:mi>
              <mml:mi>c</mml:mi>
              <mml:mo>_</mml:mo>
              <mml:mi>p</mml:mi>
              <mml:mi>e</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>n</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>c</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mi>max</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>b</mml:mi>
                    </mml:mrow>
                    <mml:mo>′</mml:mo>
                  </mml:msup>
                  <mml:mo>∈</mml:mo>
                  <mml:mi>K</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mo>{</mml:mo>
              <mml:mi>g</mml:mi>
              <mml:mi>c</mml:mi>
              <mml:mo>_</mml:mo>
              <mml:mi mathvariant="italic">pro</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>c</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>b</mml:mi>
                    </mml:mrow>
                    <mml:mo>′</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:msub>
              <mml:mo>}</mml:mo>
              <mml:mo>−</mml:mo>
              <mml:mi>g</mml:mi>
              <mml:mi>c</mml:mi>
              <mml:mo>_</mml:mo>
              <mml:mi mathvariant="italic">pro</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>c</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>.</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p>The penalty is thus zero for the interval <italic toggle="yes">b</italic> where the likelihood of <italic toggle="yes">c</italic> achieves maximum. The penalty increases with the gap between the proposed GC content interval <italic toggle="yes">b</italic> and the most likely interval for contig <italic toggle="yes">c</italic>. For very short contigs, probabilities of different GC content intervals are closer to each other, and thus the resulting penalties are smaller compared to longer contigs.</p>
      </sec>
      <sec>
        <title>2.5.3 Pre-defining GC content intervals</title>
        <p>The GC content intervals considered were pre-determined prior to running experiments based on an analysis of the reference dataset. The GC content of most plasmids and chromosomes in the reference dataset was observed to be between 0.4 and 0.6. The interval [0.4, 0.6] was subdivided into 4 equal intervals resulting in <inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:math></inline-formula> intervals <inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0.4</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0.4</mml:mn><mml:mo>,</mml:mo><mml:mn>0.45</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0.45</mml:mn><mml:mo>,</mml:mo><mml:mn>0.5</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0.5</mml:mn><mml:mo>,</mml:mo><mml:mn>0.55</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0.55</mml:mn><mml:mo>,</mml:mo><mml:mn>0.6</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0.6</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>3 Experimental results</title>
    <sec>
      <title>3.1 Datasets and tools</title>
      <p>We evaluated the following methods: our new tool PlasBin-flow, HyAsP (<xref rid="btad250-B13" ref-type="bibr">Müller and Chauve 2019</xref>), MOB-recon (<xref rid="btad250-B17" ref-type="bibr">Robertson and Nash 2018</xref>), plasmidSPAdes (<xref rid="btad250-B2" ref-type="bibr">Antipov et al. 2016</xref>), and gplas (<xref rid="btad250-B3" ref-type="bibr">Arredondo-Alonso et al. 2020</xref>). PlasmidSPAdes and gplas are <italic toggle="yes">de-novo</italic> binning methods, while MOB-recon, HyASP, and PlasBin-flow rely on a reference database of plasmid genes.</p>
      <p>Our dataset consists of 133 bacterial genomes and 377 plasmids from a collection of real bacterial isolates with closed genome assemblies compiled by <xref rid="btad250-B17" ref-type="bibr">Robertson and Nash (2018)</xref>. To simulate the use of a realistic reference database, we split our data into a reference set and a test set; the samples released before 19 December 2015 were used to build the reference database and those released after that date formed the test set. The reference set consists of 67 bacterial isolates with 230 plasmids containing 10 685 plasmid genes.</p>
      <p>The remaining test set consists of 66 samples with 147 plasmids. For the test set, Illumina sequencing data was re-assembled using Unicycler to provide contigs and assembly graphs, except in case of plasmidSPAdes. PlasmidSPAdes takes raw reads as input and constructs its own assembly graph using the SPAdes assembler. Gplas requires the use of mlplasmids (<xref rid="btad250-B4" ref-type="bibr">Arredondo-Alonso et al. 2018</xref>) to compute the probability of contigs to originate from a plasmid. Since mlplasmids is a species-specific tool, it currently supports only four species, three of which feature in our test dataset (<italic toggle="yes">Escherichia coli</italic>, <italic toggle="yes">Enterococcus faecium</italic>, and <italic toggle="yes">Klebsiella pneumoniae</italic>). From the test dataset, 41 samples with 88 plasmids belong to these three species.</p>
    </sec>
    <sec>
      <title>3.2 Evaluation metrics</title>
      <p>To evaluate predictions of individual tools on a particular testing sample, we need to compare them to the ground truth determined from annotated finished assembly of the sample as given by Robertson and Nash (<xref rid="btad250-B17" ref-type="bibr">2018</xref>). We consider two sets of measures: weighted or base-pair level statistics, which consider accuracy of bin predictions weighted by the lengths of individual contigs (effectively counting how many base pairs were involved in correct predictions), and unweighted or contig-level statistics, which only consider accuracy of predictions for individual contigs, disregarding contig lengths.</p>
      <p>Each short-read contig in the isolate assembly is mapped against the plasmids from the corresponding finished assembly (ground truth) using BLAST+ (<xref rid="btad250-B6" ref-type="bibr">Camacho et al. 2009</xref>). Matches that span ˂95% of the contig length are discarded. Thus for each bin <italic toggle="yes">u</italic> predicted by a particular tool, we have a set of contigs <inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> included in the bin <italic toggle="yes">u</italic>, and for each ground-truth plasmid <italic toggle="yes">v</italic>, we have a set of contigs <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> that match (via BLAST+) to the ground-truth plasmid <italic toggle="yes">v</italic>. It should be noted that plasmidSPAdes is run on a different set of contigs than the other five methods. Thus, the sets of contigs representing the ground truth plasmids are different in case of plasmidSPAdes.</p>
      <p>For the two sets of contigs <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE124"><mml:math id="IM124" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we define <inline-formula id="IE125"><mml:math id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:mtext>overlap</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as either <inline-formula id="IE126"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> (in case of unweighted statistics) or the cumulative size in base pairs of all contigs in <inline-formula id="IE127"><mml:math id="IM127" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (in case of weighted statistics). Similarly, we define <inline-formula id="IE128"><mml:math id="IM128" display="inline" overflow="scroll"><mml:mrow><mml:mtext>size</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for a set of contigs <italic toggle="yes">X</italic> as either <inline-formula id="IE129"><mml:math id="IM129" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>X</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> (in case of unweighted statistics) or the cumulative size in base pairs of all contigs in <italic toggle="yes">X</italic> (in case of weighted statistics).</p>
      <p>In order to compute the precision, we assign to each predicted plasmid bin <italic toggle="yes">v</italic> one of the true plasmids <inline-formula id="IE130"><mml:math id="IM130" display="inline" overflow="scroll"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE131"><mml:math id="IM131" display="inline" overflow="scroll"><mml:mtext>overlap</mml:mtext><mml:mo>(</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>v</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:math></inline-formula> is maximized. The precision is then computed as <inline-formula id="IE132"><mml:math id="IM132" display="inline" overflow="scroll"><mml:mtext>overlap</mml:mtext><mml:mo>(</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>v</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>/</mml:mo><mml:mtext>size</mml:mtext><mml:mo>(</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>v</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:math></inline-formula>. Similarly, to compute the recall, we assign to each true plasmid <italic toggle="yes">u</italic> one of the predicted plasmid bins <inline-formula id="IE133"><mml:math id="IM133" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE134"><mml:math id="IM134" display="inline" overflow="scroll"><mml:mrow><mml:mtext>overlap</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is maximized. The recall is then computed as <inline-formula id="IE135"><mml:math id="IM135" display="inline" overflow="scroll"><mml:mrow><mml:mtext>overlap</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mtext>size</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>For a sample with a set <inline-formula id="IE136"><mml:math id="IM136" display="inline" overflow="scroll"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula> of predicted plasmid bins and <inline-formula id="IE137"><mml:math id="IM137" display="inline" overflow="scroll"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> of true plasmids, the mean precision for the sample is then computed as:
</p>
      <disp-formula id="E13">
        <mml:math id="M13" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mfrac>
              <mml:mrow>
                <mml:munder>
                  <mml:mo>∑</mml:mo>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mo>∈</mml:mo>
                    <mml:mi mathvariant="script">P</mml:mi>
                  </mml:mrow>
                </mml:munder>
                <mml:mrow>
                  <mml:mtext>overlap</mml:mtext>
                </mml:mrow>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>P</mml:mi>
                  </mml:mrow>
                  <mml:mi>v</mml:mi>
                </mml:msub>
                <mml:mo>,</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>T</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>f</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>v</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:munder>
                  <mml:mo>∑</mml:mo>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mo>∈</mml:mo>
                    <mml:mi mathvariant="script">P</mml:mi>
                  </mml:mrow>
                </mml:munder>
                <mml:mrow>
                  <mml:mtext>size</mml:mtext>
                </mml:mrow>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>P</mml:mi>
                  </mml:mrow>
                  <mml:mi>v</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
            </mml:mfrac>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>The mean recall for the sample is computed as:
</p>
      <disp-formula id="E14">
        <mml:math id="M14" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mfrac>
              <mml:mrow>
                <mml:munder>
                  <mml:mo>∑</mml:mo>
                  <mml:mrow>
                    <mml:mi>u</mml:mi>
                    <mml:mo>∈</mml:mo>
                    <mml:mi mathvariant="script">T</mml:mi>
                  </mml:mrow>
                </mml:munder>
                <mml:mrow>
                  <mml:mtext>overlap</mml:mtext>
                </mml:mrow>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>P</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>g</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>u</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>,</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>T</mml:mi>
                  </mml:mrow>
                  <mml:mi>u</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:munder>
                  <mml:mo>∑</mml:mo>
                  <mml:mrow>
                    <mml:mi>u</mml:mi>
                    <mml:mo>∈</mml:mo>
                    <mml:mi mathvariant="script">T</mml:mi>
                  </mml:mrow>
                </mml:munder>
                <mml:mrow>
                  <mml:mtext>size</mml:mtext>
                </mml:mrow>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>T</mml:mi>
                  </mml:mrow>
                  <mml:mi>u</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
            </mml:mfrac>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>The F1 measure for a sample is computed as a harmonic mean of mean precision and mean recall for that sample.</p>
    </sec>
    <sec>
      <title>3.3 Results</title>
      <p>For the set of 41 samples from species supported by gplas, we only consider contigs of length at least 1000 bp for our evaluation in order to be fair to gplas that has been evaluated with such a restriction in (<xref rid="btad250-B3" ref-type="bibr">Arredondo-Alonso et al. 2020</xref>). All contigs, irrespective of length, are considered for the evaluation of the remaining 25 samples.</p>
      <p><xref rid="btad250-T1" ref-type="table">Table 1</xref> shows both unweighted and weighted accuracy measures (mean precision, mean recall, and mean F1) for all considered tools averaged over the 41 testing samples, whereas <xref rid="btad250-F1" ref-type="fig">Figs 1</xref> and <xref rid="btad250-F2" ref-type="fig">2</xref> show the full distribution of these measures. We can observe that in the case of weighted measures, that consider only contigs of length at least 1000 bp, the accuracy of PlasBin-flow lags behind gplas as well as MOB-recon, which ranks as the best tool. PlasBin-flow show significant improvement over its HyAsP, PlasBin. and plasmidSPAdes and a comparable recall to gplas.</p>
      <fig position="float" id="btad250-F1">
        <label>Figure 1.</label>
        <caption>
          <p>Distribution of the unweighted precision, recall, and F1-score statistics for samples from three species supported by gplas.</p>
        </caption>
        <graphic xlink:href="btad250f1" position="float"/>
      </fig>
      <fig position="float" id="btad250-F2">
        <label>Figure 2.</label>
        <caption>
          <p>Distribution of the weighted precision, recall, and F1-score statistics for samples from three species supported by gplas.</p>
        </caption>
        <graphic xlink:href="btad250f2" position="float"/>
      </fig>
      <p>Unweighted (contig level) accuracy is a challenging measure, since short contigs have a higher contribution to these measures. Depending on the exact down-stream application, correct binning of shorter contigs may or may not be important. Shorter contigs are more difficult to classify and bin because corresponding sequence-based statistics have a higher variance and homology-based statistics are often non-informative. When considering unweighted accuracy measures, PlasBin-flow shows higher recall than gplas, which is especially selective in the choice of contigs. PlasmidSPAdes also shows high recall, but it suffers from many false predictions (low precision). MOB-suite performs the best overall.</p>
      <p><xref rid="btad250-T2" ref-type="table">Table 2</xref> compares both unweighted and weighted accuracy measures for the 25 testing samples that could not be analysed with gplas because they are from unsupported species. Unlike in the analysis of the first 41 samples, we consider all contigs in the evaluation as we do not evaluate gplas on these 25 samples. <xref rid="btad250-F3" ref-type="fig">Figures 3</xref> and <xref rid="btad250-F4" ref-type="fig">4</xref> show the full distribution of these measures. In the case of weighted accuracy measures, PlasBin-flow shows the best accuracy, but in terms of recall where it ranks second-best behind MOB-recon but shows a better combined F1 accuracy. A similar trend is observed for unweighted accuracy measures.</p>
      <fig position="float" id="btad250-F3">
        <label>Figure 3.</label>
        <caption>
          <p>Distribution of the unweighted precision, recall, and F1-score statistics for remaining 25 samples.</p>
        </caption>
        <graphic xlink:href="btad250f3" position="float"/>
      </fig>
      <fig position="float" id="btad250-F4">
        <label>Figure 4.</label>
        <caption>
          <p>Distribution of the weighted precision, recall, and F1-score statistics for remaining 25 samples.</p>
        </caption>
        <graphic xlink:href="btad250f4" position="float"/>
      </fig>
      <p>The performance of PlasBin-flow shows a marked improvement on the latter 25 samples. Compared to other methods, PlasBin-flow is able to leverage the information from the assembly graph and as a result, is able to bin short contigs with higher accuracy than other tools. Since the comparison of the 41 samples from the three species supported by gplas has only been done on contigs longer than 1000 bp (due to inability of gplas to classify shorter contigs), this illustrates that one of the main advantages of PlasBin-flow is how it handles short contigs, that are often numerous in a short-read assembly. In fact, when considering all contigs, PlasBin-flow (F1 accuracy 0.55) outperforms MOB-recon (F1 accuracy 0.45) even on the first 41 samples (refer to <xref rid="sup1" ref-type="supplementary-material">Supplementary Material Fig. S1</xref>).</p>
      <p>We provide in <xref rid="sup1" ref-type="supplementary-material">Supplementary Material Section S3</xref> additional figures that show the results of the considered tools for various thresholds of contigs minimum length.</p>
    </sec>
    <sec>
      <title>3.4 Computational footprint</title>
      <p>We ran our experiments on a standard laptop computer, with a quad-core processor and 16GB of memory. PlasBin-flow relies on an MILP, that typically requires large computing resources (time and memory), however, we could observe that PlasBin-flow has a very reasonable computational footprint. In terms of median and mean running times, the method was comparable to other methods such as HyAsP, MOB-recon, and gplas. Excluding a handful of samples that required around 2 hours of computation time, PlasBin-flow usually completed within a few minutes. Over all considered samples, PlasBin-flow had a maximum running time close to 2 h, with a memory footprint close to 6 GB (maximum 10 GB). Running time details are provided in <xref rid="btad250-T3" ref-type="table">Table 3</xref>.</p>
      <table-wrap position="float" id="btad250-T3">
        <label>Table 3.</label>
        <caption>
          <p>Running time statistics.<xref rid="tblfn3" ref-type="table-fn"><sup>a</sup></xref></p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Tool</th>
              <th rowspan="1" colspan="1">Minimum</th>
              <th rowspan="1" colspan="1">Maximum</th>
              <th rowspan="1" colspan="1">Median</th>
              <th rowspan="1" colspan="1">Mean</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">PlasBin-flow</td>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">120</td>
              <td rowspan="1" colspan="1">6</td>
              <td rowspan="1" colspan="1">6</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">PlasBin</td>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">473</td>
              <td rowspan="1" colspan="1">22</td>
              <td rowspan="1" colspan="1">117</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">HyAsP</td>
              <td rowspan="1" colspan="1">1</td>
              <td rowspan="1" colspan="1">19</td>
              <td rowspan="1" colspan="1">3</td>
              <td rowspan="1" colspan="1">4</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MOB-recon</td>
              <td rowspan="1" colspan="1">3</td>
              <td rowspan="1" colspan="1">15</td>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">8</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">gplas</td>
              <td rowspan="1" colspan="1">2</td>
              <td rowspan="1" colspan="1">12</td>
              <td rowspan="1" colspan="1">3</td>
              <td rowspan="1" colspan="1">4</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">plasmidSPAdes</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">363</td>
              <td rowspan="1" colspan="1">16</td>
              <td rowspan="1" colspan="1">43</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn5">
            <label>a</label>
            <p>Median, mean, minimum, and maximum running time (in minutes) recorded over the 66 test samples.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
  </sec>
  <sec>
    <title>4 Conclusion</title>
    <p>In this work, we presented PlasBin-flow, an MILP algorithm that uses network flows for grouping contigs into putative plasmid bins. We compared the results of PlasBin-flow against other state-of-the-art plasmid binning methods: HyAsP, plasmidSPAdes, MOB-recon, and gplas using two sets of metrics: weighted (basepair level) and unweighted (contig level). In both cases, PlasBin-flow consistently performed reasonably well in precision statistics. For samples belonging to <italic toggle="yes">E. coli</italic>, <italic toggle="yes">E. faecium</italic>, and <italic toggle="yes">K. pneumoniae</italic>, PlasBin-flow ranked behind MOB-recon and gplas in the average F1 scores. Gplas in particular had a distinct advantage over PlasBin-flow due to its use of species specific training sets. The performance of PlasBin-flow was markedly better on samples belonging to other species. PlasBin-flow was especially useful in binning contigs of short length, which are typically difficult to bin correctly.</p>
    <p>The objective function in PlasBin-flow is significantly changed from that used in PlasBin. The uniformity of %GC content along the contigs in a putative plasmid bin is achieved using a probabilistic model. The use of %GC content penalties discourages the choice of contigs disparate %GC content to be selected in the same bin. Another salient features of this method are the use of flow values as a proxy for read coverage used in a solution. The conditions necessary to maintain a consistent flow ensure the uniform read coverage in a plasmid bin without the need to explicitly compute the mean read coverage of the bin. The objective function used in our experiments assigned the same weight to the three terms it contains. This was a choice guided by a limited exploration of possible weights for each term (<xref rid="sup1" ref-type="supplementary-material">Supplementary Material Section S2</xref>). However, given the importance of the tuning dataset, e.g. to obtain the gene density of contigs, a different choice might be relevant for other datasets, that should result from exploring a grid of possible weights.</p>
    <p>In some instances, PlasBin-flow shows low recall. There are two possible explanations for low recall: misidentification and misbinning. In case of misidentification, PlasBin-flow may have failed to identify the contigs belonging to a true plasmid as part of any plasmid bin, e.g. due to the low gene density of a contig. On the other hand, misbinning occurs when a true plasmid is split into multiple bins output by PlasBin-flow. As a result, even if PlasBin-flow manages to identify relevant plasmid contigs, the recall statistics will only consider contigs placed in one of the bins, the contigs in other bins will not contribute toward recall. We further discuss splitting bins as a cause of low recall in (<xref rid="sup1" ref-type="supplementary-material">Supplementary Material Section S4</xref>).</p>
    <p>Through an exploration of the results obtained on our test dataset, we have determined that splitting of bins often occurs when groups of contigs belonging to the same plasmid are connected by a bridge of contigs with low plasmid gene densities. In future work, we will investigate possible remedies for this problem, including: (i) merging bins with similar GC content and coverage depth in post-processing; (ii) modifying the optimization function to provide positive rewards from more sources (at present, only contigs with high plasmid gene densities bring positive rewards); and (iii) building a more comprehensive database of plasmid genes. We expect such changes to further improve overall performance of PlasBin-flow.</p>
    <p>The method currently used for delayed constraint generation in the MILP may in some cases disregard the true optimal solution of the underlying optimization problem. We plan to refine the delayed constraint generation so that the added constraints would prevent flow in the disconnected components, rather than forbidding edges previously involved in disconnected components completely. This will guarantee that the optimal solution to the original optimization problem is found and may further help to prevent unnecessary bin splitting; on the other hand, such modification may require more iterations and may negatively affect the running time.</p>
    <p>It should be noted that bins generated by PlasBin-flow might not be walks. Ideally, a plasmid, or plasmid segment, should appear as a walk in the assembly graph. However PlasBin-flow computes connected subgraphs without looking explicitly for walks. The flow through the subgraph representing a bin can be seen as a proxy for a walk; however, the problem of extracting walks from a bin subgraph relates more to the actual assembly of plasmids than to the problem of binning and requires further attention.</p>
    <p>Our MILP formulation could also accommodate other contig features in its objective function such as including a probabilistic value from plasmid contig classification methods such as mlplasmids, or accounting for the presence of plasmid-specific genes (replicon genes e.g.). This avenue is among the ones we plan to explore further in order to improve the PlasBin-flow model.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad250_Supplementary_Data</label>
      <media xlink:href="btad250_supplementary_data.zip">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>PlasBin-Flow is open-source and available at <ext-link xlink:href="https://github.com/cchauve/PlasBin-flow" ext-link-type="uri">https://github.com/cchauve/PlasBin-flow</ext-link>. The database used in the experiments is also available in the same repository. The accession details for the samples as well as the output of all the methods used in the experiments can be accessed at <ext-link xlink:href="https://doi.org/10.5281/zenodo.7807303" ext-link-type="uri">https://doi.org/10.5281/zenodo.7807303</ext-link>.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This research was funded in part by the grants from (i) Slovak Research Agency VEGA [1/0538/22] (TV), and [1/0463/20] (BB), (ii) the European Union’s Horizon 2020 program under the Marie Skłodowska-Curie [grant agreement No. 872539] PANGAIA (TV, BB), and (iii) Genome Canada and the Natural Sciences and Engineering Research Council of Canada [RGPIN-03986] (CC).</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad250-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Andreopoulos</surname><given-names>WB</given-names></string-name>, <string-name><surname>Geller</surname><given-names>AM</given-names></string-name>, <string-name><surname>Lucke</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Deeplasmid: deep learning accurately separates plasmids from bacterial chromosomes</article-title>. <source>Nucleic Acids Res</source><year>2022</year>;<volume>50</volume>:<fpage>e17</fpage>–<lpage>e17</lpage>.<pub-id pub-id-type="pmid">34871418</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Antipov</surname><given-names>D</given-names></string-name>, <string-name><surname>Hartwick</surname><given-names>N</given-names></string-name>, <string-name><surname>Shen</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>plasmidSPAdes: assembling plasmids from whole genome sequencing data</article-title>. <source>Bioinformatics</source><year>2016</year>;<volume>32</volume>:<fpage>3380</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">27466620</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Arredondo-Alonso</surname><given-names>S</given-names></string-name>, <string-name><surname>Bootsma</surname><given-names>M</given-names></string-name>, <string-name><surname>Hein</surname><given-names>Y</given-names></string-name></person-group><etal>et al</etal><article-title>gplas: a comprehensive tool for plasmid analysis using short-read graphs</article-title>. <source>Bioinformatics</source><year>2020</year>;<volume>36</volume>:<fpage>3874</fpage>–<lpage>6</lpage>.<pub-id pub-id-type="pmid">32271863</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Arredondo-Alonso</surname><given-names>S</given-names></string-name>, <string-name><surname>Rogers</surname><given-names>MRC</given-names></string-name>, <string-name><surname>Braat</surname><given-names>JC</given-names></string-name></person-group><etal>et al</etal><article-title>Mlplasmids: a user-friendly tool to predict plasmid- and chromosome-derived sequences for single species</article-title>. <source>Microbial Genomics</source><year>2018</year>;<volume>4</volume>:<fpage>e000224</fpage>.<pub-id pub-id-type="pmid">30383524</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bankevich</surname><given-names>A</given-names></string-name>, <string-name><surname>Nurk</surname><given-names>S</given-names></string-name>, <string-name><surname>Antipov</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>Spades: a new genome assembly algorithm and its applications to single-cell sequencing</article-title>. <source>J Comput Biol</source><year>2012</year>;<volume>19</volume>:<fpage>455</fpage>–<lpage>77</lpage>.<pub-id pub-id-type="pmid">22506599</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Camacho</surname><given-names>C</given-names></string-name>, <string-name><surname>Coulouris</surname><given-names>G</given-names></string-name>, <string-name><surname>Avagyan</surname><given-names>V</given-names></string-name></person-group><etal>et al</etal><article-title>BLAST+: architecture and applications</article-title>. <source>BMC Bioinformatics</source><year>2009</year>;<volume>10</volume>:<fpage>421</fpage>.<pub-id pub-id-type="pmid">20003500</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Carattoli</surname><given-names>A.</given-names></string-name></person-group><article-title>Plasmids and the spread of resistance</article-title>. <source>Int J Med Microbiol</source><year>2013</year>;<volume>303</volume>:<fpage>298</fpage>–<lpage>304</lpage>.<pub-id pub-id-type="pmid">23499304</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>De Oliveira</surname><given-names>DMP</given-names></string-name>, <string-name><surname>Forde</surname><given-names>BM</given-names></string-name>, <string-name><surname>Kidd</surname><given-names>TJ</given-names></string-name></person-group><etal>et al</etal><article-title>Antimicrobial resistance in ESKAPE pathogens</article-title>. <source>Clin Microbiol Rev</source><year>2020</year>;<volume>33</volume>:<fpage>e00181</fpage>–<lpage>19</lpage>.<pub-id pub-id-type="pmid">32404435</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Dewar</surname><given-names>AE</given-names></string-name>, <string-name><surname>Thomas</surname><given-names>JL</given-names></string-name>, <string-name><surname>Scott</surname><given-names>TW</given-names></string-name></person-group><etal>et al</etal><article-title>Plasmids do not consistently stabilize cooperation across bacteria but may promote broad pathogen host-range</article-title>. <source>Nat Ecol Evol</source><year>2021</year>;<volume>5</volume>:<fpage>1624</fpage>–<lpage>36</lpage>.<pub-id pub-id-type="pmid">34750532</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gerner-Smidt</surname><given-names>P</given-names></string-name>, <string-name><surname>Besser</surname><given-names>J</given-names></string-name>, <string-name><surname>Concepción-Acevedo</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>Whole genome sequencing: bridging One-Health surveillance of foodborne diseases</article-title>. <source>Front Public Health</source><year>2019</year>;<volume>7</volume>:<fpage>172</fpage>.<pub-id pub-id-type="pmid">31316960</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Luo</surname><given-names>L</given-names></string-name>, <string-name><surname>Wang</surname><given-names>H</given-names></string-name>, <string-name><surname>Payne</surname><given-names>MJ</given-names></string-name></person-group><etal>et al</etal><article-title>Comparative genomics of Chinese and international isolates of <italic toggle="yes">Escherichia albertii</italic>: population structure and evolution of virulence and antimicrobial resistance</article-title>. <source>Microbial Genomics</source><year>2021</year>;<volume>7</volume>:<fpage>000710</fpage>.<pub-id pub-id-type="pmid">34882085</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B12">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Mane</surname><given-names>AC, Faizrahnemoon M, Chauve C.</given-names></string-name></person-group><part-title>A mixed integer linear programming algorithm for plasmid binning</part-title>. In: <person-group person-group-type="editor"><string-name><surname>Jin</surname><given-names>L.</given-names></string-name>, <string-name><surname>Durand</surname><given-names>D</given-names></string-name></person-group> (eds.), <source>Comparative Genomics - 19th International Conference, RECOMB-CG 2022, La Jolla, CA, USA, May 20–21, 2022, Proceedings</source>, Lecture Notes in Computer Science, Vol. <volume>13234</volume>. <publisher-loc>Berlin, Germany</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>2022</year>, <fpage>279</fpage>–<lpage>292</lpage>.</mixed-citation>
    </ref>
    <ref id="btad250-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Müller</surname><given-names>R</given-names></string-name>, <string-name><surname>Chauve</surname><given-names>C.</given-names></string-name></person-group><article-title>HyAsP, a greedy tool for plasmids identification</article-title>. <source>Bioinformatics</source><year>2019</year>;<volume>35</volume>:<fpage>4436</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">31116364</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Nishida</surname><given-names>H.</given-names></string-name></person-group><article-title>Comparative analyses of base compositions, DNA sizes, and dinucleotide frequency profiles in archaeal and bacterial chromosomes and plasmids</article-title>. <source>Int J Evol Biol</source><year>2012</year>;<volume>2012</volume>:<fpage>342482</fpage>.<pub-id pub-id-type="pmid">22536540</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Partridge</surname><given-names>SR</given-names></string-name>, <string-name><surname>Kwong</surname><given-names>SM</given-names></string-name>, <string-name><surname>Firth</surname><given-names>N</given-names></string-name></person-group><etal>et al</etal><article-title>Mobile genetic elements associated with antimicrobial resistance</article-title>. <source>Clin Microbiol Rev</source><year>2018</year>;<volume>31</volume>:<fpage>e00088</fpage>–<lpage>17</lpage>.<pub-id pub-id-type="pmid">30068738</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Pellow</surname><given-names>D</given-names></string-name>, <string-name><surname>Mizrahi</surname><given-names>I</given-names></string-name>, <string-name><surname>Shamir</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Plasclass improves plasmid sequence classification</article-title>. <source>PLoS Comput Biol</source><year>2020</year>;<volume>16</volume>:<fpage>e1007781</fpage>.<pub-id pub-id-type="pmid">32243433</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Robertson</surname><given-names>J</given-names></string-name>, <string-name><surname>Nash</surname><given-names>J.</given-names></string-name></person-group><article-title>MOB-suite: software tools for clustering, reconstruction and typing of plasmids from draft assemblies</article-title>. <source>Microbial Genomics</source><year>2018</year>;<volume>4</volume>:<fpage>e000206</fpage>.<pub-id pub-id-type="pmid">30052170</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rozov</surname><given-names>R</given-names></string-name>, <string-name><surname>Brown Kav</surname><given-names>A</given-names></string-name>, <string-name><surname>Bogumil</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>Recycler: an algorithm for detecting plasmids from de novo assembly graphs</article-title>. <source>Bioinformatics</source><year>2017</year>;<volume>33</volume>:<fpage>475</fpage>–<lpage>82</lpage>.<pub-id pub-id-type="pmid">28003256</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Souvorov</surname><given-names>A</given-names></string-name>, <string-name><surname>Agarwala</surname><given-names>R</given-names></string-name>, <string-name><surname>Lipman</surname><given-names>DJ</given-names></string-name></person-group><etal>et al</etal><article-title>SKESA: strategic k-mer extension for scrupulous assemblies</article-title>. <source>Genome Biol</source><year>2018</year>;<volume>19</volume>:<fpage>153</fpage>.<pub-id pub-id-type="pmid">30286803</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Struelens</surname><given-names>MJ</given-names></string-name>, <string-name><surname>Sintchenko</surname><given-names>V.</given-names></string-name></person-group><article-title>Editorial: pathogen genomics: empowering infectious disease surveillance and outbreak investigations</article-title>. <source>Front Public Health</source><year>2020</year>;<volume>8</volume>:<fpage>179</fpage>.<pub-id pub-id-type="pmid">32509718</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tedersoo</surname><given-names>L</given-names></string-name>, <string-name><surname>Albertsen</surname><given-names>M</given-names></string-name>, <string-name><surname>Anslan</surname><given-names>S</given-names></string-name></person-group><etal>et al</etal><article-title>Perspectives and benefits of high-throughput long-read sequencing in microbial ecology</article-title>. <source>Appl Environ Microbiol</source><year>2021</year>;<volume>87</volume>:<fpage>e0062621</fpage>.<pub-id pub-id-type="pmid">34132589</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>van der Graaf-van Bloois</surname><given-names>L</given-names></string-name>, <string-name><surname>Wagenaar</surname><given-names>JA</given-names></string-name>, <string-name><surname>Zomer</surname><given-names>AL</given-names></string-name></person-group><etal>et al</etal><article-title>RFPlasmid: predicting plasmid sequences from short-read assembly data using machine learning</article-title>. <source>Microbial Genomics</source><year>2021</year>;<volume>7</volume>:<fpage>000683</fpage>.<pub-id pub-id-type="pmid">34846288</pub-id></mixed-citation>
    </ref>
    <ref id="btad250-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wick</surname><given-names>RR</given-names></string-name>, <string-name><surname>Judd</surname><given-names>LM</given-names></string-name>, <string-name><surname>Gorrie</surname><given-names>CL</given-names></string-name></person-group><etal>et al</etal><article-title>Unicycler: resolving bacterial genome assemblies from short and long sequencing reads</article-title>. <source>PLoS Comput Biol</source><year>2017</year>;<volume>13</volume>:<fpage>e1005595</fpage>.<pub-id pub-id-type="pmid">28594827</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
