<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3436807</article-id>
    <article-id pub-id-type="pmid">22962448</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/bts380</article-id>
    <article-id pub-id-type="publisher-id">bts380</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group>
          <subject>Sequencing and Sequence Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Indel-tolerant read mapping with trinucleotide frequencies using cache-oblivious <italic>kd</italic>-trees</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Mahmud</surname>
          <given-names>Md Pavel</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="COR1">
          <sup>*</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Wiedenhoeft</surname>
          <given-names>John</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Schliep</surname>
          <given-names>Alexander</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="AFF2">
          <sup>2</sup>
        </xref>
        <xref ref-type="corresp" rid="COR1">
          <sup>*</sup>
        </xref>
      </contrib>
    </contrib-group>
    <aff id="AFF1"><sup>1</sup> Department of Computer Science</aff>
    <aff id="AFF2"><sup>2</sup> BioMaPS Institute for Quantitative Biology, Rutgers University, New Jersey, USA</aff>
    <author-notes>
      <corresp id="COR1">*To whom correspondence should be addressed.</corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>9</month>
      <year>2012</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>3</day>
      <month>9</month>
      <year>2012</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>3</day>
      <month>9</month>
      <year>2012</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>28</volume>
    <issue>18</issue>
    <issue-title>ECCB 2012 PROCEEDINGS PAPERS COMMITTEE SEPTEMBER 9 TO SEPTEMBER 12, 2012, CONFERENCE CENTER BASEL, SWITZERLAND</issue-title>
    <fpage>i325</fpage>
    <lpage>i332</lpage>
    <permissions>
      <copyright-statement>© The Author(s) (2012). Published by Oxford University Press.</copyright-statement>
      <copyright-year>2012</copyright-year>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/3.0">
        <license-p><!--CREATIVE COMMONS-->This is an Open Access article distributed under the terms of the Creative Commons Attribution License <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/3.0">http://creativecommons.org/licenses/by/3.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> Mapping billions of reads from next generation sequencing experiments to reference genomes is a crucial task, which can require hundreds of hours of running time on a single CPU even for the fastest known implementations. Traditional approaches have difficulties dealing with matches of large edit distance, particularly in the presence of frequent or large insertions and deletions (indels). This is a serious obstacle both in determining the spectrum and abundance of genetic variations and in personal genomics.</p>
      <p><bold>Results:</bold> For the first time, we adopt the approximate string matching paradigm of <italic>geometric embedding</italic> to read mapping, thus rephrasing it to nearest neighbor queries in a <italic>q</italic>-gram frequency vector space. Using the <italic>L</italic><sub>1</sub> distance between frequency vectors has the benefit of providing lower bounds for an edit distance with affine gap costs. Using a cache-oblivious <italic>kd</italic>-tree, we realize running times, which match the state-of-the-art. Additionally, running time and memory requirements are about constant for read lengths between 100 and 1000 bp. We provide a first proof-of-concept that geometric embedding is a promising paradigm for read mapping and that <italic>L</italic><sub>1</sub> distance might serve to detect structural variations. TreQ, our initial implementation of that concept, performs more accurate than many popular read mappers over a wide range of structural variants.</p>
      <p><bold>Availability and implementation:</bold> TreQ will be released under the GNU Public License (GPL), and precomputed genome indices will be provided for download at <ext-link ext-link-type="uri" xlink:href="http://treq.sf.net">http://treq.sf.net</ext-link>.</p>
      <p>
        <bold>Contact:</bold>
        <email>pavelm@cs.rutgers.edu</email>
      </p>
      <p><bold>Supplementary information:</bold><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/bts380/DC1">Supplementary data</ext-link> are available at <italic>Bioinformatics</italic> online.</p>
    </abstract>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec id="SEC1">
    <title>1 INTRODUCTION</title>
    <p>The possibility to re-sequence genomes rapidly and cost-efficiently using next generation sequencing (NGS) technologies has provided fascinating insights into the breadth and prevalence of human genetic variation (The 1000 Genomes Project Consortium, 2010; <xref ref-type="bibr" rid="B51">The International HapMap Consortium, 2005</xref>), in particular the abundance of structural variants—we will jointly refer to them as insertion and deletions (indels) and not distinguish, for example between novel sequence insertions and duplications. Unfortunately, these structural variants, more exactly short indels, are complicating the first step in the analysis, mapping DNA sequencing reads to reference genomes.</p>
    <p>This is surprising, as approximate string matching, the theoretical problem underlying read mapping, is arguably one of the most fundamental problem in bioinformatics and a very well-studied area in data mining; for surveys see <xref ref-type="bibr" rid="B9">Boytsov (2011b)</xref>; <xref ref-type="bibr" rid="B39">Navarro (2001)</xref>. Mapping reads from DNA sequencing experiments requires solving approximate string matching problems for billions of short DNA sequences of length 20–500 bp against entire genomes. There have been a multitude of methods proposed—see for example the benchmarks performed by <xref ref-type="bibr" rid="B19">Hach <italic>et al.</italic> (2010)</xref>—and the results and optimal choice of method depend strongly on the read length and the maximal edit distance allowed.</p>
    <p>Out of the variety of different approaches [see <xref ref-type="bibr" rid="B8">Boytsov (2011a)</xref> for a detailed taxonomy] proposed for approximate string matching, current read mappers rely on only three different paradigms (<xref ref-type="bibr" rid="B31">Li and Homer, 2010</xref>): seed-and-extend (encompassing hash tables and <italic>q</italic>-gram filtering), prefix/suffix tries (using the Burrows–Wheeler transform) and one approach based on merge sort (<xref ref-type="bibr" rid="B35">Malhis and Jones, 2010</xref>). Their computational efficiency depends on the existence of exact matches between the read and the genome.</p>
    <p>Intuitively, there cannot be an approximate match of small edit distance between a read and the genome if not one or several exact matches of length <italic>q</italic> exist. The relationship between the presence of such matching <italic>q</italic>-grams (sequence of length <italic>q</italic>) and the edit distance was revealed in a seminal paper by <xref ref-type="bibr" rid="B52">Ukkonen (1992)</xref>: a lower bound for the edit distance between two strings is given by the <italic>L</italic><sub>1</sub> distance between their count vectors of <italic>q</italic>-grams (for <italic>q</italic>=3 these are the trinucleotide frequency vectors). This provides the basis for a seed-extend strategy of using efficient algorithms for finding one initial exact <italic>q</italic>-gram match, exploring whether additional exact <italic>q</italic>-gram matches support the existence of an approximate match, <xref ref-type="fig" rid="F1">Figure 1</xref> (left), and then use an efficient alignment algorithm, such as Myers' bit-vector algorithm (<xref ref-type="bibr" rid="B38">Myers, 1999</xref>), to verify and assess the quality of the match. Existing methods either implement this idea of <italic>q</italic>-gram filtering (<xref ref-type="bibr" rid="B41">Navarro <italic>et al.</italic>, 2005</xref>) directly (<xref ref-type="bibr" rid="B56">Weese <italic>et al.</italic>, 2009</xref>), or implicitly rely on it (<xref ref-type="bibr" rid="B30">Li and Durbin, 2009</xref>).
<fig id="F1" position="float"><label>Fig. 1.</label><caption><p>Most approaches to approximate string matching using Ukkonen's <italic>q</italic>-gram lemma rely on the existence of reasonably large <italic>q</italic>-grams which are exact matches between pattern and text. These can be found efficiently with a number of techniques and yield putative hits, which are then evaluated using an alignment algorithm. For each pattern and each putative hit, the number of shared <italic>q</italic>-grams is evaluated <italic>de novo</italic> (left). We map both reads and genome locations to vectors of 2-gram frequencies and identify approximate matches finding nearest neighbors (right). This is accelerated by the use of a spatial index structure, e.g. a <italic>kd</italic>-tree, which is created by recursively partitioning the input space around the median value of a dimension.</p></caption><graphic xlink:href="bts380f1"/></fig>
</p>
    <p>The running times depend on the maximal edit distance permitted: smaller maximal edit distance allows to chose larger <italic>q</italic>, thus there will be fewer exact <italic>q</italic>-gram matches and putative approximate matches to explore; indeed their probability decreases exponentially. If we think of patterns being derived from a match in the text through edit operations of technical nature (sequencing errors), or biological nature (genetic variants), the probability of hitting all <italic>q</italic>-grams and thus rendering <italic>q</italic>-gram filtering useless increases with the number of edits (<xref ref-type="bibr" rid="B48">Sutinen and Szpankowski, 1998</xref>). Gapped <italic>q</italic>-grams (<xref ref-type="bibr" rid="B11">Burkhardt and Kärkkäinen, 2002</xref>), requiring exact matches in a fixed pattern of <italic>q</italic> out of <italic>q</italic>′ &gt; <italic>q</italic> positions, are one way of addressing this. Most popular approaches, however, strictly limit the maximal edit distance and use heuristics to keep running time in check at the potential cost of missing best matches.</p>
    <p>In particular, the detection of indels suffers from the limits on edit distance of matches. As our results show, many of the existing methods have problems in mapping 100 bp reads with indels to the reference genome; longer reads improve the situation for some approaches. Consequently, the state-of-the-art in the detection of structural variants is the use of paired-end read libraries and advanced methods for performing downstream analysis after mapping the paired-end read libraries to reference genomes (<xref ref-type="bibr" rid="B13">Chen <italic>et al.</italic>, 2009</xref>; <xref ref-type="bibr" rid="B21">Hormozdiari <italic>et al.</italic>, 2009</xref>, <xref ref-type="bibr" rid="B22">2010</xref>; <xref ref-type="bibr" rid="B26">Korbel <italic>et al.</italic>, 2009</xref>; <xref ref-type="bibr" rid="B28">Lee <italic>et al.</italic>, 2009</xref>). Nevertheless, <xref ref-type="bibr" rid="B3">Alkan <italic>et al.</italic> (2011)</xref> noted that in particular detection of small, 5–50 bp indels, is a largely open problem, although our analysis reveals that one recent approach, Stampy (<xref ref-type="bibr" rid="B34">Lunter and Goodson, 2011</xref>), provides excellent sensitivity. In the detection of such short indels, the deviations from mean insert length are measured, and thus, the sequencing coverage required to arrive at statistical significance is inversely proportional to the indel length. Our results will show that the detection of 1–16 bp indels from single reads is possible using <italic>L</italic><sub>1</sub> distance.</p>
    <p>We pursue a different strategy from current read mappers, following ideas first proposed for protein sequences (<xref ref-type="bibr" rid="B10">Bugnion <italic>et al.</italic>, 1995</xref>) and generally referred to as vector space frequency distance methods (<xref ref-type="bibr" rid="B9">Boytsov, 2011b</xref>), embedding strings as <italic>q</italic>-gram frequency vectors. These geometric embeddings have not yet made their way into read mapping, unlike other areas of bioinformatics, for example in the estimation of bacterial species phylogeny through oligonucleotide frequency distances (<xref ref-type="bibr" rid="B49">Takahashi <italic>et al.</italic>, 2009</xref>), under the name of <italic>k</italic>-spectra in classifying protein sequences using support vector machines (<xref ref-type="bibr" rid="B29">Leslie <italic>et al.</italic>, 2002</xref>) or in alignment-free sequence comparisons (<xref ref-type="bibr" rid="B17">Goke <italic>et al.</italic>, 2012</xref>; <xref ref-type="bibr" rid="B33">Liu <italic>et al.</italic>, 2011</xref>; <xref ref-type="bibr" rid="B46">Reinert <italic>et al.</italic>, 2009</xref>; <xref ref-type="bibr" rid="B55">Wan <italic>et al.</italic>, 2010</xref>).</p>
    <p>We choose <italic>q</italic> = 3 and consider vectors of all trinucleotide frequencies, by embedding reads of length between 100 and 1000 bp as vectors in ℝ<sup>64</sup>. The problem of finding a minimal edit distance approximate match now becomes the problem of finding a nearest neighbor in a data set of vectors derived from a genome by sliding a window over the genome and mapping the sequence to a frequency vector, <xref ref-type="fig" rid="F1">Figure 1</xref> (right). Finding (approximate) nearest neighbors, however, has been well studied and a large range of spatial index data structures have been proposed (<xref ref-type="bibr" rid="B5">Berchtold <italic>et al.</italic>, 1996</xref>; <xref ref-type="bibr" rid="B6">Bern, 1993</xref>; <xref ref-type="bibr" rid="B24">Katayama and Satoh, 1998</xref>; <xref ref-type="bibr" rid="B47">Sellis <italic>et al.</italic>, 1987</xref>) generally leading to <italic>O</italic>(<italic>n</italic>log<italic>n</italic>) complexity for construction of the spatial index and <italic>O</italic>(log<italic>n</italic>) complexity for nearest neighbor queries, where <italic>n</italic> denotes the number of points in the index. Empirical running times, however, vary widely based on the detailed structure of the problem instance, and thus, algorithm engineering is important for achieving competitive running times.</p>
    <p>The vector space frequency distance method introduced in <xref ref-type="bibr" rid="B10">Bugnion <italic>et al.</italic> (1995)</xref> was not further pursued except in a small scale study focusing on different ways to map strings to vectors (<xref ref-type="bibr" rid="B43">Ozturk and Ferhatosmanoglu, 2003</xref>, <xref ref-type="bibr" rid="B44">2005</xref>). In recent years, researchers in databases, both multi-media and text, investigated indices in high-dimensional spaces (<xref ref-type="bibr" rid="B7">Böhm <italic>et al.</italic>, 2001</xref>; <xref ref-type="bibr" rid="B12">Bustos and Navarro, 2009</xref>; <xref ref-type="bibr" rid="B23">Houle and Sakuma, 2005</xref>; <xref ref-type="bibr" rid="B40">Navarro and Chávez, 2006</xref>; <xref ref-type="bibr" rid="B57">Yao <italic>et al.</italic>, 2010</xref>), but the small alphabet size of DNA that leads to non-sparse frequency vectors preclude their use here. <xref ref-type="bibr" rid="B9">Boytsov (2011b)</xref> implemented and evaluated a range of different approaches in approximate string matching also on DNA datasets which are of small bacterial genome size (3.2 megabasepair). We found that his findings do not translate when the genome size increases by a factor of 1000. For instance the effects of cache or page misses, which motivate cache-oblivious data structures that guarantee minimum number of cache misses irrespective of cache size and memory hierarchy, are simply not observable on small data sets. During the development of the method, we used state-of-the-art <italic>kd</italic>-tree libraries (<xref ref-type="bibr" rid="B36">Mount and Arya, 2010</xref>; <xref ref-type="bibr" rid="B37">Muja and Lowe, 2009</xref>) but found them to be lacking in performance once the index contained more than a few million points. Indeed, on genome-size problems, the ability to effectively implement data structures in a cache-oblivious manner is more important than computational complexity.</p>
    <p>In the following sections, we will show how <italic>L</italic><sub>1</sub> distance serves as a lower bound for affine gap costs, introduces our methodology and implementation details and provides detailed analysis on both real and simulated data to show the advantages and drawbacks of geometric embeddings.</p>
  </sec>
  <sec id="SEC2">
    <title>2 METHODS</title>
    <p>We use the usual notation, following (<xref ref-type="bibr" rid="B18">Gusfield, 1997</xref>): A finite set of characters ∑ = {<italic>a,b,c,...</italic>} we will call an alphabet and a sequence <italic>s</italic> of characters from ∑ a string. We denote by |<italic>s</italic>| its length, by <italic>s<sub>i</sub></italic> its <italic>i</italic>-th character, <italic>i</italic> &gt; 0, and by <italic>s</italic>[<italic>i,j</italic>] the continuous sub-string starting at position <italic>i</italic> and ending in position <italic>j</italic>.</p>
    <p>We associate strings with vectors by computing the frequencies of all <italic>q</italic>-grams,
<disp-formula id="M1"><label>(1)</label><graphic xlink:href="bts380m1"/></disp-formula>
which define a map from ∑* → ℝ<sup>|∑|<italic><sup>q</sup></italic></sup> through <italic>s</italic> ↦ <italic>c<sub>q</sub></italic> (<italic>s</italic>). We assume that the <italic>q</italic>-words are in lexicographic order.</p>
    <p>D<sc>efinition</sc> 1. <italic>The edit distance</italic> ED(<italic>s,t</italic>) <italic>between two strings s and t is determined by the minimal number of edit operations—substitutions, insertions and deletions—necessary to transform one into another. We can notate the edit operations as rewriting rules, a → ∈ is a deletion, ∈ → a an insertion and a → b a substitution. Here, a,b ∈∑, a ≠ b and ∈ is the empty string. What is usually referred to as</italic> the <italic>edit distance is indeed the Levenshtein distance which assigns unit costs to the three possible operation. This of course generalizes to arbitrary costs c<sub>s</sub></italic>,<italic> c<sub>i</sub> and c<sub>d</sub> for substitutions, insertions and deletions, respectively.</italic></p>
    <p>Similarly we obtain a distance from the <italic>q</italic>-spectrum by considering the <italic>L</italic><sub>1</sub> distance of the count vectors in ℝ<sup>|∑|<italic><sup>q</sup></italic></sup>, <italic>L</italic><sub>1</sub>(<italic>s,t</italic>):=|<italic>c<sub>q</sub></italic> (<italic>s</italic>)–<italic>c<sub>q</sub></italic> (<italic>t</italic>)|.</p>
    <p>T<sc>heorem</sc> 1 (Ukkonnen (<xref ref-type="bibr" rid="B52">Ukkonen, 1992</xref>)). <italic>For s,t ∈</italic> ∑<italic><sup>q</sup></italic>
<disp-formula id="M2"><label>(2)</label><graphic xlink:href="bts380m2"/></disp-formula></p>
    <p>Note that the bound can become arbitrarily bad, for example when <italic>t</italic> is a rotation or transposition of <italic>s</italic>, see <xref ref-type="bibr" rid="B52">Ukkonen (1992)</xref>.</p>
    <sec id="SEC2.1">
      <title>2.1 The <italic>q</italic>-gram lemma revisited</title>
      <p>Ukkonen's lemma states that <italic>L</italic><sub>1</sub> ≤ 2<italic>q</italic>ED, but this bound is dominated by the mismatches. It is worthwhile to consider the effects of mismatches and indels separately. Consider two strings <italic>S</italic><sub>1</sub> and <italic>S</italic><sub>2</sub>, where <italic>S</italic><sub>2</sub> is derived by a single deletion of size <italic>d</italic> from <italic>S</italic><sub>1</sub> or by insertion vice versa. Then the <italic>L</italic><sub>1</sub> distance comprised two components. First, the number of <italic>q</italic>-grams spanning the gap in <italic>S</italic><sub>2</sub> is <italic>q</italic>–1. Second, for <italic>S</italic><sub>1</sub>, the first character in the deletion accounts for <italic>q</italic> deletions of <italic>q</italic>-grams; however, every consecutive character only accounts for one, as the other <italic>q</italic> – 1 are already accounted for by deleting the left neighbor. Hence, the <italic>L</italic><sub>1</sub> distance is bounded by <italic>L</italic><sub>1</sub> ≤ 2<italic>q</italic>+<italic>d</italic> – 2. As a single mismatch can affect at most 2<italic>q</italic> number of different <italic>q</italic>-grams, it follows that for <italic>m</italic> mismatches and <italic>g</italic> gaps of size <italic>d<sub>i</sub></italic>, 1 ≤ <italic>i</italic> ≤ <italic>g</italic>,
<disp-formula id="M3"><label>(3)</label><graphic xlink:href="bts380m3"/></disp-formula>
As ∑<sub><italic>i</italic>=1</sub><sup><italic>g</italic></sup>
<italic>d<sub>i</sub></italic> + <italic>m</italic> = ED, we obtain
<disp-formula id="M4"><label>(4)</label><graphic xlink:href="bts380m4"/></disp-formula>
This shows that the number <italic>g</italic> of contiguous gaps (not the total number of gapped positions), provides a sharper bound than the number of mismatched positions. For example, if ED = 4 and <italic>q</italic> = 3, then <italic>L</italic><sub>1</sub> ≤ 8 for a single indel of size 4, but <italic>L</italic><sub>1</sub> ≤ 24 for four mismatches. Any algorithms based on nearest neighbors under <italic>L</italic><sub>1</sub> distance is thus very well suited for mapping reads with large indels.</p>
      <p>Apreference for large indels in alignments is biologically more meaningful than alignments with many small indels and generally addressed by using affine gap costs. The above formula naturally implies a scoring scheme for an affine edit distance AED(<italic>s,t</italic>). As
<disp-formula id="M5"><label>(5)</label><graphic xlink:href="bts380m5"/></disp-formula>
we obtain
<disp-formula id="M6"><label>(6)</label><graphic xlink:href="bts380m6"/></disp-formula>
for gap opening cost <italic>c<sub>o</sub></italic> := 2<italic>q</italic>–1, gap extension cost <italic>c<sub>e</sub></italic> := 1 and substitution cost <italic>c<sub>s</sub></italic> := 2<italic>q</italic>.</p>
      <p>For edit operations that affect positions <italic>q</italic> letters apart, it is easy to show that the inequality is sharp, that is <italic>L</italic><sub>1</sub> gives the edit distance with affine gap costs. Consequently, finding matches of minimal <italic>L</italic><sub>1</sub> prefers matches with fewer indels over matches with frequent substitutions. However, the lower bound can be still arbitrarily bad (see previous section), but the probability of catastrophic failure is small (see the Analysis in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/bts380/DC1">Supplementary Materials</ext-link>). Indeed the probability of <italic>L</italic><sub>1</sub> distance being zero in the presence of one deletion of length <italic>k</italic> is
<disp-formula id="M7"><label>(7)</label><graphic xlink:href="bts380m7"/></disp-formula>
where <italic>P</italic><sub>2</sub><sup>*</sup> is the maximal transition probability in the Markov chain assumed to have generated reads and genome. See <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/bts380/DC1">Supplementary Material</ext-link> for details.</p>
    </sec>
    <sec id="SEC2.2">
      <title>2.2 Read mapping with cache-oblivious <italic>kd</italic>-trees</title>
      <p>Efficient searches for exact or inexact nearest neighbors in high dimensions generally involve creating a tree-like index structure that recursively partitions the space. Their efficiency depends on the quality of the index and the geometric distributions of points. A comparative study (<xref ref-type="bibr" rid="B25">Kibriya and Frank, 2007</xref>) showed that in a wide range of practical instances <italic>kd</italic>-trees outperform more advanced methods (<xref ref-type="bibr" rid="B5">Berchtold <italic>et al.</italic>, 1996</xref>; <xref ref-type="bibr" rid="B6">Bern, 1993</xref>; <xref ref-type="bibr" rid="B24">Katayama and Satoh, 1998</xref>; <xref ref-type="bibr" rid="B47">Sellis <italic>et al.</italic>, 1987</xref>).</p>
      <p>In the index generation, for each sub-tree of the <italic>kd</italic>-tree, a dimension—usually the one with the highest variance—is chosen, and then the set of points under the sub-tree is partitioned using the median value of the chosen dimension as pivot. This process continues recursively and eventually completes in <italic>O</italic>(<italic>dn</italic>log<italic>n</italic>) time for <italic>n d</italic>-dimensional points. During the search, a query point's coordinates are compared with the pivot, and a decision to search the left or right sub-tree is made. If there is no exact match to be found, the search procedure backtracks.</p>
      <p>As the index size gets larger, the effect of cache misses becomes very prominent and the running time increases substantially. As a result, over the last decade, many important data structures including <italic>kd</italic>-trees were made cache-oblivious (<xref ref-type="bibr" rid="B1">Agarwal <italic>et al.</italic>, 2003</xref>; <xref ref-type="bibr" rid="B15">Frigo <italic>et al.</italic>, 1999</xref>). Our cache-oblivious <italic>kd</italic>-tree implementation stores the tree in sequential memory using the van Emde Boas layout (<xref ref-type="bibr" rid="B53">van Emde Boas, 1975</xref>; <xref ref-type="bibr" rid="B54">van Emde Boas <italic>et al.</italic>, 1976</xref>), which guarantees an optimal number of cache misses.</p>
      <p>We have implemented the following modification to the usual <italic>kd</italic>-tree construction. During index generation, we use pre-selected dimensions based on the entropy of the dimensions over the full data set, which makes the index building step <italic>O</italic>(<italic>n</italic>log<italic>n</italic>) instead of finding the dimension with highest variance. The minimal axis-parallel hyper-rectangle containing all the points in the subtree defines a bounding box per subtree. These bounding boxes help to reduce the search space at the cost of increasing the index generation to <italic>O</italic>(<italic>dn</italic>log<italic>n</italic>). In the search step, we compute lower bounds for the <italic>L</italic><sub>1</sub> distance between the query point and all the points inside the bounding box of the left and right sub-tree in <italic>O</italic>(<italic>d</italic>) time at every subtree. We proceed with the sub-tree giving the best lower bound and store the other sub-tree for future consideration. If no exact match is found the search process becomes expensive. We bound the number of alternate paths searched per query with the parameter <italic>β</italic>, which bounds the running time per query to <italic>O</italic>(<italic>βd</italic> log<italic>n</italic>).</p>
      <p>In the bottom levels, the running time overhead to find lower bounds using the bounding boxes is comparable with directly computing the <italic>L</italic><sub>1</sub> distances. Thus, for the last <italic>τ</italic> levels, we do not create bounding boxes, and in the search step, we simply compute the <italic>L</italic><sub>1</sub> distances between the query point and the points in the sub-tree (we use fast hardware accelerated <italic>L</italic><sub>1</sub> distance computation). This also decreases memory requirement to store the tree by 2<italic><sup>τ</sup></italic> times.</p>
      <sec id="SEC2.2.1">
        <title>2.2.1 Verification by Myers' Bitvector algorithm</title>
        <p>Using Myers' bit-vector algorithm (<xref ref-type="bibr" rid="B38">Myers, 1999</xref>), we compute the edit distance and the exact location for each read based on putative locations identified as nearest neighbors, adding a slack of 14 bp on each boundary. The best position is reported, breaking ties arbitrarily.</p>
      </sec>
      <sec id="SEC2.2.2">
        <title>2.2.2 Parameter choices</title>
        <p>Parameter <italic>β</italic>, the maximum number of different paths explored in the search, controls the running time and sensitivity of TreQ. However, this does not restrict the maximal edit distance of matches in contrast to trie-based methods which avoid exponential blow-up with such restrictions. A second parameter, <italic>τ</italic> influences the memory footprint and running times, as the lowest <italic>τ</italic> levels of the cache-oblivious <italic>kd</italic>-tree are not stored and rather direct <italic>L</italic><sub>1</sub> distance computations are performed. To further reduce memory requirements, the genomic window is shifted by <italic>g</italic> base pairs to create <italic>d</italic>-dimensional (<italic>d</italic> = 4<italic><sup>q</sup></italic>) frequency vectors (final match positions are based on Myers' alignment). A third parameter <italic>α</italic>, determines number of vectors for which we only store the changes from a nearby point as they can be constructed with minimal overhead from their differences in few dimensions from the (2<italic>α</italic>+1)-<italic>th</italic> point which is actually stored (see <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/bts380/DC1">Supplementary Material</ext-link> for a detailed explanation). In our experiments we have found <italic>g</italic> = 3, <italic>α</italic> = 2, <italic>β</italic> = 3000 and <italic>τ</italic> = 3 to be a good choice for the human genome, and unless otherwise stated these are the default parameter values for TreQ. Note that for a wide range of parameter choices TreQ's accuracy remains effectively the same (cf. <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/bts380/DC1">Supplementary Figure S2</ext-link>). In contrast, most popular read mappers have large number of parameters, which are specifically tuned for typical datasets and often very difficult to optimize.</p>
      </sec>
    </sec>
  </sec>
  <sec id="SEC3">
    <title>3 DISCUSSION</title>
    <p>To evaluate TreQ and compare its performance, we ran a number of read mappers–Bowtie (<xref ref-type="bibr" rid="B27">Langmead <italic>et al.</italic>, 2009</xref>), BWA (<xref ref-type="bibr" rid="B30">Li and Durbin, 2009</xref>), SOAP2 (<xref ref-type="bibr" rid="B30">Li <italic>et al.</italic>, 2009</xref>), mrFAST (<xref ref-type="bibr" rid="B2">Alkan <italic>et al.</italic>, 2009</xref>), Novoalign (<ext-link ext-link-type="uri" xlink:href="http://www.novocraft.com">http://www.novocraft.com</ext-link>), SSAHA2 (<xref ref-type="bibr" rid="B42">Ning <italic>et al.</italic>, 2001</xref>), LAST (<xref ref-type="bibr" rid="B16">Frith <italic>et al.</italic>, 2010</xref>; <xref ref-type="bibr" rid="B20">Hamada <italic>et al.</italic>, 2011</xref>), Stampy (<xref ref-type="bibr" rid="B34">Lunter and Goodson, 2011</xref>) and RazerS (<xref ref-type="bibr" rid="B56">Weese <italic>et al.</italic>, 2009</xref>)–on simulated and real read datasets (see <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/bts380/DC1">Supplementary Tables S1</ext-link> for version numbers). These read mappers were evaluated with their default and, in some cases, customized parameters for allowing maximal permissible edit distance. We also forced them to report one single best hit. For TreQ, parameters <italic>q</italic> = 3, <italic>d</italic> = 64(= 4<italic><sup>q</sup></italic>), <italic>g</italic> = 3 and <italic>k</italic> = 200 were fixed throughout the experiments. Currently, quality scores are ignored in the match evaluation phase of TreQ. For simulated data, we define accuracy as the percentage of reads mapped to the actual genomic locations from where they were sampled (<xref ref-type="fig" rid="F2">Fig. 2</xref>). We use human genome HG18 build 36 as the reference for all the experiments.
<fig id="F2" position="float"><label>Fig. 2.</label><caption><p>Comparison of popular read mappers with TreQ. Accuracy is defined as the percentage of single best reads that are mapped to the exact genomic location they were drawn from in the simulation. Notice that TreQ outperforms most popular read mappers and is mostly on par with LAST</p></caption><graphic xlink:href="bts380f2"/></fig>
</p>
    <sec sec-type="methods" id="SEC3.1">
      <title>3.1 Simulated data</title>
      <p>We simulated four different read data sets, comprising a set of different model parameters, each by sampling 10 000 reads from the human reference genome. Given read length ℓ, we have:
<list list-type="bullet"><list-item><p><bold>S1</bold> 0 to 15ℓ% single-nucleotide substitutions at random positions</p></list-item><list-item><p><bold>S2</bold> Indels of size 0–25 at 2ℓ% random locations in the read</p></list-item><list-item><p><bold>S3</bold> Indels of size 2 at 0–10ℓ% random locations in the read</p></list-item><list-item><p><bold>S4</bold> A single indel of size 0 to 17ℓ% at a random location</p></list-item></list></p>
      <p>On top of that, we simulated sequencing error by estimating and interpolating an Illumina error profile. We estimated a first-order Markov chain of Phred score transitions from 1 million reads of length 101 from a Yoruba African individual (NA18507) for each of those 101 positions. To remove noise and simulate reads of lengths other than 101 bp, we used univariate spline interpolation to estimate the evolution of each entry of the matrix over the read sequence. These functions were then stretched or skewed for other read lengths, and new transition probabilities were derived by evaluating the spline function at the appropriate positions and rescale the rows, so that the matrix becomes stochastic. The resulting Phred score distributions of the reads simulated by iterating the new Markov chains were then verified to correspond to those of real data. As Phred scores correspond to actual error rates (<xref ref-type="bibr" rid="B14">Ewing and Green, 1998</xref>), we used them to simulate position-dependent sequencing errors.</p>
      <p>Our evaluation shows that Stampy outperforms all other methods in terms of accuracy (<xref ref-type="fig" rid="F2">Fig. 2</xref>). Its running time, however, depends on the type of read. For instance mapping all S1 reads of 500 bp length takes 1 h 35 min, in whereas mapping S2 takes 5 h (<ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/bts380/DC1">Supplementary Table S1</ext-link>). TreQ's running time ranges consistently at about 3.5 h. Stampy's running time also increases with read length, although it is mostly better than TreQ's. LAST performs in about the same accuracy range as TreQ but is not competitive in running time.</p>
      <p>In terms of accuracy, geometric embedding outperforms all suffix trie and seed-extend-based read mappers other than Stampy and LAST on almost all instances. The authors of both these programs argue that their accuracy is mainly due to the elaborate downstream analysis they perform after finding candidates. Our results are thus preliminary, as in essence we are comparing statistical alignment models of Stampy and LAST to a simple filter based on Levenshtein distance in our case. BWA can be customized to be competitive on S1 for shorter reads, at the cost of higher running times, but this improvement does not translate to S2–S4. Similarly, LAST outperforms TreQ on S1, but its performance is similar or worse than TreQ's on other conditions. Trie-based read mappers (Bowtie BWA and SOAP2) are very fast but do not perform well in general. Using a hybrid approach—in which SOAP's unmapped reads are mapped by TreQ—increases the accuracy for lower distances at the expense of slightly lower accuracy for higher distances, whereas drastically reducing the running time.</p>
    </sec>
    <sec sec-type="methods" id="SEC3.2">
      <title>3.2 Biological data</title>
      <p>Following the evaluation in <xref ref-type="bibr" rid="B19">Hach <italic>et al.</italic> (2010)</xref>, we compared TreQ to popular read mappers on a set of 1 million randomly selected 101 bp reads from Yoruba African individual (NA18507) (The 1000 Genomes Project Consortium, 2010). The running time and the percentage of reads mapped to the reference human genome HG18 build 36 within 3, 6, 12, and 18 edit distances are reported in <xref ref-type="table" rid="T1">Table 1</xref>. Times are for a single thread on a single core of a 2.2 GHz AMD Opteron processor.
<table-wrap id="T1" position="float"><label>Table 1.</label><caption><p>One million randomly selected Illumina single end reads mapped to HG18 build 36</p></caption><table frame="hsides" rules="groups"><thead><tr><th rowspan="1" colspan="1">Technique</th><th rowspan="1" colspan="1">Algorithm</th><th rowspan="1" colspan="1">Parameters</th><th rowspan="1" colspan="1">Time (h:m)</th><th colspan="4" rowspan="1">Mapped percentage ≤ ED<hr/></th></tr><tr><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1">≤ 3</th><th rowspan="1" colspan="1">≤ 6</th><th rowspan="1" colspan="1">≤ 12</th><th rowspan="1" colspan="1">≤ 18</th></tr></thead><tbody><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">Bowtie</td><td rowspan="1" colspan="1"><monospace>–best</monospace></td><td rowspan="1" colspan="1">0:04</td><td rowspan="1" colspan="1">85.22</td><td rowspan="1" colspan="1">–</td><td rowspan="1" colspan="1">–</td><td rowspan="1" colspan="1">–</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><monospace>–best -v 3</monospace></td><td rowspan="1" colspan="1">0:04</td><td rowspan="1" colspan="1">86.85</td><td rowspan="1" colspan="1">–</td><td rowspan="1" colspan="1">–</td><td rowspan="1" colspan="1">–</td></tr><tr><td rowspan="1" colspan="1">Suffix trie</td><td rowspan="1" colspan="1">BWA</td><td rowspan="1" colspan="1">default</td><td rowspan="1" colspan="1">0:14</td><td rowspan="1" colspan="1">87.31</td><td rowspan="1" colspan="1">89.35</td><td rowspan="1" colspan="1">–</td><td rowspan="1" colspan="1">–</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><monospace>-n 50 -o 10 -e 50 -M 1 -O 3 -E 1</monospace></td><td rowspan="1" colspan="1">5:53</td><td rowspan="1" colspan="1">87.35</td><td rowspan="1" colspan="1">90.08</td><td rowspan="1" colspan="1">92.39</td><td rowspan="1" colspan="1">93.03</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">SOAP2</td><td rowspan="1" colspan="1"><monospace>-v 50 -g 10 -r 1</monospace></td><td rowspan="1" colspan="1"><bold>0:03</bold></td><td rowspan="1" colspan="1">84.87</td><td rowspan="1" colspan="1">–</td><td rowspan="1" colspan="1">–</td><td rowspan="1" colspan="1">–</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">mrFAST</td><td rowspan="1" colspan="1"><monospace>–best -e 6</monospace></td><td rowspan="1" colspan="1">19:50</td><td rowspan="1" colspan="1">87.54</td><td rowspan="1" colspan="1">90.59</td><td rowspan="1" colspan="1">–</td><td rowspan="1" colspan="1">–</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">Novoalign</td><td rowspan="1" colspan="1"><monospace>-l 0 -e 1 -r Random</monospace></td><td rowspan="1" colspan="1">0:27</td><td rowspan="1" colspan="1">83.68</td><td rowspan="1" colspan="1">84.80</td><td rowspan="1" colspan="1">85.18</td><td rowspan="1" colspan="1">85.19</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">SSAHA2</td><td rowspan="1" colspan="1"><monospace>–best -1</monospace></td><td rowspan="1" colspan="1">45:36+</td><td rowspan="1" colspan="1">–</td><td rowspan="1" colspan="1">–</td><td rowspan="1" colspan="1">–</td><td rowspan="1" colspan="1">–</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">RazerS</td><td rowspan="1" colspan="1"><monospace>–unique</monospace></td><td rowspan="1" colspan="1">14:45</td><td rowspan="1" colspan="1">66.67</td><td rowspan="1" colspan="1">79.41</td><td rowspan="1" colspan="1">–</td><td rowspan="1" colspan="1">–</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">default</td><td rowspan="1" colspan="1">1:57</td><td rowspan="1" colspan="1">85.73</td><td rowspan="1" colspan="1">88.32</td><td rowspan="1" colspan="1">90.90</td><td rowspan="1" colspan="1">92.15</td></tr><tr><td rowspan="1" colspan="1">Seed-extend</td><td rowspan="1" colspan="1">Stampy</td><td rowspan="1" colspan="1"><monospace>–bwa-options</monospace></td><td rowspan="1" colspan="1">0:38</td><td rowspan="1" colspan="1"><bold>90.37</bold></td><td rowspan="1" colspan="1"><bold>92.05</bold></td><td rowspan="1" colspan="1"><bold>93.81</bold></td><td rowspan="1" colspan="1"><bold>94.84</bold></td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">default</td><td rowspan="1" colspan="1">1:32</td><td rowspan="1" colspan="1">84.76</td><td rowspan="1" colspan="1">87.66</td><td rowspan="1" colspan="1">90.23</td><td rowspan="1" colspan="1">90.78</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><monospace>-d108 -e120</monospace></td><td rowspan="1" colspan="1">1:35</td><td rowspan="1" colspan="1">84.85</td><td rowspan="1" colspan="1">87.77</td><td rowspan="1" colspan="1">90.69</td><td rowspan="1" colspan="1">91.69</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">LAST</td><td rowspan="1" colspan="1">default, LAMA</td><td rowspan="1" colspan="1">4:36</td><td rowspan="1" colspan="1">68.74</td><td rowspan="1" colspan="1">71.12</td><td rowspan="1" colspan="1">73.26</td><td rowspan="1" colspan="1">73.72</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><monospace>-d108 -e120</monospace>, LAMA</td><td rowspan="1" colspan="1">4:39</td><td rowspan="1" colspan="1">39.26</td><td rowspan="1" colspan="1">40.60</td><td rowspan="1" colspan="1">41.95</td><td rowspan="1" colspan="1">42.42</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><italic>τ</italic> = 1, <italic>β</italic> = 5000, <italic>α</italic> = 0</td><td rowspan="1" colspan="1">7:00</td><td rowspan="1" colspan="1">87.34</td><td rowspan="1" colspan="1">90.12</td><td rowspan="1" colspan="1">93.06</td><td rowspan="1" colspan="1">94.67</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><italic>τ</italic> = 2, <italic>β</italic> = 4500, <italic>α</italic> = 0</td><td rowspan="1" colspan="1">6:28</td><td rowspan="1" colspan="1">87.27</td><td rowspan="1" colspan="1">90.06</td><td rowspan="1" colspan="1">93.01</td><td rowspan="1" colspan="1">94.61</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><italic>τ</italic> = 3, <italic>β</italic> = 4000, <italic>α</italic> = 0</td><td rowspan="1" colspan="1">6:36</td><td rowspan="1" colspan="1">87.22</td><td rowspan="1" colspan="1">90.04</td><td rowspan="1" colspan="1">93.02</td><td rowspan="1" colspan="1">94.62</td></tr><tr><td rowspan="1" colspan="1">Geometric embedding</td><td rowspan="1" colspan="1">TreQ</td><td rowspan="1" colspan="1"><italic>τ</italic> = 1, <italic>β</italic> = 5000, <italic>α</italic> = 2</td><td rowspan="1" colspan="1">8:15</td><td rowspan="1" colspan="1">87.32</td><td rowspan="1" colspan="1">90.11</td><td rowspan="1" colspan="1">93.04</td><td rowspan="1" colspan="1">94.66</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><italic>τ</italic> = 2, <italic>β</italic> = 4000, <italic>α</italic> = 2</td><td rowspan="1" colspan="1">7:44</td><td rowspan="1" colspan="1">87.16</td><td rowspan="1" colspan="1">89.93</td><td rowspan="1" colspan="1">92.87</td><td rowspan="1" colspan="1">94.50</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><italic>τ</italic> = 3, <italic>β</italic> = 3000, <italic>α</italic> = 2</td><td rowspan="1" colspan="1">8:50</td><td rowspan="1" colspan="1">86.90</td><td rowspan="1" colspan="1">89.69</td><td rowspan="1" colspan="1">92.66</td><td rowspan="1" colspan="1">94.30</td></tr><tr><td rowspan="1" colspan="1">Hybrid</td><td rowspan="1" colspan="1">SOAP2 + TreQ</td><td rowspan="1" colspan="1"><italic>τ</italic> = 3, <italic>β</italic> = 3000, <italic>α</italic> = 2</td><td rowspan="1" colspan="1">2:06</td><td rowspan="1" colspan="1">87.89</td><td rowspan="1" colspan="1">90.50</td><td rowspan="1" colspan="1">93.26</td><td rowspan="1" colspan="1">94.83</td></tr></tbody></table><table-wrap-foot><fn><p>The percentages of reads mapped within a fixed edit distance (ED) by various read mappers are reported. As expected, trie-based read mappers are very fast but mostly fail to map reads with higher errors. BWA with customized parameters performs well but with significantly increased running time. Seed-extend-based methods have varied outcomes; mrFAST, RazerS and SSAHA2 take significantly more running time than others, Novoalign is comparably fast but fails to map reads with higher edit distances, whereas LAST (without LAMA option) and Stampy map almost similar amount of reads as TreQ. In contrast to most read mappers, TreQ is not restricted to few mismatches, small indels or few number of indels, and maps either an almost similar percentage of reads or more with various different parameter settings. TreQ's running time is significantly lower than mrFAST, RazerS and SSAHA2 and comparable with customized BWA; we stopped SSAHA2 after it did not finish running in 45 h. Additionally, Hybrid TreQ/SOAP outperforms most read mappers, whereas significantly reducing the required running time. Note that Bowtie only allows mismatches and is restricted to at most 3. All running times are based on running the read mappers single threaded on a single core of a 2.2 GHz AMD Opteron processor.</p></fn></table-wrap-foot></table-wrap></p>
      <p>We have found suffix-trie-based read mappers, implemented using Burrows–Wheeler transform, to be very fast on the real dataset but, unsurprisingly, limited in their ability to map reads with higher edit distances. Seed-extend-based techniques in contrast usually map more reads at large edit distances but require more CPU time. Except LAST, Stampy and TreQ, none of the other read mappers that we have evaluated successfully maps reads at high edit distances, possibly containing indels, in a reasonable amount of time. TreQ does so at competitive running time compared with mrFAST, RazerS, SSAHA2 and BWA with customized parameters (BWA's default parameters are not competitive with respect to accuracy). The hybrid SOAP/TreQ approach, taking advantage of suffix-trie-based read mappers' efficiency on low edit distances and TreQ's sensitivity at higher edit distances, uses less time and maps more reads within all edit distances considered.</p>
      <p>Although TreQ outperforms other read mappers on many mismatches or with large indels, its performance start to degrade gradually. As a result TreQ's specificity should drop at large edit distances. We have indirectly tested TreQ and other read mappers' specificity by combining the genome of human and chicken (a distant organism from human) and mapping the same one million real reads to this combined genome. We have found that BWA, BWA (customized), SOAP2, Novoalign, mrFAST and TreQ (within edit distance 18) map 87, 191, 65, 149, 189 and 187 reads, respectively, to the chicken genome. This experiment shows that TreQ's specificity is comparable with the other read mappers. For greater control over specificity, an optional maximum edit distance threshold <italic>m</italic> can be set in TreQ to discard any alignment with edit distance greater than <italic>m</italic> (default value <inline-formula><inline-graphic xlink:href="bts380i1.jpg"/></inline-formula>, for read length <italic>l</italic>).</p>
    </sec>
    <sec id="SEC3.3">
      <title>3.3 Memory requirements and multi-threading</title>
      <p>The memory requirement for the cache-oblivious <italic>kd</italic>-tree and the <italic>d</italic>-dimensional vectors are <inline-formula><inline-graphic xlink:href="bts380i2.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="bts380i3.jpg"/></inline-formula>, respectively. As a result, TreQ requires about <inline-formula><inline-graphic xlink:href="bts380i4.jpg"/></inline-formula> bytes of memory, given that 2<italic>gα</italic>(<italic>α</italic>+1)≤ <italic>d</italic>. Here, <italic>G</italic> is the genome size, <italic>g</italic> is the offset by which the genomic windows are shifted, <xref ref-type="fig" rid="F1">Figure 1</xref> (right), while creating <italic>d</italic>-dimensional <italic>q</italic>-gram vectors, 2<italic>α</italic> is the number of vectors for which we only store the changes from a nearby point and <italic>τ</italic> is the number of ignored lowest levels in the <italic>kd</italic>-tree. If we set <italic>τ</italic> = 4, <italic>α</italic> = 2 and <italic>g</italic> = 3, for <italic>d</italic> = 64 TreQ's memory requirement is around 40 GB (which is equivalent to using less than 1GB per core in a 48-core machine with the multi-threaded TreQ). Interestingly, these parameters have minor effects on accuracy and running time; for a detailed analysis, see <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/bts380/DC1">Supplementary Figure S2</ext-link>. In addition, memory requirement can be further reduced by creating separate <italic>kd</italic>-trees for each chromosome and loading one <italic>kd</italic>-tree at a time in the memory.</p>
      <p>We have developed a multi-threaded version of TreQ and tested its performance by mapping 0.1 million randomly selected Illumina single end reads (Yoruba African individual, NA18507) on a 48-core AMD Opteron 2.2 GHz server with 256 GB memory. The performance of TreQ scales very well in the number of threads, within 84% of the achievable maximum up to 40 cores (<xref ref-type="fig" rid="F3">Fig. 3</xref>).
<fig id="F3" position="float"><label>Fig. 3.</label><caption><p>Speed up achieved by the multi-threaded version of TreQ on the task of mapping a randomly selected 0.1 million 101 bp single end reads from Yoruba African individual (NA18507).</p></caption><graphic xlink:href="bts380f3"/></fig>
</p>
    </sec>
  </sec>
  <sec id="SEC4">
    <title>4 CONCLUSION</title>
    <p>We address the problem of mapping NGS reads in an indel-tolerant manner by establishing geometric embedding as a promising paradigm, allowing identification of structural variants, including one or several indels of length 1–16 bp, from single read experiments: We map reads and genomic locations to trinucleotide frequency vectors, embedding them in ℝ<sup>64</sup>. The <italic>L</italic><sub>1</sub> distance between <italic>q</italic>-gram frequency vectors provides a lower bound for an edit distance with affine gap costs in which even long indels have small distance, improving the sensitivity of their detection. A probabilistic argument assuming reads, and genomes are generated from a Markov chain provides insight into the quality of the bound.</p>
    <p>The problem of approximate matching is thus transformed into one of computing nearest neighbors using a spatial index. The decision for <italic>kd</italic>-trees was based on their favorable performance in many real-world scenarios (<xref ref-type="bibr" rid="B25">Kibriya and Frank, 2007</xref>) and the fact that they can be easily implemented in a cache-oblivious manner (<xref ref-type="bibr" rid="B4">Arge <italic>et al.</italic>, 2005</xref>), a major factor as memory accesses constitute the predominant bottleneck on modern CPU architectures.</p>
    <p>Apart from the mapping of reads to the <italic>q</italic>-gram frequency vectors, our method has running times and memory requirements, which are about constant for the operations involving the index in the length of the reads. In practice, because of word sizes on computers, we expect this to hold for sequences of length 100–1000 bp.</p>
    <p>Currently, SMP computers with many cores and 128 GB are the preferable platform for TreQ as the memory requirement is high, even when comparable with the state-of-the-art when measured in memory per core. Fortunately, SMP servers are approaching the prices of clusters with a comparable number of cores and main memory, which make the SMP platform the more versatile option at the same price point and memory usage a lesser issue. Also, the spatial index we used is a straight-forward <italic>kd</italic>-tree variant implemented in a cache-oblivious manner, which certainly can be improved upon.</p>
    <p>We are currently investigating a parallel distributed index, which will allow the use of TreQ on clusters. Generally, we expect further improvements in running times, and consequently in accuracy, from an spatial index tailored specifically to the high-dimensional, integer coordinate problem setting, e.g. an adaptation of X-trees (<xref ref-type="bibr" rid="B5">Berchtold <italic>et al.</italic>, 1996</xref>) or through the use of locality-sensitive hashing (<xref ref-type="bibr" rid="B45">Paulevé <italic>et al.</italic>, 2010</xref>). Additional improvements in terms of both memory and running time can be made by using batch processing for queries.</p>
    <p>The simplistic evaluation of putative matches using Levensthein distance will be replaced by a statistical, quality-score aware analysis following the lead of Stampy (<xref ref-type="bibr" rid="B34">Lunter and Goodson, 2011</xref>) and LAST (<xref ref-type="bibr" rid="B16">Frith <italic>et al.</italic>, 2010</xref>; <xref ref-type="bibr" rid="B20">Hamada <italic>et al.</italic>, 2011</xref>), which attribute their success to a large degree to the quality of their putative hit filtering. In our geometric embedding, quality scores can be used while searching for putative hits by using floating-point or fixed-point arithmetic and fractional count contributions for low-quality nucleotides.</p>
    <p>The approximate matching tasks differ depending on whether a read has one exact match, few matches of small Hamming or Levenshtein distance, few matches of large Levenshtein distance with large indels or many matches of arbitrary distance. The resulting running times and accuracies depend heavily on the exact composition of the read set with respect to the types of matches. This implies that for data sets which are expected to contain both reads with indels and reads with mutations, a hybrid approach might be the most sensible option, as exemplified by our hybrid method. Traditional read mappers that are fast on low-mutation reads can be used to filter the unproblematic reads and then use geometric embedding to map the remaining ones in an indel-tolerant fashion.</p>
  </sec>
</body>
<back>
  <ack>
    <title>ACKNOWLEDGEMENT</title>
    <p>We thank Martin Frith for helping us with LAST, Martin Farach-Colton for fruitful discussion on data structures and Rajat Roy for many useful suggestions about read mappers. We also thank the three anonymous reviewers for their helpful and constructive comments.</p>
    <p><italic>Conflict of Interest:</italic> none declared.</p>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="B1">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Agarwal</surname>
            <given-names>P.K.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Cache-oblivious data structures for orthogonal range searching</article-title>
        <source>Proceedings of the nineteenth annual symposium on Computational geometry</source>
        <year>2003</year>
        <publisher-loc>New York</publisher-loc>
        <publisher-name>ACM</publisher-name>
        <fpage>237</fpage>
        <lpage>245</lpage>
        <comment>SCG ‘03</comment>
      </element-citation>
    </ref>
    <ref id="B2">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Alkan</surname>
            <given-names>C.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Personalized copy number and segmental duplication maps using next-generation sequencing</article-title>
        <source>Nat. Genet.</source>
        <year>2009</year>
        <volume>41</volume>
        <fpage>1061</fpage>
        <lpage>1067</lpage>
        <pub-id pub-id-type="pmid">19718026</pub-id>
      </element-citation>
    </ref>
    <ref id="B3">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Alkan</surname>
            <given-names>C.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Genome structural variation discovery and genotyping</article-title>
        <source>Nat. Rev. Genet.</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>363</fpage>
        <lpage>376</lpage>
        <pub-id pub-id-type="pmid">21358748</pub-id>
      </element-citation>
    </ref>
    <ref id="B4">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Arge</surname>
            <given-names>L.</given-names>
          </name>
          <etal/>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Mehta</surname>
            <given-names>D.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Cache-oblivious data structures</article-title>
        <source>Handbook of Data Structures and Applications</source>
        <year>2005</year>
        <publisher-loc>Boca Raton</publisher-loc>
        <publisher-name>CRC Press</publisher-name>
        <comment>chapter 34</comment>
      </element-citation>
    </ref>
    <ref id="B5">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Berchtold</surname>
            <given-names>S.</given-names>
          </name>
          <etal/>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Vijayaraman</surname>
            <given-names>T.M.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The x-tree : An index structure for high-dimensional data</article-title>
        <source>VLDB‘96, Proceedings of 22th International Conference on Very Large Data Bases, September 3–6, 1996, Mumbai, India</source>
        <year>1996</year>
        <publisher-loc>San Francisco</publisher-loc>
        <publisher-name>Morgan Kaufmann</publisher-name>
        <fpage>28</fpage>
        <lpage>39</lpage>
      </element-citation>
    </ref>
    <ref id="B6">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bern</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <article-title>Approximate closest-point queries in high dimensions</article-title>
        <source>Inf. Process Lett.</source>
        <year>1993</year>
        <volume>45</volume>
        <fpage>95</fpage>
        <lpage>99</lpage>
      </element-citation>
    </ref>
    <ref id="B7">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Böhm</surname>
            <given-names>C.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Searching in high-dimensional spaces: Index structures for improving the performance of multimedia databases</article-title>
        <source>ACM Comput. Surv.</source>
        <year>2001</year>
        <volume>33</volume>
        <fpage>322</fpage>
        <lpage>373</lpage>
      </element-citation>
    </ref>
    <ref id="B8">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Boytsov</surname>
            <given-names>L.</given-names>
          </name>
        </person-group>
        <article-title>Indexing methods for approximate dictionary searching</article-title>
        <source>J. Exp. Algorithmics</source>
        <year>2011a</year>
        <volume>16</volume>
        <fpage>1</fpage>
      </element-citation>
    </ref>
    <ref id="B9">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Boytsov</surname>
            <given-names>L.</given-names>
          </name>
        </person-group>
        <article-title>Indexing methods for approximate dictionary searching: Comparative analysis</article-title>
        <source>J. Exp. Algorithmics</source>
        <year>2011b</year>
        <volume>16</volume>
        <fpage>1.1:1.1</fpage>
        <lpage>1.1:1.91</lpage>
      </element-citation>
    </ref>
    <ref id="B10">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bugnion</surname>
            <given-names>E.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A spatial index for approximate multiple string matching</article-title>
        <source>J. Brazilian Chem. Soc.</source>
        <year>1995</year>
        <volume>1</volume>
        <fpage>28</fpage>
        <lpage>35</lpage>
      </element-citation>
    </ref>
    <ref id="B11">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Burkhardt</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Kärkkäinen</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>Better filtering with gapped q-grams</article-title>
        <source>Fundam. Inf.</source>
        <year>2002</year>
        <volume>56</volume>
        <fpage>51</fpage>
        <lpage>70</lpage>
      </element-citation>
    </ref>
    <ref id="B12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bustos</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Navarro</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <article-title>Improving the space cost of <italic>k</italic> -nn search in metric spaces by using distance estimators</article-title>
        <source>Multimedia Tools Appl.</source>
        <year>2009</year>
        <volume>41</volume>
        <fpage>215</fpage>
        <lpage>233</lpage>
      </element-citation>
    </ref>
    <ref id="B13">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chen</surname>
            <given-names>K.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Breakdancer: an algorithm for high-resolution mapping of genomic structural variation</article-title>
        <source>Nat. Methods</source>
        <year>2009</year>
        <volume>6</volume>
        <fpage>677</fpage>
        <lpage>681</lpage>
        <pub-id pub-id-type="pmid">19668202</pub-id>
      </element-citation>
    </ref>
    <ref id="B14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ewing</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Green</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <article-title>Base-calling of automated sequencer traces using phred. II. error probabilities</article-title>
        <source>Genome Res.</source>
        <year>1998</year>
        <volume>8</volume>
        <fpage>186</fpage>
        <lpage>194</lpage>
        <pub-id pub-id-type="pmid">9521922</pub-id>
      </element-citation>
    </ref>
    <ref id="B15">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Frigo</surname>
            <given-names>M.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Cache-oblivious algorithms</article-title>
        <source>Proceedings of the 40th Annual Symposium on Foundations of Computer Science</source>
        <year>1999</year>
        <publisher-loc>Washington</publisher-loc>
        <publisher-name>IEEE Computer Society</publisher-name>
        <fpage>285</fpage>
        <comment>FOCS ‘99</comment>
      </element-citation>
    </ref>
    <ref id="B16">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Frith</surname>
            <given-names>M.C.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Incorporating sequence quality data into alignment improves DNA read mapping</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2010</year>
        <volume>38</volume>
        <fpage>e100</fpage>
        <pub-id pub-id-type="pmid">20110255</pub-id>
      </element-citation>
    </ref>
    <ref id="B17">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Goke</surname>
            <given-names>J.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Estimation of pairwise sequence similarity of mammalian enhancers with word neighbourhood counts</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <fpage>656</fpage>
        <lpage>663</lpage>
        <pub-id pub-id-type="pmid">22247280</pub-id>
      </element-citation>
    </ref>
    <ref id="B18">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Gusfield</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <source>Algorithms on Strings, Trees and Sequences: Computer Science and Computational Biology</source>
        <year>1997</year>
        <publisher-loc>Cambridge</publisher-loc>
        <publisher-name>Cambridge University Press</publisher-name>
      </element-citation>
    </ref>
    <ref id="B19">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hach</surname>
            <given-names>F.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>mrsfast: a cache-oblivious algorithm for short-read mapping</article-title>
        <source>Nat. Method.</source>
        <year>2010</year>
        <volume>7</volume>
        <fpage>576</fpage>
        <lpage>577</lpage>
      </element-citation>
    </ref>
    <ref id="B20">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hamada</surname>
            <given-names>M.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Probabilistic alignments with quality scores: an application to short-read mapping toward accurate snp/indel detection</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <fpage>3085</fpage>
        <lpage>3092</lpage>
        <pub-id pub-id-type="pmid">21976422</pub-id>
      </element-citation>
    </ref>
    <ref id="B21">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hormozdiari</surname>
            <given-names>F.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Combinatorial algorithms for structural variation detection in high-throughput sequenced genomes</article-title>
        <source>Genome Res.</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>1270</fpage>
        <lpage>1278</lpage>
        <pub-id pub-id-type="pmid">19447966</pub-id>
      </element-citation>
    </ref>
    <ref id="B22">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hormozdiari</surname>
            <given-names>F.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Next-generation variationhunter: combinatorial algorithms for transposon insertion discovery</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <fpage>i350</fpage>
        <lpage>i357</lpage>
        <pub-id pub-id-type="pmid">20529927</pub-id>
      </element-citation>
    </ref>
    <ref id="B23">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Houle</surname>
            <given-names>M.E.</given-names>
          </name>
          <name>
            <surname>Sakuma</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Aberer</surname>
            <given-names>K.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Fast approximate similarity search in extremely high-dimensional data sets</article-title>
        <source>ICDE</source>
        <year>2005</year>
        <publisher-loc>Washington, DC</publisher-loc>
        <publisher-name>IEEE Computer Society</publisher-name>
        <fpage>619</fpage>
        <lpage>630</lpage>
      </element-citation>
    </ref>
    <ref id="B24">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Katayama</surname>
            <given-names>N.</given-names>
          </name>
          <name>
            <surname>Satoh</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <article-title>Sr-tree: An index structure for nearest-neighbor searching of high-dimensional point data</article-title>
        <source>Sys. Comput. Japan</source>
        <year>1998</year>
        <volume>29</volume>
        <fpage>59</fpage>
        <lpage>73</lpage>
      </element-citation>
    </ref>
    <ref id="B25">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Kibriya</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Frank</surname>
            <given-names>E.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Kok</surname>
            <given-names>J.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>An empirical comparison of exact nearest neighbour algorithms</article-title>
        <source>Knowledge Discovery in Databases: PKDD 2007, volume 4702 of Lecture Notes in Computer Science</source>
        <year>2007</year>
        <publisher-loc>Berlin</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>140</fpage>
        <lpage>151</lpage>
      </element-citation>
    </ref>
    <ref id="B26">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Korbel</surname>
            <given-names>J.O.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Pemer: a computational framework with simulation-based error models for inferring genomic structural variants from massive paired-end sequencing data</article-title>
        <source>Genome Biol.</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>R23</fpage>
        <pub-id pub-id-type="pmid">19236709</pub-id>
      </element-citation>
    </ref>
    <ref id="B27">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Langmead</surname>
            <given-names>B.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Ultrafast and memory-efficient alignment of short dna sequences to the human genome</article-title>
        <source>Genome Biol.</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>R25</fpage>
        <pub-id pub-id-type="pmid">19261174</pub-id>
      </element-citation>
    </ref>
    <ref id="B28">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lee</surname>
            <given-names>S.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Modil: detecting small indels from clone-end sequencing with mixtures of distributions</article-title>
        <source>Nat. Methods</source>
        <year>2009</year>
        <volume>6</volume>
        <fpage>473</fpage>
        <lpage>474</lpage>
        <pub-id pub-id-type="pmid">19483690</pub-id>
      </element-citation>
    </ref>
    <ref id="B29">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Leslie</surname>
            <given-names>C.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The spectrum kernel: a string kernel for svm protein classification</article-title>
        <source>Proceedings of Pacific Symposium on Biocomputing</source>
        <year>2002</year>
        <fpage>564</fpage>
        <lpage>575</lpage>
      </element-citation>
    </ref>
    <ref id="B30">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <article-title>Fast and accurate short read alignment with burrows–wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>1754</fpage>
        <lpage>1760</lpage>
        <pub-id pub-id-type="pmid">19451168</pub-id>
      </element-citation>
    </ref>
    <ref id="B31">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Homer</surname>
            <given-names>N.</given-names>
          </name>
        </person-group>
        <article-title>A survey of sequence alignment algorithms for next-generation sequencing</article-title>
        <source>Brief. Bioinformatics</source>
        <year>2010</year>
        <volume>11</volume>
        <fpage>473</fpage>
        <lpage>483</lpage>
        <pub-id pub-id-type="pmid">20460430</pub-id>
      </element-citation>
    </ref>
    <ref id="B32">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>R.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Soap2: an improved ultrafast tool for short read alignment</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>1966</fpage>
        <lpage>1967</lpage>
        <pub-id pub-id-type="pmid">19497933</pub-id>
      </element-citation>
    </ref>
    <ref id="B33">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Liu</surname>
            <given-names>X.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>New powerful statistics for alignment-free sequence comparison under a pattern transfer model</article-title>
        <source>J. Theo. Biol.</source>
        <year>2011</year>
        <volume>284</volume>
        <fpage>106</fpage>
        <lpage>116</lpage>
      </element-citation>
    </ref>
    <ref id="B34">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lunter</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Goodson</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <article-title>Stampy: A statistical algorithm for sensitive and fast mapping of illumina sequence reads</article-title>
        <source>Genome Res.</source>
        <year>2011</year>
        <volume>21</volume>
        <fpage>936</fpage>
        <lpage>939</lpage>
        <pub-id pub-id-type="pmid">20980556</pub-id>
      </element-citation>
    </ref>
    <ref id="B35">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Malhis</surname>
            <given-names>N.</given-names>
          </name>
          <name>
            <surname>Jones</surname>
            <given-names>S.J.M.</given-names>
          </name>
        </person-group>
        <article-title>High quality SNP calling using Illumina data at shallow coverage</article-title>
        <source>Bioinformatics (Oxford, England)</source>
        <year>2010</year>
        <volume>26</volume>
        <fpage>1029</fpage>
        <lpage>35</lpage>
      </element-citation>
    </ref>
    <ref id="B36">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Mount</surname>
            <given-names>D.M.</given-names>
          </name>
          <name>
            <surname>Arya</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <article-title>Ann: A library for approximate nearest neighbor searching</article-title>
        <year>2010</year>
        <comment>Available at <ext-link ext-link-type="uri" xlink:href="http://www.cs.umd.edu/mount/ANN/">http://www.cs.umd.edu/mount/ANN/</ext-link>. Accessed on July 18, 2012</comment>
      </element-citation>
    </ref>
    <ref id="B37">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Muja</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Lowe</surname>
            <given-names>D.G.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Ranchordas</surname>
            <given-names>A.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Fast approximate nearest neighbors with automatic algorithm configuration</article-title>
        <source>International Conference on Computer Vision Theory and Application (VISSAPP‘09)</source>
        <year>2009</year>
        <publisher-loc>Setubal, Portugal</publisher-loc>
        <publisher-name>INSTICC Press</publisher-name>
        <fpage>331</fpage>
        <lpage>340</lpage>
      </element-citation>
    </ref>
    <ref id="B38">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Myers</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <article-title>A fast bit-vector algorithm for approximate string matching based on dynamic programming</article-title>
        <source>J. ACM</source>
        <year>1999</year>
        <volume>46</volume>
        <fpage>395</fpage>
        <lpage>415</lpage>
      </element-citation>
    </ref>
    <ref id="B39">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Navarro</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <article-title>A guided tour to approximate string matching</article-title>
        <source>ACM Comput. Surv.</source>
        <year>2001</year>
        <volume>33</volume>
        <fpage>31</fpage>
        <lpage>88</lpage>
      </element-citation>
    </ref>
    <ref id="B40">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Navarro</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Chávez</surname>
            <given-names>E.</given-names>
          </name>
        </person-group>
        <article-title>A metric index for approximate string matching</article-title>
        <source>Theo. Comput. Sci.</source>
        <year>2006</year>
        <volume>352</volume>
        <fpage>266</fpage>
        <lpage>279</lpage>
      </element-citation>
    </ref>
    <ref id="B41">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Navarro</surname>
            <given-names>G.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Indexing text with approximate <italic>q</italic>-grams</article-title>
        <source>J. Discrete Algorithms</source>
        <year>2005</year>
        <volume>3</volume>
        <fpage>157</fpage>
        <lpage>175</lpage>
      </element-citation>
    </ref>
    <ref id="B42">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ning</surname>
            <given-names>Z.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Ssaha: A fast search method for large dna databases</article-title>
        <source>Genome Res.</source>
        <year>2001</year>
        <volume>11</volume>
        <fpage>1725</fpage>
        <lpage>1729</lpage>
        <pub-id pub-id-type="pmid">11591649</pub-id>
      </element-citation>
    </ref>
    <ref id="B43">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Ozturk</surname>
            <given-names>O.</given-names>
          </name>
          <name>
            <surname>Ferhatosmanoglu</surname>
            <given-names>H.</given-names>
          </name>
        </person-group>
        <article-title>Effective indexing and filtering for similarity search in large biosequence databases</article-title>
        <source>BIBE</source>
        <year>2003</year>
        <publisher-loc>Washington, DC</publisher-loc>
        <publisher-name>IEEE Computer Society</publisher-name>
        <fpage>359</fpage>
        <lpage>366</lpage>
      </element-citation>
    </ref>
    <ref id="B44">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ozturk</surname>
            <given-names>O.</given-names>
          </name>
          <name>
            <surname>Ferhatosmanoglu</surname>
            <given-names>H.</given-names>
          </name>
        </person-group>
        <article-title>Vector space indexing for biosequence similarity searches</article-title>
        <source>Int. J. Artificial Intel. Tool</source>
        <year>2005</year>
        <volume>14</volume>
        <fpage>811</fpage>
        <lpage>826</lpage>
      </element-citation>
    </ref>
    <ref id="B45">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Paulevé</surname>
            <given-names>L.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Locality sensitive hashing: a comparison of hash function types and querying mechanisms</article-title>
        <source>Pattern Reco. Lett.</source>
        <year>2010</year>
        <volume>31</volume>
        <fpage>1348</fpage>
        <lpage>1358</lpage>
      </element-citation>
    </ref>
    <ref id="B46">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Reinert</surname>
            <given-names>G.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Alignment-free sequence comparison (i): statistics and power</article-title>
        <source>J. Comput. Biol.</source>
        <year>2009</year>
        <volume>16</volume>
        <fpage>1615</fpage>
        <lpage>1634</lpage>
        <pub-id pub-id-type="pmid">20001252</pub-id>
      </element-citation>
    </ref>
    <ref id="B47">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Sellis</surname>
            <given-names>T.K.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The r+-tree: A dynamic index for multi-dimensional objects</article-title>
        <source>Proceedings of the 13th International Conference on Very Large Data Bases</source>
        <year>1987</year>
        <publisher-loc>San Francisco</publisher-loc>
        <publisher-name>Morgan Kaufmann Publishers Inc</publisher-name>
        <fpage>507</fpage>
        <lpage>518</lpage>
        <comment>VLDB ‘87</comment>
      </element-citation>
    </ref>
    <ref id="B48">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Sutinen</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Szpankowski</surname>
            <given-names>W.</given-names>
          </name>
        </person-group>
        <article-title>On the collapse of q-Gram filtration</article-title>
        <source>FUN with Algorithms</source>
        <year>1998</year>
        <publisher-loc>Ottawa, ON, Canada</publisher-loc>
        <publisher-name>Carleton University</publisher-name>
        <fpage>178</fpage>
        <lpage>193</lpage>
      </element-citation>
    </ref>
    <ref id="B49">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Takahashi</surname>
            <given-names>M.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Estimation of bacterial species phylogeny through oligonucleotide frequency distances</article-title>
        <source>Genomics</source>
        <year>2009</year>
        <volume>93</volume>
        <fpage>525</fpage>
        <lpage>533</lpage>
        <pub-id pub-id-type="pmid">19442633</pub-id>
      </element-citation>
    </ref>
    <ref id="B50">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <collab>The 1000 Genomes Project Consortium</collab>
        </person-group>
        <article-title>A map of human genome variation from population-scale sequencing</article-title>
        <source>Nature</source>
        <year>2010</year>
        <volume>467</volume>
        <fpage>1061</fpage>
        <lpage>1073</lpage>
        <pub-id pub-id-type="pmid">20981092</pub-id>
      </element-citation>
    </ref>
    <ref id="B51">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <collab>The International HapMap Consortium</collab>
        </person-group>
        <article-title>A haplotype map of the human genome</article-title>
        <source>Nature</source>
        <year>2005</year>
        <volume>437</volume>
        <fpage>1299</fpage>
        <lpage>1320</lpage>
        <pub-id pub-id-type="pmid">16255080</pub-id>
      </element-citation>
    </ref>
    <ref id="B52">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ukkonen</surname>
            <given-names>E.</given-names>
          </name>
        </person-group>
        <article-title>Approximate string matching with q-grams and maximal matches</article-title>
        <source>Theor. Comput. Sci.</source>
        <year>1992</year>
        <volume>92</volume>
        <fpage>191</fpage>
        <lpage>211</lpage>
      </element-citation>
    </ref>
    <ref id="B53">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>van Emde Boas</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <article-title>Preserving order in a forest in less than logarithmic time</article-title>
        <source>Proceedings of the 16th Annual Symposium on Foundations of Computer Science</source>
        <year>1975</year>
        <publisher-loc>Washington, DC</publisher-loc>
        <publisher-name>IEEE Computer Society</publisher-name>
        <fpage>75</fpage>
        <lpage>84</lpage>
      </element-citation>
    </ref>
    <ref id="B54">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>van Emde Boas</surname>
            <given-names>P.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Design and implementation of an efficient priority queue</article-title>
        <source>Theo. Comput. Syst.</source>
        <year>1976</year>
        <volume>10</volume>
        <fpage>99</fpage>
        <lpage>127</lpage>
      </element-citation>
    </ref>
    <ref id="B55">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wan</surname>
            <given-names>L.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Alignment-free sequence comparison (ii): theoretical power of comparison statistics</article-title>
        <source>J. Comput. Biol.</source>
        <year>2010</year>
        <volume>17</volume>
        <fpage>1467</fpage>
        <lpage>1490</lpage>
        <pub-id pub-id-type="pmid">20973742</pub-id>
      </element-citation>
    </ref>
    <ref id="B56">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Weese</surname>
            <given-names>D.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Razers fast read mapping with sensitivity control</article-title>
        <source>Genome Res.</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>1646</fpage>
        <lpage>1654</lpage>
        <pub-id pub-id-type="pmid">19592482</pub-id>
      </element-citation>
    </ref>
    <ref id="B57">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Yao</surname>
            <given-names>B.</given-names>
          </name>
          <etal/>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Li</surname>
            <given-names>F.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Approximate string search in spatial databases</article-title>
        <source>ICDE</source>
        <year>2010</year>
        <publisher-loc>Washington, DC</publisher-loc>
        <publisher-name>IEEE Computer Society</publisher-name>
        <fpage>545</fpage>
        <lpage>556</lpage>
      </element-citation>
    </ref>
  </ref-list>
</back>
