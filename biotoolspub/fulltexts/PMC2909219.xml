<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">2909219</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-11-345</article-id>
    <article-id pub-id-type="pmid">20576136</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-11-345</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>SOPRA: Scaffolding algorithm for paired reads via statistical optimization</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" id="A1">
        <name>
          <surname>Dayarian</surname>
          <given-names>Adel</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>dayarian@physics.rutgers.edu</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Michael</surname>
          <given-names>Todd P</given-names>
        </name>
        <xref ref-type="aff" rid="I2">2</xref>
        <xref ref-type="aff" rid="I4">4</xref>
        <email>tmichael@waksman.rutgers.edu</email>
      </contrib>
      <contrib contrib-type="author" corresp="yes" id="A3">
        <name>
          <surname>Sengupta</surname>
          <given-names>Anirvan M</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I3">3</xref>
        <email>anirvans@physics.rutgers.edu</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Department of Physics and Astronomy, Rutgers University, Piscataway, New Jersey, USA</aff>
    <aff id="I2"><label>2</label>Waksman Institute, Rutgers University, Piscataway, New Jersey, USA</aff>
    <aff id="I3"><label>3</label>BioMaPS Institute for Quantitative Biology, Rutgers University, Piscataway, New Jersey, USA</aff>
    <aff id="I4"><label>4</label>Current address: Monsanto Company, St Louis, MO USA</aff>
    <pub-date pub-type="collection">
      <year>2010</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>24</day>
      <month>6</month>
      <year>2010</year>
    </pub-date>
    <volume>11</volume>
    <fpage>345</fpage>
    <lpage>345</lpage>
    <history>
      <date date-type="received">
        <day>22</day>
        <month>1</month>
        <year>2010</year>
      </date>
      <date date-type="accepted">
        <day>24</day>
        <month>6</month>
        <year>2010</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright Â©2010 Dayarian et al; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2010</copyright-year>
      <copyright-holder>Dayarian et al; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1471-2105/11/345"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>High throughput sequencing (HTS) platforms produce gigabases of short read (&lt;100 bp) data per run. While these short reads are adequate for resequencing applications, <italic>de novo </italic>assembly of moderate size genomes from such reads remains a significant challenge. These limitations could be partially overcome by utilizing mate pair technology, which provides pairs of short reads separated by a known distance along the genome.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We have developed SOPRA, a tool designed to exploit the mate pair/paired-end information for assembly of short reads. The main focus of the algorithm is selecting a sufficiently large subset of simultaneously satisfiable mate pair constraints to achieve a balance between the size and the quality of the output scaffolds. Scaffold assembly is presented as an optimization problem for variables associated with vertices and with edges of the contig connectivity graph. Vertices of this graph are individual contigs with edges drawn between contigs connected by mate pairs. Similar graph problems have been invoked in the context of shotgun sequencing and scaffold building for previous generation of sequencing projects. However, given the error-prone nature of HTS data and the fundamental limitations from the shortness of the reads, the ad hoc greedy algorithms used in the earlier studies are likely to lead to poor quality results in the current context. SOPRA circumvents this problem by treating all the constraints on equal footing for solving the optimization problem, the solution itself indicating the problematic constraints (chimeric/repetitive contigs, etc.) to be removed. The process of solving and removing of constraints is iterated till one reaches a core set of consistent constraints. For SOLiD sequencer data, SOPRA uses a dynamic programming approach to robustly translate the color-space assembly to base-space. For assessing the quality of an assembly, we report the no-match/mismatch error rate as well as the rates of various rearrangement errors.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>Applying SOPRA to real data from bacterial genomes, we were able to assemble contigs into scaffolds of significant length (N50 up to 200 Kb) with very few errors introduced in the process. In general, the methodology presented here will allow better scaffold assemblies of any type of mate pair sequencing data.</p>
      </sec>
    </abstract>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>Next-generation high-throughput sequencing (HTS) holds the promise of revolutionizing the field of biological research [<xref ref-type="bibr" rid="B1">1</xref>]. By producing millions of short reads (25-100 bp) per run at a moderate cost, these new sequencing platforms move whole genome sequencing from large centers to individual scientists. To name a few, the list of applications includes gene expression analysis, mutation mapping, non-coding RNA discovery, metagenomics, and protein binding site identification [<xref ref-type="bibr" rid="B2">2</xref>,<xref ref-type="bibr" rid="B3">3</xref>]. From bioinformatics point of view, there are essentially two types of problems: short read alignment or mapping and <italic>de novo </italic>assembly (the case where no reference genome is available). <italic>De novo </italic>assembly of short reads into larger DNA contigs/scaffolds has proven a bioinformatics challenge both in terms of algorithmic and computational power [<xref ref-type="bibr" rid="B4">4</xref>].</p>
    <p>Over the past few years, several algorithms have been developed for assembly of short reads. These algorithms can be divided into two broad categories. Some methods, based on 3'kmer extension, use particular data structures to efficiently search for short reads extending a seed sequence [<xref ref-type="bibr" rid="B5">5</xref>-<xref ref-type="bibr" rid="B7">7</xref>]. In contrast, the graph-based methods pose the sequence assembly as a problem of finding paths on a graph that encodes the short read overlap information [<xref ref-type="bibr" rid="B8">8</xref>-<xref ref-type="bibr" rid="B11">11</xref>].</p>
    <p>Mate pair and paired-end sequencing represent key innovations in short read sequencing that enabled assembly of short contigs into larger scaffolds. Mate pair sequencing was a key innovation that allowed shotgun sequencing of large complex genomes such as humans and Drosophila [<xref ref-type="bibr" rid="B12">12</xref>]. Mate pair libraries are generated by enzymatically isolating the ends of a long (1 to 10 kb) DNA molecule. These ends are sequenced in the same direction. In contrast, paired-end sequencing involves sequencing the ends of a smaller (&lt; 600 bp) DNA fragment from both ends in the opposite direction. In this paper, unless we are explicitly contrasting the two methods, we will use the term mate pair to refer to both these technologies.</p>
    <p>The current version of some of the above-mentioned short read assemblers can handle mate pair information. However, the use of this information was not central to the concepts that led to the design of most of these algorithms. The sole exception is the ALLPATHS assembler [<xref ref-type="bibr" rid="B9">9</xref>], where the use of mate pairs is essential. From a practical point of view, one drawback of ALLPATHS is that it requires at least two paired libraries, with very different insert sizes. Also, the performance of this assembler degrades rapidly as the coefficient of variation of insert size in a library increases past a few percent [<xref ref-type="bibr" rid="B9">9</xref>]. This sensitivity is a problem for assembly of real sequence data, as we will see. In the context of previous generations of sequencing technologies with longer reads, the incorporation of mate pair information has also been addressed, either in conjunction with contig assembly [<xref ref-type="bibr" rid="B13">13</xref>,<xref ref-type="bibr" rid="B14">14</xref>] or as a scaffolding module [<xref ref-type="bibr" rid="B15">15</xref>].</p>
    <p>Generally speaking, current scaffolding algorithms fall into two categories. Prominent de Bruijn graph based contig building algorithms (e.g. Velvet [<xref ref-type="bibr" rid="B8">8</xref>] and Euler [<xref ref-type="bibr" rid="B14">14</xref>]) utilize mate pairs to improve the path/walk in the same de Bruijn graph. The other category of scaffolding algorithms [<xref ref-type="bibr" rid="B13">13</xref>,<xref ref-type="bibr" rid="B15">15</xref>], formulate the problem in terms of graph theoretic constructs in which vertices of the graph are associated to contigs and edges encode mate pair information. Although our approach to the scaffolding problem has partial similarity to this last category, our solution strategy is different, as we will explain. Our algorithm could be implemented, in principle, for any kind of mate pairs, from Sanger reads to the HTS data. However, the special challenges inherent in scaffolding with short read data necessitate an approach that is more sophisticated than those developed so far. That is why we implemented and tested SOPRA in the context of short reads from next-generation technologies.</p>
    <p>Existence of repetitive regions in DNA, errors in the sequencing process and mis-assembly of short reads into contigs are all factors which contribute to the complexity of scaffold building using mate pair information. This complexity arises in the form of apparent inconsistency among the set of constraints laid by the mate pairs. Detecting and eliminating the sources of these inconsistencies is essential for the success of any algorithm dealing with mate pair data. This issue is especially important in the context of short read data, since, we expect a higher number of problematic mate pair constraints in the process of scaffold building.</p>
    <p>Existing scaffolding algorithms follow a greedy approach, starting with certain schemes of ordering the contigs and pairing information. The mate pairs are then iteratively incorporated as long as the new information does not conflict with the previously assembled scaffolds. In other words, at each step, only a subset of contigs and links in between are considered to improve the assembly. Given the nature of short read data, solution strategies employed in previous studies face difficulties for such data [<xref ref-type="bibr" rid="B16">16</xref>].</p>
    <p>In this paper, we present SOPRA (Statistical Optimization of Paired Read Assembly), a new tool for de novo assembly of short reads produced by new sequencing platforms. The design of SOPRA is especially targeted to exploit the mate pair information in the process of scaffold assembly. In other words, SOPRA is a module that can be combined with any of the available algorithms for contig assembly. Such a modular design allows greater flexibility and control over the scaffold building process, as has been noted before [<xref ref-type="bibr" rid="B15">15</xref>]. SOPRA proceeds in an iterative fashion where at each step problematic mate pair constraints are detected and removed. At each step, one finds a solution consistent with most of the constraints by statistically optimizing over a cost function. Then, one relaxes the most violated constraints. This alternation between removing suspicious data and optimization continues, till we get scaffolds consistent with the remaining trusted constraints.</p>
    <p>Among the available <italic>de novo </italic>assemblers, as far as we are aware, Velvet [<xref ref-type="bibr" rid="B8">8</xref>] is the only one that can handle color-space data. Adapting available assemblers for color-space data is not a trivial task, since, naive translation from color-space to base-space leads to serious error amplification [<xref ref-type="bibr" rid="B17">17</xref>]. Particular attention was paid so that SOPRA could handle data from the SOLiD platform. The final output, given in base-space, is constructed from the color-space assembly, as well as from additional information obtained by translating only the first color call of all the reads. This method will prevent the propagation of the error that can happen in the naive translation. SOPRA is available freely, under the GNU Public License, at <ext-link ext-link-type="uri" xlink:href="http://www.physics.rutgers.edu/~anirvans/SOPRA/">http://www.physics.rutgers.edu/~anirvans/SOPRA/</ext-link></p>
  </sec>
  <sec>
    <title>Results and Discussion</title>
    <p>The flow chart of the assembly process is shown in Figure <xref ref-type="fig" rid="F1">1</xref>. Below, we will explain each section in more details.</p>
    <fig id="F1" position="float">
      <label>Figure 1</label>
      <caption>
        <p><bold>Flow chart of the algorithm</bold>. In principle, the contig assembly can be performed using any of the available contig assembly algorithms. SOPRA uses the mate pair information to assemble contigs into scaffolds. S-SOPRA and V-SOPRA correspond to the integration of SOPRA with SSAKE and Velvet respectively.</p>
      </caption>
      <graphic xlink:href="1471-2105-11-345-1"/>
    </fig>
  </sec>
  <sec>
    <title>Contig Assembly Preliminaries</title>
    <p>As we mentioned, SOPRA is focused on scaffold assembly. The information SOPRA needs from a contig assembler is the computed positions of reads in each contig. SOPRA reconstructs the contigs based on this information. Note that, in the case where these reads do not show perfect overlap, reconstruction of the contigs by SOPRA may not agree with the output of the original contig assembler.</p>
    <p>In this paper, we present the performance of SOPRA integrated with two particular contig assembly algorithms, namely, SSAKE [<xref ref-type="bibr" rid="B7">7</xref>] and VELVET [<xref ref-type="bibr" rid="B8">8</xref>]. We will refer to these two versions as S-SOPRA and V-SOPRA, respectively. This integration is relatively straightforward and described in the Methods section. However, for color-space data, there is one additional step of translating the assembled contigs to base-space.</p>
    <sec>
      <title>Robust translation of contigs assembled in color-space</title>
      <p>SOLiD (Sequencing by Oligonucleotide Ligation and Detection) is a novel HTS platform. It uses four fluorescent color probes (coded as 0-3) for reading dinucleotides, namely, two neighboring bases at a time. The sixteen possible dinucleotide combinations are divided into groups of four, each of which is assigned a unique color (e.g. color 2 is assigned to combination AG, GA, TC and CT). However, the groups are designed in such a way that, every combination of the first base and the color call uniquely determines the second base. In other words, each color encodes a transition matrix in the base-space.</p>
      <p>Each SOLiD read starts with a reference base, the last base in the primer (usually T or G), followed by a certain number of color calls e.g. G10223...330. Using the reference base and the first color call, we can find the first letter base, which in turn can be combined with the second color call to obtain the second letter base. Continuing so forth, we can translate the whole sequence from color-space to the conventional base-space. The issue is if one of the color calls is wrong (because of an error in the sequencing process), the whole translation from that point on will be wrong. In other words, one error in the color-space will propagate into many errors in base-space. It is because of this error rate magnification that we do not simply translate the SOLiD output directly to the base-space. Instead, SOPRA translates the resulting color-space assembly using a dynamic programming method that avoids such error propagation, as we will explain below.</p>
      <p>We only translate the first color call (using the reference base) to the base-space but keep the rest of the sequence in color-space. This means a library of sequences, each of which consists of a reference base and <italic>L </italic>color calls, will become a library of sequences that start with a DNA base followed by <italic>L </italic>- 1 color calls. If we ignore for a moment the first DNA base, we can use the <italic>L </italic>- 1 base long sequences for contig assembly in the same way as in regular base-space data. Of course, the result of this assembly will be contigs in the color-space. Although we do not use the first letter base of the sequences in the assembly process, once a sequence is used in building a contig, we record where on the contig the first letter base of the corresponding sequence lies (Figure <xref ref-type="fig" rid="F2">2</xref>). Notice that the first letter base lies between two color calls and serves as a suggestion for what the DNA base at that position should be. On the other hand, each color call is located between two neighboring DNA bases and provides information about the corresponding dinucleotide.</p>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p><bold>Robust translation from color-space to base-space</bold>. The base-space suggestions, obtained by translating only the first color call of each read, are shown in magenta. Contig assembly is performed using only the color part (indicated by numbers 0-3) of each sequence. Inconsistencies between the color-space calls and the base-space suggestions, signals the presence of errors. We use an error probability model to find the most likely DNA sequence consistent with this data. The underlined color calls and suggestions in the figure are declared as mistakes in the final translation.</p>
        </caption>
        <graphic xlink:href="1471-2105-11-345-2"/>
      </fig>
      <p>At this point, the assembly result is a sequence in color-space, <italic>C</italic>, plus some letter base suggestions at certain locations of each contig, <italic>F</italic>. In Figure <xref ref-type="fig" rid="F3">3</xref>, the color-space contig is represented using blue numbers 0-3, whereas, base-space suggestions are shown in magenta. Now, we pose the following question: Given a color-space sequence plus its letter base suggestions, what is the most likely DNA sequence which gave rise to this data? We will set up a model that allows for mistakes in the base suggestions as well as in the assembled color-space contigs. To each arbitrary base-space sequence, the model assigns a probability for that sequence to be the real DNA sequence. The final translation output would be the base-space sequence that maximizes this probability.</p>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p><bold>Histogram of separation between locations of two reads of a mate pair on the reference genome</bold>. This histogram appears to be a combination of two parts. One part is a distribution peaked around the insert size of the mate pair library, as expected. However, in addition, there is a broad background. (A) <italic>E. coli </italic>data from SOLiD platform. (B) <italic>E. coli </italic>dataset, but limited to pairs for which the separation is around the peak region in (A). (C) <italic>P. syringae </italic>data from Illumina platform. (D) <italic>P. syringae </italic>dataset, but limited to pairs for which the separation is around the peak region in (C). Both distributions in (B) and (D) have large standard deviations, each around 20% of the corresponding mean values.</p>
        </caption>
        <graphic xlink:href="1471-2105-11-345-3"/>
      </fig>
      <p>The reason why this method prevents propagation of error can be intuitively understood as follows. If the presence of a color call error is ignored, the naÃ¯ve translation will disagree with most of the base-space suggestions. If this disagreement goes on for a long stretch, from the perspective of the probability function, it is better to declare that particular position to be a color call error and replace it with another color such that the translation becomes consistent with the stretch of base-space suggestions. The ability to alter a color call to enhance the consistency with base suggestions in long stretches helps not only with substitution errors, but also helps to compensate for inconsistency arising from indels. The details of the model are explained in the Methods section.</p>
    </sec>
    <sec>
      <title>Contig self-consistency check</title>
      <p>We implemented the self-consistency checks described below only in S-SOPRA. The reason for these checks is that the programs, like SSAKE, which use a greedy algorithm for contig assembly, are particularly vulnerable to generating chimeric contigs. If two legs of a mate pair are located on the same contig, then their relative orientation and position in the contig should match the ones suggested from the mate pair link. If we observe more than certain number of times (threshold is a parameter of the software) cases where the orientation disagrees or the separation between reads is more than one standard deviation different from the insert size, we discard that contig. This method, however, does not necessarily detect chimeric contigs where two or more regions from different parts of the genome have been mis-assembled into one contig. Mate pair information can be used to detect such mis-assemblies, as explained below.</p>
      <p>If a contig is genuine, there should be several mate pairs connecting different locations on the same contig (assuming the contig is at least a few times longer than the insert size of mate pairs). However, if it is the case that the contig is composed of two or more sequences coming from different parts of the genome, there should not be as many mate pair links connecting those sequences together. For each point on a contig, we count how many mate pair links connect the right side of that point to the left side. If this number is particularly low for some region, we cut the contig into two at that position.</p>
    </sec>
    <sec>
      <title>Estimation of insert size</title>
      <p>In the case where there are enough long contigs, the typical value of the insert size can be estimated from the mate pairs located on the same contig. To do so, we first remove the outliers for which the separation between the pair is different from the suggested insert size by more than the value of the suggested insert size (or equivalently, more than five times the standard deviation, if we assume it is 20% of the suggested insert size). The empirical insert size is equal to the mean value of the separation for the remained pairs. The user needs to know only an approximate value for the insert size based on the library preparation protocol. Prior knowledge of the typical insert size needs to be accurate only when almost all contigs are smaller than the typical inserts.</p>
      <p>In case the insert size targeted by the library preparation methods is not available to the user, he/she could take advantage of the empirical distribution of insert sizes output by SOPRA and determine the typical insert size by inspection. In any case, it is a good idea to inspect this distribution, to ascertain the quality of the mate pair library.</p>
    </sec>
    <sec>
      <title>Removal of reads in high coverage regions from scaffolding process</title>
      <p>A contig containing repetitive regions can provide conflicting mate pair constraints and cause mis-assembly in the scaffolding process. Although, one could take up the problem of resolving the repeat structures, our approach currently is to identify and remove such contigs from the scaffolding process. One way of detecting repeats is by looking for high coverage regions in each contigs. If a contig has high mean coverage (determined by a parameter of the software) we remove such a contig from scaffold assembly before starting the process. Some contigs have high coverage locally without having high mean coverage. We exclude mate pairs with reads falling in such local high coverage regions for the scaffolding considerations as well (the threshold is a parameter of the software).</p>
    </sec>
  </sec>
  <sec>
    <title>Scaffold Assembly</title>
    <p>If two legs of a mate pair are incorporated into two separate contigs, we can infer the relative orientation and relative position of those two contigs on the genome. However, such ordering of contigs is not an easy task, since, the constraints imposed by mate pairs are often not self-consistent. The best one can do is to assign the orientations and positions so that as many constraints as possible are satisfied. In addition, there can be misleading or incorrect information. These dubious constraints arise not only from issues like erroneous contig assembly, but also from innate problems in mate pair data itself.</p>
    <p>To elucidate this point, let us examine the two real libraries discussed below in the performance comparison section. In Figure <xref ref-type="fig" rid="F3">3</xref>, we plot the histogram of separation between the two reads belonging to a mate pair, obtained by matching the reads to the reference genome. As we can see, the distribution of separation could be thought of as a combination of a sharp peak and a broad background that spans over the entire length of the genome. Even if we limit ourselves to the sharp peak (Figures <xref ref-type="fig" rid="F3">3B</xref> and <xref ref-type="fig" rid="F3">3D</xref>), the standard deviation is around 20% of the mean value. The variability in separation is much larger than values used for generating simulated data in some studies [<xref ref-type="bibr" rid="B8">8</xref>,<xref ref-type="bibr" rid="B9">9</xref>]. The algorithm for position assignment has to be robust to such large degree of uncertainties. As will be discussed in the coming sections, in our approach, this goal is achieved by identifying and removing those mate pairs that belong to the broad background as well as from averaging effect of imposing all the remaining constraints together.</p>
    <p>For contig building, it is often convenient to represent the sequence overlap information using graph theoretic constructs, e.g. in terms of an overlap graph or a de Bruijn graph. Similarly, it is useful to encode the constraints given by mate pair information into a graphical model. In this model, the underlying undirected graph has vertices corresponding to each contig. Any two contigs connected through mate pairs have an edge in between. We call this graph the contig connectivity graph. This graph is similar to the contig-mate-pair graph introduced in [<xref ref-type="bibr" rid="B13">13</xref>], except that here each contig is represented by a single vertex as opposed to two. This kind of graph structure has been used in other studies as well [<xref ref-type="bibr" rid="B15">15</xref>]. The structure of the contig connectivity graph, at different stages of the assembly, can be visualized with the help of programs such as GraphViz package [<xref ref-type="bibr" rid="B18">18</xref>].</p>
    <p>In our formulation, orientations and positions for each contig are variables living on the vertices of this graph. If we introduce the mate pair information as probabilistic constraints on relative orientations and positions of neighboring vertices on the graph, this graphical model has the structure of a Markov random field model [<xref ref-type="bibr" rid="B19">19</xref>]. Markov random field models were originally inspired by problems in statistical physics. There are relatively obvious connections between finding the ground state (the most probable configuration of Markov random field) of certain statistical physics models and well-known graph optimization problems as was pointed out by several researchers in the eighties [<xref ref-type="bibr" rid="B20">20</xref>]. Such analogies also led to the simulated annealing [<xref ref-type="bibr" rid="B21">21</xref>] as a heuristic method for solving hard combinatorial optimization problems (see [<xref ref-type="bibr" rid="B22">22</xref>] for a review). We will explain our procedure by invoking the physical analogies, but one could often describe the same procedure using a language familiar to computer scientists.</p>
    <p>We perform the scaffolding in two steps. We first assign the orientation of contigs, without considering their positions. Once the orientation is determined, in the second step, we calculate the position of contigs. In this second step, we only use those mate pair links which are consistent with the orientation assigned in the first step. In principle, one could have optimized for orientation and position together, however, our two steps process simplifies the algorithm.</p>
    <p>One additional constraint is that distinct contigs cannot be assigned to the same or overlapping positions. This should be true for every possible pair of vertices. This means that if we want to impose this condition in the contig connectivity graph, every possible pair of vertices will be connected by an edge representing this non-overlapping condition. In other words, every vertex will be directly connected to all other vertices. In this sense, the Markov random field structure on the contig connectivity graph is violated. We first solve for orientations and positions ignoring the non-overlapping constraints. The resulting solution typically includes some scaffolds for which the non-overlap condition is not satisfied. We segment these scaffolds into smaller scaffolds satisfying the non-overlap condition using another Markov random field model living on a new graph obtained by augmenting the contig connectivity graph with additional edges between apparently overlapping contigs.</p>
    <sec>
      <title>Determining the relative orientation</title>
      <p>We indicate the two possibilities for the orientation of contig <italic>i </italic>by <italic>S</italic><sub><italic>i </italic></sub>= 1 and <italic>S</italic><sub><italic>i </italic></sub>= - 1. If two contigs <italic>i </italic>and <italic>j </italic>are connected through mate pair links, we associate a number to it, denoted by <italic>J</italic><sub><italic>ij</italic></sub>. The sign of <italic>J</italic><sub><italic>ij </italic></sub>is positive if the links suggest that two contigs have the same orientation, otherwise it is negative. The absolute value of <italic>J</italic><sub><italic>ij </italic></sub>is equal to the number of links that connect the two contigs. If all the mate pairs connecting two contigs do not agree with each other, we require that at least a significant majority do. To be a significant majority, we require the percentage of the mate pairs in the dominant group to be higher than a certain threshold, which is a parameter in the software. Otherwise, all the links between those contigs are ignored.</p>
      <p>The reason for rejecting all these links is as follow. For two close-by genuine contigs, not belonging to repeats, the source of orientational conflicts is the presence of spurious mate pairs. Usually, these inconsistent spurious links form a small minority. However, when a part of a contig belongs to repetitive regions or one of the contig is chimeric, the nature of the orientational conflicts is different. For example, it is likely that part of the mate pair information suggests the contig belongs to one strand while some other part of the information suggest it belongs to the other strand. In such cases, the majority group and the minority group can have comparable number of links. If a significant majority of links do agree, the minority links are ignored suspecting that they are spurious. If the numbers are comparable, then all links are ignored for the reason mentioned above.</p>
      <p>For each configuration of orientations, <italic>S </italic>= (<italic>S</italic><sub>1</sub>,<italic>S</italic><sub>2</sub>,...,<italic>S</italic><sub><italic>N</italic></sub>), <italic>N </italic>being the number of contigs, we define the following cost function:<disp-formula id="bmcM1"><label>(1)</label><graphic xlink:href="1471-2105-11-345-i1.gif"/></disp-formula></p>
      <p>This quantity, a measure of how many of the mate pair links are satisfied, could be thought of as the energy of an Ising spin system with interactions <italic>J</italic><sub><italic>ij</italic></sub>. If it were possible to find a configuration to satisfy all the constraints, we would have: <italic>sign </italic>(<italic>J</italic><sub><italic>ij</italic></sub>) = <italic>sign </italic>(<italic>S</italic><sub><italic>i </italic></sub><italic>S</italic><sub><italic>j</italic></sub>), â <italic>i</italic>, <italic>j</italic>. The energy of this configuration would be: <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i2.gif"/></inline-formula>. As we mentioned before, it is often the case that such a configuration does not exist. Therefore, our goal is to find the best configuration in which as many mate pair links as possible are satisfied. Effectively, we want to find the orientation assignment that minimizes the energy function in Equation (1) (Figure <xref ref-type="fig" rid="F4">4A</xref>). This minimization is equivalent to the maximum weight cut problem, which appeared in the context of shotgun sequencing [<xref ref-type="bibr" rid="B23">23</xref>] and of scaffold assembly [<xref ref-type="bibr" rid="B15">15</xref>]. Given that this problem is NP-complete [<xref ref-type="bibr" rid="B24">24</xref>,<xref ref-type="bibr" rid="B25">25</xref>], it is natural to search for heuristic methods. The approach of these earlier studies is to resolve the constraints in the scaffold assembly problem through particular greedy algorithms that depend upon ad hoc schemes of ordering the contigs. The contrast between such approaches and ours will become clear, as we will explain our algorithm in the Methods section.</p>
      <fig id="F4" position="float">
        <label>Figure 4</label>
        <caption>
          <p><bold>Modeling constraints on the contig connectivity graph</bold>. (A) For two contigs <italic>i </italic>and <italic>j </italic>connected through mate pairs, the quantity <italic>J</italic><sub><italic>ij </italic></sub>encodes the information about relative orientation (sign of <italic>J</italic><sub><italic>ij</italic></sub>) and number of mate pairs connecting those contigs (absolute value of <italic>J</italic><sub><italic>ij</italic></sub>). Minimizing the energy produces an orientation assignment that satisfies as many constraints as possible. The constraints that are not satisfied in the optimal configuration (shown in red) are ignored in the next part. (B) To determine the relative position of contigs, we model the collection of mate pairs connecting contigs <italic>i </italic>and <italic>j </italic>as a spring attached to the start points of those contigs. The relaxed length of this spring, <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i3.gif"/></inline-formula>, is equal to the average suggested distance between the start points of those contigs given by mate pair constraints.</p>
        </caption>
        <graphic xlink:href="1471-2105-11-345-4"/>
      </fig>
    </sec>
    <sec>
      <title>Determining the relative position</title>
      <p>For determining the relative positions of contigs, we only use the mate pair links that are orientation-wise consistent with the optimal configuration found in the previous section. Consider a set of contigs connected through mate pair links. Let <italic>X </italic>= (0,<italic>x</italic><sub>2</sub>,...,<italic>x</italic><sub><italic>N</italic></sub>), denotes the positions of the start points of these contigs. By putting <italic>x</italic><sub>1 </sub>= 0, we have chosen a particular system of coordinates. Each mate, <italic>r</italic>, connecting contigs <italic>i </italic>and <italic>j</italic>, provides us with some information about <italic>x</italic><sub><italic>i </italic></sub>- <italic>x</italic><sub><italic>j</italic></sub>, encoded in the probability distribution <italic>p</italic><sup><italic>r</italic></sup>(<italic>x</italic><sub><italic>i </italic></sub>- <italic>x</italic><sub><italic>j</italic></sub>). This distribution is picked around certain value, <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i4.gif"/></inline-formula>, which can be determined from the location of the two reads in the corresponding contigs and the insert size of the mate pairs (the formula is presented in the Methods section).</p>
      <p>Had we not assigned the orientations, one could still define <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i5.gif"/></inline-formula>, with the orientations only affecting the sign of the quantity. Note that <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i6.gif"/></inline-formula> is the suggested distance between the corresponding contigs, whereas, the sign determines the ordering (i.e. which one is to the left and which one is to the right). In Figure <xref ref-type="fig" rid="F4">4A</xref>, next to each edge, we just show <italic>J</italic><sub><italic>ij</italic></sub>'s. However, each edge also carries the additional information on the relative position of the corresponding contigs (<inline-formula><inline-graphic xlink:href="1471-2105-11-345-i4.gif"/></inline-formula>'s). Before assigning the orientation, the contig connectivity graph does not fully capture the ordering of contigs, since, as we explained, <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i4.gif"/></inline-formula> is determined up to a sign. After the orientation assignment, the full information about relative position of contigs is captured by this graph.</p>
      <p>The overall information provided by all the mate pairs linking contigs <italic>i </italic>and <italic>j </italic>is given by <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i7.gif"/></inline-formula>. Note that | <italic>J</italic><sub><italic>ij </italic></sub>| is the number of mate pairs bridging between contigs <italic>i </italic>and <italic>j</italic>. We do not know the exact form of <italic>p</italic><sup><italic>r </italic></sup>(<italic>x</italic><sub><italic>i </italic></sub>- <italic>x</italic><sub><italic>j</italic></sub>); however, if we take it to be a Gaussian centered around <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i4.gif"/></inline-formula>, we will have:<disp-formula id="bmcM2"><label>(2)</label><graphic xlink:href="1471-2105-11-345-i8.gif"/></disp-formula></p>
      <p>where <italic>Ï </italic>corresponds to the variance in the insert size of mate pairs. Our approach is to determine the relative position of contigs by maximizing the joint probability distribution:<disp-formula id="bmcM3"><label>(3)</label><graphic xlink:href="1471-2105-11-345-i9.gif"/></disp-formula></p>
      <p>where <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i10.gif"/></inline-formula> is the average suggested distance between the start points of contigs <italic>i </italic>and <italic>j</italic>. Equivalently, one could minimize the function:<disp-formula><graphic xlink:href="1471-2105-11-345-i11.gif"/></disp-formula></p>
      <p>This function has an alternative interpretation as the energy of a coupled system. In this analogy, the collection of mate pairs between two contigs <italic>i </italic>and <italic>j </italic>is replaced by a spring connecting the start points of those contigs. The spring constant is equal to | <italic>J</italic><sub><italic>ij </italic></sub>|, and the relaxed length of the spring is given by <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i3.gif"/></inline-formula>. In this way, the original system of contigs connected through a network of mate pairs is modeled as a system of objects connected through a network of springs (Figure <xref ref-type="fig" rid="F4">4B</xref>). The solution maximizing the probability given in Equation (3) corresponds to the equilibrium position (<italic>X</italic>*) of the objects in the spring system. These positions could be calculated by solving a set of linear equations corresponding to the force on each object being zero.</p>
      <p>In the equilibrium position, if the distance between two contigs is equal to the distance suggested by the mate pairs connecting them, then the corresponding spring is relaxed; otherwise, the spring is either stretched or compressed. In other words, we could define <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i12.gif"/></inline-formula> as a measure of the degree to which the mate pair constraints are violated. If all the suggested distances were self-consistent, all Î<sub><italic>ij</italic></sub>'s would be nearly zero (no stretch/compression in the springs). In real data, it is possible that some sequences match in several locations on the genome, and therefore, mate pair information would not uniquely determine the position of contigs. In our model, the sign of this non-uniqueness is that in the equilibrium solution, <italic>X</italic>*, some of the springs will be stretched or compressed. The same situation can arise because of contig mis-assembly where two separate regions of the genome are joined into one contig.</p>
      <p>When there is a stretched or compressed spring, we remove the contigs attached to the end of that spring from the system and restart the scaffold assembly on the remaining contigs. In other words, we go back to the orientation assignment step (Figure <xref ref-type="fig" rid="F1">1</xref>). The cycle stops when in the equilibrium position, all the springs are close to their relaxed state, namely, all Î<sub><italic>ij</italic></sub>'s are below a certain threshold. Note that <italic>X</italic>* is the positions of the start points of contig. If the orientation of contig <italic>i </italic>is positive, it means that it covers the interval <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i13.gif"/></inline-formula> on the scaffold. If <italic>i </italic>has negative orientation, we assign the reverse complement of <italic>i </italic>to the interval <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i14.gif"/></inline-formula>.</p>
      <p>The greedy algorithms, previously applied to the combinatorially difficult problem of assigning relative positions, consider contigs in a certain order; an order that depends on the number of links associated with each contig [<xref ref-type="bibr" rid="B13">13</xref>,<xref ref-type="bibr" rid="B15">15</xref>]. Potentially, such methods could be prone to incorporating repeats/chimeric contigs which could have significant number of links associated with it. In contrast, our method has the advantage of providing an unambiguous means for flagging misleading distance constraints with having to commit to any such order.</p>
    </sec>
    <sec>
      <title>Detecting tangled scaffolds by the contig density profile</title>
      <p>We calculated the position of the contigs in a scaffold from a set of linear equations based on the assumption in Equation (2). Of course, position intervals corresponding to distinct contigs should be non-overlapping. However, the solution of these linear equations is not guaranteed to satisfy this non-overlap condition. In fact, such overlapping configurations do arise in practice. Below, we explain some of the causes leading to this problem.</p>
      <p>Consider the scenario described in Figure <xref ref-type="fig" rid="F5">5A</xref>. There are two sets of contigs, shown in green and magenta, belonging to distinct regions of the genome. Contigs within each set are self-consistently connected through mate pairs. Assume during contig assembly, contig 3 from the first set and contig 7 from the second set get mis-assembled into one contig. In this case, we obtain a scaffold that contains all the contigs and yet, does not have any stretched or compressed spring.</p>
      <fig id="F5" position="float">
        <label>Figure 5</label>
        <caption>
          <p><bold>Detecting and resolving scaffold mis-assembly using density profile and Potts model</bold>. (A) Two scaffolds, shown in green and magenta, belong to the different regions of the genome. Mis-assembly of a chimeric contig composed of contig 3 from the green scaffold and contig 7 from the magenta scaffold causes the two distinct scaffolds to join together. In the new scaffold, many positions are covered by two contigs. (B) For a genuine scaffold, the density profile (see text for definition) should be close to one (or zero for gaps). The plot shows the density profile for a mis-assembled scaffold obtained in the assembly process of a real dataset from the <italic>E. coli </italic>genome. Each point along the x-axis represents a window of length 1000 bases along the scaffold. The y-axis shows the average density for positions located within each window. From this profile, we can infer that at least four scaffolds have been mis-assembled together. (C) Our labeling method for dividing contigs into distinct groups for the case shown in (A) can lead to any of the three possibilities shown here. We use color to present different labels. Note that the problematic contig (3-7) always lies at the boundary between different groups.</p>
        </caption>
        <graphic xlink:href="1471-2105-11-345-5"/>
      </fig>
      <p>In addition to contig mis-assembly, existence of repetitive regions in the genome is another factor that can cause improper joining of multiple scaffolds. In that case, contigs 3 and 7 in Figure <xref ref-type="fig" rid="F5">5A</xref> are seen as one contig in the assembly, whereas they are really copies of the same sequence that matches on multiple places on the genome. Each copy can cause the mis-incorporation of a new set of contigs from its neighbors.</p>
      <p>In order to detect this type of complication, we define the 'density profile', a quantity that represents how many contigs cover each region of a scaffold. In the final assembly output, this density should be near one for all regions of each scaffold (except for gaps where the density is zero). For a configuration like in Figure <xref ref-type="fig" rid="F5">5A</xref> most of the points in the problematic region are covered by two contigs, leading to a higher density. Therefore, by inspecting the density profile, we expect to detect these cases where two or more scaffolds are mis-assembled into one scaffold. Figure <xref ref-type="fig" rid="F5">5B</xref> shows the density profile obtained in the assembly process of a real dataset from <italic>E. coli </italic>genome (discussed below in the performance comparison section). Notice that there are two regions with density above the background density of one, and that those high densities are in fact very close to integers (3 and 2). The nearly integral values indicate how many potentially distinct scaffolds have been joined together.</p>
    </sec>
    <sec>
      <title>Scaffold segmentation</title>
      <p>After detecting high-density regions, we need a procedure to identify and remove the problematic contigs that lead to the merger of disjoint scaffolds. We will call these contigs "junctures" for future references. We wish to assign the rest of the contigs into distinct scaffolds in such a way that each scaffold has an acceptable density profile. With that goal in mind, we provide each contig <italic>i </italic>with a variable <italic>Ï</italic><sub><italic>i</italic></sub>. One could think of <italic>Ï</italic><sub><italic>i</italic></sub>'s as a putative scaffold label. From the density profile, we can determine <italic>q</italic>, the total number of distinct labels (scaffolds) that we need. For example, the profile in Figure <xref ref-type="fig" rid="F5">5B</xref> implies <italic>q </italic>= 4.</p>
      <p>We want to assign the labels according to two criteria. On one hand, we want the contigs that are directly connected by mate pairs to have the same label. On the other hand, we want the contigs that lie over each other to have different labels. To present these criteria mathematically, we define two matrices <italic>D </italic>and <italic>O</italic>. If contigs <italic>i </italic>and <italic>j </italic>are directly connected by mate pairs, the matrix element <italic>D</italic><sub><italic>ij </italic></sub>is one; otherwise, it is zero. The matrix element <italic>O</italic><sub><italic>ij </italic></sub>is a positive number monotonically increasing with the length of the region that contigs <italic>i </italic>and <italic>j </italic>cover simultaneously. We want to find the label assignment that minimizes the following cost function:<disp-formula id="bmcM4"><label>(4)</label><graphic xlink:href="1471-2105-11-345-i15.gif"/></disp-formula></p>
      <p>Here, <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i16.gif"/></inline-formula> is the Kronecker delta; it is one if <italic>Ï</italic><sub><italic>i </italic></sub>and <italic>Ï</italic><sub><italic>j </italic></sub>are equal and zero otherwise. This cost function is exactly the energy of a q-state Potts model with both ferromagnetic and antiferromagnetic interactions. We use a simulated annealing method [<xref ref-type="bibr" rid="B21">21</xref>] to find a configuration of label assignment that minimizes the above energy (details explained in the Methods section).</p>
      <p>In the minimum energy configuration, neighboring contigs belonging to the same scaffold prefer to have the same label while contigs belonging to different scaffolds, juxtaposed in position space, prefer to have different labels. This is a direct consequence of the two criteria with which we began. However, these two criteria cannot be satisfied everywhere at the same time. Around the junctures, namely, contigs joining such juxtaposed scaffolds, the two criteria are at conflict with each other. The result of this conflict is the formation of domain boundaries (change of label) in the neighborhood of the junctures. To get a better sense of this phenomenon, let us revisit the example in Figure <xref ref-type="fig" rid="F5">5A</xref>. The result of label assignment by our algorithm could give rise to any of the three configurations in Figure <xref ref-type="fig" rid="F5">5C</xref> (different labels are shown by different colors). Note that the juncture is always located at the boundary where different labels meet.</p>
      <p>Motivated by this discussion, we form an initial list of suspected junctures from the contigs located at label boundaries, namely, contigs having at least one neighbor with a different label. This list often has much fewer members than the original set that we started with. Ideally, one would like to consider the result of removing all the different combinations of suspected contigs from the original set to check if it resolves the problems in density profile. An exhaustive search over all combinations becomes possible when the list is small. Otherwise, one has to limit the list to members located at the densest part of the scaffold. If the list is still too large, we have to proceed with a randomly chosen subset.</p>
      <p>After removing any subset of these suspected junctures from the original set of contigs, the remaining set of contigs will form one or more connected components. We score each subset by combining two numbers, one penalizing the formation of too many small components and the other penalizing the presence of high-density regions. We choose the best scoring subset to be removed and focus on the resulting connected components.</p>
      <p>For each connected component, we check whether the corresponding density profile is free of high-density regions. All connected components with satisfactory density profiles are declared to be new scaffolds. For the rest, we restart the labeling process individually for each component, and continue this process until all the components have satisfactory density profiles. The removed contigs, either in the Potts model or in the spring model, are reported as single contigs at the end of the assembly.</p>
      <p>The Potts model based approach is different from the formulation in terms of non-self-overlapping path introduced in Pop <italic>et al. </italic>[<xref ref-type="bibr" rid="B15">15</xref>]. The method of arbitrarily picking the longest non-self-overlapping path [<xref ref-type="bibr" rid="B15">15</xref>] through the tangle might end up joining two scaffolds wrongly. In our method, we remove the problematic contigs, even if, in some cases, it could lead to some good scaffold breaking up. If there are mate pairs overarching the removed contigs, it is possible for scaffolds to have the correct continuation. This is the case for the example in Figure <xref ref-type="fig" rid="F5">5A</xref>, since contigs 6 and 8 are connected by a mate pair overarching contig 7.</p>
    </sec>
    <sec>
      <title>Contig joining and gap estimation</title>
      <p>In the last stage of scaffold assembly, we decide whether neighboring contigs in a scaffold are to be joined or be separated by a gap. Notice that according to the computed positions, the end of two neighboring contigs might still have a small positional overlap (the density profile is sensitive only to overlaps larger than a few bases); otherwise, they will be separated by a gap. In either the case of positional overlap or the case where the estimated gap is smaller than certain value (e.g. 10 bases), if the ends of neighboring contigs are similar, we join those two contigs. For the rest of the cases, we insert a sequence composed of letter 'N' between the contigs. The length of each sequence is decided by rounding the length of the corresponding gap to the closest multiple of 50. In the special case where there is no sequence similarity, despite the positions indicating a small overlap, we separate the contigs by a 50 base long sequence of 'N'.</p>
    </sec>
  </sec>
  <sec>
    <title>Assembly Performance on Real Data</title>
    <sec>
      <title>Metrics of assembly quality</title>
      <p>Before we discuss our results, we need to define how we assess the quality of a <italic>de novo </italic>assembly. The first obvious measure of performance is the typical size of assembled contigs and scaffolds. This quantity is often reported in terms of an N50 value. Roughly speaking, half of the bases are covered by contigs/scaffolds that are longer than the N50 value. However, N50 provides no indication of the accuracy of the assembled contigs/scaffolds. In order to evaluate the quality of the assembly, it is common to study the performance of the algorithm on data from known genomes. While comparing the assembled components to the reference genome, we need to pay attention to different kinds of errors that could arise and define the metrics of performance accordingly.</p>
      <p>To define such metrics, let us bear the following question in mind: In order to map a contig to the reference genome, what type of different operations do we need to do? For example, it might be possible for an entire contig to be matched to a continuous part of the genome with a few mismatches and indels. However, it could also be the case that the contig cannot be matched to a continuous region of the genome; instead, different parts of the contig might match to different regions of the reference genome. Of course, for some contigs, one might not find any significant match at all. In addition to errors in the contigs, there would also be errors in the assignment of relative positions and orientations of contigs in a scaffold.</p>
      <p>It is common in the sequence assembly literature to single out mismatch rates and combine some of the other kinds of errors in the 'no-match' category. The emphasis of our algorithm is on using the mate pair information for orienting, positioning and joining contigs. Improper execution of these tasks leads to the formation of chimeric contigs, dislocation and inversion of contigs in a scaffold, as well as merger of distinct scaffolds. Metrics for quality assembly corresponding to these categories of errors are essential for fair comparison among different algorithms. In general, for each algorithm, there is a trade-off between building large scaffolds and making small number of mistakes. For example, a cautious algorithm might produce smaller scaffolds rather than keep on joining suspicious fragments together.</p>
      <p>Following the spirit of the above discussion, we will define four categories of errors in order to assess the quality of the assembly. We used MegaBLAST [<xref ref-type="bibr" rid="B26">26</xref>] with a minimum identity threshold of 92% to align the sequences against the reference genome (Refseq: NC_007005 for <italic>P. syringae </italic>and NC_010473 for <italic>E. coli</italic>). The sum of the length of all the contigs for which no BLAST hit is found, expressed as a percentage of total assembled bases, is reported as the no-match error rate, <italic>Îµ</italic><sub><italic>no_m</italic></sub>. Each BLAST hit for a contig comes with a number of mismatches and short indels. Mismatch error rate, <italic>Îµ</italic><sub><italic>mis_m</italic></sub>, reports the total number of mismatches and indels as a percentage of total assembled bases. In addition, if only some parts of a contig do not match to the reference genome, the total length of those parts contributes to mismatch counts as well.</p>
      <p>As we discussed above, there are other types of error that lead to large-scale 'rearrangements' of genomic sequence. The use of the term 'rearrangement error' is inspired by the analogy with the process of genome evolution. Just as local errors in assembly have similarity to mutations and indels, the large scale errors in assembly, have their evolutionary analogues: inversion, translocations etc.</p>
      <p>These rearrangement errors, measured in the unit of number of events per Mbp of assembly, are divided into the following categories. The error rate <italic>Îµ</italic><sub><italic>ch </italic></sub>is associated with chimeric mis-assemblies, namely, the cases where two distinct parts of the genome have been joined into one contig. For chimeric contigs, we would like to differentiate between the cases where the real gap between mis-assembled parts is in the order of few hundred bases and the cases where this gap is in the order of, for example, a few megabases. Therefore, overall error rate <italic>Îµ</italic><sub><italic>ch </italic></sub>is broken down to two parts, <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i17.gif"/></inline-formula> and <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i18.gif"/></inline-formula>, accounting for chimeric contigs involving gaps smaller or larger than 500 bases, respectively.</p>
      <p>Apart from the issue of chimeric contigs, we also have erroneous assignment of orientations and positions of contigs in a scaffold. Each time the relative orientation of two neighboring contigs on a scaffold disagrees with that in the reference genome, we have an event contributing to the error rate <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i19.gif"/></inline-formula>. In addition, for any two consecutive contigs in a scaffold, we have an estimated separation, which decides the number of 'N' bases we insert in between those contigs in the final output. For consecutive contigs with verified relative orientations, we compare the estimated separation with the real separation on the reference genome. The last category of rearrangement error rate, <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i20.gif"/></inline-formula>, is associated with the cases where the difference between those values is greater than 500 bases. The two categories of error, presented in this paragraph, keep track of events where two contigs from different strands or from far apart regions have been brought together.</p>
    </sec>
    <sec>
      <title>Description of the libraries</title>
      <p>We present the assembly result for two real datasets, one being a mate pair library from SOLiD, while the other is of the paired-end kind from Illumina. In paired-end technology, mainly used by Illumina, two reads in a pair come from the opposite strands. In mate pair technology, both reads in a pair are from the same strand. The insert size is also typically larger for the mate pair libraries, which is beneficial for many applications. At the same time, owing to the particular enzymatic steps required to make the mate pairs, there is a higher rate of production of molecules which do not represent true ends of the large DNA molecule. The sequence information from these molecules has to be properly identified and handled so as not to lead to inconsistent scaffolds.</p>
      <p>The first dataset is a 50 bp mate pair dataset, generated by SOLiD platform, for the 4.7 Mb genome of <italic>Escherichia coli DH10B </italic><ext-link ext-link-type="uri" xlink:href="http://solidsoftwaretools.com/gf/project/ecoli2x50/">http://solidsoftwaretools.com/gf/project/ecoli2x50/</ext-link>. After we used an in-house filter [<xref ref-type="bibr" rid="B27">27</xref>] to remove polyclonal and error-laden reads, we were left with 7.4 million pairs of 50 bp long sequences. For this mate pair library, we used the insert size of 1350 bp (Figure <xref ref-type="fig" rid="F3">3</xref>). Assembly of these reads resulted in very poor quality output. Therefore, we decided to trim down the reads to 35 bp, expecting most of the sequencing errors are concentrated towards the end of the reads [<xref ref-type="bibr" rid="B27">27</xref>]. Even after filtering and trimming, the remaining reads provided 100Ã coverage, and produced better assembly than the raw data set (data not shown).</p>
      <p>The other dataset contains 3.5 million pairs of 36 bp long reads from the Illumina platform, providing 40Ã coverage of the 6.09 Mb genome of <italic>Pseudomonas syringae pv. syringae B728a </italic>[<xref ref-type="bibr" rid="B28">28</xref>]. For this paired-end library, we used the insert size of 350 bp (Figure <xref ref-type="fig" rid="F3">3</xref>).</p>
    </sec>
    <sec>
      <title>Performance comparison</title>
      <p>We compare the performance of our algorithm to that of Velvet [<xref ref-type="bibr" rid="B8">8</xref>]. One reason for selecting Velvet is that several studies found that the performance of Velvet was either better or at least competitive with other available programs [<xref ref-type="bibr" rid="B11">11</xref>,<xref ref-type="bibr" rid="B28">28</xref>,<xref ref-type="bibr" rid="B29">29</xref>]. The other reason is that we wanted to study the platform dependence of the performance of SOPRA. Velvet is the only program among the popular assemblers that handles color-space data. For <italic>P. syringae </italic>dataset from the Illumina platform, the original study [<xref ref-type="bibr" rid="B28">28</xref>] from which we obtained the library has compared performance of several assemblers. The authors attempted assembly using EULER-SR [<xref ref-type="bibr" rid="B10">10</xref>] and SHARCGS [<xref ref-type="bibr" rid="B5">5</xref>], but they ran out of random access memory (32 Gb available). It also turned out that Velvet outperforms SSAKE [<xref ref-type="bibr" rid="B7">7</xref>], VCAKE [<xref ref-type="bibr" rid="B6">6</xref>] and EDENA [<xref ref-type="bibr" rid="B11">11</xref>]. These last two assemblers do not incorporate mate pair information and were run only in unpaired mode. ALLPATHS [<xref ref-type="bibr" rid="B9">9</xref>] requires multiple paired libraries with different insert sizes. Given the above issues, we decided to proceed with comparison Velvet.</p>
      <p>In many areas, including biological data mining, a common exercise for assessing the performance of a binary classifier is to consider the DET or ROC curve [<xref ref-type="bibr" rid="B30">30</xref>,<xref ref-type="bibr" rid="B31">31</xref>]. As one reduces the stringency of the classifier, false negative rate decreases at the cost of increasing the false positive rate. DET/ROC curves provide a quantitative representation of this trade-off and are essential for finding optimal operating point that balances the conflicting goals of keeping both of these error rates down. As we mentioned before, in the context of <italic>de novo </italic>assembly, there is a similar trade-off between N50 and the assembly quality [<xref ref-type="bibr" rid="B28">28</xref>]. In this analogy, smaller N50 corresponds to having a high false negative rate, while low quality of the assembly plays the role of high false positive rate.</p>
      <p>The comparative assembly performance, in the form of N50 versus error rate, is shown in Figures <xref ref-type="fig" rid="F6">6</xref> and <xref ref-type="fig" rid="F7">7</xref>. Ideally, one would like to be on the top left corners of these graphs, which corresponds to large sizes and low error rates. We present the performance of the algorithms both for contig assembly (triangles) and scaffold assembly (circles).</p>
      <fig id="F6" position="float">
        <label>Figure 6</label>
        <caption>
          <p><bold>N50 vs. combined mismatch and no-match error rate for <italic>de novo </italic>assembly of real data</bold>. See main text and the caption for Table 1 for explanation of the error rates.</p>
        </caption>
        <graphic xlink:href="1471-2105-11-345-6"/>
      </fig>
      <fig id="F7" position="float">
        <label>Figure 7</label>
        <caption>
          <p><bold>N50 vs. combined rearrangement error rate for <italic>de novo </italic>assembly of real data</bold>. See main text and the caption for Table 1 for explanation of the error rates</p>
        </caption>
        <graphic xlink:href="1471-2105-11-345-7"/>
      </fig>
      <p>In the case of <italic>E. coli </italic>data produced by SOLiD platform, for contig assembly, the mismatch rate for V-SOPRA is lower than that for Velvet (Figure <xref ref-type="fig" rid="F6">6A</xref>). This is partly because of error correcting feature of our algorithm for translating color-space data. In contrast, S-SOPRA produces much shorter contigs compared to the other two. Running Velvet with the paired option did not particularly improve the N50, but it increased the mismatch rate significantly. In comparison to Velvet, both V-SOPRA and S-SOPRA perform better in term of scaffold size and error rate, with V-SOPRA outperforming S-SOPRA.</p>
      <p>In contrast to the case of the <italic>E. coli </italic>mate pair dataset from SOLiD, pairing information helps Velvet generate much larger scaffolds from the <italic>P. syringae </italic>paired-end Illumina dataset. Figure <xref ref-type="fig" rid="F6">6B</xref> shows the results of running Velvet, with 'paired' option, on the <italic>P. syringae </italic>reads, for two different parameter sets. Note that the two-fold increase in N50 comes at the cost of increasing the error rate by more than one order of magnitude. This trade-off pattern is consistent with a study comparing, among other things, the performance of Velvet for many combinations of parameters [<xref ref-type="bibr" rid="B28">28</xref>]. V-SOPRA produces comparable N50 at a much lower mismatch rate. For this particular dataset, the contig building performance of V-SOPRA and Velvet is nearly identical. Like in the <italic>E. coli </italic>dataset, the performance of S-SOPRA is worse than V-SOPRA.</p>
      <p>More or less the same pattern continues with the large-scale rearrangement error rates. In Figure <xref ref-type="fig" rid="F7">7</xref> we report N50 versus the combined rearrangement error rates. In the case of Illumina dataset, V-SOPRA did not produce any errors in certain categories (Table <xref ref-type="table" rid="T1">1</xref>).</p>
      <table-wrap id="T1" position="float">
        <label>Table 1</label>
        <caption>
          <p><italic>De novo </italic>assembly statistics for <italic>P. syringae</italic></p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="left">Assembler</th>
              <th align="center">
                <italic>Îµ</italic>
                <sub><italic>no</italic>_<italic>m</italic></sub>
              </th>
              <th align="center">
                <italic>Îµ</italic>
                <sub><italic>mis</italic>_<italic>m</italic></sub>
              </th>
              <th align="center">
                <inline-formula>
                  <inline-graphic xlink:href="1471-2105-11-345-i17.gif"/>
                </inline-formula>
              </th>
              <th align="center">
                <inline-formula>
                  <inline-graphic xlink:href="1471-2105-11-345-i18.gif"/>
                </inline-formula>
              </th>
              <th align="center">
                <inline-formula>
                  <inline-graphic xlink:href="1471-2105-11-345-i19.gif"/>
                </inline-formula>
              </th>
              <th align="center">
                <inline-formula>
                  <inline-graphic xlink:href="1471-2105-11-345-i20.gif"/>
                </inline-formula>
              </th>
              <th align="center">N50</th>
              <th align="center">Genome coverage</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td/>
              <td align="center" colspan="2">
                <bold>% of total assembly</bold>
              </td>
              <td align="center" colspan="4">
                <bold>No. of events/Mbp of assembly</bold>
              </td>
              <td align="center">
                <bold>Kbp</bold>
              </td>
              <td align="center">
                <bold>%</bold>
              </td>
            </tr>
            <tr>
              <td colspan="9">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">S-SOPRA (unpaired)</td>
              <td align="center">.2</td>
              <td align="center">.14</td>
              <td align="center">.33</td>
              <td align="center">5.25</td>
              <td align="center">-</td>
              <td align="center">-</td>
              <td align="center">2.1</td>
              <td align="center">98.4</td>
            </tr>
            <tr>
              <td align="left">V-SOPRA (unpaired)</td>
              <td align="center">.17</td>
              <td align="center">.01</td>
              <td align="center">0</td>
              <td align="center">0</td>
              <td align="center">-</td>
              <td align="center">-</td>
              <td align="center">6.6</td>
              <td align="center">97.7</td>
            </tr>
            <tr>
              <td align="left">Velvet (unpaired)</td>
              <td align="center">.16</td>
              <td align="center">.01</td>
              <td align="center">0</td>
              <td align="center">0</td>
              <td align="center">-</td>
              <td align="center">-</td>
              <td align="center">7</td>
              <td align="center">97.2</td>
            </tr>
            <tr>
              <td align="left">S-SOPRA (paired)</td>
              <td align="center">.3</td>
              <td align="center">.13</td>
              <td align="center">.49</td>
              <td align="center">5.58</td>
              <td align="center">0.66</td>
              <td align="center">3.12</td>
              <td align="center">44.2</td>
              <td align="center">98.4</td>
            </tr>
            <tr>
              <td align="left">V-SOPRA (paired)</td>
              <td align="center">.18</td>
              <td align="center">.01</td>
              <td align="center">.33</td>
              <td align="center">0</td>
              <td align="center">0</td>
              <td align="center">0</td>
              <td align="center">74</td>
              <td align="center">97.7</td>
            </tr>
            <tr>
              <td align="left">Velvet (paired1)</td>
              <td align="center">.16</td>
              <td align="center">.02</td>
              <td align="center">3.28</td>
              <td align="center">.82</td>
              <td align="center">0</td>
              <td align="center">0.16</td>
              <td align="center">46.7</td>
              <td align="center">97.7</td>
            </tr>
            <tr>
              <td align="left">Velvet (paired2)</td>
              <td align="center">.14</td>
              <td align="center">.81</td>
              <td align="center">4.93</td>
              <td align="center">4.1</td>
              <td align="center">1.64</td>
              <td align="center">7.56</td>
              <td align="center">118.8</td>
              <td align="center">96.6</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>The error rate <italic>Îµ</italic><sub><italic>no</italic>_<italic>m </italic></sub>represents the sum of length of the contigs/scaffolds with no BLAST hit as a percentage of total assembled bases. Mismatch error rate <italic>Îµ</italic><sub><italic>mis</italic>_<italic>m </italic></sub>reports the total number of mismatches and indels as a percentage of total assembled bases. The error rates <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i17.gif"/></inline-formula> and <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i18.gif"/></inline-formula> are associated with chimeric mis-assemblies, involving gaps smaller or larger than 500 bases, respectively. The error rate <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i19.gif"/></inline-formula> accounts for the number of cases where the relative orientation of two neighboring contigs disagrees with that in the reference genome. The cases where the estimated separation between two consecutive contigs on a scaffold differs from the real separation in the reference genome by more than 500 bases are associated with <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i20.gif"/></inline-formula>. These last four categories of errors are measure as the number of erroneous events per megabases of assembly.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>In general, for both datasets and all categories of error, our algorithm utilized the mate pair information to enhance N50 by one or two orders of magnitude without significantly increasing the error rates (see details in Tables <xref ref-type="table" rid="T1">1</xref> and <xref ref-type="table" rid="T2">2</xref>). The N50 gain from contigs to scaffolds, for the SOLiD dataset is remarkable for SOPRA when compared to the corresponding gain for Velvet. We believe, based on our simulations (data not shown), that our gain for the Illumina dataset would have been much larger if, instead of being around 350 bases, the insert size of this library were close to a kilobase. Another reassuring aspect of SOPRA as compared to Velvet is that for SOLiD dataset, the algorithm managed to keep the mismatch error rate low, partly thanks to the robust handling of the color-space translation.</p>
      <table-wrap id="T2" position="float">
        <label>Table 2</label>
        <caption>
          <p><italic>De nov</italic><italic>o </italic>assembly statistics for <italic>E. coli</italic></p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="left">Assembler</th>
              <th align="center">
                <italic>Îµ</italic>
                <sub><italic>no</italic>_<italic>m</italic></sub>
              </th>
              <th align="center">
                <italic>Îµ</italic>
                <sub><italic>mis</italic>_<italic>m</italic></sub>
              </th>
              <th align="center">
                <inline-formula>
                  <inline-graphic xlink:href="1471-2105-11-345-i17.gif"/>
                </inline-formula>
              </th>
              <th align="center">
                <inline-formula>
                  <inline-graphic xlink:href="1471-2105-11-345-i18.gif"/>
                </inline-formula>
              </th>
              <th align="center">
                <inline-formula>
                  <inline-graphic xlink:href="1471-2105-11-345-i19.gif"/>
                </inline-formula>
              </th>
              <th align="center">
                <inline-formula>
                  <inline-graphic xlink:href="1471-2105-11-345-i20.gif"/>
                </inline-formula>
              </th>
              <th align="center">N50</th>
              <th align="center">Genome coverage</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td/>
              <td align="center" colspan="2">
                <bold>% of total assembly</bold>
              </td>
              <td align="center" colspan="4">
                <bold>No. of events/Mbp of assembly</bold>
              </td>
              <td align="center">
                <bold>Kbp</bold>
              </td>
              <td align="center">
                <bold>%</bold>
              </td>
            </tr>
            <tr>
              <td colspan="9">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">S-SOPRA (unpaired)</td>
              <td align="center">.2</td>
              <td align="center">.14</td>
              <td align="center">.43</td>
              <td align="center">2.13</td>
              <td align="center">-</td>
              <td align="center">-</td>
              <td align="center">.5</td>
              <td align="center">92.7</td>
            </tr>
            <tr>
              <td align="left">V-SOPRA (unpaired)</td>
              <td align="center">.02</td>
              <td align="center">.03</td>
              <td align="center">.22</td>
              <td align="center">0</td>
              <td align="center">-</td>
              <td align="center">-</td>
              <td align="center">1.5</td>
              <td align="center">94</td>
            </tr>
            <tr>
              <td align="left">Velvet (unpaired)</td>
              <td align="center">.02</td>
              <td align="center">.2</td>
              <td align="center">.22</td>
              <td align="center">.64</td>
              <td align="center">-</td>
              <td align="center">-</td>
              <td align="center">1.5</td>
              <td align="center">94.3</td>
            </tr>
            <tr>
              <td align="left">S-SOPRA (paired)</td>
              <td align="center">.2</td>
              <td align="center">.15</td>
              <td align="center">.43</td>
              <td align="center">2.13</td>
              <td align="center">0.43</td>
              <td align="center">2.55</td>
              <td align="center">125.5</td>
              <td align="center">92.7</td>
            </tr>
            <tr>
              <td align="left">V-SOPRA (paired)</td>
              <td align="center">.02</td>
              <td align="center">.03</td>
              <td align="center">.21</td>
              <td align="center">0</td>
              <td align="center">0.43</td>
              <td align="center">1.7</td>
              <td align="center">200.6</td>
              <td align="center">94</td>
            </tr>
            <tr>
              <td align="left">Velvet (paired)</td>
              <td align="center">.06</td>
              <td align="center">.67</td>
              <td align="center">2.55</td>
              <td align="center">1.7</td>
              <td align="center">0.65</td>
              <td align="center">.87</td>
              <td align="center">2.3</td>
              <td align="center">94.2</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>For the definition of different error rates, see the caption for Table 1.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>We also used MegaBLAST to analyze the contigs which SOPRA removed from the scaffolding process during the assembly. The result is presented in Table <xref ref-type="table" rid="T3">3</xref>. For the <italic>P. syringae </italic>dataset from Illumina platform, most of the removed sequences were either chimeric or belonged to repeats (referred to as problematic contigs). For the <italic>E. coli </italic>dataset from SOLiD sequencer, slightly more than half of removed sequences were determined to be problematic. In both cases, the total length of removed sequences remains a small fraction of the total assembly. It should be noted that for a removed contig which was not determined to be problematic, there is a possibility that it contains a short stretch of sequence belonging to repeats which was not identified by MegaBLAST.</p>
      <table-wrap id="T3" position="float">
        <label>Table 3</label>
        <caption>
          <p>Analysis of contigs removed from the scaffolding process</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th/>
              <th align="center" colspan="2"><italic>E. coli </italic>dataset</th>
              <th align="center" colspan="2"><italic>P. syringae </italic>dataset</th>
            </tr>
            <tr>
              <th/>
              <th colspan="4">
                <hr/>
              </th>
            </tr>
            <tr>
              <th/>
              <th align="center">V-SOPRA</th>
              <th align="center">S-SOPRA</th>
              <th align="center">V-SOPRA</th>
              <th align="center">S-SOPRA</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">Total number of removed contigs</td>
              <td align="center">106</td>
              <td align="center">338</td>
              <td align="center">61</td>
              <td align="center">189</td>
            </tr>
            <tr>
              <td align="center">Total genomic length of removed contigs (% of total assembly)</td>
              <td align="center">192 kb (4.1%)</td>
              <td align="center">313 kb (6.7%)</td>
              <td align="center">77 kb (1.3%)</td>
              <td align="center">272 kb (4.5%)</td>
            </tr>
            <tr>
              <td align="center">number of problematic contigs</td>
              <td align="center">58</td>
              <td align="center">128</td>
              <td align="center">60</td>
              <td align="center">164</td>
            </tr>
            <tr>
              <td align="center">Total genomic length of problematic contigs (% of total assembly)</td>
              <td align="center">130 kb (2.8%)</td>
              <td align="center">184 kb (3.9%)</td>
              <td align="center">76 kb (1.2%)</td>
              <td align="center">233 kb (3.8%)</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Problematic contigs refer to contigs which are either chimeric, belong to repeats, or do not match to the reference genome. Genomic length means that for repeats, the length is multiplied by the corresponding copy number.</p>
        </table-wrap-foot>
      </table-wrap>
    </sec>
  </sec>
  <sec>
    <title>Conclusion</title>
    <p>The goal of scaffold assembly is to arrange contigs such that most of the mate pair constraints are satisfied. Given the inconsistencies in the constraints, any solution strategy inevitably has to decide upon a subset of constraints to be ignored. In our algorithm, this choice is made iteratively, going back and forth between the optimization step and removal of offending constraints. For example, in the process of assigning the optimal orientations, we also detect the links that are not satisfied and are to be removed. The same was true for the next step, where, by modeling the links as springs, we both assign the positions and remove the constraints that cause stretch/compression in this solution.</p>
    <p>Taking the entire set of remaining mate pair constraints into account simultaneously at each round of optimization is critical to the success of our approach. Some algorithms, at each step, consider only a small subset of contigs and links in between to improve the assembly in a particular region [<xref ref-type="bibr" rid="B13">13</xref>-<xref ref-type="bibr" rid="B15">15</xref>]. This manner of local processing of mate pair information stands in stark contrast to our global approach.</p>
    <p>In a sequencing project, the issue of large variability in separation of mate pairs (Figures <xref ref-type="fig" rid="F3">3B</xref> and <xref ref-type="fig" rid="F3">3D</xref>) has an important implication for the choice of the insert size in the library preparation. The insert size should preferably be large enough to bridge over most of the small repeats or the shallowly sequenced regions. However, as the typical insert size increases, so does the standard deviation of the separation for individual mate pairs. The averaging effect from having multiple mate pairs between two contigs depends upon the number of such pairs, which, in turn, is limited by the size of the corresponding contigs. Therefore, beyond a certain point, larger insert size might result in higher uncertainty in contig positioning. We expect the optimal insert size to be dependent upon the typical size of the contigs, the depth of coverage, and most importantly, the ability to restrict size variation in the library preparation. In our simulations for assembly of some bacterial genomes, the optimal insert size is typically around 1 Kb, if we were to choose only one insert size (data not shown). However, if the contig assembly mostly produces small fragments, namely, the contig N50 is much less than 1 Kb, the quality of scaffold assembly suffers significantly.</p>
    <p>In our study, we emphasized the possible conflict between getting larger scaffolds and avoiding mis-assembly. We showed that the N50/error rate trade-off characteristics for V-SOPRA is excellent. In a practical <italic>de novo </italic>assembly project, mis-assembly rates are hard to estimate. As a result, one may be tempted to increase the N50 without consideration of accumulating inaccuracies[<xref ref-type="bibr" rid="B32">32</xref>]. Therefore, it is important for such projects to develop a set of independent benchmarks to assess the accuracy of assembly. The N50/error rate trade-off curve, based on such benchmarks, can be used to set the optimal parameters for the assembler.</p>
    <p>Currently, SOPRA is quite conservative and it errs on the side of breaking up things whenever there is any confusion. As we have seen, this tendency has not resulted in smaller N50s compared to other algorithms. However, it is possible that a more sophisticated algorithm could partially reconstruct the structure of repeat regions while solving the orientation and positions of different contigs. One may also be able to breakup some chimeric contigs at the right place rather than remove the whole contig. We hope to include these features in the future versions of the algorithm.</p>
    <p>The current HTS platforms not only read sequence fragments but also generate additional information regarding relative position and orientation of pairs of reads. Our methodology is particularly adept at exploiting this extra information. The approach developed here could be easily adapted to any new technology that provides additional positional and orientational constraints on multiple reads. Combination of efficient algorithms for utilization of such constraints and improvements in accuracy of reads leading to better quality contig building will bring us closer to the goal of assembling genomes from the next generation of HTS data.</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <p>SOPRA was implemented in Perl and tested both on a 64-bit Linux and on a Mac OS X server machine. The available memory for both machines was 16 GB. The code is available freely, under the GNU Public License, at <ext-link ext-link-type="uri" xlink:href="http://www.physics.rutgers.edu/~anirvans/SOPRA/">http://www.physics.rutgers.edu/~anirvans/SOPRA/</ext-link></p>
    <sec>
      <title>Robust Translation of Color-space Data</title>
      <p>We saw how the output of our color-space contig assembly consists of a sequence in color-space, <italic>C</italic>, plus some base-space suggestions, <italic>F</italic>, at certain locations (Figure <xref ref-type="fig" rid="F2">2</xref>). However, it may not be possible to find a base-space sequence that agrees with all the color-space calls and base-space suggestions. Therefore, we turn the issue of translating this color-space sequence into a search for the most likely DNA sequence that gave rise to this data (<italic>C </italic>and <italic>F</italic>). Basically, we set up a hidden variable model. The hidden states of the model are the real letter bases. The color calls and letter base suggestions are the observations. There are two unknown parameters: the probability that a given color call is wrong, and the probability that a letter base suggestion is wrong. For the sake of convenience in calculations, we parameterize these two probabilities as <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i21.gif"/></inline-formula> and <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i22.gif"/></inline-formula>, respectively.</p>
      <p>We can then ask for a given <italic>C</italic>, <italic>F</italic>, <italic>r</italic><sub><italic>c </italic></sub>and <italic>r</italic><sub><italic>s</italic></sub>, what is the probability for a particular base-space sequence, <italic>B</italic>, to be the real DNA sequence? Let <italic>c</italic><sub><italic>i </italic></sub>represent the color call between position <italic>i </italic>and <italic>i </italic>+ 1 of a contig. At each position, we can have different first base suggestions (one for each short read starting at that position). Let <italic>f</italic><sub><italic>i,b </italic></sub>denote the number of times a particular base <italic>b </italic>â {<italic>A</italic>, <italic>T</italic>, <italic>C</italic>, <italic>G</italic>} is suggested at position <italic>i</italic>. If at certain position there is no suggestion for a particular base, the corresponding <italic>f</italic><sub><italic>i,b </italic></sub>is equal to zero. Let us represent a base-space sequence of length <italic>N </italic>as <italic>B</italic><sub>1,<italic>N </italic></sub>= <italic>b</italic><sub>1</sub><italic>b</italic><sub>2</sub>... <italic>b</italic><sub><italic>N</italic></sub>, where <italic>b</italic><sub><italic>i </italic></sub>â {<italic>A</italic>, <italic>T</italic>, <italic>C</italic>, <italic>G</italic>} for all 1 â¤ <italic>i </italic>â¤ <italic>N</italic>. For each sequence, <italic>B</italic><sub>1,<italic>N</italic></sub>, there is an associated sequence <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i23.gif"/></inline-formula> in color-space such that <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i24.gif"/></inline-formula> is the color associated to the dinucleotide <italic>b</italic><sub><italic>i</italic></sub><italic>b</italic><sub><italic>i</italic>+1</sub>. Let us also represent the probability of <italic>B</italic><sub>1,<italic>N </italic></sub>being the real DNA sequence, given <italic>C, F, r</italic><sub><italic>c </italic></sub>and <italic>r</italic><sub><italic>s</italic></sub>, as:<disp-formula><graphic xlink:href="1471-2105-11-345-i25.gif"/></disp-formula></p>
      <p>Using the above notation, we have:<disp-formula id="bmcM5"><label>(5)</label><graphic xlink:href="1471-2105-11-345-i26.gif"/></disp-formula></p>
      <p><inline-formula><inline-graphic xlink:href="1471-2105-11-345-i27.gif"/></inline-formula> is the Kronecker delta; it is equal to one if the color call between position <italic>i </italic>and <italic>i </italic>+ 1 (i.e. <italic>c</italic><sub><italic>i</italic></sub>) agrees with the color associated with the dinucleotide <italic>b</italic><sub><italic>i</italic></sub><italic>b</italic><sub><italic>i </italic>+ 1 </sub>(i.e. <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i24.gif"/></inline-formula>); otherwise, it is zero. <italic>Î´</italic><sub><italic>bi</italic>,<italic>b </italic></sub>is the Kronecker delta as well. The next step is to find the base-space sequence that maximizes the above probability. The particular structure of this model allows us to efficiently solve for the optimal sequence using dynamic programming as follows. Consider an arbitrary position <italic>k</italic>. Equation 5 can be written as:<disp-formula><graphic xlink:href="1471-2105-11-345-i28.gif"/></disp-formula></p>
      <p>The middle term on the right hand side contains<inline-formula><inline-graphic xlink:href="1471-2105-11-345-i29.gif"/></inline-formula>, which depends on both <italic>b</italic><sub><italic>k </italic></sub>and <italic>b</italic><sub><italic>k</italic></sub><sub>+ 1</sub>. The term <italic>p</italic><sub><italic>k </italic>+ 1,<italic>N </italic></sub>(<italic>B</italic><sub><italic>k </italic>+ 1,<italic>N</italic></sub>) does not contain any variable which corresponds to positions smaller than <italic>k </italic>+ 1, however, it depends on <italic>b</italic><sub><italic>k </italic>+ 1</sub>. Similarly, the term <italic>P</italic><sub>1,<italic>K </italic></sub>(<italic>B</italic><sub>1,<italic>K</italic></sub>) does not contain any variable which corresponds to positions greater than <italic>k</italic>, however, it depends on <italic>b</italic><sub><italic>k</italic></sub>. There are four possibilities for <italic>b</italic><sub><italic>k</italic></sub>, namely, <italic>A</italic>,<italic>T</italic>,<italic>C </italic>and <italic>G</italic>. For each of these possibilities, we can ask what <italic>B</italic><sub>1,<italic>k-1 </italic></sub>= <italic>b</italic><sub>1</sub><italic>b</italic><sub>2</sub>...<italic>b</italic><sub><italic>k</italic>-1 </sub>will optimize <italic>P</italic><sub>1,<italic>k </italic></sub>(<italic>B</italic><sub>1,<italic>k</italic></sub>). Imagine we know the answer to this question for some arbitrary <italic>k</italic>. Then, we can easily find the answer to the following question: For each of the four possibilities for <italic>b</italic><sub><italic>k</italic>+1</sub>, what <italic>B</italic><sub>1,<italic>k </italic></sub>= <italic>b</italic><sub>1</sub><italic>b</italic><sub>2</sub>...<italic>b</italic><sub><italic>k </italic></sub>will optimize <italic>P</italic><sub>1,<italic>k </italic>+ 1 </sub>(<italic>B</italic><sub>1,<italic>k </italic>+ 1</sub>)? The reason is that we can write:<disp-formula><graphic xlink:href="1471-2105-11-345-i30.gif"/></disp-formula></p>
      <p>For each particular choice of <italic>b</italic><sub><italic>k</italic></sub><sub>+1</sub>, there are four possibilities for <italic>b</italic><sub><italic>k</italic></sub>. For each of these possibilities, we know the first term in the right hand side and we can calculate the second and the third term. The information that we have to save at step <italic>k </italic>+ 1 is that for each <italic>b</italic><sub><italic>k </italic>+ 1</sub>, what is the maximum value of <italic>P</italic><sub>1,<italic>k </italic>+ 1 </sub>(<italic>B</italic><sub>1,<italic>k </italic>+ 1</sub>) and what base <italic>b</italic><sub><italic>k </italic></sub>corresponds to this value.</p>
      <p>We start with <italic>k </italic>= 1 where for each of four possibilities for <italic>b</italic><sub>1 </sub>we can calculate <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i31.gif"/></inline-formula>. We continue as explained above to find, for each of four possibilities for <italic>b</italic><sub><italic>N</italic></sub>, what sequence <italic>B</italic><sub>1,<italic>N</italic>-1 </sub>= <italic>b</italic><sub>1</sub><italic>b</italic><sub>2</sub>... <italic>b</italic><sub><italic>N</italic>-1 </sub>will maximize <italic>P</italic><sub>1,<italic>N </italic></sub>(<italic>B</italic><sub>1,<italic>N</italic></sub>). We have four options for <italic>b</italic><sub><italic>N </italic></sub>and four corresponding values for <italic>P</italic><sub>1,<italic>N </italic></sub>(<italic>B</italic><sub>1,<italic>N</italic></sub>). We pick the <italic>b</italic><sub><italic>N </italic></sub>for which the probability <italic>P</italic><sub>1,<italic>N </italic></sub>(<italic>B</italic><sub>1,<italic>N</italic></sub>) is highest. We then go backward and check, for this choice of <italic>b</italic><sub><italic>N</italic></sub>, what base <italic>b</italic><sub><italic>N</italic>-1 </sub>was used. We continue this backward process until we get the whole optimum sequence.</p>
      <p>The only remaining issue is the choice of values for <italic>r</italic><sub><italic>c </italic></sub>and <italic>r</italic><sub><italic>s</italic></sub>. Ideally, we would like to choose these values such that the quantity <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i32.gif"/></inline-formula> is maximized. This quantity represents the probability of observing the data, namely, the color-space contig and first base suggestions. One could use iterative methods like expectation maximization in order to find the optimal values of error rates. However, the translation result is robust for a wide range of parameters and training the rate is not particularly essential in all cases that we encountered, for simulated and for real data. Intuitively, the reason for this robustness is as follows. If an error were propagated, it would disagree with most of the subsequent base pair suggestions. The relative strength of <italic>r</italic><sub><italic>c </italic></sub>versus <italic>r</italic><sub><italic>s </italic></sub>decides how many such mismatches would be tolerated before a color call error is declared. If the density of first base suggestion is high, color call errors get found out within a few bases, as long as the ratio <italic>r</italic><sub><italic>c </italic></sub>over <italic>r</italic><sub><italic>s </italic></sub>is within a reasonable range. The density of first base suggestions is usually high for short read data, given the high coverage and the fact that there is one base suggestion for each incorporated short read. As a first estimate, we can put the probability for a letter base suggestion to be wrong equal to, <italic>e</italic><sub><italic>s. </italic></sub>, the sequencing error rate generated by SOLiD platform. The rough estimate for the probability of a color call being wrong would be <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i33.gif"/></inline-formula>, where <italic>d </italic>is the average depth of coverage of the corresponding contig.</p>
    </sec>
    <sec>
      <title>Optimization Strategy for Orientation Assignment</title>
      <p>We solve the orientation assignment problem by finding the ground state of an Ising model. In general, this is an NP-complete problem [<xref ref-type="bibr" rid="B24">24</xref>,<xref ref-type="bibr" rid="B25">25</xref>]. However, for moderate quality mate pair data, the typical optimization problems that we face have a redeeming feature. In many cases, most of the vertices in the contig connectivity graph are connected to only a few neighboring contigs, thanks to the nearly linear structure of the scaffold. This feature allows us to partition the graph into smaller components on which the optimization can be performed independently. We can then put the partitioned components back together to find the optimal configuration. Below, we explain this procedure in more detail.</p>
      <p>An articulation vertex is defined as a vertex such that by removing it from the graph, the graph splits into two or more disconnected components. For each connected component of the graph, we search for articulation vertices that have more than two neighbors (an articulation vertex with only two neighbors is just part of a linear chain in the graph for which the energy optimization can be solved efficiently). After finding an articulation point, we split the graph into the corresponding disconnected components. We give a copy of the articulation vertex to each of these newly formed components. We iteratively continue this procedure on each of these components until we end up with non-reducible ones i.e. components without articulation points that have more than two neighbors. Finding the articulation points and dividing up the graph takes <italic>O</italic>(<italic>N </italic><sup>2</sup>) time, where <italic>N </italic>is the total number of the vertices. We can separately optimize the orientation configuration for these non-reducible components. Notice that, in each component, the optimal configuration has a degeneracy of two, namely, if we reverse all the orientations, we get the same energy (<italic>E</italic>[<italic>S</italic>] = <italic>E</italic>[-<italic>S</italic>]).</p>
      <p>Once we have the optimized configuration for each of these components, we reverse the process of iterative partitioning. At each step we join back components formed by removal an articulation vertex. Each of these components was provided with a copy of the articulation vertex. Using the freedom of an overall flip within each component, we arrange to have the same orientation for the copies of the articulation vertex in different components. We can stitch the components together by merging the different copies into a single vertex. The order of merging the articulation vertices is the reverse of the order in which they were split. The reason we can find the global optimum solution by separately optimizing non-reducible components and joining them back together is as follows. Given the definition of the articulation points, there is no edge connecting the non-reducible components in the original graph. In other words, in the energy function, there is no term that includes two vertices which belong to different non-reducible components. As a result, the total energy can be broken up into sums of energies of the non-reducible components. Thus, we can optimize the orientational configuration for each of these components separately, up to an overall reversal within each component. The only set of constraints that has to be satisfied is that the copies of each articulation vertex should have the same orientation. This goal can be easily achieved using the freedom of overall reversal within each component.</p>
      <p>In order to optimize the non-reducible components, we proceed as follow. For a given component, we pick a random vertex <italic>i </italic>and name the singleton set {<italic>i</italic>} to be <italic>Z</italic><sub>1</sub>. Next, take all the vertices connected to the vertex in <italic>Z</italic><sub>1 </sub>and call this new set <italic>Z</italic><sub>2</sub>. We will then consider all the vertices adjacent to the vertices in <italic>Z</italic><sub>2</sub>, and for each of them, if it does not already belong to <italic>Z</italic><sub>1 </sub>or <italic>Z</italic><sub>2</sub>, we put it in a new set called <italic>Z</italic><sub>3</sub>. We continue until all the vertices in the corresponding connected component have been visited.</p>
      <p>For a general graph, the size of <italic>Z</italic><sub><italic>k</italic></sub>, denoted by | <italic>Z</italic><sub><italic>k </italic></sub>|, grows exponentially as <italic>k </italic>increases. However, for the contig connectivity graph, because of the linear structure of the scaffolds, in many cases | <italic>Z</italic><sub><italic>k </italic></sub>| remains a small number and does not grow as <italic>k </italic>increases. For a given non-reducible component, depending on the sizes of <italic>Z</italic><sub><italic>k</italic></sub>'s, we choose different strategies. In the case where all the sizes are smaller than a threshold value (e.g. six), we use a dynamic programming approach, similar to the Viterbi algorithm, to optimize the energy, <italic>E</italic>[<italic>S</italic>] (Equation 2). In the other case, we use the simulated annealing method as explained below.</p>
      <p>The dynamic programming approach is very similar to the procedure explained above for translation of color-space data into base-space. Note that by construction, a vertex belonging to a set <italic>Z</italic><sub><italic>k </italic></sub>can only be connected to the vertices belonging to <italic>Z</italic><sub><italic>k</italic>-1</sub>,<italic>Z</italic><sub><italic>k </italic></sub>or <italic>Z</italic><sub><italic>k </italic>+ 1</sub>. In other words, we can write:<disp-formula><graphic xlink:href="1471-2105-11-345-i34.gif"/></disp-formula></p>
      <p>where the expressions for <italic>E</italic><sub>1,<italic>k</italic></sub>, <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i35.gif"/></inline-formula> and <italic>E</italic><sub><italic>k+</italic></sub><sub>1,</sub><sub><italic>N</italic></sub>, only contain orientations from vertices belonging to the sets <italic>Z</italic><sub>1</sub>âª<italic>Z</italic><sub>2</sub>....âª<italic>Z</italic><sub><italic>k</italic></sub>, <italic>Z</italic><sub><italic>k</italic></sub>âª<italic>Z</italic><sub><italic>k</italic>+1 </sub>and <italic>Z</italic><sub><italic>k</italic>+1</sub>âª<italic>Z</italic><sub><italic>k</italic>+2</sub>...âª<italic>Z</italic><sub><italic>N</italic></sub>, respectively. This means that if we fix orientations of all the vertices belonging to <italic>Z</italic><sub><italic>k </italic></sub>(there are <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i36.gif"/></inline-formula> possibilities for the choice of these orientations), we can optimize <italic>E</italic><sub>1,<italic>k </italic></sub>without any knowledge of the orientations associated with vertices belonging to <italic>Z</italic><sub><italic>l</italic></sub>, â <italic>l </italic>&gt;<italic>k</italic>. At this point, it is clear how we can implement the dynamic programming procedure.</p>
      <p>Let <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i37.gif"/></inline-formula> be an arbitrary set of orientations for all the vertices belonging to <italic>Z</italic><sub><italic>k</italic></sub>. There are <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i36.gif"/></inline-formula> possibilities for <italic>o</italic><sub><italic>k</italic></sub>. For each of these possibilities, we can ask what choice of <italic>O</italic><sub>1,<italic>k-1 </italic></sub>= (<italic>o</italic><sub>1</sub>,<italic>o</italic><sub>2</sub>,..., <italic>o</italic><sub><italic>k</italic>-1</sub>) will minimize <italic>E</italic><sub>1,<italic>k</italic></sub>. If we know the answer to this question for some arbitrary <italic>k</italic>, then, we can easily find the answer to the following question: For each of the <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i38.gif"/></inline-formula> possibilities for <italic>o</italic><sub><italic>k</italic></sub><sub>+1</sub>, what <italic>O</italic><sub>1,<italic>k </italic></sub>= (<italic>o</italic><sub>1</sub>,<italic>o</italic><sub>2</sub>,...,<italic>o</italic><sub><italic>k</italic></sub>) will minimize <italic>E</italic><sub>1,<italic>k </italic>+ 1</sub>? The reason is that we can write: <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i39.gif"/></inline-formula>. For each particular choice of <italic>o</italic><sub><italic>k</italic></sub><sub>+1</sub>, there are <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i36.gif"/></inline-formula> possibilities for <italic>o</italic><sub><italic>k</italic></sub>. For each of these possibilities, we know the first term in the right hand side and we can calculate the second term. The information that we have to save at step <italic>k </italic>+ 1 is that for each choice of <italic>o</italic><sub><italic>k </italic>+ 1</sub>, what is the minimum value of <italic>E</italic><sub>1,<italic>k </italic>+ 1 </sub>and what choice of <italic>o</italic><sub><italic>k </italic></sub>corresponds to this value.</p>
      <p>We start with <italic>k </italic>= 1 where for each of 2 possibilities for <italic>o</italic><sub>1 </sub>(note that <italic>Z</italic><sub>1 </sub>only has one member), we can calculate <italic>E</italic><sub>1,1 </sub>which is equal to zero in both cases. We continue as explained above to find, for each of <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i40.gif"/></inline-formula> possibilities of <italic>o</italic><sub><italic>N </italic></sub>(<italic>N </italic>being the total number of <italic>Z</italic><sub><italic>k</italic></sub>'s), what choice of <italic>O</italic><sub>1,<italic>N</italic>-1 </sub>= <italic>o</italic><sub>1</sub><italic>o</italic><sub>2</sub>...<italic>o</italic><sub><italic>N</italic>-1 </sub>will minimize <italic>E</italic><sub>1,<italic>N</italic></sub>. We have <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i40.gif"/></inline-formula> options for <italic>o</italic><sub><italic>N </italic></sub>and <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i40.gif"/></inline-formula> corresponding values for <italic>E</italic><sub>1,<italic>N</italic></sub>. We pick the <italic>o</italic><sub><italic>N </italic></sub>for which the energy <italic>E</italic><sub>1,<italic>N </italic></sub>is lowest. Note that because of the degeneracy in the energy function (<italic>E</italic>[<italic>S</italic>] = <italic>E</italic>[-<italic>S</italic>]), there are two choices of <italic>o</italic><sub><italic>N </italic></sub>with exactly the same energy. We can arbitrary pick either one of them. We then go backward and check, for this choice of <italic>o</italic><sub><italic>N</italic></sub>, what set of orientation <italic>o</italic><sub><italic>N</italic>-1 </sub>was used. We continue this backtracking until we get the optimum orientation for all the vertices.</p>
      <p>As mentioned before, for a generic graph, size of <italic>Z</italic><sub><italic>k</italic></sub>'s grow with <italic>k </italic>and the step of going from <italic>k </italic>to <italic>k </italic>+ 1 requires a large number of calculations. This is expected as the problem of minimizing Ising energy on an arbitrary graph is NP-complete [<xref ref-type="bibr" rid="B24">24</xref>,<xref ref-type="bibr" rid="B25">25</xref>]. However, if the structure of a particular graph allows efficient use of the dynamic programming approach, then the above procedure results in an exact solution. We might have to abandon this method and adopt a heuristic one when there are highly-connected components of moderate or large size.</p>
      <p>Figure <xref ref-type="fig" rid="F8">8A</xref> shows a typical region of the contig connectivity graph for the <italic>E. coli </italic>dataset. As one can see, the contig connectivity graph is mostly quite sparse. Assume if we only consider a small part of the graph, similar to the one shown in Figure <xref ref-type="fig" rid="F8">8B</xref>, and defines the <italic>Z</italic><sub><italic>k </italic></sub>sets starting from an arbitrary point. Given the typical structure in the graph, it is clear why the size of <italic>Z</italic><sub><italic>k</italic></sub>'s do not often grow as <italic>k </italic>increases. If by removing the articulation points we manage to break up parts of the contig connectivity graph into small components, the above exact method can be applied to most of such components. Some of the branches in figures <xref ref-type="fig" rid="F8">8A</xref> are part of bigger loops which cannot be seen here. When several such relatively big loops get interconnected, the above optimization strategy often becomes impractical.</p>
      <fig id="F8" position="float">
        <label>Figure 8</label>
        <caption>
          <p><bold>A typical region of the contig connectivity graph for the <italic>E. coli </italic>dataset</bold>. (A) The graph typically has a sparse structure. Some of the branches shown are part of bigger loops which cannot be seen here. (B) The blow up of the region indicated by arrow in (A).</p>
        </caption>
        <graphic xlink:href="1471-2105-11-345-8"/>
      </fig>
    </sec>
    <sec>
      <title>Simulated Annealing Method</title>
      <p>We explain the procedure in the context of finding the optimal orientation configuration. Simulated annealing [<xref ref-type="bibr" rid="B21">21</xref>] is a Monte Carlo method in which one samples the configuration, <italic>S</italic>, with probability <italic>P</italic>[<italic>S</italic>]âexp(-<italic>E</italic>[<italic>S</italic>]<italic>/T</italic>), while slowly decreasing the temperature parameter, <italic>T</italic>, towards zero. If the energy of the system reaches a value close to <italic>E</italic><sub>min </sub>as the temperature goes to zero, it indicates that most of the orientational constraints are satisfied. The advantage of this method over certain greedy approaches is that in simulated annealing, all the contigs and the constraints are treated democratically. Also, in the presence of multiple local optima, one expects simulated annealing to perform better than various domain specific greedy algorithms. In practice, much depends on the particular greedy algorithm and the structure of the graph, as was found in the context of several optimization problems on graphs ([<xref ref-type="bibr" rid="B33">33</xref>]). In that study ([<xref ref-type="bibr" rid="B33">33</xref>]), it was found that for relatively sparse and regular graphs, simulated annealing did better than some well-established greedy algorithms. This fact, along with many other examples of successful use of simulated annealing [<xref ref-type="bibr" rid="B21">21</xref>,<xref ref-type="bibr" rid="B22">22</xref>], motivated our choice.</p>
      <p>In simulated annealing, we start from an arbitrary configuration, e.g. <italic>S</italic><sub><italic>i </italic></sub>= 1, â <italic>i</italic>. At each step, we randomly choose a contig and check whether by flipping its orientation the energy would decrease or increase. If the energy decreases, we flip the orientation. Otherwise, if the energy increases by Î <italic>E</italic>, we flip the orientation with probability exp(-Î <italic>E/T</italic>) where <italic>T </italic>is a parameter. We start with a large value of <italic>T </italic>which will allow orientation flip in most cases. After each step, we slightly decrease <italic>T </italic>according to an exponential cooling schedule [<xref ref-type="bibr" rid="B21">21</xref>]. As we go forward, the energy of the system will on average decrease and get closer and closer to <italic>E</italic><sub>min</sub>. This continues until the energy curve reaches a plateau, at which point the search is stopped.</p>
      <p>For the Potts model, the only difference is that, instead of the variable <italic>S</italic><sub><italic>i</italic></sub>, we assign the variable <italic>Ï</italic><sub><italic>i </italic></sub>to contig <italic>i</italic>. We start with a random label assignment and at each step we make a decision to whether or not change the label of a randomly chosen contigs to a new randomly chosen label. We find that, although the final label configuration may depend upon the choice of initial configuration, the domain boundaries are robustly reconstructed.</p>
      <p>In the optimization problems that we face, if the inconsistencies were too severe, the degree of frustration in the system would be very high, and any heuristic method would typically produce a suboptimal solution. In our experience, this is not the case as evidenced by the fact that the energy of the final orientation configuration is close to the minimum energy (data not shown). This fact, on one hand, allows simulated annealing to find the solution. On the other hand, being able to satisfy most of the constraints indicates that the mate pair data is on the whole trustworthy.</p>
    </sec>
    <sec>
      <title>Calculation of <italic>l</italic><sub><italic>ij</italic></sub></title>
      <p>In a SOLiD mate pair library, each pair is composed of two reads, denotes by <italic>R</italic>3 and <italic>F</italic>3. They come from the same strand and <italic>F</italic>3 read is located to the right of <italic>R</italic>3 as one goes from 5' to 3'. Imagine the <italic>R</italic>3 read was used in contig <italic>i</italic><sub><italic>R </italic></sub>and the <italic>F</italic>3 read was used in contig <italic>i</italic><sub><italic>F</italic></sub>. Now, let us define the variables <italic>Ï</italic><sub><italic>R </italic></sub>and <italic>Ï</italic><sub><italic>F</italic></sub>. If the <italic>R</italic>3 read itself (and not its reverse compliment) was used in contig <italic>i</italic><sub><italic>R</italic></sub>, then <italic>Ï</italic><sub><italic>R </italic></sub>= 1; otherwise, <italic>Ï</italic><sub><italic>R </italic></sub>= -1. Similarly, if the <italic>F</italic>3 read itself (and not its reverse compliment) was used in contig <italic>i</italic><sub><italic>F</italic></sub>, then <italic>Ï</italic><sub><italic>F </italic></sub>= 1; otherwise, <italic>Ï</italic><sub><italic>F </italic></sub>= -1. The position of the <italic>R</italic>3 and <italic>F</italic>3 reads in contigs <italic>i</italic><sub><italic>R </italic></sub>and <italic>i</italic><sub><italic>F </italic></sub>is denoted by <italic>p</italic><sub><italic>R </italic></sub>and <italic>p</italic><sub><italic>F</italic></sub>, respectively. Also, let <italic>Ins </italic>denote the insert size of the library. Then, for the suggested distance between contigs <italic>i</italic><sub><italic>R </italic></sub>and <italic>i</italic><sub><italic>F </italic></sub>(i.e. <italic>x</italic><sub><italic>R </italic></sub>- <italic>x</italic><sub><italic>R</italic></sub>), we have: <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i41.gif"/></inline-formula>. Here, <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i42.gif"/></inline-formula>. is the orientation assigned to contig <italic>i</italic><sub><italic>R</italic></sub>. For an Illumina paired-end library, the two short reads are located on the opposite strand and face each other. Let us still use the same notation as above, namely, call the first read <italic>R </italic>and the second one <italic>F</italic>, etc. Then, the above formula becomes: <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i43.gif"/></inline-formula>. Each mate pair, connecting contigs <italic>i</italic><sub><italic>R </italic></sub>and <italic>i</italic><sub><italic>F</italic></sub>, provides us with its own suggested distance which we calculate using the above formula. The average of all these suggested distances for contigs <italic>i</italic><sub><italic>R </italic></sub>and <italic>i</italic><sub><italic>F </italic></sub>is denoted by <inline-formula><inline-graphic xlink:href="1471-2105-11-345-i44.gif"/></inline-formula>.</p>
    </sec>
    <sec>
      <title>V-SOPRA Parameters</title>
      <p>For contig assembly part of V-SOPRA, we directly used Velvet v0.7 without invoking the paired option. We get the output in the format of sequence positions in contigs. For base-space data, this information is stored in the <italic>afg </italic>file generated by Velvet. For color-space data, Velvet is part of a pipeline called SOLiD system <italic>de novo </italic>accessory tools [<xref ref-type="bibr" rid="B34">34</xref>]. In this pipeline, color-space data has to be preprocessed before inputting to Velvet. Velvet output also has to go through a post-processing step. We use the output of this post-processor that contains the information related to the position of sequences in contigs (the sequences are still in color-space). There is one last step in the pipeline that outputs the final contigs in base-space. However, we do not use this last step. The parameters used for running Velvet in the fragment mode as the first step in V-SOPRA are the same as those described below in the Velvet parameter subsection.</p>
      <p>For scaffold assembly, parameter <italic>W </italic>determines the minimum number of mate pairs that have to join two contigs in order for those contigs to be considered connected. For <italic>E. coli </italic>data, we set <italic>W </italic>= 5, whereas for <italic>P. syringae </italic>data we put <italic>W </italic>= 4. Parameter <italic>L</italic>, determining the minimum length that a contig must have in order to be used in the scaffold assembly, was set to <italic>L </italic>= 150 for both datasets.</p>
      <p>On the Linux machine, the first step of the program, reconstructing the contigs from Velvet output and recording the mate pair information, took 50 minutes for both <italic>E. coli </italic>and <italic>P. syringae </italic>dataset. The color-space translation for <italic>E. coli </italic>data took 14 minutes. The scaffold assembly part took 1.2 hours for <italic>E. coli </italic>and 5 minutes for <italic>P. syringae </italic>dataset. The runtimes were similar for the Mac OS X server.</p>
    </sec>
    <sec>
      <title>S-SOPRA Parameters</title>
      <p>S-SOPRA performs contig assembly based upon our modification of SSAKE v3.2 which can also handle color-space data. The crucial parameter for contig assembly is the parameter that determines the minimum required overlap length between two reads. For <italic>E. coli </italic>data we used <italic>m </italic>= 16, whereas for <italic>P. syringae </italic>data we set <italic>m </italic>= 17. For scaffold assembly, we set <italic>L </italic>= 200 for <italic>E. coli </italic>data, whereas for <italic>P. syringae </italic>data we put <italic>L </italic>= 175. For <italic>E. coli </italic>data, we set <italic>W </italic>= 5, whereas for <italic>P. syringae </italic>data we put <italic>W </italic>= 4.</p>
      <p>The first step of the program that builds the contig based on SSAKE algorithm and records the mate pair information took 8.5 hours for <italic>E. coli </italic>and 6 hours for <italic>P. syringae </italic>dataset. The color-space translation for <italic>E. coli </italic>data took 16 minutes. The scaffold assembly part took 7 hours for <italic>E. coli </italic>and 1.8 hours for <italic>P. syringae </italic>dataset. These numbers are for the Linux machine with similar runtime for the Mac OS X server.</p>
    </sec>
    <sec>
      <title>Velvet Parameters</title>
      <p>For Velvet, we tried different combinations of parameters and report results for the ones giving the best performance. For <italic>E. coli </italic>data, Velvet in the fragment mode was run with a hash length of 19 and coverage cutoff of 6Ã. We ran Velvet in the paired mode using a hash length of 19, coverage cutoff of 6Ã and coverage expectation of 50.</p>
      <p>For <italic>P. syringae </italic>data, Velvet in the fragment mode was run with a hash length of 21 and coverage cutoff of 6Ã. We ran Velvet in the paired mode using two different parameter sets noted by paired1 and paired2 in Table <xref ref-type="table" rid="T1">1</xref> and <xref ref-type="table" rid="T2">2</xref>. Both parameter sets used hash length of 21 and coverage cutoff of 6Ã. The coverage expectation for the first parameter set was 12, whereas for the second parameter set we used 50.</p>
    </sec>
    <sec>
      <title>Filtering Raw SOLiD Data</title>
      <p>The performance of any assembler is sensitive to the sequencing error rate. In many cases, for high coverage datasets, assembler performance benefits from filtering the data. The lowered coverage is more than compensated for by the improvement of the data quality. While Illumina data is filtered on the machine, all SOLiD reads are reported. We used an in-house filtering approach for SOLiD data [<xref ref-type="bibr" rid="B27">27</xref>] that removed more than 50% of the raw data, still leaving us with 100Ã coverage.</p>
    </sec>
  </sec>
  <sec>
    <title>Abbreviations</title>
    <p>HTS: High throughput sequencing.</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>AMS and TPM conceived and supervised the project. AD and AMS contributed to the design of the algorithm. AD developed the program and performed the data analysis. All authors read and approved the final manuscript.</p>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>We thank Ariella Sasson and Alexander Schliep for useful conversations on sequence assembly and for careful reading of the manuscript. We gratefully acknowledge many informative discussions on sequencing technologies with Randall Kerstetter. The <italic>P. syringae </italic>dataset is the same one used in [<xref ref-type="bibr" rid="B28">28</xref>], we would like to thanks the authors for sharing the dataset. This work was supported by National Human Genome Research Institute grant 5R01HG003470 (AMS), and a Busch Biomedical Grant (TPM).</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Shendure</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Ji</surname>
          <given-names>H</given-names>
        </name>
        <article-title>Next-generation DNA sequencing</article-title>
        <source>Nat Biotechnol</source>
        <year>2008</year>
        <volume>26</volume>
        <issue>10</issue>
        <fpage>1135</fpage>
        <lpage>1145</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt1486</pub-id>
        <pub-id pub-id-type="pmid">18846087</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>MacLean</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Jones</surname>
          <given-names>JD</given-names>
        </name>
        <name>
          <surname>Studholme</surname>
          <given-names>DJ</given-names>
        </name>
        <article-title>Application of 'next-generation' sequencing technologies to microbial genetics</article-title>
        <source>Nat Rev Microbiol</source>
        <year>2009</year>
        <volume>7</volume>
        <issue>4</issue>
        <fpage>287</fpage>
        <lpage>296</lpage>
        <pub-id pub-id-type="pmid">19287448</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Mardis</surname>
          <given-names>ER</given-names>
        </name>
        <article-title>The impact of next-generation sequencing technology on genetics</article-title>
        <source>Trends Genet</source>
        <year>2008</year>
        <volume>24</volume>
        <issue>3</issue>
        <fpage>133</fpage>
        <lpage>141</lpage>
        <pub-id pub-id-type="pmid">18262675</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="book">
        <name>
          <surname>Jones</surname>
          <given-names>NC</given-names>
        </name>
        <name>
          <surname>Pevzner</surname>
          <given-names>P</given-names>
        </name>
        <source>An introduction to bioinformatics algorithms</source>
        <year>2004</year>
        <publisher-name>Cambridge, MA: MIT Press</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Dohm</surname>
          <given-names>JC</given-names>
        </name>
        <name>
          <surname>Lottaz</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Borodina</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Himmelbauer</surname>
          <given-names>H</given-names>
        </name>
        <article-title>SHARCGS, a fast and highly accurate short-read assembly algorithm for de novo genomic sequencing</article-title>
        <source>Genome Res</source>
        <year>2007</year>
        <volume>17</volume>
        <issue>11</issue>
        <fpage>1697</fpage>
        <lpage>1706</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.6435207</pub-id>
        <pub-id pub-id-type="pmid">17908823</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Jeck</surname>
          <given-names>WR</given-names>
        </name>
        <name>
          <surname>Reinhardt</surname>
          <given-names>JA</given-names>
        </name>
        <name>
          <surname>Baltrus</surname>
          <given-names>DA</given-names>
        </name>
        <name>
          <surname>Hickenbotham</surname>
          <given-names>MT</given-names>
        </name>
        <name>
          <surname>Magrini</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Mardis</surname>
          <given-names>ER</given-names>
        </name>
        <name>
          <surname>Dangl</surname>
          <given-names>JL</given-names>
        </name>
        <name>
          <surname>Jones</surname>
          <given-names>CD</given-names>
        </name>
        <article-title>Extending assembly of short DNA sequences to handle error</article-title>
        <source>Bioinformatics</source>
        <year>2007</year>
        <volume>23</volume>
        <issue>21</issue>
        <fpage>2942</fpage>
        <lpage>2944</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btm451</pub-id>
        <pub-id pub-id-type="pmid">17893086</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Warren</surname>
          <given-names>RL</given-names>
        </name>
        <name>
          <surname>Sutton</surname>
          <given-names>GG</given-names>
        </name>
        <name>
          <surname>Jones</surname>
          <given-names>SJ</given-names>
        </name>
        <name>
          <surname>Holt</surname>
          <given-names>RA</given-names>
        </name>
        <article-title>Assembling millions of short DNA sequences using SSAKE</article-title>
        <source>Bioinformatics</source>
        <year>2007</year>
        <volume>23</volume>
        <issue>4</issue>
        <fpage>500</fpage>
        <lpage>501</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btl629</pub-id>
        <pub-id pub-id-type="pmid">17158514</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zerbino</surname>
          <given-names>DR</given-names>
        </name>
        <name>
          <surname>Birney</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Velvet: algorithms for de novo short read assembly using de Bruijn graphs</article-title>
        <source>Genome Res</source>
        <year>2008</year>
        <volume>18</volume>
        <issue>5</issue>
        <fpage>821</fpage>
        <lpage>829</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.074492.107</pub-id>
        <pub-id pub-id-type="pmid">18349386</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Butler</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>MacCallum</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Kleber</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Shlyakhter</surname>
          <given-names>IA</given-names>
        </name>
        <name>
          <surname>Belmonte</surname>
          <given-names>MK</given-names>
        </name>
        <name>
          <surname>Lander</surname>
          <given-names>ES</given-names>
        </name>
        <name>
          <surname>Nusbaum</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Jaffe</surname>
          <given-names>DB</given-names>
        </name>
        <article-title>ALLPATHS: de novo assembly of whole-genome shotgun microreads</article-title>
        <source>Genome Res</source>
        <year>2008</year>
        <volume>18</volume>
        <issue>5</issue>
        <fpage>810</fpage>
        <lpage>820</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.7337908</pub-id>
        <pub-id pub-id-type="pmid">18340039</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Chaisson</surname>
          <given-names>MJ</given-names>
        </name>
        <name>
          <surname>Pevzner</surname>
          <given-names>PA</given-names>
        </name>
        <article-title>Short read fragment assembly of bacterial genomes</article-title>
        <source>Genome Res</source>
        <year>2008</year>
        <volume>18</volume>
        <issue>2</issue>
        <fpage>324</fpage>
        <lpage>330</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.7088808</pub-id>
        <pub-id pub-id-type="pmid">18083777</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Hernandez</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Francois</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Farinelli</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Osteras</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Schrenzel</surname>
          <given-names>J</given-names>
        </name>
        <article-title>De novo bacterial genome sequencing: millions of very short reads assembled on a desktop computer</article-title>
        <source>Genome Res</source>
        <year>2008</year>
        <volume>18</volume>
        <issue>5</issue>
        <fpage>802</fpage>
        <lpage>809</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.072033.107</pub-id>
        <pub-id pub-id-type="pmid">18332092</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Myers</surname>
          <given-names>EW</given-names>
        </name>
        <name>
          <surname>Sutton</surname>
          <given-names>GG</given-names>
        </name>
        <name>
          <surname>Delcher</surname>
          <given-names>AL</given-names>
        </name>
        <name>
          <surname>Dew</surname>
          <given-names>IM</given-names>
        </name>
        <name>
          <surname>Fasulo</surname>
          <given-names>DP</given-names>
        </name>
        <name>
          <surname>Flanigan</surname>
          <given-names>MJ</given-names>
        </name>
        <name>
          <surname>Kravitz</surname>
          <given-names>SA</given-names>
        </name>
        <name>
          <surname>Mobarry</surname>
          <given-names>CM</given-names>
        </name>
        <name>
          <surname>Reinert</surname>
          <given-names>KH</given-names>
        </name>
        <name>
          <surname>Remington</surname>
          <given-names>KA</given-names>
        </name>
        <article-title>A whole-genome assembly of Drosophila</article-title>
        <source>Science</source>
        <year>2000</year>
        <volume>287</volume>
        <issue>5461</issue>
        <fpage>2196</fpage>
        <lpage>2204</lpage>
        <pub-id pub-id-type="doi">10.1126/science.287.5461.2196</pub-id>
        <pub-id pub-id-type="pmid">10731133</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Huson</surname>
          <given-names>DH</given-names>
        </name>
        <name>
          <surname>Reinert</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Myers</surname>
          <given-names>EW</given-names>
        </name>
        <article-title>The greedy path-merging algorithm for Contig Scaffolding</article-title>
        <source>Journal of the Acm</source>
        <year>2002</year>
        <volume>49</volume>
        <issue>5</issue>
        <fpage>603</fpage>
        <lpage>615</lpage>
        <pub-id pub-id-type="doi">10.1145/585265.585267</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Pevzner</surname>
          <given-names>PA</given-names>
        </name>
        <name>
          <surname>Tang</surname>
          <given-names>H</given-names>
        </name>
        <article-title>Fragment assembly with double-barreled data</article-title>
        <source>Bioinformatics</source>
        <year>2001</year>
        <volume>17</volume>
        <issue>Suppl 1</issue>
        <fpage>S225</fpage>
        <lpage>233</lpage>
        <pub-id pub-id-type="pmid">11473013</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Pop</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Kosack</surname>
          <given-names>DS</given-names>
        </name>
        <name>
          <surname>Salzberg</surname>
          <given-names>SL</given-names>
        </name>
        <article-title>Hierarchical scaffolding with Bambus</article-title>
        <source>Genome Research</source>
        <year>2004</year>
        <volume>14</volume>
        <issue>1</issue>
        <fpage>149</fpage>
        <lpage>159</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.1536204</pub-id>
        <pub-id pub-id-type="pmid">14707177</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Pop</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Genome assembly reborn: recent computational challenges</article-title>
        <source>Brief Bioinform</source>
        <year>2009</year>
        <volume>10</volume>
        <issue>4</issue>
        <fpage>354</fpage>
        <lpage>366</lpage>
        <pub-id pub-id-type="doi">10.1093/bib/bbp026</pub-id>
        <pub-id pub-id-type="pmid">19482960</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>McKernan</surname>
          <given-names>KJ</given-names>
        </name>
        <name>
          <surname>Peckham</surname>
          <given-names>HE</given-names>
        </name>
        <name>
          <surname>Costa</surname>
          <given-names>GL</given-names>
        </name>
        <name>
          <surname>McLaughlin</surname>
          <given-names>SF</given-names>
        </name>
        <name>
          <surname>Fu</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Tsung</surname>
          <given-names>EF</given-names>
        </name>
        <name>
          <surname>Clouser</surname>
          <given-names>CR</given-names>
        </name>
        <name>
          <surname>Duncan</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Ichikawa</surname>
          <given-names>JK</given-names>
        </name>
        <name>
          <surname>Lee</surname>
          <given-names>CC</given-names>
        </name>
        <article-title>Sequence and structural variation in a human genome uncovered by short-read, massively parallel ligation sequencing using two-base encoding</article-title>
        <source>Genome Res</source>
        <year>2009</year>
        <volume>19</volume>
        <issue>9</issue>
        <fpage>1527</fpage>
        <lpage>1541</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.091868.109</pub-id>
        <pub-id pub-id-type="pmid">19546169</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gansner</surname>
          <given-names>ER</given-names>
        </name>
        <name>
          <surname>North</surname>
          <given-names>SC</given-names>
        </name>
        <article-title>An open graph visualization system and its applications to software engineering</article-title>
        <source>Software-Practice &amp; Experience</source>
        <year>2000</year>
        <volume>30</volume>
        <issue>11</issue>
        <fpage>1203</fpage>
        <lpage>1233</lpage>
        <pub-id pub-id-type="doi">10.1002/1097-024X(200009)30:11&lt;1203::AID-SPE338&gt;3.0.CO;2-N</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="book">
        <name>
          <surname>Kindermann</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Snell</surname>
          <given-names>JL</given-names>
        </name>
        <collab>American Mathematical Society</collab>
        <source>Markov random fields and their applications</source>
        <year>1980</year>
        <publisher-name>Providence, R.I.: American Mathematical Society</publisher-name>
        <pub-id pub-id-type="pmid">7385929</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="book">
        <name>
          <surname>Fischer</surname>
          <given-names>KH</given-names>
        </name>
        <name>
          <surname>Hertz</surname>
          <given-names>J</given-names>
        </name>
        <source>Spin glasses</source>
        <year>1991</year>
        <publisher-name>Cambridge; New York, NY, USA: Cambridge University Press</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kirkpatrick</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Gelatt</surname>
          <given-names>CD</given-names>
          <suffix>Jr</suffix>
        </name>
        <name>
          <surname>Vecchi</surname>
          <given-names>MP</given-names>
        </name>
        <article-title>Optimization by Simulated Annealing</article-title>
        <source>Science</source>
        <year>1983</year>
        <volume>220</volume>
        <issue>4598</issue>
        <fpage>671</fpage>
        <lpage>680</lpage>
        <pub-id pub-id-type="doi">10.1126/science.220.4598.671</pub-id>
        <pub-id pub-id-type="pmid">17813860</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="book">
        <name>
          <surname>Laarhoven</surname>
          <given-names>PJMv</given-names>
        </name>
        <name>
          <surname>Aarts</surname>
          <given-names>EHL</given-names>
        </name>
        <source>Simulated annealing: theory and applications</source>
        <year>1987</year>
        <publisher-name>Dordrecht; Boston Norwell, MA, USA: D. Reidel; Sold and distributed in the U.S.A. and Canada by Kluwer Academic Publishers</publisher-name>
        <pub-id pub-id-type="pmid">3650775</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kececioglu</surname>
          <given-names>JD</given-names>
        </name>
        <name>
          <surname>Myers</surname>
          <given-names>EW</given-names>
        </name>
        <article-title>Combinatorial Algorithms for DNA-Sequence Assembly</article-title>
        <source>Algorithmica</source>
        <year>1995</year>
        <volume>13</volume>
        <issue>1-2</issue>
        <fpage>7</fpage>
        <lpage>51</lpage>
        <pub-id pub-id-type="doi">10.1007/BF01188580</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="book">
        <name>
          <surname>Garey</surname>
          <given-names>MR</given-names>
        </name>
        <name>
          <surname>Johnson</surname>
          <given-names>DS</given-names>
        </name>
        <source>Computers and intractability: a guide to the theory of NP-completeness</source>
        <year>1979</year>
        <publisher-name>San Francisco: W. H. Freeman</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Barahona</surname>
          <given-names>F</given-names>
        </name>
        <article-title>On the computational complexity of Ising spin glass models</article-title>
        <source>J Phys A</source>
        <year>1982</year>
        <volume>15</volume>
        <fpage>3241</fpage>
        <lpage>3253</lpage>
        <pub-id pub-id-type="doi">10.1088/0305-4470/15/10/028</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zhang</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Schwartz</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Wagner</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Miller</surname>
          <given-names>W</given-names>
        </name>
        <article-title>A greedy algorithm for aligning DNA sequences</article-title>
        <source>J Comput Biol</source>
        <year>2000</year>
        <volume>7</volume>
        <issue>1-2</issue>
        <fpage>203</fpage>
        <lpage>214</lpage>
        <pub-id pub-id-type="doi">10.1089/10665270050081478</pub-id>
        <pub-id pub-id-type="pmid">10890397</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Sasson</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Michael</surname>
          <given-names>TP</given-names>
        </name>
        <article-title>Filtering error from SOLiD Output</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <issue>6</issue>
        <fpage>849</fpage>
        <lpage>850</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq045</pub-id>
        <pub-id pub-id-type="pmid">20207696</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Farrer</surname>
          <given-names>RA</given-names>
        </name>
        <name>
          <surname>Kemen</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Jones</surname>
          <given-names>JD</given-names>
        </name>
        <name>
          <surname>Studholme</surname>
          <given-names>DJ</given-names>
        </name>
        <article-title>De novo assembly of the Pseudomonas syringae pv. syringae B728a genome using Illumina/Solexa short sequence reads</article-title>
        <source>FEMS Microbiol Lett</source>
        <year>2009</year>
        <volume>291</volume>
        <issue>1</issue>
        <fpage>103</fpage>
        <lpage>111</lpage>
        <pub-id pub-id-type="doi">10.1111/j.1574-6968.2008.01441.x</pub-id>
        <pub-id pub-id-type="pmid">19077061</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Salzberg</surname>
          <given-names>SL</given-names>
        </name>
        <name>
          <surname>Sommer</surname>
          <given-names>DD</given-names>
        </name>
        <name>
          <surname>Puiu</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Lee</surname>
          <given-names>VT</given-names>
        </name>
        <article-title>Gene-boosted assembly of a novel bacterial genome from very short reads</article-title>
        <source>PLoS Comput Biol</source>
        <year>2008</year>
        <volume>4</volume>
        <issue>9</issue>
        <fpage>e1000186</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pcbi.1000186</pub-id>
        <pub-id pub-id-type="pmid">18818729</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="other">
        <name>
          <surname>Martin</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Doddington</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Kamm</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Ordowski</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Przybocki</surname>
          <given-names>M</given-names>
        </name>
        <article-title>The DET Curve in Assessment of Detection Task Performance</article-title>
        <source>Proc Eurospeech '97: 1997</source>
        <year>1997</year>
        <fpage>1895</fpage>
        <lpage>1898</lpage>
      </mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="book">
        <name>
          <surname>Egan</surname>
          <given-names>JP</given-names>
        </name>
        <source>Signal detection theory and ROC-analysis</source>
        <year>1975</year>
        <publisher-name>New York: Academic Press</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B32">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Salzberg</surname>
          <given-names>SL</given-names>
        </name>
        <name>
          <surname>Yorke</surname>
          <given-names>JA</given-names>
        </name>
        <article-title>Beware of mis-assembled genomes</article-title>
        <source>Bioinformatics</source>
        <year>2005</year>
        <volume>21</volume>
        <issue>24</issue>
        <fpage>4320</fpage>
        <lpage>4321</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bti769</pub-id>
        <pub-id pub-id-type="pmid">16332717</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B33">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Johnson</surname>
          <given-names>DS</given-names>
        </name>
        <name>
          <surname>Aragon</surname>
          <given-names>CR</given-names>
        </name>
        <name>
          <surname>Mcgeoch</surname>
          <given-names>LA</given-names>
        </name>
        <name>
          <surname>Schevon</surname>
          <given-names>C</given-names>
        </name>
        <article-title>Optimization by Simulated Annealing - an Experimental Evaluation. 1. Graph Partitioning</article-title>
        <source>Operations Research</source>
        <year>1989</year>
        <volume>37</volume>
        <issue>6</issue>
        <fpage>865</fpage>
        <lpage>892</lpage>
        <pub-id pub-id-type="doi">10.1287/opre.37.6.865</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B34">
      <mixed-citation publication-type="other">
        <article-title>SOLiD system de novo accessory tools</article-title>
        <ext-link ext-link-type="uri" xlink:href="http://solidsoftwaretools.com/gf/project/denovo/">http://solidsoftwaretools.com/gf/project/denovo/</ext-link>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
