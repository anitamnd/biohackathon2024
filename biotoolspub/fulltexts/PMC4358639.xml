<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.0 20120330//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">PeerJ</journal-id>
    <journal-id journal-id-type="iso-abbrev">PeerJ</journal-id>
    <journal-id journal-id-type="pmc">PeerJ</journal-id>
    <journal-id journal-id-type="publisher-id">PeerJ</journal-id>
    <journal-title-group>
      <journal-title>PeerJ</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2167-8359</issn>
    <publisher>
      <publisher-name>PeerJ Inc.</publisher-name>
      <publisher-loc>San Francisco, USA</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4358639</article-id>
    <article-id pub-id-type="publisher-id">808</article-id>
    <article-id pub-id-type="doi">10.7717/peerj.808</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Bioinformatics</subject>
      </subj-group>
      <subj-group subj-group-type="heading">
        <subject>Genomics</subject>
      </subj-group>
      <subj-group subj-group-type="heading">
        <subject>Computational Science</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Arioc: high-throughput read alignment with GPU-accelerated exploration of the seed-and-extend search space</article-title>
    </title-group>
    <contrib-group>
      <contrib id="author-1" contrib-type="author" corresp="yes">
        <name>
          <surname>Wilton</surname>
          <given-names>Richard</given-names>
        </name>
        <xref ref-type="aff" rid="aff-1">1</xref>
        <email>richard.wilton@jhu.edu</email>
      </contrib>
      <contrib id="author-2" contrib-type="author">
        <name>
          <surname>Budavari</surname>
          <given-names>Tamas</given-names>
        </name>
        <xref ref-type="aff" rid="aff-2">2</xref>
      </contrib>
      <contrib id="author-3" contrib-type="author">
        <name>
          <surname>Langmead</surname>
          <given-names>Ben</given-names>
        </name>
        <xref ref-type="aff" rid="aff-3">3</xref>
        <xref ref-type="aff" rid="aff-6">6</xref>
      </contrib>
      <contrib id="author-4" contrib-type="author">
        <name>
          <surname>Wheelan</surname>
          <given-names>Sarah J.</given-names>
        </name>
        <xref ref-type="aff" rid="aff-4">4</xref>
        <xref ref-type="aff" rid="aff-7">7</xref>
      </contrib>
      <contrib id="author-5" contrib-type="author">
        <name>
          <surname>Salzberg</surname>
          <given-names>Steven L.</given-names>
        </name>
        <xref ref-type="aff" rid="aff-3">3</xref>
        <xref ref-type="aff" rid="aff-5">5</xref>
        <xref ref-type="aff" rid="aff-6">6</xref>
      </contrib>
      <contrib id="author-6" contrib-type="author">
        <name>
          <surname>Szalay</surname>
          <given-names>Alexander S.</given-names>
        </name>
        <xref ref-type="aff" rid="aff-1">1</xref>
        <xref ref-type="aff" rid="aff-3">3</xref>
      </contrib>
      <aff id="aff-1"><label>1</label><institution>Department of Physics and Astronomy, Johns Hopkins University</institution>, <addr-line>Baltimore, MD</addr-line>, <country>USA</country></aff>
      <aff id="aff-2"><label>2</label><institution>Department of Applied Mathematics and Statistics, Johns Hopkins University</institution>, <country>USA</country></aff>
      <aff id="aff-3"><label>3</label><institution>Department of Computer Science, Johns Hopkins University</institution>, <country>USA</country></aff>
      <aff id="aff-4"><label>4</label><institution>Department of Oncology, Johns Hopkins University School of Medicine</institution>, <country>USA</country></aff>
      <aff id="aff-5"><label>5</label><institution>Department of Biomedical Engineering, Johns Hopkins University</institution>, <country>USA</country></aff>
      <aff id="aff-6"><label>6</label><institution>Center for Computational Biology, McKusick-Nathans Institute of Genetic Medicine, Johns Hopkins University</institution>, <country>USA</country></aff>
      <aff id="aff-7"><label>7</label><institution>Center for Computational Genomics, Johns Hopkins University</institution>, <country>USA</country></aff>
    </contrib-group>
    <contrib-group>
      <contrib id="editor-1" contrib-type="editor">
        <name>
          <surname>Rahmann</surname>
          <given-names>Sven</given-names>
        </name>
      </contrib>
    </contrib-group>
    <pub-date pub-type="epub" date-type="pub" iso-8601-date="2015-03-03">
      <day>3</day>
      <month>3</month>
      <year iso-8601-date="2015">2015</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2015</year>
    </pub-date>
    <volume>3</volume>
    <elocation-id>e808</elocation-id>
    <history>
      <date date-type="received" iso-8601-date="2014-12-06">
        <day>6</day>
        <month>12</month>
        <year iso-8601-date="2014">2014</year>
      </date>
      <date date-type="accepted" iso-8601-date="2015-02-10">
        <day>10</day>
        <month>2</month>
        <year iso-8601-date="2015">2015</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2015 Wilton et al.</copyright-statement>
      <copyright-year>2015</copyright-year>
      <copyright-holder>Wilton et al.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, reproduction and adaptation in any medium and for any purpose provided that it is properly attributed. For attribution, the original author(s), title, publication source (PeerJ) and either DOI or URL of the article must be cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="https://peerj.com/articles/808"/>
    <abstract>
      <p>When computing alignments of DNA sequences to a large genome, a key element in achieving high processing throughput is to prioritize locations in the genome where high-scoring mappings might be expected. We formulated this task as a series of list-processing operations that can be efficiently performed on graphics processing unit (GPU) hardware.We followed this approach in implementing a read aligner called Arioc that uses GPU-based parallel sort and reduction techniques to identify high-priority locations where potential alignments may be found. We then carried out a read-by-read comparison of Arioc’s reported alignments with the alignments found by several leading read aligners. With simulated reads, Arioc has comparable or better accuracy than the other read aligners we tested. With human sequencing reads, Arioc demonstrates significantly greater throughput than the other aligners we evaluated across a wide range of sensitivity settings. The Arioc software is available at <uri xlink:href="https://github.com/RWilton/Arioc">https://github.com/RWilton/Arioc</uri>. It is released under a BSD open-source license.</p>
    </abstract>
    <kwd-group kwd-group-type="author">
      <kwd>Sequence alignment</kwd>
      <kwd>GPU programming</kwd>
      <kwd>Parallel algorithms</kwd>
    </kwd-group>
    <funding-group>
      <funding-statement>This work was supported by: NIH grants R01-HG007196 and R01-HG006102 (SLS); NSF grant IIS 1349906 (BL); NSF grants ACI 1261715 and ACI 1040114 (AS, RW); Gordon and Betty Moore Foundation grant 109285 (AS, RW); and JHU Discovery grants (AS, BL, SW, RW). Johns Hopkins University is an NVidia “CUDA Center of Excellence.” The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement>
    </funding-group>
  </article-meta>
</front>
<body>
  <sec sec-type="intro">
    <title>Introduction</title>
    <p>The cost and throughput of DNA sequencing have improved rapidly in the past several years (<xref rid="ref-7" ref-type="bibr">Glenn, 2011</xref>), with recent advances reducing the cost of sequencing a single human genome at 30-fold coverage to around $1,000 (<xref rid="ref-9" ref-type="bibr">Hayden, 2014</xref>). It is increasingly common for consortia, or even individual research groups, to generate sequencing datasets that include hundreds or thousands of human genomes. The first and usually the most time-consuming step in analyzing such datasets is read alignment, the process of determining the point of origin of each sequencing read with respect to a reference genome. The continued growth in the size of sequencing datasets creates a crucial need for efficient and scalable read alignment software.</p>
    <p>To address this need, a number of attempts have been made to develop read-alignment software that exploits the parallel processing capability of general-purpose graphics processing units, or GPUs. GPUs are video display devices whose hardware and system-software architecture support their use not only for graphics applications but also for general purpose computing. They are well-suited to software implementations where computations on many thousands of data items can be carried out independently in parallel. This characteristic has inspired a number of attempts to develop high-throughput read aligners that use GPU acceleration.</p>
    <p>Experience has shown, however, that it is not easy to build useful GPU-based read alignment software. In general, GPU hardware is perceived as being impractical from a software-engineering standpoint for the task of computing read alignments (<xref rid="ref-12" ref-type="bibr">Kristensen, 2011</xref>). This impression is reinforced by the common misconception that GPU hardware provides speed improvements in direct proportion to the number of concurrently-executing GPU threads, that is, that the same amount of work “ought to” run 1,000 times faster on 20,000 concurrent GPU threads than on 20 concurrent CPU threads.</p>
    <p>In practice, software running on GPU hardware is constrained by a variety of algorithmic and software-engineering considerations. GPU programming requires software to manage single-instruction multiple-data (SIMD) threading, but efficient handling of memory (data layout, caching, data transfers between CPU and GPU memory) also requires a great deal of attention. Such threading and memory-management constraints lead to realistic GPU-based speed improvements on the order of 10×–100× (<xref rid="ref-2" ref-type="bibr">Anderson et al., 2011</xref>).</p>
    <p>The salient problem in engineering a GPU-accelerated read aligner is that the most biologically relevant sequence-alignment algorithm (<xref rid="ref-24" ref-type="bibr">Smith &amp; Waterman, 1981</xref>; <xref rid="ref-8" ref-type="bibr">Gotoh, 1982</xref>) is not only memory-intensive but also involves dynamic programming dependencies that are awkward to compute efficiently in parallel. In general, this consideration has militated against the development of parallel-threaded GPU implementations (<xref rid="ref-11" ref-type="bibr">Khajeh-Saeed, Poole &amp; Perot, 2010</xref>) where multiple threads of execution cooperate to compute a single alignment. Instead, the fastest implementations of the algorithm on both CPUs and GPUs have relied on task parallelism, where each thread of execution computes an entire pairwise alignment independently of all other parallel threads (e.g., <xref rid="ref-4" ref-type="bibr">Carriero &amp; Gelernter, 1990</xref>; <xref rid="ref-20" ref-type="bibr">Manavski &amp; Valle, 2008</xref>; <xref rid="ref-18" ref-type="bibr">Liu, Wirawan &amp; Schmidt, 2013</xref>).</p>
    <p>There is, however, another significant barrier to the implementation of high-throughput GPU-based alignment software. In a typical pairwise sequence alignment problem, a short (100 to 250 nt) query sequence, or “read,” must be aligned with a comparatively long (10<sup>9</sup> nt or longer) reference sequence. Since a brute-force search for all plausible alignments in this setting would be computationally intractable, read aligners typically construct a “search space” (a list of reference-sequence locations) within which potential alignments might be discovered. This aspect of the sequence alignment problem accounts for a significant proportion of the computational effort involved in read alignment.</p>
    <sec>
      <title>Seed and extend</title>
      <p>One algorithmic approach to exploring a reference-sequence search space is known as “seed and extend” (<xref rid="ref-17" ref-type="bibr">Lipman &amp; Pearson, 1985</xref>; <xref rid="ref-1" ref-type="bibr">Altschul et al., 1990</xref>). The seed-and-extend technique is used in a number of successful read aligners and presents no algorithmic barriers to highly-parallel implementation.</p>
      <p>An aligner that uses seed-and-extend relies on a precomputed index or lookup table to identify locations in the reference where a subsequence (“seed”) extracted from the query sequence matches the same-length subsequence in the reference (<xref ref-type="fig" rid="fig-1">Fig. 1</xref>). The aligner then performs a sequence-alignment computation at one or more of the reference-sequence locations it has obtained from the lookup table. In effect, the partial alignment implied by the seed match at each reference location is extended to arrive at a full pairwise alignment between the query sequence and the reference sequence.</p>
      <fig id="fig-1" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.808/fig-1</object-id>
        <label>Figure 1</label>
        <caption>
          <title>Seed-and-extend strategy for identifying potential alignments.</title>
          <p>Fixed-length subsequences (“seeds”) are extracted from the query sequence and hashed. Each hash value (e.g., “0xDEA5D502”) is used to probe a lookup table of reference locations (e.g., “01:14353363” for chromosome 1, offset 14353363) where the corresponding seed occurs. These seed locations are prioritized and full alignments between the query sequence and the reference sequence are explored in priority order.</p>
        </caption>
        <graphic xlink:href="peerj-03-808-g001"/>
      </fig>
    </sec>
    <sec>
      <title>Frequency distribution of seed locations</title>
      <p>Most seed sequences occur rarely in the human reference genome, but a few seed sequences inevitably occur at hundreds or thousands of different locations in the reference sequence. This is not only because certain portions of the reference are internally repetitive (e.g., homopolymers or tandem repeats) but also because short sequences occasionally occur at two or more non-overlapping positions in the reference genome (e.g., because of transposon-induced duplication). This can be illustrated for the human reference genome by plotting the frequency with which 20mers (20 nt subsequences) occur (<xref ref-type="fig" rid="fig-2">Fig. 2</xref>).</p>
      <fig id="fig-2" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.808/fig-2</object-id>
        <label>Figure 2</label>
        <caption>
          <title>Frequency of 20mers in the human reference genome.</title>
          <p>The number of different positions at which the 30,000 most frequently repeated 20mers occur in the human reference genome, ranked in descending order.</p>
        </caption>
        <graphic xlink:href="peerj-03-808-g002"/>
      </fig>
      <p>Although the mean frequency of human 20mers is only 10.7, high-frequency 20mers account for a disproportionate percentage of reference-sequence locations in a lookup table. For example, only 0.1% of the 20mers in the human reference genome appear in 200 or more different locations, but they account for about 10% of the 20mers in the reference sequence. In contrast, 71.7% of the 20mers in the human genome occur exactly once.</p>
      <p>For a read aligner that implements a seed-and-extend strategy, this long-tailed distribution of seed frequencies is a computational obstacle for reads that contain one or more “high-frequency” seeds. To avoid searching for potential alignments at an inordinate number of locations in the reference sequence, an aligner must limit the number of locations at which it computes alignments for reads that contain such seeds.</p>
    </sec>
    <sec>
      <title>Limiting the search space</title>
      <p>Read aligners address this problem by using several heuristics, all of which limit the number of potential alignments computed:</p>
      <list list-type="simple" id="list-1">
        <list-item>
          <label>•</label>
          <p>Limit the number of high-scoring mappings reported per read.</p>
        </list-item>
        <list-item>
          <label>•</label>
          <p>Limit the number of seeds examined per read.</p>
        </list-item>
        <list-item>
          <label>•</label>
          <p>Limit the number of reference locations examined per seed.</p>
        </list-item>
      </list>
      <p>These heuristics trade throughput for sensitivity. An aligner spends less time computing potential alignments simply because it does not examine the entire search space (all reference locations for all seeds in each read). For the same reason, however, the aligner is less likely to identify all of the high-scoring mappings for each read. The Arioc aligner implements two different heuristics to mitigate this problem.</p>
    </sec>
    <sec>
      <title>Reference-location sampling</title>
      <p>Arioc uses hash tables in which every location in the reference sequence is sampled. For highly repetitive regions of the human genome, however, adjacent and overlapping 20mers in the reference sequence hash to a large number of locations in the reference sequence. Repetitive regions are thus associated with long hash-table lists (“big buckets”) because the 20mers corresponding to those lists refer to numerous repetitive regions elsewhere in the reference.</p>
      <p>For this reason, the Arioc lookup tables are constructed by sampling adjacent “big bucket” hash-table lists in repetitive regions so that only one such list in 10 contains a reference-sequence location that lies within the region (<xref ref-type="fig" rid="fig-3">Fig. 3</xref>). This sampling strategy decreases the size of large hash-table lists. The tradeoff is that a read that aligns to a particular repetitive region must be seeded in up to 10 adjacent locations to guarantee that the aligner will find a reference location within that region in a hash-table list for the read.</p>
      <fig id="fig-3" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.808/fig-3</object-id>
        <label>Figure 3</label>
        <caption>
          <title>Hash-table construction: sampling in repetitive regions.</title>
          <p>Adjacent reference-sequence locations are removed from the hash table where they are found in adjacent “big buckets” (hash-table lists whose cardinality exceeds a user-configurable threshold).</p>
        </caption>
        <graphic xlink:href="peerj-03-808-g003"/>
      </fig>
    </sec>
    <sec>
      <title>Seed-coverage prioritization</title>
      <p>At run time, Arioc implements a heuristic that prioritizes alignments where a read contains two or more seeds that map to adjacent or nearby locations in the reference. This heuristic is reminiscent of the “spanning set” method used to compute alignments in the GSNAP aligner (<xref rid="ref-25" ref-type="bibr">Wu &amp; Nacu, 2010</xref>), but its implementation in Arioc is actually much simpler: within any given read, Arioc assigns higher priority to a reference-sequence locus when more seeds refer to that locus (that is, when that locus is contained in more hash-table buckets for the seeds in that read).</p>
      <p>Arioc uses an additional heuristic in the case of paired-end reads. The aligner prioritizes potential paired-end mappings where a reference location associated with at least one seed in one of the mates in the pair lies within a user-configurable distance and orientation of at least one seed in the other mate in the pair.</p>
      <p>Notably, these heuristics are implemented using a series of sorting and reduction operations on an aggregated list of seed locations. In a CPU-based implementation, the amount of computation required for these operations would be impractical with a reference genome the size of the human genome. In a GPU-based implementation, however, these list-based operations can be performed efficiently with a combination of cooperative parallel threading (sort, stream compaction) and task parallelism (computing seed coverage, filtering using paired-end criteria). For example, an NVidia GTX480 GPU can sort over 300 million 64-bit integer values per second.</p>
      <p>The Arioc aligner was designed to evaluate the performance of these “GPU-friendly” heuristics. In effect, Arioc implements a pipeline in which the following operations are performed on GPU hardware for each read:</p>
      <list list-type="simple" id="list-2">
        <list-item>
          <label>•</label>
          <p>Define the “search space” for the read; that is, compute the set of reference locations that correspond to the seeds in the read.</p>
        </list-item>
        <list-item>
          <label>•</label>
          <p>Adjust the reference locations so that they correspond to the location of the seed within the read.</p>
        </list-item>
        <list-item>
          <label>•</label>
          <p>Sort and unduplicate the list of reference locations.</p>
        </list-item>
        <list-item>
          <label>•</label>
          <p>Count the number of seeds that reference each reference location.</p>
        </list-item>
        <list-item>
          <label>•</label>
          <p>For paired-end reads, identify pairs of reference locations that lie within a predefined distance and orientation of each other.</p>
        </list-item>
        <list-item>
          <label>•</label>
          <p>Coalesce adjacent seed locations so that they are covered by a minimum number of alignment computations.</p>
        </list-item>
        <list-item>
          <label>•</label>
          <p>Compute alignments to identify and record high scoring mappings.</p>
        </list-item>
      </list>
    </sec>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <p>The Arioc aligner is written in C+ + and compiled for both Windows (with Microsoft Visual C+ +) and Linux (with the Gnu C+ + compiler). The implementation runs on a user-configurable number of concurrent CPU threads and on one or more NVidia GPUs. The implementation pipeline uses about 30 different CUDA kernels written in C+ + (nongapped and gapped alignment computation, application-specific list processing) and about 100 calls to various CUDA Thrust APIs (sort, reductions, set difference, string compaction).</p>
    <p>The development and test computers were each configured with dual 6-core Intel Xeon X5670 CPUs running at 2.93 GHz, so a total of 24 logical threads were available to applications. There was 144 GB of system RAM, of which about 96 GB was available to applications. Each computer was also configured with three NVidia Tesla series GPUs (Kepler K20c), each of which supports 5 GB of on-device “global” memory and 26,624 parallel threads. The internal expansion bus in each machine was PCIe v2.</p>
    <p>Throughput (query sequences aligned per second) was measured only when no other user applications were using the machines so that all CPU, memory, and I/O resources were available. For experiments with simulated data, we used Mason (<xref rid="ref-10" ref-type="bibr">Holtgrewe, 2010</xref>) to generate 100 nt and 250 nt paired-end reads. For experiments with Illumina data, we used 100 nt paired-end Illumina Genome Analyzer data from the YanHuang genome (<xref rid="ref-15" ref-type="bibr">Li et al., 2009</xref>).</p>
    <sec>
      <title>Software implementation</title>
      <p>The Arioc implementation is a pipeline (<xref ref-type="fig" rid="fig-4">Fig. 4</xref>) in which batches of reads are processed by a sequence of discrete software modules, each of which operates on a separate CPU thread that is allocated for the lifetime of the module and then discarded. When multiple GPUs are used, each GPU is associated with its own CPU thread. Modules are designed to execute concurrently on CPU threads and on the GPU. Data common to multiple CPU threads is shared; data common to a sequence of GPU operations resides in GPU device memory without being transferred to or from CPU memory.</p>
      <fig id="fig-4" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.808/fig-4</object-id>
        <label>Figure 4</label>
        <caption>
          <title>Arioc pipeline.</title>
          <p>The Arioc pipeline implementation consists of one-time-only initialization (memory allocation, loading of lookup tables and reference data) followed by iterative batched processing of reads (query sequences). Within each batch, nongapped alignments are discovered using GPU-based spaced seed alignment. Gapped alignments, using GPU-based seed-and-extend alignment, are computed only for reads for which a satisfactory number of nongapped alignments are not found. All mappings are finalized (scored and mapped), classified, and reported in multiple concurrent CPU threads.</p>
        </caption>
        <graphic xlink:href="peerj-03-808-g004"/>
      </fig>
      <p>The execution of the Arioc pipeline consists of iterative processing of batches of reads (query sequences), where the number of reads in a batch is constrained by the amount of available GPU memory. Within each batch iteration, the GPUs are used for list processing and for the computation of alignments, while CPU threads are used concurrently for scoring, classification, and formatting of alignment results as well as for input and output. GPU code executes concurrently with CPU code wherever possible. For example, the classification, reporting, and final output of the alignment results for a batch overlaps with the beginning of processing of the subsequent batch.</p>
    </sec>
    <sec>
      <title>Nongapped alignment</title>
      <p>The nongapped aligner uses periodic spaced seeds (gapped q-grams) to identify potential mappings. The seed pattern covers 84 adjacent positions with 30 “care” positions using the repeating 7-bit pattern 0010111; it is fully sensitive for nongapped alignments containing up to two mismatches when it is evaluated at seven adjacent locations in a sequence (<xref rid="ref-5" ref-type="bibr">Chen, Souaiaia &amp; Chen, 2009</xref>). Both the seed value and the query sequences are encoded in 64-bit packed binary values (<xref ref-type="fig" rid="fig-5">Fig. 5</xref>) to facilitate bitwise operations.</p>
      <fig id="fig-5" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.808/fig-5</object-id>
        <label>Figure 5</label>
        <caption>
          <title>Binary encoding of sequence data.</title>
          <p>Arioc packs 21 three-bit symbols into a sequence of 64-bit values. Encoding proceeds from low-order to high-order bits. For example, the 4-nucleotide sequence AACT is encoded as binary 111101100100, or hexadecimal 0x0000000000000F64.</p>
        </caption>
        <graphic xlink:href="peerj-03-808-g005"/>
      </fig>
      <p>For each of the first seven positions in each query sequence, the result of the bitwise AND between the seed value and the query sequence is packed into a 30-bit value that is used to probe a lookup table of potential alignment locations in the reference sequence. For each such location, mappings between the query sequence and the reference sequence are identified by bitwise comparison of the entire query sequence with the corresponding reference.</p>
      <p>Nongapped mappings with mismatches near one or both ends are examined for potential soft clipping. Arioc soft-clips a nongapped mapping whenever its alignment score is higher than it would be without soft clipping. The nongapped aligner assigns a numerical score to each mapping by applying the user-specified parameters for Smith–Waterman–Gotoh affine-gap alignment.</p>
    </sec>
    <sec>
      <title>Gapped alignment</title>
      <p>Arioc only performs gapped alignment with reads for which it does not find a sufficient number of nongapped alignments. The minimum number of satisfactory nongapped alignments required for a read to be excluded from further processing is a user-configurable parameter.</p>
      <p>The gapped aligner is a straightforward implementation of the seed-and-extend strategy. To facilitate parallel computation, multiple seed locations are examined concurrently within each read. Groups of seed locations are selected iteratively. The first group of seeds is chosen so as to cover the entire read without overlapping seeds; subsequent groups are selected so as to straddle the seed positions examined in previous groups (<xref ref-type="fig" rid="fig-6">Fig. 6</xref>).</p>
      <fig id="fig-6" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.808/fig-6</object-id>
        <label>Figure 6</label>
        <caption>
          <title>Seed locations in read sequences.</title>
          <p>Seed locations for each of six seed iterations, for 20 nt seeds in a 100 nt read.</p>
        </caption>
        <graphic xlink:href="peerj-03-808-g006"/>
      </fig>
      <p>In each iteration, the seed subsequences are extracted from the read and hashed to 30 bits using MurmurHash3 (<xref rid="ref-3" ref-type="bibr">Appleby, 2014</xref>). The 30-bit hash values are used to probe a hash table of reference-sequence locations. The reference locations are prioritized and Smith–Waterman–Gotoh local alignment is computed at the highest-priority locations. Reads for which a user-configured number of satisfactory mappings have been found are excluded from subsequent iterations.</p>
      <p>Each iteration examines seed locations that straddle the locations that were processed in previous iterations; seeds are chosen at locations that are halfway between those examined in all previous iterations. (This is similar to the behavior of Bowtie 2’s -R option.) In this way the cumulative number of seeds examined doubles with each iteration, but the actual number of reference locations considered remains relatively stable. With fixed-length 20 nt seeds (20mers), six “seed iterations” are required to examine every seed location in the query sequence.</p>
    </sec>
    <sec>
      <title>Lookup table structures</title>
      <p>To associate seeds with reference-sequence locations, Arioc uses two pairs of lookup tables, one pair for nongapped alignment and the other for gapped alignment. Each pair of lookup tables comprises an H table with one element for each possible hash value and a J table that contains reference-sequence locations. Each table lookup is a two-step process: a read from the H table (to obtain an offset into the J table) followed by reading a list of reference-sequence locations from the J table.</p>
    </sec>
    <sec>
      <title>Restricting the seed-and-extend search space</title>
      <p>To facilitate GPU-based list operations, the Arioc implementation encodes reference locations as 64-bit bitmapped values that can be represented in one-dimensional arrays. These arrays are maintained exclusively in GPU device memory where multiple CUDA kernels can access them. CUDA kernels are used to reorganize and triage reference-location lists:</p>
      <list list-type="simple" id="list-3">
        <list-item>
          <label>•</label>
          <p>Prioritize reference locations that lie within paired-end distance and orientation constraints.</p>
        </list-item>
        <list-item>
          <label>•</label>
          <p>Prioritize reference locations where overlapping and adjacent seeds cover the largest number of adjacent positions in the reference sequence.</p>
        </list-item>
        <list-item>
          <label>•</label>
          <p>Exclude reference locations that have been examined in previous seed iterations.</p>
        </list-item>
        <list-item>
          <label>•</label>
          <p>Identify reference locations for which acceptable mappings exist and for which criteria for paired-end mapping are met.</p>
        </list-item>
      </list>
    </sec>
    <sec>
      <title>Mapping quality (MAPQ)</title>
      <p>For each mapped read, Arioc computes an estimate of the probability that that read is mapped to a reference location other than the location where the read actually originated. MAPQ is reported as −10log<sub>10</sub>(<italic>p</italic>), where <italic>p</italic> is the aligner’s estimate of the probability that the read is not mapped to the correct reference location. Arioc estimates <italic>p</italic> using a computational model based on a probabilistic analysis of different types of mapping errors (<xref rid="ref-16" ref-type="bibr">Li, Ruan &amp; Durbin, 2008</xref>). Arioc supports two user-selectable implementations of this model: one based on the methodology used in BWA-MEM (<xref rid="ref-14" ref-type="bibr">Li, 2013</xref>) with MAPQ scores in the numerical range 0 to 60, and another derived from the empirical logic used in Bowtie 2 (<xref rid="ref-13" ref-type="bibr">Langmead &amp; Salzberg, 2012</xref>), with reported MAPQ values between 0 and 44.</p>
    </sec>
    <sec>
      <title>Specific concerns for GPU implementation</title>
      <p>Available memory and computational resources on GPU devices constrain the implementation of the Arioc pipeline. Although the compiled code is not “tuned” to a particular GPU device, the source-code implementation follows programming practices that experience has shown lead to higher performance: judicious use of GPU memory and use of data-parallel algorithms and implementation methods.</p>
      <sec>
        <title>Memory size</title>
        <p>The limited amount of on-device GPU memory constrains the amount of data that can be processed at any given time on a GPU. Because GPU memory requirements vary as data moves through the implementation pipeline, it is impossible to provide for full usage of available GPU memory at every processing step.</p>
        <p>The approach taken in Arioc is to let the user specify a batch size that indicates the maximum number of reads that can be processed concurrently. In computations where available GPU memory is exceeded (for example, in performing gapped local alignment), Arioc breaks the batch into smaller sub-batches and processes the sub-batches iteratively.</p>
        <p>Arioc also uses about 65 GB of page-locked, GPU-addressable host-system memory for its lookup tables. Data transfers from this memory are slow because they move across the PCIe bus, but the data-transfer rate is acceptable because comparatively little data is transferred during hash-table lookups.</p>
      </sec>
      <sec>
        <title>Memory layout</title>
        <p>The Arioc implementation pays particular attention to the layout of data in GPU memory. Memory reads and writes are “coalesced” so that data elements accessed by adjacent groups of GPU threads are laid out in adjacent locations in memory. Arioc therefore uses one-dimensional arrays of data to store the data elements accessed by multiple GPU threads. Although this style of in-memory data storage leads to somewhat opaque-looking code, the improvement in the speed of GPU code is noticeable (sometimes by a factor of two or more).</p>
      </sec>
      <sec>
        <title>Minimal data transfers between CPU and GPU memory</title>
        <p>Although data can theoretically move between CPU and GPU memory at speeds determined by the PCIe bus, experience has shown that application throughput is decreased when large amounts of data are moved to and from the GPU. For this reason, Arioc maintains as much data as possible in GPU memory. Data is transferred to the CPU only when all GPU-based processing is complete.</p>
      </sec>
      <sec>
        <title>Divergent flow of control in parallel threads</title>
        <p>Divergent flow of control in adjacent GPU threads can result in slower code execution. Branching logic is therefore kept to a minimum in GPU code in Arioc. Although this problem was encountered in previous GPU sequence-aligner implementations (<xref rid="ref-23" ref-type="bibr">Schatz et al., 2007</xref>), it is empirically less important in the Arioc implementation than the effect of optimized GPU memory access.</p>
      </sec>
    </sec>
    <sec>
      <title>Analysis of alignment results</title>
      <p>We used the human reference genome release 37 (<xref rid="ref-6" ref-type="bibr">Genome Reference Consortium, 2014</xref>) for throughput and sensitivity experiments. We evaluated published results for a number of CPU-based and GPU-based read aligners (<xref ref-type="supplementary-material" rid="supp-1">Supplementary Table T1</xref>) and identified four whose speed or sensitivity made them candidates for direct comparison with the Arioc implementation. These included two widely-used CPU-based read aligners and two recent GPU-based implementations (software versions listed in <xref ref-type="supplementary-material" rid="supp-1">Supplementary Table T1</xref>):</p>
      <list list-type="simple" id="list-4">
        <list-item>
          <label>•</label>
          <p>Bowtie 2 (<xref rid="ref-13" ref-type="bibr">Langmead &amp; Salzberg, 2012</xref>) (CPU)</p>
        </list-item>
        <list-item>
          <label>•</label>
          <p>BWA-MEM (<xref rid="ref-14" ref-type="bibr">Li, 2013</xref>) (CPU)</p>
        </list-item>
        <list-item>
          <label>•</label>
          <p>SOAP3-dp (<xref rid="ref-19" ref-type="bibr">Luo et al., 2013</xref>) (GPU)</p>
        </list-item>
        <list-item>
          <label>•</label>
          <p>NVBIO (<xref rid="ref-21" ref-type="bibr">NVidia, 2014</xref>) (GPU)</p>
        </list-item>
      </list>
      <p>We parsed the SAM-formatted output (<xref rid="ref-22" ref-type="bibr">SAM/BAM Format Specification Working Group, 2013</xref>) from each aligner and aggregated the results reported by each aligner for each read. We examined the POS (position), TLEN (paired-end fragment length), and AS (alignment score) fields to ensure the consistency of the set of mappings reported by each aligner. For SOAP3-DP, which does not report alignment scores, we derived scores from the mapping information reported in the CIGAR and MD fields. We computed local alignments using the following scoring parameters: match = + 2; mismatch = − 6; gap open = − 5; gap space = − 3, with a threshold alignment score of 100 (for 100 nt reads) or 400 (for 250 nt reads).</p>
      <p>We used simulated (Mason) reads to evaluate sensitivity for both paired-end and unpaired reads. For each aligner, we used high “effort” parameters so as to maximally favor sensitivity over throughput. For each read mapped by each aligner, we compared the POS and CIGAR information reported by the aligner with the POS and CIGAR generated by Mason. We assumed that a read was correctly mapped when, after accounting for soft clipping, one or both of its ends mapped within 3 nt of the mapping generated by Mason. (<xref ref-type="supplementary-material" rid="supp-1">Supplementary Table T4</xref> explains our choice of a 3 nt threshold.) To illustrate sensitivity and specificity, we plotted the cumulative number of correctly-mapped and incorrectly-mapped reads reported by each aligner, stratified by the MAPQ score (<xref rid="ref-16" ref-type="bibr">Li, Ruan &amp; Durbin, 2008</xref>) for each read.</p>
      <p>We used the YanHuang data to measure throughput using both paired-end and unpaired reads. For this analysis, we recorded throughput across a range of “effort” parameters chosen so as to trade speed for sensitivity. We defined “sensitivity” as the percentage of reads reported as mapped by each aligner with alignment score (and, for paired-end reads, TLEN) within configured limits.</p>
      <p>Prior to computing alignments, all of the GPU-aware aligners spend a brief period of execution time initializing static data structures in GPU device memory. We excluded this startup time from throughput calculations for these aligners.</p>
    </sec>
  </sec>
  <sec sec-type="results">
    <title>Results</title>
    <p>Each of the read aligners we tested is able to map tens of millions of reads to the human genome in an acceptably short period of time. All of the aligners, including Arioc, were capable of mapping simulated reads with high accuracy. With sequencer reads, Arioc demonstrated up to 10 times higher throughput across a wide range of sensitivity settings.</p>
    <sec>
      <title>Evaluation with simulated data</title>
      <p>With simulated Illumina read data, Arioc mapped paired-end reads to their correct origin in the reference genome with sensitivity and specificity comparable to all four of the aligners to which we compared it (<xref ref-type="fig" rid="fig-7">Fig. 7</xref> and <xref ref-type="supplementary-material" rid="supp-1">Supplementary Figures S1</xref>–<xref ref-type="supplementary-material" rid="supp-1">S8</xref>). Although each aligner uses a slightly different computational model for MAPQ, all of the aligners maintain a very high ratio of correct to incorrect mappings until mappings with relatively low MAPQ scores are considered.</p>
      <fig id="fig-7" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.808/fig-7</object-id>
        <label>Figure 7</label>
        <caption>
          <title>Correctly-mapped versus incorrectly-mapped simulated reads.</title>
          <p>Total correctly mapped versus incorrectly mapped reads, plotted for decreasing MAPQ, for 1 million simulated 100 nt paired-end Illumina reads (2 million total reads). Results for unpaired reads and for 250 nt reads are similar (<xref ref-type="supplementary-material" rid="supp-1">Supplementary Figures S1</xref>–<xref ref-type="supplementary-material" rid="supp-1">S8</xref>).</p>
        </caption>
        <graphic xlink:href="peerj-03-808-g007"/>
      </fig>
    </sec>
    <sec>
      <title>Evaluation with sequencer-generated data</title>
      <p>We used experimental data from the YanHuang human genome project to evaluate speed (<xref ref-type="fig" rid="fig-8">Fig. 8</xref> and <xref ref-type="supplementary-material" rid="supp-1">Supplementary Figure S9</xref>). Across a wide range of sensitivity settings, Arioc’s speed on a single GPU is about 10 times that of the CPU-based aligners to which we compared it, and two to three times that of the GPU-based aligners to which we compared it.</p>
      <fig id="fig-8" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.808/fig-8</object-id>
        <label>Figure 8</label>
        <caption>
          <title>Throughput versus sensitivity.</title>
          <p>Speed (measured as the number of 100 nt query sequences processed per second) plotted versus sensitivity (expressed as the overall percentage of mapped pairs). Data for 10 million 100 nt paired-end reads from the YanHuang genome. Workstation hardware: 12 CPU cores (24 threads of execution), one NVidia K20c GPU. Results for unpaired reads are similar (<xref ref-type="supplementary-material" rid="supp-1">Supplementary Figure S9</xref>).</p>
        </caption>
        <graphic xlink:href="peerj-03-808-g008"/>
      </fig>
      <p>With this data, throughput decreases with increasing sensitivity for all of the aligners, with a steep decrease near each aligner’s maximum sensitivity. This is apparent even with BWA-MEM and SOAP3-dp, although we were unable to “tune” these aligners across as wide a range of sensitivity settings as the others.</p>
      <p>When executed concurrently on multiple GPUs in a single machine, Arioc’s throughput increases in proportion to the number of GPUs (<xref ref-type="fig" rid="fig-9">Fig. 9</xref>). At lower sensitivity settings, overall throughput is limited by PCIe bus bandwidth. Scaling improves at higher sensitivity settings, where throughput is limited by the number of dynamic-programming computations carried out on the GPUs.</p>
      <fig id="fig-9" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.808/fig-9</object-id>
        <label>Figure 9</label>
        <caption>
          <title>Throughput on multiple GPUs.</title>
          <p>Throughput on one, two, and three GPUs (NVidia K20c) in a single computer for the data shown in <xref ref-type="fig" rid="fig-8">Fig. 8</xref>. For comparison, 2× and 3× multiples of single-GPU throughput are also plotted.</p>
        </caption>
        <graphic xlink:href="peerj-03-808-g009"/>
      </fig>
    </sec>
  </sec>
  <sec sec-type="discussion">
    <title>Discussion</title>
    <p>Apart from its potential for high throughput, the Arioc implementation demonstrates that an increase in throughput can be achieved without losing sensitivity. Furthermore, by sacrificing throughput, Arioc can be “pushed” to a comparatively high level of sensitivity.</p>
    <sec>
      <title>Performance characteristics</title>
      <p>The shape of the speed-versus-sensitivity curves we observed illustrates that read aligners achieve increased sensitivity by exploring a proportionally larger search space per successful mapping. Arioc’s search-space heuristics cause it to find high-scoring mappings (that is, perfect or near-perfect alignments) rapidly within a relatively small search space. For reads that do not map with high alignment scores, however, Arioc must explore more seed locations and compute more dynamic programming problems before it can report a satisfactory mapping. For example, in the experiment shown in <xref ref-type="fig" rid="fig-8">Fig. 8</xref>, Arioc computed about 8 times as many dynamic-programming alignments at the high end of its sensitivity range as it did at the low end of the range.</p>
      <p>Arioc explores a significantly larger search space for reads that it cannot align with a comparatively small number of mismatches or gaps. This mitigates the effect of the heuristics that filter the list of potential mapping locations on the reference sequence. In particular, gapped mappings that might be missed in an early seed iteration, when seeds are spaced widely, are detected in later seed iterations. The nature of these heuristics, however, implies that the additional mappings that Arioc finds when it is configured for higher sensitivity are generally lower-scoring mappings.</p>
      <p>The effect of Arioc’s heuristics on the computation of MAPQ (mapping quality) for a read is difficult to determine. In some cases, Arioc assigns a lower MAPQ (higher probability that the read is incorrectly mapped) simply because it computes alignments in parallel for the read and therefore tends to find more alternative mappings than would a non-parallelized implementation. On the other hand, by excluding many potential reference locations (and thus potential alternative mappings) from its search space, Arioc might incorrectly assign a high MAPQ to a read. In any event, we do not observe any notable difference overall in Arioc’s MAPQ scoring when compared with other aligners.</p>
    </sec>
    <sec>
      <title>GPU-accelerated sequence alignment</title>
      <p>Unlike the Smith–Waterman–Gotoh alignment algorithm, parallel list-management algorithms—in particular, variations of radix sort and of prefix (scan) operations—are amenable to cooperative parallel-threaded implementation. Much of the intermediate processing in the sequence-alignment pipeline is thus well-suited to GPU-based implementation. We exploited this characteristic of the read-alignment process in designing and developing the Arioc software.</p>
      <p>There are two features in the design and implementation of Arioc that distinguish it from other GPU-based read aligners. First, Arioc embodies a software design that uses the GPU as an “accelerator” in a task-parallel pipeline. CPU threads execute concurrently with GPU threads on independent data wherever possible, with synchronization points only where the GPU has completed processing a set of data. In practice, this means that overall throughput is GPU-bound and thus insensitive to variations in the time spent executing CPU threads (including post-processing alignments, reading and writing data files, and recording performance data).</p>
      <p>Second, Arioc is the result of a software-engineering approach that emphasizes the reuse of existing code as well as the use of data structures that conform to optimal GPU memory and threading models. In particular, we emphasized data structures that can be represented in one-dimensional arrays of integers as well as list manipulations that involve simple, data-independent numerical operations. In this way we were able to make extensive use of the NVidia Thrust library, a freely-available, well-optimized library implementation of basic parallel operations on GPU hardware. Arioc’s speed derives from its use of the GPU for the kinds of computations for which the cooperative threading model is well-suited (stream compaction, radix sort, parallel prefix reduction, set difference).</p>
      <p>We recognize that direct comparisons in speed between CPU-based and GPU-based software implementations are fraught with difficulties. We attempted to choose comparison hardware that was reasonably similar in terms of cost and availability. As more capable CPU and GPU hardware becomes available, we expect Arioc, like all of the aligners we evaluated, to deliver higher throughput.</p>
      <p>We also foresee further optimization of Arioc’s implementation. For example, there are newer, faster GPU function libraries that might be used to replace calls to the Thrust APIs. Also, we have not experimented with low-level optimization of our Smith–Waterman–Gotoh GPU implementation (<xref rid="ref-18" ref-type="bibr">Liu, Wirawan &amp; Schmidt, 2013</xref>). It is likely that such optimizations will appreciably improve Arioc’s throughput.</p>
      <p>In an effort to keep up with the increasing amount of sequence data used in clinical and research settings, the usual approach to designing read alignment software has been to focus on increasing throughput. Experience with both CPU-based and GPU-based aligner implementations suggests that the most expeditious way to improve throughput is to add additional computational hardware, that is, to compute read alignments concurrently in multiple threads of execution. In this regard, therefore, GPU hardware is an attractive platform for high-throughput sequence-alignment implementations.</p>
      <p>Nonetheless, the highly data-parallel nature of GPU hardware makes it difficult to reuse CPU-based techniques in a GPU implementation. A different approach to exploiting GPU parallelism is to use it for computational tasks that are particularly well-suited to the hardware, that are difficult to perform efficiently on sequential CPU threads, and that can improve throughput while maintaining high accuracy. Our results with Arioc demonstrate the validity of this strategy.</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material" id="supplemental-information">
    <title>Supplemental Information</title>
    <supplementary-material content-type="local-data" id="supp-1">
      <object-id pub-id-type="doi">10.7717/peerj.808/supp-1</object-id>
      <label>Supplemental Information 1</label>
      <caption>
        <title>Supplementary info</title>
      </caption>
      <media xlink:href="peerj-03-808-s001.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <p>We are grateful to David Luebke and Cliff Wooley of NVidia Corporation for their help in understanding some of the nuances of NVidia GPU programming.</p>
  </ack>
  <sec sec-type="additional-information">
    <title>Additional Information and Declarations</title>
    <fn-group content-type="competing-interests">
      <title>Competing Interests</title>
      <fn id="conflict-1" fn-type="conflict">
        <p>The authors declare there are no competing interests.</p>
      </fn>
    </fn-group>
    <fn-group content-type="author-contributions">
      <title>Author Contributions</title>
      <fn id="contribution-1" fn-type="con">
        <p><xref ref-type="contrib" rid="author-1">Richard Wilton</xref> conceived and designed the experiments, performed the experiments, analyzed the data, wrote the paper, prepared figures and/or tables, and reviewed drafts of the paper.</p>
      </fn>
      <fn id="contribution-2" fn-type="con">
        <p><xref ref-type="contrib" rid="author-2">Tamas Budavari</xref> reviewed drafts of the paper and collaborated in the design of the mapping-quality component of the software.</p>
      </fn>
      <fn id="contribution-3" fn-type="con">
        <p><xref ref-type="contrib" rid="author-3">Ben Langmead</xref> wrote the paper, reviewed drafts of the paper and collaborated in the design of the mapping-quality component of the software.</p>
      </fn>
      <fn id="contribution-4" fn-type="con">
        <p><xref ref-type="contrib" rid="author-4">Sarah J. Wheelan</xref> reviewed drafts of the paper and collaborated in the design of the dynamic-programming component of the software.</p>
      </fn>
      <fn id="contribution-5" fn-type="con">
        <p><xref ref-type="contrib" rid="author-5">Steven L. Salzberg</xref> wrote the paper and reviewed drafts of the paper.</p>
      </fn>
      <fn id="contribution-6" fn-type="con">
        <p><xref ref-type="contrib" rid="author-6">Alexander S. Szalay</xref> prepared figures and/or tables and reviewed drafts of the paper.</p>
      </fn>
    </fn-group>
  </sec>
  <ref-list content-type="authoryear">
    <title>References</title>
    <ref id="ref-1">
      <label>Altschul et al. (1990)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
          <name>
            <surname>Gish</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>EW</given-names>
          </name>
          <name>
            <surname>Lipman</surname>
            <given-names>DJ</given-names>
          </name>
        </person-group>
        <article-title>Basic local alignment search tool</article-title>
        <source>Journal of Molecular Biology</source>
        <year>1990</year>
        <volume>215</volume>
        <fpage>403</fpage>
        <lpage>410</lpage>
        <pub-id pub-id-type="doi">10.1016/S0022-2836(05)80360-2</pub-id>
        <pub-id pub-id-type="pmid">2231712</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-2">
      <label>Anderson et al. (2011)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Anderson</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Catanzaro</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Chong</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Gonina</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Keutzer</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Lai</surname>
            <given-names>CY</given-names>
          </name>
          <name>
            <surname>Murphy</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Sheffield</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Su</surname>
            <given-names>BY</given-names>
          </name>
          <name>
            <surname>Sundaram</surname>
            <given-names>N</given-names>
          </name>
        </person-group>
        <article-title>Considerations when evaluating microprocessor platforms</article-title>
        <conf-name>Proceedings of the 3rd USENIX conference on hot topics in parallelism</conf-name>
        <year>2011</year>
        <conf-sponsor>USENIX Association</conf-sponsor>
        <conf-loc>Berkeley</conf-loc>
      </element-citation>
    </ref>
    <ref id="ref-3">
      <label>Appleby (2014)</label>
      <element-citation publication-type="other">
        <person-group>
          <name>
            <surname>Appleby</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <year>2014</year>
        <comment>MurmurHash3. <italic>Available at <uri xlink:href="https://code.google.com/p/smhasher/">https://code.google.com/p/smhasher/</uri></italic></comment>
      </element-citation>
    </ref>
    <ref id="ref-4">
      <label>Carriero &amp; Gelernter (1990)</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Carriero</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Gelernter</surname>
            <given-names>DH</given-names>
          </name>
        </person-group>
        <source>How to write parallel programs: a first course</source>
        <year>1990</year>
        <publisher-loc>Cambridge</publisher-loc>
        <publisher-name>MIT Press</publisher-name>
        <pub-id pub-id-type="other">9-262-03171-X</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-5">
      <label>Chen, Souaiaia &amp; Chen (2009)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chen</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Souaiaia</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>PerM: efficient mapping of short sequencing reads with periodic full sensitive spaced seeds</article-title>
        <source>Bioinformatics</source>
        <issue>19</issue>
        <year>2009</year>
        <volume>25</volume>
        <fpage>2514</fpage>
        <lpage>2521</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp486</pub-id>
        <pub-id pub-id-type="pmid">19675096</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-6">
      <label>Genome Reference Consortium (2014)</label>
      <element-citation publication-type="other">
        <person-group>
          <collab>
            <institution>Genome Reference Consortium</institution>
          </collab>
        </person-group>
        <year>2014</year>
        <comment>Human Build 37 patch release 5 (GRCh37.p5). <italic>Available at <uri xlink:href="http://www.ncbi.nlm.nih.gov/assembly/GCF_000001405.17/">http://www.ncbi.nlm.nih.gov/assembly/GCF_000001405.17/</uri></italic></comment>
      </element-citation>
    </ref>
    <ref id="ref-7">
      <label>Glenn (2011)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Glenn</surname>
            <given-names>TC</given-names>
          </name>
        </person-group>
        <article-title>Field guide to next-generation DNA sequencers</article-title>
        <source>Molecular Ecology Resources</source>
        <year>2011</year>
        <volume>11</volume>
        <fpage>759</fpage>
        <lpage>769</lpage>
        <pub-id pub-id-type="doi">10.1111/j.1755-0998.2011.03024.x</pub-id>
        <pub-id pub-id-type="pmid">21592312</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-8">
      <label>Gotoh (1982)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gotoh</surname>
            <given-names>O</given-names>
          </name>
        </person-group>
        <article-title>An improved algorithm for matching biological sequences</article-title>
        <source>Journal of Molecular Biology</source>
        <year>1982</year>
        <volume>162</volume>
        <fpage>705</fpage>
        <lpage>708</lpage>
        <pub-id pub-id-type="doi">10.1016/0022-2836(82)90398-9</pub-id>
        <pub-id pub-id-type="pmid">7166760</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-9">
      <label>Hayden (2014)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hayden</surname>
            <given-names>EC</given-names>
          </name>
        </person-group>
        <article-title>Is the $1,000 genome for real?</article-title>
        <source>Nature News &amp; Comment</source>
        <year>2014</year>
        <pub-id pub-id-type="doi">10.1038/nature.2014.14530</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-10">
      <label>Holtgrewe (2010)</label>
      <element-citation publication-type="report">
        <person-group person-group-type="author">
          <name>
            <surname>Holtgrewe</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Mason—a read simulator for second generation sequencing data</article-title>
        <source>Technical Report TR-B-10-06</source>
        <year>2010</year>
        <institution>Berlin: Institut für Mathematik und Informatik, Freie Universität Berlin</institution>
      </element-citation>
    </ref>
    <ref id="ref-11">
      <label>Khajeh-Saeed, Poole &amp; Perot (2010)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Khajeh-Saeed</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Poole</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Perot</surname>
            <given-names>JB</given-names>
          </name>
        </person-group>
        <article-title>Acceleration of the Smith–Waterman algorithm using single and multiple graphics processors</article-title>
        <source>Journal of Computational Physics</source>
        <year>2010</year>
        <volume>229</volume>
        <fpage>4247</fpage>
        <lpage>4258</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jcp.2010.02.009</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-12">
      <label>Kristensen (2011)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kristensen</surname>
            <given-names>DM</given-names>
          </name>
        </person-group>
        <article-title>Moving beyond genome sequencing into personalized genomic medicine: biological and computing challenges</article-title>
        <source>Genome Biology</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>308</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2011-12-10-308</pub-id>
        <pub-id pub-id-type="pmid">22023790</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-13">
      <label>Langmead &amp; Salzberg (2012)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Langmead</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Fast gapped-read alignment with Bowtie 2</article-title>
        <source>Nature Methods</source>
        <year>2012</year>
        <volume>9</volume>
        <fpage>357</fpage>
        <lpage>359</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.1923</pub-id>
        <pub-id pub-id-type="pmid">22388286</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-14">
      <label>Li (2013)</label>
      <element-citation publication-type="working-paper">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Aligning sequence reads, clone sequences and assembly contigs with BWA-MEM</article-title>
        <year>2013</year>
        <pub-id pub-id-type="arxiv">1303.3997v1</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-15">
      <label>Li et al. (2009)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Ma</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Song</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Yang</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Huang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Yang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>The YH database: the first Asian diploid genome database</article-title>
        <source>Nucleic Acids Research</source>
        <issue>database issue</issue>
        <year>2009</year>
        <volume>37</volume>
        <fpage>D1025</fpage>
        <lpage>D1028</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkn966</pub-id>
        <pub-id pub-id-type="pmid">19073702</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-16">
      <label>Li, Ruan &amp; Durbin (2008)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Ruan</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Mapping short DNA sequencing reads and calling variants using mapping quality scores (Supplementary Text)</article-title>
        <source>Genome Research</source>
        <year>2008</year>
        <volume>18</volume>
        <fpage>1851</fpage>
        <lpage>1858</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.078212.108</pub-id>
        <pub-id pub-id-type="pmid">18714091</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-17">
      <label>Lipman &amp; Pearson (1985)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lipman</surname>
            <given-names>DJ</given-names>
          </name>
          <name>
            <surname>Pearson</surname>
            <given-names>WR</given-names>
          </name>
        </person-group>
        <article-title>Rapid and sensitive protein similarity searches</article-title>
        <source>Science</source>
        <issue>4693</issue>
        <year>1985</year>
        <volume>227</volume>
        <fpage>1435</fpage>
        <lpage>1441</lpage>
        <pub-id pub-id-type="doi">10.1126/science.2983426</pub-id>
        <pub-id pub-id-type="pmid">2983426</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-18">
      <label>Liu, Wirawan &amp; Schmidt (2013)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Liu</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Wirawan</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Schmidt</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>CUDASW+ + 3.0: accelerating Smith–Waterman protein database search by coupling CPU and GPU SIMD instructions</article-title>
        <source>BMC Bioinformatics</source>
        <year>2013</year>
        <volume>14</volume>
        <fpage>117</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-14-117</pub-id>
        <pub-id pub-id-type="pmid">23557111</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-19">
      <label>Luo et al. (2013)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Luo</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Wong</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Zhu</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>CM</given-names>
          </name>
          <name>
            <surname>Zhu</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Wu</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>LK</given-names>
          </name>
          <name>
            <surname>Lin</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Zhu</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Cheung</surname>
            <given-names>DW</given-names>
          </name>
          <name>
            <surname>Ting</surname>
            <given-names>HF</given-names>
          </name>
          <name>
            <surname>Yiu</surname>
            <given-names>SM</given-names>
          </name>
          <name>
            <surname>Peng</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Yu</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Lam</surname>
            <given-names>TW</given-names>
          </name>
        </person-group>
        <article-title>SOAP3-dp: fast, accurate and sensitive GPU-based short read aligner</article-title>
        <source>PLoS ONE</source>
        <issue>5</issue>
        <year>2013</year>
        <volume>8</volume>
        <elocation-id>e808</elocation-id>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0065632</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-20">
      <label>Manavski &amp; Valle (2008)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Manavski</surname>
            <given-names>SA</given-names>
          </name>
          <name>
            <surname>Valle</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>CUDA compatible GPU cards as efficient hardware accelerators for Smith–Waterman sequence alignment</article-title>
        <source>BMC Bioinformatics</source>
        <issue>supplement 2</issue>
        <year>2008</year>
        <volume>9</volume>
        <fpage>S10</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-9-S2-S10</pub-id>
        <pub-id pub-id-type="pmid">18387198</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-21">
      <label>NVidia (2014)</label>
      <element-citation publication-type="other">
        <person-group>
          <collab>
            <institution>NVidia Corporation</institution>
          </collab>
        </person-group>
        <year>2014</year>
        <comment>NVBIO. Santa Clara: NVidia. <italic>Available at <uri xlink:href="http://nvlabs.github.io/nvbio">http://nvlabs.github.io/nvbio</uri></italic></comment>
      </element-citation>
    </ref>
    <ref id="ref-22">
      <label>SAM/BAM Format Specification Working Group (2013)</label>
      <element-citation publication-type="other">
        <person-group>
          <collab>
            <institution>SAM/BAM Format Specification Working Group</institution>
          </collab>
        </person-group>
        <year>2013</year>
        <comment>Sequence Alignment/Map Format Specification. <italic>Available at <uri xlink:href="https://github.com/samtools/hts-specs">https://github.com/samtools/hts-specs</uri></italic></comment>
      </element-citation>
    </ref>
    <ref id="ref-23">
      <label>Schatz et al. (2007)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schatz</surname>
            <given-names>MC</given-names>
          </name>
          <name>
            <surname>Trapnell</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Delcher</surname>
            <given-names>AL</given-names>
          </name>
          <name>
            <surname>Varshney</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>High-throughput sequence alignment using Graphics Processing Units</article-title>
        <source>BMC Bioinformatics</source>
        <year>2007</year>
        <volume>8</volume>
        <fpage>474</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-8-474</pub-id>
        <pub-id pub-id-type="pmid">18070356</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-24">
      <label>Smith &amp; Waterman (1981)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smith</surname>
            <given-names>TF</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>MS</given-names>
          </name>
        </person-group>
        <article-title>Identification of common molecular subsequences</article-title>
        <source>Journal of Molecular Biology</source>
        <year>1981</year>
        <volume>147</volume>
        <fpage>195</fpage>
        <lpage>197</lpage>
        <pub-id pub-id-type="doi">10.1016/0022-2836(81)90087-5</pub-id>
        <pub-id pub-id-type="pmid">7265238</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-25">
      <label>Wu &amp; Nacu (2010)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wu</surname>
            <given-names>TD</given-names>
          </name>
          <name>
            <surname>Nacu</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Fast and SNP-tolerant detection of complex variants and splicing in short reads</article-title>
        <source>Bioinformatics</source>
        <issue>7</issue>
        <year>2010</year>
        <volume>26</volume>
        <fpage>873</fpage>
        <lpage>881</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq057</pub-id>
        <pub-id pub-id-type="pmid">20147302</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
