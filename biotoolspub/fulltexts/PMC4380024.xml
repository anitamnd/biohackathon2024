<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4380024</article-id>
    <article-id pub-id-type="pmid">25380957</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btu728</article-id>
    <article-id pub-id-type="publisher-id">btu728</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="heading">
          <subject>Phylogenetics</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Joint amalgamation of most parsimonious reconciled gene trees</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Scornavacca</surname>
          <given-names>Celine</given-names>
        </name>
        <xref ref-type="aff" rid="btu728-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="btu728-AFF1">
          <sup>2</sup>
        </xref>
        <xref ref-type="corresp" rid="btu728-COR1">*</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Jacox</surname>
          <given-names>Edwin</given-names>
        </name>
        <xref ref-type="aff" rid="btu728-AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Szöllősi</surname>
          <given-names>Gergely J.</given-names>
        </name>
        <xref ref-type="aff" rid="btu728-AFF1">
          <sup>3</sup>
        </xref>
        <xref ref-type="corresp" rid="btu728-COR1">*</xref>
      </contrib>
      <aff id="btu728-AFF1"><sup>1</sup>ISEM, UM2-CNRS-IRD, Place Eugène Bataillon 34095 Montpellier, France, <sup>2</sup>Institut de Biologie Computationnelle (IBC), 95 rue de la Galéra, 34095 Montpellier, France and <sup>3</sup>ELTE-MTA ‘Lendület’ Biophysics Research Group 1117 Bp., Pázmány P. stny. 1A., Budapest, Hungary</aff>
    </contrib-group>
    <author-notes>
      <corresp id="btu728-COR1">*To whom correspondence should be addressed.</corresp>
      <fn id="FN1">
        <p>Associate Editor: David Posada</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>3</month>
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>06</day>
      <month>11</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>06</day>
      <month>11</month>
      <year>2014</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>31</volume>
    <issue>6</issue>
    <fpage>841</fpage>
    <lpage>848</lpage>
    <history>
      <date date-type="received">
        <day>27</day>
        <month>5</month>
        <year>2014</year>
      </date>
      <date date-type="rev-recd">
        <day>28</day>
        <month>10</month>
        <year>2014</year>
      </date>
      <date date-type="accepted">
        <day>29</day>
        <month>10</month>
        <year>2014</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author 2014. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2014</copyright-year>
      <license xlink:href="http://creativecommons.org/licenses/by-nc/4.0/" license-type="creative-commons">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> Traditionally, gene phylogenies have been reconstructed solely on the basis of molecular sequences; this, however, often does not provide enough information to distinguish between statistically equivalent relationships. To address this problem, several recent methods have incorporated information on the species phylogeny in gene tree reconstruction, leading to dramatic improvements in accuracy. Although probabilistic methods are able to estimate all model parameters but are computationally expensive, parsimony methods—generally computationally more efficient—require a prior estimate of parameters and of the statistical support.</p>
      <p><bold>Results:</bold> Here, we present the Tree Estimation using Reconciliation (TERA) algorithm, a parsimony based, species tree aware method for gene tree reconstruction based on a scoring scheme combining duplication, transfer and loss costs with an estimate of the sequence likelihood. TERA explores all reconciled gene trees that can be amalgamated from a sample of gene trees. Using a large scale simulated dataset, we demonstrate that TERA achieves the same accuracy as the corresponding probabilistic method while being faster, and outperforms other parsimony-based methods in both accuracy and speed. Running TERA on a set of 1099 homologous gene families from complete cyanobacterial genomes, we find that incorporating knowledge of the species tree results in a two thirds reduction in the number of apparent transfer events.</p>
      <p><bold>Availability and implementation:</bold> The algorithm is implemented in our program <italic>TERA</italic>, which is freely available from <ext-link ext-link-type="uri" xlink:href="http://mbb.univ-montp2.fr/MBB/download_sources/16__TERA">http://mbb.univ-montp2.fr/MBB/download_sources/16__TERA</ext-link>.</p>
      <p><bold>Contact:</bold><email>celine.scornavacca@univ-montp2.fr</email>, <email>ssolo@angel.elte.hu</email></p>
      <p><bold>Supplementary information:</bold><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu728/-/DC1">Supplementary data</ext-link> are available at <italic>Bioinformatics</italic> online.</p>
    </abstract>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Molecular phylogenetics infers gene trees based on the information contained in molecular sequences. Unfortunately, individual sequences may contain limited signal, and, as a result, phylogenetic reconstruction often involves choosing between statistically equivalent or weakly distinguishable evolutionary relationships.</p>
    <p>Although each homologous gene family has its own unique story, these are all related by a shared species history—which can be helpful for gene tree inference (<xref rid="btu728-B17" ref-type="bibr">Maddison, 1997</xref>; <xref rid="btu728-B32" ref-type="bibr">Szöllősi <italic>et al.,</italic> 2014</xref>). In the past decade, several methods have been developed that model the evolutionary processes that generate gene trees within the species tree (<xref rid="btu728-B1" ref-type="bibr">Akerborg <italic>et al.,</italic> 2009</xref>; <xref rid="btu728-B2" ref-type="bibr">Arvestad, 2003</xref>; <xref rid="btu728-B12" ref-type="bibr">Hallett and Lagergren, 2001</xref>; <xref rid="btu728-B21" ref-type="bibr">Rannala and Yang, 2003</xref>; <xref rid="btu728-B22" ref-type="bibr">Rasmussen and Kellis, 2007</xref>, <xref rid="btu728-B24" ref-type="bibr">2012</xref>; <xref rid="btu728-B26" ref-type="bibr">Sjöstrand <italic>et al.,</italic> 2014</xref>; <xref rid="btu728-B27" ref-type="bibr">Suchard, 2005</xref>; <xref rid="btu728-B29" ref-type="bibr">Szöllősi <italic>et al.,</italic> 2012</xref><italic>,</italic>
<xref rid="btu728-B30" ref-type="bibr">2013a</xref>; <xref rid="btu728-B33" ref-type="bibr">Than and Nakhleh, 2009</xref>). From an inference perspective, these methods attempt to find the optimal way to explain the phylogenetic signal in extant sequences—represented as a gene tree—given the species tree. They explore the set of possible <italic>reconciliations</italic>, i.e. different ways to draw the gene tree into the species tree given some combination of macro evolutionary events, such as gene duplications, gene transfers, gene losses and incomplete lineage sorting. Studies that incorporate such events into gene tree inference have shown that information on the species phylogeny significantly improves the accuracy of gene tree inference (<xref rid="btu728-B1" ref-type="bibr">Akerborg <italic>et al.,</italic> 2009</xref>; <xref rid="btu728-B5" ref-type="bibr">Boussau <italic>et al.,</italic> 2013</xref>; <xref rid="btu728-B23" ref-type="bibr">Rasmussen and Kellis, 2010</xref>; <xref rid="btu728-B31" ref-type="bibr">Szöllősi <italic>et al.,</italic> 2013b</xref>). To design such <italic>species tree aware methods</italic> for reconstructing gene phylogenies, the space of reconciled gene trees must be explored using information from both a model of <italic>sequence evolution</italic> and a <italic>reconciliation</italic> model, in order to optimize a <italic>joint</italic> sequence-reconciliation score. Such exploration is computationally expensive with traditional optimization approaches that rely on the local search of the space of gene trees.</p>
    <p>To circumvent this problem, <xref rid="btu728-B7" ref-type="bibr">David and Alm (2010)</xref> introduced the amalgamation algorithm, described in detail in Section 2.3 below and illustrated in <xref ref-type="fig" rid="btu728-F1">Figure 1</xref>. Furthermore, <xref rid="btu728-B31" ref-type="bibr">Szöllősi <italic>et al.</italic> (2013b)</xref> recently developed an approach to exhaustively explore all reconciled gene trees that can be <italic>amalgamated</italic> from a sample of gene trees, i.e. obtainable by combining clades observed in the sample. Additionally, their method—ALE, for Amalgamated Likelihood Estimation—combines the amalgamation algorithm of <xref rid="btu728-B7" ref-type="bibr">David and Alm (2010)</xref> with conditional clade probabilities (CCPs) introduced by <xref rid="btu728-B13" ref-type="bibr">Höhna and Drummond (2012)</xref> and reconstructs the gene phylogenies by optimizing a joint sequence-reconciliation likelihood score, resulting in gene trees that are dramatically more accurate than those reconstructed using molecular sequences alone.
<fig id="btu728-F1" position="float"><label>Fig. 1.</label><caption><p>CCPs can be used to estimate the posterior probability of any tree that can be <italic>amalgamated</italic> from clades present in a sample of gene trees (<xref rid="btu728-B7" ref-type="bibr">David and Alm, 2010</xref>; <xref rid="btu728-B13" ref-type="bibr">Höhna and Drummond, 2012</xref>). Conditional clade frequencies can be used to approximate CCPs and are computed as the proportion of occurrences of a particular split of a clade according to a tripartition <italic>π</italic>, e.g. (<italic>abc</italic>
<inline-formula><mml:math id="MM1"><mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula>
<italic>de</italic>) among all trees in which the clade, e.g. (<italic>abcde</italic>), is found. Estimates based on the sample of trees on the left are shown as fractions for two different gene trees that can be amalgamated. The estimate for a gene tree is given by the sum of the reconciliation score and the logarithm of the tree CCPs. Based on the sample on the left, the tree with the highest posterior probability is the third tree (blue online). Reconciling it with the species tree requires one transfer and one loss event. It is, however, possible to combine clades present in the second (green online) and third (blue online) trees to produce a gene tree that is not present in the original sample but is identical to the species tree, <italic>i.e.</italic> it requires no events to draw it into the species tree. Depending on the costs of transfer and loss events, and the self-consistently estimated <italic>c<sub>A</sub></italic> parameter, the scenario without transfer might be optimal for the joint score</p></caption><graphic xlink:href="btu728f1p"/></fig>
</p>
    <p>ALE overcomes a fundamental limitation of recent parsimony based methods that improve gene trees given a putative species tree (<xref rid="btu728-B7" ref-type="bibr">David and Alm, 2010</xref>; <xref rid="btu728-B18" ref-type="bibr">Nguyen <italic>et al.,</italic> 2012</xref>; <xref rid="btu728-B36" ref-type="bibr">Wu <italic>et al.,</italic> 2013</xref>). Unlike those methods, it does not require the user to specify a cost for each type of event or a threshold on statistical supports. However, ALE faces the drawbacks associated with probabilistic methods. In particular: (i) when computing the reconciliation score, ALE has an increased computational cost compared with a parsimony algorithm (e.g. <xref rid="btu728-B6" ref-type="bibr">Conow <italic>et al.,</italic> 2010</xref>; <xref rid="btu728-B9" ref-type="bibr">Doyon <italic>et al.,</italic> 2010</xref>), which is due to a potentially large constant factor resulting from the numerical integration of the likelihood; (ii) ALE’s results are contingent on difficult to estimate time-like branch lengths of the species tree, while parsimony methods can reconcile gene trees relying only on the order of speciations in time (e.g. <xref rid="btu728-B9" ref-type="bibr">Doyon <italic>et al.,</italic> 2010</xref>), and even deal with undated species trees (e.g. <xref rid="btu728-B3" ref-type="bibr">Bansal <italic>et al.,</italic> 2012</xref>). Parsimony methods in general, despite lacking an explicit connection to a generative probabilistic model and relying on other heuristics, have been shown to be highly accurate, comparable to sophisticated probabilistic reconciliation methods, with reduced runtime (<xref rid="btu728-B36" ref-type="bibr">Wu <italic>et al.,</italic> 2013</xref>, <xref rid="btu728-B37" ref-type="bibr">2014</xref>).</p>
    <p>Here we present the TERA algorithm (Tree Estimation using Reconciliation and Amalgamation) that amalgamates the most parsimonious reconciled gene tree from a set of gene trees reconstructed from a unique gene alignment, according to a joint sequence-reconciliation score. Although TERA, like other parsimony based methods, requires the prior specification of the costs associated with duplication, transfer and loss (DTL) events, it does not require prior assumptions about a statistical support threshold, as it estimates a self-consistent support threshold from its input. Furthermore, TERA considers explicitly the possibility of transfer from extinct or unsampled branches of the species tree, which is expected to be the case for practically all transfers (<xref rid="btu728-B30" ref-type="bibr">Szöllősi <italic>et al.,</italic> 2013a</xref>). TERA does not, however, consider incomplete lineage sorting. The self-consistent score estimation scheme used by TERA, introduced in Section 2.4, should be applicable to other parsimony methods, while amalgamation is in theory compatible with any reconciliation algorithm that assumes branches of the gene tree to be independent.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 Preliminaries</title>
      <p>Given a binary rooted tree <italic>T</italic>, we respectively denote by <italic>V</italic>(<italic>T</italic>), <italic>E</italic>(<italic>T</italic>), <italic>L</italic>(<italic>T</italic>) and <italic>r</italic>(<italic>T</italic>), its node, edge, leaf node sets and root node. The label of each leaf <italic>u</italic> is denoted by <inline-formula><mml:math id="MM2"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, while the set of labels of leaves of <italic>T</italic> is denoted by <inline-formula><mml:math id="MM3"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Given a node <inline-formula><mml:math id="MM4"><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we denote respectively by <italic>u</italic><sub>p</sub>, <italic>u</italic><sub>s</sub> and <inline-formula><mml:math id="MM5"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mtext>l</mml:mtext></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mtext>r</mml:mtext></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> the father, the sibling and the children of <italic>u</italic> (if they are defined). Note that in this article all trees are considered as unordered, so <italic>u</italic><sub>l</sub> and <italic>u</italic><sub>r</sub> are interchangeable. For a node <italic>u</italic> of <italic>T</italic>, <italic>T</italic><sub>u</sub> denotes the subtree of <italic>T</italic> rooted at <italic>u</italic>. Given two nodes <italic>u</italic> and <italic>v</italic> of <italic>T</italic>, <inline-formula><mml:math id="MM6"><mml:mrow><mml:mi>u</mml:mi><mml:msub><mml:mo>≤</mml:mo><mml:mi>T</mml:mi></mml:msub><mml:mi>v</mml:mi></mml:mrow></mml:math></inline-formula> (<inline-formula><mml:math id="MM7"><mml:mrow><mml:mi>u</mml:mi><mml:msub><mml:mo>&lt;</mml:mo><mml:mi>T</mml:mi></mml:msub><mml:mi>v</mml:mi></mml:mrow></mml:math></inline-formula>, respectively) if and only if <italic>v</italic> is on the unique path from <italic>u</italic> to <italic>r</italic>(<italic>T</italic>) (respectively, and <inline-formula><mml:math id="MM8"><mml:mrow><mml:mi>u</mml:mi><mml:mo>≠</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:math></inline-formula>); in such a case, <italic>u</italic> is said to be a (strict) descendant of <italic>v</italic>. Given a node <italic>u</italic> of <italic>T</italic>, we define the <italic>clade</italic> associated with <italic>u</italic>, denoted by <italic>C</italic>(<italic>u</italic>), as the set <inline-formula><mml:math id="MM9"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. If <italic>u</italic> is an internal node, we define the <italic>tripartition</italic> associated with <italic>u</italic>, denoted by <inline-formula><mml:math id="MM10"><mml:mrow><mml:mi>Π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, as the triple (<inline-formula><mml:math id="MM11"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mtext>l</mml:mtext></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mtext>r</mml:mtext></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>). For leaf nodes, the trivial tripartition <inline-formula><mml:math id="MM12"><mml:mrow><mml:mi>Π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is defined as the triple (<inline-formula><mml:math id="MM13"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mo>∅</mml:mo><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula>). Finally, the height of <italic>T</italic> is denoted by <italic>h</italic>(<italic>T</italic>).</p>
      <p>In this article, unless stated otherwise, we assume that gene and species trees are rooted, binary and uniquely leaf labeled, i.e. within each tree there is a bijection between leaves and labels. Due to this bijectivity we will refer to leaves and labels interchangeably.</p>
      <p>We define a gene tree <italic>G</italic> as a tree where each leaf represents an extant gene. Similarly, a species tree <italic>S</italic> is defined as a tree in which each leaf represents a distinct extant species. Note that several leaves of a gene tree can be associated to the same species due to gene birth corresponding to duplication and transfer events. Formally, we indicate this by a surjective function <inline-formula><mml:math id="MM14"><mml:mrow><mml:mi>s</mml:mi><mml:mo>:</mml:mo><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>→</mml:mo><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, called the <italic>species labeling</italic> of <italic>G</italic>. The set of species labels of the leaves of <italic>G</italic> is denoted <inline-formula><mml:math id="MM15"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>A tree <italic>T</italic> is said to be <italic>time ordered</italic> when it is associated with a <italic>time function</italic>
<inline-formula><mml:math id="MM16"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mi>T</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>→</mml:mo><mml:msup><mml:mi mathvariant="double-struck">R</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> that associates each of its nodes with a non-negative value so that, for any two nodes <inline-formula><mml:math id="MM17"><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, if <italic>x</italic>′ is a strict descendant of <italic>x</italic> then <inline-formula><mml:math id="MM18"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Moreover, <inline-formula><mml:math id="MM19"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we have that <inline-formula><mml:math id="MM20"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. A <italic>subdivision</italic>
<italic>T</italic>′ of a time-ordered tree <italic>T</italic> is the tree obtained from <italic>T</italic> by adding a new node <italic>y</italic> with <inline-formula><mml:math id="MM21"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mtext>T</mml:mtext><mml:mo>′</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> on each edge <inline-formula><mml:math id="MM22"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> such that there exists <inline-formula><mml:math id="MM23"><mml:mrow><mml:mi>z</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with <inline-formula><mml:math id="MM24"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mtext>T</mml:mtext></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mtext>T</mml:mtext></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mtext>T</mml:mtext></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mtext>p</mml:mtext></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. For nodes <inline-formula><mml:math id="MM25"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> corresponding to nodes already present in <italic>T</italic>, we set <inline-formula><mml:math id="MM26"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mrow><mml:mtext>T</mml:mtext><mml:mo>′</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mtext>T</mml:mtext></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>2.2 Species tree-gene tree reconciliation</title>
      <p>Here, we consider the problem of finding the most parsimonious reconciliation (MPR) when considering—as possible macro-events that result in the birth and death of gene copies—speciation, gene duplication, gene transfers and gene loss (<xref rid="btu728-B28" ref-type="bibr">Szöllősi and Daubin, 2012</xref>). The general problem of finding an MPR is known to be NP-complete, even for reconciling two binary trees (<xref rid="btu728-B35" ref-type="bibr">Tofigh <italic>et al.,</italic> 2011</xref>). The complexity of the problem is due to the difficulty of ensuring the <italic>time</italic>
<italic>consistency</italic> of gene transfers, i.e. satisfying the chronological constraints among nodes of the species tree that are induced by transfer events. However, the problem becomes polynomially solvable when accepting a time-ordered species tree as input (among others <xref rid="btu728-B6" ref-type="bibr">Conow <italic>et al.,</italic> 2010</xref>; <xref rid="btu728-B9" ref-type="bibr">Doyon <italic>et al.,</italic> 2010</xref>
<xref rid="btu728-B34" ref-type="bibr">Tofigh, 2009</xref>, see <xref rid="btu728-B8" ref-type="bibr">Doyon <italic>et al.,</italic> 2011</xref> for a review). In this article, we build upon the combinatorial reconciliation model introduced by <xref rid="btu728-B9" ref-type="bibr">Doyon <italic>et al.</italic> (2010)</xref>, which can be used to solve this special case of the problem.</p>
      <p>Some parsimony methods (e.g. <xref rid="btu728-B3" ref-type="bibr">Bansal <italic>et al.,</italic> 2012</xref>) do not need information on the order of speciations in time. This allows a more efficient recursion over reconciliations, but at the cost of considering reconciliations that contain transfer events that are not consistent with any ordering of the species tree (<xref rid="btu728-B35" ref-type="bibr">Tofigh <italic>et al.,</italic> 2011</xref>).</p>
      <p>The <inline-formula><mml:math id="MM27"><mml:mrow><mml:mi mathvariant="double-struck">D</mml:mi><mml:mi mathvariant="double-struck">T</mml:mi><mml:mi mathvariant="double-struck">L</mml:mi></mml:mrow></mml:math></inline-formula> model of <xref rid="btu728-B9" ref-type="bibr">Doyon <italic>et al.</italic> (2010)</xref> can be used to reconcile a time-ordered binary species tree <italic>S</italic> with a binary gene tree <italic>G</italic> by constructing a mapping <italic>α</italic> that maps each node <inline-formula><mml:math id="MM28"><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> into an ordered list of nodes in <inline-formula><mml:math id="MM29"><mml:mrow><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, namely the ancestral and/or extant species in which the sequence corresponding to <italic>u</italic> evolved. This model takes into account four kinds of biological events: speciation, gene duplication, gene transfer and gene loss. The atomic events of this model are: a speciation (<inline-formula><mml:math id="MM30"><mml:mi mathvariant="double-struck">S</mml:mi></mml:math></inline-formula>), a duplication (<inline-formula><mml:math id="MM31"><mml:mi mathvariant="double-struck">D</mml:mi></mml:math></inline-formula>), a transfer (<inline-formula><mml:math id="MM32"><mml:mi mathvariant="double-struck">T</mml:mi></mml:math></inline-formula>), a transfer followed immediately by the loss of the non-transferred child (<inline-formula><mml:math id="MM33"><mml:mrow><mml:mi mathvariant="double-struck">T</mml:mi><mml:mi mathvariant="double-struck">L</mml:mi></mml:mrow></mml:math></inline-formula>), a speciation followed by the loss of one of the two resulting children (<inline-formula><mml:math id="MM34"><mml:mrow><mml:mi mathvariant="double-struck">S</mml:mi><mml:mi mathvariant="double-struck">L</mml:mi></mml:mrow></mml:math></inline-formula>), and a contemporary event (<inline-formula><mml:math id="MM35"><mml:mi mathvariant="double-struck">C</mml:mi></mml:math></inline-formula>) that associates an extant gene to its corresponding species. Finally, a null event (<inline-formula><mml:math id="MM36"><mml:mo>∅</mml:mo></mml:math></inline-formula>), is used to model a gene lineage crossing a time boundary. Note that duplication-loss events and transfer followed by the loss of the transferred gene, unlike a transfer followed by the loss of the non-transferred gene and speciation-loss events, leave no trace and are therefore undetectable. This is why, in the <inline-formula><mml:math id="MM37"><mml:mrow><mml:mi mathvariant="double-struck">D</mml:mi><mml:mi mathvariant="double-struck">T</mml:mi><mml:mi mathvariant="double-struck">L</mml:mi></mml:mrow></mml:math></inline-formula> model, losses are never considered alone. We refer the reader to <xref rid="btu728-B9" ref-type="bibr">Doyon <italic>et al.</italic> (2010)</xref> for the formal definition of a <inline-formula><mml:math id="MM38"><mml:mrow><mml:mi mathvariant="double-struck">D</mml:mi><mml:mi mathvariant="double-struck">T</mml:mi><mml:mi mathvariant="double-struck">L</mml:mi></mml:mrow></mml:math></inline-formula> reconciliation.</p>
      <p>Let <italic>θ</italic>, <italic>τ</italic>, <italic>λ</italic> be, respectively, the costs of a duplication, a transfer and a loss. Given a <inline-formula><mml:math id="MM39"><mml:mrow><mml:mi mathvariant="double-struck">D</mml:mi><mml:mi mathvariant="double-struck">T</mml:mi><mml:mi mathvariant="double-struck">L</mml:mi></mml:mrow></mml:math></inline-formula> reconciliation, we define the cost of <italic>α</italic>, denoted by <inline-formula><mml:math id="MM40"><mml:mrow><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>α</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, as the sum <inline-formula><mml:math id="MM41"><mml:mrow><mml:mi>θ</mml:mi><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mi>τ</mml:mi><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>λ</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:math></inline-formula>, where <italic>d</italic>, <italic>t</italic> and <italic>l</italic> are respectively the number of <inline-formula><mml:math id="MM42"><mml:mi mathvariant="double-struck">D</mml:mi></mml:math></inline-formula> events, of <inline-formula><mml:math id="MM43"><mml:mi mathvariant="double-struck">T</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="MM44"><mml:mrow><mml:mi mathvariant="double-struck">T</mml:mi><mml:mi mathvariant="double-struck">L</mml:mi></mml:mrow></mml:math></inline-formula> events, and of <inline-formula><mml:math id="MM45"><mml:mrow><mml:mi mathvariant="double-struck">S</mml:mi><mml:mi mathvariant="double-struck">L</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM46"><mml:mrow><mml:mi mathvariant="double-struck">T</mml:mi><mml:mi mathvariant="double-struck">L</mml:mi></mml:mrow></mml:math></inline-formula> events in <italic>α</italic>. In <xref rid="btu728-B9" ref-type="bibr">Doyon <italic>et al.</italic> (2010)</xref> the authors give an efficient algorithm to compute <italic>c</italic>(<italic>G</italic>, <italic>S</italic>) for a time-ordered species tree <italic>S</italic> and a gene tree <italic>G</italic>, where <italic>c</italic>(<italic>G</italic>, <italic>S</italic>) is defined as the minimum cost over all possible <inline-formula><mml:math id="MM47"><mml:mrow><mml:mi mathvariant="double-struck">D</mml:mi><mml:mi mathvariant="double-struck">T</mml:mi><mml:mi mathvariant="double-struck">L</mml:mi></mml:mrow></mml:math></inline-formula> reconciliations between <italic>G</italic> and <italic>S</italic>.</p>
    </sec>
    <sec>
      <title>2.3 Choosing a reliable gene tree among several competing alternatives</title>
      <p>Even though our aim is to reconstruct reliable gene trees from a multiple sequence alignment and a species phylogeny, our approach does not directly take sequence alignments as an input, but requires a sample of gene trees, typically produced from the alignment by either a Markov Chain Monte Carlo (MCMC) methods such as PhyloBayes (<xref rid="btu728-B15" ref-type="bibr">Lartillot <italic>et al.,</italic> 2009</xref>) and MrBayes (<xref rid="btu728-B25" ref-type="bibr">Ronquist <italic>et al.,</italic> 2012</xref>), or bootstrap resampling.</p>
      <p>To find the optimal gene tree, clades found in the input sample of gene trees are combined using the <italic>amalgamation</italic> approach in order to recover an optimal tree with respect to our scoring scheme. The optimal tree recovered will only contain clades found in the input sample of gene trees, but it will not in general be found in the sample itself.</p>
      <p><xref ref-type="fig" rid="btu728-F1">Figure 1</xref> provides a schematic illustration of the amalgamation approach. Clades present in the sample of trees (the unrooted trees on the left) can be combined to obtain a tree such that each clade is found in the sample, but the tree itself is not. For example, one can produce a green-blue tree consisting of a green subtree with genes a, b and c, and a blue subtree with genes d, e and f. The sequence score of each tree is obtained using CCPs that depend on the number of times different trees are seen in the sample and is described in detail in the next section. The reconciliation score for each tree corresponds to the MPR of the gene tree with the species tree. The amalgamation algorithm itself is a joint dynamic programming recursion over (i) all trees that can be produced from clades present in the input sample and (ii) all possible ways to reconcile each of these trees with the species tree, to recover a gene tree with the smallest joint sequence-reconciliation score. As shown in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu728/-/DC1">Figure 1</ext-link> in the <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu728/-/DC1">online appendix</ext-link>, amalgamation permits us to explore a vastly larger set of trees than those contained in the sample.</p>
      <p>Conceptually, both ALE (<xref rid="btu728-B31" ref-type="bibr">Szöllősi <italic>et al.,</italic> 2013b</xref>) and TERA are based on the amalgamation approach of AnGST (<xref rid="btu728-B7" ref-type="bibr">David and Alm, 2010</xref>), and all three methods are—at the level of the dynamic programming recursion—closely related. TERA differs from AnGST in the underlying reconciliation model (<xref rid="btu728-B9" ref-type="bibr">Doyon <italic>et al.,</italic> 2010</xref>) and because it allows transfers going/coming from extinct or unsampled species (<xref rid="btu728-B30" ref-type="bibr">Szöllősi <italic>et al.,</italic> 2013a</xref>). Moreover, the AnGST scoring scheme is solely based on the reconciliation score. ALE differs from TERA in that it relies on a complex underlying probabilistic model; the results of which, in contrast to TERA, are contingent on time-like branch lengths of the species tree.</p>
      <p>TERA’s amalgamation algorithm can be regarded as a generalization of the gene tree reconciliation algorithm of <xref rid="btu728-B9" ref-type="bibr">Doyon <italic>et al.</italic> (2010)</xref>, which iterates over reconciliations by mapping each node of a gene tree to branches of the species tree. In the joint recursion presented in this article, instead of nodes of a gene tree, the clades found in the input sample of gene trees are mapped into branches of the species tree.</p>
      <p>More formally, assume we are given a set of (unrooted) gene trees <inline-formula><mml:math id="MM48"><mml:mi mathvariant="script" class="calligraphy">G</mml:mi></mml:math></inline-formula> on the same leaf set reconstructed from a unique sequence alignment. We denote respectively by <inline-formula><mml:math id="MM49"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM50"><mml:mrow><mml:mi>Π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> the union of all the clades, and the union of all tripartitions in <inline-formula><mml:math id="MM51"><mml:mi mathvariant="script" class="calligraphy">G</mml:mi></mml:math></inline-formula>. For each tripartition <italic>π</italic>, we denote by <inline-formula><mml:math id="MM52"><mml:mrow><mml:mi>π</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> (<inline-formula><mml:math id="MM53"><mml:mrow><mml:mi>π</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM54"><mml:mrow><mml:mi>π</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, respectively) the first (second and third, respectively) element of <italic>π</italic>. If <inline-formula><mml:math id="MM55"><mml:mi mathvariant="script" class="calligraphy">G</mml:mi></mml:math></inline-formula> contains unrooted trees we consider all possible rootings for each tree when computing <inline-formula><mml:math id="MM56"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM57"><mml:mrow><mml:mi>Π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Furthermore, for a given clade <italic>C</italic> of <inline-formula><mml:math id="MM58"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we denote by <inline-formula><mml:math id="MM59"><mml:mrow><mml:mi>Π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> the set of tripartitions <inline-formula><mml:math id="MM60"><mml:mrow><mml:mi>π</mml:mi><mml:mo>∈</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for which <inline-formula><mml:math id="MM61"><mml:mrow><mml:mi>π</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula>. When focusing only on the reconciliation score, the optimization problem consists of computing <inline-formula><mml:math id="MM62"><mml:mrow><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>min</mml:mi><mml:mo>⁡</mml:mo></mml:mrow><mml:mrow><mml:mi>G</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="MM63"><mml:mrow><mml:msub><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the set of gene trees such that <inline-formula><mml:math id="MM64"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for all <inline-formula><mml:math id="MM65"><mml:mrow><mml:mi>G</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. The pseudocode is given in Algorithm 1 in the appendix. Roughly speaking, our algorithm starts by computing the subdivision <italic>S</italic>′ of <italic>S</italic>, and the sets <inline-formula><mml:math id="MM66"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM67"><mml:mrow><mml:mi>Π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Then, it performs a joint traversal of all gene tree clades and species tree branches wherein clades <italic>C</italic> in <inline-formula><mml:math id="MM68"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are considered in order of increasing size, and nodes <italic>x</italic>′ of <italic>S</italic> in order of increasing height. For each pair (<italic>C</italic>, <italic>x</italic>′) the algorithm computes the cost of reconciling clade <italic>C</italic> with <italic>x</italic>′ by testing all possible tripartitions <italic>π</italic> in <inline-formula><mml:math id="MM70"><mml:mrow><mml:mi>Π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Because each non-trivial tripartition <italic>π</italic> can be seen as an internal node of an amalgamated tree, with children <inline-formula><mml:math id="MM71"><mml:mrow><mml:mi>π</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM72"><mml:mrow><mml:mi>π</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, the cost of reconciling a tripartition <italic>π</italic> with <italic>x</italic>′ can be computed according to Algorithm 1 of <xref rid="btu728-B9" ref-type="bibr">Doyon <italic>et al.</italic> (2010)</xref>. We refer the reader to Algorithm 1 of <xref rid="btu728-B9" ref-type="bibr">Doyon <italic>et al.</italic> (2010)</xref> for a better understanding of the pseudocode. The correctness of our approach is proven in the appendix.</p>
      <p>Note that—for ease of writing—the pseudocode of the algorithm does not contain the transfers from the dead, i.e. the transfers going/coming from extinct or unsampled species (<xref rid="btu728-B30" ref-type="bibr">Szöllősi <italic>et al.,</italic> 2013a</xref>). However, Algorithm 1 can be easily modified to accommodate this kind of event by adding to the species tree <italic>S</italic> a sister group of the root clade such that, within this group, duplications and losses are free, speciations are not permitted, and transfers to this new group (formally corresponding to unrepresented speciations) cost zero—similar to what is done in the likelihood framework by <xref rid="btu728-B30" ref-type="bibr">Szöllősi <italic>et al.</italic> (2013a)</xref>.</p>
    </sec>
    <sec>
      <title>2.4 Taking into account the CCP</title>
      <p>As described in the introduction, our goal is to create a species tree aware method for reconstructing gene phylogenies that uses information from both gene sequences and from the reconciliation with a species tree. That is, we wish to construct a method that optimizes a joint sequence-reconciliation score. In order to do this, we must find an efficient manner to incorporate a sequence based cost in addition to the reconciliation cost of <xref rid="btu728-B9" ref-type="bibr">Doyon <italic>et al.</italic> (2010)</xref> in the amalgamation scheme.</p>
      <p>AnGST, the seminal algorithm of <xref rid="btu728-B7" ref-type="bibr">David and Alm (2010)</xref> that introduced the idea of amalgamation, does not distinguish between trees that can be amalgamated. The problem with this approach is that, as the number of input trees—and thus the amount of information given as input—increases, the set of possible trees that can be amalgamated also increases—until all possible tree topologies can be amalgamated. At this point, since all possible tree topologies can be amalgamated, the most parsimonious reconciled gene tree will only depend on the reconciliation score. In practice this introduces the problem that the topology of the amalgamated gene tree may vary significantly when adding only a few trees to the sample of trees (in the worst case only one tree).</p>
      <p>In a probabilistic framework, conditional clade probabilities (CCPs, cf. <xref ref-type="fig" rid="btu728-F1">Fig. 1</xref>) provide an accurate approximation of posterior probabilities for a very large number of tree topologies from a smaller MCMC sample (<xref rid="btu728-B13" ref-type="bibr">Höhna and Drummond, 2012</xref>; <xref rid="btu728-B14" ref-type="bibr">Larget, 2013</xref>; <xref rid="btu728-B31" ref-type="bibr">Szöllősi <italic>et al.,</italic> 2013b</xref>). The <italic>CCP</italic> of a rooted tree <inline-formula><mml:math id="MM73"><mml:mrow><mml:mi>G</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mrow><mml:mtext>am</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> (<xref rid="btu728-B13" ref-type="bibr">Höhna and Drummond, 2012</xref>), denoted by <inline-formula><mml:math id="MM74"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>CCP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, is defined as the product of the conditional probabilities of all partitions in <inline-formula><mml:math id="MM75"><mml:mrow><mml:mi>Π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The <inline-formula><mml:math id="MM76"><mml:mrow><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mtext> </mml:mtext><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>b</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>i</mml:mi><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:math></inline-formula> of the partition of clade <italic>C</italic> according to the tripartition <italic>π</italic> is denoted <inline-formula><mml:math id="MM77"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>CCP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and is approximated by the ratio <inline-formula><mml:math id="MM78"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="script" class="calligraphy">G</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="script" class="calligraphy">G</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where for each clade <inline-formula><mml:math id="MM79"><mml:mrow><mml:mi>C</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and for each tripartition <inline-formula><mml:math id="MM80"><mml:mrow><mml:mi>π</mml:mi><mml:mo>∈</mml:mo><mml:mi>Π</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="script" class="calligraphy">G</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM81"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="script" class="calligraphy">G</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the frequency of <italic>C</italic> and <italic>π</italic> in <inline-formula><mml:math id="MM82"><mml:mi mathvariant="script" class="calligraphy">G</mml:mi></mml:math></inline-formula>.</p>
      <p>Here, in order to construct a parsimony method that optimizes a joint sequence-reconciliation score, we choose to minimize the joint cost
<disp-formula id="btu728-M1"><label>(1)</label><mml:math id="MM83"><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mrow><mml:mtext>joint</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mtext>A</mml:mtext></mml:msub><mml:msub><mml:mi>N</mml:mi><mml:mtext>A</mml:mtext></mml:msub></mml:mrow></mml:math></disp-formula>
over <inline-formula><mml:math id="MM84"><mml:mrow><mml:mi>G</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script" class="calligraphy">G</mml:mi><mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, where the parameter <italic>c</italic><sub><italic>A</italic></sub> weights the contribution of the sequence alignment <italic>N</italic><sub>A</sub> to the cost, defined as
<disp-formula id="btu728-M2"><label>(2)</label><mml:math id="MM85"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mtext>A</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>CCP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>CCP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mtext>MAP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
where <inline-formula><mml:math id="MM86"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>CCP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mtext>MAP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> corresponds to the posterior probability of the gene tree with the highest posterior probability according to the sequence alignment. The logarithm of the CCP provides an additive cost for deviation from the phylogeny preferred by the sequence alignment alone, similar to the additive cost for deviation from species phylogeny provided by the DTL event costs. The parameter <italic>c</italic><sub><italic>A</italic></sub> is analogous to a statistical support threshold, corresponding to a cost <italic>c</italic><sub><italic>A</italic></sub> for each point of log posterior probability difference between the log posterior probability of a given phylogeny and the gene tree with highest posterior probability.</p>
      <p>As illustrated in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu728/-/DC1">Figure 1</ext-link>, <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu728/-/DC1">Algorithm 1 in online appendix</ext-link> is easily modified by adding <inline-formula><mml:math id="MM87"><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo>·</mml:mo><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>CCP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>π</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="MM88"><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mi mathvariant="double-struck">S</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:msub><mml:mi>c</mml:mi><mml:mi mathvariant="double-struck">D</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="MM89"><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mi mathvariant="double-struck">T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> while filling the dynamic programming matrix (on line 15, 17 and 18 of Algorithm 1, respectively). The term <inline-formula><mml:math id="MM90"><mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo>·</mml:mo><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>CCP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mtext>MAP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, corresponding to the gene tree with the highest posterior probability, can be neglected during cost minimization as it simply corresponds to an additive constant.</p>
      <p>Given estimates for the DTL costs (available for example in <xref rid="btu728-B7" ref-type="bibr">David and Alm, 2010</xref>; <xref rid="btu728-B19" ref-type="bibr">Nguyen <italic>et al.</italic>, 2013</xref>), the parameter <italic>c</italic><sub><italic>A</italic></sub> can be estimated in a self-consistent manner.</p>
      <p>However, finding the proper weight between the disagreement with the species tree (increase in DTL events) and the disagreement with the sequence alignment (decrease in <inline-formula><mml:math id="MM91"><mml:mrow><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>CCP</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>) is difficult. Our estimation approach consists of looking for the set of costs that are the most self-consistent, i.e. the ratio of costs that best corresponds to the ratio of events.</p>
      <p>We assume a simple model for how costs determine the number of events: each type of event, i.e. DTL events as well as the disagreement with the alignment counted by <italic>N</italic><sub>A</sub>, are considered to occur independently, such that events with smaller costs are expected to occur more frequently. In particular, the expected amount of disagreement with the species tree due to, respectively duplications, transfers and losses, is proportional to <inline-formula><mml:math id="MM92"><mml:mrow><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mi>δ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mi>τ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM93"><mml:mrow><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mi>λ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, while the expected amount of disagreement with the sequence alignment is propotional to <inline-formula><mml:math id="MM94"><mml:mrow><mml:mi>exp</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The observed amount of disagreement with the species tree is given by the sum of the number of DTL events, i.e. <italic>N</italic><sub><italic>D</italic></sub>, <italic>N</italic><sub><italic>T</italic></sub> and <italic>N</italic><sub><italic>L</italic></sub>, while the observed amount of disagreement with the sequence alignment is given by <italic>N</italic><sub>A</sub>. We then employ an expectation maximization like recursion equating at each step the observed frequencies with the expected frequencies:
<disp-formula id="btu728-M3"><label>(3)</label><mml:math id="MM95"><mml:mrow><mml:msubsup><mml:mi>c</mml:mi><mml:mi>A</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mi>w</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>A</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>D</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>T</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>L</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>A</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
Algorithm 1 is then run until <inline-formula><mml:math id="MM96"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:msubsup><mml:mi>c</mml:mi><mml:mi>A</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mi>w</mml:mi></mml:mrow></mml:msubsup><mml:mo>−</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula> is larger then a threshold <italic>ϵ</italic>.</p>
    </sec>
    <sec>
      <title>2.5 Implementation and validation</title>
      <p>TERA is implemented in C++ and is freely available from <ext-link ext-link-type="uri" xlink:href="http://mbb.univ-montp2.fr/MBB/download_sources/16__TERA">http://mbb.univ-montp2.fr/MBB/download_sources/16__TERA</ext-link>.</p>
      <p>Posterior samples of gene trees, for both simulated and real alignments, were downloaded together with the ‘true’ gene trees used to simulate alignments from the dryad data repository (doi:10.5061/dryad.pv6df) provided by <xref rid="btu728-B31" ref-type="bibr">Szöllősi <italic>et al.</italic> (2013b)</xref>.</p>
      <p>For all the parsimony-based species tree aware methods, including TERA, we used the DTL costs <italic>δ</italic> = 2, <italic>τ</italic> = 3, <italic>λ</italic> = 1 obtained by <xref rid="btu728-B7" ref-type="bibr">David and Alm (2010)</xref> using a criteria based on minimizing the change in ancestral genome sizes on a large biological dataset. We ran TreeFix-DTL with default parameters, JTT/GTR with a gamma distribution as models of evolution, and as a starting tree the PhyML tree. MowgliNNI was run with default parameters, a threshold of 50 for weak edges, and with the PhyML tree—with bootstrap values—as a starting gene tree. AnGST was run with default parameters using the dated species tree on samples of 1000 gene trees, whereas JPrIME-DLTRS was run with JTT with a gamma distribution as model of evolution, 100 000 iterations, a thinning factor of 10 and a time out of 10 h. Finally, we ran TERA with a starting <italic>c</italic><sub><italic>A</italic></sub> of 0.1 and for <inline-formula><mml:math id="MM97"><mml:mi mathvariant="script" class="calligraphy">G</mml:mi></mml:math></inline-formula> samples from 10 up to 10 000 gene trees for each simulated alignment. The gene trees reconstructed by ALE were downloaded from the above mentioned data repository.</p>
      <p>Note that, from a practical perspective, the DTL costs we use are the default parameters for all the parsimonious methods described in the article, and seem to work well for several parts of the Tree of Life. If the user suspects that these values are not suited for the analyses, these parameters should be estimated beforehand, e.g. using the ALE method.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>To test the accuracy of gene trees reconstructed using TERA we chose a dataset based on 1099 homologous gene families present in 36 cyanobacterial genomes. This dataset, published in <xref rid="btu728-B31" ref-type="bibr">Szöllősi <italic>et al.</italic> (2013b)</xref>, was constructed using homologous families from the HOGENOM database (<xref rid="btu728-B20" ref-type="bibr">Penel <italic>et al.,</italic> 2009</xref>) and contains both real and simulated alignments as well as the gene trees used to simulate sequences. The mean number of genes per family in this dataset is 36.66, the largest family has 114 genes and the smallest 21 genes; the mean number of species in which a family is found is 31.49, with a minimum of 4 and a maximum of 36; the mean copy number per genome—counting as zero genomes in which a family is absent—is 1.012, with a minimum of 0.5833 and a maximum of 3.17.</p>
    <p>We chose this dataset, because (i) it contains a diverse set of gene families from a reasonably large and divergent set of species, and (ii) the parametric bootstrap-like simulation procedure used attempts to retain as much of the complexity of the underlying biological dataset as possible (<xref rid="btu728-B31" ref-type="bibr">Szöllősi <italic>et al.,</italic> 2013b</xref>). Furthermore, to emulate the relative complexity of real data compared with available models of sequence evolution, we used a complex model of sequence evolution to simulate sequences—an LG model (<xref rid="btu728-B16" ref-type="bibr">Le and Gascuel, 2008</xref>) with across-site rate variation and invariant sites—and used PhyloBayes (<xref rid="btu728-B15" ref-type="bibr">Lartillot <italic>et al.,</italic> 2009</xref>) with a simpler model—a Poisson model (<xref rid="btu728-B10" ref-type="bibr">Felsenstein, 1981</xref>) with no rate variation—to produce the sample of gene trees used by both TERA and AnGST (see below for more details).</p>
    <sec>
      <title>3.1 Validation on simulated data</title>
      <p>For the simulated alignments, both the ‘true’ gene tree used to generate the sequences and the species tree—along which the gene trees evolved—are known. Consequently, it is possible to directly assess the accuracy of different reconstruction methods in recovering the correct gene tree.</p>
      <p>As shown in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu728/-/DC1">Figure 1</ext-link>a in the <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu728/-/DC1">online appendix</ext-link>, the number of possible amalgamations increases roughly exponentially with increasing sample size in the simulated dataset, but the median reconstruction accuracy achieved by TERA begins to saturate (<ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu728/-/DC1">Figure 1</ext-link>b in the <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu728/-/DC1">online appendix</ext-link>). To compare the accuracy of our method to that of others, we reconstructed gene trees using six different ‘species tree aware’ methods: (i) the TERA algorithm described here, (ii) ALE (<xref rid="btu728-B31" ref-type="bibr">Szöllősi <italic>et al.,</italic> 2013b</xref>), (iii) TreeFix-DTL (Bansal <italic>et al.,</italic> 2014, submitted for publication, <ext-link ext-link-type="uri" xlink:href="http://compbio.mit.edu/treefix-dtl/">http://compbio.mit.edu/treefix-dtl/</ext-link>), (iv) MowgliNNI (<xref rid="btu728-B19" ref-type="bibr">Nguyen <italic>et al.,</italic> 2013</xref>), (v) AnGST (<xref rid="btu728-B7" ref-type="bibr">David and Alm, 2010</xref>) and (vi) JPrIME-DLTRS (<xref rid="btu728-B26" ref-type="bibr">Sjöstrand <italic>et al.,</italic> 2014</xref>) as well as the species tree unaware method, PhyML (<xref rid="btu728-B11" ref-type="bibr">Guindon <italic>et al.,</italic> 2010</xref>).</p>
      <p>In <xref ref-type="fig" rid="btu728-F2">Figure 2</xref>a, we plot the normalized Robinson-Foulds (defined as the Robinson-Foulds distance divided by its maximum possible value, and denoted as n-R-F in the following) distance of the reconstructed gene trees to the true tree. These results show that all of the species tree aware methods achieve better accuracy than the species tree unaware method PhyML, which is to be expected as they are given additional information in the form of the species tree. Among the species tree aware methods, with an input of 10 000 samples TERA’s accuracy is statistically indistinguishable from the more complex maximum likelihood based results from ALE (paired Wilcoxon test <italic>P</italic> &gt; 0.1) and is significantly more accurate than TreeFix-DTL (Bansal <italic>et al.,</italic> 2014, submitted for publication) (paired Wilcoxon test <italic>P</italic> &lt; 10<sup>−</sup><sup>8</sup>) as well as the other species tree aware method MowgliNNI (<xref rid="btu728-B19" ref-type="bibr">Nguyen <italic>et al.,</italic> 2013</xref>). TERA also outperformed jPrIME-DLTRS, although the accuracy of the latter may have been limited by the available run time (recall that a time out of 10 h per each data set was given). For an input of 1000 samples, TERA is less accurate than either TERA or ALE with 10 000 input samples (paired Wilcoxon tests <italic>P</italic> &lt; 10<sup>−</sup><sup>8</sup>), statistically indistinguishable from jPrIME-DLTRS, slightly more accurate then TreeFix-DTL (paired Wilcoxon test <italic>P</italic> = 0.026), and still significantly more accurate than MowgliNNI and AnGST (paired Wilcoxon tests <italic>P</italic> &lt; 10<sup>−</sup><sup>8</sup>).
<fig id="btu728-F2" position="float"><label>Fig. 2.</label><caption><p>(<bold>a)</bold> To compare the accuracy of TERA and other methods we used the simulated data set of Szöllősi <italic>et al.</italic> (2013b). We find that TERA achieves statistically equivalent accuracy to ALE and better accuracy than the other methods, see main text for details. <bold>(b)</bold> To test for over and underfitting of the species tree we examined the 431 gene families with exactly one copy in each of the 36 cyanobacterial species. For each family we plot the difference of the R-F distance of the true tree to the species tree and the R-F distance of the reconstructed gene tree from the species tree. Negative values for the difference indicate overfitting, while in the case of underfitting we expect a positive value</p></caption><graphic xlink:href="btu728f2p"/></fig>
</p>
      <p>Results for AnGST are only shown for sample sizes of 1000 gene trees, due to the very large memory requirement of the AnGST implementation. To investigate the effect of using a joint sequence-reconciliation score we also ran TERA with <italic>c</italic><sub><italic>A</italic></sub> = 0, i.e. emulating AnGST in only optimizing the reconciliation score. We found that on a sample of 1000 trees AnGST was more accurate then TERA with <italic>c</italic><sub><italic>A</italic></sub> = 0 with an n-R-F of, 0.156 and 0.166, respectively. However, using TERA with only 1000 samples, but estimating <italic>c</italic><sub><italic>A</italic></sub>, resulted in a mean n-R-F of 0.146. The average <italic>c</italic><sub><italic>A</italic></sub> estimated by TERA was 0.49 while the average <italic>N</italic><sub><italic>A</italic></sub> was 6.57.</p>
      <p>An important difference of TreeFix-DTL compared with the other methods considered here, is that it does not use information of the time order of speciation events in the species tree (note that AnGST can also run without information on time ordering). Therefore TreeFix-DTL uses less information, which may explain the difference in performance in comparison to TERA on the simulated dataset. Nonetheless, we ran TERA with 10 random time orderings of the species tree and this resulted in statistically identical n-R-F values when using the correct time order of speciations (Wilcoxon rank sum test <italic>P</italic> = 0.6).</p>
      <p>A potential concern regarding methods that optimize a joint reconciliation-sequence score is that we may overfit the species tree. If overfitting of the species tree occurs we expect the reconstructed gene trees to become too similar to the species tree. In the context of the simulated dataset used here, we expect that the reconstructed gene trees will become more similar to the species tree than the true trees used to simulate alignments. To test for such a signal of overfitting, we require a measure of similarity between gene trees and the species tree. The most straightforward solution is to restrict our analysis to gene families that have exactly one copy in each species. In this case, we can simply use the n-R-F distance between the species tree and each of the gene trees as our similarity measure. In <xref ref-type="fig" rid="btu728-F2">Figure 2</xref>b, we show the results for the 431 single copy universal gene families in our simulated dataset. We measure the extent of over and underfitting as the difference in n-R-F distance between the species tree and the reconstructed gene tree and the n-R-F distance between the species tree and the true gene tree. We observe that the species tree unaware method, PhyML, as expected, reconstructs trees that are more distant to the species tree than the true tree. The results for the species tree aware methods are more variable: ALE, based on an explicit probabilistic approach, exhibits a median difference of zero and produces only a few examples of overfitting. TERA, which estimates the <italic>c</italic><sub><italic>A</italic></sub> parameter giving the relative weight of the sequence and reconciliation component of the joint score, also achieves a median difference of zero when 10 000 samples are given as input, but produces a somewhat larger number of slightly overfitted trees. When only 1000 samples are used, both TERA and AnGST underfit the species tree, similar to jPRIME-DLTRS, suggesting that it may be a lack of convergence of the sampling in all cases. TreeFix-DTL, which relies on a fixed support threshold, shows signs of more significant overfitting; while MowgliNNI substantially underfits the species tree, at least with the default parameters used here.</p>
      <p>The runtimes for the methods discussed in this section are given in <xref ref-type="table" rid="btu728-T1">Table 1</xref>. We can see that TERA has the fastest stand-alone runtime. However, if the runtime necessary to generate the input tree(s) are considered, Mowgli is the fastest method, but it is also the least accurate (cf. <xref ref-type="fig" rid="btu728-F2">Fig. 2a</xref>). For an input size of 1000 samples TERA achieves comparable accuracy to TreeFix-DTL, but with a seven fold reduced mean runtime. For an input size of 10 000 samples TERA achieves similar accuracy to ALE and outperforms TreeFix-DTL, but considering the time to generate the required inputs TreeFix-DTL is 1.3 times faster on average.
<table-wrap id="btu728-T1" position="float"><label>Table 1.</label><caption><p>Mean runtimes in seconds for the methods discussed in the main text on a cluster of 2.1 GHz Intel Xeon processors with 24 GB of RAM with maximum runtime limited to 10 h per family</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1">Stand-alone [s]</th><th rowspan="1" colspan="1">Input [s]</th><th rowspan="1" colspan="1"/></tr><tr><th align="center" colspan="4" rowspan="1"><hr/></th></tr><tr><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th colspan="2" align="center" rowspan="1"><bold>PhyloBayes</bold><hr/></th></tr><tr><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1">1000 samples</th><th rowspan="1" colspan="1">10 000 samples</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1"><bold>TERA</bold></td><td align="char" char="." rowspan="1" colspan="1">3.65</td><td align="char" char="." rowspan="1" colspan="1">756.6</td><td align="char" char="." rowspan="1" colspan="1">7566</td></tr><tr><td rowspan="1" colspan="1"><bold>AnGST</bold></td><td align="char" char="." rowspan="1" colspan="1">54.9</td><td align="char" char="." rowspan="1" colspan="1">756.6</td><td align="char" char="." rowspan="1" colspan="1">—</td></tr><tr><td rowspan="1" colspan="1"><bold>ALE</bold></td><td align="char" char="." rowspan="1" colspan="1">159.2</td><td align="char" char="." rowspan="1" colspan="1">756.6</td><td align="char" char="." rowspan="1" colspan="1">7566</td></tr><tr><td colspan="4" rowspan="1"><hr/></td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td colspan="2" rowspan="1"><bold>PhyML</bold></td></tr><tr><td colspan="4" rowspan="1"><hr/></td></tr><tr><td rowspan="1" colspan="1"><bold>MowgliNNI</bold></td><td align="char" char="." rowspan="1" colspan="1">6.3</td><td colspan="2" rowspan="1">182.5</td></tr><tr><td rowspan="1" colspan="1"><bold>TreeFix</bold></td><td align="char" char="." rowspan="1" colspan="1">5718.0</td><td colspan="2" rowspan="1">182.5</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td colspan="2" rowspan="1"><bold>No input tree needed</bold></td></tr><tr><td rowspan="1" colspan="1"><bold>jPrIME</bold></td><td align="char" char="." rowspan="1" colspan="1">32 137.3</td><td colspan="2" rowspan="1">0</td></tr></tbody></table><table-wrap-foot><fn id="btu728-TF1"><p>The time required to compute inputs is given by the runtime of PhyloBayes for 1000 and 10 000 samples and for the time required for PhyML to compute an ML tree with SH branch supports. Stand-alone runtimes are given for 10 000 samples for TERA and ALE and 1000 samples for AnGST.</p></fn></table-wrap-foot></table-wrap></p>
    </sec>
    <sec sec-type="results">
      <title>3.2 Results on real data</title>
      <p>In order to test TERA on biological data, we again used the dataset published in <xref rid="btu728-B31" ref-type="bibr">Szöllősi <italic>et al.</italic> (2013b)</xref>, but focusing on real alignments. As inputs to TERA we used: (i) the tree samples obtained from real alignments and (ii) the ML species tree unaware gene trees obtained using PhyML from the same alignments. Similar to the results of ALE (<xref rid="btu728-B31" ref-type="bibr">Szöllősi <italic>et al.,</italic> 2013b</xref>), we find that the number of transfer and loss events (but not duplication events) in most parsimonious reconciled gene trees is substantially lower than those found in the most parsimonious reconciliations of PhyML trees: the mean and median number of transfers per family was 3.914 and 3 compared with 10.38 and 9, respectively; the mean and median number of losses per family was 5.088 and 4 compared with 7.542 and 7, respectively, while the mean and median number of duplications per family was 1.071 and 0 compared with 1.042 and 0, respectively.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>We have presented a detailed description of the TERA algorithm, a parsimony-based species tree aware method of gene tree reconstruction. We demonstrate that TERA reconstructs gene trees with nearly identical accuracy as the more complex ML based ALE method and, at least on the simulated datasets considered here, outperforms the other parsimony based species tree aware methods.</p>
    <p>Examining a subset of single copy universal gene families we show that TERA does not overfit or underfit the species tree. This result lends credibility to TERA’s results on biological data, whereby two thirds of apparent gene transfers in gene trees reconstructed without taking into consideration the species tree are not recovered given knowledge of the species phylogeny.</p>
    <p>Although parsimony based methods are fundamentally limited in some aspects compared with model based probabilistic methods, in the case of species tree aware gene tree reconstruction our results indicate that parsimony based methods can closely approach their accuracy. A further advantage of TERA compared with the corresponding probabilistic method ALE is that it is faster (if only up to a constant factor), does not require explicit time-like branch lengths that are difficult to estimate, and due to its relative simplicity, in particular the lack of numerical integration, is more robust in practice. Compared with parsimony based methods that require prior assumptions about statistical support, TERA is distinguished by its ability to estimate a statistical support threshold from its input. In contrast to the methods considered here it does require more elaborate upstream analysis, taking as its input a sample of trees from e.g. an MCMC-based tree inference methods, while in contrast MowgliNNI requires a single tree with branch supports, and TreeFix-DTL a multiple sequence alignment.</p>
    <p>Finally, while we have shown that it is possible to estimate the <italic>c</italic><sub><italic>A</italic></sub> parameter, we have been less successful in estimating all four costs (<inline-formula><mml:math id="MM98"><mml:mrow><mml:mi>δ</mml:mi><mml:mo>,</mml:mo><mml:mi>τ</mml:mi><mml:mo>,</mml:mo><mml:mi>λ</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mtext>A</mml:mtext></mml:msub></mml:mrow></mml:math></inline-formula>) simultaneously, due to the tendency of the cost estimates to diverge toward a very low transfer cost, and a correspondingly large number of transfers. We expect that relaxing the, in general, unrealistic assumption of independence between events could ameliorate this problem.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="PMC_1" content-type="local-data">
      <caption>
        <title>Supplementary Data</title>
      </caption>
      <media mimetype="text" mime-subtype="html" xlink:href="supp_31_6_841__index.html"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="pdf" xlink:href="supp_btu728_appendix.pdf"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgements</title>
    <p>The authors like to thank Eric Tannier, Bastien Boussau and Vincent Daubin for the constructive discussions.</p>
  </ack>
  <sec>
    <title>Funding</title>
    <p>C.S. and E.J. were supported by the <funding-source>French <italic>Agence Nationale de la Recherche Investissements d’avenir/ioinformatique</italic></funding-source> (<award-id>ANR-10-BINF-01-02</award-id>, <italic>Ancestrome</italic>). G.J.Sz. was supported by the <funding-source>Marie Curie</funding-source>
<award-id>CIG 618438</award-id> ‘Genestory’ and the <funding-source>Albert Szent-Györgyi Call-Home Researcher Scholarship</funding-source>
<award-id>A1-SZGYA-FOK-13-0005</award-id> supported by the <funding-source>European Union and the State of Hungary</funding-source>, co-financed by the European Social Fund in the framework of TÁMOP 4.2.4. <award-id>A/1-11-1-2012-0001</award-id>
<funding-source>‘National Excellence Program’</funding-source>. This publication is contribution no. <award-id>2014-178</award-id> of the Institut des Sciences de l’Evolution de Montpellier [<award-id>ISEM, UMR 5554</award-id>].</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </sec>
  <ref-list>
    <title>References</title>
    <ref id="btu728-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Akerborg</surname><given-names>O.</given-names></name><etal/></person-group> (<year>2009</year>). <article-title>Simultaneous Bayesian gene tree reconstruction and reconciliation analysis</article-title>. <source>Proc. Nat. Acad. Sci. USA</source><italic>,</italic>
<volume>106</volume>, <fpage>5714</fpage>–<lpage>5719</lpage>.<pub-id pub-id-type="pmid">19299507</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Arvestad</surname><given-names>L.</given-names></name></person-group> (<year>2003</year>). <article-title>Bayesian gene/species tree reconciliation and orthology analysis using MCMC</article-title>. <source>Bioinformatics</source><italic>,</italic>
<volume>19</volume>, <fpage>7i</fpage>–<lpage>15i</lpage>.</mixed-citation>
    </ref>
    <ref id="btu728-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bansal</surname><given-names>M.S.</given-names></name><etal/></person-group> (<year>2012</year>). <article-title>Efficient algorithms for the reconciliation problem with gene duplication, horizontal transfer and loss</article-title>. <source>Bioinformatics</source><italic>,</italic>
<volume>28</volume>, <fpage>i283</fpage>–<lpage>i291</lpage>.<pub-id pub-id-type="pmid">22689773</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Boussau</surname><given-names>B.</given-names></name><etal/></person-group> (<year>2013</year>). <article-title>Genome-scale coestimation of species and gene trees</article-title>. <source>Genome Res</source><italic>.</italic>
<volume>23</volume>, <fpage>323</fpage>–<lpage>330</lpage>.<pub-id pub-id-type="pmid">23132911</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Conow</surname><given-names>C.</given-names></name><etal/></person-group> (<year>2010</year>). <article-title>Jane: a new tool for the cophylogeny reconstruction problem</article-title>. <source>Algorithms Mol. Biol</source><italic>.</italic>
<volume>5</volume>, <fpage>16</fpage>.<pub-id pub-id-type="pmid">20181081</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>David</surname><given-names>L.A.</given-names></name><name><surname>Alm</surname><given-names>E.J.</given-names></name></person-group> (<year>2010</year>). <article-title>Rapid evolutionary innovation during an Archaean genetic expansion</article-title>. <source>Nature</source><italic>,</italic>
<volume>469</volume>, <fpage>93</fpage>–<lpage>96</lpage>.<pub-id pub-id-type="pmid">21170026</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Doyon</surname><given-names>J.</given-names></name><etal/></person-group> (<year>2011</year>). <article-title>Models, algorithms and programs for phylogeny reconciliation</article-title>. <source>Brief Bioinform</source><italic>.</italic>
<volume>12</volume>, <fpage>392</fpage>–<lpage>400</lpage>.<pub-id pub-id-type="pmid">21949266</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B9">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Doyon</surname><given-names>J.-P.</given-names></name><etal/></person-group> (<year>2010</year>). <article-title>An efficient algorithm for gene/species trees parsimonious reconciliation with losses, duplications and transfers</article-title>. In: <source>Proceedings of the 2010 International Conference on Comparative Genomics, RECOMB-CG’10</source>, <publisher-name>Springer-Verlag</publisher-name>, <publisher-loc>Berlin, Heidelberg</publisher-loc>, pp. <fpage>93</fpage>–<lpage>108</lpage>.</mixed-citation>
    </ref>
    <ref id="btu728-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Felsenstein</surname><given-names>J.</given-names></name></person-group> (<year>1981</year>). <article-title>Evolutionary trees from DNA sequences: a maximum likelihood approach</article-title>. <source>J. Mol. Evol</source><italic>.</italic>
<volume>17</volume>, <fpage>368</fpage>–<lpage>376</lpage>.<pub-id pub-id-type="pmid">7288891</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Guindon</surname><given-names>S.</given-names></name><etal/></person-group> (<year>2010</year>). <article-title>New algorithms and methods to estimate maximum-likelihood phylogenies: assessing the performance of PhyML 3.0</article-title>. <source>Syst. Biol</source><italic>.</italic>
<volume>59</volume>, <fpage>307</fpage>–<lpage>321</lpage>.<pub-id pub-id-type="pmid">20525638</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B12">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Hallett</surname><given-names>M.T.</given-names></name><name><surname>Lagergren</surname><given-names>J.</given-names></name></person-group> (<year>2001</year>). <article-title>Efficient algorithms for lateral gene transfer problems</article-title>. In: <source>Proceedings of the Fifth Annual International Conference on Computational Biology</source><italic>,</italic>
<publisher-name>ACM</publisher-name>, <publisher-loc>New York, NY</publisher-loc>, pp. <fpage>149</fpage>–<lpage>156</lpage>.</mixed-citation>
    </ref>
    <ref id="btu728-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Höhna</surname><given-names>S.</given-names></name><name><surname>Drummond</surname><given-names>A.</given-names></name></person-group> (<year>2012</year>). <article-title>Guided tree topology proposals for Bayesian phylogenetic inference</article-title>. <source>Syst. Biol</source><italic>.</italic>
<volume>61</volume>, <fpage>1</fpage>–<lpage>11</lpage>.<pub-id pub-id-type="pmid">21828081</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Larget</surname><given-names>B.</given-names></name></person-group> (<year>2013</year>). <article-title>The estimation of tree posterior probabilities using conditional clade probability distributions</article-title>. <source>Syst. Biol</source><italic>.</italic>
<volume>62</volume>, <fpage>501</fpage>–<lpage>511</lpage>.<pub-id pub-id-type="pmid">23479066</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lartillot</surname><given-names>N.</given-names></name><etal/></person-group><italic>.</italic> (<year>2009</year>). <article-title>PhyloBayes 3: a Bayesian software package for phylogenetic reconstruction and molecular dating</article-title>. <source>Bioinformatics</source><italic>,</italic>
<volume>25</volume>, <fpage>2286</fpage>.<pub-id pub-id-type="pmid">19535536</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Le</surname><given-names>S.Q.</given-names></name><name><surname>Gascuel</surname><given-names>O.</given-names></name></person-group> (<year>2008</year>). <article-title>An improved general amino acid replacement matrix</article-title>. <source>Mol. Biol. Evol</source><italic>.</italic>
<volume>25</volume>, <fpage>1307</fpage>–<lpage>1320</lpage>.<pub-id pub-id-type="pmid">18367465</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Maddison</surname><given-names>W.P.</given-names></name></person-group> (<year>1997</year>). <article-title>Gene trees in species trees</article-title>. <source>Syst. Biol</source><italic>.</italic>
<volume>46</volume>, <fpage>523</fpage>–<lpage>536</lpage>.</mixed-citation>
    </ref>
    <ref id="btu728-B18">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Nguyen</surname><given-names>T.</given-names></name><etal/></person-group> (<year>2012</year>). <article-title>Accounting for gene tree uncertainties improves gene trees and reconciliation inference</article-title>. In: <person-group person-group-type="editor"><name><surname>Raphael</surname><given-names>B.</given-names></name><name><surname>Tang</surname><given-names>J</given-names></name></person-group> (eds.) <source>Algorithms in Bioinformatics, volume 7534 of Lecture Notes in Computer Science</source>. <publisher-name>Springer</publisher-name>, <publisher-loc>Berlin Heidelberg</publisher-loc>, pp. <fpage>123</fpage>–<lpage>134</lpage>.</mixed-citation>
    </ref>
    <ref id="btu728-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Nguyen</surname><given-names>T.H.</given-names></name><etal/></person-group> (<year>2013</year>). <article-title>Reconciliation and local gene tree rearrangement can be of mutual profit</article-title>. <source>Algorithms Mol Biol</source><italic>,</italic>
<volume>8</volume>, <fpage>12</fpage>.<pub-id pub-id-type="pmid">23566548</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Penel</surname><given-names>S.</given-names></name><etal/></person-group> (<year>2009</year>). <article-title>Databases of homologous gene families for comparative genomics</article-title>. <source>BMC Bioinformatics</source><italic>,</italic>
<volume>6</volume>, <fpage>S3</fpage>.<pub-id pub-id-type="pmid">19534752</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rannala</surname><given-names>B.</given-names></name><name><surname>Yang</surname><given-names>Z.</given-names></name></person-group> (<year>2003</year>). <article-title>Bayes estimation of species divergence times and ancestral population sizes using DNA sequences from multiple loci</article-title>. <source>Genetics</source><italic>,</italic>
<volume>164</volume>, <fpage>1645</fpage>–<lpage>1656</lpage>.<pub-id pub-id-type="pmid">12930768</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rasmussen</surname><given-names>M.D.</given-names></name><name><surname>Kellis</surname><given-names>M.</given-names></name></person-group> (<year>2007</year>). <article-title>Accurate gene-tree reconstruction by learning gene- and species-specific substitution rates across multiple complete genomes</article-title>. <source>Genome Res</source><italic>.</italic>
<volume>17</volume>, <fpage>1932</fpage>–<lpage>1942</lpage>.<pub-id pub-id-type="pmid">17989260</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rasmussen</surname><given-names>M.D.</given-names></name><name><surname>Kellis</surname><given-names>M.</given-names></name></person-group> (<year>2010</year>). <article-title>A Bayesian Approach for Fast and Accurate Gene Tree Reconstruction</article-title>. <source>Mol. Biol. Evol</source><italic>.</italic>
<volume>28</volume>, <fpage>273</fpage>–<lpage>290</lpage>.<pub-id pub-id-type="pmid">20660489</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rasmussen</surname><given-names>M.D.</given-names></name><name><surname>Kellis</surname><given-names>M.</given-names></name></person-group> (<year>2012</year>). <article-title>Unified modeling of gene duplication, loss, and coalescence using a locus tree</article-title>. <source>Genome Res</source><italic>.</italic>
<volume>22</volume>, <fpage>755</fpage>–<lpage>765</lpage>.<pub-id pub-id-type="pmid">22271778</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ronquist</surname><given-names>F.</given-names></name><etal/></person-group> (<year>2012</year>). <article-title>MrBayes 3.2: efficient Bayesian phylogenetic inference and model choice across a large model space</article-title>. <source>Syst. Biol</source><italic>.</italic>
<volume>61</volume>, <fpage>539</fpage>–<lpage>542</lpage>.<pub-id pub-id-type="pmid">22357727</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sjöstrand</surname><given-names>J.</given-names></name><etal/></person-group> (<year>2014</year>). <article-title>A bayesian method for analyzing lateral gene transfer</article-title>. <source>Syst. Biol</source><italic>.</italic>
<volume>63</volume>, <fpage>409</fpage>–<lpage>420</lpage>.<pub-id pub-id-type="pmid">24562812</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Suchard</surname><given-names>M.A.</given-names></name></person-group> (<year>2005</year>). <article-title>Stochastic models for horizontal gene transfer: taking a random walk through tree space</article-title>. <source>Genetics</source><italic>,</italic>
<volume>170</volume>, <fpage>419</fpage>–<lpage>431</lpage>.<pub-id pub-id-type="pmid">15781714</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Szöllősi</surname><given-names>G.J.</given-names></name><name><surname>Daubin</surname><given-names>V.</given-names></name></person-group> (<year>2012</year>). <article-title>Modeling gene family evolution and reconciling phylogenetic discord</article-title>. <source>Methods Mol. Biol</source><italic>.</italic>
<volume>856</volume>, <fpage>29</fpage>–<lpage>51</lpage>.<pub-id pub-id-type="pmid">22399454</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Szöllősi</surname><given-names>G.J.</given-names></name><etal/></person-group> (<year>2012</year>). <article-title>Phylogenetic modeling of lateral gene transfer reconstructs the pattern and relative timing of speciations</article-title>. <source>Proc. Nat. Acad. Sci. USA</source><italic>,</italic>
<volume>109</volume>, <fpage>17513</fpage>–<lpage>17518</lpage>.<pub-id pub-id-type="pmid">23043116</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Szöllősi</surname><given-names>G.J.</given-names></name><etal/></person-group> (<year>2013a</year>). <article-title>lateral gene transfer from the dead</article-title>. <source>Syst. Biol.</source><italic>,</italic>
<volume>62</volume>, <fpage>386</fpage>–<lpage>397</lpage>.<pub-id pub-id-type="pmid">23355531</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Szöllősi</surname><given-names>G.J.</given-names></name><etal/></person-group> (<year>2013b</year>). <article-title>Efficient exploration of the space of reconciled gene trees</article-title>. <source>Syst. Biol</source><italic>.</italic>
<volume>62</volume>, <fpage>901</fpage>–<lpage>912</lpage>.<pub-id pub-id-type="pmid">23925510</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Szöllősi</surname><given-names>G.</given-names></name><etal/></person-group> (<year>2014</year>). <article-title>The inference of gene trees with species trees</article-title>. <source>Syst. Biol.</source>
<volume>64</volume>, <fpage>e42</fpage>–<lpage>e62</lpage>.<pub-id pub-id-type="pmid">25070970</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Than</surname><given-names>C.</given-names></name><name><surname>Nakhleh</surname><given-names>L.</given-names></name></person-group> (<year>2009</year>). <article-title>Species tree inference by minimizing deep coalescences</article-title>. <source>PLoS Comput. Biol</source><italic>.</italic>
<volume>5</volume>, <fpage>e1000501</fpage>.<pub-id pub-id-type="pmid">19749978</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B34">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Tofigh</surname><given-names>A.</given-names></name></person-group> (<year>2009</year>). <article-title>Using trees to capture reticulate evolution, lateral gene transfers and cancer progression</article-title><comment><italic>.</italic> PhD Thesis, KTH Royal Institute of Technology, Sweden</comment>.</mixed-citation>
    </ref>
    <ref id="btu728-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Tofigh</surname><given-names>A.</given-names></name><etal/></person-group><italic>.</italic> (<year>2011</year>). <article-title>Simultaneous identification of duplications and lateral gene transfers</article-title>. <source>IEEE/ACM Trans. Comput. Biol. Bioinform</source><italic>.</italic>
<volume>8</volume>, <fpage>517</fpage>–<lpage>535</lpage>.<pub-id pub-id-type="pmid">21233529</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wu</surname><given-names>Y.-C.</given-names></name><etal/></person-group> (<year>2013</year>). <article-title>TreeFix: statistically informed gene tree error correction using species trees</article-title>. <source>Syst. Biol</source><italic>.</italic>
<volume>62</volume>, <fpage>110</fpage>–<lpage>120</lpage>.<pub-id pub-id-type="pmid">22949484</pub-id></mixed-citation>
    </ref>
    <ref id="btu728-B37">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wu</surname><given-names>Y.-C.</given-names></name><etal/></person-group> (<year>2014</year>). <article-title>Most parsimonious reconciliation in the presence of gene duplication, loss, and deep coalescence using labeled coalescent trees</article-title>. <source>Genome Res</source><italic>.</italic>
<volume>24</volume>, <fpage>475</fpage>–<lpage>486</lpage>.<pub-id pub-id-type="pmid">24310000</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
