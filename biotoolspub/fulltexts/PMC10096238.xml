<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d3 20150301//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 39.96?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id>
    <journal-id journal-id-type="iso-abbrev">PLoS Comput Biol</journal-id>
    <journal-id journal-id-type="publisher-id">plos</journal-id>
    <journal-title-group>
      <journal-title>PLOS Computational Biology</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1553-734X</issn>
    <issn pub-type="epub">1553-7358</issn>
    <publisher>
      <publisher-name>Public Library of Science</publisher-name>
      <publisher-loc>San Francisco, CA USA</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10096238</article-id>
    <article-id pub-id-type="pmid">37000853</article-id>
    <article-id pub-id-type="doi">10.1371/journal.pcbi.1011032</article-id>
    <article-id pub-id-type="publisher-id">PCOMPBIOL-D-22-00949</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Genetics</subject>
          <subj-group>
            <subject>Genomics</subject>
            <subj-group>
              <subject>Human Genomics</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Genetics</subject>
          <subj-group>
            <subject>Genomics</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Genetics</subject>
          <subj-group>
            <subject>Heredity</subject>
            <subj-group>
              <subject>Homozygosity</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Animal Studies</subject>
          <subj-group>
            <subject>Experimental Organism Systems</subject>
            <subj-group>
              <subject>Model Organisms</subject>
              <subj-group>
                <subject>Arabidopsis Thaliana</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Model Organisms</subject>
          <subj-group>
            <subject>Arabidopsis Thaliana</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Organisms</subject>
          <subj-group>
            <subject>Eukaryota</subject>
            <subj-group>
              <subject>Plants</subject>
              <subj-group>
                <subject>Brassica</subject>
                <subj-group>
                  <subject>Arabidopsis Thaliana</subject>
                </subj-group>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Animal Studies</subject>
          <subj-group>
            <subject>Experimental Organism Systems</subject>
            <subj-group>
              <subject>Plant and Algal Models</subject>
              <subj-group>
                <subject>Arabidopsis Thaliana</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Database and Informatics Methods</subject>
          <subj-group>
            <subject>Bioinformatics</subject>
            <subj-group>
              <subject>Sequence Analysis</subject>
              <subj-group>
                <subject>Sequence Alignment</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Molecular Biology</subject>
          <subj-group>
            <subject>Molecular Biology Techniques</subject>
            <subj-group>
              <subject>Sequencing Techniques</subject>
              <subj-group>
                <subject>Genome Sequencing</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Molecular Biology Techniques</subject>
          <subj-group>
            <subject>Sequencing Techniques</subject>
            <subj-group>
              <subject>Genome Sequencing</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Organisms</subject>
          <subj-group>
            <subject>Eukaryota</subject>
            <subj-group>
              <subject>Animals</subject>
              <subj-group>
                <subject>Invertebrates</subject>
                <subj-group>
                  <subject>Cnidaria</subject>
                  <subj-group>
                    <subject>Jellyfish</subject>
                  </subj-group>
                </subj-group>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Zoology</subject>
          <subj-group>
            <subject>Animals</subject>
            <subj-group>
              <subject>Invertebrates</subject>
              <subj-group>
                <subject>Cnidaria</subject>
                <subj-group>
                  <subject>Jellyfish</subject>
                </subj-group>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Computer and Information Sciences</subject>
        <subj-group>
          <subject>Software Engineering</subject>
          <subj-group>
            <subject>Computer Software</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Engineering and Technology</subject>
        <subj-group>
          <subject>Software Engineering</subject>
          <subj-group>
            <subject>Computer Software</subject>
          </subj-group>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>JASPER: A fast genome polishing tool that improves accuracy of genome assemblies</article-title>
      <alt-title alt-title-type="running-head">JASPER: A fast genome polishing tool</alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0002-6664-0145</contrib-id>
        <name>
          <surname>Guo</surname>
          <given-names>Alina</given-names>
        </name>
        <role content-type="http://credit.niso.org/contributor-roles/conceptualization/">Conceptualization</role>
        <role content-type="http://credit.niso.org/contributor-roles/formal-analysis/">Formal analysis</role>
        <role content-type="http://credit.niso.org/contributor-roles/investigation/">Investigation</role>
        <role content-type="http://credit.niso.org/contributor-roles/software/">Software</role>
        <role content-type="http://credit.niso.org/contributor-roles/supervision/">Supervision</role>
        <role content-type="http://credit.niso.org/contributor-roles/validation/">Validation</role>
        <role content-type="http://credit.niso.org/contributor-roles/visualization/">Visualization</role>
        <role content-type="http://credit.niso.org/contributor-roles/writing-review-editing/">Writing – review &amp; editing</role>
        <xref rid="aff001" ref-type="aff">
          <sup>1</sup>
        </xref>
        <xref rid="aff002" ref-type="aff">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0002-8859-7432</contrib-id>
        <name>
          <surname>Salzberg</surname>
          <given-names>Steven L.</given-names>
        </name>
        <role content-type="http://credit.niso.org/contributor-roles/conceptualization/">Conceptualization</role>
        <role content-type="http://credit.niso.org/contributor-roles/funding-acquisition/">Funding acquisition</role>
        <role content-type="http://credit.niso.org/contributor-roles/project-administration/">Project administration</role>
        <role content-type="http://credit.niso.org/contributor-roles/writing-review-editing/">Writing – review &amp; editing</role>
        <xref rid="aff001" ref-type="aff">
          <sup>1</sup>
        </xref>
        <xref rid="aff003" ref-type="aff">
          <sup>3</sup>
        </xref>
        <xref rid="aff004" ref-type="aff">
          <sup>4</sup>
        </xref>
        <xref rid="aff005" ref-type="aff">
          <sup>5</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0001-5091-3092</contrib-id>
        <name>
          <surname>Zimin</surname>
          <given-names>Aleksey V.</given-names>
        </name>
        <role content-type="http://credit.niso.org/contributor-roles/conceptualization/">Conceptualization</role>
        <role content-type="http://credit.niso.org/contributor-roles/data-curation/">Data curation</role>
        <role content-type="http://credit.niso.org/contributor-roles/formal-analysis/">Formal analysis</role>
        <role content-type="http://credit.niso.org/contributor-roles/investigation/">Investigation</role>
        <role content-type="http://credit.niso.org/contributor-roles/software/">Software</role>
        <role content-type="http://credit.niso.org/contributor-roles/supervision/">Supervision</role>
        <role content-type="http://credit.niso.org/contributor-roles/validation/">Validation</role>
        <role content-type="http://credit.niso.org/contributor-roles/visualization/">Visualization</role>
        <role content-type="http://credit.niso.org/contributor-roles/writing-original-draft/">Writing – original draft</role>
        <role content-type="http://credit.niso.org/contributor-roles/writing-review-editing/">Writing – review &amp; editing</role>
        <xref rid="aff001" ref-type="aff">
          <sup>1</sup>
        </xref>
        <xref rid="aff003" ref-type="aff">
          <sup>3</sup>
        </xref>
        <xref rid="cor001" ref-type="corresp">*</xref>
      </contrib>
    </contrib-group>
    <aff id="aff001">
      <label>1</label>
      <addr-line>Department of Biomedical Engineering, Johns Hopkins University, Baltimore, Maryland, United States of America</addr-line>
    </aff>
    <aff id="aff002">
      <label>2</label>
      <addr-line>Department of Applied Mathematics and Statistics, Johns Hopkins University, Baltimore, Maryland, United States of America</addr-line>
    </aff>
    <aff id="aff003">
      <label>3</label>
      <addr-line>Center for Computational Biology, Johns Hopkins University, Baltimore, Maryland, United States of America</addr-line>
    </aff>
    <aff id="aff004">
      <label>4</label>
      <addr-line>Department of Computer Science, Johns Hopkins University, Baltimore, Maryland, United States of America</addr-line>
    </aff>
    <aff id="aff005">
      <label>5</label>
      <addr-line>Department of Biostatistics, Johns Hopkins University, Baltimore, Maryland, United States of America</addr-line>
    </aff>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Segata</surname>
          <given-names>Nicola</given-names>
        </name>
        <role>Editor</role>
        <xref rid="edit1" ref-type="aff"/>
      </contrib>
    </contrib-group>
    <aff id="edit1">
      <addr-line>University of Trento, ITALY</addr-line>
    </aff>
    <author-notes>
      <fn fn-type="COI-statement" id="coi001">
        <p>Authors declare no competing interests.</p>
      </fn>
      <corresp id="cor001">* E-mail: <email>alekseyz@jhu.edu</email></corresp>
    </author-notes>
    <pub-date pub-type="epub">
      <day>31</day>
      <month>3</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="collection">
      <month>3</month>
      <year>2023</year>
    </pub-date>
    <volume>19</volume>
    <issue>3</issue>
    <elocation-id>e1011032</elocation-id>
    <history>
      <date date-type="received">
        <day>22</day>
        <month>6</month>
        <year>2022</year>
      </date>
      <date date-type="accepted">
        <day>16</day>
        <month>3</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2023 Guo et al</copyright-statement>
      <copyright-year>2023</copyright-year>
      <copyright-holder>Guo et al</copyright-holder>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
      </license>
    </permissions>
    <self-uri content-type="pdf" xlink:href="pcbi.1011032.pdf"/>
    <abstract>
      <p>Advances in long-read sequencing technologies have dramatically improved the contiguity and completeness of genome assemblies. Using the latest nanopore-based sequencers, we can generate enough data for the assembly of a human genome from a single flow cell. With the long-read data from these sequences, we can now routinely produce de novo genome assemblies in which half or more of a genome is contained in megabase-scale contigs. Assemblies produced from nanopore data alone, though, have relatively high error rates and can benefit from a process called polishing, in which more-accurate reads are used to correct errors in the consensus sequence. In this manuscript, we present a novel tool for genome polishing called JASPER (Jellyfish-based Assembly Sequence Polisher for Error Reduction). In contrast to many other polishing methods, JASPER gains efficiency by avoiding the alignment of reads to the assembly. Instead, JASPER uses a database of k-mer counts that it creates from the reads to detect and correct errors in the consensus. Our experiments demonstrate that JASPER is faster than alignment-based polishers, and both faster and more accurate than other k-mer based polishing methods. We also introduce the idea of using a polishing tool to create population-specific reference genomes, and illustrate this idea using sequence data from multiple individuals from Tokyo, Japan.</p>
    </abstract>
    <funding-group>
      <award-group id="award001">
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100005825</institution-id>
            <institution>National Institute of Food and Agriculture</institution>
          </institution-wrap>
        </funding-source>
        <award-id>2018-67015-28199</award-id>
        <principal-award-recipient>
          <contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0001-5091-3092</contrib-id>
          <name>
            <surname>Zimin</surname>
            <given-names>Aleksey V.</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
      <award-group id="award002">
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100000154</institution-id>
            <institution>Division of Integrative Organismal Systems</institution>
          </institution-wrap>
        </funding-source>
        <award-id>IOS-1744309</award-id>
        <principal-award-recipient>
          <contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0002-8859-7432</contrib-id>
          <name>
            <surname>Salzberg</surname>
            <given-names>Steven L.</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
      <award-group id="award003">
        <funding-source>
          <institution>National Institutes of Health</institution>
        </funding-source>
        <award-id>R01-HG006677</award-id>
        <principal-award-recipient>
          <contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0002-8859-7432</contrib-id>
          <name>
            <surname>Salzberg</surname>
            <given-names>Steven L.</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
      <award-group id="award004">
        <funding-source>
          <institution>National Institutes of Health</institution>
        </funding-source>
        <award-id>R35-GM130151</award-id>
        <principal-award-recipient>
          <contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0002-8859-7432</contrib-id>
          <name>
            <surname>Salzberg</surname>
            <given-names>Steven L.</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
      <funding-statement>This work was supported in part by the USDA National Institute of Food and Agriculture (<ext-link xlink:href="https://nifa.usda.gov/" ext-link-type="uri">https://nifa.usda.gov/</ext-link>), under grant 2018-67015-28199 awarded to AVZ, by National Science Foundation (<ext-link xlink:href="https://www.nsf.gov/" ext-link-type="uri">https://www.nsf.gov/</ext-link>) grant IOS-1744309 awarded to SLS and AVZ, and by National Institutes of Health (<ext-link xlink:href="https://www.nih.gov/" ext-link-type="uri">https://www.nih.gov/</ext-link>) grants R01-HG006677 and R35-GM130151 awarded to SLS. The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement>
    </funding-group>
    <counts>
      <fig-count count="4"/>
      <table-count count="3"/>
      <page-count count="11"/>
    </counts>
    <custom-meta-group>
      <custom-meta>
        <meta-name>PLOS Publication Stage</meta-name>
        <meta-value>vor-update-to-uncorrected-proof</meta-value>
      </custom-meta>
      <custom-meta>
        <meta-name>Publication Update</meta-name>
        <meta-value>2023-04-12</meta-value>
      </custom-meta>
      <custom-meta id="data-availability">
        <meta-name>Data Availability</meta-name>
        <meta-value>The Illumina and PacBio data for A. thaliana are available from NCBI SRA under PRJNA896160. The human CHM13 data is available from <ext-link xlink:href="https://github.com/marbl/CHM13" ext-link-type="uri">https://github.com/marbl/CHM13</ext-link> and from NCBI as Genbank accession GCA_009914755.4. The CHM13 assembly with Genbank accession GCA_001015355 was polished with Illumina reads from NCBI SRA accessions SRR1997411 and SRR3189741. The human population data is available from the 1000 Genomes Project website (<ext-link xlink:href="http://www.internationalgenome.org" ext-link-type="uri">http://www.internationalgenome.org</ext-link>). We list all commands and parameters used in running the polishers and evaluations in <xref rid="pcbi.1011032.s001" ref-type="supplementary-material">S1 Text</xref>.</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
  <notes>
    <title>Data Availability</title>
    <p>The Illumina and PacBio data for A. thaliana are available from NCBI SRA under PRJNA896160. The human CHM13 data is available from <ext-link xlink:href="https://github.com/marbl/CHM13" ext-link-type="uri">https://github.com/marbl/CHM13</ext-link> and from NCBI as Genbank accession GCA_009914755.4. The CHM13 assembly with Genbank accession GCA_001015355 was polished with Illumina reads from NCBI SRA accessions SRR1997411 and SRR3189741. The human population data is available from the 1000 Genomes Project website (<ext-link xlink:href="http://www.internationalgenome.org" ext-link-type="uri">http://www.internationalgenome.org</ext-link>). We list all commands and parameters used in running the polishers and evaluations in <xref rid="pcbi.1011032.s001" ref-type="supplementary-material">S1 Text</xref>.</p>
  </notes>
</front>
<body>
  <sec sec-type="intro" id="sec001">
    <title>Introduction</title>
    <p>As a result of continual increases in sequencing efficiency and much longer read lengths, highly contiguous genome assemblies are now a staple of genomic research. In particular, instruments from Oxford Nanopore Technologies have enabled many scientists to sequence and assemble genomes from many species without the need for a significant investment in sequencing equipment. A single PromethION flowcell, for example, now yields enough data to produce a highly contiguous assembly of a human genome. However, because the per-base accuracy of ONT reads is still relatively low, creating an accurate final sequence (the “consensus”) remains a challenge. One way to improve the consensus quality is to “polish” the assembly using accurate reads from the same DNA source. These more-accurate reads can either be short (100-250bp) Illumina reads, or more expensive but longer (10Kb and above) PacBio HiFi reads. A variety of polishing tools have been developed and published for this purpose, including Pilon [<xref rid="pcbi.1011032.ref001" ref-type="bibr">1</xref>], Racon [<xref rid="pcbi.1011032.ref002" ref-type="bibr">2</xref>], POLCA [<xref rid="pcbi.1011032.ref003" ref-type="bibr">3</xref>], ntEdit [<xref rid="pcbi.1011032.ref004" ref-type="bibr">4</xref>], and NextPolish [<xref rid="pcbi.1011032.ref005" ref-type="bibr">5</xref>]. The recently published Merfin tool [<xref rid="pcbi.1011032.ref006" ref-type="bibr">6</xref>] uses k-mers to filter variant calls that can be later used for polishing. Almost all these tools require aligning the polishing reads to the assembled contigs, which is computationally expensive. ntEdit does not require alignment, but instead uses Bloom filters to compute and store k-mer quality information about the reads used for polishing. K-mer counts and base quality values are also used for correcting errors in Illumina reads in tools such as QUAKE [<xref rid="pcbi.1011032.ref007" ref-type="bibr">7</xref>] and QuORUM [<xref rid="pcbi.1011032.ref008" ref-type="bibr">8</xref>].</p>
    <p>In this manuscript, we introduce a novel alignment-free polishing tool, JASPER (Jellyfish-based Assembly Sequence Polisher for Error Reduction), which uses k-mer counts computed from the polishing reads with Jellyfish [<xref rid="pcbi.1011032.ref009" ref-type="bibr">9</xref>] to make corrections in assembled contigs. Our experiments show that JASPER is substantially faster than alignment-based polishing tools, with a relatively small cost in overall accuracy. We also show that JASPER is both faster and more accurate than ntEdit.</p>
    <p>The computational efficiency of JASPER enables another possible application, which we illustrate in this study with an example. One can use JASPER to produce population-specific human reference genomes, using Illumina reads sequenced from multiple individuals from a population of interest. Aligning these Illumina reads to a genome could become quite expensive, especially if the number of individuals is large, while counting k-mers in the reads is much cheaper computationally. JASPER can use these k-mer counts to “correct” a human genome assembly so that it contains all homozygous variants that are common in the population from which the reads were drawn. When using this population-specific reference for comparisons of DNA from other individuals from the same population, shared variants will not be seen, thus making downstream analyses easier.</p>
    <sec sec-type="materials|methods" id="sec002">
      <title>Design and implementation</title>
      <p>JASPER attempts to locate and correct errors in a genome sequence using only the k-mer count data (k = 37 by default) in a set of reads sequenced from the same individual. Given a set of reads, JASPER first calls Jellyfish to count k-mers in the reads. It then uses the “jellyfish histo” command to create a histogram of k-mer counts N(C), where N is the number of distinct k-mers with count C in the reads. The correction algorithm is implemented in Python, and it calls Jellyfish from within Python to load and query the database of k-mer counts. JASPER runs multiple instances of the correction algorithm in parallel, using shared memory to load the database.</p>
      <p><xref rid="pcbi.1011032.g001" ref-type="fig">Fig 1</xref> shows a typical k-mer count histogram, with the k-mer count on the horizontal axis and the number of k-mers with a particular count on the vertical axis. The histogram is actually a combination of two different functions E(C) and R(C), where E(C) is the distribution of erroneous k-mers as a function of their count (shown in red in <xref rid="pcbi.1011032.g001" ref-type="fig">Fig 1</xref>) and R(C) is the number of true k-mers (from the genome) that occur in the sequence data (blue area in <xref rid="pcbi.1011032.g001" ref-type="fig">Fig 1</xref>). The local minimum in the histogram occurs at the point C<sub>eq</sub> where E(C<sub>eq</sub>)~ = R(C<sub>eq</sub>), where any k-mer with a count of C<sub>eq</sub> has a 50% chance of containing a sequencing error. K-mers with counts below C<sub>eq</sub> are more likely to contain sequencing errors than to belong to the genome and therefore we call them <italic toggle="yes">unreliable</italic>. Not every unreliable k-mer contains an error, but unreliable k-mers are more likely to contain an error than not.</p>
      <fig position="float" id="pcbi.1011032.g001">
        <object-id pub-id-type="doi">10.1371/journal.pcbi.1011032.g001</object-id>
        <label>Fig 1</label>
        <caption>
          <title>A typical k-mer count histogram for low-error-rate sequencing data (Illumina or PacBio HiFi).</title>
          <p>The red region contains error k-mers that are due to sequencing errors in the reads. The blue region represents the distribution of the counts of correct k-mers in the reads. The x-position labeled R<sub>t</sub> is defined as half of the x coordinate of the local minimum of the distribution.</p>
        </caption>
        <graphic xlink:href="pcbi.1011032.g001" position="float"/>
      </fig>
      <p>The general workflow of JASPER is as follows. For each contig sequence in an assembly, we look up the count for each k-mer in the contig in the database of k-mer counts (from the reads). We skip any k-mers containing a non-ACGT character. For each k-mer in the assembly, we determine whether it is unreliable, and thus is likely to contain an error, by using a heuristic approach with two thresholds: an absolute threshold, A<sub>t</sub>, and a relative threshold, R<sub>t</sub>, where A<sub>t</sub> &lt; R<sub>t</sub> &lt; C<sub>eq</sub>. Any k-mer with a count below A<sub>t</sub> is considered to be unreliable. By default, JASPER sets R<sub>t</sub> = floor(0.5*C<sub>eq</sub>) and A<sub>t</sub> = round(0.5*R<sub>t</sub>), where C<sub>eq</sub> is the local minimum of the histogram curve as shown in <xref rid="pcbi.1011032.g001" ref-type="fig">Fig 1</xref>, and floor(x) is the closest integer to x that is smaller than x. We note that this computation works for C<sub>eq</sub> &gt; = 4. If C<sub>eq</sub> &lt; 4, then JASPER considers that the input read data is not suitable for polishing and returns an error. If a k-mer has a count less than R<sub>t</sub> but not less than A<sub>t</sub>, then we label it as unreliable if its count is also less than half of the count of the previous k-mer. These heuristics are intended to account for natural variations of coverage in the sequencing data. As we examine k-mer counts along the genome sequence, any drop in k-mer counts that is due to natural variation in coverage is likely to be smooth, whereas any drop that is due to an error in the sequence is likely to be sharp. When we find the first unreliable k-mer K<sub>e</sub> after a run of correct k-mers, all subsequent consecutive k-mers whose counts are below R<sub>t</sub> are considered to be unreliable as well. JASPER continues to mark k-mers as unreliable until it sees a k-mer with a count above R<sub>t</sub>. This generates a “run” of unreliable k-mers of length L. In highly repetitive regions, JASPER limits its efforts by only marking as unreliable a run of K or K-1 consecutive k-mers whose maximum count is 50 times less than the average k-mer counts of the K k-mers before the run. We use the length of the run L to determine if there is a potential error in the contig sequence, the putative error type and the appropriate correction strategy, as follows:</p>
      <list list-type="order">
        <list-item>
          <p>L = K (37 by default): the putative error is a single-base substitution or insertion located at the last base of the sequence of errors, S<sub>L</sub>. JASPER attempts to fix this error by changing the last base of S<sub>L</sub> or deleting it. We accept the fix if all k-mers spanning the putative deletion site have counts of at least R<sub>t</sub> after the modification.</p>
        </list-item>
        <list-item>
          <p>L &gt; K: we assume that this is caused by two or more errors that are less than K apart. In this case we perform the correction by building a k-mer graph. We take the last K-1 bases of the last good k-mer and query the Jellyfish database for the counts of k-mers corresponding to the four possible extensions (A,C,G,T). Any extension that yields a k-mer with count above R<sub>t</sub> is valid. Each valid extension originates a path that we can extend further. Thus, we build a local directional k-mer graph that contains all paths of k-mers with counts above R<sub>t</sub>. We follow all possible paths for up to L steps. If the number of possible paths exceeds 5,000 at any step, we give up. If the last 5 bases of any path match the first 5 bases of the first good k-mer, we test all k-mers that contain the matching 5 bases, and if all these k-mers’ counts are above R<sub>t</sub>, we accept the path as the fix. By construction this ensures that the counts of all k-mers along the path are above R<sub>t</sub>.</p>
        </list-item>
        <list-item>
          <p>L &lt; K: for this scenario the putative error is either (i) a single base deletion somewhere in S<sub>L</sub>; (ii) an insertion of the same base if the last base of the last reliable k-mer before S<sub>L</sub> is the same as the last base of the first unreliable k-mer (in S<sub>L</sub>); (iii) a haplotype phasing error where the assembly algorithm chose a base from one haplotype and a base from the other haplotype separated by K or fewer positions; or (iv) a deletion of multiple bases that are the same as the last base of the last reliable k-mer before S<sub>L</sub>. We try the modifications sequentially until we arrive at the situation where all k-mers containing bases in modified S<sub>L</sub> have counts of at least R<sub>t</sub>.</p>
        </list-item>
      </list>
      <p>The major types of errors described above are illustrated in <xref rid="pcbi.1011032.g002" ref-type="fig">Fig 2</xref>, which uses K = 5 for clarity and space considerations. Note that for haplotype phasing errors, only one of the bases (the last base of the first k-mer in S<sub>L</sub>, or the first base of the last k-mer in S<sub>L</sub>) will be wrong.</p>
      <fig position="float" id="pcbi.1011032.g002">
        <object-id pub-id-type="doi">10.1371/journal.pcbi.1011032.g002</object-id>
        <label>Fig 2</label>
        <caption>
          <title>Illustration of the six most common error types that JASPER can detect and fix.</title>
          <p>Error bases are in lowercase. The error k-mers (K = 5) are shown above the sequence. Black arrows indicate locations of deletions.</p>
        </caption>
        <graphic xlink:href="pcbi.1011032.g002" position="float"/>
      </fig>
      <p>If we are unable to find a way to modify the consensus in such a way as to make all k-mers in S<sub>L</sub> reliable, the algorithm makes no modifications because the fact that a k-mer is unreliable does not guarantee that it is erroneous.</p>
      <p>After we make a complete pass of corrections over the entire set of contig sequences, by default we run one more pass. Errors fixed on the first pass may allow JASPER to fix another set of errors on subsequent passes. Note that the number of errors does not increase with more passes, implying that the JASPER algorithm introduces few or no new errors. <xref rid="pcbi.1011032.g003" ref-type="fig">Fig 3</xref> shows the number of errors remaining in the <italic toggle="yes">A</italic>. <italic toggle="yes">thaliana</italic> simulated data experiment for up to 10 passes of polishing. The number of errors reaches its minimum after three passes, and then flattens out completely, implying that the subsequent passes do not introduce or correct any more errors. We did verify that for this case the number of corrections made in passes 4–10 was indeed zero.</p>
      <fig position="float" id="pcbi.1011032.g003">
        <object-id pub-id-type="doi">10.1371/journal.pcbi.1011032.g003</object-id>
        <label>Fig 3</label>
        <caption>
          <title>Number of errors remaining after polishing (green, left axis) and the run time of JASPER (green, right axis) for different number of polishing iterations (-p parameter), on <italic toggle="yes">A</italic>. <italic toggle="yes">thaliana</italic> data with simulated errors with K = 63.</title>
          <p>The number of errors stops decreasing after three iterations, and it never increases for up to 10 iterations. The run time increases approximately linearly with the number of iterations. We do not show the original number of errors (pass 0), because it is large (118,563).</p>
        </caption>
        <graphic xlink:href="pcbi.1011032.g003" position="float"/>
      </fig>
      <p>We note the distinction between ntEdit and JASPER algorithms. ntEdit is based on finding a subset of “solid” k-mers in a set of Illumina reads using Bloom filters, and then using this binary designation to detect and fix errors in the consensus. In JASPER we use the actual counts of occurrences of k-mers in the reads used for polishing to determine whether the k-mer is likely to contain an error, depending on the local context, i.e. the difference between its count and the counts of the preceding and following k-mers. Thus, depending on the context, not all unreliable k-mers will be called potentially erroneous and trigger the correction algorithm. Another major difference from ntedit is the use of the k-mer graph method to correct cases where there are several errors close together. These algorithmic differences in JASPER lead to better effectiveness with fewer erroneous corrections, and thus running multiple passes of JASPER leads to uniformly better-polished output assemblies, as shown in <xref rid="pcbi.1011032.g003" ref-type="fig">Fig 3</xref>.</p>
    </sec>
  </sec>
  <sec sec-type="results" id="sec003">
    <title>Results</title>
    <p>We first compare JASPER to several leading genome polishing tools, including POLCA [<xref rid="pcbi.1011032.ref003" ref-type="bibr">3</xref>], NextPolish [<xref rid="pcbi.1011032.ref005" ref-type="bibr">5</xref>], and ntEdit [<xref rid="pcbi.1011032.ref004" ref-type="bibr">4</xref>]. POLCA and NextPolish are among the best methods for polishing with Illumina reads [<xref rid="pcbi.1011032.ref003" ref-type="bibr">3</xref>], and ntEdit is the best of the alignment-free genome polishers.</p>
    <p>In our first experiments, we utilized publicly available data for the model plant <italic toggle="yes">Arabidopsis thaliana</italic> (ecotype Col-0, see Data availability section). We began with a previously-published high-quality assembly of the genome [<xref rid="pcbi.1011032.ref010" ref-type="bibr">10</xref>], which we label Athal-Berlin, and introduced 39635 single base substitutions and 78928 single base insertions and deletions at random locations in the genome. We call the resulting assembly Athal-simerr. We then used wgsim (<ext-link xlink:href="https://github.com/lh3/wgsim" ext-link-type="uri">https://github.com/lh3/wgsim</ext-link>) to simulate 30x coverage by 2x150 paired-end Illumina reads with a 1% error rate. We call these reads the “simulated polishing reads.” We then used the simulated polishing reads to correct the Athal-simerr assembly with POLCA, NextPolish, ntEdit and JASPER. In the second experiment, we used the MaSuRCA assembler [<xref rid="pcbi.1011032.ref011" ref-type="bibr">11</xref>] (v4.0.6) to create another assembly of <italic toggle="yes">A</italic>. <italic toggle="yes">thaliana</italic> using the PacBio and Illumina reads from Berlin et al. [<xref rid="pcbi.1011032.ref010" ref-type="bibr">10</xref>]. We call this assembly Athal-MaSuRCA. We polished this assembly with POLCA, NextPolish, ntEdit, and JASPER, using a 60x coverage subset of the Illumina reads from Berlin et al. [<xref rid="pcbi.1011032.ref010" ref-type="bibr">10</xref>] with all methods. Because k-mer length is a key parameter for JASPER and ntEdit, we ran polishing with k ranging from 27–67 for these two programs and chose the value of k that yielded the best result (the least bases in errors remaining) for each program. We used the default settings for the other polishing parameters. For evaluations, we followed the same approach as was used in [<xref rid="pcbi.1011032.ref005" ref-type="bibr">5</xref>]. We aligned the Illumina reads used for polishing to the polished assemblies with bwa-mem [<xref rid="pcbi.1011032.ref012" ref-type="bibr">12</xref>] and called variants with the freebayes software [<xref rid="pcbi.1011032.ref013" ref-type="bibr">13</xref>]. Any homozygous variant, i.e. any variant where no reads agreed with the assembly, and where two or more reads disagreed, was counted as an error.</p>
    <p>Our evaluation of the polishing tools on the <italic toggle="yes">A</italic>. <italic toggle="yes">thaliana</italic> data is shown in Tables <xref rid="pcbi.1011032.t001" ref-type="table">1</xref> and <xref rid="pcbi.1011032.t002" ref-type="table">2</xref>. <xref rid="pcbi.1011032.t001" ref-type="table">Table 1</xref> shows that JASPER overall corrects more errors than ntEdit but does not correct as many as the alignment-based polishing tools, such as POLCA and NextPolish. On the real data ntEdit increases the number of substitution errors slightly, while both methods reduce the number of insertion/deletion (indel) errors. The primary reason for the inferior performance of the k-mer-based methods is that most errors in Athal-MaSuRCA are indels of several bases in a row. While alignment-based methods are able to correct such errors, k-mer-based methods fail when the indel size is close to the size of the k-mer. <xref rid="pcbi.1011032.t002" ref-type="table">Table 2</xref> shows a more in-depth analysis of the specific corrections made by different polishing methods on the simulated data. Alignment-based methods perform well in this analysis, where POLCA is more accurate and NextPolish more sensitive. JASPER has the best precision, followed closely by POLCA. JASPER is superior to ntEdit in both sensitivity and precision in this experiment.</p>
    <table-wrap position="float" id="pcbi.1011032.t001">
      <object-id pub-id-type="doi">10.1371/journal.pcbi.1011032.t001</object-id>
      <label>Table 1</label>
      <caption>
        <title>Comparison of polishing tools on assemblies of <italic toggle="yes">A</italic>. <italic toggle="yes">thaliana</italic>.</title>
        <p>Numbers correspond to the number of bases in substitutions, insertions, or deletions detected by aligning the reads to the assemblies and calling variants with the freebayes software. Any variant with reference allele frequency 0 and alternative allele frequency &gt;1 was considered an error. For substitution errors we counted the number of bases in substitutions, and for indel errors we counted the number of inserted or deleted bases. Columns labeled “Simulated” refer to experiments where we introduced random errors into a reference, and that used short reads simulated from the unaltered reference for polishing. Columns labeled “Real” refer to experiments that used real Illumina reads to polish a draft assembly of the data. Timing data used a 24-core Intel Xeon Gold 6248R @ 3.0Ghz server with 24 threads. Execution time is given for the real data. The best value in each column (lower is better) is shown in bold.</p>
      </caption>
      <alternatives>
        <graphic xlink:href="pcbi.1011032.t001" id="pcbi.1011032.t001g" position="float"/>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col align="left" valign="middle" span="1"/>
            <col align="left" valign="middle" span="1"/>
            <col align="left" valign="middle" span="1"/>
            <col align="left" valign="middle" span="1"/>
            <col align="left" valign="middle" span="1"/>
            <col align="left" valign="middle" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th align="left" rowspan="1" colspan="1"/>
              <th align="center" rowspan="1" colspan="1">Simulated errors #bases in substitutions remaining</th>
              <th align="center" rowspan="1" colspan="1">Simulated errors #bases in indels remaining</th>
              <th align="center" rowspan="1" colspan="1">Real errors #bases in substitutions remaining</th>
              <th align="center" rowspan="1" colspan="1">Real errors #bases in indels remaining</th>
              <th align="center" rowspan="1" colspan="1">Execution time (minutes)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" rowspan="1" colspan="1">No polishing</td>
              <td align="center" rowspan="1" colspan="1">39,635</td>
              <td align="center" rowspan="1" colspan="1">78,928</td>
              <td align="center" rowspan="1" colspan="1">1,117</td>
              <td align="center" rowspan="1" colspan="1">2,507</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">POLCA</td>
              <td align="center" rowspan="1" colspan="1">
                <bold>76</bold>
              </td>
              <td align="center" rowspan="1" colspan="1">
                <bold>234</bold>
              </td>
              <td align="center" rowspan="1" colspan="1">
                <bold>273</bold>
              </td>
              <td align="center" rowspan="1" colspan="1">
                <bold>459</bold>
              </td>
              <td align="center" rowspan="1" colspan="1">42.6</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">NextPolish</td>
              <td align="center" rowspan="1" colspan="1">721</td>
              <td align="center" rowspan="1" colspan="1">1,077</td>
              <td align="center" rowspan="1" colspan="1">316</td>
              <td align="center" rowspan="1" colspan="1">520</td>
              <td align="center" rowspan="1" colspan="1">144.0</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">ntEdit<break/>(best k)</td>
              <td align="center" rowspan="1" colspan="1">1,532 (k = 35)</td>
              <td align="center" rowspan="1" colspan="1">1,824 (k = 35)</td>
              <td align="center" rowspan="1" colspan="1">1,153 (k = 41)</td>
              <td align="center" rowspan="1" colspan="1">1,888 (k = 41)</td>
              <td align="center" rowspan="1" colspan="1">8.4</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">JASPER<break/>(best k)</td>
              <td align="center" rowspan="1" colspan="1">181 (k = 63)</td>
              <td align="center" rowspan="1" colspan="1">292 (k = 63)</td>
              <td align="center" rowspan="1" colspan="1">869 (k = 37)</td>
              <td align="center" rowspan="1" colspan="1">1,814 (k = 37)</td>
              <td align="center" rowspan="1" colspan="1">5.3</td>
            </tr>
          </tbody>
        </table>
      </alternatives>
    </table-wrap>
    <table-wrap position="float" id="pcbi.1011032.t002">
      <object-id pub-id-type="doi">10.1371/journal.pcbi.1011032.t002</object-id>
      <label>Table 2</label>
      <caption>
        <title>Statistical analysis of the corrections made by different polishing methods on an <italic toggle="yes">A</italic>. <italic toggle="yes">thaliana</italic> with simulated errors using simulated reads.</title>
        <p>True Positives are errors that we introduced and that were corrected; False Positives are spurious corrections that polishers made where there were no errors introduced; and False Negatives are errors in the genome that were not corrected. The best numbers in each column are in bold. JASPER is the most accurate polisher with the lowest number of False Positives.</p>
      </caption>
      <alternatives>
        <graphic xlink:href="pcbi.1011032.t002" id="pcbi.1011032.t002g" position="float"/>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col align="left" valign="middle" span="1"/>
            <col align="left" valign="middle" span="1"/>
            <col align="left" valign="middle" span="1"/>
            <col align="left" valign="middle" span="1"/>
            <col align="left" valign="middle" span="1"/>
            <col align="left" valign="middle" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th align="left" rowspan="1" colspan="1"/>
              <th align="left" rowspan="1" colspan="1">True Positives</th>
              <th align="left" rowspan="1" colspan="1">False Positives</th>
              <th align="left" rowspan="1" colspan="1">False Negatives</th>
              <th align="left" rowspan="1" colspan="1">Sensitivity</th>
              <th align="left" rowspan="1" colspan="1">Precision</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" rowspan="1" colspan="1">POLCA</td>
              <td align="left" rowspan="1" colspan="1">118,296</td>
              <td align="left" rowspan="1" colspan="1">93</td>
              <td align="left" rowspan="1" colspan="1">213</td>
              <td align="char" char="." rowspan="1" colspan="1">
                <bold>99.9%</bold>
              </td>
              <td align="char" char="." rowspan="1" colspan="1">
                <bold>99.9%</bold>
              </td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">NextPolish</td>
              <td align="left" rowspan="1" colspan="1">
                <bold>118,343</bold>
              </td>
              <td align="left" rowspan="1" colspan="1">1,629</td>
              <td align="left" rowspan="1" colspan="1">
                <bold>166</bold>
              </td>
              <td align="char" char="." rowspan="1" colspan="1">
                <bold>99.9%</bold>
              </td>
              <td align="char" char="." rowspan="1" colspan="1">98.6%</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">ntEdit (k = 35)</td>
              <td align="left" rowspan="1" colspan="1">115,803</td>
              <td align="left" rowspan="1" colspan="1">584</td>
              <td align="left" rowspan="1" colspan="1">2,706</td>
              <td align="char" char="." rowspan="1" colspan="1">97.8%</td>
              <td align="char" char="." rowspan="1" colspan="1">99.5%</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">JASPER (k = 63)</td>
              <td align="left" rowspan="1" colspan="1">118,169</td>
              <td align="left" rowspan="1" colspan="1">
                <bold>90</bold>
              </td>
              <td align="left" rowspan="1" colspan="1">340</td>
              <td align="char" char="." rowspan="1" colspan="1">99.7%</td>
              <td align="char" char="." rowspan="1" colspan="1">
                <bold>99.9%</bold>
              </td>
            </tr>
          </tbody>
        </table>
      </alternatives>
    </table-wrap>
    <p>For a more detailed comparison of JASPER and ntEdit, we varied the k-mer size used for correction from k = 27 to 67 for experiments on real data from <italic toggle="yes">A</italic>. <italic toggle="yes">thaliana</italic>. The results are shown in <xref rid="pcbi.1011032.g004" ref-type="fig">Fig 4</xref>. We observed that with longer k-mers, JASPER’s performance on substitutions improves, while its performance on indels remains flat. For k &lt; = 43, JASPER performs similarly to ntEdit on indels and substantially better on substitutions, resulting in overall better performance at all values of k. Above k = 43, ntEdit’s performance on indels declines (the number of uncorrected errors increases), while its performance on substitutions improves slightly. The run time for JASPER and ntEdit did not vary significantly with increasing k, although the memory usage increased.</p>
    <fig position="float" id="pcbi.1011032.g004">
      <object-id pub-id-type="doi">10.1371/journal.pcbi.1011032.g004</object-id>
      <label>Fig 4</label>
      <caption>
        <title>Effectiveness of ntEdit and JASPER polishing on real <italic toggle="yes">A</italic>. <italic toggle="yes">thaliana</italic> data as a function of the k-mer size used for polishing.</title>
        <p>We show the number of remaining substitution errors in blue, the number of remaining indel errors in orange and the total number of remaining errors in green. Solid horizontal lines mark the number of errors before correction. The number of errors remaining is plotted as solid lines for JASPER and dashed lines for ntEdit. JASPER corrects more substitution errors at every k-mer size, and more indel errors at all but two values of k. For all values of k, the total errors remaining is lower for JASPER.</p>
      </caption>
      <graphic xlink:href="pcbi.1011032.g004" position="float"/>
    </fig>
    <p><italic toggle="yes">A</italic>. <italic toggle="yes">thaliana</italic> has a relatively small genome that lacks some of the complex repetitive structures that are present in mammalian genomes. To test our approach on a mammalian-sized genome, we used a publicly available but unpublished assembly (GenBank accession GCA_001015355) of the human CHM13 cell line that was assembled with Celera Assembler v. 8.3rc2 from ~70x coverage in PacBio P6C4 reads and polished with Arrow.</p>
    <p>We used Illumina reads for CHM13 available from NCBI (accessions SRR1997411 and SRR3189741) for polishing the GCA_001015355 assembly (See Data availability section). The reads provided about 60x coverage of the genome. As with the <italic toggle="yes">A</italic>. <italic toggle="yes">thaliana</italic> real data experiments, we used the approach from [<xref rid="pcbi.1011032.ref005" ref-type="bibr">5</xref>] to measure the number of errors in the assembly as the number of homozygous variants compared to the Illumina reads after polishing. <xref rid="pcbi.1011032.t003" ref-type="table">Table 3</xref> shows polishing results and timings for four programs on the CHM13 assembly. Here JASPER (k = 47) is slower but more accurate than ntEdit (k = 50, recommended value) and both k-mer-based polishers are much faster but less accurate than the alignment-based polishers.</p>
    <table-wrap position="float" id="pcbi.1011032.t003">
      <object-id pub-id-type="doi">10.1371/journal.pcbi.1011032.t003</object-id>
      <label>Table 3</label>
      <caption>
        <title>Comparison of the polishers on the human CHM13 assembly polished with Illumina reads.</title>
        <p>Timing data used a 24-core Intel Xeon Gold 6248R @ 3.0Ghz server with 24 threads. JASPER and ntEdit are the two fastest polishers. JASPER is slower than ntEdit, but it produces more accurate polished assembly.</p>
      </caption>
      <alternatives>
        <graphic xlink:href="pcbi.1011032.t003" id="pcbi.1011032.t003g" position="float"/>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col align="left" valign="middle" span="1"/>
            <col align="left" valign="middle" span="1"/>
            <col align="left" valign="middle" span="1"/>
            <col align="left" valign="middle" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th align="left" rowspan="1" colspan="1"/>
              <th align="center" rowspan="1" colspan="1">Substitution errors</th>
              <th align="center" rowspan="1" colspan="1">Insertion/ deletion errors</th>
              <th align="center" rowspan="1" colspan="1">Execution time (hours)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" rowspan="1" colspan="1">Unpolished</td>
              <td align="center" rowspan="1" colspan="1">62,778</td>
              <td align="center" rowspan="1" colspan="1">298,508</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">POLCA</td>
              <td align="center" rowspan="1" colspan="1">23,118</td>
              <td align="center" rowspan="1" colspan="1">56,380</td>
              <td align="center" rowspan="1" colspan="1">13.75</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">NextPolish</td>
              <td align="center" rowspan="1" colspan="1">
                <bold>19,149</bold>
              </td>
              <td align="center" rowspan="1" colspan="1">
                <bold>29,017</bold>
              </td>
              <td align="center" rowspan="1" colspan="1">27.5</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">ntEdit (k = 50)</td>
              <td align="center" rowspan="1" colspan="1">60,252</td>
              <td align="center" rowspan="1" colspan="1">220,434</td>
              <td align="center" rowspan="1" colspan="1">
                <bold>2.3</bold>
              </td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">JASPER (k = 47)</td>
              <td align="center" rowspan="1" colspan="1">59,687</td>
              <td align="center" rowspan="1" colspan="1">199,583</td>
              <td align="center" rowspan="1" colspan="1">4.5</td>
            </tr>
          </tbody>
        </table>
      </alternatives>
    </table-wrap>
    <p>JASPER also reports an overall quality value (QV) for the assembly based on the fraction of unreliable k-mers it observes before and after polishing. The Methods section discusses how we determine whether a k-mer is unreliable. We then compute the quality as QV = (-10)log<sub>10</sub>(E<sub>b</sub>), where E<sub>b</sub> is the proportion of erroneous bases in the assembly. E<sub>b</sub> is estimated from the observed number of unreliable k-mers as E<sub>b</sub> = 1—(1—E<sub>k</sub>)<sup>(1/K)</sup>, where K is the k-mer length and E<sub>k</sub> is the k-mer error rate. E<sub>k</sub> is computed as the number of unreliable k-mers divided by the genome size; e.g., if we found 100 unreliable k-mers in a 1 Mbp genome, then E<sub>k</sub> would be 1/10000. This approximation uses a simplifying assumption that the errors are distributed randomly in the genome, which is not generally true; e.g., two or more errors might occur more often consecutively in homopolymers or simple sequence repeats. The QV as computed here is an under-estimate of the true assembly quality, because it assumes that: (1) the reads contain all true k-mers in the genome, and (2) all unreliable k-mers contain an error. Both assumptions are generally not true. In real data sets, it is usually impossible to know how much of the assembled sequence is missing from the reads, especially if the genome was assembled with reads from one sequencing technology (e.g. Oxford nanopore) and polished with reads from another (e.g. Illumina), although that number is likely to be very small when coverage is deep. For example, even in our experiments with 30x coverage of <italic toggle="yes">A</italic>. <italic toggle="yes">thaliana</italic> using simulated 150bp reads, which provide much more uniform coverage than the real data, we found 1080 k-mers (out of about 120M) in the assembly that were not present in the simulated reads.</p>
    <p>We can capitalize on the speed of JASPER to address another interesting problem: creating population-specific human reference genomes. When calling short variants (substitutions and indels) from whole-genome sequencing data of one individual against the reference genome, one typically gets several million variant calls. Some of these variant calls, especially those where the individual is homozygous, will be uninformative because they are common variants in the sub-population to which the individual belongs. To reduce the number of uninformative homozygous variant calls, one can use polishing to “correct” the reference genome in places where it disagrees with almost all individuals from a given sub-population. Doing so will essentially hide the variants that are common in the sub-population to which the individual belongs, thus making downstream analysis easier. Polishing tools including Jasper and others can be used create population-specific reference genomes by using Illumina data from multiple individuals to “polish” a human genome assembly such as GRCh38 or CHM13. However, for large population samples the computational cost of making such a reference with alignment-based tools might be prohibitive. In this application, we are not really polishing, but rather altering the reference to make it look much more like an individual genome from the target population. Also, the task here is not to introduce the most common population variants into the reference, but rather remove homozygous variants from the reference that are rare in the population. Due to its efficiency, JASPER is well-suited for this task. To illustrate this capability, we performed two experiments.</p>
    <p>In the first experiment, we used the recently published complete CHM13 human genome [<xref rid="pcbi.1011032.ref014" ref-type="bibr">14</xref>] as the basis for creating a population-specific reference. Because CHM13 is missing the Y chromosome, we added the Y chromosome from GRCh38 to the CHM13 assembly, creating a new assembly which we designate CHM13+Y. We then downloaded Illumina data from eight individuals (NA18939, NA18946, NA18976, NA18978, NA18979, NA18981, NA18991, NA19011), all from Tokyo, Japan, from the 1000 Genomes Project website (<ext-link xlink:href="http://www.internationalgenome.org" ext-link-type="uri">http://www.internationalgenome.org</ext-link>). This yielded a total of ~260 Gbp in Illumina reads. We then set aside one sample, NA18939, and used the remaining sets of reads to polish CHM13+Y using JASPER, resulting in an assembly we call Tokyo-polish.</p>
    <p>We then aligned the reads from NA18939 to both the CHM13+Y and the Tokyo-polish genomes and called variants with POLCA software utilizing the “-n” switch that switches off all polishing algorithms and simply reports the variant calls in the VCF format [<xref rid="pcbi.1011032.ref003" ref-type="bibr">3</xref>]. We then counted the number of homozygous variant calls where the reference allele was supported by 0 reads and the alternate allele was supported by at least two reads. We found 1,590,668 such variants when comparing the reads to the CHM13+Y genome, and 1,029,097 variants when comparing to the Tokyo-polish reference. Thus, we observed a 35% reduction in the number of homozygous variant calls against the polished reference.</p>
    <p>A related question is whether the polished reference would be closer to an individual who was unrelated to the population of interest. To answer this question, we used the Illumina reads with similar genomic coverage as NA18939 data, for individual PGP17 from the Personal Genomes Project (PGP), who is estimated to be about 60% Ashkenazi with no Japanese ancestry. We observed 1,052,191 homozygous variant calls between the Tokyo-polish reference and the PGP17 individual, vs. 1,029,097 calls between the Tokyo-polish reference and NA18939. Thus (as expected) PGP17 was no closer to the Tokyo-polish assembly than NA18939. We then ran an experiment to compare the use of JASPER to create a population-specific reference versus using the recently-published Ashkenazi Jewish reference genome, Ash1 [<xref rid="pcbi.1011032.ref015" ref-type="bibr">15</xref>]. Ash1 was assembled from HG002, an Ashkenazi Jewish individual who is part of the 1000 Genomes Project. We also downloaded 30X coverage in Illumina data from his parents, HG003 and HG004. We used the Illumina reads from both parents to “polish” GRCh38.p13, creating a new Ashkenazi-specific reference, which we designated as GRCh38-Ash.</p>
    <p>The publication describing Ash1 [<xref rid="pcbi.1011032.ref015" ref-type="bibr">15</xref>] called variants in the PGP17 genome by aligning the Illumina reads from PGP17 to Ash1, and found 1,333,345 homozygous variants, versus 1,700,364 homozygous variants when found when aligning PGP17 reads to GRCh38. We used the same methods and thresholds to call variants in PGP17 versus our GRCh38-Ash reference genome and found 1,049,117 homozygous variants. Fewer homozygous variants suggest that our polished genome is an even closer match to PGP17 than the individual Ash1 genome for the purpose of short variant calling.</p>
    <p>In summary, JASPER is a very fast tool for polishing genomes, which runs many times faster than the fastest alignment-based polisher. In addition to its usefulness as a polishing tool, JASPER can also be used to efficiently create new personalized reference genomes.</p>
    <sec id="sec004">
      <title>Availability and future directions</title>
      <p>In this manuscript we introduced an efficient novel polishing tool called JASPER that is substantially faster than polishing methods based on sequence alignment, and more accurate than currently available k-mer based methods. The efficiency and scalability of JASPER allow one to use it to create personalized reference genomes for specific populations very efficiently, even for large sequenced populations. JASPER is an open-source software available on GitHub at <ext-link xlink:href="https://github.com/alguoo314/JASPER" ext-link-type="uri">https://github.com/alguoo314/JASPER</ext-link>.</p>
    </sec>
  </sec>
  <sec id="sec005" sec-type="supplementary-material">
    <title>Supporting information</title>
    <supplementary-material id="pcbi.1011032.s001" position="float" content-type="local-data">
      <label>S1 Text</label>
      <caption>
        <title>Command lines used for polishing experiments and evaluations.</title>
        <p>(DOCX)</p>
      </caption>
      <media xlink:href="pcbi.1011032.s001.docx">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ref-list>
    <title>References</title>
    <ref id="pcbi.1011032.ref001">
      <label>1</label>
      <mixed-citation publication-type="journal"><name><surname>Walker</surname><given-names>BJ</given-names></name>, <name><surname>Abeel</surname><given-names>T</given-names></name>, <name><surname>Shea</surname><given-names>T</given-names></name>, <name><surname>Priest</surname><given-names>M</given-names></name>, <name><surname>Abouelliel</surname><given-names>A</given-names></name>, <name><surname>Sakthikumar</surname><given-names>S</given-names></name>, <etal>et al</etal>. <article-title>pilon: an integrated tool for comprehensive microbial variant detection and genome assembly improvement</article-title>. <source>PloS ONE</source>. <year>2014</year><month>Nov</month><day>19</day>;<volume>9</volume>(<issue>11</issue>):<fpage>e112963</fpage>. <comment>doi: </comment><pub-id pub-id-type="doi">10.1371/journal.pone.0112963</pub-id><?supplied-pmid 25409509?><pub-id pub-id-type="pmid">25409509</pub-id></mixed-citation>
    </ref>
    <ref id="pcbi.1011032.ref002">
      <label>2</label>
      <mixed-citation publication-type="journal"><name><surname>Vaser</surname><given-names>R</given-names></name>, <name><surname>Sović</surname><given-names>I</given-names></name>, <name><surname>Nagarajan</surname><given-names>N</given-names></name>, <name><surname>Šikić</surname><given-names>M</given-names></name>. <article-title>Fast and accurate de novo genome assembly from long uncorrected reads</article-title>. <source>Genome Research</source>. <year>2017</year><month>May</month><day>1</day>;<volume>27</volume>(<issue>5</issue>):<fpage>737</fpage>–<lpage>46</lpage>. <comment>doi: </comment><pub-id pub-id-type="doi">10.1101/gr.214270.116</pub-id><?supplied-pmid 28100585?><pub-id pub-id-type="pmid">28100585</pub-id></mixed-citation>
    </ref>
    <ref id="pcbi.1011032.ref003">
      <label>3</label>
      <mixed-citation publication-type="journal"><name><surname>Zimin</surname><given-names>AV</given-names></name>, <name><surname>Salzberg</surname><given-names>SL</given-names></name>. <article-title>The genome polishing tool POLCA makes fast and accurate corrections in genome assemblies</article-title>. <source>PLoS computational biology</source>. <year>2020</year><month>Jun</month><day>26</day>;<volume>16</volume>(<issue>6</issue>):<fpage>e1007981</fpage>. <comment>doi: </comment><pub-id pub-id-type="doi">10.1371/journal.pcbi.1007981</pub-id><?supplied-pmid 32589667?><pub-id pub-id-type="pmid">32589667</pub-id></mixed-citation>
    </ref>
    <ref id="pcbi.1011032.ref004">
      <label>4</label>
      <mixed-citation publication-type="journal"><name><surname>Warren</surname><given-names>RL</given-names></name>, <name><surname>Coombe</surname><given-names>L</given-names></name>, <name><surname>Mohamadi</surname><given-names>H</given-names></name>, <name><surname>Zhang</surname><given-names>J</given-names></name>, <name><surname>Jaquish</surname><given-names>B</given-names></name>, <name><surname>Isabel</surname><given-names>N</given-names></name>, <etal>et al</etal>. <article-title>ntEdit: scalable genome sequence polishing</article-title>. <source>Bioinformatics</source>. <year>2019</year><month>Nov</month><day>1</day>;<volume>35</volume>(<issue>21</issue>):<fpage>4430</fpage>–<lpage>2</lpage>. <comment>doi: </comment><pub-id pub-id-type="doi">10.1093/bioinformatics/btz400</pub-id><?supplied-pmid 31095290?><pub-id pub-id-type="pmid">31095290</pub-id></mixed-citation>
    </ref>
    <ref id="pcbi.1011032.ref005">
      <label>5</label>
      <mixed-citation publication-type="journal"><name><surname>Hu</surname><given-names>J</given-names></name>, <name><surname>Fan</surname><given-names>J</given-names></name>, <name><surname>Sun</surname><given-names>Z</given-names></name>, <name><surname>Liu</surname><given-names>S</given-names></name>. <article-title>NextPolish: a fast and efficient genome polishing tool for long read assembly. Bioinformatics (Oxford, England). 2019 Nov. Koren S, Walenz BP, Berlin K, Miller JR, Bergman NH, Phillippy AM. Canu: scalable and accurate long-read assembly via adaptive k-mer weighting and repeat separation</article-title>. <source>Genome Research</source>. <year>2017</year><month>May</month><day>1</day>;<volume>27</volume>(<issue>5</issue>):<fpage>722</fpage>–<lpage>36</lpage>.<pub-id pub-id-type="pmid">28298431</pub-id></mixed-citation>
    </ref>
    <ref id="pcbi.1011032.ref006">
      <label>6</label>
      <mixed-citation publication-type="journal"><name><surname>Formenti</surname><given-names>G</given-names></name>, <name><surname>Rhie</surname><given-names>A</given-names></name>, <name><surname>Walenz</surname><given-names>BP</given-names></name>, <name><surname>Thibaud-Nissen</surname><given-names>F</given-names></name>, <name><surname>Shafin</surname><given-names>K</given-names></name>, <name><surname>Koren</surname><given-names>S</given-names></name>, <etal>et al</etal>. <article-title>Merfin: improved variant filtering, assembly evaluation and polishing via k-mer validation</article-title>. <source>Nature Methods</source>. <year>2022</year><month>Mar</month><volume>31</volume>:<fpage>1</fpage>–<lpage>9</lpage>. <comment>doi: </comment><pub-id pub-id-type="doi">10.1038/s41592-022-01445-y</pub-id><?supplied-pmid 35361932?><pub-id pub-id-type="pmid">35361932</pub-id></mixed-citation>
    </ref>
    <ref id="pcbi.1011032.ref007">
      <label>7</label>
      <mixed-citation publication-type="journal"><name><surname>Marçais</surname><given-names>G</given-names></name>, <name><surname>Kingsford</surname><given-names>C</given-names></name>. <article-title>A fast, lock-free approach for efficient parallel counting of occurrences of k-mers</article-title>. <source>Bioinformatics</source>. <year>2011</year><month>Mar</month><day>15</day>;<volume>27</volume>(<issue>6</issue>):<fpage>764</fpage>–<lpage>70</lpage>. <comment>doi: </comment><pub-id pub-id-type="doi">10.1093/bioinformatics/btr011</pub-id><?supplied-pmid 21217122?><pub-id pub-id-type="pmid">21217122</pub-id></mixed-citation>
    </ref>
    <ref id="pcbi.1011032.ref008">
      <label>8</label>
      <mixed-citation publication-type="journal"><name><surname>Kelley</surname><given-names>DR</given-names></name>, <name><surname>Schatz</surname><given-names>MC</given-names></name>, <name><surname>Salzberg</surname><given-names>SL</given-names></name>. <article-title>Quake: quality-aware detection and correction of sequencing errors</article-title>. <source>Genome biology</source>. <year>2010</year><month>Nov</month>;<volume>11</volume>(<issue>11</issue>):<fpage>1</fpage>–<lpage>3</lpage>. <comment>doi: </comment><pub-id pub-id-type="doi">10.1186/gb-2010-11-11-r116</pub-id><?supplied-pmid 21114842?><pub-id pub-id-type="pmid">21114842</pub-id></mixed-citation>
    </ref>
    <ref id="pcbi.1011032.ref009">
      <label>9</label>
      <mixed-citation publication-type="journal"><name><surname>Marçais</surname><given-names>G</given-names></name>, <name><surname>Yorke</surname><given-names>JA</given-names></name>, <name><surname>Zimin</surname><given-names>A</given-names></name>. <article-title>QuorUM: an error corrector for Illumina reads</article-title>. <source>PLoS One</source>. <year>2015</year><month>Jun</month><day>17</day>;<volume>10</volume>(<issue>6</issue>):<fpage>e0130821</fpage>. <comment>doi: </comment><pub-id pub-id-type="doi">10.1371/journal.pone.0130821</pub-id><?supplied-pmid 26083032?><pub-id pub-id-type="pmid">26083032</pub-id></mixed-citation>
    </ref>
    <ref id="pcbi.1011032.ref010">
      <label>10</label>
      <mixed-citation publication-type="journal"><name><surname>Berlin</surname><given-names>K</given-names></name>, <name><surname>Koren</surname><given-names>S</given-names></name>, <name><surname>Chin</surname><given-names>CS</given-names></name>, <name><surname>Drake</surname><given-names>JP</given-names></name>, <name><surname>Landolin</surname><given-names>JM</given-names></name>, <name><surname>Phillippy</surname><given-names>AM</given-names></name>. <article-title>Assembling large genomes with single-molecule sequencing and locality-sensitive hashing</article-title>. <source>Nature Biotechnology</source>. <year>2015</year><month>Jun</month>;<volume>33</volume>(<issue>6</issue>):<fpage>623</fpage>. <comment>doi: </comment><pub-id pub-id-type="doi">10.1038/nbt.3238</pub-id><?supplied-pmid 26006009?><pub-id pub-id-type="pmid">26006009</pub-id></mixed-citation>
    </ref>
    <ref id="pcbi.1011032.ref011">
      <label>11</label>
      <mixed-citation publication-type="journal"><name><surname>Zimin</surname><given-names>AV</given-names></name>, <name><surname>Puiu</surname><given-names>D</given-names></name>, <name><surname>Luo</surname><given-names>MC</given-names></name>, <name><surname>Zhu</surname><given-names>T</given-names></name>, <name><surname>Koren</surname><given-names>S</given-names></name>, <name><surname>Marçais</surname><given-names>G</given-names></name>, <etal>et al</etal>. <article-title>Hybrid assembly of the large and highly repetitive genome of Aegilops tauschii, a progenitor of bread wheat, with the MaSuRCA mega-reads algorithm</article-title>. <source>Genome Research</source>. <year>2017</year><month>May</month><day>1</day>;<volume>27</volume>(<issue>5</issue>):<fpage>787</fpage>–<lpage>92</lpage>. <comment>doi: </comment><pub-id pub-id-type="doi">10.1101/gr.213405.116</pub-id><?supplied-pmid 28130360?><pub-id pub-id-type="pmid">28130360</pub-id></mixed-citation>
    </ref>
    <ref id="pcbi.1011032.ref012">
      <label>12</label>
      <mixed-citation publication-type="journal"><name><surname>Li</surname><given-names>H</given-names></name>, <name><surname>Durbin</surname><given-names>R</given-names></name>. <article-title>Fast and accurate short read alignment with Burrows–Wheeler transform</article-title>. <source>Bioinformatics</source>. <year>2009</year><month>Jul</month><day>15</day>;<volume>25</volume>(<issue>14</issue>):<fpage>1754</fpage>–<lpage>60</lpage>. <comment>doi: </comment><pub-id pub-id-type="doi">10.1093/bioinformatics/btp324</pub-id><?supplied-pmid 19451168?><pub-id pub-id-type="pmid">19451168</pub-id></mixed-citation>
    </ref>
    <ref id="pcbi.1011032.ref013">
      <label>13</label>
      <mixed-citation publication-type="other">Garrison E, Marth G. Haplotype-based variant detection from short-read sequencing. arXiv preprint arXiv:1207.3907. 2012 Jul 17.</mixed-citation>
    </ref>
    <ref id="pcbi.1011032.ref014">
      <label>14</label>
      <mixed-citation publication-type="journal"><name><surname>Nurk</surname><given-names>S</given-names></name>, <name><surname>Koren</surname><given-names>S</given-names></name>, <name><surname>Rhie</surname><given-names>A</given-names></name>, <name><surname>Rautiainen</surname><given-names>M</given-names></name>, <name><surname>Bzikadze</surname><given-names>AV</given-names></name>, <name><surname>Mikheenko</surname><given-names>A</given-names></name>, <etal>et al</etal>. <article-title>The complete sequence of a human genome</article-title>. <source>Science</source>. <year>2022</year><month>Apr</month><day>1</day>;<volume>376</volume>(<issue>6588</issue>):<fpage>44</fpage>–<lpage>53</lpage>. <comment>doi: </comment><pub-id pub-id-type="doi">10.1126/science.abj6987</pub-id><?supplied-pmid 35357919?><pub-id pub-id-type="pmid">35357919</pub-id></mixed-citation>
    </ref>
    <ref id="pcbi.1011032.ref015">
      <label>15</label>
      <mixed-citation publication-type="journal"><name><surname>Shumate</surname><given-names>A</given-names></name>, <name><surname>Zimin</surname><given-names>AV</given-names></name>, <name><surname>Sherman</surname><given-names>RM</given-names></name>, <name><surname>Puiu</surname><given-names>D</given-names></name>, <name><surname>Wagner</surname><given-names>JM</given-names></name>, <name><surname>Olson</surname><given-names>ND</given-names></name>, <etal>et al</etal>. <article-title>Assembly and annotation of an Ashkenazi human reference genome</article-title>. <source>Genome biology</source>. <year>2020</year><month>Dec</month>;<volume>21</volume>(<issue>1</issue>):<fpage>1</fpage>–<lpage>8</lpage>. <comment>doi: </comment><pub-id pub-id-type="doi">10.1186/s13059-020-02047-7</pub-id><?supplied-pmid 32487205?><pub-id pub-id-type="pmid">32487205</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
