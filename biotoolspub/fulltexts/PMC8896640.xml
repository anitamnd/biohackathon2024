<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8896640</article-id>
    <article-id pub-id-type="pmid">34999766</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btac010</article-id>
    <article-id pub-id-type="publisher-id">btac010</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>CRAM 3.1: advances in the CRAM file format</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-6447-4112</contrib-id>
        <name>
          <surname>Bonfield</surname>
          <given-names>James K</given-names>
        </name>
        <xref rid="btac010-cor1" ref-type="corresp"/>
        <aff><institution>Informatics and Digital Solutions, Wellcome Sanger Institute, Wellcome Genome Campus</institution>, Hinxton CB10 1SA, <country country="GB">UK</country></aff>
        <!--jkb@sanger.ac.uk-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Birol</surname>
          <given-names>Inanc</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btac010-cor1">Email: <email>jkb@sanger.ac.uk</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <day>15</day>
      <month>3</month>
      <year>2022</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2022-01-06">
      <day>06</day>
      <month>1</month>
      <year>2022</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>06</day>
      <month>1</month>
      <year>2022</year>
    </pub-date>
    <volume>38</volume>
    <issue>6</issue>
    <fpage>1497</fpage>
    <lpage>1503</lpage>
    <history>
      <date date-type="received">
        <day>11</day>
        <month>10</month>
        <year>2021</year>
      </date>
      <date date-type="rev-recd">
        <day>14</day>
        <month>12</month>
        <year>2021</year>
      </date>
      <date date-type="editorial-decision">
        <day>03</day>
        <month>1</month>
        <year>2022</year>
      </date>
      <date date-type="accepted">
        <day>04</day>
        <month>1</month>
        <year>2022</year>
      </date>
      <date date-type="corrected-typeset">
        <day>13</day>
        <month>1</month>
        <year>2022</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2022. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2022</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btac010.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>CRAM has established itself as a high compression alternative to the BAM file format for DNA sequencing data. We describe updates to further improve this on modern sequencing instruments.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>With Illumina data CRAM 3.1 is 7–15% smaller than the equivalent CRAM 3.0 file, and 50–70% smaller than the corresponding BAM file. Long-read technology shows more modest compression due to the presence of high-entropy signals.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>The CRAM 3.0 specification is freely available from <ext-link xlink:href="https://samtools.github.io/hts-specs/CRAMv3.pdf" ext-link-type="uri">https://samtools.github.io/hts-specs/CRAMv3.pdf</ext-link>. The CRAM 3.1 improvements are available in a separate OpenSource HTScodecs library from <ext-link xlink:href="https://github.com/samtools/htscodecs" ext-link-type="uri">https://github.com/samtools/htscodecs</ext-link>, and have been incorporated into HTSlib.</p>
      </sec>
      <sec id="s5">
        <title>Supplementary information</title>
        <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Wellcome Trust</institution>
            <institution-id institution-id-type="DOI">10.13039/100010269</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>206194</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="7"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>It has been well established that the growth in genomic sequencing data is challenging (<xref rid="btac010-B24" ref-type="bibr">Stephens <italic toggle="yes">et al.</italic>, 2015</xref>). The earlier file formats of SAM and BAM (<xref rid="btac010-B20" ref-type="bibr">Li <italic toggle="yes">et al.</italic>, 2009</xref>) were appropriate for the era, but better techniques were soon required. The notion of reference-based compression, storing only the differences between DNA sequence fragments and the reference they have been aligned against, was proposed (<xref rid="btac010-B14" ref-type="bibr">Fritz <italic toggle="yes">et al.</italic>, 2011</xref>). Fritz <italic toggle="yes">et al.</italic> also proposed techniques for efficient encoding of unaligned data by the use of sequence assembly to generate consensus sequences, which may then be used as the reference sequence to compare against. This work leads to the development of CRAM by the European Bioinformatics Institute (<xref rid="btac010-B8" ref-type="bibr">Cochrane <italic toggle="yes">et al.</italic>, 2013</xref>).</p>
    <p>The primary goals of CRAM were a reduction in storage requirements, while maintaining direct compatibility with BAM, permitting lossless round trips. All data representable in BAM are also available in CRAM. This includes the SAM header, which is the same format in CRAM, and the optional auxiliary key-value ‘tags’. These annotations are defined by a shared SAMtags specification (<ext-link xlink:href="http://samtools.github.io/hts-specs/SAMtags.pdf" ext-link-type="uri">https://samtools.github.io/hts-specs/SAMtags.pdf</ext-link>).</p>
    <p>Although reference compression is where the original work focussed, it is wrong to assume that this is the primary reason for CRAM’s reduced file size. BAM serializes all data together (first name, chromosome, position, sequence, quality and auxiliary fields, then second name, chromosome and so on). This leads to poor compression ratios as names, sequences and quality values all have very different characteristics. CRAM has a column-oriented approach, where a block of names are compressed together or a block of qualities together. Each block can be compressed with an algorithm specific to that data type. This leads to significantly reduced file sizes and is often the biggest factor in file reduction.</p>
    <p>The first tool implementing CRAM (then version 1.0) was CRAMtools (Vadim Zalunin, 2011, unpublished data), written in Java. The Scramble tool (<xref rid="btac010-B2" ref-type="bibr">Bonfield, 2014</xref>) was the first C implementation and lead to a specification tidy-up producing CRAM 2.0 in 2013. HTSlib (<xref rid="btac010-B5" ref-type="bibr">Bonfield <italic toggle="yes">et al.</italic>, 2021</xref>) gained CRAM support shortly after. CRAM 3.0 appeared a year later in 2014, with some additional compression codecs including the rANS entropy encoder (<xref rid="btac010-B12" ref-type="bibr">Duda, 2013</xref>) and LZMA (Lempel Ziv Markov-chain Algorithm, Igor Pavlov, 1998, unpublished data). More implementations of CRAM have since appeared, written in JavaScript (<xref rid="btac010-B6" ref-type="bibr">Buels <italic toggle="yes">et al.</italic>, 2019</xref>) and Rust (<ext-link xlink:href="https://github.com/zaeleus/noodles" ext-link-type="uri">https://github.com/zaeleus/noodles</ext-link>). Many more programming languages support CRAM via bindings to one of these existing implementations.</p>
    <p>The CRAM specification is now maintained by the Global Alliance for Genomics and Health (GA4GH: <ext-link xlink:href="https://www.ga4gh.org/cram/" ext-link-type="uri">https://www.ga4gh.org/cram/</ext-link>). It ties in with a number of other GA4GH standards and protocols (<xref rid="btac010-B22" ref-type="bibr">Rehm <italic toggle="yes">et al.</italic>, 2021</xref>), which further extend the features and capabilities. Reference sequences may be obtained either via local files or using a refget server (<xref rid="btac010-B28" ref-type="bibr">Yates <italic toggle="yes">et al.</italic>, 2021</xref>). CRAM files can be streamed remotely using the htsget protocol (<xref rid="btac010-B18" ref-type="bibr">Kelleher <italic toggle="yes">et al.</italic>, 2019</xref>), and they may be encrypted using Crypt4GH (<xref rid="btac010-B23" ref-type="bibr">Senf <italic toggle="yes">et al.</italic>, 2021</xref>).</p>
    <p>Since 2014 CRAM has been very stable, but a lot has changed data-wise. Illumina’s quality values have been successively quantized from 40 discrete values, to 8, and now with NovaSeq to 4 (<xref rid="btac010-B17" ref-type="bibr">Illumina, 2012</xref>). We have also seen the rise of long-read technologies and more complex auxiliary data types being embedded in the files. As the data changes, so too should the encoding and compression methods available to the format. Methods, such as Run-Length Encoding (RLE), were considered and explicitly rejected as unhelpful in the original CRAM development, but now these same techniques can be beneficial. CRAM 3.1 is the first major update to CRAM since 2014. It keeps the underlying format unchanged, but adds new compression codecs. This is the first CRAM version to include data-type-specific codecs (for identifiers and quality scores), rather than relying on general purpose methods.</p>
    <p>With large data volumes come large processing requirements. By default, CRAM optimizes for a balance between CPU cost, file size and granularity of random access. However, the option of higher memory and CPU requirements for long-term archival is still worthy of consideration so CRAM 3.1 also improves support for archival modes.</p>
    <p>At the time of writing CRAM 3.1 is in draft. Implementations of the new codecs exist in C (HTSlib, SAMtools and Scramble) with a JavaScript proof of concept.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <p>The basic structure of CRAM can be seen in <xref rid="btac010-F1" ref-type="fig">Figure 1</xref>. It starts with a header matching the SAM specification, although it mandates the use of MD5sums on reference sequence lines for data provenance and to ensure correct decoding.</p>
    <fig position="float" id="btac010-F1">
      <label>Fig. 1.</label>
      <caption>
        <p>Logical layout of a CRAM file, showing containers and slices as rows, and data series as columns. Random access is possible on rows, with rapid filtering (discarding) of columns</p>
      </caption>
      <graphic xlink:href="btac010f1" position="float"/>
    </fig>
    <p>CRAM’s records are broken down into data series, loosely fitting the columns in a SAM file, such as alignment position, quality values or CIGAR string components. Each auxiliary tag also gets its own data series.</p>
    <p>The CRAM header is then followed by a series of containers, which in turn hold slices and data blocks within them. The container header consists of meta-data describing how and where each data series is encoded. The slices are collections of alignment records, applying the encoding rules described by the container to the records and storing the result in the requested blocks. The blocks are then compressed using their own selected compression algorithms. It is these algorithms, which have been added to in CRAM 3.1. Slices may be of any size, but the HTSlib implementation defaults to 10 000 records, or fewer if long reads are present.</p>
    <p>The self-describing nature of CRAM offers great flexibility to the encoder, meaning that over time encoder improvements may yield smaller files. For example, the first 10 million reads of a NovaSeq alignment in CRAM 3.0 format produced by HTSlib 1.2 takes up 199.6 MB. The latest HTSlib 1.13 encodes the same file in 195.2 MB and Picard 2.25.7 with default options uses 254.1 MB. All of these files are compatible and have the same choice of codecs available. The algorithms for selecting which codec to use are implementation specific and outside of the scope of both the CRAM specification and this manuscript, however details for how HTSlib adapts and learns the codecs to use are available in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>.</p>
    <p>As it is possible to store each data series in its own block, this permits selective decoding where only specific types of data need to be decoded. This can be of great benefit to certain algorithms. For example, the ‘samtools flagstat’ command gives a summary of SAM FLAG bit frequencies (<xref rid="btac010-B10" ref-type="bibr">Danecek <italic toggle="yes">et al.</italic>, 2021</xref>). Although it does not need to know about sequences, quality values or read identifiers, with a BAM file it is still required to decompress this data due to the serial nature of the format. With CRAM it only decompresses the data series required. Consequentially ‘samtools flagstat’ on the NA12878 Platinum Genomes file takes 7 min 5 s on the CRAM file and 22 min 52 s on the BAM file (with neither file in disc cache).</p>
    <p>The NM and MD SAM auxiliary tags have special handling within CRAM. As they describe the difference between an aligned sequence and the reference and we are typically doing reference-based compression, they may be omitted and generated on-the-fly during decode. If these values are found to be in error then they can either be corrected, or if we wish to have bug-compatible data then the (incorrect) values may be stored verbatim in the CRAM file.</p>
    <p>Each slice can optionally also contain a copy of the reference used for that genomic region. This permits CRAM to do reference-based compression while removing the dependency on external data files. For deeply covered regions this does not have a significant impact on compression ratios. This embedded reference could be a consensus rather than the official external reference, offering the potential for improved compression via fewer sequence differences. However, doing so means storing NM and MD verbatim in regions where consensus and reference differ, negating most of the gains. Note, this problem is resolved in Deez (<xref rid="btac010-B16" ref-type="bibr">Hach <italic toggle="yes">et al.</italic>, 2014</xref>) by using a two-level delta (sequence to consensus and consensus to reference), and may be considered for a future CRAM update.</p>
    <p>CRAM distinguishes between data encodings (what data series goes where and in what byte layout) as described by the container header, and compression codecs (what algorithm is used to compress the data blocks), which is described in the blocks themselves. The compression codecs permitted in CRAM 3.0 are three external general compression tools—deflate (<xref rid="btac010-B11" ref-type="bibr">Deutsch and Gailly, 1996</xref>), bzip2 and LZMA—and the rANS entropy encoder. The entropy encoder uses static frequencies, written at the start of the block, which can be either Order-0 or Order-1 metrics. An example of Order-0 frequencies is the observation that the letter ‘u’ accounts for 3% of the total letter usage in English, while an Order-1 observation is that ‘u’ occurs nearly 100% of the time following the letter ‘q’.</p>
    <p>The current official CRAM format is 3.0, but CRAM 3.1 has been a draft standard since 2019. The layout of the CRAM format is unchanged, but new custom compression codecs have been added. These include:</p>
    <p>
      <disp-quote content-type="extract">
        <p><bold>Improved rANS with data transformations:</bold> The reduction in the count of discrete quality values in Illumina data from 40 (early HiSeq) to 4 (NovaSeq) has meant that some simple data transformations can reduce both data size and time to encode. The updated rANS codec now performs 16-bit state renormalization instead of the earlier 8-bit step, for faster processing. Additionally, the four interleaved rANS states can now optionally be expanded to 32 states. Typically this is only applied on large blocks due to the extra overhead of storing an additional 28 states. This permits multiple efficient SIMD implementations (plus a non-SIMD ‘scalar’ version), all binary compatible with each other. Our software automatically selects the implementation based on the processor available.</p>
        <p>Additionally, data transformations can now be applied before entropy encoding:</p>
        <p><bold>RLE:</bold> RLE uses a Mespotine RLE variant (<xref rid="btac010-B21" ref-type="bibr">Mespotine, 2015</xref>), which stores a list of symbols for which runs are always stored (even if the additional run-length is zero). Symbols not in this list will never have a run-length attached (even if long). This is highly effective at reducing the size of data with stationary probabilities, such as quality values.</p>
        <p>The symbol literals and run-lengths are separated into two distinct data streams, each of which is compressed independently using rANS before concatenation together.</p>
        <p><bold>PACK:</bold> The bit-packing strategy initially counts the number of distinct symbols in the input data. If it is 2 or less, then each value is assigned 1 bit and we pack 8 into a byte, if it is 4 or less, each value consumes 2 bits (4 to a byte) and if it is 16 or less then each value consumes 4 bits (2 to a byte). The data stream starts with a small lookup table mapping symbols to bit-values. This is an extremely rapid way to reduce the data volume, speeding up the relatively slower entropy encoding part. It many cases it also boosts the compression ratio.</p>
        <p><bold>STRIPE:</bold> This de-interleaves data into N separate streams consisting of bytes at location <italic toggle="yes">Nx</italic> + <italic toggle="yes">c</italic> for 0 ≤ <italic toggle="yes">c</italic> &lt; <italic toggle="yes">N</italic>. For example, with <italic toggle="yes">N</italic> = 4 bytes 0,4,8,…, 1,5,9,…, 2,6,10,… and 3,7,11,… produce four streams. Each stream is then compressed using rANS, potentially also including further RLE and PACK transforms.</p>
        <p>Both RLE and PACK are highly effective at compressing Illumina’s 4-quantized quality values from the NovaSeq platform, while STRIPE is useful for 16-bit and 32-bit integer values. The name tokenizer (below) also makes extensive use of the rANS data transformations.</p>
        <p><bold>Adaptive arithmetic encoder:</bold> This is a byte-wise arithmetic codec with adaptively updated frequencies. This helps for data types with non-stationary probability distributions, but it has a significantly higher CPU overhead than rANS. It also includes the data transformations used in the updated rANS codec. However, the RLE method is more complex, using per symbol models of run-lengths instead of separating into literal and run-length streams.</p>
        <p>The adaptive arithmetic encoder is internally used by the FQZComp quality codec and optionally by the name tokenizer. It has Order-0 and Order-1 models, but being adaptive in nature (without the need to store large frequency tables) it could trivially be extended to support higher order models if deemed necessary in the future. These have not been added to date due to the usual desire to encode small blocks to permit fine-grained random access.</p>
        <p><bold>FQZComp quality encoder:</bold> This is a generalized version of the quality model used in the FQZComp tool (<xref rid="btac010-B3" ref-type="bibr">Bonfield and Mahoney, 2013</xref>). It is currently limited to a maximum of 16 bits of context in order to permit rapid model tuning and to make it appropriate for a more random-access-oriented file format. The context is applied to an adaptive arithmetic encoder. This makes it slower than rANS and more suitable to data archival. The construction of this context is flexible, offering great opportunity for learning and tuning to a specific dataset. The data format includes the model description, so changing models will not produce incompatible CRAM files. A variety of pre-defined models are used by our implementation, but this is something we expect to improve upon.</p>
      </disp-quote>
    </p>
    <p>Data available for model context generation include:</p>
    <p>
      <disp-quote content-type="extract">
        <p><bold>Previous quality values:</bold> shifted and bitwise-ORed together. Qualities can also be indirected via a lookup table, e.g. to first reduce the NovaSeq qualities to 2 bits.</p>
        <p><bold>Base</bold> <bold>position:</bold> the location along the current read (left to right). When coupled with a position lookup table this permits selection of specific cycles, exploiting any knowledge of good and bad cycles.</p>
        <p><bold>Cumulative difference:</bold> a counter that increments every time a quality value differs to the previous one, optionally quantized via a lookup table. The variation in quality values along a read is often indicative of future variation.</p>
        <p><bold>Selector bits:</bold> unlike the quality derived metrics above, the selector bits are copied verbatim from the data stream into the context. These are used for any data the encoder wishes to use to separate qualities values into discrete groups. Examples could be splitting by average quality value or clustering by <italic toggle="yes">x</italic>/<italic toggle="yes">y</italic> location extracted from the read name (e.g. flowcell edge effects or bubbles). This provides a lot of flexibility for future quality classification and clustering methods.</p>
        <p>There is scope for extending this to also include the adjacent sequence bases, for further improvement in PacBio and ONT quality encoding, but this would add interdependence between CRAM data series so such a change is delayed to CRAM 4.0.</p>
        <p>Additional reverse complement and duplicate record flags are used to control the orientation of the quality string or to copy a previous quality string. The description of how to compute the model context is written into the quality stream, meaning the decoder follows instructions written by the encoder, permitting considerable flexibility in encoder improvements.</p>
        <p>An example FQZComp configuration is shown in <xref rid="btac010-F2" ref-type="fig">Figure 2</xref>. </p>
      </disp-quote>
    </p>
    <fig position="float" id="btac010-F2">
      <label>Fig. 2.</label>
      <caption>
        <p>An example FQZComp configuration describing how previous quality values, the position in the sequence, a running sum of the quality differences (delta) and a generic model selector can be combined with lookup tables to generate a context model</p>
      </caption>
      <graphic xlink:href="btac010f2" position="float"/>
    </fig>
    <p><bold>Read name tokenizer:</bold> The read identifiers are often highly structured, such as ‘HSQ1004:134:C0D8DACXX:4:2107:20375:180666’. Much like how CRAM separates the primary SAM fields into columns, the name tokenizer separates the components of a read name. A tokenized prior identifier is used to compare against and the tokens are encoded in the context of these previous token values. Token types are:</p>
    <p>
      <disp-quote content-type="extract">
        <p><bold>CHAR:</bold> A single character.</p>
        <p><bold>ALPHA:</bold> A string of multiple characters.</p>
        <p><bold>DIGITS:</bold> A series of digits, up to 10 long. Longer runs of digits are broken down into multiple DIGITS tokens.</p>
        <p><bold>DIGITS0:</bold> A series of digits starting with 0 or more leading zeros.</p>
        <p><bold>MATCH:</bold> A flag to indicate this token exactly matches the same token position in the prior identifier.</p>
        <p><bold>DDELTA:</bold> Numeric delta against the number in the same tokenized column in the prior identifier. The delta must be between 0 and 255.</p>
        <p><bold>DDELTA0:</bold> Numeric delta with leading zeros. The number of leading zeros must match. The delta must be between 0 and 255. For example, 0123 and 0130 would use DDELTA0 7.</p>
        <p><bold>NOP:</bold> A token, which does nothing. This is used to ensure the number of tokens is consistent between identifiers, or to separate sets of token columns apart when two very different styles of read identifiers are mixed in the same input file.</p>
        <p><bold>END:</bold> A marker for the last token.</p>
        <p>These token types and their associated values are each stored in their own column-specific data streams, potentially producing a dozen or more streams. Each stream is then compressed using rANS or adaptive arithmetic codecs with their results then serialized together.</p>
        <p>The origins of this method also come from the FQZComp tool, although similar strategies were employed by many of the other SequenceSqueeze entries and subsequent derivations, with broadly similar results. This tokenizer was also successfully submitted to MPEG-G, hence the same tokenization scheme is used there (coupled to a different entropy encoder).</p>
      </disp-quote>
    </p>
    <p>CRAM also permits some controlled data loss. Read names may be discarded, with new names generated during decode. Read pairing within a slice is encoded by explicit links between records, so the generated names are still in pairs. Quality values may also be omitted, with only specific sites being stored. However, this is not the recommended approach to quality value reduction. It is possible to reduce the entropy of quality value either by smoothing methods, such as P-block (<xref rid="btac010-B7" ref-type="bibr">Cánovas <italic toggle="yes">et al.</italic>, 2014</xref>) or site-specific quality reassignment via CALQ (<xref rid="btac010-B25" ref-type="bibr">Voges <italic toggle="yes">et al.</italic>, 2018</xref>) or Crumble (<xref rid="btac010-B4" ref-type="bibr">Bonfield <italic toggle="yes">et al.</italic>, 2019</xref>). These modified quality strings are then much more compressible, particularly, when combined with the newer RLE rANS transform. As such, we view quality loss best dealt with as a topic external to the file format.</p>
    <p>The primary focus of CRAM is with sorted aligned data. However, SAM, BAM and CRAM all support unaligned data too and the addition of both per-file and per-read meta-data arguably make these a superior format to using FASTQ. There are many FASTQ compression tools, which offer superior ratios to unaligned CRAM, but our approach to FASTQ is primarily as a transitional format between sequencing and either alignment or assembly rather than as a suitable long-term archival format. That said, combining an approximate rapid sequence aligner with CRAM can be used to reduce data size. Examples of this using SNAP (<xref rid="btac010-B29" ref-type="bibr">Zaharia <italic toggle="yes">et al.</italic>, 2011</xref>) are in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>.</p>
    <p>CRAM may also store non-position-sorted data, such as sorted by read name order. Sequences may use either reference-based or reference-less encoding, with the latter sometimes being a more time and memory performant option when dealing with unsorted data from very large genomes.</p>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>This manuscript is on improvements to the CRAM format rather than a specific implementation, however, it is not possible to analyse the performance of the format without evaluating an implementation. We use SAMtools and HTSlib 1.13. Where possible, we also compare against Deez, MPEG-G and Genozip (<xref rid="btac010-B19" ref-type="bibr">Lan <italic toggle="yes">et al.</italic>, 2021</xref>). The GenomSys MPEG-G tool is not freely available so figures reported are taken from their paper and its references. Note, their CRAM figures significantly differ to ours. We requested clarification from the authors, but received no reply and some of these differences remain unexplained.</p>
    <p>Benchmarks for the new codecs in isolation, outside of CRAM, can be seen in the tables below.</p>
    <p><xref rid="btac010-T1" ref-type="table">Table 1</xref> shows entropy encoder speeds for the first 1 million records from NovaSeq data. Speeds on HiSeq 2000 qualities are listed in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>. Also shown are other static frequency entropy encoders including Zlib’s Huffman encoder and the Finite State Entropy (FSE) implementation used in Zstd (<xref rid="btac010-B9" ref-type="bibr">Collet, 2021</xref>). These only support Order-0 encoding and Huffman is unable to encode the skewed 4-quality NovaSeq data efficiently.</p>
    <table-wrap position="float" id="btac010-T1">
      <label>Table 1.</label>
      <caption>
        <p>NovaSeq quality: entropy encoder speeds</p>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="1" colspan="1">Program</th>
            <th rowspan="1" colspan="1">Option</th>
            <th rowspan="1" colspan="1">Size (MB)</th>
            <th rowspan="1" colspan="1">Enc (MB/s)</th>
            <th rowspan="1" colspan="1">Dec (MB/s)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">Zlib</td>
            <td rowspan="1" colspan="1">Huffman</td>
            <td rowspan="1" colspan="1">21.48</td>
            <td rowspan="1" colspan="1">151</td>
            <td rowspan="1" colspan="1">365</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">FSE</td>
            <td rowspan="1" colspan="1">tANS</td>
            <td rowspan="1" colspan="1">9.90</td>
            <td rowspan="1" colspan="1">435</td>
            <td rowspan="1" colspan="1">531</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">FSE</td>
            <td rowspan="1" colspan="1">Huffman</td>
            <td rowspan="1" colspan="1">20.74</td>
            <td rowspan="1" colspan="1">710</td>
            <td rowspan="1" colspan="1">1303</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">rANS4x8</td>
            <td rowspan="1" colspan="1">O0</td>
            <td rowspan="1" colspan="1">9.91</td>
            <td rowspan="1" colspan="1">405</td>
            <td rowspan="1" colspan="1">624</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">rANS4x16</td>
            <td rowspan="1" colspan="1">O0</td>
            <td rowspan="1" colspan="1">9.90</td>
            <td rowspan="1" colspan="1">426</td>
            <td rowspan="1" colspan="1">797</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">rANS32x16-AVX2</td>
            <td rowspan="1" colspan="1">O0</td>
            <td rowspan="1" colspan="1">9.92</td>
            <td rowspan="1" colspan="1">709</td>
            <td rowspan="1" colspan="1">1949</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">rANS4x8</td>
            <td rowspan="1" colspan="1">O1</td>
            <td rowspan="1" colspan="1">9.14</td>
            <td rowspan="1" colspan="1">291</td>
            <td rowspan="1" colspan="1">408</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">rANS4x16</td>
            <td rowspan="1" colspan="1">O1</td>
            <td rowspan="1" colspan="1">9.14</td>
            <td rowspan="1" colspan="1">304</td>
            <td rowspan="1" colspan="1">608</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">rANS32x16-AVX2</td>
            <td rowspan="1" colspan="1">O1</td>
            <td rowspan="1" colspan="1">9.16</td>
            <td rowspan="1" colspan="1">430</td>
            <td rowspan="1" colspan="1">1484</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">rANS32x16-AVX512</td>
            <td rowspan="1" colspan="1">O0, PACK+RLE</td>
            <td rowspan="1" colspan="1">9.17</td>
            <td rowspan="1" colspan="1">627</td>
            <td rowspan="1" colspan="1">1302</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">rANS32x16-AVX512</td>
            <td rowspan="1" colspan="1">O1, PACK+RLE</td>
            <td rowspan="1" colspan="1">8.26</td>
            <td rowspan="1" colspan="1">533</td>
            <td rowspan="1" colspan="1">1078</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">arith</td>
            <td rowspan="1" colspan="1">O0</td>
            <td rowspan="1" colspan="1">9.83</td>
            <td rowspan="1" colspan="1">120</td>
            <td rowspan="1" colspan="1">94</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">arith</td>
            <td rowspan="1" colspan="1">O0, PACK+RLE</td>
            <td rowspan="1" colspan="1">9.16</td>
            <td rowspan="1" colspan="1">220</td>
            <td rowspan="1" colspan="1">188</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">arith</td>
            <td rowspan="1" colspan="1">O1</td>
            <td rowspan="1" colspan="1">9.12</td>
            <td rowspan="1" colspan="1">105</td>
            <td rowspan="1" colspan="1">91</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">arith</td>
            <td rowspan="1" colspan="1">O1, PACK+RLE</td>
            <td rowspan="1" colspan="1">8.12</td>
            <td rowspan="1" colspan="1">156</td>
            <td rowspan="1" colspan="1">115</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">GABAC-app</td>
            <td rowspan="1" colspan="1">−d15 -s1</td>
            <td rowspan="1" colspan="1">8.40</td>
            <td rowspan="1" colspan="1">5</td>
            <td rowspan="1" colspan="1">8</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <fn id="tblfn1">
          <p><italic toggle="yes">Note</italic>: Block size 1 MB, except FSE Huffman, which used 128 KB. Figures produced using the unroll32 branch (git hash 9e9c3f7) from <ext-link xlink:href="https://github.com/jkbonfield/htscodecs" ext-link-type="uri">https://github.com/jkbonfield/htscodecs</ext-link>. The test system self-reported as "Intel(R) Xeon(R) Gold 6242 CPU @ 2.80GHz". (Note this differs to the full CRAM benchmarks, due to the desite to include AVX2 and AVX512 figures.)</p>
        </fn>
      </table-wrap-foot>
    </table-wrap>
    <p>This table also shows performance of the adaptive coder along with the Genomic Adaptive Binary Arithmetic Coder (GABAC) (<xref rid="btac010-B26" ref-type="bibr">Voges <italic toggle="yes">et al.</italic>, 2020</xref>) used in the OpenSource Genie (<xref rid="btac010-B1" ref-type="bibr">Bliss <italic toggle="yes">et al.</italic>, 2018</xref>) reference implementation of MPEG-G (<xref rid="btac010-B27" ref-type="bibr">Voges <italic toggle="yes">et al.</italic>, 2021</xref>). This latter provides a reasonable ratio for the low-entropy NovaSeq dataset, but is two orders of magnitude slower than the faster methods. Note, this may not be indicative of a well optimized GABAC implementation.</p>
    <p><xref rid="btac010-T2" ref-type="table">Table 2</xref> shows the performance of two pre-defined FQZComp configurations on high-entropy HiSeq 2000 quality values and low-entropy NovaSeq quality values, compared against libbsc and the original FQZComp FASTQ compression tool. It can be seen that the choice of model configuration can be critical, as well as demonstrating advances in the FQZComp parameters made since the original release. This particular set of HiSeq 2000 data has some highly erroneous cycles, so using more bits to track position within the read is very productive. Additionally, this model utilizes the embedded selector bits to separate data by READ1 and READ2 flags, slightly improving the compression of the NovaSeq data too.</p>
    <table-wrap position="float" id="btac010-T2">
      <label>Table 2.</label>
      <caption>
        <p>Quality value FQZComp performance</p>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="center" span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="1" colspan="1">Program</th>
            <th rowspan="1" colspan="1">Option</th>
            <th rowspan="1" colspan="1">Size (MB)</th>
            <th rowspan="1" colspan="1">Enc (MB/s)</th>
            <th rowspan="1" colspan="1">Dec (MB/s)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">NovaSeq qualities</td>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"> bsc-3.1.7</td>
            <td rowspan="1" colspan="1">−m0e2tTp</td>
            <td rowspan="1" colspan="1">7.72</td>
            <td rowspan="1" colspan="1">19.3</td>
            <td rowspan="1" colspan="1">35.8</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"> FQZComp-4.6</td>
            <td rowspan="1" colspan="1">−q2</td>
            <td rowspan="1" colspan="1">8.12</td>
            <td rowspan="1" colspan="1">46.2</td>
            <td rowspan="1" colspan="1">40.8</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"> FQZComp-4.6</td>
            <td rowspan="1" colspan="1">−q3</td>
            <td rowspan="1" colspan="1">7.72</td>
            <td rowspan="1" colspan="1">41.9</td>
            <td rowspan="1" colspan="1">37.8</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"> CRAM FQZComp</td>
            <td rowspan="1" colspan="1">−s0</td>
            <td rowspan="1" colspan="1">7.27</td>
            <td rowspan="1" colspan="1">28.6</td>
            <td rowspan="1" colspan="1">51.8</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"> CRAM FQZComp</td>
            <td rowspan="1" colspan="1">−s1+read 1/2</td>
            <td rowspan="1" colspan="1">7.21</td>
            <td rowspan="1" colspan="1">21.4</td>
            <td rowspan="1" colspan="1">26.7</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">HiSeq 2000 qualities</td>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"> bsc-3.1.7</td>
            <td rowspan="1" colspan="1">−m0e2tTp</td>
            <td rowspan="1" colspan="1">42.6</td>
            <td rowspan="1" colspan="1">6.5</td>
            <td rowspan="1" colspan="1">9.4</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"> FQZComp-4.6</td>
            <td rowspan="1" colspan="1">−q2</td>
            <td rowspan="1" colspan="1">44.9</td>
            <td rowspan="1" colspan="1">23.3</td>
            <td rowspan="1" colspan="1">20.0</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"> FQZComp-4.6</td>
            <td rowspan="1" colspan="1">−q3</td>
            <td rowspan="1" colspan="1">41.0</td>
            <td rowspan="1" colspan="1">19.6</td>
            <td rowspan="1" colspan="1">16.7</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"> CRAM FQZComp</td>
            <td rowspan="1" colspan="1">−s0</td>
            <td rowspan="1" colspan="1">42.5</td>
            <td rowspan="1" colspan="1">15.8</td>
            <td rowspan="1" colspan="1">17.8</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"> CRAM FQZComp</td>
            <td rowspan="1" colspan="1">−s1+read 1/2</td>
            <td rowspan="1" colspan="1">31.3</td>
            <td rowspan="1" colspan="1">13.3</td>
            <td rowspan="1" colspan="1">14.9</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <fn id="tblfn2">
          <p><italic toggle="yes">Note</italic>: Compression of NovaSeq and HiSeq 2000 quality values using libbsc, CRAM 3.1’s FQZComp and the original FQZComp-4.6 tool, in 10 blocks of 100 000 records. This uses the same htscodecs branch and test system as the rANS benchmark in Table 1.</p>
        </fn>
      </table-wrap-foot>
    </table-wrap>
    <p><xref rid="btac010-T3" ref-type="table">Table 3</xref> shows the performance of the name tokenizer on 10 blocks each containing 100 000 NovaSeq read names. The tokenizer is considerably smaller than general purpose tools on the more predictable name-sorted data. With chromosome and position sorted data, which scrambles the name ordering, the tokenizer is only beaten by the much slower ‘mcm’ tool.</p>
    <table-wrap position="float" id="btac010-T3">
      <label>Table 3.</label>
      <caption>
        <p>NovaSeq read name compression</p>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="1" colspan="1"/>
            <th colspan="3" align="center" rowspan="1">Name sorted<hr/></th>
            <th colspan="3" align="center" rowspan="1">Position sorted<hr/></th>
          </tr>
          <tr>
            <th rowspan="1" colspan="1">Program</th>
            <th rowspan="1" colspan="1">Size</th>
            <th rowspan="1" colspan="1">Enc (MB/s)</th>
            <th rowspan="1" colspan="1">Dec (MB/s)</th>
            <th rowspan="1" colspan="1">Size</th>
            <th rowspan="1" colspan="1">Enc (MB/s)</th>
            <th rowspan="1" colspan="1">Dec (MB/s)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">bzip2</td>
            <td rowspan="1" colspan="1">2.52</td>
            <td rowspan="1" colspan="1">32.08</td>
            <td rowspan="1" colspan="1">222.11</td>
            <td rowspan="1" colspan="1">6.18</td>
            <td rowspan="1" colspan="1">15.97</td>
            <td rowspan="1" colspan="1">137.88</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">gzip -12</td>
            <td rowspan="1" colspan="1">2.14</td>
            <td rowspan="1" colspan="1">3.78</td>
            <td rowspan="1" colspan="1">250.59</td>
            <td rowspan="1" colspan="1">5.50</td>
            <td rowspan="1" colspan="1">2.80</td>
            <td rowspan="1" colspan="1">241.93</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">bsc -m5e1tT</td>
            <td rowspan="1" colspan="1">1.68</td>
            <td rowspan="1" colspan="1">27.61</td>
            <td rowspan="1" colspan="1">23.07</td>
            <td rowspan="1" colspan="1">3.99</td>
            <td rowspan="1" colspan="1">22.59</td>
            <td rowspan="1" colspan="1">19.53</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">xz -9</td>
            <td rowspan="1" colspan="1">1.31</td>
            <td rowspan="1" colspan="1">2.50</td>
            <td rowspan="1" colspan="1">74.98</td>
            <td rowspan="1" colspan="1">4.87</td>
            <td rowspan="1" colspan="1">1.70</td>
            <td rowspan="1" colspan="1">65.31</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">mcm -m7</td>
            <td rowspan="1" colspan="1">1.22</td>
            <td rowspan="1" colspan="1">3.07</td>
            <td rowspan="1" colspan="1">3.21</td>
            <td rowspan="1" colspan="1">3.43</td>
            <td rowspan="1" colspan="1">2.69</td>
            <td rowspan="1" colspan="1">2.78</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">tok3 -3</td>
            <td rowspan="1" colspan="1">1.11</td>
            <td rowspan="1" colspan="1">24.68</td>
            <td rowspan="1" colspan="1">49.61</td>
            <td rowspan="1" colspan="1">3.55</td>
            <td rowspan="1" colspan="1">22.98</td>
            <td rowspan="1" colspan="1">67.84</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">tok3 -7</td>
            <td rowspan="1" colspan="1">0.89</td>
            <td rowspan="1" colspan="1">15.46</td>
            <td rowspan="1" colspan="1">48.54</td>
            <td rowspan="1" colspan="1">3.55</td>
            <td rowspan="1" colspan="1">10.00</td>
            <td rowspan="1" colspan="1">69.44</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">tok3 -19</td>
            <td rowspan="1" colspan="1">0.88</td>
            <td rowspan="1" colspan="1">8.82</td>
            <td rowspan="1" colspan="1">41.59</td>
            <td rowspan="1" colspan="1">3.48</td>
            <td rowspan="1" colspan="1">4.84</td>
            <td rowspan="1" colspan="1">39.13</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <fn id="tblfn3">
          <p><italic toggle="yes">Note</italic>: Performance of the read name tokenizer on name sorted and chromosome/position sorted NovaSeq reads. Size is shown in MB. Tok3 compression levels −3 and −7 use the rANS entropy encoder at low and medium tokenization levels, while −19 is the maximum compression level using adaptive arithmetic encoding. This uses the same htscodecs branch and test system as the rANS benchmark in Table 1.</p>
        </fn>
      </table-wrap-foot>
    </table-wrap>
    <p>Overall CRAM performance is not a single metric as it permits user-adjustable trade-offs between speed, size and granularity of random access. To a lesser extent this is true for BAM too with differing Deflate compression levels. We provide data for multiple format versions as well at several compression levels. The CRAM benchmarks are from the released version of SAMtools 1.13. Note, this does not yet include the SIMD-vectorized rANS entropy encoder and is using the 4-way Scalar implementation. Results using a vectorized build of SAMtools are presented in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>.</p>
    <p>All decode timings are a read and complete decode of the files, with data discarded where possible. Encode timings are conversion from compressed BAM to a new file format. Full benchmarks and details are available in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>. The encoder and decoder were given 12 threads, using an Intel Xeon CPU E5-2660 running at 2.20 GHz. The quoted MPEG-G timings used 12 threads on an Intel Xeon E5-2670 at 2.6 GHz. Clock speeds for both systems are as reported by Intel, but may be subject to automatic boosting.</p>
    <p><xref rid="btac010-F3" ref-type="fig">Figure 3</xref> shows the results for the Illumina HiSeq 2000 (ERR194147), Illumina NovaSeq (ERR3239334) and PacBio CLR (<ext-link xlink:href="http://ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/technical/working/20131209_na12878_pacbio/si/NA12878.pacbio.bwa-sw.20140202.bam" ext-link-type="uri">ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/technical/working/20131209_na12878_pacbio/si/NA12878.pacbio.bwa-sw.20140202.bam</ext-link>). All three are Whole-Genome Shotgun libraries of NA12878.</p>
    <fig position="float" id="btac010-F3">
      <label>Fig. 3.</label>
      <caption>
        <p>Benchmarks of aligned data formats using 12 threads. MPEG-G figures are taken from the Voges <italic toggle="yes">et al.</italic> paper, with ‘MPEG-G (est.)’ possibly using a slightly different input file (see text). Genozip 12 and Genozip 13 refer to versions 12.0.34 and 13.0.5, respectively, with the latter being released after the initial preprint publication and during manuscript review. Parts A, B and C show results for Human sample NA12878 sequenced using Illumina HiSeq2000, NovaSeq and PacBio CLR respectively. </p>
      </caption>
      <graphic xlink:href="btac010f3" position="float"/>
    </fig>
    <p><xref rid="btac010-F3" ref-type="fig">Figure 3A</xref> shows the encode and decode speeds against file size for the Illumina HiSeq 2000 data (ERR194147). This is also MPEG-G dataset 02. Some formats have multiple points, linked together by a line. This represents different compression profiles used by the tools. In BAM, this adjusts the libdeflate compression levels to 6, 10 and the maximum of 12.</p>
    <p>CRAM charts show profiles ‘normal’, ‘small’, ‘archive’ and ‘archive’ at compression level 9. The default ‘normal’ profile only uses the rANS codec and Deflate. The ‘small’ profile increases the block size and enables Bzip2 compression and in CRAM 3.1 the FQZComp codec. The ‘archive’ profile further increases block size, boosts the deflate compression level and in CRAM 3.1 enables the adaptive arithmetic coder. At compression level 8 and above the LZMA codec is also enabled for all CRAM versions. This has a significant cost to compression time so is often not a good speed/size trade-off, but is still fast at decoding.</p>
    <p>It can be seen that CRAM 3.1 offers a similar leap over CRAM 3.0 compression ratios that it did in turn over CRAM 2.1. CRAM 3.1 is between 7% and 16% smaller than CRAM 3.0 at the equivalent profile, while being similar on speed except for ‘small’ and ‘archive’ decoding times. All CRAMs except those using LZMA encode faster than their BAM equivalents, while saving up to 56% storage, although BAM is quicker to decode. This is compatible with our design goal of being similar speed to BAM.</p>
    <p>It is unclear whether the published MPEG-G benchmarks include auxiliary tags, but these only account for under 1% of this file. CRAM 3.1’s compression profiles straddle the MPEG-G file size, with the ‘small’ CRAM profile being both smaller and four times faster than MPEG-G. However, note the MPEG-G benchmarks were not performed by us, so there may be differences in measuring techniques.</p>
    <p>Deez compression ratios are between CRAM 3.0 and CRAM 3.1 and a little behind MPEG-G. It is the slowest tool, although it should be noted that despite being given 12 threads it typically only utilized 2. Total CPU usage was less than MPEG-G. Genozip was also much slower than CRAM 3.1 while being larger, although during manuscript review updated versions of Genozip were released which are considerably closer on file size, with the most recent versions incorporating the CRAM codecs described here.</p>
    <p><xref rid="btac010-F3" ref-type="fig">Figure 3B</xref> shows the same NA12878 sample sequenced using an Illumina NovaSeq instrument (ERR3239334). The improvements of CRAM over BAM here are more marked, due to the higher compressibility of the quantized quality values. The gains from CRAM 3.0 to CRAM 3.1 are also greater, with the ‘normal’ profile being 16% smaller. The CRAM 3.1 files are between 3.1 and 3.5 times smaller than BAM.</p>
    <p>As before, Deez is slow and with this file does not match CRAM 3.0 for file size. No MPEG-G results are available for this dataset, but the published results for the NovaSeq MPEG-G dataset 37 implies good compression performance with a size similar to CRAM 3.1 archive mode. Genozip initially performed poorly, with file sizes larger than CRAM and considerably slower, while the recent revision gave superior compression ratios. The gain over CRAM 3.1 is almost entirely in the XA:Z auxiliary tags, which are abnormally large in this dataset. The latest Genozip releases now also integrate the new CRAM compression codecs described here.</p>
    <p><xref rid="btac010-F3" ref-type="fig">Figure 3C</xref> shows an aligned PacBio CLR file, also for NA12878. This is the MPEG-G dataset 03. Published results are available for MPEG-G on this data, but we were only able to get our BAM and CRAM files to match their earlier published results (MPEG document M56361) by removing secondary alignments and discarding auxiliary tags. Hence, for comparison purposes, we applied these transformations to the downloaded BAM before performing this benchmark. We have been unable to verify with the authors if this is the correct procedure used in the MPEG-G publication, so it is listed here as ‘MPEG-G (est.)’.</p>
    <p>This dataset shows a very minimal change between CRAM versions and compression profiles. The file is dominated by the quality values, which are largely uncompressible due to having a big range of discrete values (0–93) with very little correlation between successive values. Nevertheless, it is evident that CRAM saves a significant portion over BAM and CRAM 3.0/3.1 is a big improvement on the historic CRAM 2.1. The assumed MPEG-G size, Deez and Genozip 12 are all larger than CRAM 3.0 while being significantly slower. The most recent Genozip release has incorporated the quality encoding from ENANO (<xref rid="btac010-B13" ref-type="bibr">Dufort y Álvarez <italic toggle="yes">et al.</italic>, 2020</xref>), which utilizes sequence bases as a context for quality encoding. This has a significant reduction to PacBio size, but restrictives selective decoding of individual data types and has a significant CPU overhead. Nonetheless use of sequence as a context may be considered for future CRAM releases.</p>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>CRAM has achieved the goals of providing a space-efficient alternative to BAM, while not suffering a significant time penalty. CRAM files in the European Nucleotide Archive significantly outnumber BAMs (personal communication) and it has seen wide adoption at many other sites. While some other tools are now smaller than CRAM 3.0 on some data files, this typically comes at a heavy cost in CPU. We demonstrate with CRAM 3.1 that changing just one component of the CRAM format, the compression codecs available, is sufficient for CRAM to remain competitive on size while not sacrificing its speed advantage. We also expect CRAM 3.1 to continue to improve as we learn how best to tune each codec, in particular the selection of the optimal FQZComp models.</p>
    <p>However, there are wider format adjustments that could be made over and above adding new compression codecs, which will be addressed in CRAM 4.0. While an early draft of this already exists, CRAM 4.0 is likely to undergo further revisions. Improvements include migration of the rANS PACK and RLE filters to the CRAM slice encoding methods with additional transformations, such as integer delta encoding (useful for Oxford Nanopore Technology signal data) and an LZP step to help reduce repetitive auxiliary tags and to remove duplication in quality values due to secondary alignments. Further custom codecs may also need to be developed for the most expensive auxiliary tags, such as breaking down comma-separated tag formats (e.g. SA:Z and XA:Z) into components similar to the read name tokenizer. The general purpose compression interfaces used may also be reconsidered, such as replacing Deflate with Zstd and Bzip2 with Libbsc (<xref rid="btac010-B15" ref-type="bibr">Grebnov, 2011</xref>). There is scope for moving some compression meta-data, such as the Order-1 frequency tables in rANS, out of the data block produced by compression codecs and into the container header. This could permit more fine-grained random access with many slices per container sharing the same meta-data. Finally, improvements can be made to how embedded consensus sequences are handled, perhaps using a two-step delta as implemented in Deez.</p>
    <p>It is evident however that some data does not gain compression with CRAM 3.1 due to the inherent randomness of the data held within, and no format improvement is likely to solve that. This is particularly true for some long-read technologies. We question the requirement to have so many distinct quality values in PacBio and ONT data and suggest lossy compression may be suitable for these datasets, prior to encoding in CRAM. We feel that this is best researched and addressed by the sequencing manufacturers and urge them to consider ways to reduce the data footprint of their output files.</p>
    <p>An implementation of the CRAM 3.1 and 4.0 draft standards may be found in HTSlib (<ext-link xlink:href="https://github.com/samtools/htslib" ext-link-type="uri">https://github.com/samtools/htslib</ext-link>). The individual codecs used are available as a separate library to permit use in other applications: HTScodecs (<ext-link xlink:href="https://github.com/samtools/htscodecs" ext-link-type="uri">https://github.com/samtools/htscodecs</ext-link>).</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btac010_Supplementary_Data</label>
      <media xlink:href="btac010_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>Vadim Zalunin (European Bioinformatics Institute) was instrumental in producing the first production-ready implementation of CRAM, upon which the rest of this work sits. We would also like to thank Chris Norman (Broad Institute) for his work as a co-maintainer of the CRAM specification and continued support for CRAM within htsjdk. The Order-0 rANS codec was based on work by Fabian Giesen and the arithmetic coder includes work by Eugene Shelwien. Andrew Whitwham proof read the paper and Rob Davies performed code reviews, both from Wellcome Sanger Institute.</p>
    <sec sec-type="data-availability">
      <title>Data availability</title>
      <p>The data underlying this article are available in the European Nucleotide Archives (ERR3239334, ERR194147) and 1000 Genomes Project ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/technical/working/20131209_na12878_pacbio/si/NA12878.pacbio.bwa-sw.20140202.bam). The NovaSeq and HiSeq data used for testing the entropy encoders are available from ftp://ftp.sanger.ac.uk/pub/users/jkb/CRAM3.1/. Scripts for benchmarking are available from <ext-link xlink:href="https://github.com/jkbonfield/cram31_bench" ext-link-type="uri">https://github.com/jkbonfield/cram31_bench</ext-link>.</p>
    </sec>
    <sec>
      <title>Funding</title>
      <p>This research was funded in whole, or in part, by the Wellcome Trust [206194]. For the purpose of Open Access, the author has applied a CC BY public copyright licence to any Author Accepted Manuscript version arising from this submission.</p>
      <p><italic toggle="yes">Conflict of Interest</italic>: none declared. </p>
    </sec>
  </ack>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btac010-B1">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Bliss</surname><given-names>B.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) Genie: an MPEG-G conformant software to compress genomic data.</mixed-citation>
    </ref>
    <ref id="btac010-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bonfield</surname><given-names>J.K.</given-names></string-name></person-group> (<year>2014</year>) <article-title>The scramble conversion tool</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>2818</fpage>–<lpage>2819</lpage>.<pub-id pub-id-type="pmid">24930138</pub-id></mixed-citation>
    </ref>
    <ref id="btac010-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bonfield</surname><given-names>J.K.</given-names></string-name>, <string-name><surname>Mahoney</surname><given-names>M.V.</given-names></string-name></person-group> (<year>2013</year>) <article-title>Compression of FASTQ and SAM format sequencing data</article-title>. <source>PLoS One</source>, <volume>8</volume>, <fpage>e59190</fpage>.<pub-id pub-id-type="pmid">23533605</pub-id></mixed-citation>
    </ref>
    <ref id="btac010-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bonfield</surname><given-names>J.K.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>Crumble: reference free lossy compression of sequence quality values</article-title>. <source>Bioinformatics</source>, <volume>35</volume>, <fpage>337</fpage>–<lpage>339</lpage>.<pub-id pub-id-type="pmid">29992288</pub-id></mixed-citation>
    </ref>
    <ref id="btac010-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bonfield</surname><given-names>J.K.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2021</year>) <article-title>HTSlib: C library for reading/writing high-throughput sequencing data</article-title>. <source>Gigascience</source>, <volume>10</volume>, <fpage>giab007</fpage>.<pub-id pub-id-type="pmid">33594436</pub-id></mixed-citation>
    </ref>
    <ref id="btac010-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Buels</surname><given-names>R.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>Cram-JS: reference-based decompression in node and the browser</article-title>. <source>Bioinformatics</source>, <volume>35</volume>, <fpage>4451</fpage>–<lpage>4452</lpage>.<pub-id pub-id-type="pmid">31099383</pub-id></mixed-citation>
    </ref>
    <ref id="btac010-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cánovas</surname><given-names>R.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) <article-title>Lossy compression of quality scores in genomic data</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>2130</fpage>–<lpage>2136</lpage>.<pub-id pub-id-type="pmid">24728856</pub-id></mixed-citation>
    </ref>
    <ref id="btac010-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cochrane</surname><given-names>G.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2013</year>) <article-title>Facing growth in the European nucleotide archive</article-title>. <source>Nucleic Acids Res</source>., <volume>41</volume>, <fpage>D30</fpage>–<lpage>D35</lpage>.<pub-id pub-id-type="pmid">23203883</pub-id></mixed-citation>
    </ref>
    <ref id="btac010-B9">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Collet</surname><given-names>Y.</given-names></string-name></person-group> (<year>2021</year>) Zstandard Compression and the ’application/zstd’ Media Type. RFC 8878, RFC Editor.</mixed-citation>
    </ref>
    <ref id="btac010-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Danecek</surname><given-names>P.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2021</year>) <article-title>Twelve years of SAMtools and BCFtools</article-title>. <source>Gigascience</source>, <volume>10</volume>, <fpage>giab008</fpage>.<pub-id pub-id-type="pmid">33590861</pub-id></mixed-citation>
    </ref>
    <ref id="btac010-B11">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Deutsch</surname><given-names>P.</given-names></string-name>, <string-name><surname>Gailly</surname><given-names>J.L.</given-names></string-name></person-group> (<year>1996</year>) Zlib compressed data format specification version 3.3. RFC 1950, RFC Editor.</mixed-citation>
    </ref>
    <ref id="btac010-B12">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Duda</surname><given-names>J.</given-names></string-name></person-group> (<year>2013</year>) <article-title>Asymmetric numeral systems: entropy coding combining speed of Huffman coding with compression rate of arithmetic coding</article-title>. arXiv:1311.2540.</mixed-citation>
    </ref>
    <ref id="btac010-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Dufort y Álvarez</surname><given-names>G.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2020</year>) <article-title>ENANO: encoder for NANOpore FASTQ files</article-title>. <source>Bioinformatics</source>, <volume>36</volume>, <fpage>4506</fpage>–<lpage>4507</lpage>.<pub-id pub-id-type="pmid">32470109</pub-id></mixed-citation>
    </ref>
    <ref id="btac010-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Fritz</surname><given-names>M.H.-Y.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2011</year>) <article-title>Efficient storage of high throughput DNA sequencing data using reference-based compression</article-title>. <source>Genome Res</source>., <volume>21</volume>, <fpage>734</fpage>–<lpage>740</lpage>.<pub-id pub-id-type="pmid">21245279</pub-id></mixed-citation>
    </ref>
    <ref id="btac010-B15">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Grebnov</surname><given-names>I.</given-names></string-name></person-group> (<year>2011</year>) libbsc: a high performance data compression library. https://github.com/IlyaGrebnov/libbsc.</mixed-citation>
    </ref>
    <ref id="btac010-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Hach</surname><given-names>F.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) <article-title>DeeZ: reference-based compression by local assembly</article-title>. <source>Nat. Methods</source>, <volume>11</volume>, <fpage>1082</fpage>–<lpage>1084</lpage>.<pub-id pub-id-type="pmid">25357237</pub-id></mixed-citation>
    </ref>
    <ref id="btac010-B17">
      <mixed-citation publication-type="other">Illumina (<year>2012</year>) Reducing whole-genome data storage footprint. <italic toggle="yes">Technical report</italic>. <ext-link xlink:href="http://res.illumina.com/documents/products/whitepapers/whitepaper_datacompression.pdf" ext-link-type="uri">http://res.illumina.com/documents/products/whitepapers/whitepaper_datacompression.pdf (10 January 2022, date last accessed)</ext-link>.</mixed-citation>
    </ref>
    <ref id="btac010-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kelleher</surname><given-names>J.</given-names></string-name></person-group>  <etal>et al</etal>; GA4GH Streaming Task Team. (<year>2019</year>) <article-title>htsget: a protocol for securely streaming genomic data</article-title>. <source>Bioinformatics</source>, <volume>35</volume>, <fpage>119</fpage>–<lpage>121</lpage>.<pub-id pub-id-type="pmid">29931085</pub-id></mixed-citation>
    </ref>
    <ref id="btac010-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lan</surname><given-names>D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2021</year>) <article-title>Genozip: a universal extensible genomic data compressor</article-title>. <source>Bioinformatics</source>, <volume>37</volume>, <fpage>2225</fpage>–<lpage>2230</lpage>.<pub-id pub-id-type="pmid">33585897</pub-id></mixed-citation>
    </ref>
    <ref id="btac010-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group>  <etal>et al</etal>; 1000 Genome Project Data Processing Subgroup. (<year>2009</year>) <article-title>The Sequence Alignment/Map format and SAMtools</article-title>. <source>Bioinformatics</source>, <volume>25</volume>, <fpage>2078</fpage>–<lpage>2079</lpage>.<pub-id pub-id-type="pmid">19505943</pub-id></mixed-citation>
    </ref>
    <ref id="btac010-B21">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Mespotine</surname><given-names>M.</given-names></string-name></person-group> (<year>2015</year>) Mespotine-RLE-basic v0.9 - an overhead-reduced and improved Run-Length-Encoding Method.</mixed-citation>
    </ref>
    <ref id="btac010-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rehm</surname><given-names>H.L.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2021</year>) <article-title>GA4GH: international policies and standards for data sharing across genomic research and healthcare</article-title>. <source>Cell Genomics</source>, <volume>1</volume>, <fpage>100029</fpage>.<pub-id pub-id-type="pmid">35072136</pub-id></mixed-citation>
    </ref>
    <ref id="btac010-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Senf</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2021</year>) <article-title>Crypt4GH: a file format standard enabling native access to encrypted data</article-title>. <source>Bioinformatics</source>, <volume>37</volume>, <fpage>2753</fpage>–<lpage>2754</lpage>.<pub-id pub-id-type="pmid">33543751</pub-id></mixed-citation>
    </ref>
    <ref id="btac010-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Stephens</surname><given-names>Z.D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2015</year>) <article-title>Big data: astronomical or genomical?</article-title>  <source>PLoS Biol</source>., <volume>13</volume>, <fpage>e1002195</fpage>.<pub-id pub-id-type="pmid">26151137</pub-id></mixed-citation>
    </ref>
    <ref id="btac010-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Voges</surname><given-names>J.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) <article-title>CALQ: compression of quality values of aligned sequencing data</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>1650</fpage>–<lpage>1658</lpage>.<pub-id pub-id-type="pmid">29186284</pub-id></mixed-citation>
    </ref>
    <ref id="btac010-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Voges</surname><given-names>J.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2020</year>) <article-title>GABAC: an arithmetic coding solution for genomic data</article-title>. <source>Bioinformatics</source>, <volume>36</volume>, <fpage>2275</fpage>–<lpage>2277</lpage>.<pub-id pub-id-type="pmid">31830243</pub-id></mixed-citation>
    </ref>
    <ref id="btac010-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Voges</surname><given-names>J.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2021</year>) <article-title>An introduction to mpeg-g: the first open iso/iec standard for the compression and exchange of genomic sequencing data</article-title>. <source>Proc. IEEE</source>, <volume>109</volume>, <fpage>1607</fpage>–<lpage>1622</lpage>.</mixed-citation>
    </ref>
    <ref id="btac010-B28">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Yates</surname><given-names>A.D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2022</year>) <article-title>Refget: standardised access to reference sequences</article-title>. <italic toggle="yes">Bioinformatics</italic>, 38, 299–300. https://doi.org/10.1093/bioinformatics/btab524.</mixed-citation>
    </ref>
    <ref id="btac010-B29">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Zaharia</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2011</year>) Faster and more accurate sequence alignment with SNAP. https://arxiv.org/abs/1111.5572.</mixed-citation>
    </ref>
  </ref-list>
</back>
