<?properties open_access?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1460-2059</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">2734321</article-id>
    <article-id pub-id-type="pmid">19549630</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btp383</article-id>
    <article-id pub-id-type="publisher-id">btp383</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group>
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Swift: primary data analysis for the Illumina Solexa sequencing platform</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Whiteford</surname>
          <given-names>Nava</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="COR1">*</xref>
        <xref ref-type="author-notes" rid="FN1">
          <sup>†</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Skelly</surname>
          <given-names>Tom</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Curtis</surname>
          <given-names>Christina</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ritchie</surname>
          <given-names>Matt E.</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>3</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Löhr</surname>
          <given-names>Andrea</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>4</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Zaranek</surname>
          <given-names>Alexander Wait</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>5</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Abnizova</surname>
          <given-names>Irina</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Brown</surname>
          <given-names>Clive</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="author-notes" rid="FN1">
          <sup>†</sup>
        </xref>
      </contrib>
    </contrib-group>
    <aff id="AFF1"><sup>1</sup> Wellcome Trust Sanger Institute, Wellcome Trust Genome Campus, Hinxton, Cambridge, CB10 1SA, <sup>2</sup> Department of Oncology, University of Cambridge, CRUK Cambridge Research Institute, Li Ka Shing Centre, Robinson Way Cambridge CB2 0RE, UK, <sup>3</sup> Bioinformatics Division, The Walter and Eliza Hall Institute of Medical Research, 1G Royal Parade, Parkville, Victoria 3052, Australia, <sup>4</sup> Harvard-Smithsonian Center for Astrophysics, 60 Garden Street Cambridge, MA 02138 and <sup>5</sup> Harvard Medical School, Genetics, 77 Avenue Louis Pasteur, Boston, MA 02115, USA</aff>
    <author-notes>
      <corresp id="COR1">* To whom correspondence should be addressed.</corresp>
      <fn id="FN1">
        <p><sup>†</sup>Present Address: Oxford Nanopore Technologies Sandy Lane, Kidlington, OX5 1PF, UK.</p>
      </fn>
      <fn>
        <p>Associate Editor: Joaquin Dopazo</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>1</day>
      <month>9</month>
      <year>2009</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>23</day>
      <month>6</month>
      <year>2009</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>23</day>
      <month>6</month>
      <year>2009</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>25</volume>
    <issue>17</issue>
    <fpage>2194</fpage>
    <lpage>2199</lpage>
    <history>
      <date date-type="received">
        <day>22</day>
        <month>2</month>
        <year>2009</year>
      </date>
      <date date-type="rev-recd">
        <day>4</day>
        <month>5</month>
        <year>2009</year>
      </date>
      <date date-type="accepted">
        <day>18</day>
        <month>6</month>
        <year>2009</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2009 The Author(s)</copyright-statement>
      <copyright-year>2009</copyright-year>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by-nc/2.0/uk/">
        <license-p><!--CREATIVE COMMONS-->This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/2.0/uk/">http://creativecommons.org/licenses/by-nc/2.0/uk/</ext-link>) which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> Primary data analysis methods are of critical importance in second generation DNA sequencing. Improved methods have the potential to increase yield and reduce the error rates. Openly documented analysis tools enable the user to understand the primary data, this is important for the optimization and validity of their scientific work.</p>
      <p><bold>Results:</bold> In this article, we describe Swift, a new tool for performing primary data analysis on the Illumina Solexa Sequencing Platform. Swift is the first tool, outside of the vendors own software, which completes the full analysis process, from raw images through to base calls. As such it provides an alternative to, and independent validation of, the vendor supplied tool. Our results show that Swift is able to increase yield by 13.8%, at comparable error rate.</p>
      <p><bold>Availability and Implementation:</bold> Swift is implemented in C++and supported under Linux. It is supplied under an open source license (LGPL3), allowing researchers to build upon the platform. Swift is available from <ext-link ext-link-type="uri" xlink:href="http://swiftng.sourceforge.net">http://swiftng.sourceforge.net</ext-link>.</p>
      <p><bold>Contact:</bold><email>new@sgenomics.org</email>; <email>nava.whiteford@nanoporetech.com</email></p>
      <p><bold>Supplementary information:</bold><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/btp383/DC1">Supplementary data</ext-link> are available at <italic>Bioinformatics</italic> online.</p>
    </abstract>
  </article-meta>
</front>
<body>
  <sec sec-type="intro" id="SEC1">
    <title>1 INTRODUCTION</title>
    <p>Second generation sequencing technologies such as the Genome Analyzer (Illumina, San Diego, USA), 454-FLX (Roche, Basel, Switzerland) and SOLiD (Applied Biosystems, California, USA) have increased the production of sequence data by several orders of magnitude (Quail <italic>et al.</italic>, <xref ref-type="bibr" rid="B11">2008</xref>). Along with an increase in throughput these technologies bring an increased primary data analysis problem, both in terms of the complexity of the analysis and the volume of data that needs to be processed. Second generation devices image a surface to which clusters of DNA grown from a template or beads have been attached. The data analysis problem, therefore, first presents itself as one of image analysis, the result of which is a sequence of intensities which require further signal corrections to produce base calls (Brown <italic>et al.</italic>, <xref ref-type="bibr" rid="B2">2006</xref>). A number of new base-calling methods have been developed including Altacyclic (Erlich <italic>et al.</italic>, <xref ref-type="bibr" rid="B5">2008</xref>) and Rolexa (Rougemont <italic>et al.</italic>, <xref ref-type="bibr" rid="B13">2008</xref>). However, to our knowledge no image analysis methods have been developed aside from the proprietary implementation provided by the vendor.</p>
    <p>In this article, we present Swift, an open source primary data analysis package for the Illumina Solexa sequencing platform which performs image analysis and base calling. Swift is the first freely available solution to the primary data analysis problem ‘from images to base calls’ and is available under the LGPL3 at <ext-link ext-link-type="uri" xlink:href="http://swiftng.sourceforge.net">http://swiftng.sourceforge.net</ext-link>. We perform validation against a ϕX 174 dataset.</p>
    <p>The use of benchmark datasets is well established for the validation of analysis methods for gene expression (Cope <italic>et al.</italic>, <xref ref-type="bibr" rid="B4">2004</xref>; Holloway <italic>et al.</italic>, <xref ref-type="bibr" rid="B8">2006</xref>) and genotyping (Lin <italic>et al.</italic>, <xref ref-type="bibr" rid="B10">2008</xref>) microarrays. To facilitate algorithm development and comparison for the Illumina Solexa platform, we have made the raw files from a ϕX 174 dataset available from our web site. This dataset, which provides a stable reference against which sequencing errors may be determined, is used to assess the performance of our approach.</p>
  </sec>
  <sec sec-type="methods" id="SEC2">
    <title>2 METHODS</title>
    <p>In Illumina Solexa sequencing template, DNA sequences are attached to a flowcell (shown in <xref ref-type="fig" rid="F1">Fig. 1</xref>). ‘Clusters’ of single-stranded DNA are grown from these single molecules and the prepared flowcell is placed in the sequencing device for imaging. Sequencing occurs as a cyclic process. A cycle of chemistry is performed which synthesizes a single fluorescently labelled complementary base to each DNA molecule (Bentley <italic>et al.</italic>, <xref ref-type="bibr" rid="B1">2008</xref>). The clusters are then imaged four times per cycle using two different lasers and two filters to detect the excitation of the four labelled nucleotides. The primary data analysis problem is therefore to take sets of images from the device and extract base calls from them. In an ideal scenario, a cluster would fluoresce in a single channel and the sequence of the template could be readily determined. However, the intensity vectors are not purely responsive to one distinct base and there are several signal artefacts present which must be corrected for in order to achieve accurate base calls.
<fig id="F1" position="float"><label>Fig. 1.</label><caption><p>A Genome Analyzer flowcell (left) and imaging region or ‘tile’ (right), with a magnified section showing a cluster. Images have been normalized, to span the full grey-scale range, for illustration purposes.</p></caption><graphic xlink:href="btp383f1"/></fig></p>
    <sec id="SEC2.1">
      <title>2.1 Image analysis</title>
      <p>In each cycle, the flowcell is imaged in a series of non-overlapping regions (<xref ref-type="fig" rid="F1">Fig. 1</xref>). The number of regions (known in Illumina terminology as ‘tiles’) depends on the device configuration. The default configuration for a Genome Analyzer 2 is 100 tiles per lane, where there are eight lanes per flowcell. Tiles are separated by a margin to prevent clusters being imaged multiple times. The flowcell is moved under the camera in order to image each tile in each cycle. Therefore, during each cycle 800 tiles are imaged in four channels. Runs are typically around 37 cycles producing a total of 118 400 images. Each GA2 image is a 2048 × 1794 pixel 16 bit grey-scale TIFF (though only 12 bits contain data). Each pixel covers ∼0.14 μ<sup>2</sup> of the flowcell and ∼9 pixels comprise one cluster object.</p>
      <p>In Swift, the unit of analysis is a set of images covering a single tile. These undergo image analysis the result of which is an intensity vector, for each cluster (a total of 148 intensity values, per cluster, for a 37 cycle run).</p>
      <sec id="SEC2.1.1">
        <title>2.1.1 Background subtraction</title>
        <p>The removal of non-specific ‘background’ intensity is desirable in order to obtain a less-biased measure of the true signal. For microarrays, it has been shown that subtracting a conservative estimate of the local background performs well, and avoids negative intensities (Ritchie <italic>et al.</italic>, <xref ref-type="bibr" rid="B12">2007</xref>), which are undesirable in downstream analysis and, as described below, possible in the GAPipeline (Brown <italic>et al.</italic>, <xref ref-type="bibr" rid="B2">2006</xref>). We therefore take the conservative approach of morphological erosion (Serra, <xref ref-type="bibr" rid="B14">1983</xref>) in Swift. In this method the minimal pixel value within a window around each pixel is subtracted from the central pixel's value. For efficiency, we use a square structuring element and implement the process using a FIFO queue.</p>
      </sec>
      <sec id="SEC2.1.2">
        <title>2.1.2 Image correlation</title>
        <p>In each cycle, the stage supporting the flowcell is moved to each tile position in turn. This repositioning is not entirely accurate and between cycles images may be several pixels out of alignment. We must therefore bring the images within each channel into alignment to compensate for this. A reference cycle is selected (typically the first cycle) to which subsequent images are aligned. Images are thresholded for alignment, discarding noise, using the method described in the following section. Alignment is performed by cross-correlating the images at the pixel level. Registering images to subpixel resolution was found unnecessary. This step may be performed efficiently using a Fast Fourier Transform (FFT) (Castro and Morandi, <xref ref-type="bibr" rid="B3">1987</xref>). Swift uses the FFTW library (Frigo and Johnson, <xref ref-type="bibr" rid="B7">1998</xref>) to implement this process.</p>
        <p>To allow for a variation in offsets across the image (due perhaps to incorrect focusing, or warping of the flowcell due to temperature variation), we divide the image into regular regions and calculate and apply offsets in each region independently. After this cross-cycle registration step, images within each channel should be in alignment. In order to make this process robust, the median channel offsets are used, as all imaging channels should be subject to the same stage movement.</p>
        <p>Though each channel is now in alignment from cycle to cycle, an offset still exists between channels. This offset is due to the different dye emission frequencies, and therefore differences in the optical path. In order to compensate for this offset an aggregate image is constructed for each channel, which simply sums the intensities from all cycles creating a reference image which should contain all clusters. The reference image for each channel is correlated against the other channels and from this cross-channel offsets are determined. Once these offsets are applied all images should be in alignment and we can begin to identify objects and extract their intensities.</p>
      </sec>
      <sec id="SEC2.1.3">
        <title>2.1.3 Object identification and intensity extraction</title>
        <p>Images are thresholded in order to identify foreground (cluster) pixels. In order to threshold the image, we create a morphologically dilated (Serra, <xref ref-type="bibr" rid="B14">1983</xref>) image and threshold those pixels in the original image that are within a given fraction of their dilated value. These parameters may be adjusted by the user. The process is implemented efficiently using a FIFO queue and square structuring element. This thresholding scheme is invariant to the differences in illumination commonly seen in Genome Analyzer image data. Reference contours are produced for each cluster, formed from groups of four-connected foreground pixels. Reference contours are created from non-overlapping objects in first cycle images by default.</p>
        <p>Once we have a set of reference contours for each cluster, the maximum pixel intensity within the contour is extracted from the background subtracted, aligned images. This process is performed for each cluster across cycle. The result is a sequence of four intensities per cycle across <italic>N</italic> cycles.</p>
      </sec>
    </sec>
    <sec id="SEC2.2">
      <title>2.2 Base calling</title>
      <p>If no artefacts were present in the signal, we could now simply ‘call’ the maximum intensity as the base call. However, a number of artefacts are present making the post-image analysis signal correction problem significant. Several tools exist for solving this post-image analysis, or base-calling, problem (Erlich <italic>et al.</italic>, <xref ref-type="bibr" rid="B5">2008</xref>; Rougemont <italic>et al.</italic>, <xref ref-type="bibr" rid="B13">2008</xref>). Swift is able to output a GAPipeline-style intensity file, allowing it to be used with any of these tools. However, Swift also provides its own base-calling algorithms allowing complete end to end operation using a simple but efficient and robust approach. In contrast to the existing tools, Swift does not employ machine learning or statistical modelling but rather applies a series of corrections to the signal a methodology similar to that employed in the GAPipeline.</p>
      <sec id="SEC2.2.1">
        <title>2.2.1 Crosstalk correction</title>
        <p>The first artefact we must correct for is crosstalk. This is caused by an overlap in the dye emission frequencies. Simply put, the C channel illumination overlaps with the A, causing a C label to produce a small amount of illumination in the A channel, and similarly the G and T dye responses also overlap. <xref ref-type="fig" rid="F2">Figure 2</xref> shows crosstalk plots typical of those produced by a Genome Analyzer 2. In order to correct for this we use a method similar to (Li and Speed, <xref ref-type="bibr" rid="B9">1998</xref>) with a few minor differences. The basic method puts regression lines through the arms of the plots. The arms are identified by placing bins along with <italic>X-</italic> and <italic>Y</italic>-axis and detecting the minimum values in these bins. Linear regression is performed on these values and the slope is used to derive a correction matrix. This process is performed iteratively until almost no slope remains. In Swift, we also perform some basic outlier detection, by placing a number of bins across the crosstalk plot and removing those containing few points.
<fig id="F2" position="float"><label>Fig. 2.</label><caption><p>Pairwise intensity plots from cycle 1 of a Genome Analyzer 2 run. Unlike pairwise plots produced by capillary sequencing (Li and Speed, <xref ref-type="bibr" rid="B9">1998</xref>) many Genome Analyzer plots have a distinctive ‘bowed’ appearance.</p></caption><graphic xlink:href="btp383f2"/></fig></p>
        <p>Some Genome Analyzer datasets produce deviations in crosstalk, which appear intensity dependent. This produces slightly ‘bowed’ plots as seen in <xref ref-type="fig" rid="F2">Figure 2</xref>. Placing a linear regression though the minimal values produces poor results and we therefore adopt a second strategy in addition to the method described to cope with this scenario. In this method, we identify a set of clusters (using the chastity metric described below) where it is likely that the correct base call can easily be determined, and then perform a linear regression on these values and derive a correction matrix as before. <xref ref-type="fig" rid="F3">Figure 3</xref> shows the pairwise intensity plots after correction.
<fig id="F3" position="float"><label>Fig. 3.</label><caption><p>Pairwise intensity plots from cycle 1 of a Genome Analyzer 2 run after crosstalk correction.</p></caption><graphic xlink:href="btp383f3"/></fig></p>
        <p>After crosstalk correction negative values, which represent an over-correction, are removed. The resultant signal is re-expressed as a deviation from the median intensity value in each channel. This normalization provides a fixed reference point for signals. We believe this may help compensate for any build up in background intensity, such as the common ‘sticky-T’ phenomenon, due to incomplete cleavage of the T-dye.</p>
      </sec>
      <sec id="SEC2.2.2">
        <title>2.2.2 Phasing correction</title>
        <p>As previously stated each cluster contains many identical copies of a template sequence. During each cycle, labelled nucleotides are incorporated into these molecules. However, this is driven by stochastic chemical processes, so some molecules may fail to incorporate a labelled nucleotide, or may fail to block and incorporate &gt;1 nt. This manifests itself as a leakage in intensity between cycles. For example, if a G base is present in cycle 2, we will see a small amount of G intensity leaking into cycles 1 and 3. <xref ref-type="fig" rid="F4">Figure 4</xref> illustrates forward phasing.
<fig id="F4" position="float"><label>Fig. 4.</label><caption><p>Schematic representation of phasing in Illumina Solexa sequencing. The figure shows intensities detected across cycle where the true sequence reads <monospace>CGTAC…</monospace> Cross-cycle signal leakage can be seen, for example, in cycle 2 which contains a significant fraction of the intensity present in cycle 1. By the final cycle, the signals are almost fully convolved and it becomes difficult to determine the true signal. Phasing is caused by the non-incorporation of a labelled nucleotide in a given cycle. The reverse phenomenon (data not shown) is caused by the multiple incorporation of nucleotides and manifests itself as signal leakage between the current and previous cycles.</p></caption><graphic xlink:href="btp383f4"/></fig></p>
        <p>To correct this, we rank clusters by ‘Chastity’ (described in the following section) and use the top 400 clusters to estimate phasing. We correct each cycle and channel independently. For each channel, we identify those clusters which are brightest in the current channel, but whose maximal intensity is not this channel in previous and subsequent cycles. From these we calculate the fraction of the intensity that has leaked between cycles and use this as our phasing estimate.</p>
        <p>This phasing estimation is then applied as a correction where this fraction of the current cycle's intensity is subtracted from subsequent and previous cycles and added to the current cycle. A limit is placed upon the phasing estimation to ensure that unreasonable values are not used. The correction is applied iteratively starting with the first cycle, then correcting for each subsequent cycle's phasing.</p>
      </sec>
      <sec id="SEC2.2.3">
        <title>2.2.3 Chastity filtering</title>
        <p>In the ideal scenario discrete clusters are grown, each from a single DNA template. However, mixed clusters can be grown starting from more than one template, in which case the base calls of the cluster cannot be accurately determined. Swift uses the same metric as the GAPipeline to filter out these clusters. The metric is defined as follows:
<disp-formula id="M1"><label>(1)</label><graphic xlink:href="btp383m1"/></disp-formula></p>
        <p>In the GAPipeline, a limit is placed on the second lowest value of chastity over the first 25 bases. By default this is set as 0.6. As this is a robust and well-validated metric it is also used in Swift, with a user-selectable threshold.</p>
      </sec>
      <sec id="SEC2.2.4">
        <title>2.2.4 Base calling</title>
        <p>After correction, the base with the maximum intensity is chosen as the called base. Swift can also optionally produce a Fast4 file. This file contains the raw probabilities for all four bases. This additional information may prove useful in alignment. Base probabilities are simply calculated as a fraction of the total intensity. Fastq files may also be created. The value used is derived from the probability of the called base scaled over the range Q6–Q30. As with all quality scores this value requires calibration in order to provide a useful metric.</p>
      </sec>
      <sec id="SEC2.2.5">
        <title>2.2.5 Comparison with the GAPipeline</title>
        <p>GAPipeline (the vendor-supplied analysis tool) performs image analysis, base calling and alignment (optional) and is composed of a number of independent programs. The UNIX ‘make’ utility is used to manage workflow and job control. <xref ref-type="fig" rid="F5">Figure 5</xref> shows the processing steps common to Swift and the GAPipeline. In this section, we briefly discuss our investigation of the GAPipeline's methods, based on the release prior to GAPipeline 1.0. A detailed description of our analysis is also available (<ext-link ext-link-type="uri" xlink:href="http://sgenomics.org/mediawiki/upload/8/80/Pipeline.pdf">http://sgenomics.org/mediawiki/upload/8/80/Pipeline.pdf</ext-link>).
<fig id="F5" position="float"><label>Fig. 5.</label><caption><p>Processing steps required to process primary data from images to base calls.</p></caption><graphic xlink:href="btp383f5"/></fig></p>
        <p>Processing begins with Firecrest, the GAPipeline image analysis tool. Firecrest operates in two passes. In the first pass a full image analysis is performed but only the offsets between imaging channels are retained. The second pass then applies these offsets between channels. This differs from Swift which aligns images within each channel and then performs alignment on aggregate reference images in a single pass. Firecrest begins by applying a Mexican hat filter to each image. This attenuation of high and low frequencies smoothes the image and strengthens the edges. The image is broken into an even number of regions &gt;125 pixel square for noise and background estimation. A smoothed, filtered histogram of the pixels in each region is created to which a Gaussian is fitted. The average calculated from the Gaussian is used to populate a ‘background’ image, the SD a ‘noise’ image, a single value is used for each 125 pixel square region. The ‘background image’ is subtracted and then thresholded for object identification. Thresholding retains pixels whose value is greater than four times the value in the ‘noise image’. This differs significantly from Swift where the background subtraction and thresholding varies smoothly across the image, adapting for local intensity variation.</p>
        <p>In Firecrest, objects &gt;15 pixels but &lt;115 pixels are split producing two objects, one at the maximum pixel value, another at the second highest. In contrast to this, Swift performs no deblending by default. In general, the deblending of an object may be one source of ‘optical duplicates’ where multiple clusters are identified where only one true cluster exists. This is best avoided if possible.</p>
        <p>In Firecrest, once objects have been identified local background is compensated for. This takes a 10 × 10 window around the pixel of maximum intensity in an object. The median of all pixels not within the object is taken (some basic outlier removal is performed) and subtracted from the objects maximal intensity value (this is designed to compensate for local background noise). In contrast to Swift, this often produces non-integer and negative values. Swift avoids this producing only positive integers as its output of image analysis. This not only simplifies later processing, but also reduces the cost of archival.</p>
        <p>The pixel of maximum intensity in each object has a parabolic fit applied to it and the values of adjacent pixels, which produces a position at subpixel resolution. In order to bring the images into alignment, synthetic images are constructed from the reference positions (a Gaussian distribution of intensities is created, centred around this position). The synthetic images are cross-correlated in 125 × 125 pixel regions, producing an X/Y offset in each region. A linear regression is fitted to the X and Y offsets calculated in order to determine a scaling factor (this assumes the offsets deviate linearly across the tile). In contrast, Swift uses the object profiles identified after thresholding on subregions of the image. Swift does not apply a linear fit to the data, as our investigation shows that the offsets do not vary linearly across the tile (<xref ref-type="fig" rid="F6">Fig. 6</xref>).
<fig id="F6" position="float"><label>Fig. 6.</label><caption><p>X and Y offsets per channel calculated by Swift on the first five cycles of run 1851 lane 4, tile 1. Offsets were calculated independently in 400 subregions of each image. Many of these offset maps do not exhibit a linear variation across the tile.</p></caption><graphic xlink:href="btp383f6"/></fig></p>
        <p>Once in alignment, the pixels lying under the reference positions are extracted, producing an intensity vector for each cluster. This intensity vector is then passed on to a script which performs crosstalk correction using the method of (Li and Speed, <xref ref-type="bibr" rid="B9">1998</xref>). A phasing correction is then performed. We have not examined the GAPipeline post-image analysis corrections in great detail, though it is apparent that no explicit normalization is performed and that other than this our methods are similarly motivated.</p>
      </sec>
    </sec>
  </sec>
  <sec sec-type="results" id="SEC3">
    <title>3 RESULTS</title>
    <p>In this section, we discuss the validation of Swift against five tiles of ϕ X174 control from a 37 cycle single-end Genome Analyzer 2 run. A full set of tile images, intensity files and base calls is available from <ext-link ext-link-type="uri" xlink:href="http://sgenomics.org/swift/paperdataset.html">http://sgenomics.org/swift/paperdataset.html</ext-link>. A comparably small dataset was chosen in order to allow us to make the full dataset available. We identify clusters from the first three cycles. In doing so, we run the risk of producing ‘optical duplicates’, that is, identifying multiple clusters, and therefore reads, where there is only really one. In order to mitigate this effect, we apply an optical duplicate filter. This filter removes those duplicate reads within a 6 × 6 window with similar sequence (allowing eight mismatches), and retains the read with the highest ‘chastity’. No optical duplicate filtering was performed for the GAPipeline. Settings may be tuned to reduce the duplicate rate, however, this will result in a reduction in yield. We compare the Swift output with version 1.3.2 of the Illumina GAPipeline. <xref ref-type="table" rid="T1">Table 1</xref> summarizes these results. Default parameters were used for the GAPipeline. Swift produced an average increase in yield of 13.8% while maintaining a similar error rate. The user may tune Swift's parameters to reduce the optical duplicate rate, error rate or increase yield as desired.
<table-wrap id="T1" position="float"><label>Table 1.</label><caption><p>Comparison of Swift and GAPipeline 1.3.2 error rates for given tiles on Sanger Institute run 1851 lane 4</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1"/><th align="left" colspan="4" rowspan="1">Swift<hr/></th></tr><tr><th align="left" rowspan="1" colspan="1">Tile no.</th><th align="left" rowspan="1" colspan="1">Total reads</th><th align="left" rowspan="1" colspan="1">Dups. Rem.</th><th align="left" rowspan="1" colspan="1">PF</th><th align="left" rowspan="1" colspan="1">Err. (%)</th></tr></thead><tbody align="left"><tr><td align="left" rowspan="1" colspan="1">1</td><td align="left" rowspan="1" colspan="1">333 345</td><td align="left" rowspan="1" colspan="1">192 103</td><td align="left" rowspan="1" colspan="1">100 697</td><td align="left" rowspan="1" colspan="1">1.20</td></tr><tr><td align="left" rowspan="1" colspan="1">21</td><td align="left" rowspan="1" colspan="1">288 498</td><td align="left" rowspan="1" colspan="1">158 540</td><td align="left" rowspan="1" colspan="1">96 923</td><td align="left" rowspan="1" colspan="1">0.97</td></tr><tr><td align="left" rowspan="1" colspan="1">41</td><td align="left" rowspan="1" colspan="1">286 302</td><td align="left" rowspan="1" colspan="1">150 220</td><td align="left" rowspan="1" colspan="1">88 374</td><td align="left" rowspan="1" colspan="1">1.05</td></tr><tr><td align="left" rowspan="1" colspan="1">61</td><td align="left" rowspan="1" colspan="1">276 433</td><td align="left" rowspan="1" colspan="1">146 407</td><td align="left" rowspan="1" colspan="1">92 247</td><td align="left" rowspan="1" colspan="1">1.00</td></tr><tr><td align="left" rowspan="1" colspan="1">81</td><td align="left" rowspan="1" colspan="1">280 069</td><td align="left" rowspan="1" colspan="1">155 752</td><td align="left" rowspan="1" colspan="1">98 872</td><td align="left" rowspan="1" colspan="1">1.00</td></tr><tr><td colspan="5" rowspan="1"><hr/></td></tr><tr><td rowspan="1" colspan="1"/><td align="left" colspan="3" rowspan="1">GAPipeline 1.3.2<hr/></td><td align="left" rowspan="1" colspan="1">Swift yield<hr/></td></tr><tr><td align="left" rowspan="1" colspan="1">Tile no.</td><td align="left" rowspan="1" colspan="1">Total reads</td><td align="left" rowspan="1" colspan="1">PF</td><td align="left" rowspan="1" colspan="1">Err. (%)</td><td align="left" rowspan="1" colspan="1">Inc. (%)</td></tr><tr><td colspan="5" rowspan="1"><hr/></td></tr><tr><td align="left" rowspan="1" colspan="1">1</td><td align="left" rowspan="1" colspan="1">112 353</td><td align="left" rowspan="1" colspan="1">79 548</td><td align="left" rowspan="1" colspan="1">1.10</td><td align="left" rowspan="1" colspan="1">26.6</td></tr><tr><td align="left" rowspan="1" colspan="1">21</td><td align="left" rowspan="1" colspan="1">108 588</td><td align="left" rowspan="1" colspan="1">85 330</td><td align="left" rowspan="1" colspan="1">1.04</td><td align="left" rowspan="1" colspan="1">13.6</td></tr><tr><td align="left" rowspan="1" colspan="1">41</td><td align="left" rowspan="1" colspan="1">101 574</td><td align="left" rowspan="1" colspan="1">79 453</td><td align="left" rowspan="1" colspan="1">1.13</td><td align="left" rowspan="1" colspan="1">11.2</td></tr><tr><td align="left" rowspan="1" colspan="1">61</td><td align="left" rowspan="1" colspan="1">104 237</td><td align="left" rowspan="1" colspan="1">84 658</td><td align="left" rowspan="1" colspan="1">1.16</td><td align="left" rowspan="1" colspan="1">8.9</td></tr><tr><td align="left" rowspan="1" colspan="1">81</td><td align="left" rowspan="1" colspan="1">112 546</td><td align="left" rowspan="1" colspan="1">90 996</td><td align="left" rowspan="1" colspan="1">1.04</td><td align="left" rowspan="1" colspan="1">8.6</td></tr></tbody></table><table-wrap-foot><fn><p>This lane contained ϕX 174, a commonly used control genome. Sequences were aligned using PhageAlign from the GAPipeline version 1.3.2. The GAPipeline performed its own alignment. Default parameters we used for the GAPipeline. As can be seen Swift provides an average increase in yield of 13.8% at comparable error rate.</p></fn></table-wrap-foot></table-wrap>
</p>
    <p>In order to determine whether improvements come from image analysis or base calling, we analysed intensity files from the GAPipeline using Swift (<xref ref-type="table" rid="T2">Table 2</xref>). The results show a small increase in yield over the GAPipeline in most cases, but no reduction in error rate. This indicates that Swift's improvements come for the most part from the image analysis. We do however note that the number of optical duplicates removed is lower.
<table-wrap id="T2" position="float"><label>Table 2.</label><caption><p>Comparison of Swift and GAPipeline 1.3.2 Image analysis when used in conjunction with the Swift basecaller, as for <xref ref-type="table" rid="T1">Table 1</xref></p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1"/><th align="left" colspan="4" rowspan="1">GAPipeline 1.3.2 + Swift<hr/></th><th align="left" rowspan="1" colspan="1">Swift yield<hr/></th></tr><tr><th align="left" rowspan="1" colspan="1">Tile no.</th><th align="left" rowspan="1" colspan="1">Total reads</th><th align="left" rowspan="1" colspan="1">Dups. Rem.</th><th align="left" rowspan="1" colspan="1">PF</th><th align="left" rowspan="1" colspan="1">Err. (%)</th><th align="left" rowspan="1" colspan="1">Inc. (%)</th></tr></thead><tbody align="left"><tr><td align="left" rowspan="1" colspan="1">1</td><td align="left" rowspan="1" colspan="1">112 925</td><td align="left" rowspan="1" colspan="1">112 503</td><td align="left" rowspan="1" colspan="1">92 345</td><td align="left" rowspan="1" colspan="1">1.12</td><td align="left" rowspan="1" colspan="1">9.05</td></tr><tr><td align="left" rowspan="1" colspan="1">21</td><td align="left" rowspan="1" colspan="1">108 588</td><td align="left" rowspan="1" colspan="1">108 190</td><td align="left" rowspan="1" colspan="1">91 022</td><td align="left" rowspan="1" colspan="1">1.12</td><td align="left" rowspan="1" colspan="1">6.48</td></tr><tr><td align="left" rowspan="1" colspan="1">41</td><td align="left" rowspan="1" colspan="1">101 574</td><td align="left" rowspan="1" colspan="1">101 171</td><td align="left" rowspan="1" colspan="1">85 281</td><td align="left" rowspan="1" colspan="1">1.15</td><td align="left" rowspan="1" colspan="1">3.63</td></tr><tr><td align="left" rowspan="1" colspan="1">61</td><td align="left" rowspan="1" colspan="1">104 237</td><td align="left" rowspan="1" colspan="1">103 782</td><td align="left" rowspan="1" colspan="1">87 455</td><td align="left" rowspan="1" colspan="1">1.24</td><td align="left" rowspan="1" colspan="1">5.48</td></tr><tr><td align="left" rowspan="1" colspan="1">81</td><td align="left" rowspan="1" colspan="1">112 546</td><td align="left" rowspan="1" colspan="1">112 122</td><td align="left" rowspan="1" colspan="1">82 588</td><td align="left" rowspan="1" colspan="1">1.36</td><td align="left" rowspan="1" colspan="1">19.72</td></tr></tbody></table></table-wrap>
</p>
    <p>In order to support our validation of Swift, a different and larger genome was analysed. A lane of data from 3 Mb of exonic regions in PGP2 (Zaranek,A. <italic>et al.</italic> (2009) Lessons from the initial data release of the personal genome project, in preparation.) was used for this purpose. This dataset is available online via Tranche at <ext-link ext-link-type="uri" xlink:href="http://openwetware.org/wiki/PGP_and_Tranche">http://openwetware.org/wiki/PGP_and_Tranche</ext-link>. Analysis was performed in a virtual machine on the Free Factories compute infrastructure (Zaranek <italic>et al.</italic>, <xref ref-type="bibr" rid="B15">2008</xref>).</p>
    <p><xref ref-type="table" rid="T3">Table 3</xref> summaries our results. Swift produced significantly more reads than the GAPipeline (∼ 10<sup>6</sup> additional reads). However, fewer of these passed purity filtering, resulting in a smaller total dataset (GAPipeline 502 872 additional reads). The error rate was comparable (GAPipeline 0.3766%, Swift 0.6524%). In order to determine if the GAPipelines increased read count can be attributed to optical duplicates, we ran processed the GAPipeline intensity files against the Swift basecaller and optical duplicate filter. This removed 209 199 duplicate reads accounting for a significant portion of the difference.
<table-wrap id="T3" position="float"><label>Table 3.</label><caption><p>Comparison of Swift and the GAPipeline 1.3.2 for a lane of data from 3 Mb of exonic regions in PGP2 (Zaranek,A. <italic>et al.</italic> (2009) Lessons from the initial data release of the personal genome project, in preparation.)</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th align="left" rowspan="1" colspan="1">Tool</th><th align="left" rowspan="1" colspan="1">Total reads</th><th align="left" rowspan="1" colspan="1">PF reads</th></tr></thead><tbody align="left"><tr><td align="left" rowspan="1" colspan="1">Swift</td><td align="left" rowspan="1" colspan="1">8 164 716</td><td align="left" rowspan="1" colspan="1">4 665 259</td></tr><tr><td align="left" rowspan="1" colspan="1">GAPipeline 1.3.2</td><td align="left" rowspan="1" colspan="1">6 903 576</td><td align="left" rowspan="1" colspan="1">5 168 131</td></tr><tr><td align="left" rowspan="1" colspan="1">GAPipeline 1.3.2+Swift</td><td align="left" rowspan="1" colspan="1">6 694 377</td><td align="left" rowspan="1" colspan="1">4 954 683</td></tr></tbody></table><table-wrap-foot><fn><p>For Swift, ‘total reads’ indicates the number of reads after duplicate filtering.</p></fn></table-wrap-foot></table-wrap>
</p>
    <p>We have validated Swift for use with genomic data. However, the application of Solexa sequencing to RNA-Seq, Chip-Seq and other sequencing applications are of significant importance. The ability to tune Swift's parameters to lower the optical duplicate rate may be attractive here. Swift supports paired end runs, this does not change the analysis but simply splits reads after they have been generated.</p>
    <sec id="SEC3.1">
      <title>3.1 An assessment of quality scores</title>
      <p>As previously described, Swift generates a set of four probabilities at each position. This is calculated as a fraction of the base intensity over the sum of all intensities. For example, probability of an A call would be:
<disp-formula id="M2"><label>(2)</label><graphic xlink:href="btp383m2"/></disp-formula>
In order to generate a single quality score, Swift extracts the base with the highest probability. This value is scaled over the range of Q6–Q30, such that Q30 represents a probability of one and Q6 zero. <xref ref-type="fig" rid="F7">Figure 7</xref>a shows the observed versus predicted quality scores for one tile of our dataset. As can be seen, the dependence of the observed quality is not linear to those predicted, and they do not reflect the true quality, as to be expected from an uncalibrated quality score. In order to correct for this, we apply a simple calibration (Ewing and Green, <xref ref-type="bibr" rid="B6">1998</xref>) scheme. To generate a calibration table, reads from a training tile are aligned to a reference, those reads with more than seven mismatches are discarded as being most likely generated from contamination. Once the observed quality scores have been calculated, they are used to construct a mapping from predicted to observed values. This mapping may then be applied to another dataset where the true reference may not be known, using a simple lookup table. <xref ref-type="fig" rid="F7">Figure 7</xref>b shows the results of applying this mapping onto a different tile from the same run, the quality scores now largely reflect the true base quality (showing that the method is somewhat transferable). The highest quality assigned is Q32, with 53% of bases being calibrated to Q30 or above. This result shows that the calibration table generated is transferable between tiles. This robust and simple calibration scheme is therefore a reasonable placeholder until more precise methods are developed.
<fig id="F7" position="float"><label>Fig. 7.</label><caption><p>(<bold>a</bold>) Predicted versus observed quality for run 1851 lane 4 tile 1. In calculating this plot reads with more than seven mismatches were discarded in order to remove sample contamination. (<bold>b</bold>) The data shown in (a) were used to generate a calibration table. This table was then applied to the remaining tiles (21, 41, 61 and 81). The result is that quality scores now largely reflect true quality.</p></caption><graphic xlink:href="btp383f7"/></fig></p>
    </sec>
    <sec id="SEC3.2">
      <title>3.2 Computational requirements</title>
      <p>Processing a single GA2 tile across 37 cycles requires ∼1 GB of main memory. When compiled using the Intel C++ compiler version 11, processing took 25 min. The GAPipeline uses GNU C++ and modifying this is non-trivial. The GAPipeline took 23 min to process this tile and 657 MB of memory on our dataset (gcc version 4.2.3 installed). Using this compiler Swift took 30 min. Swift however operates on the tile level; a user may therefore submit 800 jobs and gain maximum utilization of their cluster (as opposed to eight jobs which may be submitted for the GAPipeline). Our benchmarks were performed on a single core of a Intel Core2Duo T8100 at 2.10 GHz.</p>
    </sec>
  </sec>
  <sec sec-type="discussion" id="SEC4">
    <title>4 DISCUSSION</title>
    <p>We have described a new open source pipeline for the analysis of primary data from the Illumina Solexa sequencing platform. Our analysis provides validation of the vendor-provided analysis tools and is the first openly documented technique for extracting sequence data from images on this platform. We have provided a pipeline which other researchers may use as a platform for further development and which allows them to freely distribute their modifications.</p>
    <p>Swift protects the user from potentially undesirable changes to the vendor-supplied analysis tools. It gives users an alternative to bundled analysis platforms and allows them to manage their own IT infrastructure. It also provides an openly documented analysis tool enabling the user to understand the primary data, and to investigate frequent device changes which can cause unexpected side effects. For example, the original version of the Genome Analyzer did not image the flowcell wall, current revisions do resulting in artificial poly A sequences. Understanding the primary data is critical to the operation of a high-throughput sequencing facility.</p>
    <p>We have also shown that there is significant room for improvement in the vendor-supplied analysis showing an increased yield of 13.6% (at the same error rate). We believe that the image analysis methods presented should prove to be transferable to other next-generation sequencing platforms, such as the Applied Biosciences SOLiD™ Sequencer and Roche 454 FLX, though in the latter case, the image analysis problem should be simplified due to the regular arraying of beads. Potentially, this allows a user to maintain a single primary data analysis platform for all second generation systems.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="PMC_1" content-type="local-data">
      <caption>
        <title>[Supplementary Data]</title>
      </caption>
      <media mimetype="text" mime-subtype="html" xlink:href="btp383_index.html"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="ps" xlink:href="btp383_btp383f1.eps"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="ps" xlink:href="btp383_btp383f4.eps"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="ps" xlink:href="btp383_btp383f5.eps"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="ps" xlink:href="btp383_btp383f6.eps"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>ACKNOWLEDGEMENTS</title>
    <p>We thank the following individuals from the Wellcome Trust Sanger Institute: James Bonfield for many illuminating discussions, Andy Brown and Roger Pettett for their suggestions relating to Swift's reporting module and Tony Cox for his continued support. We also thank Klaus Maisinger of Illumina for discussions relating to the Illumina primary data analysis methods and Tony Cox of Illumina for answering our queries relating to PhageAlign.</p>
    <p><italic>Conflict of Interest</italic>: Since the inception of this work Nava Whiteford and Clive Brown have moved to 3rd Generation sequencing company, Oxford Nanopore Technologies. The other authors have declared none.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="B1">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bentley</surname>
            <given-names>D</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Accurate whole human genome sequencing using reversible terminator chemistry</article-title>
        <source>Nature</source>
        <year>2008</year>
        <volume>456</volume>
        <fpage>53</fpage>
        <lpage>59</lpage>
        <pub-id pub-id-type="pmid">18987734</pub-id>
      </element-citation>
    </ref>
    <ref id="B2">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Brown</surname>
            <given-names>CG</given-names>
          </name>
          <etal/>
        </person-group>
        <source>Solexa/Illumina GAPipeline product and product documentation</source>
        <year>2006</year>
        <publisher-name>Illumina Inc</publisher-name>
      </element-citation>
    </ref>
    <ref id="B3">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Castro</surname>
            <given-names>ED</given-names>
          </name>
          <name>
            <surname>Morandi</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Registration of translated and rotated images using finite fourier transforms</article-title>
        <source>IEEE Trans. Pattern Anal. Mach. Intell.</source>
        <year>1987</year>
        <volume>9</volume>
        <fpage>700</fpage>
        <lpage>703</lpage>
      </element-citation>
    </ref>
    <ref id="B4">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cope</surname>
            <given-names>LM</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A benchmark for Affymetrix genechip expression measures</article-title>
        <source>Bioinformatics</source>
        <year>2004</year>
        <volume>20</volume>
        <fpage>323</fpage>
        <lpage>331</lpage>
        <pub-id pub-id-type="pmid">14960458</pub-id>
      </element-citation>
    </ref>
    <ref id="B5">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Erlich</surname>
            <given-names>Y</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Alta-cyclic: a self-optimizing base caller for next-generation sequencing</article-title>
        <source>Nat. Methods</source>
        <year>2008</year>
        <volume>5</volume>
        <fpage>679</fpage>
        <lpage>682</lpage>
        <pub-id pub-id-type="pmid">18604217</pub-id>
      </element-citation>
    </ref>
    <ref id="B6">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ewing</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Green</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Base-calling of automated sequencer traces using Phred. ii. Error probabilities</article-title>
        <source>Genome Res</source>
        <year>1998</year>
        <volume>8</volume>
        <fpage>186</fpage>
        <lpage>194</lpage>
        <pub-id pub-id-type="pmid">9521922</pub-id>
      </element-citation>
    </ref>
    <ref id="B7">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Frigo</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Johnson</surname>
            <given-names>SG</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Frigo</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Johnson</surname>
            <given-names>SG</given-names>
          </name>
        </person-group>
        <article-title>FFTW: An Adaptive Software Architecture for the FFT</article-title>
        <source>Proceedings of ICASSP 3</source>
        <year>1998</year>
        <publisher-name>IEEE</publisher-name>
        <fpage>1381</fpage>
        <lpage>1384</lpage>
      </element-citation>
    </ref>
    <ref id="B8">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Holloway</surname>
            <given-names>A</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Statistical analysis of an rna titration series evaluates microarray precision and sensitivity on a whole-array basis</article-title>
        <source>BMC Bioinformatics</source>
        <year>2006</year>
        <volume>7</volume>
        <fpage>511</fpage>
        <pub-id pub-id-type="pmid">17118209</pub-id>
      </element-citation>
    </ref>
    <ref id="B9">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Speed</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>An estimate of the crosstalk matrix in four-dye fluorescence-based DNA sequencing</article-title>
        <source>Electrophoresis</source>
        <year>1998</year>
        <volume>20</volume>
        <fpage>1433</fpage>
        <lpage>1442</lpage>
        <pub-id pub-id-type="pmid">10424466</pub-id>
      </element-citation>
    </ref>
    <ref id="B10">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lin</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Validation and extension of an empirical Bayes method for SNP calling on Affymetrix microarrays</article-title>
        <source>Genome Biol.</source>
        <year>2008</year>
        <volume>9</volume>
        <fpage>R63</fpage>
        <pub-id pub-id-type="pmid">18387188</pub-id>
      </element-citation>
    </ref>
    <ref id="B11">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Quail</surname>
            <given-names>M</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A large genome center's improvements to the Illumina sequencing system</article-title>
        <source>Nat. Methods</source>
        <year>2008</year>
        <volume>5</volume>
        <fpage>1005</fpage>
        <lpage>1010</lpage>
        <pub-id pub-id-type="pmid">19034268</pub-id>
      </element-citation>
    </ref>
    <ref id="B12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ritchie</surname>
            <given-names>ME</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A comparison of background correction methods for two-colour microarrays</article-title>
        <source>Bioinformatics</source>
        <year>2007</year>
        <volume>23</volume>
        <fpage>2700</fpage>
        <lpage>2707</lpage>
        <pub-id pub-id-type="pmid">17720982</pub-id>
      </element-citation>
    </ref>
    <ref id="B13">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rougemont</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Probabilistic base calling of Solexa sequencing data</article-title>
        <source>BMC Bioinformatics</source>
        <year>2008</year>
        <volume>9</volume>
        <fpage>431</fpage>
        <pub-id pub-id-type="pmid">18851737</pub-id>
      </element-citation>
    </ref>
    <ref id="B14">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Serra</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <source>Image Analysis and Mathematical Morphology.</source>
        <year>1983</year>
        <publisher-loc>Orlando, FL</publisher-loc>
        <publisher-name>Academic Press, Inc.</publisher-name>
      </element-citation>
    </ref>
    <ref id="B15">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Zaranek</surname>
            <given-names>AW</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Free factories: unified infrastructure for data intensive web services</article-title>
        <source>ATC'08: USENIX 2008 Annual Technical Conference on Annual Technical Conference.</source>
        <year>2008</year>
        <publisher-loc>Berkeley, CA</publisher-loc>
        <publisher-name>USENIX Association</publisher-name>
        <fpage>391</fpage>
        <lpage>404</lpage>
      </element-citation>
    </ref>
  </ref-list>
</back>
