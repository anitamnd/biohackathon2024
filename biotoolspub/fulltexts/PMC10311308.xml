<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10311308</article-id>
    <article-id pub-id-type="pmid">37387165</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad262</article-id>
    <article-id pub-id-type="publisher-id">btad262</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Systems Biology and Networks</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Trap spaces of multi-valued networks: definition, computation, and applications</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-6581-998X</contrib-id>
        <name>
          <surname>Trinh</surname>
          <given-names>Van-Giang</given-names>
        </name>
        <aff><institution>LIS, Aix-Marseille University</institution>, Marseille 13397, <country country="FR">France</country></aff>
        <xref rid="btad262-cor1" ref-type="corresp"/>
        <!--trinh.van-giang@lis-lab.fr-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Benhamou</surname>
          <given-names>Belaid</given-names>
        </name>
        <aff><institution>LIS, Aix-Marseille University</institution>, Marseille 13397, <country country="FR">France</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Henzinger</surname>
          <given-names>Thomas</given-names>
        </name>
        <aff><institution>Institute of Science and Technology</institution>, Klosterneuburg 3400, <country country="AT">Austria</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-1993-0331</contrib-id>
        <name>
          <surname>Pastva</surname>
          <given-names>Samuel</given-names>
        </name>
        <aff><institution>Institute of Science and Technology</institution>, Klosterneuburg 3400, <country country="AT">Austria</country></aff>
        <xref rid="btad262-cor1" ref-type="corresp"/>
        <!--samuel.pastva@ist.ac.at-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad262-cor1">Corresponding authors. LIS, Aix-Marseille University, Marseille, France. E-mail: <email>trinh.van-giang@lis-lab.fr</email> (V.-G.T.); Institute of Science and Technology, Klosterneuburg, Austria. E-mail: <email>samuel.pastva@ist.ac.at</email> (S.P.)</corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-06-30">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB/ECCB 2023 Proceedings</issue-title>
    <fpage>i513</fpage>
    <lpage>i522</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad262.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Boolean networks are simple but efficient mathematical formalism for modelling complex biological systems. However, having only two levels of activation is sometimes not enough to fully capture the dynamics of real-world biological systems. Hence, the need for multi-valued networks (MVNs), a generalization of Boolean networks. Despite the importance of MVNs for modelling biological systems, only limited progress has been made on developing theories, analysis methods, and tools that can support them. In particular, the recent use of trap spaces in Boolean networks made a great impact on the field of systems biology, but there has been no similar concept defined and studied for MVNs to date.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>In this work, we generalize the concept of trap spaces in Boolean networks to that in MVNs. We then develop the theory and the analysis methods for trap spaces in MVNs. In particular, we implement all proposed methods in a Python package called <monospace>trapmvn</monospace>. Not only showing the applicability of our approach via a realistic case study, we also evaluate the time efficiency of the method on a large collection of real-world models. The experimental results confirm the time efficiency, which we believe enables more accurate analysis on larger and more complex multi-valued models.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>Source code and data are freely available at <ext-link xlink:href="https://github.com/giang-trinh/trap-mvn" ext-link-type="uri">https://github.com/giang-trinh/trap-mvn</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>L’Institut Carnot STAR, Marseille</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>European Union’s Horizon 2020</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Marie Skłodowska-Curie</institution>
          </institution-wrap>
        </funding-source>
        <award-id>101034413</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="10"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Boolean networks are simple but efficient mathematical formalism for modelling, analysing, and controlling complex biological systems (<xref rid="btad262-B30" ref-type="bibr">Schwab et al. 2020</xref>). Beyond systems biology, they have been widely applied in various areas from science to engineering (<xref rid="btad262-B30" ref-type="bibr">Schwab et al. 2020</xref>). Boolean network models of biological systems represent genes (or other species) as nodes that can take Boolean values: 1 (active) and 0 (inactive). However, having only two levels of activation may not be enough to fully capture the dynamics of real-world biological systems (<xref rid="btad262-B29" ref-type="bibr">Schaub et al. 2007</xref>). There are many examples (<xref rid="btad262-B29" ref-type="bibr">Schaub et al. 2007</xref>; <xref rid="btad262-B12" ref-type="bibr">Didier et al. 2011</xref>; <xref rid="btad262-B23" ref-type="bibr">Mushthofa et al. 2018</xref>) where the dynamics of the system can only be modelled by considering more than two activation levels. Hence, there is a crucial need to study multi-valued networks (MVNs), which are a generalization of Boolean networks (<xref rid="btad262-B25" ref-type="bibr">Naldi et al. 2007</xref>; <xref rid="btad262-B29" ref-type="bibr">Schaub et al. 2007</xref>).</p>
    <sec>
      <title>1.1 Related work</title>
      <p>Despite the importance of MVNs, only limited progress has been made on developing theories, analysis methods, and tools that can support them (<xref rid="btad262-B23" ref-type="bibr">Mushthofa et al. 2018</xref>). First, besides simulation, the analysis of logical models is mostly based around ‘attractor’ computation, since those correspond roughly to observable biological phenotypes (<xref rid="btad262-B30" ref-type="bibr">Schwab et al. 2020</xref>). For example, in gene regulatory and signalling networks, attractors can correspond to cell types, cell fates, and cyclic behaviour (e.g. circadian rhythms and cell cycles). Hence, analysis of attractors could provide new insights into systems biology. However, finding all attractors of a logical model (even for the Boolean case) is challenging due to the complex dynamics of models (<xref rid="btad262-B30" ref-type="bibr">Schwab et al. 2020</xref>). The recent study of trap spaces of Boolean networks (<xref rid="btad262-B18" ref-type="bibr">Klarner et al. 2017</xref>) made a real breakthrough in the field of systems biology, as minimal trap spaces provide very good approximations of attractors and are much easier to compute. However, there has been no similar concept defined and studied for MVNs to date.</p>
      <p>Furthermore, other biological properties, such as the gradual commitment of a cell to a specific phenotype, can be revealed through the lens of ‘succession diagrams’ constructed from the networks’ ‘maximal’ trap spaces (<xref rid="btad262-B28" ref-type="bibr">Rozum et al. 2021</xref>, <xref rid="btad262-B27" ref-type="bibr">2022</xref>). As such, minimal trap spaces are not the only relevant form of a trap space. In the <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref> (Section S4.2), we give a more detailed discussion of trap space applications in biological modelling.</p>
      <p>Second, most of the existing studies (see, e.g. <xref rid="btad262-B25" ref-type="bibr">Naldi et al. 2007</xref>; <xref rid="btad262-B29" ref-type="bibr">Schaub et al. 2007</xref>; <xref rid="btad262-B12" ref-type="bibr">Didier et al. 2011</xref> ) focus on ‘unitary’ MVNs, with only very few studies focusing on ‘general’ MVNs (see, e.g. <xref rid="btad262-B23" ref-type="bibr">Mushthofa et al. 2018</xref>). Third, to the best of our knowledge, very few methods/tools [see, e.g. GINsim (<xref rid="btad262-B27" ref-type="bibr">Naldi et al. 2007</xref>), BMA (<xref rid="btad262-B4" ref-type="bibr">Benque et al. 2012</xref>)] have been developed for MVNs. Most analysis methods/tools for logical models are designed for Boolean networks only [see, e.g. GINsim (<xref rid="btad262-B25" ref-type="bibr">Naldi et al. 2007</xref>), PyBoolNet (<xref rid="btad262-B18" ref-type="bibr">Klarner et al. 2017</xref>), mpbn (<xref rid="btad262-B26" ref-type="bibr">Paulevé et al. 2020</xref>), and Trappist (<xref rid="btad262-B33" ref-type="bibr">Trinh et al. 2022)</xref>].</p>
      <p>One notable issue is that the current supporting methods for MVNs cannot handle large and complex models (<xref rid="btad262-B25" ref-type="bibr">Naldi et al. 2007</xref> ; <xref rid="btad262-B23" ref-type="bibr">Mushthofa et al. 2018</xref>). This issue also prevents the modellers from building such models (<xref rid="btad262-B25" ref-type="bibr">Naldi et al. 2007</xref>), which could provide more accurate insights. Finally, a popular research direction is to convert an MVN to a Boolean network with similar dynamical behaviour, then applying the rich set of analysis methods/tools designed for Boolean networks. However, the existing Boolean encoding methods (e.g. the Van Ham Boolean mapping and its variants; <xref rid="btad262-B16" ref-type="bibr">Ham 1979</xref>; <xref rid="btad262-B12" ref-type="bibr">Didier et al. 2011</xref>) may not cover the full set of dynamics of the original MVN (<xref rid="btad262-B12" ref-type="bibr">Didier et al. 2011</xref>), and the encoding may even hinder the efficiency of the Boolean network methods/tools (<xref rid="btad262-B23" ref-type="bibr">Mushthofa et al. 2018</xref>). It is also worth noting that all mentioned encoding methods support only unitary MVNs. We believe that it is possible to develop direct and efficient methods for MVNs.</p>
    </sec>
    <sec>
      <title>1.2 Our contributions</title>
      <p>In this work, we study both general and unitary MVNs. Note that this inclusion of general networks is important not only in theory, but also in many biological applications (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S1</xref>). First, we generalize the concept of trap spaces in Boolean networks to that in MVNs. Second, we prove several properties of trap spaces in MVNs including (i) the separation of minimal trap spaces, (ii) their relation with respect to the Van Ham Boolean mapping, and (iii) the characterization of trap spaces through Petri net (PN) siphons. Based on this characterization, we propose a new method utilizing answer set programming (ASP; <xref rid="btad262-B14" ref-type="bibr">Gebser et al. 2011</xref>) for computing different types of trap spaces of MVNs, including generic trap spaces, maximal trap spaces, minimal trap spaces, and fixed-points (a special sub-type of trap spaces). For fixed-points, we also consider another new method, which relies on the characterization of deadlocks of the PN encoding (<xref rid="btad262-B21" ref-type="bibr">Liu and Barkaoui 2016</xref>). We evaluate the method on a collection of real-world MVNs and show its applicability in treatment prediction on a case study of Myc-deregulation in breast cancer.</p>
    </sec>
    <sec>
      <title>1.3 Paper outline</title>
      <p>This article is structured as follows: In Section 2, we formalize the notion of trap spaces in MVNs and their relationship to the PN siphons. We propose a method based on answer-set programming for computing such trap spaces efficiently. In Section 3, we present a Python package <monospace>trapmvn</monospace> that implements this method for both SBML-qual and BMA models. We demonstrate the practical performance of the method on a wide selection of real-world models. We then use <monospace>trapmvn</monospace> as part of a case study to identify viable intervention targets in a model of Myc-associated deregulation in breast cancer. Finally, Section 4 discusses the scalability of the method, its future prospects, and highlights the role of trap spaces in reliable long-term behavioural analysis of logical models.</p>
      <p>This article also has an associated supplement, in which we include the non-essential technical details of our methodology, as well as the full results of our benchmarks and case study. This article refers to this supplement where appropriate.</p>
    </sec>
  </sec>
  <sec>
    <title>2 Methods</title>
    <p>In this section, we define trap spaces of MVNs, discuss some of their theoretical properties, and finally present a method based on ASP for computing trap spaces of symbolically represented MVNs.</p>
    <sec>
      <title>2.1 MVNs</title>
      <statement id="mthst1">
        <p><sc>Definition</sc> 1. <italic toggle="yes">An MVN is a triple</italic> <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>K</mml:mi><mml:mo>,</mml:mo><mml:mi>F</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">such that:</italic></p>
      </statement>
      <list list-type="bullet">
        <list-item>
          <p>
            <inline-formula id="IE2">
              <mml:math id="IM2" display="inline" overflow="scroll">
                <mml:mrow>
                  <mml:mi>V</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mo>{</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>v</mml:mi>
                    </mml:mrow>
                    <mml:mn>1</mml:mn>
                  </mml:msub>
                  <mml:mo>,</mml:mo>
                  <mml:mo>…</mml:mo>
                  <mml:mo>,</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>v</mml:mi>
                    </mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:msub>
                  <mml:mo>}</mml:mo>
                </mml:mrow>
              </mml:math>
            </inline-formula>
            <italic toggle="yes">is an indexed set of nodes (variables).</italic>
          </p>
        </list-item>
        <list-item>
          <p><inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">is an indexed set of integer intervals, representing the domains of variables</italic> <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
        </list-item>
        <list-item>
          <p><inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>F</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">is an indexed set of update functions of variables</italic> <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">. Each f<sub>i</sub> has a signature</italic> <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:msubsup><mml:mrow><mml:mo>Π</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
        </list-item>
      </list>
      <p>With a slight abuse of notation, we write <italic toggle="yes">v<sub>i</sub></italic> to denote both the network node and the associated integer variable. Furthermore, we can also write <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to denote the domain and update function of <italic toggle="yes">v<sub>i</sub></italic>, respectively. We define <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> as the ‘state’ of the MVN, with <italic toggle="yes">x<sub>i</sub></italic> (or <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) denoting the value of <italic toggle="yes">v<sub>i</sub></italic> in the state <italic toggle="yes">x</italic>. We can also write <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mi>x</mml:mi></mml:math></inline-formula> as a vector <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. We then write <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> to denote the set of all states (‘state space’) of network <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula>. Finally, note that there are different possible formulations of update functions <italic toggle="yes">F</italic>, including fuzzy logic (<xref rid="btad262-B23" ref-type="bibr">Mushthofa et al. 2018</xref>), rule-based descriptions (<xref rid="btad262-B25" ref-type="bibr">Naldi et al. 2007</xref>; <xref rid="btad262-B11" ref-type="bibr">Delaplace and Ivanov 2020</xref>), or arithmetic expressions (<xref rid="btad262-B4" ref-type="bibr">Benque et al. 2012</xref>). We will return to this aspect when we discuss the encoding and manipulation of networks by our method.</p>
      <p>The dynamics of an MVN are studied through its ‘state-transition graph’, <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>→</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. In particular, a ‘trap’ set of <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is a set of states that is closed with respect to <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mo>→</mml:mo></mml:math></inline-formula>. A trap set is called an ‘attractor’ if it is minimal, i.e. there is no other trap set that is a proper subset of this set. However, there are different ways of defining <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, possibly leading to significantly different behavioural features.</p>
      <p>First, we divide MVNs based on the variable update scheme as ‘general’ (<xref rid="btad262-B23" ref-type="bibr">Mushthofa et al. 2018</xref>) and ‘unitary’ (<xref rid="btad262-B29" ref-type="bibr">Schaub et al. 2007</xref>; <xref rid="btad262-B11" ref-type="bibr">Delaplace and Ivanov 2020</xref>). In the general networks, the variable changes follow the update functions exactly. Meanwhile, in the unitary networks, the value of <italic toggle="yes">v<sub>i</sub></italic> can only change by ‘one level’ at a time (i.e. +1 or –1). It has been argued that unitary networks better capture the continuity of biological interactions (<xref rid="btad262-B29" ref-type="bibr">Schaub et al. 2007</xref>), but is not true universally (<xref rid="btad262-B31" ref-type="bibr">Sun et al. 2014</xref>).</p>
      <p>Note that the stepwise notion of unitary update can be in fact encoded directly into the update functions <italic toggle="yes">F</italic>. Specifically, we define <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to represent the update function which adheres to the chosen variable update. That is, <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for general MVNs and <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula> for unitary MVNs, where <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>0 if <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>1 if <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>&lt;</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and <italic toggle="yes">d</italic> = – 1 when <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>&gt;</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>The second aspect of MVN semantics is the concurrency of updates. Here, two prevalent approaches are the ‘synchronous’ (all variables update together) and ‘asynchronous’ update (exactly one variable updates non-deterministically in each step).</p>
      <p>Note that for the same MVN, different update schemes may result in vastly different state-transition graphs (<xref rid="btad262-B32" ref-type="bibr">Thomas 1991</xref>). Consider the MVN <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula> with <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> (Example 2 in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref>). <xref rid="btad262-F1" ref-type="fig">Figure 1(a)</xref> shows the state transition graph of <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula> under the general update scheme. This graph has six trap sets: {[0 1]}, {[1 1]}, {[0 0], [0 2]}, {[0 1], [1 1]}, {[0 0], [0 1], [0 2]}, and {[0 0], [0 1], [0 2], [1 0], [1 1], [1 2]}. Out of these, three are attractors (minimal trap sets): {[0 1]}, {[1 1]}, and {[0 0], [0 2]}. Meanwhile, <xref rid="btad262-F1" ref-type="fig">Fig. 1(b)</xref> shows the state transition graph of <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula> using the unitary update scheme, which admits only two attractors: {[0 1]} and {[1 1]}.</p>
      <fig position="float" id="btad262-F1">
        <label>Figure 1.</label>
        <caption>
          <p><inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of the example MVN under general (a) and unitary update schemes (b). Attractors are highlighted in bold.</p>
        </caption>
        <graphic xlink:href="btad262f1" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>2.2 Trap spaces of MVNs</title>
      <p>Overall, this variability under different update schemes motivates the study of ‘trap spaces’. In the Boolean case, trap spaces have been shown to be a good approximation of network attractors, regardless of the chosen update concurrency (<xref rid="btad262-B26" ref-type="bibr">Paulevé et al. 2020</xref>). Here, we thus establish trap spaces for MVNs with a similar goal in mind:<statement id="mthst2"><p><sc>Definition</sc> 2. <italic toggle="yes">A space m of</italic> <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">is a mapping which assigns each</italic> <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">a non-empty subset of K<sub>i</sub>:</italic> <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">. We write</italic> <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>⋆</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula><italic toggle="yes">to denote the set of all spaces of</italic> <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula>.</p></statement></p>
      <p>With a slight abuse of notation, we can also interpret <italic toggle="yes">m</italic> as a subset of <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, writing <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula> for a state <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> when <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for all <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>. Subsequently, we can define trap spaces as follows:<statement id="mthst3"><p><sc>Definition</sc> 3. <italic toggle="yes">A trap space is a space m such that for every state</italic> <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">and variable</italic> <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">, we have</italic> <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p></statement></p>
      <p>In other words, in all states represented by <italic toggle="yes">m</italic>, all update functions only produce values that stay within <italic toggle="yes">m</italic>, meaning no <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (regardless of the update concurrency) can contain a transition which leaves <italic toggle="yes">m</italic>. Consequently, trap spaces of an MVN are independent on its concurrency update, is not true for the case of attractors. Note the use of <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, meaning that the notion of trap space respects the choice of unitary or general variable update.</p>
      <p>When interpreting spaces <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>⋆</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> as subsets of <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we can trivially establish a sub-space relation on <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>⋆</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>, which allows us to reason about ‘minimal’ and ‘maximal’ trap spaces:<statement id="mthst4"><p><sc>Definition</sc> 4. <italic toggle="yes">A trap space m is minimal if and only if there is no trap space</italic> <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>⋆</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula><italic toggle="yes">s.t.</italic> <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>′</mml:mo><mml:mo>⊂</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">. Analogously, a trap space m is maximal if and only if</italic> <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>⊂</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">, and there is no trap space</italic> <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>⋆</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula><italic toggle="yes">s.t.</italic> <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>⊂</mml:mo><mml:mi>m</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>.</p></statement></p>
      <p>Note that for the notion of maximal subspace, we require that <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>⊂</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Otherwise, a trivial space <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mo>⋆</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> which represents all network states (i.e. <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mo>⋆</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) is always a trap space, and always a superset of all other trap spaces.</p>
      <p>For illustration, reconsider the example MVN (<xref rid="btad262-F1" ref-type="fig">Fig. 1</xref>). Its general counterpart has six trap spaces as follows:
</p>
      <disp-formula id="E1">
        <mml:math id="M1" display="block" overflow="scroll">
          <mml:mtable>
            <mml:mtr>
              <mml:mtd>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>m</mml:mi>
                  </mml:mrow>
                  <mml:mn>1</mml:mn>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>,</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>m</mml:mi>
                  </mml:mrow>
                  <mml:mn>2</mml:mn>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>,</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>m</mml:mi>
                  </mml:mrow>
                  <mml:mn>3</mml:mn>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mn>2</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>,</mml:mo>
              </mml:mtd>
            </mml:mtr>
            <mml:mtr>
              <mml:mtd>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>m</mml:mi>
                  </mml:mrow>
                  <mml:mn>4</mml:mn>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>,</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>m</mml:mi>
                  </mml:mrow>
                  <mml:mn>5</mml:mn>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mn>2</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>,</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>m</mml:mi>
                  </mml:mrow>
                  <mml:mn>6</mml:mn>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mn>2</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>.</mml:mo>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>Out of these, three are minimal trap spaces (<inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>) and two are maximal trap spaces (<inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>5</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>). Meanwhile, its unitary counterpart has two minimal trap spaces (<inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>}</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>) and three maximal trap spaces (<inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>}</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>). Finally, let us observe the following:<statement id="mthst5"><p><sc>Theorem</sc> 1 (Separation of minimal trap spaces). <italic toggle="yes">Let m<sub>1</sub> and m<sub>2</sub> be two distinct minimal trap spaces of</italic> <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula><italic toggle="yes">. Then</italic> <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula>.</p></statement></p>
      <p>The proof is available in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref> as Theorem 3.</p>
      <p>By Definition 3 and the definition of a trap set, a trap space is also a trap set of an MVN for any chosen update concurrency. As a consequence, each trap space must contain at least one attractor of the MVN. By <xref rid="mthst5" ref-type="statement">Theorem 1</xref>, any two distinct minimal trap spaces are disjoint; thus, the attractors contained in them are also disjoint. Hence, we can conclude that regardless of the chosen update concurrency, minimal trap spaces can be used as approximations of attractors in MVNs: The number of minimal trap spaces under-approximates the number of attractors (there can be other attractors that are not contained in minimal trap spaces), and each minimal trap space over-approximates at least a single attractor. <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S3.3</xref> presents additional examples of relations between attractors and minimal trap spaces.</p>
    </sec>
    <sec>
      <title>2.3 Translation to Boolean networks</title>
      <p>When <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> for all <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>, we can refer to <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula> as a ‘Boolean network’ <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">N</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>F</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> instead. For Boolean networks, the notion of trap spaces is well known, including efficient tools for computation of minimal and maximal trap spaces (<xref rid="btad262-B18" ref-type="bibr">Klarner et al. 2017</xref>; <xref rid="btad262-B26" ref-type="bibr">Paulevé et al. 2020</xref>; <xref rid="btad262-B33" ref-type="bibr">Trinh et al. 2022</xref>).</p>
      <p>There are several works (<xref rid="btad262-B12" ref-type="bibr">Didier et al. 2011</xref>; <xref rid="btad262-B11" ref-type="bibr">Delaplace and Ivanov 2020</xref>) attempting to encode the multi-valued dynamics of an MVN into a Boolean network. Probably, the most widely used being the Van Ham encoding (<xref rid="btad262-B16" ref-type="bibr">Ham 1979</xref>), implemented in the tools <monospace>GINsim</monospace> (<xref rid="btad262-B6" ref-type="bibr">Chaouiya et al. 2011a</xref>, <xref rid="btad262-B9" ref-type="bibr">2011b</xref>) and <monospace>bioLQM</monospace> (<xref rid="btad262-B8" ref-type="bibr">Chaouiya et al. 2013</xref>). The core idea of the Van Ham encoding is to expand each multi-valued variable <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula> into <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> Boolean variables, such that an integer value <italic toggle="yes">v </italic>=<italic toggle="yes"> k</italic> is encoded as the truth value of the first <italic toggle="yes">k</italic> Boolean variables. The main advantage of this encoding is that any unitary state change only involves a single Boolean variable. The disadvantage is that the encoding admits invalid states which do not correctly encode any integer and may interfere with the actual dynamics of the model. More details about the Van Ham encoding are given in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S2.3</xref>.</p>
      <p>It is known that the Van Ham encoding preserves attractors of unitary networks (<xref rid="btad262-B12" ref-type="bibr">Didier et al. 2011</xref>). Nevertheless, it is unclear whether this mapping also preserves trap spaces in general. To answer this question, we present the following proposition, the proofs for which can be found in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref>.<statement id="mthst6"><p><sc>Proposition</sc> 1. <italic toggle="yes">Let</italic> <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">N</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">denote the Van Ham encoding of a</italic> MVN <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula><italic toggle="yes">. Then, it holds that:</italic></p></statement></p>
      <list list-type="bullet">
        <list-item>
          <p><italic toggle="yes">There is a general MVN</italic> <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula><italic toggle="yes">for which neither the maximal nor minimal trap spaces of</italic> <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">N</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">correspond to the respective trap spaces of</italic> <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula>.</p>
        </list-item>
        <list-item>
          <p><italic toggle="yes">There is a unitary MVN</italic> <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula><italic toggle="yes">such that the maximal trap spaces of</italic> <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">N</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">do not correspond to the maximal trap spaces of</italic> <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula>.</p>
        </list-item>
        <list-item>
          <p><italic toggle="yes">For every unitary MVN</italic> <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula><italic toggle="yes">, the minimal trap spaces of</italic> <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">N</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">correspond to the minimal trap spaces of</italic> <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula>.</p>
        </list-item>
      </list>
      <p>This proposition states that the Van Ham encoding is still applicable for computation of minimal trap spaces of unitary networks, but cannot be used beyond this particular problem class.</p>
    </sec>
    <sec>
      <title>2.4 Computing trap spaces through PN siphons</title>
      <p>To tackle the problem of trap space computation of MVNs, we instead propose a different approach, based on an encoding of the problem into an answer-set programming query.</p>
      <sec>
        <title>2.4.1 PN encoding of MVNs</title>
        <p>First, let us establish a characterization of trap spaces through conflict-free PN siphons.<statement id="mthst7"><p><sc>Definition</sc> 5. <italic toggle="yes">A one-safe PN is a bipartite-directed graph</italic> <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">P</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>W</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">, where P and T are disjoint finite sets of vertices called places and transitions</italic>, <italic toggle="yes">respectively. Set W describes the arcs between places and transitions:</italic> <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:mi>W</mml:mi><mml:mo>⊆</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo>×</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>×</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p></statement></p>
        <p>A <italic toggle="yes">marking M</italic> of a one-safe PN is a subset <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo>⊆</mml:mo><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
        <p>For <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>P</mml:mi><mml:mo>∪</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula>, we write pred(<italic toggle="yes">x</italic>) and succ(<italic toggle="yes">x</italic>) to denote the predecessors and successors of <italic toggle="yes">x</italic> with respect to <italic toggle="yes">W</italic> (this notation naturally extends to subsets of <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>∪</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula>). The dynamics of a PN are dictated by the ‘firing of transitions’, such that a transition <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula> can be fired non-deterministically in the marking <italic toggle="yes">M</italic> if <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:mtext>pred</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:math></inline-formula>. The result is a new marking <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>∖</mml:mo><mml:mtext>pred</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mtext>succ</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This process defines a state-transition graph with vertices as the possible markings.</p>
        <p>In the appendix of <xref rid="btad262-B10" ref-type="bibr">Chatain et al. (2014)</xref>, the authors present a PN encoding of the ‘asynchronous’ MVN dynamics, which we briefly recall here. Note that this is not the only PN encoding of MVNs (see, e.g. <xref rid="btad262-B7" ref-type="bibr">Chaouiya et al. 2004</xref>, <xref rid="btad262-B6" ref-type="bibr">2011a</xref>, <xref rid="btad262-B9" ref-type="bibr">2011b</xref>), but to the best of our knowledge, the other encodings are not particularly suitable for the characterization of trap spaces.</p>
        <p>Let <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> denote the one-safe PN encoding of an MVN <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula> based on <xref rid="btad262-B10" ref-type="bibr">Chatain et al. (2014)</xref>. The places <italic toggle="yes">P</italic> of <inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> contain one place for every level of every MVN variable: <inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:munder><mml:mo>∪</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. The set of transitions and arcs is then constructed such that the firing of a transition mirrors a possible update of an MVN variable. For example, let <inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula> be such that for every <inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we have <inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>∧</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⇒</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:math></inline-formula> (with <inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:mi>o</mml:mi><mml:menclose notation="updiagonalstrike"><mml:mo>=</mml:mo></mml:menclose><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>). We then create a transition <italic toggle="yes">t</italic> with <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:mtext>pred</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:mtext>succ</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Such transition ‘moves’ a token from <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> under the assumption <italic toggle="yes">u</italic> = <italic toggle="yes">l</italic>. Note that there are many possible combinations of sets <italic toggle="yes">T</italic> and <italic toggle="yes">W</italic> that are valid for a particular <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula>. Later, we show how we compute these sets in our case.</p>
        <p>Finally, let <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>⋆</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> be a space of <inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula>. We write that a set of places <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>⊆</mml:mo><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula> is the ‘mirror’ of <italic toggle="yes">m</italic> when for every <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⇔</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:menclose notation="updiagonalstrike"><mml:mo>∈</mml:mo></mml:menclose><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula>. That is, <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> contains the places corresponding to the ‘inverse’ of <italic toggle="yes">m</italic>. Observe that a state <inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is also a (trivial) space, and hence has a mirror <inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
      <sec>
        <title>2.4.2 Siphon characterization of MVN trap spaces</title>
        <statement id="mthst8">
          <p><sc>Definition</sc> 6. <italic toggle="yes">A PN siphon</italic> <inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo>⊆</mml:mo><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">is a set of places such that for all</italic> <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>∩</mml:mo><mml:mtext>succ</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:menclose notation="updiagonalstrike"><mml:mo>=</mml:mo></mml:menclose><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">implies</italic><inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>∩</mml:mo><mml:mtext>pred</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:menclose notation="updiagonalstrike"><mml:mo>=</mml:mo></mml:menclose><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        </statement>
        <p>Intuitively, a <italic toggle="yes">siphon S</italic> preserves the condition that if all places in <italic toggle="yes">S</italic> are unmarked (<inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo>∩</mml:mo><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula>), the siphon remains unmarked. Furthermore, for a PN <inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we say that a siphon is ‘conflict-free’ when for all <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>, we have that <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>}</mml:mo><mml:mo>∖</mml:mo><mml:mi>S</mml:mi><mml:menclose notation="updiagonalstrike"><mml:mo>=</mml:mo></mml:menclose><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula>. That is, a conflict-free siphon must not contain ‘all’ places encoding a particular variable. Intuitively, every conflict-free siphon of <inline-formula id="IE124"><mml:math id="IM124" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> represents a mirror of ‘some’ space <inline-formula id="IE125"><mml:math id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>⋆</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> (however, not all mirrors of spaces are siphons).</p>
        <p>With this knowledge, we can observe the following theorem:<statement id="mthst9"><p><sc>Theorem</sc> 2. <italic toggle="yes">Let</italic> <inline-formula id="IE126"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula><italic toggle="yes">be an MVN and</italic> <inline-formula id="IE127"><mml:math id="IM127" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">its PN encoding. Then a space</italic> <inline-formula id="IE128"><mml:math id="IM128" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>⋆</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula><italic toggle="yes">is a trap space if and only if its mirror</italic> <inline-formula id="IE129"><mml:math id="IM129" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">is a conflict-free siphon of</italic> <inline-formula id="IE130"><mml:math id="IM130" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p></statement></p>
        <p>The proof is available in the Supplementary Data as Theorem 5.</p>
        <p>Finally, note that we can define a partial order on siphons based on the subset relation, just as we did for trap spaces. Based on the definition of a mirror and the correspondence we just proved, we can easily deduce the following (see the proofs of Theorems 6 and 7 in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref>):<statement id="mthst10"><p><sc>Proposition</sc> 2. <italic toggle="yes">A trap space m of an MVN</italic> <inline-formula id="IE131"><mml:math id="IM131" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula><italic toggle="yes">is minimal if</italic> <inline-formula id="IE132"><mml:math id="IM132" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">is a maximal conflict-free siphon of</italic> <inline-formula id="IE133"><mml:math id="IM133" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">. A trap space m is maximal if</italic> <inline-formula id="IE134"><mml:math id="IM134" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">is a minimal conflict-free siphon.</italic></p></statement></p>
        <p>Observe that there are existing methods based on ASP (<xref rid="btad262-B33" ref-type="bibr">Trinh et al. 2022</xref>) and SAT solving (<xref rid="btad262-B24" ref-type="bibr">Nabli et al., 2016</xref>) that can handle enumeration of maximal (respectively, minimal) siphons and have been successfully used on Boolean networks before (<xref rid="btad262-B33" ref-type="bibr">Trinh et al. 2022</xref>). Our result shows that these methods should be also applicable to MVNs. Specifically, we aim to extend the ASP encoding from (<xref rid="btad262-B33" ref-type="bibr">Trinh et al. 2022</xref>) in order to support both maximal and minimal trap spaces of both general and unitary MVNs.</p>
      </sec>
      <sec>
        <title>2.4.3 Siphon computation through ASP encoding</title>
        <p>For now, we neglected the question of update function representation for MVNs, as this depends strongly on the chosen input format. In our work, we consider both SBML-qual (<xref rid="btad262-B8" ref-type="bibr">Chaouiya et al. 2013</xref>) and BMA (BioModelAnalyzer) (<xref rid="btad262-B4" ref-type="bibr">Benque et al. 2012</xref>) formats. These differ significantly in terms of both format and capabilities.</p>
        <p>Ultimately, we represent an update function <italic toggle="yes">f<sub>i</sub></italic> using a series of ‘binary decision diagrams’ (BDDs) (<xref rid="btad262-B5" ref-type="bibr">Bryant 1986</xref>) <inline-formula id="IE135"><mml:math id="IM135" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. The network variables are encoded into Boolean variables <inline-formula id="IE136"><mml:math id="IM136" display="inline" overflow="scroll"><mml:mrow><mml:munder><mml:mo>∪</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, just as in the case of the PN encoding. Subsequently, each BDD in the series gives the necessary and sufficient conditions for achieving a particular result level:
</p>
        <disp-formula id="E2">
          <mml:math id="M2" display="block" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>f</mml:mi>
                </mml:mrow>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>x</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:mrow>
                <mml:mo>{</mml:mo>
                <mml:mrow>
                  <mml:mtable>
                    <mml:mtr columnalign="left">
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>y</mml:mi>
                            </mml:mrow>
                            <mml:mn>1</mml:mn>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>B</mml:mi>
                            </mml:mrow>
                            <mml:mn>1</mml:mn>
                          </mml:msub>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mi>x</mml:mi>
                          <mml:mo stretchy="false">)</mml:mo>
                          <mml:mo>=</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr columnalign="left">
                      <mml:mtd columnalign="left">
                        <mml:mo>…</mml:mo>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mrow/>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr columnalign="left">
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>y</mml:mi>
                            </mml:mrow>
                            <mml:mi>k</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>B</mml:mi>
                            </mml:mrow>
                            <mml:mi>k</mml:mi>
                          </mml:msub>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mi>x</mml:mi>
                          <mml:mo stretchy="false">)</mml:mo>
                          <mml:mo>=</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:mrow>
              </mml:mrow>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p>Here, <inline-formula id="IE137"><mml:math id="IM137" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">B<sub>i</sub></italic> are individual BDDs, such that each BDD can be interpreted as a Boolean function on the encoded state <italic toggle="yes">x</italic>. We also require that for each state, there is exactly one BDD <italic toggle="yes">B<sub>j</sub></italic> s.t. <inline-formula id="IE138"><mml:math id="IM138" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, hence the whole function is well defined. Also, note that such <italic toggle="yes">f<sub>i</sub></italic> can be easily transformed into <inline-formula id="IE139"><mml:math id="IM139" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, respecting either general or unitary variable update as desired.</p>
        <p>This representation is relatively straightforward to obtain for SBML-qual models, as each update function is given as a list of Boolean terms over standard equality/inequality integer propositions. In this representation, the output values can repeat across multiple terms, and the function is not required to be exhaustive (there is a ‘default’ output value assigned to remaining inputs). However, this is easy to amend once each term is transformed into a symbolic BDD representation (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref>).</p>
        <p>For BMA, the translation process is more involved, as update functions are described through a language of algebraic expressions including addition (+), subtraction (–), multiplication (<inline-formula id="IE140"><mml:math id="IM140" display="inline" overflow="scroll"><mml:mo>·</mml:mo></mml:math></inline-formula>), and division (<inline-formula id="IE141"><mml:math id="IM141" display="inline" overflow="scroll"><mml:mo>/</mml:mo></mml:math></inline-formula>), as well as other special functions like average and rounding. Furthermore, BMA employs a normalizing transformation on function inputs when the input domain differs from the output domain. That is, an input variable <italic toggle="yes">v</italic> in the range <inline-formula id="IE142"><mml:math id="IM142" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is normalized to the range <inline-formula id="IE143"><mml:math id="IM143" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> when used in the update function <italic toggle="yes">f<sub>u</sub></italic>. As such, while BMA only admits integer variables, the update functions are more akin to rational functions.</p>
        <p>While there are frameworks which partially support symbolic evaluation of such functions, e.g. algebraic decision diagrams (<xref rid="btad262-B2" ref-type="bibr">Bahar et al. 1997</xref>), we are not aware of any implementation that would support all the operations required by BMA. We thus opted to enumerate the whole function table and re-encode it back into individual BDDs.</p>
        <p>Finally, to encode the dynamics of <inline-formula id="IE144"><mml:math id="IM144" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> into a PN, we consider all variable updates <inline-formula id="IE145"><mml:math id="IM145" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>→</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (with <italic toggle="yes">k</italic> being <inline-formula id="IE146"><mml:math id="IM146" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>±</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> when <inline-formula id="IE147"><mml:math id="IM147" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula> is unitary), and then enumerate all satisfying partial valuations <italic toggle="yes">w</italic> of the BDD <inline-formula id="IE148"><mml:math id="IM148" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>∧</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>B</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (<inline-formula id="IE149"><mml:math id="IM149" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>B</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> being the BDD of <inline-formula id="IE150"><mml:math id="IM150" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> for output level <italic toggle="yes">k</italic>). For every valuation <italic toggle="yes">w</italic>, a transition <inline-formula id="IE151"><mml:math id="IM151" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula> is created which moves the token from <inline-formula id="IE152"><mml:math id="IM152" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE153"><mml:math id="IM153" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> while ensuring that for every other relevant <inline-formula id="IE154"><mml:math id="IM154" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>, place <inline-formula id="IE155"><mml:math id="IM155" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> contains a token.</p>
        <p>Note that the number of satisfying partial valuations <italic toggle="yes">w</italic> of a BDD (and transitively, the number of PN transitions) depends on the ‘ordering’ of Boolean variables within the BDD. However, computing the optimal variable ordering is a known non-trivial problem. To reduce the number of transitions in the resulting PN, we always test <italic toggle="yes">k</italic> randomized orderings for every update function and pick the one which produces the most compact PN.</p>
        <p>Once the PN encoding <inline-formula id="IE156"><mml:math id="IM156" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is completed, the method proceeds based on the ASP encoding of the PN siphon problem proposed by <xref rid="btad262-B33" ref-type="bibr">Trinh et al. (2022)</xref>. This encoding produces a query which can be processed by an ASP solver such as <monospace>clingo</monospace> (<xref rid="btad262-B14" ref-type="bibr">Gebser et al. 2011</xref>), enumerating all maximal/minimal siphons of <inline-formula id="IE157"><mml:math id="IM157" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Technical aspects of this process are given in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref>.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>We now present the results of our computational experiments. First, we establish the benchmark model dataset and describe the overall implementation of our tool <monospace>trapmvn</monospace>. We then present the performance evaluation of <monospace>trapmvn</monospace> in relation to the benchmark models and other tools (where applicable). Finally, we use the trap spaces arising under a wide range of therapeutic interventions in a Myc-deregulation model of breast cancer to assess the viability and reliability of such interventions.</p>
    <sec>
      <title>3.1 Experiment setup</title>
      <p>In our testing, we utilize SBML models from the BBM benchmark (<ext-link xlink:href="https://github.com/sybila/biodivine-boolean-models/" ext-link-type="uri">https://github.com/sybila/biodivine-boolean-models/</ext-link>; note that BBM primarily publishes Booleanized SBML models, but the original multi-valued SBML files are also available.), which includes models from the GINsim tool (<xref rid="btad262-B6" ref-type="bibr">Chaouiya et al. 2011a</xref>, <xref rid="btad262-B9" ref-type="bibr">2011b</xref>) repository as well as other independently sourced models. Furthermore, we include models from the BMA tool (<ext-link xlink:href="http://biomodelanalyzer.org" ext-link-type="uri">http://biomodelanalyzer.org</ext-link>) repository (<xref rid="btad262-B4" ref-type="bibr">Benque et al. 2012</xref>). Disregarding trivial cases, we are left with 26 benchmark models. To the best of our knowledge, this is a highly representative sample of multi-valued models currently available in literature. The details of each benchmark model, technical description of the performance testing, as well as full results are given in Section 6 of the <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref>.</p>
    </sec>
    <sec>
      <title>3.2 The <monospace>trapmvn</monospace> package</title>
      <p>We implement our method as a stand-alone open-source Python package <monospace>trapmvn</monospace>. The package provides a basic parser for both SBML and BMA models (JSON or XML). It implements the symbolic encoding for both formats using the BDD data structure from the <monospace>AEON.py</monospace> package (<xref rid="btad262-B3" ref-type="bibr">Beneš et al. 2022</xref>). From this symbolic encoding, we build either a ‘general’ or a ‘unitary’ one-safe PN. Such PN can be then encoded into the ASP query for the respective problem class and processed by the solver <monospace>clingo</monospace> (<xref rid="btad262-B14" ref-type="bibr">Gebser et al. 2011</xref>). All these steps are available to the user through several Python classes, but can be also handled directly by a simple command line interface. Finally, we also support export of the symbolic model representation back into SBML. This allows us to convert BMA models to SBML (to the best of our knowledge, this is not supported by any other tool).</p>
    </sec>
    <sec>
      <title>3.3 Performance evaluation</title>
      <p>Due to the lack of both theory and available tools, we are not aware of any existing study of trap spaces in MVNs. Nevertheless, as we have shown, the Van Ham encoding (<xref rid="btad262-B16" ref-type="bibr">Ham 1979</xref>) preserves the ‘minimal’ trap spaces under unitary semantics. Tools for computing minimal trap spaces of plain Boolean networks can be thus used in this case. We use <monospace>bioLQM</monospace> (<xref rid="btad262-B8" ref-type="bibr">Chaouiya et al. 2013</xref>) to compute the Van Ham encoding when necessary.</p>
      <p>We can also consider fixed-points as a special (simpler) class of trap spaces. We can thus also compare with tools that specialize in this type of problem. Consequently, our performance evaluation consists of three parts: ‘minimal’ and ‘maximal’ trap spaces, and ‘fixed-points’.</p>
      <sec>
        <title>3.3.1 Minimal trap spaces</title>
        <p>To test the performance of <monospace>trapmvn</monospace> when computing minimal trap spaces, we compare its runtime to two state-of-the-art tools for trap space computation in Boolean networks, <monospace>trappist</monospace> (<xref rid="btad262-B33" ref-type="bibr">Trinh et al. 2022)</xref> and <monospace>mpbn</monospace> (<xref rid="btad262-B26" ref-type="bibr">Paulevé et al. 2020</xref>) (using the Van Ham encoding). Because the number of trap spaces can be large and the knowledge of all trap spaces is not always required, we consider two experiment settings: computing just ‘one’ and computing ‘all’ minimal trap spaces. The full results of this analysis are available in <xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S5 and S6</xref>.</p>
        <p>In general, <monospace>trapmvn</monospace> can handle all models in reasonable time for both the general and unitary semantics. Focusing on the unitary case, the difference in runtime when computing all minimal trap spaces is summarized in <xref rid="btad262-F2" ref-type="fig">Fig. 2</xref>. Here, we see that <monospace>trapmvn</monospace> performs substantially better than <monospace>mpbn</monospace>, and is also always faster than <monospace>trappist</monospace>. However, the exact speed-up is hard to assess due to the presence of logarithmic time scales. As such, we also provide a simple box plot comparing the actual speed-up in <xref rid="btad262-F3" ref-type="fig">Fig. 3</xref>. Here, we see that <monospace>trapmvn</monospace> outperforms both methods by a significant margin in both scenarios (i.e. first result and all results). We also compute the average speed-up weighted by the absolute runtime of each benchmark (i.e. longer running benchmarks are given higher weight), showing that when computing ‘all’ trap spaces, <monospace>trapmvn</monospace> is <inline-formula id="IE158"><mml:math id="IM158" display="inline" overflow="scroll"><mml:mrow><mml:mn>3</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster than <monospace>trappist</monospace>, and <inline-formula id="IE159"><mml:math id="IM159" display="inline" overflow="scroll"><mml:mrow><mml:mn>58</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster than <monospace>mpbn</monospace>.</p>
        <fig position="float" id="btad262-F2">
          <label>Figure 2.</label>
          <caption>
            <p>Relative performance of <monospace>trapmvn</monospace> compared with <monospace>trappist</monospace> and <monospace>mpbn</monospace> when counting all minimal trap spaces. The time scales are logarithmic. Points at the edge of the graph represent timeouts.</p>
          </caption>
          <graphic xlink:href="btad262f2" position="float"/>
        </fig>
        <fig position="float" id="btad262-F3">
          <label>Figure 3.</label>
          <caption>
            <p>Relative speed-up in runtime of <monospace>trap-mvn</monospace> compared with <monospace>trappist</monospace> (top), res. <monospace>mpbn</monospace> (bottom).</p>
          </caption>
          <graphic xlink:href="btad262f3" position="float"/>
        </fig>
      </sec>
      <sec>
        <title>3.3.2 Maximal trap spaces</title>
        <p>The Van Ham encoding is not suitable for preserving ‘maximal’ trap spaces, and we are not aware of any existing method that can efficiently transform this problem to the domain of Boolean networks. As such, we cannot compare <monospace>trapmvn</monospace> to any other tool for this problem class. Nevertheless, we show that <monospace>trapmvn</monospace> can easily compute all maximal trap spaces of the considered benchmark models (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S7</xref>).</p>
      </sec>
      <sec>
        <title>3.3.3 Fixed-points</title>
        <p>Finally, for the case of fixed-points, there are two viable ASP encodings, one based on PN siphons and the other based on PN deadlocks. The encoding based on deadlocks is generally more efficient for this simpler problem class. As such, we implement both variants in <monospace>trapmvn</monospace> and compare the results to the Booleanized results from the tools <monospace>trappist</monospace> (<xref rid="btad262-B33" ref-type="bibr">Trinh et al. 2022</xref>) and <monospace>mpbn</monospace> (<xref rid="btad262-B26" ref-type="bibr">Paulevé et al. 2020</xref>), and multi-valued results from <monospace>AN-ASP</monospace> (<xref rid="btad262-B1" ref-type="bibr">Abdallah et al. 2017</xref>). Overall, our evaluation confirms the benefits of the deadlock-based encoding, showing a <inline-formula id="IE160"><mml:math id="IM160" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.6</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> speed-up compared with the siphon encoding (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S8</xref>). Furthermore, we show that <monospace>trapmvn</monospace> also performs better than <monospace>trappist</monospace> or <monospace>mpbn</monospace> on fixed-point computation, but is outperformed by <monospace>AN-ASP</monospace> (<inline-formula id="IE161"><mml:math id="IM161" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.3</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> speed-up), since <monospace>AN-ASP</monospace> is optimized solely for this specific type of problem.</p>
      </sec>
    </sec>
    <sec>
      <title>3.4 Therapeutic interventions of Myc-deregulation</title>
      <p>To demonstrate the practical utility of <monospace>trapmvn</monospace> in biological modelling, we present a case study expanding on the findings of <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref>. The authors of <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref> use <monospace>BMA</monospace> (<xref rid="btad262-B4" ref-type="bibr">Benque et al. 2012</xref>) to explore viable therapeutic interventions in a large computational model of breast cancer through the lens of network attractors. Here, we show how to more reliably interpret the model by focusing on trap spaces instead.</p>
      <sec>
        <title>3.4.1 Modelling Myc heterogeneity in breast cancer</title>
        <p>The Myc transcription factor is one of the key coordinators in cell proliferation and regeneration (<xref rid="btad262-B19" ref-type="bibr">Kortlever et al. 2017</xref>). As such, oncogenic deregulations of Myc are commonplace in many cancers, breast cancer in particular (<xref rid="btad262-B34" ref-type="bibr">Vita and Henriksson 2006</xref>).</p>
        <p>Still, most tumours have been shown to consist of several genetically distinct mutants, only some of which exhibit Myc overexpression (<xref rid="btad262-B15" ref-type="bibr">Gerlinger et al. 2012</xref>; <xref rid="btad262-B17" ref-type="bibr">Heselmeyer-Haddad et al. 2012</xref>). Such heterogeneity can impede some treatments, but it can also enable new therapies that target the cooperation between the mutants (<xref rid="btad262-B22" ref-type="bibr">Marusyk et al. 2014</xref>; <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. 2019</xref>).</p>
        <p>In the case of Myc-related mutations, an overexpression of Myc is linked to super-competitive behaviour that causes the cancerous cells to outproliferate their healthy neighbours. However, the same overexpression is also linked to greatly increased predisposition to apoptosis. In <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref>, the authors reveal a mechanism by which Myc<sup>high</sup> mutants survive using a supply of Wnt1 transcription factor produced by a different, Myc<sup>low</sup> mutant.</p>
        <p>This process is demonstrated both experimentally on <italic toggle="yes">in vivo</italic> mouse models, as well as <italic toggle="yes">in silico</italic> on a large-scale multi-valued computational model. Based on the intervention response observed <italic toggle="yes">in silico</italic>, the authors identify a viable therapy targeting COX2 and MEK transcription factors and validate this therapy <italic toggle="yes">in vivo</italic>.</p>
        <p>The model itself consists of 72 variables, ranging from 4 to 7 levels (<monospace>MYC IN-VIVO</monospace> in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S5</xref>). It is based on known literature, with additional validation and tuning using several independent datasets. There are five model variants: A healthy ‘wild-type’ (WT) model, Myc<sup>low</sup> and Myc<sup>high</sup> variants where the tumour consists homogeneously of a single mutant, and finally, mix-Myc<sup>low</sup> and mix-Myc<sup>high</sup> variants, which describe a heterogeneous tumour. In this case, the interaction is given as an outside assumption; there is no single model consisting of both Myc<sup>low</sup> and Myc<sup>high</sup> mutants sharing a state space.</p>
        <p>To study the effects of possible therapeutic interventions, the authors compare the ‘synchronous’ attractors approximated by <monospace>BMA</monospace> across a range of single and dual variable knockouts. The effect of each intervention on the real-world phenotypes is assessed through variables <monospace>Apoptosis</monospace> and <monospace>Proliferation</monospace> which are directly embedded into the network. While this methodology is viable, it has shortcomings which we hope to address.</p>
        <p>First, while <monospace>BMA</monospace> should be capable of computing the ‘exact’ synchronous attractors, the results in <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref> are only based on an ‘approximate’ method, due to the (lack of) scalability of the exact method. Second, the ‘synchronous’ update scheme can miss plausible model behaviour due to artificial synchronization between variables (<xref rid="btad262-B30" ref-type="bibr">Schwab et al. 2020</xref>). Meanwhile, trap spaces are universal regardless of the chosen update scheme (<xref rid="btad262-B26" ref-type="bibr">Paulevé et al. 2020</xref>). Finally, for non-trivial attractors, the case study in <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref> only considers the ‘average’ values of <monospace>Apoptosis</monospace> and <monospace>Proliferation</monospace>, which can be a poor approximation of the model’s actual admissible behaviour. This is despite the fact that BMA ‘can’ also compute the estimated attractor intervals.</p>
      </sec>
      <sec>
        <title>3.4.2 Single intervention effects</title>
        <p>We start by replicating the single-variable knockout interventions performed in <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref>, but in the context of trap spaces. Highlights from this analysis are presented in <xref rid="btad262-T1" ref-type="table">Table 1</xref> (full data are available in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref>). These results are in many aspects comparable to the original results obtained through <monospace>BMA</monospace>, however, they often paint a more complete picture of the model’s behaviour.</p>
        <table-wrap position="float" id="btad262-T1">
          <label>Table 1.</label>
          <caption>
            <p>Effects of selected single-node perturbations on proliferation (left) and apoptosis (right).</p>
          </caption>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col valign="top" align="left" span="1"/>
            </colgroup>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">
                  <inline-graphic xlink:href="btad262ilf1.jpg"/>
                </td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <fn id="tblfn1">
              <p>Intervals show non-trivial trap spaces. Values with asterisk show improvements over BMA approximate result.</p>
            </fn>
          </table-wrap-foot>
        </table-wrap>
        <p>First, there are four instances where our ‘exact’ method actually improves the precision of the original ‘approximate’ result (marked with an asterisk). Note that the more specific result is in all cases at the edge of the interval established by <monospace>BMA</monospace>, which means that it substantially differs from the ‘average’ considered in <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref>.</p>
        <p>Second, there are clearly many cases where the intervention causes the appearance of a non-trivial trap space, signified by an interval instead of a fixed value. Knowledge of these intervals is crucial when interpreting the effectiveness of interventions.</p>
        <p>For example, consider the value of <monospace>Apoptosis</monospace> for the knockouts of Mcl1 and COX2 in mix-Myc<sup>low</sup>. The average value is the same (i.e. 3), but the admissible interval is <inline-formula id="IE198"><mml:math id="IM198" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> for Mcl1 and <inline-formula id="IE199"><mml:math id="IM199" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>6</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> for COX2. The Mcl1 intervention guarantees <inline-formula id="IE200"><mml:math id="IM200" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">Apoptosis</mml:mi><mml:mo>≥</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, but we have no such expectation for COX2: Even though the ‘best case’ outcome is higher (i.e. <inline-formula id="IE201"><mml:math id="IM201" display="inline" overflow="scroll"><mml:mrow><mml:mn>6</mml:mn><mml:mo>&gt;</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>), the system is not guaranteed to visit these high-value states sufficiently often to trigger apoptosis.</p>
      </sec>
      <sec>
        <title>3.4.3 Dual interventions with reliable and opportunistic effects</title>
        <p>To systematically rank the high number of possible dual interventions, we propose to score each intervention <italic toggle="yes">I</italic> with two metrics, ‘reliability’ and ‘opportunity’, denoted by rel(<italic toggle="yes">I</italic>) and opp(<italic toggle="yes">I</italic>), respectively. The intuition is that these scores should represent the ‘worst’ and ‘best’ case scenarios (in terms of <monospace>Apoptosis</monospace> and <monospace>Proliferation</monospace>) admitted by the model for each intervention, regardless of the considered update concurrency. The exact definitions of these scores are given in <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S5.4</xref>.</p>
        <p>We then focus on the admissible dual-knockout interventions: both knockouts must be druggable (according to <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. 2019</xref>), and their combination cannot increase <monospace>Apoptosis</monospace> beyond level three in the WT model. This leaves 995 interventions for which we compute both scores. For presentation purposes, we sort the interventions by the ‘average’ of these two scores.</p>
        <p>The eight best and the eight worst interventions are shown in <xref rid="btad262-F4" ref-type="fig">Fig. 4</xref>. As we can see, some of the best interventions admit a non-trivial trap space for the mix-Myc<sup>low</sup> variant. However, even in this case, the reliability and opportunity scores are not vastly different. This raises a natural question regarding the prevalence of differences between reliability and opportunity scores in general. We further study this question in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Section S5.4</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S6</xref>, in particular), where we show that substantial differences between the two scores are in fact common even within the best scoring interventions.</p>
        <fig position="float" id="btad262-F4">
          <label>Figure 4.</label>
          <caption>
            <p>Eight best and worst dual interventions (out of 995 tested), together with their reliability and opportunity scores, as well as their effect on the relevant model variables.</p>
          </caption>
          <graphic xlink:href="btad262f4" position="float"/>
        </fig>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>In this article, we formalized the notion of trap spaces in MVNs, then explored and proved properties of such trap spaces with applications in the analysis and control of MVNs. One notable property is that trap spaces of MVNs are independent to concurrency update schemes. We argued that, akin to Boolean networks, trap spaces can serve as approximation of network attractors. Furthermore, we showed that not all useful properties of trap spaces are preserved through a Boolean encoding of an MVN. For example, maximal trap spaces of unitary networks, crucial for the construction of the network’s succession diagram (<xref rid="btad262-B28" ref-type="bibr">Rozum et al. 2021</xref>), are not preserved. Next, we made a connection between trap spaces of an MVN and siphons of its PN encoding. Based on this relationship, we proposed and implemented a new ASP method for computing different types of trap spaces of an MVN.</p>
    <sec>
      <title>4.1 Method performance</title>
      <p>We have evaluated the time efficiency of our method on real-world models collected from the literature. We show that the method scales well with the network size and it can handle large-scale realistic models for both the general and unitary semantics. The indirect approach (i.e. through a Boolean encoding) is only applicable for the case of fixed-points and minimal unitary trap spaces. In these cases, the direct approach (i.e. our method) outperforms the best indirect method.</p>
      <p>In particular, we discuss the factors that contribute to the running time of each compared method (all are ASP-based) with respect to the minimal trap space computation. Aside from the absolute number of solutions, the practical complexity of an ASP query is affected by its number of atoms and its ‘density’, i.e. the ratio between the number of ASP rules and atoms. Through a systematic analysis (details are available in <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S6.1</xref>), we see that an increase in density is always accompanied by increased runtime. Query density is clearly not the only indicator of ASP problem complexity. However, assuming we control for other relevant factors (solution count, tool/method, update scheme, model format, etc.), query density appears to be a relevant metric for comparing the complexity of two minimal trap space computation problems.</p>
      <p>We also analyse the runtime of our method <monospace>trap-mvn</monospace> in the general and unitary cases. In general, <monospace>trap-mvn</monospace> needs more time for the general case than for the unitary case, as the PN encoding of a general MVN has more transitions than that of its unitary counterpart. The detailed discussions are given at the end of Section S6.1.</p>
      <p>Finally, we have tried to also compare the performance of <monospace>trap-mvn</monospace> to BMA. However, in its current state, we were only able to run the ‘approximate’ attractor detection method, which is (as expected), much faster than any of the tested ‘exact’ methods. There appears to be no public documentation or reproducible artefact concerning the exact solver-based approach for the currently available version of BMA. However, the authors of <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref> note that the exact method was not able to efficiently analyse the Myc heterogeneity model. As such, it seems unlikely that it would provide competitive performance on the remaining models in our benchmark set.</p>
    </sec>
    <sec>
      <title>4.2 Reliable identification of network interventions</title>
      <p>Subsequently, we studied the practical applicability of our method on a model of Myc-deregulation from <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref>. First, we indeed found instances where our exact method can improve the approximate results obtained in <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref>. Furthermore, as we show in <xref rid="btad262-T1" ref-type="table">Table 1</xref>, the behaviour of the model can often admit significant fluctuations and uncertainty. These are not reflected in the average value within attractor states, as considered in <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref>. This highlights the need for rigorous and exhaustive analysis of such behaviour uncertainty.</p>
      <p>With this goal in mind, we propose a ‘reliability’ and ‘opportunity’ score to assess the viability of therapeutic interventions. Based on these scores, we see that even interventions that introduce some amount of uncertainty can be safely considered among the most viable (<xref rid="btad262-F4" ref-type="fig">Fig. 4</xref>). Furthermore, we study how prevalent is the variability of intervention scores in our dataset. As shown in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S6</xref>, for almost half of the interventions (439/995), the difference is zero. However, for 463/995 interventions, the model still admits a difference of three or more points. Such difference can impact the expected observed biological phenotypes if not taken into account. Furthermore, our results reveal that even though the highest score variability is associated with scores we would not consider particularly viable, very viable interventions (e.g. average score &gt;5) can still exhibit high variability (<inline-formula id="IE202"><mml:math id="IM202" display="inline" overflow="scroll"><mml:mrow><mml:mo>≤</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:math></inline-formula>).</p>
      <p>Notably, the COX2 + MEK intervention chosen in <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref> has a reliability and opportunity score equal to 5, placing it on rows 65–149 of the table in <xref rid="btad262-F4" ref-type="fig">Fig. 4</xref> (there are 84 interventions with the same scores). While this is not among the best scores, it is still better than 85%–93% of interventions, meaning we retained the viability of this particular intervention. Furthermore, it should be noted that our screening for ‘viable’ interventions is rather rudimentary: in practice, some of the top perturbations might be ruled out due to factors other than the WT <monospace>Apoptosis</monospace> result (e.g. other side effects not captured by this model).</p>
      <p>Overall, these results support the claim that logical models can exhibit a high level of variability in their outcomes and it is crucial to take this variability into account when drawing conclusions. Due to their favourable computational and theoretical properties, trap spaces appear to be uniquely suited for this task.</p>
    </sec>
    <sec>
      <title>4.3 Applications and future prospects</title>
      <p>Observe that the results we explored in this article can be also useful for other types of MVN analysis. First, there is a trap space-based model reduction technique. This relies on the fact that, given a single trap space, we can obtain a simpler MVN that captures the self-contained dynamics of the states within this trap space. Second, the set of minimal trap spaces of an MVN can be seen as an approximation of its attractors, regardless of the update concurrency. Third, there are existing control methods for Boolean networks based on trap spaces (<xref rid="btad262-B13" ref-type="bibr">Fontanals et al. 2020</xref>; <xref rid="btad262-B27" ref-type="bibr">Rozum et al. 2022</xref>). It should be possible to extend these methods to control of MVNs. We discuss the details of these applications in Section S3.3.</p>
      <p>As a perspective, we also plan to attack the attractor detection problem for MVNs, as trap spaces only capture the network’s static behaviour, whereas attractors can also capture its more complex dynamical aspects. Exploiting the relation between attractors and trap spaces of MVNs is a potentially promising direction for this problem. Furthermore, we plan to develop direct and efficient control methods for MVNs, because the control problem is crucial in systems biology. Arguably, it can be seen as ‘a sequel’ of the trap space or attractor analysis (<xref rid="btad262-B13" ref-type="bibr">Fontanals et al. 2020</xref>).</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad262_Supplementary_Data</label>
      <media xlink:href="btad262_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by L’Institut Carnot STAR, Marseille, France, and by the European Union’s Horizon 2020 research and innovation programme under the Marie Skłodowska-Curie Grant Agreement No. [101034413].</p>
  </sec>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>Source code and data are freely available at <ext-link xlink:href="https://github.com/giang-trinh/trap-mvn" ext-link-type="uri">https://github.com/giang-trinh/trap-mvn</ext-link>.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad262-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Abdallah</surname><given-names>EB</given-names></string-name>, <string-name><surname>Folschette</surname><given-names>M</given-names></string-name>, <string-name><surname>Roux</surname><given-names>O</given-names></string-name></person-group><etal>et al</etal><article-title>ASP-based method for the enumeration of attractors in non-deterministic synchronous and asynchronous multi-valued networks</article-title>. <source>Algorithms Mol Biol</source><year>2017</year>;<volume>12</volume>:<fpage>20</fpage>–<lpage>3</lpage>. <pub-id pub-id-type="doi">10.1186/s13015-017-0111-2</pub-id>.<pub-id pub-id-type="pmid">28814968</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bahar</surname><given-names>RI</given-names></string-name>, <string-name><surname>Frohm</surname><given-names>EA</given-names></string-name>, <string-name><surname>Gaona</surname><given-names>CM</given-names></string-name></person-group><etal>et al</etal><article-title>Algebric decision diagrams and their applications</article-title>. <source>Formal Methods Syst. Des</source><year>1997</year>;<volume>10</volume>:<fpage>171</fpage>–<lpage>206</lpage>. <pub-id pub-id-type="doi">10.1023/A:1008699807402</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad262-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Beneš</surname><given-names>N</given-names></string-name>, <string-name><surname>Brim</surname><given-names>L</given-names></string-name>, <string-name><surname>Huvar</surname><given-names>O</given-names></string-name></person-group><etal>et al</etal><article-title>AEON.py: python library for attractor analysis in asynchronous Boolean networks</article-title>. <source>Bioinformatics</source><year>2022</year>;<volume>38</volume>:<fpage>4978</fpage>–<lpage>80</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btac624</pub-id>.<pub-id pub-id-type="pmid">36102786</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B4">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Benque</surname><given-names>D</given-names></string-name>, <string-name><surname>Bourton</surname><given-names>S</given-names></string-name>, <string-name><surname>Cockerton</surname><given-names>C</given-names></string-name></person-group> <etal>et al</etal><part-title>BMA: visual tool for modeling and analyzing biological networks</part-title>. In: Madhusudan P, Seshia SA. (eds.) <source>Computer Aided Verification</source>. <publisher-loc>Berlin, Germany</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>2012</year>, <fpage>686</fpage>–<lpage>692</lpage>.</mixed-citation>
    </ref>
    <ref id="btad262-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bryant</surname><given-names>RE.</given-names></string-name></person-group><article-title>Graph-based algorithms for boolean function manipulation</article-title>. <source>IEEE Trans Comput</source><year>1986</year>;<volume>C-35</volume>:<fpage>677</fpage>–<lpage>91</lpage>. <pub-id pub-id-type="doi">10.1109/TC.1986.1676819</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad262-B6">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Chaouiya</surname><given-names>C</given-names></string-name>, <string-name><surname>Naldi</surname><given-names>A</given-names></string-name>, <string-name><surname>Thieffry</surname><given-names>D.</given-names></string-name></person-group><part-title>Logical modelling of gene regulatory networks with GINsim</part-title>. In: van Helden J, Toussaint A, Thieffry D. (eds.) <source>Bacterial Molecular Networks</source>. <publisher-loc>New York, NY</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>2011a</year>, <fpage>463</fpage>–<lpage>79</lpage>.</mixed-citation>
    </ref>
    <ref id="btad262-B7">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Chaouiya</surname><given-names>C</given-names></string-name>, <string-name><surname>Remy</surname><given-names>E</given-names></string-name>, <string-name><surname>Ruet</surname><given-names>P</given-names></string-name></person-group><etal>et al</etal><part-title>Qualitative modelling of genetic networks: From logical regulatory graphs to standard Petri nets</part-title>. In: Cortadella J, Reisig W. (eds.) <source>International Conference on Applications and Theory of Petri Nets</source>. <publisher-loc>Berlin, Germany</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>2004</year>, <fpage>137</fpage>–<lpage>56</lpage>.</mixed-citation>
    </ref>
    <ref id="btad262-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chaouiya</surname><given-names>C</given-names></string-name>, <string-name><surname>Bérenguier</surname><given-names>D</given-names></string-name>, <string-name><surname>Keating</surname><given-names>SM</given-names></string-name></person-group><etal>et al</etal><article-title>SBML qualitative models: a model representation format and infrastructure to foster interactions between qualitative modelling formalisms and tools</article-title>. <source>BMC Syst Biol</source><year>2013</year>;<volume>7</volume>:<fpage>135</fpage>. <pub-id pub-id-type="doi">10.1186/1752-0509-7-135</pub-id>.<pub-id pub-id-type="pmid">24321545</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chaouiya</surname><given-names>C</given-names></string-name>, <string-name><surname>Naldi</surname><given-names>A</given-names></string-name>, <string-name><surname>Remy</surname><given-names>E</given-names></string-name></person-group><etal>et al</etal><article-title>Petri net representation of multi-valued logical regulatory graphs</article-title>. <source>Nat Comput</source><year>2011b</year>;<volume>10</volume>:<fpage>727</fpage>–<lpage>50</lpage>. <pub-id pub-id-type="doi">10.1007/s11047-010-9178-0</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad262-B10">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Chatain</surname><given-names>T</given-names></string-name>, <string-name><surname>Haar</surname><given-names>S</given-names></string-name>, <string-name><surname>Jezequel</surname><given-names>L</given-names></string-name></person-group> <etal>et al</etal><part-title>Characterization of reachable attractors using petri net unfoldings</part-title>. In: Mendes P, Dada JO, Smallbone K. (eds.) <source>Computational Methods in Systems Biology</source>. <publisher-loc>Berlin, Germany</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>2014</year>, <fpage>129</fpage>–<lpage>42</lpage>.</mixed-citation>
    </ref>
    <ref id="btad262-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Delaplace</surname><given-names>F</given-names></string-name>, <string-name><surname>Ivanov</surname><given-names>S.</given-names></string-name></person-group><article-title>Bisimilar booleanization of multivalued networks</article-title>. <source>Biosystems</source><year>2020</year>;<volume>197</volume>:<fpage>104205</fpage>. <pub-id pub-id-type="doi">10.1016/j.biosystems.2020.104205</pub-id>.<pub-id pub-id-type="pmid">32622866</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Didier</surname><given-names>G</given-names></string-name>, <string-name><surname>Remy</surname><given-names>E</given-names></string-name>, <string-name><surname>Chaouiya</surname><given-names>C</given-names></string-name></person-group><etal>et al</etal><article-title>Mapping multivalued onto Boolean dynamics</article-title>. <source>J Theor Biol</source><year>2011</year>;<volume>270</volume>:<fpage>177</fpage>–<lpage>84</lpage>. <pub-id pub-id-type="doi">10.1016/j.jtbi.2010.09.017</pub-id>.<pub-id pub-id-type="pmid">20868697</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B13">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Fontanals</surname><given-names>LC</given-names></string-name>, <string-name><surname>Tonello</surname><given-names>E</given-names></string-name>, <string-name><surname>Siebert</surname><given-names>H.</given-names></string-name></person-group><part-title>Control strategy identification via trap spaces in Boolean networks</part-title>. In: Abate A, Petrov T, Wolf V. (eds.) <source>Computational Methods in Systems Biology</source>. <publisher-loc>Berlin, Germany</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>2020</year>, <fpage>159</fpage>–<lpage>75</lpage>.</mixed-citation>
    </ref>
    <ref id="btad262-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gebser</surname><given-names>M</given-names></string-name>, <string-name><surname>Kaufmann</surname><given-names>B</given-names></string-name>, <string-name><surname>Kaminski</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Potassco: the Potsdam answer set solving collection</article-title>. <source>AI Commun</source><year>2011</year>;<volume>24</volume>:<fpage>107</fpage>–<lpage>24</lpage>. <pub-id pub-id-type="doi">10.3233/AIC-2011-0491</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad262-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gerlinger</surname><given-names>M</given-names></string-name>, <string-name><surname>Rowan</surname><given-names>AJ</given-names></string-name>, <string-name><surname>Horswell</surname><given-names>S</given-names></string-name></person-group><etal>et al</etal><article-title>Intratumor heterogeneity and branched evolution revealed by multiregion sequencing</article-title>. <source>N Engl J Med</source><year>2012</year>;<volume>366</volume>:<fpage>883</fpage>–<lpage>92</lpage>. <pub-id pub-id-type="doi">10.1056/NEJMoa1113205</pub-id>.<pub-id pub-id-type="pmid">22397650</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B16">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Ham</surname><given-names>PV.</given-names></string-name></person-group><part-title>How to deal with variables with more than two levels</part-title>. In: Thomas R. (ed.) <source>Lecture Notes in Biomathematics</source>. <publisher-loc>Berlin, Germany</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>1979</year>, <fpage>326</fpage>–<lpage>43</lpage>.</mixed-citation>
    </ref>
    <ref id="btad262-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Heselmeyer-Haddad</surname><given-names>K</given-names></string-name>, <string-name><surname>Berroa Garcia</surname><given-names>LY</given-names></string-name>, <string-name><surname>Bradley</surname><given-names>A</given-names></string-name></person-group><etal>et al</etal><article-title>Single-cell genetic analysis of ductal carcinoma in situ and invasive breast cancer reveals enormous tumor heterogeneity yet conserved genomic imbalances and gain of myc during progression</article-title>. <source>Am J Pathol</source><year>2012</year>;<volume>181</volume>:<fpage>1807</fpage>–<lpage>22</lpage>. <pub-id pub-id-type="doi">10.1016/j.ajpath.2012.07.012</pub-id>.<pub-id pub-id-type="pmid">23062488</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Klarner</surname><given-names>H</given-names></string-name>, <string-name><surname>Streck</surname><given-names>A</given-names></string-name>, <string-name><surname>Siebert</surname><given-names>H</given-names></string-name></person-group><etal>et al</etal><article-title>PyBoolNet: a python package for the generation, analysis and visualization of Boolean networks</article-title>. <source>Bioinformatics</source><year>2017</year>;<volume>33</volume>:<fpage>770</fpage>–<lpage>2</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btw682</pub-id>.<pub-id pub-id-type="pmid">27797783</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kortlever</surname><given-names>RM</given-names></string-name>, <string-name><surname>Sodir</surname><given-names>NM</given-names></string-name>, <string-name><surname>Wilson</surname><given-names>CH</given-names></string-name></person-group><etal>et al</etal><article-title>Myc cooperates with Ras by programming inflammation and immune suppression</article-title>. <source>Cell</source><year>2017</year>;<volume>171</volume>:<fpage>1301</fpage>–<lpage>15.e14</lpage>. <pub-id pub-id-type="doi">10.1016/j.cell.2017.11.013</pub-id>.<pub-id pub-id-type="pmid">29195074</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kreuzaler</surname><given-names>P</given-names></string-name>, <string-name><surname>Clarke</surname><given-names>MA</given-names></string-name>, <string-name><surname>Brown</surname><given-names>EJ</given-names></string-name></person-group><etal>et al</etal><article-title>Heterogeneity of Myc expression in breast cancer exposes pharmacological vulnerabilities revealed through executable mechanistic modeling</article-title>. <source>Proc Natl Acad Sci USA</source><year>2019</year>;<volume>116</volume>:<fpage>22399</fpage>–<lpage>408</lpage>. <pub-id pub-id-type="doi">10.1073/pnas.1903485116</pub-id>.<pub-id pub-id-type="pmid">31611367</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Liu</surname><given-names>G</given-names></string-name>, <string-name><surname>Barkaoui</surname><given-names>K.</given-names></string-name></person-group><article-title>A survey of siphons in petri nets</article-title>. <source>Inf Sci</source><year>2016</year>;<volume>363</volume>:<fpage>198</fpage>–<lpage>220</lpage>. <pub-id pub-id-type="doi">10.1016/j.ins.2015.08.037</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad262-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marusyk</surname><given-names>A</given-names></string-name>, <string-name><surname>Tabassum</surname><given-names>DP</given-names></string-name>, <string-name><surname>Altrock</surname><given-names>PM</given-names></string-name></person-group><etal>et al</etal><article-title>Non-cell-autonomous driving of tumour growth supports sub-clonal heterogeneity</article-title>. <source>Nature</source><year>2014</year>;<volume>514</volume>:<fpage>54</fpage>–<lpage>8</lpage>. <pub-id pub-id-type="doi">10.1038/nature13556</pub-id>.<pub-id pub-id-type="pmid">25079331</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mushthofa</surname><given-names>M</given-names></string-name>, <string-name><surname>Schockaert</surname><given-names>S</given-names></string-name>, <string-name><surname>Hung</surname><given-names>LH</given-names></string-name></person-group><etal>et al</etal><article-title>Modeling multi-valued biological interaction networks using fuzzy answer set programming</article-title>. <source>Fuzzy Sets Syst</source><year>2018</year>;<volume>345</volume>:<fpage>63</fpage>–<lpage>82</lpage>. <pub-id pub-id-type="doi">10.1016/j.fss.2018.01.003</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad262-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Nabli</surname><given-names>F</given-names></string-name>, <string-name><surname>Martinez</surname><given-names>T</given-names></string-name>, <string-name><surname>Fages</surname><given-names>F</given-names></string-name></person-group><etal>et al</etal><article-title>On enumerating minimal siphons in Petri nets using CLP and SAT solvers: theoretical and practical complexity</article-title>. <source>Constraints</source><year>2016</year>;<volume>21</volume>:<fpage>251</fpage>–<lpage>76</lpage>. <pub-id pub-id-type="doi">10.1007/s10601-015-9190-1</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad262-B25">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Naldi</surname><given-names>A</given-names></string-name>, <string-name><surname>Thieffry</surname><given-names>D</given-names></string-name>, <string-name><surname>Chaouiya</surname><given-names>C.</given-names></string-name></person-group><part-title>Decision diagrams for the representation and analysis of logical models of genetic networks</part-title>. In: Calder M, Gilmore S. (eds.) <source>Computational Methods in Systems Biology</source>. <publisher-loc>Berlin, Germany</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>2007</year>, <fpage>233</fpage>–<lpage>47</lpage>.</mixed-citation>
    </ref>
    <ref id="btad262-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Paulevé</surname><given-names>L</given-names></string-name>, <string-name><surname>Kolčák</surname><given-names>J</given-names></string-name>, <string-name><surname>Chatain</surname><given-names>T</given-names></string-name></person-group><etal>et al</etal><article-title>Reconciling qualitative, abstract, and scalable modeling of biological networks</article-title>. <source>Nat Commun</source><year>2020</year>;<volume>11</volume>:<fpage>1</fpage>–<lpage>7</lpage>. <pub-id pub-id-type="doi">10.1038/s41467-020-18112-5</pub-id>.<pub-id pub-id-type="pmid">31911652</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rozum</surname><given-names>JC</given-names></string-name>, <string-name><surname>Deritei</surname><given-names>D</given-names></string-name>, <string-name><surname>Park</surname><given-names>KH</given-names></string-name></person-group><etal>et al</etal><article-title>Pystablemotifs: python library for attractor identification and control in Boolean networks</article-title>. <source>Bioinformatics</source><year>2022</year>;<volume>38</volume>:<fpage>1465</fpage>–<lpage>6</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btab825</pub-id>.<pub-id pub-id-type="pmid">34875008</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rozum</surname><given-names>JC</given-names></string-name>, <string-name><surname>Gómez Tejeda Zañudo</surname><given-names>J</given-names></string-name>, <string-name><surname>Gan</surname><given-names>X</given-names></string-name></person-group><etal>et al</etal><article-title>Parity and time reversal elucidate both decision-making in empirical models and attractor scaling in critical Boolean networks</article-title>. <source>Sci Adv</source><year>2021</year>;<volume>7</volume>:<fpage>eabf8124</fpage>. <pub-id pub-id-type="doi">10.1126/sciadv.abf8124</pub-id>.<pub-id pub-id-type="pmid">34272246</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Schaub</surname><given-names>MA</given-names></string-name>, <string-name><surname>Henzinger</surname><given-names>TA</given-names></string-name>, <string-name><surname>Fisher</surname><given-names>J.</given-names></string-name></person-group><article-title>Qualitative networks: a symbolic approach to analyze biological signaling networks</article-title>. <source>BMC Syst Biol</source><year>2007</year>;<volume>1</volume>:<fpage>1</fpage>–<lpage>21</lpage>. <pub-id pub-id-type="doi">10.1186/1752-0509-1-4</pub-id>.<pub-id pub-id-type="pmid">17408505</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Schwab</surname><given-names>JD</given-names></string-name>, <string-name><surname>Kühlwein</surname><given-names>SD</given-names></string-name>, <string-name><surname>Ikonomi</surname><given-names>N</given-names></string-name></person-group><etal>et al</etal><article-title>Concepts in Boolean network modeling: what do they all mean?</article-title><source>Comput Struct Biotechnol J</source><year>2020</year>;<volume>18</volume>:<fpage>571</fpage>–<lpage>82</lpage>. <pub-id pub-id-type="doi">10.1016/j.csbj.2020.03.001</pub-id>.<pub-id pub-id-type="pmid">32257043</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sun</surname><given-names>Z</given-names></string-name>, <string-name><surname>Jin</surname><given-names>X</given-names></string-name>, <string-name><surname>Albert</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Multi-level modeling of light-induced stomatal opening offers new insights into its regulation by drought</article-title>. <source>PLoS Comput Biol</source><year>2014</year>;<volume>10</volume>:<fpage>e1003930</fpage>. <pub-id pub-id-type="doi">10.1371/journal.pcbi.1003930</pub-id>.<pub-id pub-id-type="pmid">25393147</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Thomas</surname><given-names>R.</given-names></string-name></person-group><article-title>Regulatory networks seen as asynchronous automata: a logical description</article-title>. <source>J Theor Biol</source><year>1991</year>;<volume>153</volume>:<fpage>1</fpage>–<lpage>23</lpage>. <pub-id pub-id-type="doi">10.1016/S0022-5193(05)80350-9</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad262-B33">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Trinh</surname><given-names>V</given-names></string-name>, <string-name><surname>Benhamou</surname><given-names>B</given-names></string-name>, <string-name><surname>Hiraishi</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><part-title>Minimal trap spaces of logical models are maximal siphons of their Petri net encoding</part-title>. In: Petre I, Păun A. (eds.) <source>Computational Methods in Systems Biology</source>. <publisher-loc>Berlin, Germany</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>2022</year>, <fpage>158</fpage>–<lpage>76</lpage>.</mixed-citation>
    </ref>
    <ref id="btad262-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Vita</surname><given-names>M</given-names></string-name>, <string-name><surname>Henriksson</surname><given-names>M.</given-names></string-name></person-group><article-title>The Myc oncoprotein as a therapeutic target for human cancer</article-title>. <source>Semin Cancer Biol</source><year>2006</year>;<volume>16</volume>:<fpage>318</fpage>–<lpage>30</lpage>. <pub-id pub-id-type="doi">10.1016/j.semcancer.2006.07.015</pub-id>.<pub-id pub-id-type="pmid">16934487</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10311308</article-id>
    <article-id pub-id-type="pmid">37387165</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad262</article-id>
    <article-id pub-id-type="publisher-id">btad262</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Systems Biology and Networks</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Trap spaces of multi-valued networks: definition, computation, and applications</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-6581-998X</contrib-id>
        <name>
          <surname>Trinh</surname>
          <given-names>Van-Giang</given-names>
        </name>
        <aff><institution>LIS, Aix-Marseille University</institution>, Marseille 13397, <country country="FR">France</country></aff>
        <xref rid="btad262-cor1" ref-type="corresp"/>
        <!--trinh.van-giang@lis-lab.fr-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Benhamou</surname>
          <given-names>Belaid</given-names>
        </name>
        <aff><institution>LIS, Aix-Marseille University</institution>, Marseille 13397, <country country="FR">France</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Henzinger</surname>
          <given-names>Thomas</given-names>
        </name>
        <aff><institution>Institute of Science and Technology</institution>, Klosterneuburg 3400, <country country="AT">Austria</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-1993-0331</contrib-id>
        <name>
          <surname>Pastva</surname>
          <given-names>Samuel</given-names>
        </name>
        <aff><institution>Institute of Science and Technology</institution>, Klosterneuburg 3400, <country country="AT">Austria</country></aff>
        <xref rid="btad262-cor1" ref-type="corresp"/>
        <!--samuel.pastva@ist.ac.at-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad262-cor1">Corresponding authors. LIS, Aix-Marseille University, Marseille, France. E-mail: <email>trinh.van-giang@lis-lab.fr</email> (V.-G.T.); Institute of Science and Technology, Klosterneuburg, Austria. E-mail: <email>samuel.pastva@ist.ac.at</email> (S.P.)</corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-06-30">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB/ECCB 2023 Proceedings</issue-title>
    <fpage>i513</fpage>
    <lpage>i522</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad262.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Boolean networks are simple but efficient mathematical formalism for modelling complex biological systems. However, having only two levels of activation is sometimes not enough to fully capture the dynamics of real-world biological systems. Hence, the need for multi-valued networks (MVNs), a generalization of Boolean networks. Despite the importance of MVNs for modelling biological systems, only limited progress has been made on developing theories, analysis methods, and tools that can support them. In particular, the recent use of trap spaces in Boolean networks made a great impact on the field of systems biology, but there has been no similar concept defined and studied for MVNs to date.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>In this work, we generalize the concept of trap spaces in Boolean networks to that in MVNs. We then develop the theory and the analysis methods for trap spaces in MVNs. In particular, we implement all proposed methods in a Python package called <monospace>trapmvn</monospace>. Not only showing the applicability of our approach via a realistic case study, we also evaluate the time efficiency of the method on a large collection of real-world models. The experimental results confirm the time efficiency, which we believe enables more accurate analysis on larger and more complex multi-valued models.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>Source code and data are freely available at <ext-link xlink:href="https://github.com/giang-trinh/trap-mvn" ext-link-type="uri">https://github.com/giang-trinh/trap-mvn</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>L’Institut Carnot STAR, Marseille</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>European Union’s Horizon 2020</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Marie Skłodowska-Curie</institution>
          </institution-wrap>
        </funding-source>
        <award-id>101034413</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="10"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Boolean networks are simple but efficient mathematical formalism for modelling, analysing, and controlling complex biological systems (<xref rid="btad262-B30" ref-type="bibr">Schwab et al. 2020</xref>). Beyond systems biology, they have been widely applied in various areas from science to engineering (<xref rid="btad262-B30" ref-type="bibr">Schwab et al. 2020</xref>). Boolean network models of biological systems represent genes (or other species) as nodes that can take Boolean values: 1 (active) and 0 (inactive). However, having only two levels of activation may not be enough to fully capture the dynamics of real-world biological systems (<xref rid="btad262-B29" ref-type="bibr">Schaub et al. 2007</xref>). There are many examples (<xref rid="btad262-B29" ref-type="bibr">Schaub et al. 2007</xref>; <xref rid="btad262-B12" ref-type="bibr">Didier et al. 2011</xref>; <xref rid="btad262-B23" ref-type="bibr">Mushthofa et al. 2018</xref>) where the dynamics of the system can only be modelled by considering more than two activation levels. Hence, there is a crucial need to study multi-valued networks (MVNs), which are a generalization of Boolean networks (<xref rid="btad262-B25" ref-type="bibr">Naldi et al. 2007</xref>; <xref rid="btad262-B29" ref-type="bibr">Schaub et al. 2007</xref>).</p>
    <sec>
      <title>1.1 Related work</title>
      <p>Despite the importance of MVNs, only limited progress has been made on developing theories, analysis methods, and tools that can support them (<xref rid="btad262-B23" ref-type="bibr">Mushthofa et al. 2018</xref>). First, besides simulation, the analysis of logical models is mostly based around ‘attractor’ computation, since those correspond roughly to observable biological phenotypes (<xref rid="btad262-B30" ref-type="bibr">Schwab et al. 2020</xref>). For example, in gene regulatory and signalling networks, attractors can correspond to cell types, cell fates, and cyclic behaviour (e.g. circadian rhythms and cell cycles). Hence, analysis of attractors could provide new insights into systems biology. However, finding all attractors of a logical model (even for the Boolean case) is challenging due to the complex dynamics of models (<xref rid="btad262-B30" ref-type="bibr">Schwab et al. 2020</xref>). The recent study of trap spaces of Boolean networks (<xref rid="btad262-B18" ref-type="bibr">Klarner et al. 2017</xref>) made a real breakthrough in the field of systems biology, as minimal trap spaces provide very good approximations of attractors and are much easier to compute. However, there has been no similar concept defined and studied for MVNs to date.</p>
      <p>Furthermore, other biological properties, such as the gradual commitment of a cell to a specific phenotype, can be revealed through the lens of ‘succession diagrams’ constructed from the networks’ ‘maximal’ trap spaces (<xref rid="btad262-B28" ref-type="bibr">Rozum et al. 2021</xref>, <xref rid="btad262-B27" ref-type="bibr">2022</xref>). As such, minimal trap spaces are not the only relevant form of a trap space. In the <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref> (Section S4.2), we give a more detailed discussion of trap space applications in biological modelling.</p>
      <p>Second, most of the existing studies (see, e.g. <xref rid="btad262-B25" ref-type="bibr">Naldi et al. 2007</xref>; <xref rid="btad262-B29" ref-type="bibr">Schaub et al. 2007</xref>; <xref rid="btad262-B12" ref-type="bibr">Didier et al. 2011</xref> ) focus on ‘unitary’ MVNs, with only very few studies focusing on ‘general’ MVNs (see, e.g. <xref rid="btad262-B23" ref-type="bibr">Mushthofa et al. 2018</xref>). Third, to the best of our knowledge, very few methods/tools [see, e.g. GINsim (<xref rid="btad262-B27" ref-type="bibr">Naldi et al. 2007</xref>), BMA (<xref rid="btad262-B4" ref-type="bibr">Benque et al. 2012</xref>)] have been developed for MVNs. Most analysis methods/tools for logical models are designed for Boolean networks only [see, e.g. GINsim (<xref rid="btad262-B25" ref-type="bibr">Naldi et al. 2007</xref>), PyBoolNet (<xref rid="btad262-B18" ref-type="bibr">Klarner et al. 2017</xref>), mpbn (<xref rid="btad262-B26" ref-type="bibr">Paulevé et al. 2020</xref>), and Trappist (<xref rid="btad262-B33" ref-type="bibr">Trinh et al. 2022)</xref>].</p>
      <p>One notable issue is that the current supporting methods for MVNs cannot handle large and complex models (<xref rid="btad262-B25" ref-type="bibr">Naldi et al. 2007</xref> ; <xref rid="btad262-B23" ref-type="bibr">Mushthofa et al. 2018</xref>). This issue also prevents the modellers from building such models (<xref rid="btad262-B25" ref-type="bibr">Naldi et al. 2007</xref>), which could provide more accurate insights. Finally, a popular research direction is to convert an MVN to a Boolean network with similar dynamical behaviour, then applying the rich set of analysis methods/tools designed for Boolean networks. However, the existing Boolean encoding methods (e.g. the Van Ham Boolean mapping and its variants; <xref rid="btad262-B16" ref-type="bibr">Ham 1979</xref>; <xref rid="btad262-B12" ref-type="bibr">Didier et al. 2011</xref>) may not cover the full set of dynamics of the original MVN (<xref rid="btad262-B12" ref-type="bibr">Didier et al. 2011</xref>), and the encoding may even hinder the efficiency of the Boolean network methods/tools (<xref rid="btad262-B23" ref-type="bibr">Mushthofa et al. 2018</xref>). It is also worth noting that all mentioned encoding methods support only unitary MVNs. We believe that it is possible to develop direct and efficient methods for MVNs.</p>
    </sec>
    <sec>
      <title>1.2 Our contributions</title>
      <p>In this work, we study both general and unitary MVNs. Note that this inclusion of general networks is important not only in theory, but also in many biological applications (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S1</xref>). First, we generalize the concept of trap spaces in Boolean networks to that in MVNs. Second, we prove several properties of trap spaces in MVNs including (i) the separation of minimal trap spaces, (ii) their relation with respect to the Van Ham Boolean mapping, and (iii) the characterization of trap spaces through Petri net (PN) siphons. Based on this characterization, we propose a new method utilizing answer set programming (ASP; <xref rid="btad262-B14" ref-type="bibr">Gebser et al. 2011</xref>) for computing different types of trap spaces of MVNs, including generic trap spaces, maximal trap spaces, minimal trap spaces, and fixed-points (a special sub-type of trap spaces). For fixed-points, we also consider another new method, which relies on the characterization of deadlocks of the PN encoding (<xref rid="btad262-B21" ref-type="bibr">Liu and Barkaoui 2016</xref>). We evaluate the method on a collection of real-world MVNs and show its applicability in treatment prediction on a case study of Myc-deregulation in breast cancer.</p>
    </sec>
    <sec>
      <title>1.3 Paper outline</title>
      <p>This article is structured as follows: In Section 2, we formalize the notion of trap spaces in MVNs and their relationship to the PN siphons. We propose a method based on answer-set programming for computing such trap spaces efficiently. In Section 3, we present a Python package <monospace>trapmvn</monospace> that implements this method for both SBML-qual and BMA models. We demonstrate the practical performance of the method on a wide selection of real-world models. We then use <monospace>trapmvn</monospace> as part of a case study to identify viable intervention targets in a model of Myc-associated deregulation in breast cancer. Finally, Section 4 discusses the scalability of the method, its future prospects, and highlights the role of trap spaces in reliable long-term behavioural analysis of logical models.</p>
      <p>This article also has an associated supplement, in which we include the non-essential technical details of our methodology, as well as the full results of our benchmarks and case study. This article refers to this supplement where appropriate.</p>
    </sec>
  </sec>
  <sec>
    <title>2 Methods</title>
    <p>In this section, we define trap spaces of MVNs, discuss some of their theoretical properties, and finally present a method based on ASP for computing trap spaces of symbolically represented MVNs.</p>
    <sec>
      <title>2.1 MVNs</title>
      <statement id="mthst1">
        <p><sc>Definition</sc> 1. <italic toggle="yes">An MVN is a triple</italic> <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>K</mml:mi><mml:mo>,</mml:mo><mml:mi>F</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">such that:</italic></p>
      </statement>
      <list list-type="bullet">
        <list-item>
          <p>
            <inline-formula id="IE2">
              <mml:math id="IM2" display="inline" overflow="scroll">
                <mml:mrow>
                  <mml:mi>V</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mo>{</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>v</mml:mi>
                    </mml:mrow>
                    <mml:mn>1</mml:mn>
                  </mml:msub>
                  <mml:mo>,</mml:mo>
                  <mml:mo>…</mml:mo>
                  <mml:mo>,</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>v</mml:mi>
                    </mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:msub>
                  <mml:mo>}</mml:mo>
                </mml:mrow>
              </mml:math>
            </inline-formula>
            <italic toggle="yes">is an indexed set of nodes (variables).</italic>
          </p>
        </list-item>
        <list-item>
          <p><inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">is an indexed set of integer intervals, representing the domains of variables</italic> <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
        </list-item>
        <list-item>
          <p><inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>F</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">is an indexed set of update functions of variables</italic> <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">. Each f<sub>i</sub> has a signature</italic> <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:msubsup><mml:mrow><mml:mo>Π</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
        </list-item>
      </list>
      <p>With a slight abuse of notation, we write <italic toggle="yes">v<sub>i</sub></italic> to denote both the network node and the associated integer variable. Furthermore, we can also write <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to denote the domain and update function of <italic toggle="yes">v<sub>i</sub></italic>, respectively. We define <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> as the ‘state’ of the MVN, with <italic toggle="yes">x<sub>i</sub></italic> (or <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) denoting the value of <italic toggle="yes">v<sub>i</sub></italic> in the state <italic toggle="yes">x</italic>. We can also write <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mi>x</mml:mi></mml:math></inline-formula> as a vector <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. We then write <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> to denote the set of all states (‘state space’) of network <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula>. Finally, note that there are different possible formulations of update functions <italic toggle="yes">F</italic>, including fuzzy logic (<xref rid="btad262-B23" ref-type="bibr">Mushthofa et al. 2018</xref>), rule-based descriptions (<xref rid="btad262-B25" ref-type="bibr">Naldi et al. 2007</xref>; <xref rid="btad262-B11" ref-type="bibr">Delaplace and Ivanov 2020</xref>), or arithmetic expressions (<xref rid="btad262-B4" ref-type="bibr">Benque et al. 2012</xref>). We will return to this aspect when we discuss the encoding and manipulation of networks by our method.</p>
      <p>The dynamics of an MVN are studied through its ‘state-transition graph’, <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>→</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. In particular, a ‘trap’ set of <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is a set of states that is closed with respect to <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mo>→</mml:mo></mml:math></inline-formula>. A trap set is called an ‘attractor’ if it is minimal, i.e. there is no other trap set that is a proper subset of this set. However, there are different ways of defining <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, possibly leading to significantly different behavioural features.</p>
      <p>First, we divide MVNs based on the variable update scheme as ‘general’ (<xref rid="btad262-B23" ref-type="bibr">Mushthofa et al. 2018</xref>) and ‘unitary’ (<xref rid="btad262-B29" ref-type="bibr">Schaub et al. 2007</xref>; <xref rid="btad262-B11" ref-type="bibr">Delaplace and Ivanov 2020</xref>). In the general networks, the variable changes follow the update functions exactly. Meanwhile, in the unitary networks, the value of <italic toggle="yes">v<sub>i</sub></italic> can only change by ‘one level’ at a time (i.e. +1 or –1). It has been argued that unitary networks better capture the continuity of biological interactions (<xref rid="btad262-B29" ref-type="bibr">Schaub et al. 2007</xref>), but is not true universally (<xref rid="btad262-B31" ref-type="bibr">Sun et al. 2014</xref>).</p>
      <p>Note that the stepwise notion of unitary update can be in fact encoded directly into the update functions <italic toggle="yes">F</italic>. Specifically, we define <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to represent the update function which adheres to the chosen variable update. That is, <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for general MVNs and <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula> for unitary MVNs, where <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>0 if <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>1 if <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>&lt;</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and <italic toggle="yes">d</italic> = – 1 when <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>&gt;</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>The second aspect of MVN semantics is the concurrency of updates. Here, two prevalent approaches are the ‘synchronous’ (all variables update together) and ‘asynchronous’ update (exactly one variable updates non-deterministically in each step).</p>
      <p>Note that for the same MVN, different update schemes may result in vastly different state-transition graphs (<xref rid="btad262-B32" ref-type="bibr">Thomas 1991</xref>). Consider the MVN <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula> with <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> (Example 2 in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref>). <xref rid="btad262-F1" ref-type="fig">Figure 1(a)</xref> shows the state transition graph of <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula> under the general update scheme. This graph has six trap sets: {[0 1]}, {[1 1]}, {[0 0], [0 2]}, {[0 1], [1 1]}, {[0 0], [0 1], [0 2]}, and {[0 0], [0 1], [0 2], [1 0], [1 1], [1 2]}. Out of these, three are attractors (minimal trap sets): {[0 1]}, {[1 1]}, and {[0 0], [0 2]}. Meanwhile, <xref rid="btad262-F1" ref-type="fig">Fig. 1(b)</xref> shows the state transition graph of <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula> using the unitary update scheme, which admits only two attractors: {[0 1]} and {[1 1]}.</p>
      <fig position="float" id="btad262-F1">
        <label>Figure 1.</label>
        <caption>
          <p><inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of the example MVN under general (a) and unitary update schemes (b). Attractors are highlighted in bold.</p>
        </caption>
        <graphic xlink:href="btad262f1" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>2.2 Trap spaces of MVNs</title>
      <p>Overall, this variability under different update schemes motivates the study of ‘trap spaces’. In the Boolean case, trap spaces have been shown to be a good approximation of network attractors, regardless of the chosen update concurrency (<xref rid="btad262-B26" ref-type="bibr">Paulevé et al. 2020</xref>). Here, we thus establish trap spaces for MVNs with a similar goal in mind:<statement id="mthst2"><p><sc>Definition</sc> 2. <italic toggle="yes">A space m of</italic> <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">is a mapping which assigns each</italic> <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">a non-empty subset of K<sub>i</sub>:</italic> <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">. We write</italic> <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>⋆</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula><italic toggle="yes">to denote the set of all spaces of</italic> <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula>.</p></statement></p>
      <p>With a slight abuse of notation, we can also interpret <italic toggle="yes">m</italic> as a subset of <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, writing <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula> for a state <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> when <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for all <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>. Subsequently, we can define trap spaces as follows:<statement id="mthst3"><p><sc>Definition</sc> 3. <italic toggle="yes">A trap space is a space m such that for every state</italic> <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">and variable</italic> <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">, we have</italic> <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p></statement></p>
      <p>In other words, in all states represented by <italic toggle="yes">m</italic>, all update functions only produce values that stay within <italic toggle="yes">m</italic>, meaning no <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (regardless of the update concurrency) can contain a transition which leaves <italic toggle="yes">m</italic>. Consequently, trap spaces of an MVN are independent on its concurrency update, is not true for the case of attractors. Note the use of <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, meaning that the notion of trap space respects the choice of unitary or general variable update.</p>
      <p>When interpreting spaces <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>⋆</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> as subsets of <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we can trivially establish a sub-space relation on <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>⋆</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>, which allows us to reason about ‘minimal’ and ‘maximal’ trap spaces:<statement id="mthst4"><p><sc>Definition</sc> 4. <italic toggle="yes">A trap space m is minimal if and only if there is no trap space</italic> <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>⋆</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula><italic toggle="yes">s.t.</italic> <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>′</mml:mo><mml:mo>⊂</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">. Analogously, a trap space m is maximal if and only if</italic> <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>⊂</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">, and there is no trap space</italic> <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>⋆</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula><italic toggle="yes">s.t.</italic> <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>⊂</mml:mo><mml:mi>m</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>.</p></statement></p>
      <p>Note that for the notion of maximal subspace, we require that <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>⊂</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Otherwise, a trivial space <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mo>⋆</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> which represents all network states (i.e. <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mo>⋆</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) is always a trap space, and always a superset of all other trap spaces.</p>
      <p>For illustration, reconsider the example MVN (<xref rid="btad262-F1" ref-type="fig">Fig. 1</xref>). Its general counterpart has six trap spaces as follows:
</p>
      <disp-formula id="E1">
        <mml:math id="M1" display="block" overflow="scroll">
          <mml:mtable>
            <mml:mtr>
              <mml:mtd>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>m</mml:mi>
                  </mml:mrow>
                  <mml:mn>1</mml:mn>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>,</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>m</mml:mi>
                  </mml:mrow>
                  <mml:mn>2</mml:mn>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>,</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>m</mml:mi>
                  </mml:mrow>
                  <mml:mn>3</mml:mn>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mn>2</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>,</mml:mo>
              </mml:mtd>
            </mml:mtr>
            <mml:mtr>
              <mml:mtd>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>m</mml:mi>
                  </mml:mrow>
                  <mml:mn>4</mml:mn>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>,</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>m</mml:mi>
                  </mml:mrow>
                  <mml:mn>5</mml:mn>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mn>2</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>,</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>m</mml:mi>
                  </mml:mrow>
                  <mml:mn>6</mml:mn>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mn>2</mml:mn>
                <mml:mo>}</mml:mo>
                <mml:mo>.</mml:mo>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>Out of these, three are minimal trap spaces (<inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>) and two are maximal trap spaces (<inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>5</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>). Meanwhile, its unitary counterpart has two minimal trap spaces (<inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>}</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>) and three maximal trap spaces (<inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>}</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>). Finally, let us observe the following:<statement id="mthst5"><p><sc>Theorem</sc> 1 (Separation of minimal trap spaces). <italic toggle="yes">Let m<sub>1</sub> and m<sub>2</sub> be two distinct minimal trap spaces of</italic> <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula><italic toggle="yes">. Then</italic> <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula>.</p></statement></p>
      <p>The proof is available in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref> as Theorem 3.</p>
      <p>By Definition 3 and the definition of a trap set, a trap space is also a trap set of an MVN for any chosen update concurrency. As a consequence, each trap space must contain at least one attractor of the MVN. By <xref rid="mthst5" ref-type="statement">Theorem 1</xref>, any two distinct minimal trap spaces are disjoint; thus, the attractors contained in them are also disjoint. Hence, we can conclude that regardless of the chosen update concurrency, minimal trap spaces can be used as approximations of attractors in MVNs: The number of minimal trap spaces under-approximates the number of attractors (there can be other attractors that are not contained in minimal trap spaces), and each minimal trap space over-approximates at least a single attractor. <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S3.3</xref> presents additional examples of relations between attractors and minimal trap spaces.</p>
    </sec>
    <sec>
      <title>2.3 Translation to Boolean networks</title>
      <p>When <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> for all <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>, we can refer to <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula> as a ‘Boolean network’ <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">N</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>F</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> instead. For Boolean networks, the notion of trap spaces is well known, including efficient tools for computation of minimal and maximal trap spaces (<xref rid="btad262-B18" ref-type="bibr">Klarner et al. 2017</xref>; <xref rid="btad262-B26" ref-type="bibr">Paulevé et al. 2020</xref>; <xref rid="btad262-B33" ref-type="bibr">Trinh et al. 2022</xref>).</p>
      <p>There are several works (<xref rid="btad262-B12" ref-type="bibr">Didier et al. 2011</xref>; <xref rid="btad262-B11" ref-type="bibr">Delaplace and Ivanov 2020</xref>) attempting to encode the multi-valued dynamics of an MVN into a Boolean network. Probably, the most widely used being the Van Ham encoding (<xref rid="btad262-B16" ref-type="bibr">Ham 1979</xref>), implemented in the tools <monospace>GINsim</monospace> (<xref rid="btad262-B6" ref-type="bibr">Chaouiya et al. 2011a</xref>, <xref rid="btad262-B9" ref-type="bibr">2011b</xref>) and <monospace>bioLQM</monospace> (<xref rid="btad262-B8" ref-type="bibr">Chaouiya et al. 2013</xref>). The core idea of the Van Ham encoding is to expand each multi-valued variable <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula> into <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> Boolean variables, such that an integer value <italic toggle="yes">v </italic>=<italic toggle="yes"> k</italic> is encoded as the truth value of the first <italic toggle="yes">k</italic> Boolean variables. The main advantage of this encoding is that any unitary state change only involves a single Boolean variable. The disadvantage is that the encoding admits invalid states which do not correctly encode any integer and may interfere with the actual dynamics of the model. More details about the Van Ham encoding are given in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S2.3</xref>.</p>
      <p>It is known that the Van Ham encoding preserves attractors of unitary networks (<xref rid="btad262-B12" ref-type="bibr">Didier et al. 2011</xref>). Nevertheless, it is unclear whether this mapping also preserves trap spaces in general. To answer this question, we present the following proposition, the proofs for which can be found in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref>.<statement id="mthst6"><p><sc>Proposition</sc> 1. <italic toggle="yes">Let</italic> <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">N</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">denote the Van Ham encoding of a</italic> MVN <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula><italic toggle="yes">. Then, it holds that:</italic></p></statement></p>
      <list list-type="bullet">
        <list-item>
          <p><italic toggle="yes">There is a general MVN</italic> <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula><italic toggle="yes">for which neither the maximal nor minimal trap spaces of</italic> <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">N</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">correspond to the respective trap spaces of</italic> <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula>.</p>
        </list-item>
        <list-item>
          <p><italic toggle="yes">There is a unitary MVN</italic> <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula><italic toggle="yes">such that the maximal trap spaces of</italic> <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">N</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">do not correspond to the maximal trap spaces of</italic> <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula>.</p>
        </list-item>
        <list-item>
          <p><italic toggle="yes">For every unitary MVN</italic> <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula><italic toggle="yes">, the minimal trap spaces of</italic> <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">N</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">correspond to the minimal trap spaces of</italic> <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula>.</p>
        </list-item>
      </list>
      <p>This proposition states that the Van Ham encoding is still applicable for computation of minimal trap spaces of unitary networks, but cannot be used beyond this particular problem class.</p>
    </sec>
    <sec>
      <title>2.4 Computing trap spaces through PN siphons</title>
      <p>To tackle the problem of trap space computation of MVNs, we instead propose a different approach, based on an encoding of the problem into an answer-set programming query.</p>
      <sec>
        <title>2.4.1 PN encoding of MVNs</title>
        <p>First, let us establish a characterization of trap spaces through conflict-free PN siphons.<statement id="mthst7"><p><sc>Definition</sc> 5. <italic toggle="yes">A one-safe PN is a bipartite-directed graph</italic> <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">P</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>W</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">, where P and T are disjoint finite sets of vertices called places and transitions</italic>, <italic toggle="yes">respectively. Set W describes the arcs between places and transitions:</italic> <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:mi>W</mml:mi><mml:mo>⊆</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo>×</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>×</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p></statement></p>
        <p>A <italic toggle="yes">marking M</italic> of a one-safe PN is a subset <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo>⊆</mml:mo><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
        <p>For <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>P</mml:mi><mml:mo>∪</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula>, we write pred(<italic toggle="yes">x</italic>) and succ(<italic toggle="yes">x</italic>) to denote the predecessors and successors of <italic toggle="yes">x</italic> with respect to <italic toggle="yes">W</italic> (this notation naturally extends to subsets of <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>∪</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula>). The dynamics of a PN are dictated by the ‘firing of transitions’, such that a transition <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula> can be fired non-deterministically in the marking <italic toggle="yes">M</italic> if <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:mtext>pred</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:math></inline-formula>. The result is a new marking <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>∖</mml:mo><mml:mtext>pred</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mtext>succ</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This process defines a state-transition graph with vertices as the possible markings.</p>
        <p>In the appendix of <xref rid="btad262-B10" ref-type="bibr">Chatain et al. (2014)</xref>, the authors present a PN encoding of the ‘asynchronous’ MVN dynamics, which we briefly recall here. Note that this is not the only PN encoding of MVNs (see, e.g. <xref rid="btad262-B7" ref-type="bibr">Chaouiya et al. 2004</xref>, <xref rid="btad262-B6" ref-type="bibr">2011a</xref>, <xref rid="btad262-B9" ref-type="bibr">2011b</xref>), but to the best of our knowledge, the other encodings are not particularly suitable for the characterization of trap spaces.</p>
        <p>Let <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> denote the one-safe PN encoding of an MVN <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula> based on <xref rid="btad262-B10" ref-type="bibr">Chatain et al. (2014)</xref>. The places <italic toggle="yes">P</italic> of <inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> contain one place for every level of every MVN variable: <inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:munder><mml:mo>∪</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. The set of transitions and arcs is then constructed such that the firing of a transition mirrors a possible update of an MVN variable. For example, let <inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula> be such that for every <inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we have <inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>∧</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⇒</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:math></inline-formula> (with <inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:mi>o</mml:mi><mml:menclose notation="updiagonalstrike"><mml:mo>=</mml:mo></mml:menclose><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>). We then create a transition <italic toggle="yes">t</italic> with <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:mtext>pred</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:mtext>succ</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Such transition ‘moves’ a token from <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> under the assumption <italic toggle="yes">u</italic> = <italic toggle="yes">l</italic>. Note that there are many possible combinations of sets <italic toggle="yes">T</italic> and <italic toggle="yes">W</italic> that are valid for a particular <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula>. Later, we show how we compute these sets in our case.</p>
        <p>Finally, let <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>⋆</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> be a space of <inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula>. We write that a set of places <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>⊆</mml:mo><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula> is the ‘mirror’ of <italic toggle="yes">m</italic> when for every <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⇔</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:menclose notation="updiagonalstrike"><mml:mo>∈</mml:mo></mml:menclose><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula>. That is, <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> contains the places corresponding to the ‘inverse’ of <italic toggle="yes">m</italic>. Observe that a state <inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is also a (trivial) space, and hence has a mirror <inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
      <sec>
        <title>2.4.2 Siphon characterization of MVN trap spaces</title>
        <statement id="mthst8">
          <p><sc>Definition</sc> 6. <italic toggle="yes">A PN siphon</italic> <inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo>⊆</mml:mo><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">is a set of places such that for all</italic> <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>∩</mml:mo><mml:mtext>succ</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:menclose notation="updiagonalstrike"><mml:mo>=</mml:mo></mml:menclose><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">implies</italic><inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>∩</mml:mo><mml:mtext>pred</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:menclose notation="updiagonalstrike"><mml:mo>=</mml:mo></mml:menclose><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        </statement>
        <p>Intuitively, a <italic toggle="yes">siphon S</italic> preserves the condition that if all places in <italic toggle="yes">S</italic> are unmarked (<inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo>∩</mml:mo><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula>), the siphon remains unmarked. Furthermore, for a PN <inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we say that a siphon is ‘conflict-free’ when for all <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>, we have that <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>}</mml:mo><mml:mo>∖</mml:mo><mml:mi>S</mml:mi><mml:menclose notation="updiagonalstrike"><mml:mo>=</mml:mo></mml:menclose><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula>. That is, a conflict-free siphon must not contain ‘all’ places encoding a particular variable. Intuitively, every conflict-free siphon of <inline-formula id="IE124"><mml:math id="IM124" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> represents a mirror of ‘some’ space <inline-formula id="IE125"><mml:math id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>⋆</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> (however, not all mirrors of spaces are siphons).</p>
        <p>With this knowledge, we can observe the following theorem:<statement id="mthst9"><p><sc>Theorem</sc> 2. <italic toggle="yes">Let</italic> <inline-formula id="IE126"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula><italic toggle="yes">be an MVN and</italic> <inline-formula id="IE127"><mml:math id="IM127" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">its PN encoding. Then a space</italic> <inline-formula id="IE128"><mml:math id="IM128" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>⋆</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula><italic toggle="yes">is a trap space if and only if its mirror</italic> <inline-formula id="IE129"><mml:math id="IM129" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">is a conflict-free siphon of</italic> <inline-formula id="IE130"><mml:math id="IM130" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p></statement></p>
        <p>The proof is available in the Supplementary Data as Theorem 5.</p>
        <p>Finally, note that we can define a partial order on siphons based on the subset relation, just as we did for trap spaces. Based on the definition of a mirror and the correspondence we just proved, we can easily deduce the following (see the proofs of Theorems 6 and 7 in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref>):<statement id="mthst10"><p><sc>Proposition</sc> 2. <italic toggle="yes">A trap space m of an MVN</italic> <inline-formula id="IE131"><mml:math id="IM131" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula><italic toggle="yes">is minimal if</italic> <inline-formula id="IE132"><mml:math id="IM132" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">is a maximal conflict-free siphon of</italic> <inline-formula id="IE133"><mml:math id="IM133" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">. A trap space m is maximal if</italic> <inline-formula id="IE134"><mml:math id="IM134" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">is a minimal conflict-free siphon.</italic></p></statement></p>
        <p>Observe that there are existing methods based on ASP (<xref rid="btad262-B33" ref-type="bibr">Trinh et al. 2022</xref>) and SAT solving (<xref rid="btad262-B24" ref-type="bibr">Nabli et al., 2016</xref>) that can handle enumeration of maximal (respectively, minimal) siphons and have been successfully used on Boolean networks before (<xref rid="btad262-B33" ref-type="bibr">Trinh et al. 2022</xref>). Our result shows that these methods should be also applicable to MVNs. Specifically, we aim to extend the ASP encoding from (<xref rid="btad262-B33" ref-type="bibr">Trinh et al. 2022</xref>) in order to support both maximal and minimal trap spaces of both general and unitary MVNs.</p>
      </sec>
      <sec>
        <title>2.4.3 Siphon computation through ASP encoding</title>
        <p>For now, we neglected the question of update function representation for MVNs, as this depends strongly on the chosen input format. In our work, we consider both SBML-qual (<xref rid="btad262-B8" ref-type="bibr">Chaouiya et al. 2013</xref>) and BMA (BioModelAnalyzer) (<xref rid="btad262-B4" ref-type="bibr">Benque et al. 2012</xref>) formats. These differ significantly in terms of both format and capabilities.</p>
        <p>Ultimately, we represent an update function <italic toggle="yes">f<sub>i</sub></italic> using a series of ‘binary decision diagrams’ (BDDs) (<xref rid="btad262-B5" ref-type="bibr">Bryant 1986</xref>) <inline-formula id="IE135"><mml:math id="IM135" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. The network variables are encoded into Boolean variables <inline-formula id="IE136"><mml:math id="IM136" display="inline" overflow="scroll"><mml:mrow><mml:munder><mml:mo>∪</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, just as in the case of the PN encoding. Subsequently, each BDD in the series gives the necessary and sufficient conditions for achieving a particular result level:
</p>
        <disp-formula id="E2">
          <mml:math id="M2" display="block" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>f</mml:mi>
                </mml:mrow>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>x</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:mrow>
                <mml:mo>{</mml:mo>
                <mml:mrow>
                  <mml:mtable>
                    <mml:mtr columnalign="left">
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>y</mml:mi>
                            </mml:mrow>
                            <mml:mn>1</mml:mn>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>B</mml:mi>
                            </mml:mrow>
                            <mml:mn>1</mml:mn>
                          </mml:msub>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mi>x</mml:mi>
                          <mml:mo stretchy="false">)</mml:mo>
                          <mml:mo>=</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr columnalign="left">
                      <mml:mtd columnalign="left">
                        <mml:mo>…</mml:mo>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mrow/>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr columnalign="left">
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>y</mml:mi>
                            </mml:mrow>
                            <mml:mi>k</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>B</mml:mi>
                            </mml:mrow>
                            <mml:mi>k</mml:mi>
                          </mml:msub>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mi>x</mml:mi>
                          <mml:mo stretchy="false">)</mml:mo>
                          <mml:mo>=</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:mrow>
              </mml:mrow>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p>Here, <inline-formula id="IE137"><mml:math id="IM137" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">B<sub>i</sub></italic> are individual BDDs, such that each BDD can be interpreted as a Boolean function on the encoded state <italic toggle="yes">x</italic>. We also require that for each state, there is exactly one BDD <italic toggle="yes">B<sub>j</sub></italic> s.t. <inline-formula id="IE138"><mml:math id="IM138" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, hence the whole function is well defined. Also, note that such <italic toggle="yes">f<sub>i</sub></italic> can be easily transformed into <inline-formula id="IE139"><mml:math id="IM139" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, respecting either general or unitary variable update as desired.</p>
        <p>This representation is relatively straightforward to obtain for SBML-qual models, as each update function is given as a list of Boolean terms over standard equality/inequality integer propositions. In this representation, the output values can repeat across multiple terms, and the function is not required to be exhaustive (there is a ‘default’ output value assigned to remaining inputs). However, this is easy to amend once each term is transformed into a symbolic BDD representation (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref>).</p>
        <p>For BMA, the translation process is more involved, as update functions are described through a language of algebraic expressions including addition (+), subtraction (–), multiplication (<inline-formula id="IE140"><mml:math id="IM140" display="inline" overflow="scroll"><mml:mo>·</mml:mo></mml:math></inline-formula>), and division (<inline-formula id="IE141"><mml:math id="IM141" display="inline" overflow="scroll"><mml:mo>/</mml:mo></mml:math></inline-formula>), as well as other special functions like average and rounding. Furthermore, BMA employs a normalizing transformation on function inputs when the input domain differs from the output domain. That is, an input variable <italic toggle="yes">v</italic> in the range <inline-formula id="IE142"><mml:math id="IM142" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is normalized to the range <inline-formula id="IE143"><mml:math id="IM143" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> when used in the update function <italic toggle="yes">f<sub>u</sub></italic>. As such, while BMA only admits integer variables, the update functions are more akin to rational functions.</p>
        <p>While there are frameworks which partially support symbolic evaluation of such functions, e.g. algebraic decision diagrams (<xref rid="btad262-B2" ref-type="bibr">Bahar et al. 1997</xref>), we are not aware of any implementation that would support all the operations required by BMA. We thus opted to enumerate the whole function table and re-encode it back into individual BDDs.</p>
        <p>Finally, to encode the dynamics of <inline-formula id="IE144"><mml:math id="IM144" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> into a PN, we consider all variable updates <inline-formula id="IE145"><mml:math id="IM145" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>→</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (with <italic toggle="yes">k</italic> being <inline-formula id="IE146"><mml:math id="IM146" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>±</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> when <inline-formula id="IE147"><mml:math id="IM147" display="inline" overflow="scroll"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula> is unitary), and then enumerate all satisfying partial valuations <italic toggle="yes">w</italic> of the BDD <inline-formula id="IE148"><mml:math id="IM148" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>∧</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>B</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (<inline-formula id="IE149"><mml:math id="IM149" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>B</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> being the BDD of <inline-formula id="IE150"><mml:math id="IM150" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> for output level <italic toggle="yes">k</italic>). For every valuation <italic toggle="yes">w</italic>, a transition <inline-formula id="IE151"><mml:math id="IM151" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula> is created which moves the token from <inline-formula id="IE152"><mml:math id="IM152" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE153"><mml:math id="IM153" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> while ensuring that for every other relevant <inline-formula id="IE154"><mml:math id="IM154" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>, place <inline-formula id="IE155"><mml:math id="IM155" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> contains a token.</p>
        <p>Note that the number of satisfying partial valuations <italic toggle="yes">w</italic> of a BDD (and transitively, the number of PN transitions) depends on the ‘ordering’ of Boolean variables within the BDD. However, computing the optimal variable ordering is a known non-trivial problem. To reduce the number of transitions in the resulting PN, we always test <italic toggle="yes">k</italic> randomized orderings for every update function and pick the one which produces the most compact PN.</p>
        <p>Once the PN encoding <inline-formula id="IE156"><mml:math id="IM156" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is completed, the method proceeds based on the ASP encoding of the PN siphon problem proposed by <xref rid="btad262-B33" ref-type="bibr">Trinh et al. (2022)</xref>. This encoding produces a query which can be processed by an ASP solver such as <monospace>clingo</monospace> (<xref rid="btad262-B14" ref-type="bibr">Gebser et al. 2011</xref>), enumerating all maximal/minimal siphons of <inline-formula id="IE157"><mml:math id="IM157" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Technical aspects of this process are given in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref>.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>We now present the results of our computational experiments. First, we establish the benchmark model dataset and describe the overall implementation of our tool <monospace>trapmvn</monospace>. We then present the performance evaluation of <monospace>trapmvn</monospace> in relation to the benchmark models and other tools (where applicable). Finally, we use the trap spaces arising under a wide range of therapeutic interventions in a Myc-deregulation model of breast cancer to assess the viability and reliability of such interventions.</p>
    <sec>
      <title>3.1 Experiment setup</title>
      <p>In our testing, we utilize SBML models from the BBM benchmark (<ext-link xlink:href="https://github.com/sybila/biodivine-boolean-models/" ext-link-type="uri">https://github.com/sybila/biodivine-boolean-models/</ext-link>; note that BBM primarily publishes Booleanized SBML models, but the original multi-valued SBML files are also available.), which includes models from the GINsim tool (<xref rid="btad262-B6" ref-type="bibr">Chaouiya et al. 2011a</xref>, <xref rid="btad262-B9" ref-type="bibr">2011b</xref>) repository as well as other independently sourced models. Furthermore, we include models from the BMA tool (<ext-link xlink:href="http://biomodelanalyzer.org" ext-link-type="uri">http://biomodelanalyzer.org</ext-link>) repository (<xref rid="btad262-B4" ref-type="bibr">Benque et al. 2012</xref>). Disregarding trivial cases, we are left with 26 benchmark models. To the best of our knowledge, this is a highly representative sample of multi-valued models currently available in literature. The details of each benchmark model, technical description of the performance testing, as well as full results are given in Section 6 of the <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref>.</p>
    </sec>
    <sec>
      <title>3.2 The <monospace>trapmvn</monospace> package</title>
      <p>We implement our method as a stand-alone open-source Python package <monospace>trapmvn</monospace>. The package provides a basic parser for both SBML and BMA models (JSON or XML). It implements the symbolic encoding for both formats using the BDD data structure from the <monospace>AEON.py</monospace> package (<xref rid="btad262-B3" ref-type="bibr">Beneš et al. 2022</xref>). From this symbolic encoding, we build either a ‘general’ or a ‘unitary’ one-safe PN. Such PN can be then encoded into the ASP query for the respective problem class and processed by the solver <monospace>clingo</monospace> (<xref rid="btad262-B14" ref-type="bibr">Gebser et al. 2011</xref>). All these steps are available to the user through several Python classes, but can be also handled directly by a simple command line interface. Finally, we also support export of the symbolic model representation back into SBML. This allows us to convert BMA models to SBML (to the best of our knowledge, this is not supported by any other tool).</p>
    </sec>
    <sec>
      <title>3.3 Performance evaluation</title>
      <p>Due to the lack of both theory and available tools, we are not aware of any existing study of trap spaces in MVNs. Nevertheless, as we have shown, the Van Ham encoding (<xref rid="btad262-B16" ref-type="bibr">Ham 1979</xref>) preserves the ‘minimal’ trap spaces under unitary semantics. Tools for computing minimal trap spaces of plain Boolean networks can be thus used in this case. We use <monospace>bioLQM</monospace> (<xref rid="btad262-B8" ref-type="bibr">Chaouiya et al. 2013</xref>) to compute the Van Ham encoding when necessary.</p>
      <p>We can also consider fixed-points as a special (simpler) class of trap spaces. We can thus also compare with tools that specialize in this type of problem. Consequently, our performance evaluation consists of three parts: ‘minimal’ and ‘maximal’ trap spaces, and ‘fixed-points’.</p>
      <sec>
        <title>3.3.1 Minimal trap spaces</title>
        <p>To test the performance of <monospace>trapmvn</monospace> when computing minimal trap spaces, we compare its runtime to two state-of-the-art tools for trap space computation in Boolean networks, <monospace>trappist</monospace> (<xref rid="btad262-B33" ref-type="bibr">Trinh et al. 2022)</xref> and <monospace>mpbn</monospace> (<xref rid="btad262-B26" ref-type="bibr">Paulevé et al. 2020</xref>) (using the Van Ham encoding). Because the number of trap spaces can be large and the knowledge of all trap spaces is not always required, we consider two experiment settings: computing just ‘one’ and computing ‘all’ minimal trap spaces. The full results of this analysis are available in <xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S5 and S6</xref>.</p>
        <p>In general, <monospace>trapmvn</monospace> can handle all models in reasonable time for both the general and unitary semantics. Focusing on the unitary case, the difference in runtime when computing all minimal trap spaces is summarized in <xref rid="btad262-F2" ref-type="fig">Fig. 2</xref>. Here, we see that <monospace>trapmvn</monospace> performs substantially better than <monospace>mpbn</monospace>, and is also always faster than <monospace>trappist</monospace>. However, the exact speed-up is hard to assess due to the presence of logarithmic time scales. As such, we also provide a simple box plot comparing the actual speed-up in <xref rid="btad262-F3" ref-type="fig">Fig. 3</xref>. Here, we see that <monospace>trapmvn</monospace> outperforms both methods by a significant margin in both scenarios (i.e. first result and all results). We also compute the average speed-up weighted by the absolute runtime of each benchmark (i.e. longer running benchmarks are given higher weight), showing that when computing ‘all’ trap spaces, <monospace>trapmvn</monospace> is <inline-formula id="IE158"><mml:math id="IM158" display="inline" overflow="scroll"><mml:mrow><mml:mn>3</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster than <monospace>trappist</monospace>, and <inline-formula id="IE159"><mml:math id="IM159" display="inline" overflow="scroll"><mml:mrow><mml:mn>58</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster than <monospace>mpbn</monospace>.</p>
        <fig position="float" id="btad262-F2">
          <label>Figure 2.</label>
          <caption>
            <p>Relative performance of <monospace>trapmvn</monospace> compared with <monospace>trappist</monospace> and <monospace>mpbn</monospace> when counting all minimal trap spaces. The time scales are logarithmic. Points at the edge of the graph represent timeouts.</p>
          </caption>
          <graphic xlink:href="btad262f2" position="float"/>
        </fig>
        <fig position="float" id="btad262-F3">
          <label>Figure 3.</label>
          <caption>
            <p>Relative speed-up in runtime of <monospace>trap-mvn</monospace> compared with <monospace>trappist</monospace> (top), res. <monospace>mpbn</monospace> (bottom).</p>
          </caption>
          <graphic xlink:href="btad262f3" position="float"/>
        </fig>
      </sec>
      <sec>
        <title>3.3.2 Maximal trap spaces</title>
        <p>The Van Ham encoding is not suitable for preserving ‘maximal’ trap spaces, and we are not aware of any existing method that can efficiently transform this problem to the domain of Boolean networks. As such, we cannot compare <monospace>trapmvn</monospace> to any other tool for this problem class. Nevertheless, we show that <monospace>trapmvn</monospace> can easily compute all maximal trap spaces of the considered benchmark models (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S7</xref>).</p>
      </sec>
      <sec>
        <title>3.3.3 Fixed-points</title>
        <p>Finally, for the case of fixed-points, there are two viable ASP encodings, one based on PN siphons and the other based on PN deadlocks. The encoding based on deadlocks is generally more efficient for this simpler problem class. As such, we implement both variants in <monospace>trapmvn</monospace> and compare the results to the Booleanized results from the tools <monospace>trappist</monospace> (<xref rid="btad262-B33" ref-type="bibr">Trinh et al. 2022</xref>) and <monospace>mpbn</monospace> (<xref rid="btad262-B26" ref-type="bibr">Paulevé et al. 2020</xref>), and multi-valued results from <monospace>AN-ASP</monospace> (<xref rid="btad262-B1" ref-type="bibr">Abdallah et al. 2017</xref>). Overall, our evaluation confirms the benefits of the deadlock-based encoding, showing a <inline-formula id="IE160"><mml:math id="IM160" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.6</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> speed-up compared with the siphon encoding (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S8</xref>). Furthermore, we show that <monospace>trapmvn</monospace> also performs better than <monospace>trappist</monospace> or <monospace>mpbn</monospace> on fixed-point computation, but is outperformed by <monospace>AN-ASP</monospace> (<inline-formula id="IE161"><mml:math id="IM161" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.3</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> speed-up), since <monospace>AN-ASP</monospace> is optimized solely for this specific type of problem.</p>
      </sec>
    </sec>
    <sec>
      <title>3.4 Therapeutic interventions of Myc-deregulation</title>
      <p>To demonstrate the practical utility of <monospace>trapmvn</monospace> in biological modelling, we present a case study expanding on the findings of <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref>. The authors of <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref> use <monospace>BMA</monospace> (<xref rid="btad262-B4" ref-type="bibr">Benque et al. 2012</xref>) to explore viable therapeutic interventions in a large computational model of breast cancer through the lens of network attractors. Here, we show how to more reliably interpret the model by focusing on trap spaces instead.</p>
      <sec>
        <title>3.4.1 Modelling Myc heterogeneity in breast cancer</title>
        <p>The Myc transcription factor is one of the key coordinators in cell proliferation and regeneration (<xref rid="btad262-B19" ref-type="bibr">Kortlever et al. 2017</xref>). As such, oncogenic deregulations of Myc are commonplace in many cancers, breast cancer in particular (<xref rid="btad262-B34" ref-type="bibr">Vita and Henriksson 2006</xref>).</p>
        <p>Still, most tumours have been shown to consist of several genetically distinct mutants, only some of which exhibit Myc overexpression (<xref rid="btad262-B15" ref-type="bibr">Gerlinger et al. 2012</xref>; <xref rid="btad262-B17" ref-type="bibr">Heselmeyer-Haddad et al. 2012</xref>). Such heterogeneity can impede some treatments, but it can also enable new therapies that target the cooperation between the mutants (<xref rid="btad262-B22" ref-type="bibr">Marusyk et al. 2014</xref>; <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. 2019</xref>).</p>
        <p>In the case of Myc-related mutations, an overexpression of Myc is linked to super-competitive behaviour that causes the cancerous cells to outproliferate their healthy neighbours. However, the same overexpression is also linked to greatly increased predisposition to apoptosis. In <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref>, the authors reveal a mechanism by which Myc<sup>high</sup> mutants survive using a supply of Wnt1 transcription factor produced by a different, Myc<sup>low</sup> mutant.</p>
        <p>This process is demonstrated both experimentally on <italic toggle="yes">in vivo</italic> mouse models, as well as <italic toggle="yes">in silico</italic> on a large-scale multi-valued computational model. Based on the intervention response observed <italic toggle="yes">in silico</italic>, the authors identify a viable therapy targeting COX2 and MEK transcription factors and validate this therapy <italic toggle="yes">in vivo</italic>.</p>
        <p>The model itself consists of 72 variables, ranging from 4 to 7 levels (<monospace>MYC IN-VIVO</monospace> in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S5</xref>). It is based on known literature, with additional validation and tuning using several independent datasets. There are five model variants: A healthy ‘wild-type’ (WT) model, Myc<sup>low</sup> and Myc<sup>high</sup> variants where the tumour consists homogeneously of a single mutant, and finally, mix-Myc<sup>low</sup> and mix-Myc<sup>high</sup> variants, which describe a heterogeneous tumour. In this case, the interaction is given as an outside assumption; there is no single model consisting of both Myc<sup>low</sup> and Myc<sup>high</sup> mutants sharing a state space.</p>
        <p>To study the effects of possible therapeutic interventions, the authors compare the ‘synchronous’ attractors approximated by <monospace>BMA</monospace> across a range of single and dual variable knockouts. The effect of each intervention on the real-world phenotypes is assessed through variables <monospace>Apoptosis</monospace> and <monospace>Proliferation</monospace> which are directly embedded into the network. While this methodology is viable, it has shortcomings which we hope to address.</p>
        <p>First, while <monospace>BMA</monospace> should be capable of computing the ‘exact’ synchronous attractors, the results in <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref> are only based on an ‘approximate’ method, due to the (lack of) scalability of the exact method. Second, the ‘synchronous’ update scheme can miss plausible model behaviour due to artificial synchronization between variables (<xref rid="btad262-B30" ref-type="bibr">Schwab et al. 2020</xref>). Meanwhile, trap spaces are universal regardless of the chosen update scheme (<xref rid="btad262-B26" ref-type="bibr">Paulevé et al. 2020</xref>). Finally, for non-trivial attractors, the case study in <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref> only considers the ‘average’ values of <monospace>Apoptosis</monospace> and <monospace>Proliferation</monospace>, which can be a poor approximation of the model’s actual admissible behaviour. This is despite the fact that BMA ‘can’ also compute the estimated attractor intervals.</p>
      </sec>
      <sec>
        <title>3.4.2 Single intervention effects</title>
        <p>We start by replicating the single-variable knockout interventions performed in <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref>, but in the context of trap spaces. Highlights from this analysis are presented in <xref rid="btad262-T1" ref-type="table">Table 1</xref> (full data are available in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref>). These results are in many aspects comparable to the original results obtained through <monospace>BMA</monospace>, however, they often paint a more complete picture of the model’s behaviour.</p>
        <table-wrap position="float" id="btad262-T1">
          <label>Table 1.</label>
          <caption>
            <p>Effects of selected single-node perturbations on proliferation (left) and apoptosis (right).</p>
          </caption>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col valign="top" align="left" span="1"/>
            </colgroup>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">
                  <inline-graphic xlink:href="btad262ilf1.jpg"/>
                </td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <fn id="tblfn1">
              <p>Intervals show non-trivial trap spaces. Values with asterisk show improvements over BMA approximate result.</p>
            </fn>
          </table-wrap-foot>
        </table-wrap>
        <p>First, there are four instances where our ‘exact’ method actually improves the precision of the original ‘approximate’ result (marked with an asterisk). Note that the more specific result is in all cases at the edge of the interval established by <monospace>BMA</monospace>, which means that it substantially differs from the ‘average’ considered in <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref>.</p>
        <p>Second, there are clearly many cases where the intervention causes the appearance of a non-trivial trap space, signified by an interval instead of a fixed value. Knowledge of these intervals is crucial when interpreting the effectiveness of interventions.</p>
        <p>For example, consider the value of <monospace>Apoptosis</monospace> for the knockouts of Mcl1 and COX2 in mix-Myc<sup>low</sup>. The average value is the same (i.e. 3), but the admissible interval is <inline-formula id="IE198"><mml:math id="IM198" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> for Mcl1 and <inline-formula id="IE199"><mml:math id="IM199" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>6</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> for COX2. The Mcl1 intervention guarantees <inline-formula id="IE200"><mml:math id="IM200" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">Apoptosis</mml:mi><mml:mo>≥</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, but we have no such expectation for COX2: Even though the ‘best case’ outcome is higher (i.e. <inline-formula id="IE201"><mml:math id="IM201" display="inline" overflow="scroll"><mml:mrow><mml:mn>6</mml:mn><mml:mo>&gt;</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>), the system is not guaranteed to visit these high-value states sufficiently often to trigger apoptosis.</p>
      </sec>
      <sec>
        <title>3.4.3 Dual interventions with reliable and opportunistic effects</title>
        <p>To systematically rank the high number of possible dual interventions, we propose to score each intervention <italic toggle="yes">I</italic> with two metrics, ‘reliability’ and ‘opportunity’, denoted by rel(<italic toggle="yes">I</italic>) and opp(<italic toggle="yes">I</italic>), respectively. The intuition is that these scores should represent the ‘worst’ and ‘best’ case scenarios (in terms of <monospace>Apoptosis</monospace> and <monospace>Proliferation</monospace>) admitted by the model for each intervention, regardless of the considered update concurrency. The exact definitions of these scores are given in <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S5.4</xref>.</p>
        <p>We then focus on the admissible dual-knockout interventions: both knockouts must be druggable (according to <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. 2019</xref>), and their combination cannot increase <monospace>Apoptosis</monospace> beyond level three in the WT model. This leaves 995 interventions for which we compute both scores. For presentation purposes, we sort the interventions by the ‘average’ of these two scores.</p>
        <p>The eight best and the eight worst interventions are shown in <xref rid="btad262-F4" ref-type="fig">Fig. 4</xref>. As we can see, some of the best interventions admit a non-trivial trap space for the mix-Myc<sup>low</sup> variant. However, even in this case, the reliability and opportunity scores are not vastly different. This raises a natural question regarding the prevalence of differences between reliability and opportunity scores in general. We further study this question in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Data</xref> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Section S5.4</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S6</xref>, in particular), where we show that substantial differences between the two scores are in fact common even within the best scoring interventions.</p>
        <fig position="float" id="btad262-F4">
          <label>Figure 4.</label>
          <caption>
            <p>Eight best and worst dual interventions (out of 995 tested), together with their reliability and opportunity scores, as well as their effect on the relevant model variables.</p>
          </caption>
          <graphic xlink:href="btad262f4" position="float"/>
        </fig>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>In this article, we formalized the notion of trap spaces in MVNs, then explored and proved properties of such trap spaces with applications in the analysis and control of MVNs. One notable property is that trap spaces of MVNs are independent to concurrency update schemes. We argued that, akin to Boolean networks, trap spaces can serve as approximation of network attractors. Furthermore, we showed that not all useful properties of trap spaces are preserved through a Boolean encoding of an MVN. For example, maximal trap spaces of unitary networks, crucial for the construction of the network’s succession diagram (<xref rid="btad262-B28" ref-type="bibr">Rozum et al. 2021</xref>), are not preserved. Next, we made a connection between trap spaces of an MVN and siphons of its PN encoding. Based on this relationship, we proposed and implemented a new ASP method for computing different types of trap spaces of an MVN.</p>
    <sec>
      <title>4.1 Method performance</title>
      <p>We have evaluated the time efficiency of our method on real-world models collected from the literature. We show that the method scales well with the network size and it can handle large-scale realistic models for both the general and unitary semantics. The indirect approach (i.e. through a Boolean encoding) is only applicable for the case of fixed-points and minimal unitary trap spaces. In these cases, the direct approach (i.e. our method) outperforms the best indirect method.</p>
      <p>In particular, we discuss the factors that contribute to the running time of each compared method (all are ASP-based) with respect to the minimal trap space computation. Aside from the absolute number of solutions, the practical complexity of an ASP query is affected by its number of atoms and its ‘density’, i.e. the ratio between the number of ASP rules and atoms. Through a systematic analysis (details are available in <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S6.1</xref>), we see that an increase in density is always accompanied by increased runtime. Query density is clearly not the only indicator of ASP problem complexity. However, assuming we control for other relevant factors (solution count, tool/method, update scheme, model format, etc.), query density appears to be a relevant metric for comparing the complexity of two minimal trap space computation problems.</p>
      <p>We also analyse the runtime of our method <monospace>trap-mvn</monospace> in the general and unitary cases. In general, <monospace>trap-mvn</monospace> needs more time for the general case than for the unitary case, as the PN encoding of a general MVN has more transitions than that of its unitary counterpart. The detailed discussions are given at the end of Section S6.1.</p>
      <p>Finally, we have tried to also compare the performance of <monospace>trap-mvn</monospace> to BMA. However, in its current state, we were only able to run the ‘approximate’ attractor detection method, which is (as expected), much faster than any of the tested ‘exact’ methods. There appears to be no public documentation or reproducible artefact concerning the exact solver-based approach for the currently available version of BMA. However, the authors of <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref> note that the exact method was not able to efficiently analyse the Myc heterogeneity model. As such, it seems unlikely that it would provide competitive performance on the remaining models in our benchmark set.</p>
    </sec>
    <sec>
      <title>4.2 Reliable identification of network interventions</title>
      <p>Subsequently, we studied the practical applicability of our method on a model of Myc-deregulation from <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref>. First, we indeed found instances where our exact method can improve the approximate results obtained in <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref>. Furthermore, as we show in <xref rid="btad262-T1" ref-type="table">Table 1</xref>, the behaviour of the model can often admit significant fluctuations and uncertainty. These are not reflected in the average value within attractor states, as considered in <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref>. This highlights the need for rigorous and exhaustive analysis of such behaviour uncertainty.</p>
      <p>With this goal in mind, we propose a ‘reliability’ and ‘opportunity’ score to assess the viability of therapeutic interventions. Based on these scores, we see that even interventions that introduce some amount of uncertainty can be safely considered among the most viable (<xref rid="btad262-F4" ref-type="fig">Fig. 4</xref>). Furthermore, we study how prevalent is the variability of intervention scores in our dataset. As shown in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S6</xref>, for almost half of the interventions (439/995), the difference is zero. However, for 463/995 interventions, the model still admits a difference of three or more points. Such difference can impact the expected observed biological phenotypes if not taken into account. Furthermore, our results reveal that even though the highest score variability is associated with scores we would not consider particularly viable, very viable interventions (e.g. average score &gt;5) can still exhibit high variability (<inline-formula id="IE202"><mml:math id="IM202" display="inline" overflow="scroll"><mml:mrow><mml:mo>≤</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:math></inline-formula>).</p>
      <p>Notably, the COX2 + MEK intervention chosen in <xref rid="btad262-B20" ref-type="bibr">Kreuzaler et al. (2019)</xref> has a reliability and opportunity score equal to 5, placing it on rows 65–149 of the table in <xref rid="btad262-F4" ref-type="fig">Fig. 4</xref> (there are 84 interventions with the same scores). While this is not among the best scores, it is still better than 85%–93% of interventions, meaning we retained the viability of this particular intervention. Furthermore, it should be noted that our screening for ‘viable’ interventions is rather rudimentary: in practice, some of the top perturbations might be ruled out due to factors other than the WT <monospace>Apoptosis</monospace> result (e.g. other side effects not captured by this model).</p>
      <p>Overall, these results support the claim that logical models can exhibit a high level of variability in their outcomes and it is crucial to take this variability into account when drawing conclusions. Due to their favourable computational and theoretical properties, trap spaces appear to be uniquely suited for this task.</p>
    </sec>
    <sec>
      <title>4.3 Applications and future prospects</title>
      <p>Observe that the results we explored in this article can be also useful for other types of MVN analysis. First, there is a trap space-based model reduction technique. This relies on the fact that, given a single trap space, we can obtain a simpler MVN that captures the self-contained dynamics of the states within this trap space. Second, the set of minimal trap spaces of an MVN can be seen as an approximation of its attractors, regardless of the update concurrency. Third, there are existing control methods for Boolean networks based on trap spaces (<xref rid="btad262-B13" ref-type="bibr">Fontanals et al. 2020</xref>; <xref rid="btad262-B27" ref-type="bibr">Rozum et al. 2022</xref>). It should be possible to extend these methods to control of MVNs. We discuss the details of these applications in Section S3.3.</p>
      <p>As a perspective, we also plan to attack the attractor detection problem for MVNs, as trap spaces only capture the network’s static behaviour, whereas attractors can also capture its more complex dynamical aspects. Exploiting the relation between attractors and trap spaces of MVNs is a potentially promising direction for this problem. Furthermore, we plan to develop direct and efficient control methods for MVNs, because the control problem is crucial in systems biology. Arguably, it can be seen as ‘a sequel’ of the trap space or attractor analysis (<xref rid="btad262-B13" ref-type="bibr">Fontanals et al. 2020</xref>).</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad262_Supplementary_Data</label>
      <media xlink:href="btad262_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by L’Institut Carnot STAR, Marseille, France, and by the European Union’s Horizon 2020 research and innovation programme under the Marie Skłodowska-Curie Grant Agreement No. [101034413].</p>
  </sec>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>Source code and data are freely available at <ext-link xlink:href="https://github.com/giang-trinh/trap-mvn" ext-link-type="uri">https://github.com/giang-trinh/trap-mvn</ext-link>.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad262-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Abdallah</surname><given-names>EB</given-names></string-name>, <string-name><surname>Folschette</surname><given-names>M</given-names></string-name>, <string-name><surname>Roux</surname><given-names>O</given-names></string-name></person-group><etal>et al</etal><article-title>ASP-based method for the enumeration of attractors in non-deterministic synchronous and asynchronous multi-valued networks</article-title>. <source>Algorithms Mol Biol</source><year>2017</year>;<volume>12</volume>:<fpage>20</fpage>–<lpage>3</lpage>. <pub-id pub-id-type="doi">10.1186/s13015-017-0111-2</pub-id>.<pub-id pub-id-type="pmid">28814968</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bahar</surname><given-names>RI</given-names></string-name>, <string-name><surname>Frohm</surname><given-names>EA</given-names></string-name>, <string-name><surname>Gaona</surname><given-names>CM</given-names></string-name></person-group><etal>et al</etal><article-title>Algebric decision diagrams and their applications</article-title>. <source>Formal Methods Syst. Des</source><year>1997</year>;<volume>10</volume>:<fpage>171</fpage>–<lpage>206</lpage>. <pub-id pub-id-type="doi">10.1023/A:1008699807402</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad262-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Beneš</surname><given-names>N</given-names></string-name>, <string-name><surname>Brim</surname><given-names>L</given-names></string-name>, <string-name><surname>Huvar</surname><given-names>O</given-names></string-name></person-group><etal>et al</etal><article-title>AEON.py: python library for attractor analysis in asynchronous Boolean networks</article-title>. <source>Bioinformatics</source><year>2022</year>;<volume>38</volume>:<fpage>4978</fpage>–<lpage>80</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btac624</pub-id>.<pub-id pub-id-type="pmid">36102786</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B4">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Benque</surname><given-names>D</given-names></string-name>, <string-name><surname>Bourton</surname><given-names>S</given-names></string-name>, <string-name><surname>Cockerton</surname><given-names>C</given-names></string-name></person-group> <etal>et al</etal><part-title>BMA: visual tool for modeling and analyzing biological networks</part-title>. In: Madhusudan P, Seshia SA. (eds.) <source>Computer Aided Verification</source>. <publisher-loc>Berlin, Germany</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>2012</year>, <fpage>686</fpage>–<lpage>692</lpage>.</mixed-citation>
    </ref>
    <ref id="btad262-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bryant</surname><given-names>RE.</given-names></string-name></person-group><article-title>Graph-based algorithms for boolean function manipulation</article-title>. <source>IEEE Trans Comput</source><year>1986</year>;<volume>C-35</volume>:<fpage>677</fpage>–<lpage>91</lpage>. <pub-id pub-id-type="doi">10.1109/TC.1986.1676819</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad262-B6">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Chaouiya</surname><given-names>C</given-names></string-name>, <string-name><surname>Naldi</surname><given-names>A</given-names></string-name>, <string-name><surname>Thieffry</surname><given-names>D.</given-names></string-name></person-group><part-title>Logical modelling of gene regulatory networks with GINsim</part-title>. In: van Helden J, Toussaint A, Thieffry D. (eds.) <source>Bacterial Molecular Networks</source>. <publisher-loc>New York, NY</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>2011a</year>, <fpage>463</fpage>–<lpage>79</lpage>.</mixed-citation>
    </ref>
    <ref id="btad262-B7">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Chaouiya</surname><given-names>C</given-names></string-name>, <string-name><surname>Remy</surname><given-names>E</given-names></string-name>, <string-name><surname>Ruet</surname><given-names>P</given-names></string-name></person-group><etal>et al</etal><part-title>Qualitative modelling of genetic networks: From logical regulatory graphs to standard Petri nets</part-title>. In: Cortadella J, Reisig W. (eds.) <source>International Conference on Applications and Theory of Petri Nets</source>. <publisher-loc>Berlin, Germany</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>2004</year>, <fpage>137</fpage>–<lpage>56</lpage>.</mixed-citation>
    </ref>
    <ref id="btad262-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chaouiya</surname><given-names>C</given-names></string-name>, <string-name><surname>Bérenguier</surname><given-names>D</given-names></string-name>, <string-name><surname>Keating</surname><given-names>SM</given-names></string-name></person-group><etal>et al</etal><article-title>SBML qualitative models: a model representation format and infrastructure to foster interactions between qualitative modelling formalisms and tools</article-title>. <source>BMC Syst Biol</source><year>2013</year>;<volume>7</volume>:<fpage>135</fpage>. <pub-id pub-id-type="doi">10.1186/1752-0509-7-135</pub-id>.<pub-id pub-id-type="pmid">24321545</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chaouiya</surname><given-names>C</given-names></string-name>, <string-name><surname>Naldi</surname><given-names>A</given-names></string-name>, <string-name><surname>Remy</surname><given-names>E</given-names></string-name></person-group><etal>et al</etal><article-title>Petri net representation of multi-valued logical regulatory graphs</article-title>. <source>Nat Comput</source><year>2011b</year>;<volume>10</volume>:<fpage>727</fpage>–<lpage>50</lpage>. <pub-id pub-id-type="doi">10.1007/s11047-010-9178-0</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad262-B10">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Chatain</surname><given-names>T</given-names></string-name>, <string-name><surname>Haar</surname><given-names>S</given-names></string-name>, <string-name><surname>Jezequel</surname><given-names>L</given-names></string-name></person-group> <etal>et al</etal><part-title>Characterization of reachable attractors using petri net unfoldings</part-title>. In: Mendes P, Dada JO, Smallbone K. (eds.) <source>Computational Methods in Systems Biology</source>. <publisher-loc>Berlin, Germany</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>2014</year>, <fpage>129</fpage>–<lpage>42</lpage>.</mixed-citation>
    </ref>
    <ref id="btad262-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Delaplace</surname><given-names>F</given-names></string-name>, <string-name><surname>Ivanov</surname><given-names>S.</given-names></string-name></person-group><article-title>Bisimilar booleanization of multivalued networks</article-title>. <source>Biosystems</source><year>2020</year>;<volume>197</volume>:<fpage>104205</fpage>. <pub-id pub-id-type="doi">10.1016/j.biosystems.2020.104205</pub-id>.<pub-id pub-id-type="pmid">32622866</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Didier</surname><given-names>G</given-names></string-name>, <string-name><surname>Remy</surname><given-names>E</given-names></string-name>, <string-name><surname>Chaouiya</surname><given-names>C</given-names></string-name></person-group><etal>et al</etal><article-title>Mapping multivalued onto Boolean dynamics</article-title>. <source>J Theor Biol</source><year>2011</year>;<volume>270</volume>:<fpage>177</fpage>–<lpage>84</lpage>. <pub-id pub-id-type="doi">10.1016/j.jtbi.2010.09.017</pub-id>.<pub-id pub-id-type="pmid">20868697</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B13">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Fontanals</surname><given-names>LC</given-names></string-name>, <string-name><surname>Tonello</surname><given-names>E</given-names></string-name>, <string-name><surname>Siebert</surname><given-names>H.</given-names></string-name></person-group><part-title>Control strategy identification via trap spaces in Boolean networks</part-title>. In: Abate A, Petrov T, Wolf V. (eds.) <source>Computational Methods in Systems Biology</source>. <publisher-loc>Berlin, Germany</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>2020</year>, <fpage>159</fpage>–<lpage>75</lpage>.</mixed-citation>
    </ref>
    <ref id="btad262-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gebser</surname><given-names>M</given-names></string-name>, <string-name><surname>Kaufmann</surname><given-names>B</given-names></string-name>, <string-name><surname>Kaminski</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Potassco: the Potsdam answer set solving collection</article-title>. <source>AI Commun</source><year>2011</year>;<volume>24</volume>:<fpage>107</fpage>–<lpage>24</lpage>. <pub-id pub-id-type="doi">10.3233/AIC-2011-0491</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad262-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gerlinger</surname><given-names>M</given-names></string-name>, <string-name><surname>Rowan</surname><given-names>AJ</given-names></string-name>, <string-name><surname>Horswell</surname><given-names>S</given-names></string-name></person-group><etal>et al</etal><article-title>Intratumor heterogeneity and branched evolution revealed by multiregion sequencing</article-title>. <source>N Engl J Med</source><year>2012</year>;<volume>366</volume>:<fpage>883</fpage>–<lpage>92</lpage>. <pub-id pub-id-type="doi">10.1056/NEJMoa1113205</pub-id>.<pub-id pub-id-type="pmid">22397650</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B16">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Ham</surname><given-names>PV.</given-names></string-name></person-group><part-title>How to deal with variables with more than two levels</part-title>. In: Thomas R. (ed.) <source>Lecture Notes in Biomathematics</source>. <publisher-loc>Berlin, Germany</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>1979</year>, <fpage>326</fpage>–<lpage>43</lpage>.</mixed-citation>
    </ref>
    <ref id="btad262-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Heselmeyer-Haddad</surname><given-names>K</given-names></string-name>, <string-name><surname>Berroa Garcia</surname><given-names>LY</given-names></string-name>, <string-name><surname>Bradley</surname><given-names>A</given-names></string-name></person-group><etal>et al</etal><article-title>Single-cell genetic analysis of ductal carcinoma in situ and invasive breast cancer reveals enormous tumor heterogeneity yet conserved genomic imbalances and gain of myc during progression</article-title>. <source>Am J Pathol</source><year>2012</year>;<volume>181</volume>:<fpage>1807</fpage>–<lpage>22</lpage>. <pub-id pub-id-type="doi">10.1016/j.ajpath.2012.07.012</pub-id>.<pub-id pub-id-type="pmid">23062488</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Klarner</surname><given-names>H</given-names></string-name>, <string-name><surname>Streck</surname><given-names>A</given-names></string-name>, <string-name><surname>Siebert</surname><given-names>H</given-names></string-name></person-group><etal>et al</etal><article-title>PyBoolNet: a python package for the generation, analysis and visualization of Boolean networks</article-title>. <source>Bioinformatics</source><year>2017</year>;<volume>33</volume>:<fpage>770</fpage>–<lpage>2</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btw682</pub-id>.<pub-id pub-id-type="pmid">27797783</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kortlever</surname><given-names>RM</given-names></string-name>, <string-name><surname>Sodir</surname><given-names>NM</given-names></string-name>, <string-name><surname>Wilson</surname><given-names>CH</given-names></string-name></person-group><etal>et al</etal><article-title>Myc cooperates with Ras by programming inflammation and immune suppression</article-title>. <source>Cell</source><year>2017</year>;<volume>171</volume>:<fpage>1301</fpage>–<lpage>15.e14</lpage>. <pub-id pub-id-type="doi">10.1016/j.cell.2017.11.013</pub-id>.<pub-id pub-id-type="pmid">29195074</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kreuzaler</surname><given-names>P</given-names></string-name>, <string-name><surname>Clarke</surname><given-names>MA</given-names></string-name>, <string-name><surname>Brown</surname><given-names>EJ</given-names></string-name></person-group><etal>et al</etal><article-title>Heterogeneity of Myc expression in breast cancer exposes pharmacological vulnerabilities revealed through executable mechanistic modeling</article-title>. <source>Proc Natl Acad Sci USA</source><year>2019</year>;<volume>116</volume>:<fpage>22399</fpage>–<lpage>408</lpage>. <pub-id pub-id-type="doi">10.1073/pnas.1903485116</pub-id>.<pub-id pub-id-type="pmid">31611367</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Liu</surname><given-names>G</given-names></string-name>, <string-name><surname>Barkaoui</surname><given-names>K.</given-names></string-name></person-group><article-title>A survey of siphons in petri nets</article-title>. <source>Inf Sci</source><year>2016</year>;<volume>363</volume>:<fpage>198</fpage>–<lpage>220</lpage>. <pub-id pub-id-type="doi">10.1016/j.ins.2015.08.037</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad262-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marusyk</surname><given-names>A</given-names></string-name>, <string-name><surname>Tabassum</surname><given-names>DP</given-names></string-name>, <string-name><surname>Altrock</surname><given-names>PM</given-names></string-name></person-group><etal>et al</etal><article-title>Non-cell-autonomous driving of tumour growth supports sub-clonal heterogeneity</article-title>. <source>Nature</source><year>2014</year>;<volume>514</volume>:<fpage>54</fpage>–<lpage>8</lpage>. <pub-id pub-id-type="doi">10.1038/nature13556</pub-id>.<pub-id pub-id-type="pmid">25079331</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mushthofa</surname><given-names>M</given-names></string-name>, <string-name><surname>Schockaert</surname><given-names>S</given-names></string-name>, <string-name><surname>Hung</surname><given-names>LH</given-names></string-name></person-group><etal>et al</etal><article-title>Modeling multi-valued biological interaction networks using fuzzy answer set programming</article-title>. <source>Fuzzy Sets Syst</source><year>2018</year>;<volume>345</volume>:<fpage>63</fpage>–<lpage>82</lpage>. <pub-id pub-id-type="doi">10.1016/j.fss.2018.01.003</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad262-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Nabli</surname><given-names>F</given-names></string-name>, <string-name><surname>Martinez</surname><given-names>T</given-names></string-name>, <string-name><surname>Fages</surname><given-names>F</given-names></string-name></person-group><etal>et al</etal><article-title>On enumerating minimal siphons in Petri nets using CLP and SAT solvers: theoretical and practical complexity</article-title>. <source>Constraints</source><year>2016</year>;<volume>21</volume>:<fpage>251</fpage>–<lpage>76</lpage>. <pub-id pub-id-type="doi">10.1007/s10601-015-9190-1</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad262-B25">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Naldi</surname><given-names>A</given-names></string-name>, <string-name><surname>Thieffry</surname><given-names>D</given-names></string-name>, <string-name><surname>Chaouiya</surname><given-names>C.</given-names></string-name></person-group><part-title>Decision diagrams for the representation and analysis of logical models of genetic networks</part-title>. In: Calder M, Gilmore S. (eds.) <source>Computational Methods in Systems Biology</source>. <publisher-loc>Berlin, Germany</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>2007</year>, <fpage>233</fpage>–<lpage>47</lpage>.</mixed-citation>
    </ref>
    <ref id="btad262-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Paulevé</surname><given-names>L</given-names></string-name>, <string-name><surname>Kolčák</surname><given-names>J</given-names></string-name>, <string-name><surname>Chatain</surname><given-names>T</given-names></string-name></person-group><etal>et al</etal><article-title>Reconciling qualitative, abstract, and scalable modeling of biological networks</article-title>. <source>Nat Commun</source><year>2020</year>;<volume>11</volume>:<fpage>1</fpage>–<lpage>7</lpage>. <pub-id pub-id-type="doi">10.1038/s41467-020-18112-5</pub-id>.<pub-id pub-id-type="pmid">31911652</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rozum</surname><given-names>JC</given-names></string-name>, <string-name><surname>Deritei</surname><given-names>D</given-names></string-name>, <string-name><surname>Park</surname><given-names>KH</given-names></string-name></person-group><etal>et al</etal><article-title>Pystablemotifs: python library for attractor identification and control in Boolean networks</article-title>. <source>Bioinformatics</source><year>2022</year>;<volume>38</volume>:<fpage>1465</fpage>–<lpage>6</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btab825</pub-id>.<pub-id pub-id-type="pmid">34875008</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rozum</surname><given-names>JC</given-names></string-name>, <string-name><surname>Gómez Tejeda Zañudo</surname><given-names>J</given-names></string-name>, <string-name><surname>Gan</surname><given-names>X</given-names></string-name></person-group><etal>et al</etal><article-title>Parity and time reversal elucidate both decision-making in empirical models and attractor scaling in critical Boolean networks</article-title>. <source>Sci Adv</source><year>2021</year>;<volume>7</volume>:<fpage>eabf8124</fpage>. <pub-id pub-id-type="doi">10.1126/sciadv.abf8124</pub-id>.<pub-id pub-id-type="pmid">34272246</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Schaub</surname><given-names>MA</given-names></string-name>, <string-name><surname>Henzinger</surname><given-names>TA</given-names></string-name>, <string-name><surname>Fisher</surname><given-names>J.</given-names></string-name></person-group><article-title>Qualitative networks: a symbolic approach to analyze biological signaling networks</article-title>. <source>BMC Syst Biol</source><year>2007</year>;<volume>1</volume>:<fpage>1</fpage>–<lpage>21</lpage>. <pub-id pub-id-type="doi">10.1186/1752-0509-1-4</pub-id>.<pub-id pub-id-type="pmid">17408505</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Schwab</surname><given-names>JD</given-names></string-name>, <string-name><surname>Kühlwein</surname><given-names>SD</given-names></string-name>, <string-name><surname>Ikonomi</surname><given-names>N</given-names></string-name></person-group><etal>et al</etal><article-title>Concepts in Boolean network modeling: what do they all mean?</article-title><source>Comput Struct Biotechnol J</source><year>2020</year>;<volume>18</volume>:<fpage>571</fpage>–<lpage>82</lpage>. <pub-id pub-id-type="doi">10.1016/j.csbj.2020.03.001</pub-id>.<pub-id pub-id-type="pmid">32257043</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sun</surname><given-names>Z</given-names></string-name>, <string-name><surname>Jin</surname><given-names>X</given-names></string-name>, <string-name><surname>Albert</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Multi-level modeling of light-induced stomatal opening offers new insights into its regulation by drought</article-title>. <source>PLoS Comput Biol</source><year>2014</year>;<volume>10</volume>:<fpage>e1003930</fpage>. <pub-id pub-id-type="doi">10.1371/journal.pcbi.1003930</pub-id>.<pub-id pub-id-type="pmid">25393147</pub-id></mixed-citation>
    </ref>
    <ref id="btad262-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Thomas</surname><given-names>R.</given-names></string-name></person-group><article-title>Regulatory networks seen as asynchronous automata: a logical description</article-title>. <source>J Theor Biol</source><year>1991</year>;<volume>153</volume>:<fpage>1</fpage>–<lpage>23</lpage>. <pub-id pub-id-type="doi">10.1016/S0022-5193(05)80350-9</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad262-B33">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Trinh</surname><given-names>V</given-names></string-name>, <string-name><surname>Benhamou</surname><given-names>B</given-names></string-name>, <string-name><surname>Hiraishi</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><part-title>Minimal trap spaces of logical models are maximal siphons of their Petri net encoding</part-title>. In: Petre I, Păun A. (eds.) <source>Computational Methods in Systems Biology</source>. <publisher-loc>Berlin, Germany</publisher-loc>: <publisher-name>Springer</publisher-name>, <year>2022</year>, <fpage>158</fpage>–<lpage>76</lpage>.</mixed-citation>
    </ref>
    <ref id="btad262-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Vita</surname><given-names>M</given-names></string-name>, <string-name><surname>Henriksson</surname><given-names>M.</given-names></string-name></person-group><article-title>The Myc oncoprotein as a therapeutic target for human cancer</article-title>. <source>Semin Cancer Biol</source><year>2006</year>;<volume>16</volume>:<fpage>318</fpage>–<lpage>30</lpage>. <pub-id pub-id-type="doi">10.1016/j.semcancer.2006.07.015</pub-id>.<pub-id pub-id-type="pmid">16934487</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
