<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7355287</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btaa444</article-id>
    <article-id pub-id-type="publisher-id">btaa444</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Comparative and Functional Genomics</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>FastMulRFS: fast and accurate species tree estimation under generic gene duplication and loss models</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Molloy</surname>
          <given-names>Erin K</given-names>
        </name>
        <xref ref-type="corresp" rid="btaa444-cor1"/>
        <xref ref-type="aff" rid="btaa444-aff1"/>
        <!--<email>emolloy2@illinois.edu</email>-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Warnow</surname>
          <given-names>Tandy</given-names>
        </name>
        <xref ref-type="corresp" rid="btaa444-cor1"/>
        <xref ref-type="aff" rid="btaa444-aff1"/>
        <!--<email>warnow@illinois.edu</email>-->
      </contrib>
    </contrib-group>
    <aff id="btaa444-aff1"><institution>Department of Computer Science, University of Illinois at Urbana-Champaign</institution>, Urbana, IL 61801, <country country="US">USA</country></aff>
    <author-notes>
      <corresp id="btaa444-cor1">To whom correspondence should be addressed. E-mail: <email>emolloy2@illinois.edu</email> or <email>warnow@illinois.edu</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>7</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2020-07-13">
      <day>13</day>
      <month>7</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>13</day>
      <month>7</month>
      <year>2020</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>36</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB 2020 Proceedings</issue-title>
    <fpage>i57</fpage>
    <lpage>i65</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2020. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2020</copyright-year>
      <license license-type="cc-by-nc" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btaa444.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Species tree estimation is a basic part of biological research but can be challenging because of gene duplication and loss (GDL), which results in genes that can appear more than once in a given genome. All common approaches in phylogenomic studies either reduce available data or are error-prone, and thus, scalable methods that do not discard data and have high accuracy on large heterogeneous datasets are needed.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We present FastMulRFS, a polynomial-time method for estimating species trees without knowledge of orthology. We prove that FastMulRFS is statistically consistent under a generic model of GDL when adversarial GDL does not occur. Our extensive simulation study shows that FastMulRFS matches the accuracy of MulRF (which tries to solve the same optimization problem) and has better accuracy than prior methods, including ASTRAL-multi (the only method to date that has been proven statistically consistent under GDL), while being much faster than both methods.</p>
      </sec>
      <sec id="s3">
        <title>Availability and impementation</title>
        <p>FastMulRFS is available on Github (<ext-link ext-link-type="uri" xlink:href="https://github.com/ekmolloy/fastmulrfs">https://github.com/ekmolloy/fastmulrfs</ext-link>).</p>
      </sec>
      <sec id="s5">
        <title>Supplementary information</title>
        <p><xref ref-type="supplementary-material" rid="sup1">Supplementary data</xref> are available at <italic>Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Science Foundation</institution>
            <institution-id institution-id-type="DOI">10.13039/100000001</institution-id>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>NSF</institution>
            <institution-id institution-id-type="DOI">10.13039/100000001</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>1535977</award-id>
        <award-id>1513629</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Ira and Debra Cohen Graduate Fellowship in Computer Science</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Illinois Campus Cluster</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Center for Supercomputing Applications</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>NSF</institution>
            <institution-id institution-id-type="DOI">10.13039/100000001</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>0725070</award-id>
        <award-id>1238993</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Species trees are important models that can be used to address many biological questions, for example how is biodiversity created/maintained and how do species adapt to their environments (<xref rid="btaa444-B13" ref-type="bibr">Cracraft <italic>et al.</italic>, 2004</xref>). There is also a vast literature regarding <italic>gene tree reconciliation</italic>, where gene trees are compared to an established species tree in order to understand how genes evolved (for some of the recent literature on this question, see <xref rid="btaa444-B15" ref-type="bibr">Delabre <italic>et al.</italic>, 2020</xref>; <xref rid="btaa444-B16" ref-type="bibr">Dondi <italic>et al.</italic>, 2019</xref>; <xref rid="btaa444-B18" ref-type="bibr">El-Mabrouk and Noutahi, 2019</xref>; <xref rid="btaa444-B24" ref-type="bibr">Hasić and Tannier, 2019</xref>; <xref rid="btaa444-B25" ref-type="bibr">Jacox <italic>et al.</italic>, 2016</xref>; <xref rid="btaa444-B27" ref-type="bibr">Kundu and Bansal, 2018</xref>; <xref rid="btaa444-B29" ref-type="bibr">Lai <italic>et al.</italic>, 2017</xref>; <xref rid="btaa444-B35" ref-type="bibr">Muhammad <italic>et al.</italic>, 2018</xref>). However, in most cases, species trees are not known in advance and instead must be estimated.</p>
    <p>Most species tree estimation methods are designed for orthologous genes, which are genes related through speciation events only and not through duplication events (<xref rid="btaa444-B21" ref-type="bibr">Fitch, 2000</xref>; <xref rid="btaa444-B34" ref-type="bibr">Moreira and Philippe, 2000</xref>). Because orthology prediction is still difficult to do correctly (<xref rid="btaa444-B1" ref-type="bibr">Altenhoff <italic>et al.</italic>, 2019</xref>; <xref rid="btaa444-B28" ref-type="bibr">Lafond <italic>et al.</italic>, 2018</xref>; <xref rid="btaa444-B42" ref-type="bibr">Sousa da Silva <italic>et al.</italic>, 2014</xref>) and mistakes in orthology prediction can result in incorrect species trees, multi-copy genes are often excluded from species tree estimation (e.g. <xref rid="btaa444-B30" ref-type="bibr">Leebens-Mack <italic>et al.</italic>, 2019</xref>; <xref rid="btaa444-B48" ref-type="bibr">Wickett <italic>et al.</italic>, 2014</xref>). Methods that can estimate species trees from gene families are of increasing interest, as this would enable phylogenetic signal to be extracted from multi-copy genes while avoiding the challenges of orthology prediction.</p>
    <p>Several methods have been proposed to infer species trees from multi-copy genes. PHYLDOG (<xref rid="btaa444-B5" ref-type="bibr">Boussau <italic>et al.</italic>, 2013</xref>), perhaps the most well-known method explicitly based on a parametric model of gene duplication and loss (GDL), uses likelihood to co-estimate the species tree and gene family trees (which may contain multiple copies from some species). This is very computationally intensive, so PHYLDOG is limited to very small datasets with 10 or so species. Recently, <xref rid="btaa444-B14" ref-type="bibr">De Oliveira Martins <italic>et al.</italic> (2016)</xref> proposed the Bayesian supertree method, <italic>guenomu</italic>, which requires the posterior distribution to be estimated for each gene family tree, for example using MrBayes (<xref rid="btaa444-B39" ref-type="bibr">Ronquist and Huelsenbeck, 2003</xref>). Thus, <italic>guenomu</italic> is also not fast enough to use on genome-scale datasets with 100 or more species.</p>
    <p>Non-parametric methods are more commonly used alternatives. For example, gene tree parsimony (GTP) methods take a set of (estimated) gene family trees as input, and then seek a species tree that implies the minimum number of evolutionary events, such as gene duplications and gene losses. Examples of GTP methods include DupTree (<xref rid="btaa444-B47" ref-type="bibr">Wehe <italic>et al.</italic>, 2008</xref>), iGTP (<xref rid="btaa444-B9" ref-type="bibr">Chaudhary <italic>et al.</italic>, 2010</xref>) and DynaDup (<xref rid="btaa444-B4" ref-type="bibr">Bayzid and Warnow, 2018</xref>). Since GTP is NP hard, most of these methods operate by using hill climbing. DynaDup, in contrast, uses dynamic programming to find an optimal solution within a constrained search space; this type of approach, to the best of our knowledge, was first proposed in <xref rid="btaa444-B23" ref-type="bibr">Hallett and Lagergren (2000)</xref> and has since been utilized for other problems, including the maximum quartet support supertree problem (<xref rid="btaa444-B6" ref-type="bibr">Bryant and Steel, 2001</xref>; <xref rid="btaa444-B32" ref-type="bibr">Mirarab <italic>et al.</italic>, 2014</xref>) and the Robinson-Foulds Supertree (RFS) problem (<xref rid="btaa444-B45" ref-type="bibr">Vachaspati and Warnow, 2016</xref>). Although GTP methods can be computationally intensive, they are more scalable than other approaches (e.g. PHYLDOG), and several phylogenomic studies have used GTP methods (<xref rid="btaa444-B7" ref-type="bibr">Burleigh <italic>et al.</italic>, 2011</xref>; <xref rid="btaa444-B40" ref-type="bibr">Sanderson and McMahon, 2007</xref>).</p>
    <p>Other fast approaches include supertree methods that have been adapted to work with gene family trees, referred to as <italic>multrees</italic>, as they can have multiple copies from each species. The most well-known supertree method for multrees is perhaps MulRF (<xref rid="btaa444-B12" ref-type="bibr">Chaudhary <italic>et al.</italic>, 2014b</xref>), which attempts to find a solution to the NP-hard Robinson-Foulds Supertree problem for multrees (RFS-multree). Although MulRF does not explicitly account for GDL, it has been shown to produce more accurate species trees than DupTree and iGTP on datasets simulated under challenging model conditions with GDL, incomplete lineage sorting (ILS), horizontal gene transfer and gene tree estimation error (GTEE) (<xref rid="btaa444-B11" ref-type="bibr">Chaudhary <italic>et al.</italic>, 2014a</xref>).</p>
    <p>In a very recent advance, <xref rid="btaa444-B31" ref-type="bibr">Legried <italic>et al.</italic> (2020)</xref> proved that ASTRAL-multi (<xref rid="btaa444-B36" ref-type="bibr">Rabiee <italic>et al.</italic>, 2019</xref>), an extension of ASTRAL (<xref rid="btaa444-B32" ref-type="bibr">Mirarab <italic>et al.</italic>, 2014</xref>) to address multi-allele inputs, is statistically consistent under the standard stochastic model of GDL proposed by <xref rid="btaa444-B2" ref-type="bibr">Arvestad <italic>et al.</italic> (2009)</xref> in which all the genes evolve independently and identically distributed (<italic>i.i.d.</italic>) within a species tree, with duplication and loss rates fixed across the edges of the species tree. In fact, ASTRAL-multi is the only method that has been proven statistically consistent under any GDL model. Yet, a comparison reported by <xref rid="btaa444-B31" ref-type="bibr">Legried <italic>et al.</italic> (2020)</xref> between ASTRAL-multi and three earlier species tree estimation methods, including DupTree, STAG (<xref rid="btaa444-B19" ref-type="bibr">Emms and Kelly, 2018</xref>), and MulRF, showed that ASTRAL-multi had good but not exceptional accuracy; specifically, when the duplication and loss rates were both high, ASTRAL-multi was more accurate than DupTree (except when GTEE was low) and STAG (which often failed to complete), but was less accurate than MulRF.</p>
    <p>The high accuracy of MulRF in comparison to ASTRAL-multi encouraged us to explore the optimization problem that MulRF attempts to solve (RFS-multree), and led to the following advances.
</p>
    <list list-type="bullet">
      <list-item>
        <p>We prove (Theorem 5) that the true species tree is an optimal solution to the NP-hard RFS-multree problem, provided there is no adversarial GDL (which occurs when the pattern of duplication and loss events produces bipartitions that are incompatible with the species tree). This model is less restrictive than the standard GDL model in that it does not assume genes evolve <italic>i.i.d.</italic> (similar to the No Common Mechanism model of <xref rid="btaa444-B43" ref-type="bibr">Tuffley and Steel, 1997</xref>), but is more restrictive in that it prohibits adversarial GDL. However, we conjecture (Conjecture 7) that adversarial GDL will occur with sufficiently low probability so that an exact solution to the RFS-multree problem will be statistically consistent for reasonable duplication and loss probabilities.</p>
      </list-item>
      <list-item>
        <p>We present FastMulRFS, a polynomial-time algorithm that uses dynamic programing to solve the RFS-multree problem exactly within a constrained search space (computed from the input gene family trees), and prove (Theorem 6) that FastMulRFS is statistically consistent under a generic GDL model when no adversarial GDL occurs.</p>
      </list-item>
      <list-item>
        <p>We prove (Theorem 2) that when solving the RFS-multree problem, any input set of multrees can be replaced by a set of smaller trees (with each species labeling at most one leaf), thus reducing memory and running time for methods that attempt to solve the RFS-multree problem.</p>
      </list-item>
      <list-item>
        <p>We evaluate FastMulRFS in comparison to ASTRAL-multi, DupTree and MulRF on 1200 different datasets with 100 species and up to 500 genes, generated under 120 model conditions with varying levels of GDL, ILS and GTEE. We find that FastMulRFS is generally more accurate than DupTree and ASTRAL-multi, and ties for most accurate with MulRF. We also find that FastMulRFS is much faster than MulRF and ASTRAL-multi, and ties for fastest with DupTree. The improvement in performance over ASTRAL-multi is the most important result, as ASTRAL-multi is the only other method to date that has been proven statistically consistent under a stochastic GDL model.</p>
      </list-item>
    </list>
    <p>In summary, FastMulRFS is a new and very fast method for species tree estimation that does not require reliable orthology detection and outperforms the leading alternative methods (even under conditions for which FastMulRFS is not yet established to be statistically consistent).</p>
  </sec>
  <sec>
    <title>2 The RFS-multree problem and FastMulRFS</title>
    <p>We define the RFS-multree and present FastMulRFS, an algorithm that solves this problem exactly within a constrained search space. Later, we prove that FastMulRFS is statistically consistent under a generic model of GDL when no adversarial GDL occurs. We begin with terminology and definitions.</p>
    <sec>
      <title>2.1 Terminology</title>
      <p>A <italic>phylogenetic tree T</italic> is defined by the triplet <inline-formula id="IE1"><mml:math id="IM1"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mo>ϕ</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>t</italic> is its unrooted tree topology, <italic>S</italic> is the label set and <inline-formula id="IE2"><mml:math id="IM2"><mml:mrow><mml:mo>ϕ</mml:mo><mml:mo>:</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>→</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula> is the assignment of labels to the leaves of <italic>t</italic>. If each label is assigned to at most one leaf, then we say that <italic>T</italic> is <italic>singly labeled</italic>, whereas if any label is assigned to two or more leaves, then we say that <italic>T</italic> is <italic>multi-labeled</italic> (equivalently, <italic>T</italic> is a <italic>multree</italic>). The edges that are incident with leaves are referred to as <italic>terminal</italic> (or <italic>trivial</italic>) edges, and the remaining edges are referred to as <italic>internal</italic> (or <italic>non-trivial</italic>) edges.</p>
      <p>Deleting an edge <italic>e</italic> but not its endpoints from <italic>T</italic> produces two subtrees <italic>t<sub>A</sub></italic> and <italic>t<sub>B</sub></italic> that define two label sets: <inline-formula id="IE3"><mml:math id="IM3"><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo>ϕ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>A</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE4"><mml:math id="IM4"><mml:mrow><mml:mi>B</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo>ϕ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>B</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. If no label appears on both sides of <italic>e</italic>, then <italic>A</italic> and <italic>B</italic> are disjoint sets, and the edge <italic>e</italic> induces a bipartition <italic>π<sub>e</sub></italic> on the label set of <italic>T</italic> (i.e. the edge <italic>e</italic> splits the leaf labels into two disjoint sets). However, if some label appears on both sides of <italic>e</italic> then <italic>A</italic> and <italic>B</italic> are not disjoint, and so by definition, the edge <italic>e</italic> does <italic>not</italic> induce a bipartition. We let <italic>C</italic>(<italic>T</italic>) denote the set of bipartitions induced by edges in tree <italic>T</italic>, noting that <italic>not</italic> all edges of <italic>T</italic> will necessarily contribute bipartitions to <italic>C</italic>(<italic>T</italic>), unlike the case of singly-labeled trees.</p>
      <p>A key concept in FastMulRFS is <italic>compatibility</italic>, originally described by <xref rid="btaa444-B20" ref-type="bibr">Estabrook <italic>et al.</italic> (1975)</xref>, which we now define (see also <xref rid="btaa444-B46" ref-type="bibr">Warnow, 2017</xref>). Let <inline-formula id="IE5"><mml:math id="IM5"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> be the true (fully resolved) species tree on <italic>S</italic>, and let <inline-formula id="IE6"><mml:math id="IM6"><mml:mrow><mml:mo>π</mml:mo><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mo>|</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula> be a bipartition on <inline-formula id="IE7"><mml:math id="IM7"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>⊆</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula>. Then π is compatible with <inline-formula id="IE8"><mml:math id="IM8"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> if and only if there is a bipartition <inline-formula id="IE9"><mml:math id="IM9"><mml:mrow><mml:mo>π</mml:mo><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mo>′</mml:mo><mml:mo>|</mml:mo><mml:mi>B</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> so that <inline-formula id="IE10"><mml:math id="IM10"><mml:mrow><mml:mi>A</mml:mi><mml:mo>⊆</mml:mo><mml:mi>A</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE11"><mml:math id="IM11"><mml:mrow><mml:mi>B</mml:mi><mml:mo>⊆</mml:mo><mml:mi>B</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. Equivalently, bipartition π on label set <inline-formula id="IE12"><mml:math id="IM12"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>⊆</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula> is compatible with <inline-formula id="IE13"><mml:math id="IM13"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> if there exists <inline-formula id="IE14"><mml:math id="IM14"><mml:mrow><mml:mo>π</mml:mo><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE15"><mml:math id="IM15"><mml:mrow><mml:mo>π</mml:mo><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> is identical to π when restricted to label set <italic>S</italic><sub>0</sub>. Similarly, a tree <italic>T</italic> on label set <italic>S</italic><sub>0</sub> is compatible with the species tree <inline-formula id="IE16"><mml:math id="IM16"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> if every bipartition in <italic>T</italic> is compatible with <inline-formula id="IE17"><mml:math id="IM17"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>2.2 Robinson-Foulds supertree problem for multrees</title>
      <p>The RF distance (<xref rid="btaa444-B38" ref-type="bibr">Robinson and Foulds, 1981</xref>) between two singly-labeled trees on the same label set has a simple definition as the bipartition distance (i.e. number of bipartitions in one but not in both trees). Now suppose <italic>T</italic> and <inline-formula id="IE18"><mml:math id="IM18"><mml:mrow><mml:mi>T</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> are singly-labeled trees on label sets <italic>S</italic> and <inline-formula id="IE19"><mml:math id="IM19"><mml:mrow><mml:mi>R</mml:mi><mml:mo>⊆</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula>, respectively. Then the <italic>RF distance</italic> between <italic>T</italic> and <inline-formula id="IE20"><mml:math id="IM20"><mml:mrow><mml:mi>T</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> can be computed as
<disp-formula id="E1"><label>(1)</label><mml:math id="M1"><mml:mrow><mml:mi>R</mml:mi><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mi>R</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>△</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="E2"><label>(2)</label><mml:math id="M2"><mml:mrow><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>R</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mi>R</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE21"><mml:math id="IM21"><mml:mrow><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mi>R</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> denotes <italic>T</italic> restricted to leaves with labels in set <italic>R</italic> (after suppressing internal nodes with degree 2). When one or both trees is a multree, then the RF distance has an alternative definition (which is equal to the standard definition when both trees are singly labeled and on the same label set): the edit distance under contraction-and-refinement operations, where a contraction is collapsing a single edge, and a refinement is inserting a single edge to decrease the degree of a polytomy (i.e. node of degree four or more). When both trees are multrees, computing the RF distance is NP-complete (<xref rid="btaa444-B10" ref-type="bibr">Chaudhary <italic>et al.</italic>, 2013</xref>). However, <xref rid="btaa444-B10" ref-type="bibr">Chaudhary <italic>et al.</italic> (2013)</xref> proved that the RF distance between a multree and a singly-labeled tree can be computed in polynomial time as follows: (i) extend <italic>T</italic> with respect to <italic>M</italic>, denoted <italic>Ext</italic>(<italic>T</italic>, <italic>M</italic>) (<xref ref-type="fig" rid="btaa444-F1">Fig. 1</xref>), (ii) relabel the leaves of <italic>M</italic> and <italic>Ext</italic>(<italic>T</italic>, <italic>M</italic>) in a <italic>mutually consistent fashion</italic> so that both trees are singly labeled and (iii) compute the RF distance using <xref ref-type="disp-formula" rid="E1">Equation (1)</xref> between the relabeled versions of <italic>Ext</italic>(<italic>T</italic>, <italic>M</italic>) and <italic>M</italic>, denoted <inline-formula id="IE22"><mml:math id="IM22"><mml:mrow><mml:mi mathvariant="italic">Ext</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE23"><mml:math id="IM23"><mml:mrow><mml:mi>M</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>, respectively; see Appendix for additional details.
</p>
      <fig id="btaa444-F1" orientation="portrait" position="float">
        <label>Fig. 1.</label>
        <caption>
          <p>Reduction of the RFS-multree problem to the Robinson-Foulds Supertree (RFS) problem. To compute the RF distance between a singly-labeled tree <italic>T</italic> (<bold>a</bold>; bottom left) and a multree <italic>M</italic> (<bold>b</bold>; top left), we replace <italic>M</italic> by a smaller singly-labeled tree <inline-formula id="IE24"><mml:math id="IM24"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (<bold>e</bold>; bottom center). We then compute the RF distance between <italic>T</italic> and <inline-formula id="IE25"><mml:math id="IM25"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> using <xref ref-type="disp-formula" rid="E1">Equation (1)</xref>. Here we explain why this works. Suppose that <italic>T</italic> (a) is a candidate singly-labeled, binary supertree for a set <inline-formula id="IE26"><mml:math id="IM26"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula> of multrees and that <italic>M</italic> (b) is one of the multrees in <inline-formula id="IE27"><mml:math id="IM27"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula>. To compute the RF distance between <italic>T</italic> and <italic>M</italic>, we extend <italic>T</italic> with respect to <italic>M</italic>, producing <italic>Ext</italic>(<italic>T</italic>, <italic>M</italic>) (<bold>c</bold>). Note that <italic>Ext</italic>(<italic>T</italic>, <italic>M</italic>) has the same non-trivial edges (shown in blue) and the same trivial edges (shown in orange) as <italic>T</italic>, and for every leaf label (species), it has the same number of leaves with that label as multree <italic>M</italic>. The trivial edges in <italic>Ext</italic>(<italic>T</italic>, <italic>M</italic>) exist in <italic>any possible</italic> singly-labeled, binary tree on <italic>S</italic>; thus, these edges do not impact the solution to the RFS-multree problem. Similarly, multree <italic>M</italic> has edges (shown in red) that will be incompatible with an extended version of <italic>any possible</italic> singly labeled, binary tree on <italic>S</italic>; thus, these edges do not impact the solution to the RFS-multree problem. An edge is incompatible with every possible singly-labeled supertree if and only if it fails to induce a bipartition (i.e. deleting an edge <italic>e</italic> splits the leaf labels into two non-disjoint sets). Thus, we collapse all internal edges in <italic>M</italic> that fail to induce a bipartition, producing <inline-formula id="IE28"><mml:math id="IM28"><mml:mrow><mml:mi mathvariant="script">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (<bold>d</bold>). Furthermore, because all leaves with the same label are now on the same side of <italic>every</italic> bipartition in <inline-formula id="IE29"><mml:math id="IM29"><mml:mrow><mml:mi mathvariant="script">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we can delete all but one leaf with each label, producing <inline-formula id="IE30"><mml:math id="IM30"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (<bold>e</bold>). The resulting tree is a non-binary, singly-labeled tree on <italic>S</italic>, so we can compute the RF distance between <italic>T</italic> and <inline-formula id="IE31"><mml:math id="IM31"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> using <xref ref-type="disp-formula" rid="E1">Equation (1)</xref> when searching for the solution to the RFS-multree problem. These observations are formalized in Lemma 13 (Appendix), and it follows that an RFS-multree supertree for <inline-formula id="IE32"><mml:math id="IM32"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula> is an RF supertree for <inline-formula id="IE33"><mml:math id="IM33"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, as summarized in Theorem 2</p>
        </caption>
        <graphic xlink:href="btaa444f1"/>
      </fig>
      <p><xref rid="btaa444-B10" ref-type="bibr">Chaudhary <italic>et al.</italic> (2013)</xref> then proposed the <italic>RFS-multree</italic>. The input is a set <inline-formula id="IE34"><mml:math id="IM34"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula> of multrees with leaves labeled by elements of the set <italic>S</italic>, and the output is a binary (i.e. fully resolved) tree <italic>T</italic> bijectively labeled by <italic>S</italic> that minimizes
<disp-formula id="E3"><label>(3)</label><mml:math id="M3"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:munder><mml:mi>R</mml:mi><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">Ext</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Any tree that minimizes this score is called an <bold>RFS-multree supertree</bold> for <inline-formula id="IE35"><mml:math id="IM35"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula>. Finally, when <inline-formula id="IE36"><mml:math id="IM36"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula> is a profile of singly-labeled trees, then the RFS-multree problem is the well-known RFS problem (<xref rid="btaa444-B3" ref-type="bibr">Bansal <italic>et al.</italic>, 2010</xref>; <xref rid="btaa444-B45" ref-type="bibr">Vachaspati and Warnow, 2016</xref>).</p>
    </sec>
    <sec>
      <title>2.3 Reducing from multrees to singly-labeled trees</title>
      <p>We simplify the RFS-multree problem by providing an alternative proof that the RF distance between a singly-labeled tree <italic>T</italic> and a multree <italic>M</italic> and can be computed in polynomial time (Lemma 13 in Appendix). We summarize the intuition behind this lemma in <xref ref-type="fig" rid="btaa444-F1">Figure 1</xref>, which leads easily to Theorem 2.<statement id="mthst1"><label>Definition 1.</label><p><italic>Given a multree</italic> <inline-formula id="IE37"><mml:math id="IM37"><mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:math></inline-formula><italic>, we collapse internal edges with some species labeling leaves on both sides of the edge, denoting the result</italic> <inline-formula id="IE38"><mml:math id="IM38"><mml:mrow><mml:mi mathvariant="script">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>. We then delete all but one leaf with each species label, denoting the result</italic> <inline-formula id="IE39"><mml:math id="IM39"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>. We define</italic> <inline-formula id="IE40"><mml:math id="IM40"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p></statement><statement id="mthst2"><label>Theorem 2.</label><p><italic>Let T be a singly-labeled, binary tree on label set S, and let</italic> <inline-formula id="IE41"><mml:math id="IM41"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula><italic>be a set of multrees. Then, T is an RFS-multree supertree for</italic> <inline-formula id="IE42"><mml:math id="IM42"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula><italic>if and only if T is a RF supertree for</italic> <inline-formula id="IE43"><mml:math id="IM43"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic>. Equivalently, T is an RFS-multree supertree for</italic> <inline-formula id="IE44"><mml:math id="IM44"><mml:mrow><mml:mi mathvariant="script">P</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula><italic>(with multree M<sub>i</sub> on label set</italic> <inline-formula id="IE45"><mml:math id="IM45"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>⊆</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula><italic>) if and only if T is a binary tree that maximizes</italic> <inline-formula id="IE46"><mml:math id="IM46"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p></statement></p>
    </sec>
    <sec>
      <title>2.4 FastMulRFS</title>
      <p>A consequence of Theorem 2 is that any heuristic for the RFS problem can be used for the RFS-multree problem simply by computing <inline-formula id="IE47"><mml:math id="IM47"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (i.e. by transforming the input multrees into singly-labeled trees) and then running the heuristic on <inline-formula id="IE48"><mml:math id="IM48"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. In this study, we explore the impact of using FastRFS (<xref rid="btaa444-B45" ref-type="bibr">Vachaspati and Warnow, 2016</xref>), an effective heuristic for the RFS problem, and we refer to this two-phase approach as <bold>FastMulRFS</bold>.</p>
      <p>The input to FastRFS is a profile <inline-formula id="IE49"><mml:math id="IM49"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> of singly-labeled trees, each on a (possibly proper) subset of <italic>S</italic> and a set Σ of allowed bipartitions on <italic>S</italic>; FastRFS provably returns a (binary) supertree <italic>T</italic> that minimizes the total RF distance to the trees in <inline-formula id="IE50"><mml:math id="IM50"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> subject to <inline-formula id="IE51"><mml:math id="IM51"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:mo>Σ</mml:mo></mml:mrow></mml:math></inline-formula>. FastRFS uses dynamic programing to solve the constrained optimization problem in <inline-formula id="IE52"><mml:math id="IM52"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>k</mml:mi><mml:mo>|</mml:mo><mml:mo>Σ</mml:mo><mml:msup><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time, where <inline-formula id="IE53"><mml:math id="IM53"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE54"><mml:math id="IM54"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. As we will show, Σ can be defined from the input multrees so that FastMulRFS runs in polynomial time and is statistically consistent under a generic GDL model when no adversarial GDL occurs.</p>
      <p>We now describe FastMulRFS, which takes a profile <inline-formula id="IE55"><mml:math id="IM55"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula> of multrees, each on a (possibly proper) subset of the species set <italic>S</italic>.
</p>
      <list list-type="bullet">
        <list-item>
          <p><bold>Step 1:</bold> We construct <inline-formula id="IE56"><mml:math id="IM56"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> from <inline-formula id="IE57"><mml:math id="IM57"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula> by collapsing all internal edges that have species labeling leaves on both sides of the edge and then deleting all but one of the multiple copies of any species. Thus, <inline-formula id="IE58"><mml:math id="IM58"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is a set of potentially unresolved single-copy gene trees. In the <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref> (Algorithm 1), we show how to compute the set <inline-formula id="IE59"><mml:math id="IM59"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> from <inline-formula id="IE60"><mml:math id="IM60"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula> in <italic>O</italic>(<italic>mnk</italic>) time, where <inline-formula id="IE61"><mml:math id="IM61"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, and <italic>m</italic> is the largest number of leaves in any multree in <inline-formula id="IE62"><mml:math id="IM62"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula>.</p>
        </list-item>
        <list-item>
          <p><bold>Step 2:</bold> We run ASTRAL given the set <inline-formula id="IE63"><mml:math id="IM63"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of single-copy gene trees to produce the set Σ of allowed bipartitions. The <italic>default</italic> technique for constructing Σ uses every bipartition in every single-copy gene tree on the <italic>complete</italic> label set <italic>S</italic>. In this case, it is easy to see that <inline-formula id="IE64"><mml:math id="IM64"><mml:mrow><mml:mo>|</mml:mo><mml:mo>Σ</mml:mo><mml:mo>|</mml:mo><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo>}</mml:mo><mml:mo>|</mml:mo><mml:mo>≤</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. Additional bipartitions may be included to guarantee that at least one fully resolved tree <italic>T</italic> satisfies <inline-formula id="IE65"><mml:math id="IM65"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:mo>Σ</mml:mo></mml:mrow></mml:math></inline-formula> and to improve accuracy (by expanding the space of allowed solutions); however, ASTRAL-III (<xref rid="btaa444-B49" ref-type="bibr">Zhang <italic>et al.</italic>, 2018</xref>) enforces <inline-formula id="IE66"><mml:math id="IM66"><mml:mrow><mml:mo>|</mml:mo><mml:mo>Σ</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. While the total running time of ASTRAL-III is <inline-formula id="IE67"><mml:math id="IM67"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>k</mml:mi><mml:mo>|</mml:mo><mml:mo>Σ</mml:mo><mml:msup><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mn>1.726</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we run ASTRAL-III to construct Σ and then exit.</p>
        </list-item>
        <list-item>
          <p><bold>Step 3:</bold> We run FastRFS on the pair <inline-formula id="IE68"><mml:math id="IM68"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>Σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        </list-item>
      </list>
      <p>In summary, FastMulRFS runs in <inline-formula id="IE69"><mml:math id="IM69"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">mnk</mml:mi><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mi>k</mml:mi><mml:mo>|</mml:mo><mml:mo>Σ</mml:mo><mml:msup><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time, where <italic>n</italic> is the number of species, <italic>k</italic> is the number of multrees and <italic>m</italic> is the largest number of leaves in any of the multrees. The default technique for constructing the set Σ of allowed bipartitions enforces <inline-formula id="IE70"><mml:math id="IM70"><mml:mrow><mml:mo>|</mml:mo><mml:mo>Σ</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and, as we will show in the next section, suffices for proofs of statistical consistency under some generic GDL models.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Species tree estimation using FastMulRFS</title>
    <p><italic>Generic GDL models.</italic> Our generic GDL models are similar to the No Common Mechanism models described in <xref rid="btaa444-B43" ref-type="bibr">Tuffley and Steel (1997)</xref>, in that there is a common rooted binary model species tree, but each gene evolves down the tree with its own duplication and loss parameters. We make natural assumptions that every gene has duplication probability and loss probability strictly &lt;1 on every edge, and note these probabilities can depend on the gene and on the edge. Thus, our generic models contain the GDL models of <xref rid="btaa444-B2" ref-type="bibr">Arvestad <italic>et al.</italic> (2009)</xref> as sub-models.</p>
    <p><italic>Adversarial GDL.</italic> We define adversarial GDL to be when the gene evolution process produces a gene family tree with a bipartition π that is not compatible with the true species tree <inline-formula id="IE71"><mml:math id="IM71"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> (see Section 2.1 for the definition of compatibility). Adversarial GDL requires a sequence of events (a duplication followed by a carefully selected set of losses) that coordinate to produce such a bipartition. <xref ref-type="fig" rid="btaa444-F2">Figure 2d</xref> illustrates a scenario that produces adversarial GDL: the gene duplicates on the edge above <italic>Y</italic> in the species tree (shown in <xref ref-type="fig" rid="btaa444-F2">Fig. 2a</xref>), so that <italic>Y</italic> has two copies of the gene. Then the first copy of the gene is lost on the edge above <italic>B</italic>, whereas the second copy of the gene is lost on the edge above <italic>A</italic> and the edge above <italic>C</italic>. As a result, the gene family tree shown in <xref ref-type="fig" rid="btaa444-F2">Figure 2d</xref> is singly labeled, but the gene family tree induces a bipartition (<inline-formula id="IE72"><mml:math id="IM72"><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>|</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi></mml:mrow></mml:math></inline-formula>) that is incompatible with the species tree; by definition, this is adversarial GDL. Alternatively, suppose the first copy of the gene had been lost on the edge above <italic>A</italic> and on the edge above (<italic>B</italic>, <italic>C</italic>), then not only is there no adversarial GDL, but also the gene family tree induces a bipartition (<inline-formula id="IE73"><mml:math id="IM73"><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo>|</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula>) that is compatible with the species tree.
</p>
    <fig id="btaa444-F2" orientation="portrait" position="float">
      <label>Fig. 2.</label>
      <caption>
        <p>Impact of gene duplications and losses (GDL) on species tree estimation using RFS-multree methods. (<bold>a</bold>) Shows a species tree and (<bold>b</bold>) through (<bold>d</bold>) show three gene family trees that evolved within the species tree. (b) Shows gene family tree with a duplication event in species <italic>Y</italic> (i.e. the most recent common ancestor of species <italic>A</italic>, <italic>B</italic> and <italic>C</italic>). All edges below the duplication (shown in red) fail to induce bipartitions and so will be contracted, and will therefore not impact the solution space for the RFS-multree criterion. (c) Shows gene tree with a duplication event in species <italic>Y</italic> followed by the first copy of the gene being lost from species <italic>B</italic> and the second copy of the gene being lost from species <italic>C</italic>. Because one of the species that evolved from <italic>Y</italic> retains both copies of the gene, the non-trivial edges below the duplication node fail to induce bipartitions, and so these edges also do not impact the solution space for RFS-multree. (d) Shows gene family tree with a duplication event in species <italic>Y</italic> followed by the first copy of the gene being lost from species <italic>B</italic> and the second copy of the gene being lost from both species <italic>A</italic> and <italic>C</italic>. None of the species that evolved from <italic>Y</italic> retain both copies of the gene, so all edges below the duplication node induce bipartitions <italic>and hence will not be contracted</italic>; we refer to this situation as ‘adversarial GDL, because it produces bipartitions in the singly-labeled trees in <inline-formula id="IE74"><mml:math id="IM74"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> that conflict with the species tree (shown in blue). Such a scenario leads to the possibility that the true species tree may not be an optimal solution to the RFS-multree problem</p>
      </caption>
      <graphic xlink:href="btaa444f2"/>
    </fig>
    <p>Another interesting case to consider is when the gene duplicates on the edge above <italic>Y</italic>, and then the first copy is lost on the edge above <italic>B</italic> and the second copy is lost on the edge above <italic>C</italic>. As a result, the gene family tree shown in <xref ref-type="fig" rid="btaa444-F2">Figure 2c</xref> does not induce any bipartitions. Now suppose <italic>A</italic>, <italic>B</italic> and <italic>C</italic> were clades (rather than leaves), then every edge in the two <italic>A</italic> clades (and the edges connecting the two <italic>A</italic> clades) would fail to induce a bipartition (assuming no other loss events). In contrast, every edge in the <italic>B</italic> clade and the <italic>C</italic> clade would induce a bipartition compatible with the species tree (assuming no other duplication events). In some sense, duplication events hide bipartitions, while losses (following a duplication event) can reveal bipartitions. A carefully selected pattern of losses (after the duplication) can result in adversarial GDL (i.e. a particular bipartition π that is not in the species tree), but small changes to that pattern may well produce bipartitions that are in the true species tree or are incompatible with π. Thus, overall, while adversarial GDL may occur, it may not have high impact on tree estimation based on the RFS-multree criterion.</p>
    <p>In this section, we will discuss model conditions under which adversarial GDL cannot occur: the <italic>duplication-only</italic> case, where all genes evolve with duplication but no loss, and the <italic>loss-only</italic> case, where all genes evolve with loss but no duplication. To prove that a model condition prohibits adversarial GDL, we need to establish that any bipartition that appears in a gene family tree is compatible with the species tree; equivalently, if it appears <italic>in full</italic> in any gene family tree then it must also appear in the species tree, while any incomplete bipartition that appears in any gene family tree can be extended (by adding the missing species) to become a bipartition that is in the species tree. It is trivial to see that if a gene evolves only with losses, then there is no adversarial GDL for that gene (Lemma 3), but the proof for duplication-only evolution is more interesting (Lemma 4).<statement id="mthst3"><label>Lemma 3.</label><p><italic>Let</italic> <inline-formula id="IE75"><mml:math id="IM75"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula><italic>be a set of true gene trees that evolved within the rooted species tree</italic> <inline-formula id="IE76"><mml:math id="IM76"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula><italic>under a stochastic loss-only model of gene evolution. Then for</italic> <inline-formula id="IE77"><mml:math id="IM77"><mml:mrow><mml:mo>π</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula><italic>, π is compatible with</italic> <inline-formula id="IE78"><mml:math id="IM78"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula><italic>. Hence, loss-only models have no adversarial GDL.</italic></p></statement><statement id="mthst4"><label>Lemma 4.</label><p><italic>Let</italic> <inline-formula id="IE79"><mml:math id="IM79"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula><italic>be the set of true gene trees that evolved within the rooted species tree</italic> <inline-formula id="IE80"><mml:math id="IM80"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula><italic>under a stochastic duplication-only model of gene evolution. Then for every multree</italic> <inline-formula id="IE81"><mml:math id="IM81"><mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">P</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>. Equivalently, for any</italic> <inline-formula id="IE82"><mml:math id="IM82"><mml:mrow><mml:mi>M</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:math></inline-formula><italic>, every edge e in M<sub>X</sub> (Definition 1) defines a bipartition π<sub>e</sub> in</italic> <inline-formula id="IE83"><mml:math id="IM83"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>. Hence, duplication-only models have no adversarial GDL.</italic></p></statement><statement id="mthst5"><label>Proof.</label><p>Let <italic>M</italic> be an unrooted gene family tree, and let <italic>e</italic> be an internal edge in <italic>E</italic>(<italic>M</italic>). We will show that an internal edge <italic>e</italic> is collapsed in producing <inline-formula id="IE84"><mml:math id="IM84"><mml:mrow><mml:mi mathvariant="script">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> if and only if <italic>e</italic> lies below at least one duplication node in the rooted version of <italic>M</italic>. Hence, the singly-labeled tree <inline-formula id="IE85"><mml:math id="IM85"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> will only retain the edges in <italic>M</italic> that have no duplication nodes above them in the rooted version of <italic>M</italic>. To see why, consider any edge <italic>e</italic> that has no duplication node above it in the rooted gene family tree: no species appears on both sides of <italic>e</italic> and hence <italic>e</italic> will not be collapsed. Conversely, if internal edge <italic>e</italic> is collapsed, then there must be at least one species on both sides of <italic>e</italic>, and so <italic>e</italic> must be below at least one duplication node in the true rooted gene family tree. Finally, consider a bipartition defined by an edge that is not collapsed, and hence has no duplication nodes above it. This bipartition appears in the true species tree <inline-formula id="IE86"><mml:math id="IM86"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, since the only events that cause the gene family tree to differ from the true species tree are duplications. □</p><p>We now prove that FastMulRFS is statistically consistent under generic GDL models if no adversarial GDL occurs.</p></statement><statement id="mthst6"><label>Theorem 5.</label><p><italic>The true species tree</italic> <inline-formula id="IE87"><mml:math id="IM87"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula><italic>is an RFS-multree supertree for any input</italic> <inline-formula id="IE88"><mml:math id="IM88"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula><italic>for which no adversarial GDL occurred.</italic></p></statement><statement id="mthst7"><label>Proof.</label><p>The optimization problem seeks a binary tree <italic>T</italic> that minimizes the sum of the RF distances to the input multrees; this is equivalent to maximizing the sum of the number of compatible bipartitions in the input multrees. If no adversarial GDL occurs, then by definition, every bipartition in the input multrees is compatible with the true species tree <inline-formula id="IE89"><mml:math id="IM89"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, and so <inline-formula id="IE90"><mml:math id="IM90"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is an optimal solution to the RFS-multree problem. □</p></statement><statement id="mthst8"><label>Theorem 6.</label><p>FastMulRFS is statistically consistent under any GDL model for which adversarial GDL is prohibited.</p></statement><statement id="mthst9"><label>Proof.</label><p>Let <inline-formula id="IE91"><mml:math id="IM91"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> be the true species tree. By Theorem 5, <inline-formula id="IE92"><mml:math id="IM92"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is an optimal solution to the RFS-multree problem for any input <inline-formula id="IE93"><mml:math id="IM93"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula> for which no adversarial GDL occurred. Since our generic GDL models assume that the probability of no duplication or loss occurring on an edge is always strictly positive for every gene, the true species tree has strictly positive probability of appearing in the set <inline-formula id="IE94"><mml:math id="IM94"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula> of gene family trees. Therefore, as the number of genes increases, Σ (as constructed by the default setting within FastMulRFS) will converge to <inline-formula id="IE95"><mml:math id="IM95"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with probability converging to 1, and <inline-formula id="IE96"><mml:math id="IM96"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> will be the unique tree that is optimal under the RFS-multree problem for input <inline-formula id="IE97"><mml:math id="IM97"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula>. FastMulRFS finds an optimal solution to RFS-multree problem subject to the tree <italic>T</italic> it returns satisfying <inline-formula id="IE98"><mml:math id="IM98"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:mo>Σ</mml:mo></mml:mrow></mml:math></inline-formula>, by Theorems 2 and 3 in <xref rid="btaa444-B45" ref-type="bibr">Vachaspati and Warnow (2016)</xref>. Since Σ converges to <inline-formula id="IE99"><mml:math id="IM99"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as the number of genes increases, the probability that FastMulRFS will return <inline-formula id="IE100"><mml:math id="IM100"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> converges to 1. □</p><p>We finish this section with a conjecture.</p><p>Conjecture 7. <italic>FastMulRFS is statistically consistent under a generic model of GDL for probabilities of GDL, so that adversarial GDL has sufficiently low probability.</italic></p></statement></p>
  </sec>
  <sec>
    <title>4 Experimental study</title>
    <sec>
      <title>4.1 Materials and Methods</title>
      <p>We evaluated FastMulRFS in comparison to ASTRAL-multi, DupTree and MulRF on biological and simulated datasets, considering species tree topological accuracy and running time. All simulated datasets are available on the Illinois Data Bank (<ext-link ext-link-type="doi" xlink:href="10.13012/B2IDB-5721322_V1">https://doi.org/10.13012/B2IDB-5721322_V1</ext-link>), and the commands necessary to reproduce this study are provided in the <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref>.</p>
      <p><italic>Biological dataset</italic>. We analyzed a fungal dataset with 16 species and 5351 genes from <xref rid="btaa444-B37" ref-type="bibr">Rasmussen and Kellis (2012)</xref>, who provided gene family trees estimated from their nucleotide alignments. In a prior study, <xref rid="btaa444-B8" ref-type="bibr">Butler <italic>et al.</italic> (2009)</xref> estimated species trees from this same dataset (specifically the concatenated amino acid alignment of putatively orthologous sequences) using MrBayes (<xref rid="btaa444-B39" ref-type="bibr">Ronquist and Huelsenbeck, 2003</xref>), constrained to enforce the out-grouping of <italic>S. castellii</italic> with respect to <italic>S. cerevisiae</italic> and <italic>C. glabrata</italic>. The other reported trees differed with respect to this group (i.e. not all analyses returned this as a clade) and differed in the placement of <italic>K. waltii</italic>. According to their study, none of these resolutions are clearly correct.</p>
      <p><italic>Simulation study.</italic> We generated a collection of 100-species datasets (each with 1000 model gene trees) under the DLCoal model (<xref rid="btaa444-B37" ref-type="bibr">Rasmussen and Kellis, 2012</xref>), which is a unified model of GDL and ILS. The easiest model condition was based on parameters estimated from the 16-species fungal dataset (<xref rid="btaa444-B17" ref-type="bibr">Du <italic>et al.</italic>, 2019</xref>; <xref rid="btaa444-B37" ref-type="bibr">Rasmussen and Kellis, 2012</xref>), and then we increased the GDL rates and ILS levels (by increasing population size) to make more challenging model conditions. We used RAxML (<xref rid="btaa444-B41" ref-type="bibr">Stamatakis, 2014</xref>) to estimate gene trees under the GTR + Γ model from the simulated alignments, with sequence lengths varied to produce four different levels of GTEE. Finally, we estimated species tree giving methods the first 25, 50, 100 and 500 gene family trees, either true or estimated, as input. This created 120 model conditions (3 GDL rates, 2 levels of ILS, 5 levels of GTEE and 4 numbers of genes), each with 10 replicates, for a total of 1200 datasets. Importantly, none of the model conditions prohibits adversarial GDL, allowing us to explore method performance when adversarial GDL may occur.</p>
      <p><italic>Evaluation criteria.</italic> On the fungal biological dataset, we evaluated accuracy with respect to established evolutionary relationships, and on the simulated datasets, we quantified error using the RF error rate, with respect to the true (model) species tree. We also recorded empirical running time; however, it should be noted that all experiments were performed on the Campus Cluster at the University of Illinois at Urbana-Champaign, which is a heterogeneous system (i.e. compute nodes do not have the same specifications; see here: <ext-link ext-link-type="uri" xlink:href="https://campuscluster.illinois.edu/resources/docs/nodes/">https://campuscluster.illinois.edu/resources/docs/nodes/</ext-link>).</p>
    </sec>
    <sec>
      <title>4.2 Results</title>
      <p><italic>Results on biological dataset.</italic> We analyzed the fungal dataset using ASTRAL-multi, FastMulRFS, DupTree and MulRF. All produced trees that are very similar to the MrBayes concatenation tree (<xref ref-type="supplementary-material" rid="sup1">Supplementary Fig. S1</xref>), and the differences are minor given (i) the variability in the trees found by <xref rid="btaa444-B8" ref-type="bibr">Butler <italic>et al.</italic> (2009)</xref>, (ii) the use of a topological constraint in their MrBayes analysis and (iii) the uncertainty about the placement of specific taxa in the tree. For further information on these analyses, see Section 5 in the Supplementary Information from <xref rid="btaa444-B8" ref-type="bibr">Butler <italic>et al.</italic> (2009)</xref>.</p>
      <p>Given that the topological differences are minor, we report the running time differences. FastMulRFS and DupTree completed in under a minute each, ASTRAL-multi completed in 18 min, and MulRF completed in 40 min. Hence, FastMulRFS is much faster than MulRF and ASTRAL-multi. While all four of these methods are relatively fast on 16 taxa, we expect the difference between methods to increase on datasets with larger numbers of species and higher rates of gene duplication. The improvement in running time over MulRF and ASTRAL-multi is due in part to the fact that both MulRF and ASTRAL-multi use the original gene family trees, while FastMulRFS uses the reduced singly-labeled trees; hence, as the number of leaves or the duplication rate increase, the advantage in running time for FastMulRFS should also increase.</p>
      <p><italic>Results on the simulated datasets.</italic> DupTree had poorer accuracy than the other tested methods (Section 4.1 in <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref>). Hence, we focus on comparing MulRF, FastMulRFS and ASTRAL-multi. The fastest method was FastMulRFS, MulRF was the slowest and ASTRAL-multi was intermediate. All methods improved in accuracy with larger numbers of genes and degraded in accuracy with higher GTEE levels, ILS levels and/or GDL rates. The relative accuracy between methods was consistent across all model conditions, although the degree of difference depended on the model conditions, with bigger differences for smaller numbers of genes and higher GTEE levels, ILS levels and GDL rates. When given 500 gene trees, error levels were low and differences between methods were (usually) small, so that the main difference was running time. We present results in <xref ref-type="fig" rid="btaa444-F3">Figure 3</xref> for MulRF, FastMulRFS and ASTRAL-multi under the highest GDL rate, the highest level of ILS and the second highest level of GTEE (about 53%). We note that high GTEE (such as in this setting) is consistent with the generally low bootstrap branch support values reported for several phylogenomic datasets (e.g. about 25% for exon and 45% for intron datasets from <xref rid="btaa444-B26" ref-type="bibr">Jarvis <italic>et al.</italic>, 2014</xref>; also see Table 1 in <xref rid="btaa444-B33" ref-type="bibr">Molloy and Warnow, 2018</xref>). See <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref> for additional results.
</p>
      <fig id="btaa444-F3" orientation="portrait" position="float">
        <label>Fig. 3.</label>
        <caption>
          <p>Species tree error rate (i.e. RF error rate) and running time (s) are shown for FastMulRFS, MulRF and ASTRAL-multi under the most challenging model conditions with 100 species. All datasets have the second highest GTEE level (moderate GTEE: 52%), the highest ILS level (low/moderate ILS: 12%) and the highest GDL rate (D/L rate: <inline-formula id="IE101"><mml:math id="IM101"><mml:mrow><mml:mn>5</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>7</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>). Red dots (first row) and bars (second row) are means for 10 replicate datasets</p>
        </caption>
        <graphic xlink:href="btaa444f3"/>
      </fig>
      <p><italic>FastMulRFS versus MulRF.</italic> Both try to solve the RFS-multree problem but use different approaches; they were essentially tied for accuracy across all tested conditions, but FastMulRFS was dramatically faster (<xref ref-type="fig" rid="btaa444-F3">Fig. 3</xref>; <xref ref-type="supplementary-material" rid="sup1">Supplementary Tables S3 and S4</xref>). In addition, FastMulRFS nearly always returned trees with better RFS-multree scores than MulRF (Section 4.2 in <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref>).</p>
      <p><italic>FastMulRFS versus ASTRAL-multi.</italic><xref ref-type="fig" rid="btaa444-F3">Figure 3</xref> shows results for the second highest GTEE level, where FastMulRFS was much more accurate than ASTRAL-multi for all numbers of genes. FastMulRFS was always at least as accurate as ASTRAL-multi (often more accurate) across the other model conditions (<xref ref-type="supplementary-material" rid="sup1">Supplementary Table S3</xref>), with larger differences between methods for the higher GTEE condition and smaller differences for the lower GTEE conditions. The running times for ASTRAL-multi and FastMulRFS increased with the number of genes, but FastMulRFS was always much faster (<xref ref-type="fig" rid="btaa444-F3">Fig. 3</xref>, <xref ref-type="supplementary-material" rid="sup1">Supplementary Table S4</xref>). For example, on the 500-gene model conditions, FastMulRFS typically completed in 1–2 min (and always in under 5 min), but ASTRAL-multi used between 10 min and 1.2 h.</p>
    </sec>
  </sec>
  <sec>
    <title>5 Discussion</title>
    <p>To date, only two methods have been proven statistically consistent under any GDL model—ASTRAL-multi and FastMulRFS—but the conditions under which these two methods have been proven statistically consistent are different. ASTRAL-multi is established consistent under a gene evolution model that allows both gene duplication and loss to occur for each gene, but requires that all the genes evolve <italic>i.i.d.</italic> In contrast, FastMulRFS has been proven consistent under a generic model that does not require the genes to evolve <italic>i.i.d.</italic> (and indeed allows for a very broad no-common-mechanism model); this is a relative strength for the theoretical result for FastMulRFS, as genes do not evolve <italic>i.i.d.</italic> down a species tree, as discussed in <xref rid="btaa444-B16" ref-type="bibr">Dondi <italic>et al.</italic> (2019)</xref>. On the other hand, FastMulRFS has only been proven consistent when no adversarial GDL occurs; this is a relative weakness of the theoretical result for FastMulRFS (although see Conjecture 7). Thus, from a theoretical perspective, there are advantages and disadvantages for both methods.</p>
    <p>We now consider the empirical performance of the methods evaluated in this study, focusing on the simulated datasets (since differences on the biological dataset were minor, except for running time). Under most of the model conditions we examined, FastMulRFS was more accurate and more robust to GTEE than ASTRAL-multi. Furthermore, the only conditions in which the two methods achieved similar accuracy were characterized by low GTEE and large numbers of genes, where both methods achieved very high accuracy. In addition, FastMulRFS was much faster than ASTRAL-multi, with large improvements in speed, especially for large numbers of genes and high GTEE. Thus, FastMulRFS had superior performance compared to ASTRAL-multi, the only previous method to date established statistically consistent under a stochastic GDL model.</p>
    <p>A comparison between FastMulRFS and MulRF is also interesting. Both methods attempt to solve the same NP-hard optimization problem, and neither is guaranteed to find an optimal solution. However, FastMulRFS is guaranteed to find an optimal solution within a constrained search space within polynomial time, whereas MulRF uses a local search strategy that is not guaranteed to find optimal solutions and is not guaranteed to complete in polynomial time. Furthermore, the way that FastMulRFS constrains its search space is sufficient to ensure that it is statistically consistent, but this statement is not guaranteed for MulRF. From a theoretical perspective, therefore, FastMulRFS is superior to MulRF. In terms of empirical performance in our study, the two methods were very close in accuracy, but FastMulRFS was dramatically faster. Therefore, overall, FastMulRFS was superior to MulRF.</p>
    <p>We note that FastMulRFS matched or improved on the other methods under all conditions we explored, where gene trees evolved under a unified model of ILS and GDL (which did not prohibit adversarial GDL). Hence, our study suggests that FastMulRFS may have good robustness and high accuracy, even under conditions where it has not (yet) been proven statistically consistent. However, future work is clearly needed to evaluate FastMulRFS and other methods under a wider range of model conditions, including explicit conditions where adversarial GDL occurs.</p>
  </sec>
  <sec>
    <title>6 Summary and conclusions</title>
    <p>FastMulRFS is a new method that can estimate species tree from unrooted gene family trees, without needing to have any information about orthology. FastMulRFS is provably statistically consistent under a GDL model that allows genes to evolve under a no-common-mechanism model [a more general model than the <xref rid="btaa444-B2" ref-type="bibr">Arvestad <italic>et al.</italic> (2009)</xref><italic>i.i.d.</italic> model assumed in the proof of statistical consistency for ASTRAL-multi], provided that adversarial GDL does not occur. Prior to this study, ASTRAL-multi was the only method proven to be statistically consistent for estimating species trees in the presence of GDL.</p>
    <p>FastMulRFS always matched or improved on the accuracy of ASTRAL-multi (often substantially) in our simulation study, which included three GDL, two ILS levels and five GTEE levels, and it was also faster than ASTRAL-multi. Furthermore, these model conditions do not prohibit adversarial GDL. This improvement in accuracy over ASTRAL-multi is significant, since our proof only establishes statistical consistency under models where no adversarial GDL, ILS or GTEE is present. Although accuracy is difficult to evaluate on biological datasets, FastMulRFS produced trees that were similar to those produced by other methods and did not violate known relationships.</p>
    <p>This study suggests several directions for future work. In particular, we should explore additional simulation conditions to evaluate the impact of higher GDL rates (including conditions that explicitly have adversarial GDL) and larger numbers of genes, where the relative performance of species tree estimation methods might be different. Simulations should also be performed to evaluate other scenarios that produce multi-copy genes, for example whole genome duplication events, which impact species tree estimation for many major clades, including fungi (<xref rid="btaa444-B8" ref-type="bibr">Butler <italic>et al.</italic>, 2009</xref>) and plants (<xref rid="btaa444-B30" ref-type="bibr">Leebens-Mack <italic>et al.</italic>, 2019</xref>). More complex simulations should also be considered, including ILS, introgression, gene conversion, etc., in order to better understand the conditions in which each method performs well. Furthermore, it would be helpful to characterize biological datasets in understand realistic levels of ILS and GDL (including the frequency of adversarial GDL).</p>
    <p>A limitation of this study is that we only examined a few methods, and future studies should also evaluate other methods, including <italic>guenomu</italic> (discussed earlier) and MixTreEM (<xref rid="btaa444-B44" ref-type="bibr">Ullah <italic>et al.</italic>, 2015</xref>), to discover the places in the parameter space of model species trees where each method outperforms the others. Furthermore, methods that operate by making predictions of orthology could be used in a three-phase approach: given inputs with sequence alignments and multrees, predict orthology, reduce to datasets with just orthologous genes (and hence singly-labeled gene trees) and then run a preferred species tree estimation method. For example, in a recent preprint, <xref rid="btaa444-B50" ref-type="bibr">Zhang <italic>et al.</italic> (2019)</xref> presented another modification of ASTRAL, A-PRO and proved it statistically consistent under a GDL model if given correctly rooted and ‘tagged’ gene trees (i.e. each node in each gene tree is correctly identified as either a duplication or a speciation); however, this assumption means that orthology can be inferred without error (an assumption that is not made for ASTRAL-multi). Future studies should evaluate A-PRO as well in estimating a species tree from multrees. Such studies would enable biologists to select methods with the best expected accuracy for their datasets.</p>
    <p>An important direction for future work is to evaluate the theoretical properties (such as statistical consistency) of FastMulRFS under parametric GDL models, where adversarial GDL is possible. The statistical consistency of DupTree and other methods (e.g. MixTrEm, <italic>guenomu</italic> and even modifications to concatenation to enable such analyses on multi-copy gene family datasets) should also be evaluated.</p>
    <p>Overall, the recent advances in development of statistically consistent methods for species tree estimation under GDL models is exciting, and the good performance of many of these methods under a range of model conditions suggests that novel combinations and ideas may lead to even better methods that provide improved accuracy and scalability.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="sup1">
      <label>btaa444_Supplementary_Data</label>
      <media xlink:href="btaa444_supplementary_data.zip">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>The authors thank the anonymous reviewers as well as Siavash Mirarab and the members of the Warnow Lab for feedback that improved this article.</p>
    <sec>
      <title>Funding</title>
      <p>This study was supported in part by the U.S. National Science Foundation (NSF) through Grant Nos. 1535977 and 1513629 (to T.W.) and by the Ira and Debra Cohen Graduate Fellowship in Computer Science (to E.K.M.). This study was performed on the Illinois Campus Cluster and the Blue Waters supercomputer, resources operated and financially supported by UIUC in conjunction with the National Center for Supercomputing Applications. Blue Waters is supported by the state of Illinois and the NSF through Grant Nos. 0725070 and 1238993.</p>
      <p><italic>Conflict of Interest</italic>: none declared.</p>
    </sec>
  </ack>
  <app-group>
    <app id="app1">
      <title>Appendix</title>
      <p>We begin with the following two additional definitions from <xref rid="btaa444-B22" ref-type="bibr">Ganapathy <italic>et al.</italic> (2006)</xref> and <xref rid="btaa444-B10" ref-type="bibr">Chaudhary <italic>et al.</italic> (2013)</xref>.</p>
      <p>Definition 8 (Full Differentiation). <italic>We say that</italic> <inline-formula id="IE102"><mml:math id="IM102"><mml:mrow><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mo>ϕ</mml:mo><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>is a full differentiation of multree</italic> <inline-formula id="IE103"><mml:math id="IM103"><mml:mrow><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mo>ϕ</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>if</italic> <inline-formula id="IE104"><mml:math id="IM104"><mml:mrow><mml:mo>ϕ</mml:mo><mml:mo>′</mml:mo><mml:mo>:</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>→</mml:mo><mml:mi>S</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula><italic>is a bijection. In other words</italic>, <inline-formula id="IE105"><mml:math id="IM105"><mml:mrow><mml:mi>M</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula><italic>is a singly labeled version of M.</italic></p>
      <p>Definition 9 (Mutually Consistent Full Differentiations). <italic>Let</italic> <inline-formula id="IE106"><mml:math id="IM106"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mn>1</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>and</italic> <inline-formula id="IE107"><mml:math id="IM107"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mn>2</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>be full differentiations of multrees</italic> <inline-formula id="IE108"><mml:math id="IM108"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>and</italic> <inline-formula id="IE109"><mml:math id="IM109"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>, respectively. For i  =  1, 2, we define</italic> <inline-formula id="IE110"><mml:math id="IM110"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:mi>S</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula><italic>to be the set of labels given to the leaves in</italic> <inline-formula id="IE111"><mml:math id="IM111"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula><italic>that are labeled s in M<sub>i</sub>. We say that</italic> <inline-formula id="IE112"><mml:math id="IM112"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula><italic>and</italic> <inline-formula id="IE113"><mml:math id="IM113"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula><italic>are mutually consistent full differentiations (MCFDs) of M<sub>1</sub> and M<sub>2</sub> if</italic> <inline-formula id="IE114"><mml:math id="IM114"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
      <p><xref rid="btaa444-B22" ref-type="bibr">Ganapathy <italic>et al.</italic> (2006)</xref> showed that if <italic>M</italic><sub>1</sub> and <italic>M</italic><sub>2</sub> are both multrees, then their RF distance can be computed as
<disp-formula id="E4"><mml:math id="M4"><mml:mi mathvariant="italic">MulRF</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:mi>R</mml:mi><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:msubsup><mml:mi>M</mml:mi><mml:mn>1</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi>M</mml:mi><mml:mn>2</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo>)</mml:mo><mml:mo>:</mml:mo><mml:msubsup><mml:mi>M</mml:mi><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo> </mml:mo><mml:mtext>is</mml:mtext><mml:mo> </mml:mo><mml:mtext>an</mml:mtext><mml:mo> </mml:mo><mml:mtext>MCFD</mml:mtext><mml:mo> </mml:mo><mml:mtext>of</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:math></disp-formula>which implies an exponential-time algorithm for computing the RF distance between two multrees (<xref rid="btaa444-B22" ref-type="bibr">Ganapathy <italic>et al.</italic>, 2006</xref>), Later, <xref rid="btaa444-B10" ref-type="bibr">Chaudhary <italic>et al.</italic> (2013)</xref> showed this problem is NP-complete and introduced a special case, where one of the two multrees has the property: every leaf with the same label is grouped together into polytomy that is separated by an edge from the rest of the tree. A multree with this property can be viewed as an extended version of a singly-labeled tree.</p>
      <p>Definition 10 (Extended Version). <italic>Let</italic> <inline-formula id="IE115"><mml:math id="IM115"><mml:mrow><mml:mi>T</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>be a singly-labeled tree, and let</italic> <inline-formula id="IE116"><mml:math id="IM116"><mml:mrow><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mi>M</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>be a multree. Let k<sub>s</sub> be the number of leaves with label s in M. The extended version of T with respect to M, denoted Ext(T, M), is created by attaching k<sub>s</sub> new leaves to the leaf labeled s in T, assigning label s to each of these new leaves, and repeating this process for all</italic> <inline-formula id="IE117"><mml:math id="IM117"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
      <p><xref rid="btaa444-B10" ref-type="bibr">Chaudhary <italic>et al.</italic> (2013)</xref> showed that the RF distance between a multree <italic>M</italic> and (the extended version of) a singly-labeled tree <italic>T</italic>, both on label set <italic>S</italic>, can be computed in polynomial time. Here, we provide an alternative proof that further simplifies this problem. First, we present two transformations that can be applied to a multree <inline-formula id="IE118"><mml:math id="IM118"><mml:mrow><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mo>ϕ</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> or to its full differentiation <inline-formula id="IE119"><mml:math id="IM119"><mml:mrow><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mo>ϕ</mml:mo><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by using the function <inline-formula id="IE120"><mml:math id="IM120"><mml:mrow><mml:mi>f</mml:mi><mml:mo>:</mml:mo><mml:mi>S</mml:mi><mml:mo>′</mml:mo><mml:mo>→</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula> with property that <inline-formula id="IE121"><mml:math id="IM121"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>ϕ</mml:mo><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>ϕ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for all <inline-formula id="IE122"><mml:math id="IM122"><mml:mrow><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>Definition 11 (Contracted Version). <italic>The contracted version of M, denoted</italic> <inline-formula id="IE123"><mml:math id="IM123"><mml:mrow><mml:mi mathvariant="script">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>, is created by contracting every edge e that fails to induce a bipartition, because some species label appears on both sides of e. Similarly, the contracted version of</italic> <inline-formula id="IE124"><mml:math id="IM124"><mml:mrow><mml:mi>M</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula><italic>, denoted</italic> <inline-formula id="IE125"><mml:math id="IM125"><mml:mrow><mml:mi mathvariant="script">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>, is created by contracting every edge e with</italic> <inline-formula id="IE126"><mml:math id="IM126"><mml:mrow><mml:msub><mml:mrow><mml:mo>π</mml:mo></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mo>|</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula><italic>such that</italic> <inline-formula id="IE127"><mml:math id="IM127"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>Definition 12 (Reduced Version). <italic>If all leaves with species label s are on the same side of every edge in E(m), then they can be represented by a single leaf labeled s. The reduced version of M or</italic> <inline-formula id="IE128"><mml:math id="IM128"><mml:mrow><mml:mi>M</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula><italic>, denoted</italic> <inline-formula id="IE129"><mml:math id="IM129"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>or</italic> <inline-formula id="IE130"><mml:math id="IM130"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>, respectively, is created as follows. For every</italic> <inline-formula id="IE131"><mml:math id="IM131"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula><italic>with the aforementioned property, delete all but one of the leaves in the set</italic> <inline-formula id="IE132"><mml:math id="IM132"><mml:mrow><mml:mo>{</mml:mo><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>ϕ</mml:mo><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>ϕ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula><italic>(suppressing internal vertices of degree 2) and relabel the remaining leaf s.</italic></p>
      <p>It is easy to see that <inline-formula id="IE133"><mml:math id="IM133"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a singly-labeled tree that is isomorphic to <inline-formula id="IE134"><mml:math id="IM134"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, because after applying the function <inline-formula id="IE135"><mml:math id="IM135"><mml:mi mathvariant="script">X</mml:mi></mml:math></inline-formula> to either <inline-formula id="IE136"><mml:math id="IM136"><mml:mrow><mml:mi>M</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> or <italic>M</italic>, all the leaves with species label <italic>s</italic> will be on the same side of every edge and thus can be replaced by a single leaf with species label <italic>s</italic> by applying the function <inline-formula id="IE137"><mml:math id="IM137"><mml:mi mathvariant="script">R</mml:mi></mml:math></inline-formula>. This observation holds for all <inline-formula id="IE138"><mml:math id="IM138"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
      <p>Lemma 13. <italic>Let T be a singly-labeled, fully resolved tree on label set S, let</italic> <inline-formula id="IE139"><mml:math id="IM139"><mml:mrow><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mo>ϕ</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>be a multree, and let</italic> <inline-formula id="IE140"><mml:math id="IM140"><mml:mrow><mml:mi mathvariant="italic">Ext</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula><italic>and</italic> <inline-formula id="IE141"><mml:math id="IM141"><mml:mrow><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mo>ϕ</mml:mo><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>be MCFDs of Ext(T, M) and M, respectively. Then</italic>,
<disp-formula id="E5"><label>(4)</label><mml:math id="M5"><mml:mrow><mml:mi>R</mml:mi><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">Ext</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>R</mml:mi><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></disp-formula><italic>where</italic> <inline-formula id="IE142"><mml:math id="IM142"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>and K is a constant that does not depend on the topology of the singly-labeled tree T on S.</italic></p>
      <p>Proof. Let <inline-formula id="IE143"><mml:math id="IM143"><mml:mrow><mml:mi>f</mml:mi><mml:mo>:</mml:mo><mml:mi>S</mml:mi><mml:mo>′</mml:mo><mml:mo>→</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula> be a function with property that <inline-formula id="IE144"><mml:math id="IM144"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>ϕ</mml:mo><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>ϕ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for all <inline-formula id="IE145"><mml:math id="IM145"><mml:mrow><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and define <inline-formula id="IE146"><mml:math id="IM146"><mml:mrow><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>A</mml:mi><mml:mo>|</mml:mo><mml:mi>B</mml:mi><mml:mo>∈</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mo>∅</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE147"><mml:math id="IM147"><mml:mrow><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>A</mml:mi><mml:mo>|</mml:mo><mml:mi>B</mml:mi><mml:mo>∈</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mi>X</mml:mi><mml:mo>:</mml:mo><mml:mo>|</mml:mo><mml:mi>A</mml:mi><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>|</mml:mo><mml:mi>B</mml:mi><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:mtext>either</mml:mtext><mml:mo>|</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mtext>or</mml:mtext><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Thus, <italic>X</italic> contains bipartitions that <italic>cannot exist</italic> in <inline-formula id="IE148"><mml:math id="IM148"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">Ext</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for any singly-labeled tree <italic>T</italic> on <italic>S</italic>, and <italic>R</italic> contains bipartitions that <italic>must exist</italic> in <inline-formula id="IE149"><mml:math id="IM149"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">Ext</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for any singly-labeled tree <italic>T</italic> on <italic>S</italic>. Let <inline-formula id="IE150"><mml:math id="IM150"><mml:mrow><mml:mi>E</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> denote <inline-formula id="IE151"><mml:math id="IM151"><mml:mrow><mml:mi mathvariant="italic">Ext</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. Then,
<disp-formula id="E6"><mml:math id="M6"><mml:mtable><mml:mtr><mml:mtd><mml:mo>|</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>E</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>E</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>E</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>R</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>R</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn><mml:mo stretchy="false">[</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mi>R</mml:mi><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>R</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn><mml:mo stretchy="false">[</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>3</mml:mn><mml:mo>−</mml:mo><mml:mi>R</mml:mi><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>R</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn><mml:mo stretchy="false">[</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>3</mml:mn><mml:mo>−</mml:mo><mml:mi>R</mml:mi><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>R</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p>
      <p>Let <italic>c</italic> be the number of species in <italic>M</italic> that have multiple copies. Then,
<disp-formula id="E7"><mml:math id="M7"><mml:mtable><mml:mtr><mml:mtd><mml:mi>R</mml:mi><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>E</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>E</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>|</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>E</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>|</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>E</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mi>R</mml:mi><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>|</mml:mo><mml:mi>R</mml:mi><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mo>|</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>where <italic>S</italic>, <italic>c</italic>, <italic>E</italic>(<italic>m</italic>), <inline-formula id="IE152"><mml:math id="IM152"><mml:mrow><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <italic>R</italic> and <italic>L</italic>(<italic>m</italic>) are independent of <italic>T</italic>. □</p>
    </app>
  </app-group>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btaa444-B1">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Altenhoff</surname><given-names>A.M.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) <chapter-title>Inferring orthology and paralogy</chapter-title> In: <person-group person-group-type="editor"><name name-style="western"><surname>Anisimova</surname><given-names>M.</given-names></name></person-group> (ed.) <source>Evolutionary Genomics: Statistical and Computational Methods</source>. Vol. <volume>1</volume>
<publisher-name>Springer</publisher-name>, : New York, NY, USA, pp. <fpage>149</fpage>–<lpage>175</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa444-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Arvestad</surname><given-names>L.</given-names></name></person-group><etal>et al</etal> (<year>2009</year>) 
<article-title>The gene evolution model and computing its associated probabilities</article-title>. <source>J. ACM</source>, <volume>56</volume>, <fpage>1</fpage>–<lpage>44</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa444-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bansal</surname><given-names>M.S.</given-names></name></person-group><etal>et al</etal> (<year>2010</year>) 
<article-title>Robinson-Foulds supertrees</article-title>. <source>Algorithms Mol. Biol</source>., <volume>5</volume>, <fpage>18</fpage>.<pub-id pub-id-type="pmid">20181274</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bayzid</surname><given-names>M.S.</given-names></name>, <name name-style="western"><surname>Warnow</surname><given-names>T.</given-names></name></person-group> (<year>2018</year>) 
<article-title>Gene tree parsimony for incomplete gene trees: addressing true biological loss</article-title>. <source>Algorithms Mol. Biol</source>., <volume>13</volume>, <fpage>1</fpage>.<pub-id pub-id-type="pmid">29387142</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Boussau</surname><given-names>B.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>Genome-scale coestimation of species and gene trees</article-title>. <source>Genome Res</source>., <volume>23</volume>, <fpage>323</fpage>–<lpage>330</lpage>.<pub-id pub-id-type="pmid">23132911</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bryant</surname><given-names>D.</given-names></name>, <name name-style="western"><surname>Steel</surname><given-names>M.</given-names></name></person-group> (<year>2001</year>) 
<article-title>Constructing optimal trees from quartets</article-title>. <source>J. Algorithms</source>, <volume>38</volume>, <fpage>237</fpage>–<lpage>259</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa444-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Burleigh</surname><given-names>J.G.</given-names></name></person-group><etal>et al</etal> (<year>2011</year>) 
<article-title>Genome-scale phylogenetics: inferring the plant tree of life from 18,896 gene trees</article-title>. <source>Syst. Biol</source>., <volume>60</volume>, <fpage>117</fpage>–<lpage>125</lpage>.<pub-id pub-id-type="pmid">21186249</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Butler</surname><given-names>G.</given-names></name></person-group><etal>et al</etal> (<year>2009</year>) 
<article-title>Evolution of pathogenicity and sexual reproduction in eight Candida genomes</article-title>. <source>Nature</source>, <volume>459</volume>, <fpage>657</fpage>–<lpage>662</lpage>.<pub-id pub-id-type="pmid">19465905</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chaudhary</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2010</year>) 
<article-title>iGTP: a software package for large-scale gene tree parsimony analysis</article-title>. <source>BMC Bioinformatics</source>, <volume>11</volume>, <fpage>574</fpage>.<pub-id pub-id-type="pmid">21092314</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chaudhary</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>Inferring species trees from incongruent multi-copy gene trees using the Robinson-Foulds distance</article-title>. <source>Algorithms Mol. Biol</source>., <volume>8</volume>, <fpage>28</fpage>.<pub-id pub-id-type="pmid">24180377</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chaudhary</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>a) 
<article-title>Assessing approaches for inferring species trees from multi-copy genes</article-title>. <source>Syst. Biol</source>., <volume>64</volume>, <fpage>325</fpage>–<lpage>339</lpage>.<pub-id pub-id-type="pmid">25540456</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chaudhary</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>b) 
<article-title>MulRF: a software package for phylogenetic analysis using multi-copy gene trees</article-title>. <source>Bioinformatics</source>, <volume>31</volume>, <fpage>432</fpage>–<lpage>433</lpage>.<pub-id pub-id-type="pmid">25273112</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B13">
      <mixed-citation publication-type="book"><person-group person-group-type="editor"><name name-style="western"><surname>Cracraft</surname><given-names>J.</given-names></name></person-group><etal>et al</etal>, eds. (<year>2004</year>) Assembling the Tree of Life. Joel, C. and Michael,J.D. (eds) Oxford University Press, Oxford, UK. See here: <ext-link ext-link-type="uri" xlink:href="https://www.amazon.com/Assembling-Tree-Life-Joel-Cracraft/dp/0195172345">https://www.amazon.com/Assembling-Tree-Life-Joel-Cracraft/dp/0195172345</ext-link>.</mixed-citation>
    </ref>
    <ref id="btaa444-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>De Oliveira Martins</surname><given-names>L.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>A Bayesian supertree model for genome-wide species tree reconstruction</article-title>. <source>Syst. Biol</source>., <volume>65</volume>, <fpage>397</fpage>–<lpage>416</lpage>.<pub-id pub-id-type="pmid">25281847</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B15">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Delabre</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2020</year>) <chapter-title>Evolution through segmental duplications and losses: a Super-Reconciliation approach</chapter-title> <italic>Algorithms Mol. Biol</italic>, <bold>15,</bold> 12. 
</mixed-citation>
    </ref>
    <ref id="btaa444-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Dondi</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) 
<article-title>Reconciling multiple genes trees via segmental duplications and losses</article-title>. <source>Algorithms Mol. Biol</source>., <volume>14</volume>.</mixed-citation>
    </ref>
    <ref id="btaa444-B17">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Du</surname><given-names>P.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) Species tree inference under the multispecies coalescent on data with paralogs is accurate. bioRxiv, doi:10.1101/498378.</mixed-citation>
    </ref>
    <ref id="btaa444-B18">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>El-Mabrouk</surname><given-names>N.</given-names></name>, <name name-style="western"><surname>Noutahi</surname><given-names>E.</given-names></name></person-group> (<year>2019</year>) <chapter-title>Gene family evolution—an algorithmic framework</chapter-title> In: <person-group person-group-type="editor"><name name-style="western"><surname>Warnow</surname><given-names>T.</given-names></name></person-group> (ed.) <source>Bioinformatics and Phylogenetics</source>. Computational Biology, vol <volume>29</volume>, pp. 87–119. Springer, Cham. 10.1007/978-3-030-10837-3_5.</mixed-citation>
    </ref>
    <ref id="btaa444-B19">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Emms</surname><given-names>D.</given-names></name>, <name name-style="western"><surname>Kelly</surname><given-names>S.</given-names></name></person-group> (<year>2018</year>) STAG: species tree inference from all genes. bioRxiv, doi:10.1101/267914.</mixed-citation>
    </ref>
    <ref id="btaa444-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Estabrook</surname><given-names>G.</given-names></name></person-group><etal>et al</etal> (<year>1975</year>) 
<article-title>An idealized concept of the true cladistic character</article-title>. <source>Math. Biosci</source>., <volume>23</volume>, <fpage>263</fpage>–<lpage>272</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa444-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Fitch</surname><given-names>W.M.</given-names></name></person-group> (<year>2000</year>) 
<article-title>Homology: a personal view on some of the problems</article-title>. <source>Trends Genet</source>., <volume>16</volume>, <fpage>227</fpage>–<lpage>231</lpage>.<pub-id pub-id-type="pmid">10782117</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Ganapathy</surname><given-names>G.</given-names></name></person-group><etal>et al</etal> (<year>2006</year>) 
<article-title>Pattern identification in biogeography</article-title>. <source>IEEE/ACM Trans. Comput. Biol. Bioinform</source>., <volume>3</volume>, <fpage>334</fpage>–<lpage>346</lpage>.<pub-id pub-id-type="pmid">17085843</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B23">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Hallett</surname><given-names>M.T.</given-names></name>, <name name-style="western"><surname>Lagergren</surname><given-names>J.</given-names></name></person-group> (<year>2000</year>) New algorithms for the duplication-loss model. In: <italic>Proceedings of the Fourth Annual International Conference on Computational Molecular Biology, RECOMB ‘00</italic>, New York, NY, pp. <fpage>138</fpage>–<lpage>146</lpage>. ACM.</mixed-citation>
    </ref>
    <ref id="btaa444-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Hasić</surname><given-names>D.</given-names></name>, <name name-style="western"><surname>Tannier</surname><given-names>E.</given-names></name></person-group> (<year>2019</year>) 
<article-title>Gene tree species tree reconciliation with gene conversion</article-title>. <source>J. Math. Biol</source>., <volume>78</volume>, <fpage>1981</fpage>–<lpage>2014</lpage>.<pub-id pub-id-type="pmid">30767052</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Jacox</surname><given-names>E.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>ecceTERA: comprehensive gene tree-species tree reconciliation using parsimony</article-title>. <source>Bioinformatics</source>, <volume>32</volume>, <fpage>2056</fpage>–<lpage>2058</lpage>.<pub-id pub-id-type="pmid">27153713</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Jarvis</surname><given-names>E.D.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Whole-genome analyses resolve early branches in the tree of life of modern birds</article-title>. <source>Science</source>, <volume>346</volume>, <fpage>1320</fpage>–<lpage>1331</lpage>.<pub-id pub-id-type="pmid">25504713</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Kundu</surname><given-names>S.</given-names></name>, <name name-style="western"><surname>Bansal</surname><given-names>M.S.</given-names></name></person-group> (<year>2018</year>) 
<article-title>On the impact of uncertain gene tree rooting on duplication-transfer-loss reconciliation</article-title>. <source>BMC Bioinform</source>., <volume>19</volume>, <fpage>21</fpage>–<lpage>31</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa444-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lafond</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Accurate prediction of orthologs in the presence of divergence after duplication</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>i366</fpage>–<lpage>i375</lpage>.<pub-id pub-id-type="pmid">29950018</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B29">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Lai</surname><given-names>H.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) <chapter-title>Fast heuristics for resolving weakly supported branches using duplication, transfers, and losses</chapter-title> In: <source>RECOMB International Workshop on Comparative Genomics</source>, pp. <fpage>298</fpage>–<lpage>320</lpage>. 
<publisher-name>Springer</publisher-name>, 
<publisher-loc>Cham</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btaa444-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Leebens-Mack</surname><given-names>J.H.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) 
<article-title>One thousand plant transcriptomes and the phylogenomics of green plants</article-title>. <source>Nature</source>, <volume>574</volume>, <fpage>679</fpage>–<lpage>685</lpage>.<pub-id pub-id-type="pmid">31645766</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B31">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Legried</surname><given-names>B.</given-names></name></person-group><etal>et al</etal> (<year>2020</year>) 
<article-title>Polynomial-time statistical estimation of species trees under gene duplication and loss</article-title>. In: Schwartz,R. (ed) <italic>Research in Computational Molecular Biology (RECOMB)</italic>. Lecture Notes in Computer Science, vol 12074. pp. 120-135. Springer, Cham. doi:<pub-id pub-id-type="doi">10.1007/978-3-030-45257-5_8</pub-id>.</mixed-citation>
    </ref>
    <ref id="btaa444-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Mirarab</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>ASTRAL: genome-scale coalescent-based species tree estimation</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>i541</fpage>–<lpage>i548</lpage>.<pub-id pub-id-type="pmid">25161245</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Molloy</surname><given-names>E.K.</given-names></name>, <name name-style="western"><surname>Warnow</surname><given-names>T.</given-names></name></person-group> (<year>2018</year>) 
<article-title>To include or not to include: the impact of gene filtering on species tree estimation methods</article-title>. <source>Syst. Biol</source>., <volume>67</volume>, <fpage>285</fpage>–<lpage>303</lpage>.<pub-id pub-id-type="pmid">29029338</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Moreira</surname><given-names>D.</given-names></name>, <name name-style="western"><surname>Philippe</surname><given-names>H.</given-names></name></person-group> (<year>2000</year>) 
<article-title>Molecular phylogeny: pitfalls and progress</article-title>. <source>Int. Microbiol</source>., <volume>3</volume>, <fpage>9</fpage>–<lpage>16</lpage>.<pub-id pub-id-type="pmid">10963328</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B35">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Muhammad</surname><given-names>S.A.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Species tree-aware simultaneous reconstruction of gene and domain evolution</article-title>. bioRxiv, doi:10.1101/336453.</mixed-citation>
    </ref>
    <ref id="btaa444-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Rabiee</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) 
<article-title>Multi-allele species reconstruction using ASTRAL</article-title>. <source>Mol. Phylogenet. Evol</source>., <volume>130</volume>, <fpage>286</fpage>–<lpage>296</lpage>.<pub-id pub-id-type="pmid">30393186</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B37">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Rasmussen</surname><given-names>M.D.</given-names></name>, <name name-style="western"><surname>Kellis</surname><given-names>M.</given-names></name></person-group> (<year>2012</year>) 
<article-title>Unified modeling of gene duplication, loss, and coalescence using a locus tree</article-title>. <source>Genome Res</source>., <volume>22</volume>, <fpage>755</fpage>–<lpage>765</lpage>.<pub-id pub-id-type="pmid">22271778</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B38">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Robinson</surname><given-names>D.F.</given-names></name>, <name name-style="western"><surname>Foulds</surname><given-names>L.R.</given-names></name></person-group> (<year>1981</year>) 
<article-title>Comparison of phylogenetic trees</article-title>. <source>Math. Biosci</source>., <volume>53</volume>, <fpage>131</fpage>–<lpage>147</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa444-B39">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Ronquist</surname><given-names>F.</given-names></name>, <name name-style="western"><surname>Huelsenbeck</surname><given-names>J.P.</given-names></name></person-group> (<year>2003</year>) 
<article-title>MrBayes 3: Bayesian phylogenetic inference under mixed models</article-title>. <source>Bioinformatics</source>, <volume>19</volume>, <fpage>1572</fpage>–<lpage>1574</lpage>.<pub-id pub-id-type="pmid">12912839</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B40">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Sanderson</surname><given-names>M.J.</given-names></name>, <name name-style="western"><surname>McMahon</surname><given-names>M.M.</given-names></name></person-group> (<year>2007</year>) 
<article-title>Inferring angiosperm phylogeny from EST data with widespread gene duplication</article-title>. <source>BMC Evol. Biol</source>., <volume>7</volume>, <fpage>S3</fpage>.</mixed-citation>
    </ref>
    <ref id="btaa444-B41">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Stamatakis</surname><given-names>A.</given-names></name></person-group> (<year>2014</year>) 
<article-title>RAxML Version 8: a tool for phylogenetic analysis and post-analysis of large phylogenies</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>1312</fpage>–<lpage>1313</lpage>.<pub-id pub-id-type="pmid">24451623</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B42">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Sousa da Silva</surname><given-names>A.W.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Big data and other challenges in the quest for orthologs</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>2993</fpage>–<lpage>2998</lpage>.<pub-id pub-id-type="pmid">25064571</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B43">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Tuffley</surname><given-names>C.</given-names></name>, <name name-style="western"><surname>Steel</surname><given-names>M.</given-names></name></person-group> (<year>1997</year>) 
<article-title>Links between maximum likelihood and maximum parsimony under a simple model of site substitution</article-title>. <source>Bull. Math. Biol</source>., <volume>59</volume>, <fpage>581</fpage>–<lpage>607</lpage>.<pub-id pub-id-type="pmid">9172826</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B44">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Ullah</surname><given-names>I.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Species tree inference using a mixture model</article-title>. <source>Mol. Biol. Evol</source>., <volume>32</volume>, <fpage>2469</fpage>–<lpage>2482</lpage>.<pub-id pub-id-type="pmid">25963975</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B45">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Vachaspati</surname><given-names>P.</given-names></name>, <name name-style="western"><surname>Warnow</surname><given-names>T.</given-names></name></person-group> (<year>2016</year>) 
<article-title>FastRFS: fast and accurate Robinson-Foulds Supertrees using constrained exact optimization</article-title>. <source>Bioinformatics</source>, <volume>33</volume>, <fpage>631</fpage>–<lpage>639</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa444-B46">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Warnow</surname><given-names>T.</given-names></name></person-group> (<year>2017</year>) <source>Computational Phylogenetics: An Introduction to Designing Methods for Phylogeny Estimation</source>. 
<publisher-name>Cambridge University Press</publisher-name>, 
<publisher-loc>Cambridge UK</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btaa444-B47">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Wehe</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2008</year>) 
<article-title>DupTree: a program for large-scale phylogenetic analyses using gene tree parsimony</article-title>. <source>Bioinformatics</source>, <volume>24</volume>, <fpage>1540</fpage>–<lpage>1541</lpage>.<pub-id pub-id-type="pmid">18474508</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B48">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Wickett</surname><given-names>N.J.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Phylotranscriptomic analysis of the origin and early diversification of land plants</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>111</volume>, <fpage>E4859</fpage>–<lpage>E4868</lpage>.<pub-id pub-id-type="pmid">25355905</pub-id></mixed-citation>
    </ref>
    <ref id="btaa444-B49">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Zhang</surname><given-names>C.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>ASTRAL-III: polynomial time species tree reconstruction from partially resolved gene trees</article-title>. <source>BMC Bioinform</source>., <volume>19</volume>, <fpage>153</fpage>.</mixed-citation>
    </ref>
    <ref id="btaa444-B50">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Zhang</surname><given-names>C.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) 
<article-title>ASTRAL-Pro: quartet-based species tree inference despite paralogy</article-title>. <italic>bioRxiv</italic>, doi:10.1101/2019.12.12.874727.</mixed-citation>
    </ref>
  </ref-list>
</back>
