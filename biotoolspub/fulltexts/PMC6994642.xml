<?DTDIdentifier.IdentifierValue -//ES//DTD journal article DTD version 5.5.0//EN//XML?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName art550.dtd?>
<?SourceDTD.Version 5.5.0?>
<?ConverterInfo.XSLTName elsevier2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<?origin publisher?>
<?FILEmeta_MEX695 xml ?>
<?FILEmain xml ?>
<?FILEmain pdf ?>
<?FILEgr1 jpg ?>
<?FILEgr2 jpg ?>
<?FILEgr3 jpg ?>
<?FILEgr4 jpg ?>
<?FILEfx1 jpg ?>
<?FILEfx2 jpg ?>
<?FILEfx3 jpg ?>
<?FILEfx4 jpg ?>
<?FILEmmc1 pdf ?>
<?properties open_access?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">MethodsX</journal-id>
    <journal-id journal-id-type="iso-abbrev">MethodsX</journal-id>
    <journal-title-group>
      <journal-title>MethodsX</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2215-0161</issn>
    <publisher>
      <publisher-name>Elsevier</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6994642</article-id>
    <article-id pub-id-type="publisher-id">S2215-0161(19)30271-7</article-id>
    <article-id pub-id-type="doi">10.1016/j.mex.2019.10.006</article-id>
    <article-id pub-id-type="publisher-id">100695</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Computer Science</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>FESTIval: A versatile framework for conducting experimental evaluations of spatial indices</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" id="aut0005">
        <name>
          <surname>Carniel</surname>
          <given-names>Anderson C.</given-names>
        </name>
        <email>accarniel@gmail.com</email>
        <xref rid="aff0005" ref-type="aff">a</xref>
        <xref rid="aff0010" ref-type="aff">b</xref>
        <xref rid="cor0005" ref-type="corresp">⁎</xref>
      </contrib>
      <contrib contrib-type="author" id="aut0010">
        <name>
          <surname>Ciferri</surname>
          <given-names>Ricardo R.</given-names>
        </name>
        <email>ricardo@dc.ufscar.br</email>
        <xref rid="aff0015" ref-type="aff">c</xref>
      </contrib>
      <contrib contrib-type="author" id="aut0015">
        <name>
          <surname>Ciferri</surname>
          <given-names>Cristina D.A.</given-names>
        </name>
        <email>cdac@icmc.usp.br</email>
        <xref rid="aff0010" ref-type="aff">b</xref>
      </contrib>
    </contrib-group>
    <aff id="aff0005"><label>a</label>Federal University of Technology – Paraná, Dois Vizinhos, PR 85660-000, Brazil</aff>
    <aff id="aff0010"><label>b</label>Department of Computer Science, University of São Paulo, São Carlos, SP 13566-590, Brazil</aff>
    <aff id="aff0015"><label>c</label>Department of Computing, Federal University of São Carlos, São Carlos, SP 13565-905, Brazil</aff>
    <author-notes>
      <corresp id="cor0005"><label>⁎</label>Corresponding author at: Federal University of Technology – Paraná, Dois Vizinhos, PR 85660-000, Brazil. <email>accarniel@gmail.com</email></corresp>
    </author-notes>
    <pub-date pub-type="pmc-release">
      <day>16</day>
      <month>10</month>
      <year>2019</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on <pub-date
						pub-type="epub">.-->
    <pub-date pub-type="collection">
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>16</day>
      <month>10</month>
      <year>2019</year>
    </pub-date>
    <volume>7</volume>
    <elocation-id>100695</elocation-id>
    <history>
      <date date-type="received">
        <day>12</day>
        <month>10</month>
        <year>2018</year>
      </date>
      <date date-type="accepted">
        <day>6</day>
        <month>10</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2019 The Author(s)</copyright-statement>
      <copyright-year>2019</copyright-year>
      <license license-type="CC BY" xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).</license-p>
      </license>
    </permissions>
    <abstract abstract-type="graphical" id="abs0005">
      <title>Graphical abstract</title>
      <fig id="fig0025" position="anchor">
        <graphic xlink:href="fx1"/>
      </fig>
    </abstract>
    <abstract id="abs0010">
      <p>The use of a spatial index is a common strategy to improve the performance of spatial queries in spatial database systems and Geographic Information Systems. Choosing the right spatial index to be employed in a given context requires a quantitative method to analyze the performance of spatial indices. This is done through extensive experimental evaluations. However, conducting these evaluations is an expensive, error-prone, and challenging task because (i) spatial objects are complex data to manage, (ii) spatial indices can apply different parameter values and thus assume distinct configurations, and (iii) there are indices specifically developed for different storage systems, such as disks and flash memories. In this article, we propose FESTIval, a versatile framework for conducting experimental evaluations of spatial indices. FESTIval has the following main advantages:</p>
      <p>
        <list list-type="simple" id="lis0005">
          <list-item id="lsti0005">
            <label>•</label>
            <p id="par0005">the support for different types of disk-based and flash-aware spatial indices;</p>
          </list-item>
          <list-item id="lsti0010">
            <label>•</label>
            <p id="par0010">the specification and execution of user-defined workloads;</p>
          </list-item>
          <list-item id="lsti0015">
            <label>•</label>
            <p id="par0015">the use of a data schema that stores index configurations and statistical data of executed workloads.</p>
          </list-item>
        </list>
      </p>
      <p>Because of its characteristics, FESTIval allows users to reproduce executed experiments. Further, FESTIval provides an extensible environment, where any spatial dataset can be handled by spatial indices. FESTIval has been used to validate new proposals of flash-aware spatial indices, such as eFIND-based indices.</p>
    </abstract>
    <kwd-group id="kwd0005">
      <title>Keywords</title>
      <kwd>Spatial indexing</kwd>
      <kwd>Spatial access methods</kwd>
      <kwd>Benchmark</kwd>
      <kwd>Disk-based spatial index</kwd>
      <kwd>Flash-aware spatial index</kwd>
      <kwd>Flash memory</kwd>
      <kwd>R-trees</kwd>
      <kwd>eFIND</kwd>
    </kwd-group>
  </article-meta>
</front>
<body>
  <sec id="sec0005">
    <title>Method details</title>
    <p id="par0020">This article introduces the <italic>Framework to Evaluate SpaTial Indices</italic> (<italic>FESTIval</italic>), a versatile method for conducting experimental evaluations of spatial indices. Before describing the details of FESTIval, we shortly discuss the context and motivation behind its development.</p>
    <sec id="sec0010">
      <title>Context and motivation</title>
      <p id="par0025"><italic>Spatial database systems</italic> and <italic>Geographic Information Systems</italic> (GIS) widely make use of spatial indices to accelerate the processing of spatial queries, such as <italic>spatial selections</italic>, <italic>range queries</italic>, and <italic>point queries</italic>
<xref rid="bib0005" ref-type="bibr">[1]</xref>, <xref rid="bib0010" ref-type="bibr">[2]</xref>. A huge set of spatial indices has been proposed in the literature. In general, a spatial index groups nearest spatial objects in index pages. Commonly, these index pages are nodes in hierarchical structures. This organization allows us to avoid the processing of data where the answer of spatial queries certainly cannot be found.</p>
      <p id="par0030">Many spatial indices are designed for manipulating spatial objects stored in magnetic disks like <italic>Hard Disk Drives</italic> (HDDs). Hence, these indices, termed <italic>disk-based spatial indices</italic>, deal with the slow mechanical access and rotational delay of HDDs. Examples of traditional disk-based spatial indices are the R-tree <xref rid="bib0015" ref-type="bibr">[3]</xref> and its variants, the R*-tree <xref rid="bib0020" ref-type="bibr">[4]</xref> and the Hilbert R-tree <xref rid="bib0025" ref-type="bibr">[5]</xref>. The R-tree is able to index spatial objects of any type (e.g., point, line, and region) by employing their minimum bounding rectangles (MBRs) organized in a hierarchical form. The R*-tree improves the insertion algorithm of the R-tree by employing a set of criteria for organizing the entries among the nodes of the tree. The Hilbert R-tree combines the Hilbert curve with the R-tree by using the Hilbert values of the nodes’ entries; thus, the Hilbert R-tree employs the searching algorithm of the R-tree and an insertion algorithm very similar to the insertion algorithm of the B-tree <xref rid="bib0030" ref-type="bibr">[6]</xref>. These spatial indices are surveyed in <xref rid="bib0005" ref-type="bibr">[1]</xref>.</p>
      <p id="par0035">The development of spatial indices for newer storage devices like <italic>flash-based Solid State Drives</italic> (SSDs) has attracted the attention of the research community <xref rid="bib0035" ref-type="bibr">[7]</xref>, <xref rid="bib0040" ref-type="bibr">[8]</xref>, <xref rid="bib0045" ref-type="bibr">[9]</xref>, <xref rid="bib0050" ref-type="bibr">[10]</xref>, <xref rid="bib0055" ref-type="bibr">[11]</xref>. The main reason is that SSDs have several improved characteristics than HDDs, such as smaller size, lighter weight, lower power consumption, and faster reads and writes. However, SSDs have intrinsic characteristics that introduce several system implications <xref rid="bib0060" ref-type="bibr">[12]</xref>, <xref rid="bib0065" ref-type="bibr">[13]</xref>, <xref rid="bib0070" ref-type="bibr">[14]</xref>, <xref rid="bib0075" ref-type="bibr">[15]</xref>, such as the asymmetric costs between reads and writes, the performance interference of interleaved reads and writes, and the read disturbance management.</p>
      <p id="par0040">To take into account the intrinsic characteristics of SSDs, <italic>flash-aware spatial indices</italic> have been proposed in the literature, such as FAST-based indices <xref rid="bib0080" ref-type="bibr">[16]</xref>, the FOR-tree <xref rid="bib0085" ref-type="bibr">[17]</xref>, and eFIND-based indices <xref rid="bib0090" ref-type="bibr">[18]</xref>, <xref rid="bib0095" ref-type="bibr">[19]</xref>. While the FOR-tree ports the R-tree to SSDs, FAST and eFIND are generic approaches to porting any type of hierarchical index to SSDs. A common focus of these approaches is on decreasing the number of random writes to the SSD by employing an in-memory buffer to store index modifications. If this buffer is full, a flushing algorithm is executed. This operation may deploy a flushing policy to pick some index modifications stored in the buffer to be sequentially written to the SSD. eFIND-based indices distinguish themselves because eFIND is based on a distinct set of design goals that exploits the positive characteristics of SSDs. For instance, eFIND has specific data structures and algorithms to mitigate the effects of reads on frequent locations and interleaved reads and writes.</p>
      <p id="par0045">With the increasing number of spatial indices, choosing the best spatial index to be employed in a given context requires the execution of extensive performance evaluations <xref rid="bib0005" ref-type="bibr">[1]</xref>. However, conducting these evaluations is an expensive, error-prone, and challenging task because (i) spatial objects are complex data to manage, (ii) spatial indices can apply different parameter values and thus assume distinct configurations, and (iii) there are indices specifically developed for different storage systems, such as disks and flash memories. A performance evaluation usually requires the execution of <italic>user-defined workloads</italic> on a given spatial dataset. A workload consists of a set of index operations, such as insertions, deletions, or updates of spatial objects, and the processing of spatial queries.</p>
      <p id="par0050">To the best of our knowledge, there are no methods that provide needed functionalities for creating and executing workloads to benchmark disk-based and flash-aware spatial indices on different storage devices. The reason is that existing approaches <xref rid="bib0100" ref-type="bibr">[20]</xref>, <xref rid="bib0105" ref-type="bibr">[21]</xref>, <xref rid="bib0110" ref-type="bibr">[22]</xref>, <xref rid="bib0115" ref-type="bibr">[23]</xref> face several problems (see next section). In general, they are not extensible since users are not able to define their own workloads. More importantly, they do not provide support for flash-aware spatial indices.</p>
      <p id="par0055">In this article, we extend our previous work [<xref rid="bib0195" ref-type="bibr">39</xref>] by proposin FESTIval, a versatile framework for conducting experimental evaluations of spatial indices that:<list list-type="simple" id="lis0010"><list-item id="lsti0020"><label>•</label><p id="par0060">provides support for different types of disk-based and flash-aware spatial indices;</p></list-item><list-item id="lsti0025"><label>•</label><p id="par0065">allows the specification and execution of user-defined workloads under a unique environment;</p></list-item><list-item id="lsti0030"><label>•</label><p id="par0070">allows the reproduction of executed experiments;</p></list-item><list-item id="lsti0035"><label>•</label><p id="par0075">employs a data schema that stores index configurations and statistical data of executed workloads.</p></list-item></list></p>
    </sec>
    <sec id="sec0015">
      <title>Related work</title>
      <p id="par0080">Benchmarking spatial indexing structures in spatial database systems and GIS helps users to identify the best spatial indices for their applications. There are a few approaches available in the literature <xref rid="bib0100" ref-type="bibr">[20]</xref>, <xref rid="bib0105" ref-type="bibr">[21]</xref>, <xref rid="bib0110" ref-type="bibr">[22]</xref>, <xref rid="bib0115" ref-type="bibr">[23]</xref> that provide tools for conducting experimental evaluations of spatial indices. AMDB <xref rid="bib0100" ref-type="bibr">[20]</xref> and BASIS <xref rid="bib0105" ref-type="bibr">[21]</xref> are approaches that enable the performance analysis of different spatial indices like the R-tree and the R*-tree under the same environment. However, they do not allow the definition of user-defined workloads. In addition, they do not provide support for flash-aware spatial indices.</p>
      <p id="par0085">LOCUS <xref rid="bib0110" ref-type="bibr">[22]</xref> is a benchmark focused on conducting performance evaluations of <italic>Location-Based Services</italic>, which consider point datasets representing mobile users. It specifies a set of workloads for executing index operations considering different types of spatial queries. Unfortunately, LOCUS does not provide support for other spatial data types (e.g., complex regions) and face the same problems of the aforementioned approaches.</p>
      <p id="par0090">The tool employed in <xref rid="bib0115" ref-type="bibr">[23]</xref> provides a unique environment to conduct experimental evaluations of different spatial indices. This tool permits users to implement their workloads by using C/C++ language. However, its focus is on in-memory spatial databases; thus, it assumes that the whole dataset fits in the main memory without accesses to external storage devices like HDDs and SSDs.</p>
      <p id="par0095">Researchers from the spatial database and GIS communities also often define their own datasets and workloads in their experiments (e.g., in <xref rid="bib0015" ref-type="bibr">[3]</xref>, <xref rid="bib0020" ref-type="bibr">[4]</xref>, <xref rid="bib0025" ref-type="bibr">[5]</xref>, <xref rid="bib0035" ref-type="bibr">[7]</xref>, <xref rid="bib0080" ref-type="bibr">[16]</xref>, <xref rid="bib0085" ref-type="bibr">[17]</xref>). The main problem of conducting such standalone experiments is the extra effort with implementations since none of the aforementioned approaches offers a versatile environment for (i) defining new workloads, (ii) implementing other spatial indices, (iii) varying parameter values, and (iv) storing the statistical data of executed workloads. Further, reproducing or extending the standalone experiments can be a problematic task because the employed implementations and datasets are possibly not publicly available.</p>
      <p id="par0100">On the other hand, in this article we solve the aforementioned problems by proposing FESTIval. FESTIval distinguishes itself because it allows the definition of user-defined workloads in a unique and common environment. Further, it allows the specification and execution of different configurations of disk-based and flash-aware spatial indices. Statistical data of these executions are stored in an integrated data schema. By posing queries on this data schema, users are able to retrieve and analyze performance results.</p>
    </sec>
    <sec id="sec0020">
      <title>FESTIval</title>
      <p id="par0105">FESTIval is an open-source PostgreSQL extension implemented in C by using the extensibility provided by the PostgreSQL internal library.<xref rid="fn0005" ref-type="fn">1</xref> FESTIval is also based on the PostGIS,<xref rid="fn0010" ref-type="fn">2</xref> a widely used PostgreSQL extension to manage spatial objects. To process topological relationships in spatial queries, FESTIval further requires GEOS,<xref rid="fn0015" ref-type="fn">3</xref> an open-source geometry engine for computing spatial predicate functions and spatial operators. The complete documentation of FESTIval is available at <ext-link ext-link-type="uri" xlink:href="https://accarniel.github.io/FESTIval/" id="intr0025">https://accarniel.github.io/FESTIval/</ext-link>.</p>
      <p id="par0110">Currently, FESTIval provides support for the following disk-based spatial indices: the R-tree, the R*-tree, and the Hilbert R-tree. FESTIval also provides support for the following flash-aware spatial indices: the FAST R-tree, the FAST R*-tree, the FAST Hilbert R-tree, the FOR-tree, the eFIND R-tree, the eFIND R*-tree, and the eFIND Hilbert R-tree. Further, FESTIval allows the execution of user-defined workloads on real storage devices (e.g., HDDs and SSDs) and on the Flash-DBSim <xref rid="bib0120" ref-type="bibr">[24]</xref>, which is a flash simulator that emulates the behavior of flash memory in the main memory. The use of a flash simulator is useful because the Flash Translation Layer (FTL) <xref rid="bib0125" ref-type="bibr">[25]</xref> of a real flash memory usually does not provide access to the number of internal operations actually performed on the flash memory.</p>
      <p id="par0115"><xref rid="fig0005" ref-type="fig">Fig. 1</xref> depicts a general view of FESTIval, which is detailed as follows.<fig id="fig0005"><label>Fig. 1</label><caption><p>The overview of FESTIval.</p></caption><alt-text id="at0005">Fig. 1</alt-text><graphic xlink:href="gr1"/></fig></p>
      <p id="par0120"><italic>Workloads</italic>. FESTIval allows the creation and execution of user-defined workloads by using the Structured Query Language (SQL). By using the FESTIval's SQL functions, a user (e.g., database administrator, researcher, and software developer) is able to define the sequence of index operations that should be executed and then analyzed. Index operations include insertions, updates, and deletions of spatial objects, and the execution of spatial queries (i.e., <italic>general and atomic operations</italic>). Further, users can also determine the exact moment that statistical data should be collected and stored in the FESTIval's data schema (i.e., <italic>auxiliary operations</italic>).</p>
      <p id="par0125"><italic>Storage device</italic>. It stores three main elements: (i) the spatial indices, (ii) the spatial datasets, and (iii) the FESTIval's data schema. The spatial indices are handled by FESTIval during the execution of workloads, whereas the spatial datasets provide spatial objects to these indices. The FESTIval's data schema stores information of spatial datasets, parameters used by spatial indices, and statistical data of executed workloads. Collected statistical data can be used in mathematical models to measure the performance of spatial indices, considering employed parameter values, characteristics of the spatial dataset, and the employed storage device.</p>
      <sec id="sec0025">
        <title>The FESTIval's data schema</title>
        <p id="par0130"><xref rid="fig0010" ref-type="fig">Fig. 2</xref> depicts the FESTIval's logical data schema, called <italic>fds</italic>. In this figure, we only show the primary and foreign keys of the relational tables to illustrate their relationships. <xref rid="tbl0005" ref-type="table">Table 1</xref> enriches this figure by listing the attributes of each relational table. Here, we only provide a general view of this schema, detailing the most important tables only. The complete description can be found at the FESTIval's documentation.<fig id="fig0010"><label>Fig. 2</label><caption><p>The FESTIval's logical data schema. This figure shows only the primary and foreign keys of the relational tables to illustrate the relationships among the tables. Primary keys are highlighted. The relationship between a primary key and a foreign key is represented by a directed arrow from the primary key to the foreign key. <xref rid="tbl0005" ref-type="table">Table 1</xref> details the attributes of each relational table of this figure.</p></caption><alt-text id="at0010">Fig. 2</alt-text><graphic xlink:href="gr2"/></fig><table-wrap position="float" id="tbl0005"><label>Table 1</label><caption><p>Attributes of each relational table of the FESTIval's data schema.</p></caption><alt-text id="at0025">Table 1</alt-text><table frame="hsides" rules="groups"><thead><tr><th align="left">Relational table</th><th align="left">Attributes</th></tr></thead><tbody><tr><td align="left">Source</td><td align="left">src_id, schema_name, table_name, column_name, pk_name</td></tr><tr><td align="left">BasicConfiguration</td><td align="left">bc_id, ss_id, page_size, io_access, refinement_type</td></tr><tr><td align="left">StorageSystem</td><td align="left">ss_id, storage_system, description</td></tr><tr><td align="left">FlashDBSimConfiguration</td><td align="left">ss_id, ftl_id, vfd_id</td></tr><tr><td align="left">VirtualFlashDevice</td><td align="left">vfd_id, nand_device_type, block_count, page_count_per_block, page_size1, page_size2, erase_limitation, read_random_time, read_serial_time, program_time, erase_time</td></tr><tr><td align="left">FlashTranslationLayer</td><td align="left">ftl_id, ftl_type, map_list_size, wear_leveling_threshold</td></tr><tr><td align="left">BufferConfiguration</td><td align="left">buf_id, buf_type, buf_size</td></tr><tr><td align="left">SpecializedConfiguration</td><td align="left">sc_id, description</td></tr><tr><td align="left">RTreeConfiguration</td><td align="left">sc_id, or_id, split_type</td></tr><tr><td align="left">RStarTreeConfiguration</td><td align="left">sc_id, or_id, reinsertion_perc_internal_nodes, reinsertion_perc_leaf_nodes, reinsertion_type, max_neighbors_exam</td></tr><tr><td align="left">HilbertRTreeConfiguration</td><td align="left">sc_id, or_id, order_splitting_policy</td></tr><tr><td align="left">FORTreeConfiguration</td><td align="left">sc_id, or_id, buffer_size, flushing_unit_size, ration_flushing, x, y</td></tr><tr><td align="left">FASTConfiguration</td><td align="left">sc_id, index_type, db_sc_id, buffer_size, flushing_unit_size, flushing_policy, log_size</td></tr><tr><td align="left">eFINDConfiguration</td><td align="left">sc_id, index_type, db_sc_id, buffer_size, read_buffer_perc, temporal_control_policy, read_temporal_control_perc, write_temporal_control_size, write_temporal_control_mindist, write_temporal_control_stride, timestamp_percentage, flushing_unit_size, flushing_policy, read_buffer_policy, log_size</td></tr><tr><td align="left">OccupancyRate</td><td align="left">or_id, min_fill_int_nodes, min_fill_leaf_nodes, max_fill_int_nodes, max_fill_leaf_nodes</td></tr><tr><td align="left">IndexConfiguration</td><td align="left">config_id, src_id, bc_id, sc_id, buf_id</td></tr><tr><td align="left">SpatialIndex</td><td align="left">idx_id, config_id, idx_name, idx_path, idx_creation, idx_last_mod</td></tr><tr><td align="left">Execution<xref rid="tblfn0005" ref-type="table-fn">a</xref></td><td align="left">pe_id, idx_id, execution_name, total_time, index_time, read_time, write_time, split_time, reads_num, writes_num, total_cpu_time, index_cpu_time, read_cpu_time, write_cpu_time, split_cpu_time,...</td></tr><tr><td align="left">ReadWriteOrder</td><td align="left">pe_id, rw_order, op_type, op_timestamp, page_id</td></tr><tr><td align="left">FlashSimulatorStatistics</td><td align="left">pe_id, read_count, write_count, erase_count, read_latency, write_latency, erase_latency</td></tr><tr><td align="left">IndexSnapshot<xref rid="tblfn0005" ref-type="table-fn">a</xref></td><td align="left">pe_id, height, num_int_nodes, num_leaf_nodes, num_entries_int_nodes, num_entries_leaf_nodes, avg_num_entries_pnode, avg_coverage_area_pnode,...</td></tr><tr><td align="left">PrintIndex</td><td align="left">pe_id, node_id, geom, elem_position, node_height</td></tr></tbody></table><table-wrap-foot><fn><p>All attributes are fully described in the FESTIval's documentation at <ext-link ext-link-type="uri" xlink:href="https://accarniel.github.io/FESTIval/" id="intr0005">https://accarniel.github.io/FESTIval/</ext-link>.</p></fn></table-wrap-foot><table-wrap-foot><fn id="tblfn0005"><label>a</label><p id="npar0030">Attributes were suppressed.</p></fn></table-wrap-foot></table-wrap></p>
        <p id="par0135">There are two categories of data managed by FESTIval: (i) configuration of a spatial index, and (ii) storage of statistical data.</p>
        <p id="par0140"><italic>Configuration of a spatial index</italic>. It consists of four components. The first component is the <italic>spatial dataset</italic>, which is the source of spatial objects to be used by a spatial index. A spatial dataset is a PostgreSQL relational table that contains a column storing spatial objects. The needed information of spatial datasets is stored in the table Source. To insert a new spatial dataset in the FESTIval's data schema, we should provide its PostgreSQL schema name (<italic>schema_name</italic>), table name (<italic>table_name</italic>), column name that contains spatial objects (<italic>column_name</italic>), and the primary key of this table (<italic>pk_name</italic>). Hence, each tuple in Source represents a dataset that can be indexed. By using this strategy, users can use any spatial dataset in experiments. This fact contributes to providing a versatile platform to conduct empirical analyses.</p>
        <p id="par0145">The second component of a configuration refers to <italic>basic parameters</italic> that are employed by any spatial index. Basic parameters are stored in the table BasicConfiguration, which contains the storage system that stores the index (<italic>ss_id</italic>), the page size in bytes that an index page should have (<italic>page_size</italic>), the method of access to the storage device (<italic>io_access</italic>), and the library used in the refinement step in the spatial query processing (<italic>refinement_type</italic>). Currently, the attribute <italic>io_access</italic> is either the classical access to storage devices (i.e., using the <italic>libio.h</italic> in C) or the DIRECT I/O (i.e., using the <italic>fcntl.h</italic> in C) that allows us to bypass the caching system of reads and writes of the operating system; while the attribute <italic>refinement_type</italic> is either the use of the GEOS library or the use of PostGIS algorithms. As for the storage system, related data is stored in the table StorageSystem. This table contains the type of the storage device (<italic>storage_system</italic>) and its description (<italic>description</italic>). It can be HDDs, SSDs, or simulated flash memories using Flash-DBSim. For simulated flash memories, the primary key of the StorageSystem is linked to the table FlashDBSimConfiguration, which is an aggregated table of two needed information of the Flash-DBSim: (i) the flash device (table VirtualFlashDevice), and (ii) the flash translation layer (table FlashTranslationLayer). The attributes of these tables correspond to the same parameters required by Flash-DBSim, represented by the table FlashDBSimConfiguration, to simulate a flash memory as detailed in <xref rid="bib0120" ref-type="bibr">[24]</xref> and in the FESTIval's documentation.</p>
        <p id="par0150">The third component of a configuration refers to the <italic>generic buffer management</italic> of the spatial index. A generic buffer manager is a general-purpose method employed to reduce the number of accesses to the storage device; thus, any spatial index can employ a buffer manager. Parameters of the generic buffer manager are stored in the table BufferConfiguration. The attributes of this table consist of the size of the buffer in bytes (<italic>buf_size</italic>), and the type of the page replacement algorithm (<italic>buf_type</italic>). Currently, FESTIval provides support for the following buffer managers: LRU <xref rid="bib0130" ref-type="bibr">[26]</xref>, LRU storing preferentially the highest nodes of the tree, called HLRU (as used in <xref rid="bib0090" ref-type="bibr">[18]</xref>), and the two versions of 2Q <xref rid="bib0135" ref-type="bibr">[27]</xref>. The management of generic buffers flushes modifications whenever their size is reached. The size of the buffer of a spatial index equal to 0 means that the spatial index has not a general buffer manager. This is the case if the spatial index has its own specialized buffer manager. For instance, flash-aware spatial indices (e.g., FAST-based and eFIND-based indices) have specialized buffer managers with specific parameter values (see below). Although it is possible to also employ generic buffer managers in flash-aware spatial indices, performance evaluations usually do not employ general buffer managers when analyzing the performance of flash-aware spatial indices <xref rid="bib0080" ref-type="bibr">[16]</xref>, <xref rid="bib0085" ref-type="bibr">[17]</xref>, <xref rid="bib0090" ref-type="bibr">[18]</xref>, <xref rid="bib0095" ref-type="bibr">[19]</xref>, <xref rid="bib0140" ref-type="bibr">[28]</xref>.</p>
        <p id="par0155">Finally, the fourth component of a configuration refers to <italic>specific parameters</italic> that are used by an index. That is, each spatial index has its own set of parameters, and the table SpecializedConfiguration generalizes this concept by providing a unique identifier for this specific set of parameters. For instance, the R-tree permits to specify its split algorithm (<italic>split_type</italic>), which can be exponential, quadratic, and linear <xref rid="bib0015" ref-type="bibr">[3]</xref>. Other split algorithms are also conceivable, such as the Greene-split <xref rid="bib0145" ref-type="bibr">[29]</xref> and the AngTan-split <xref rid="bib0150" ref-type="bibr">[30]</xref>. This specific information is stored in the specialized table RTreeConfiguration and for each entry in this table, there is also an entry in the table SpecializedConfiguration that includes a short description (<italic>description</italic>). This strategy is similarly employed to store the specific parameters of other supported indices, that is, the R*-tree (table RStarTreeConfiguration), the Hilbert R-tree (table HilbertRTreeConfiguration), the FOR-tree (table FORTreeConfiguration), FAST-based indices (table FASTConfiguration), and eFIND-based indices (table eFINDConfiguration). The attributes of these tables are based on the corresponding parameters of their indices as specified in their original research papers. For FAST- and eFIND-based spatial indices, the use of the attribute <italic>db_sc_id</italic> that refers to the identifier of an entry of the SpecializedConfiguration allows us to combine the specific parameters of the underlying index pointed by this attribute and the specific parameters of FAST and eFIND.</p>
        <p id="par0160">In addition, we can vary the <italic>occupancy rate</italic> (table OccupancyRate) of index pages. This occupancy rate is informed by the attribute <italic>or_id</italic> that is present in the tables storing specific parameters of indices. We can specify the maximum capacity of leaf and internal nodes by using percentage values <italic>max_fill_leaf_nodes</italic> and <italic>max_fill_int_nodes</italic>, respectively. These percentage values specify how much space from the page size should be allocated to accommodate node entries. We can also specify the minimum capacity of leaf and internal nodes using respectively the attributes <italic>min_fill_leaf_nodes</italic> and <italic>min_fill_int_nodes</italic>, indicating the minimum occupancy rate considering the total available space (calculated from the maximum capacity of the nodes).</p>
        <p id="par0165">FESTIval provides an SQL script, named <italic>festival-inserts.sql</italic>, that contains SQL INSERT INTO statements for inserting default parameter values into all the aforementioned relational tables related to the configuration of spatial indices. As for the default spatial datasets, they can be downloaded at <ext-link ext-link-type="uri" xlink:href="https://github.com/accarniel/FESTIval/wiki/" id="intr0030">https://github.com/accarniel/FESTIval/wiki/</ext-link> and a detailed specification of them is also given in <xref rid="bib0155" ref-type="bibr">[31]</xref>. Users are also able to insert new values to the aforementioned tables by executing SQL INSERT INTO statements. The informed values are checked by using triggers and SQL CHECK constraints in order to ensure the consistency of the parameters. For instance, it is impossible to insert a new R*-tree configuration that has a reinsertion type not defined in the original R*-tree paper.</p>
        <p id="par0170">The combination of the values of the attributes <italic>src_id</italic>, <italic>bc_id</italic>, <italic>sc_id</italic>, and <italic>buf_id</italic> of the tables Source, BasicConfiguration, SpecializedConfiguration, and BufferConfiguration, respectively, creates one spatial index configuration (table IndexConfiguration). Then, a spatial index (table SpatialIndex) consists of a configuration from the table IndexConfiguration (<italic>config_id</italic>) and other specific data, such as the name of the index (<italic>idx_name</italic>), the directory storing the index file (<italic>idx_path</italic>), the time of its creation (<italic>idx_creation</italic>), and the time of its last modification (<italic>idx_last_mod</italic>). Note that multiple spatial indices might have the same configurations; however, their states (i.e., content) might be different because of the executed operations. Only FESTIval insert entries into the tables IndexConfiguration and SpatialIndex, that is, users should not manually insert entries into these relational tables.</p>
        <p id="par0175"><italic>Storage of statistical data</italic>. FESTIval collects and stores two types of statistical data. The first type refers to <italic>statistical data collected from the execution of index operations</italic>. This data is maintained in the table Execution, which is a non-normalized table in order to avoid excessive joins when retrieving performance results. Each entry in this table means that at least one index operation like insertion, deletion, and query was performed. To identify the type of execution, the user can set a name (<italic>execution_name</italic>). This aspect is further discussed in the next sections of this article. Here, we only provide a general view of the main attributes of the table Execution: the total processing time of the index (<italic>index_time</italic>), the time spent to perform reads and writes (<italic>read_time</italic> and <italic>write_time</italic>, respectively), the processing time to execute splitting operations (<italic>split_time</italic>), the number of reads and writes (<italic>reads_num</italic> and <italic>writes_num</italic>, respectively), the CPU time of processing specific operations (e.g., <italic>index_cpu_time</italic>), and other attributes. Note that the total processing time of the index considers other times, such as the processing time of splits, reads, and writes. By collecting and storing detailed statistical data, FESTIval allows us to better analyze the composition of the total processing time (<italic>total_time</italic>). Further, FESTIval stores the order of reads and writes performed on the storage device (table ReadWriteOrder). To this end, a sequential identifier of the operation (<italic>rw_order</italic>), the type of operation (<italic>op_type</italic>, which can be either read or write), the moment that the operation was performed (<italic>op_timestamp</italic>), and the identifier of the index page (<italic>page_id</italic>) are stored. The order of reads and writes is optionally collected and is useful to discover data access patterns. Finally, if the executed workload employed a simulated flash memory, statistical data collected by Flash-DBSim are stored in the table FlashSimulatorStatistics. This data includes the number of read, writes, and erases actually performed on the simulated flash memory (<italic>read_count</italic>, <italic>write_count</italic>, and <italic>erase_count</italic>, respectively).</p>
        <p id="par0180">The second type of collected statistical data refers to <italic>the structure of the spatial index</italic>. This data is stored in the table IndexSnapshot. Each entry in this table allows us to analyze the structure of an index after executing operations that modify its structure, such as insertions and deletions. Here, we only provide a general view of the main attributes of the table IndexSnapshot: the height of the index (<italic>height</italic>), the number of internal and leaf nodes (<italic>num_int_nodes</italic> and <italic>num_leaf_nodes</italic>, respectively), the number of entries in internal and leaf nodes (<italic>num_entries_int_nodes</italic> and <italic>num_entries_leaf_nodes</italic>, respectively), summary data per node (e.g., the average number of entries – <italic>avg_num_entries_pnode</italic>), and other related attributes. Further, FESTIval provides the table PrintIndex that allows us to graphically visualize a spatial index by using a GIS, such as QGIS<xref rid="fn0020" ref-type="fn">4</xref> and ArcGIS.<xref rid="fn0025" ref-type="fn">5</xref> To this end, FESTIval stores data related to each node entry of the spatial index, such as position in the node (<italic>elem_position</italic>), its minimum bounding rectangle (MBR) (<italic>geom</italic>), height of the node (<italic>node_height</italic>), and the identifier of the node (<italic>node_id</italic>). This allows us to understand the structure of a spatial index for different purposes, such as educational.</p>
      </sec>
      <sec id="sec0030">
        <title>The FESTIval's operations</title>
        <p id="par0185">FESTIval provides a set of SQL functions that allows users to create and execute workloads by using a common design. Each SQL function has the prefix <italic>FT_</italic> and calls one C function internally implemented in the FESTIval's internal library that is responsible for performing the desired processing. Hence, an index can be seen as an <italic>abstract data type</italic>
<xref rid="bib0160" ref-type="bibr">[32]</xref> that has common parameters (i.e., its configuration) and a set of operations (i.e., SQL functions). The main advantage of this strategy is that complex implementations are hidden from users, who now can manage and test different indices under the same environment (i.e., using the same SQL functions).</p>
        <p id="par0190">There are three types of operations: (i) general operations, (ii) auxiliary operations, and (iii) atomic operations. They are described as follows.</p>
        <p id="par0195"><italic>General operations</italic>. They are responsible for handling index structures. Since FESTIval provides a common design, the same SQL function can be used for any type of index. We detail each general operation of FESTIval as follows:<list list-type="simple" id="lis0015"><list-item id="lsti0040"><label>1.</label><p id="par0200">boolean FT_CreateEmptySpatialIndex(integer index_type, text apath, integer src_id, integer bc_id, integer sc_id, integer buf_id);</p></list-item><list-item id="lsti0045"><label>2.</label><p id="par0205">boolean FT_Insert(text apath, integer pointer, geometry geom);</p></list-item><list-item id="lsti0050"><label>3.</label><p id="par0210">boolean FT_Delete(text apath, integer pointer, geometry geom);</p></list-item><list-item id="lsti0055"><label>4.</label><p id="par0215">boolean FT_Update(text apath, integer old_pointer, geometry old_geom, integer new_pointer, geometry new_geom);</p></list-item><list-item id="lsti0060"><label>5.</label><p id="par0220">setof query_result FT_QuerySpatialIndex(text apath, integer query_type, geometry search_obj, integer predicate, integer proc_option=1);</p></list-item><list-item id="lsti0065"><label>6.</label><p id="par0225">boolean FT_ApplyAllModificationsForFAI(text apath);</p></list-item><list-item id="lsti0070"><label>7.</label><p id="par0230">boolean FT_ApplyAllModificationsFromBuffer(text apath);</p></list-item></list></p>
        <p id="par0235">All these functions have a common parameter, <italic>apath</italic>, that indicates the absolute path of the index file. The first SQL function creates an empty spatial index (i.e., without any spatial objects) according to a set of parameters. It returns <italic>true</italic> if the index is successfully created, and <italic>false</italic> otherwise. The parameter <italic>index_type</italic> is an identifier that specifies the type of index to be created. Currently, FESTIval employs integer values from 1 to 10 to respectively represent the R-tree, the R*-tree, the Hilbert R-tree, the FAST R-tree, the FAST R*-tree, the FAST Hilbert R-tree, the FOR-tree, the eFIND R-tree, the eFIND R*-tree, and the eFIND Hilbert R-tree. The parameter <italic>src_id</italic> is a primary key value of the table Source that binds the spatial objects to the index. The parameters <italic>bc_id</italic>, <italic>sc_id</italic>, and <italic>buf_id</italic> specify the basic, specific, and buffer parameters of the spatial index by using the primary key values originated from the tables BasicConfiguration, SpecializedConfiguration, and BufferConfiguration, respectively. Since the specific parameters refer to only one type of index, FESTIval checks if the index to be constructed (i.e., the parameter <italic>index_type</italic>) is compatible with the values of <italic>sc_id</italic>. In summary, <italic>FT_CreateEmptySpatialIndex</italic> prepares all internal structures needed to handle a spatial index.</p>
        <p id="par0240">The three SQL functions <italic>FT_Insert</italic>, <italic>FT_Delete</italic>, and <italic>FT_Update</italic> execute operations that modify the index structure by respectively inserting, deleting, and updating spatial objects. They return <italic>true</italic> if the modification is successfully executed, and <italic>false</italic> otherwise. To insert and delete spatial objects, two additional parameters are needed: <italic>pointer</italic> and <italic>geom</italic>. The parameter <italic>pointer</italic> is the primary key value of the spatial object being inserted (or deleted), while the parameter <italic>geom</italic> is the geometry representing the spatial object. Spatial objects handled by FESTIval are PostGIS objects (i.e., <italic>geometry</italic> objects), guaranteeing a full integration of FESTIval with spatial applications that use PostGIS. To update a spatial object, <italic>FT_Update</italic> requires information about the spatial object being updated (parameters <italic>old_pointer</italic> and <italic>old_geom</italic>) to a new value (parameters <italic>new_pointer</italic> and <italic>new_geom</italic>). In general, an update is an atomic operation that sequentially deletes the old spatial object (and its pointer) and then inserts the new spatial object (and its pointer).</p>
        <p id="par0245">To apply the functions <italic>FT_Insert</italic>, <italic>FT_Delete</italic>, and <italic>FT_Update</italic>, it is needed to first create the index file (i.e., <italic>apath</italic>) by using the function <italic>FT_CreateEmptySpatialIndex</italic>. Further, since a spatial index is related to a specific dataset, it is important to apply the corresponding modification firstly in its dataset. For instance, add a new spatial object with its primary key value as a new tuple in the indexed dataset by using an SQL INSERT INTO statement before calling <italic>FT_Insert</italic>. FESTIval does not perform any changes in the dataset; thus, the user should perform modifications in the dataset as needed. The main advantage of this treatment is that we can isolate the time processing of a modification performed on the spatial index from the modification performed on the dataset.</p>
        <p id="par0250">The fifth SQL function executes spatial queries. It is a set-returning function of the PostgreSQL. It returns a set of <italic>query_result</italic> rows, formed by a primary key value (<italic>id</italic>) and a spatial object (<italic>geom</italic>) of the indexed dataset. The parameter <italic>query_type</italic> specifies the type of spatial query to be processed. There are many types of spatial queries proposed in the literature <xref rid="bib0005" ref-type="bibr">[1]</xref>, <xref rid="bib0010" ref-type="bibr">[2]</xref>. FESTIval provides support for <italic>spatial selections</italic> (<italic>query_type</italic>=1), <italic>range queries</italic> (<italic>query_type</italic>=2), and <italic>point queries</italic> (<italic>query_type</italic>=3). Spatial selection is a general type of query that returns a set of spatial objects that satisfy some topological predicate (e.g., overlap, inside) for a given spatial object, called <italic>search object</italic>. Range query is similar to spatial selection but considering the search object as a rectangular-shaped object. Point query specializes spatial selection by allowing only the use of <italic>intersects</italic> as the topological predicate and points as search objects. The parameter <italic>search_obj</italic> is the search object, which is a PostGIS object. Some restrictions with respect to the geometric format of <italic>search_obj</italic> may be applicable. If <italic>query_type</italic> is equal to 2, the MBR of <italic>search_obj</italic> is considered. If <italic>query_type</italic> is equal to 3, <italic>search_obj</italic> must be a simple point object. The parameter <italic>predicate</italic> specifies the topological predicate <xref rid="bib0165" ref-type="bibr">[33]</xref> to be used in the spatial query. It can assume the following topological predicates: <italic>intersects</italic>, <italic>overlap</italic>, <italic>disjoint</italic>, <italic>meet</italic>, <italic>inside</italic>, <italic>coveredBy</italic>, <italic>contains</italic>, <italic>covers</italic>, and <italic>equals</italic> (they are integer values from 1 to 8, respectively). Finally, the last parameter <italic>proc_option</italic> refers to the type of the result of the spatial query, which is often executed by using two steps, filter and refinement <xref rid="bib0005" ref-type="bibr">[1]</xref>. If <italic>proc_option</italic> is equal to 1, its default value, <italic>FT_QuerySpatialIndex</italic> yields the final result of the query, that is, it executes the filter and refinement steps. In this case, it is important to maintain the spatial index compatible with the indexed dataset, as previously discussed. If <italic>proc_option</italic> is equal to 2, <italic>FT_QuerySpatialIndex</italic> returns the candidates of the query returned by the filter step only.</p>
        <p id="par0255">The last two SQL functions are responsible for executing a flushing operation that writes to the storage device all buffered index modifications. They return <italic>true</italic> if the flushing operation is successfully executed, and <italic>false</italic> otherwise. <italic>FT_ApplyAllModificationsForFAI</italic> flushes all buffered modifications stored in the specialized buffers of flash-aware spatial indices (i.e., eFIND-based indices), while <italic>FT_ApplyAllModificationsFromBuffer</italic> flushes all buffered modifications stored in the generic buffers (e.g., LRU, 2Q). These SQL functions write all modifications contained in the main memory, cleaning the corresponding buffer.</p>
        <p id="par0260"><italic>Auxiliary operations</italic>. They are designed for helping the process of creating workloads. They are mainly related to collecting and storing statistical data. We detail each auxiliary operation of FESTIval by providing its synopsis together with its short description as follows:<list list-type="simple" id="lis0020"><list-item id="lsti0075"><label>1.</label><p id="par0265">boolean FT_StartCollectStatistics(boolean rw=false);</p></list-item><list-item id="lsti0080"><label>2.</label><p id="par0270">boolean FT_CollectOrderOfReadWrite();</p></list-item><list-item id="lsti0085"><label>3.</label><p id="par0275">integer FT_StoreStatisticalData(text apath, integer statistic_option=1, integer loc_stat_data=1, text file=NULL);</p></list-item><list-item id="lsti0090"><label>4.</label><p id="par0280">boolean FT_StoreIndexSnapshot(text apath, integer execution_id, boolean print_index=false, integer loc_stat_data=1, text file=NULL);</p></list-item><list-item id="lsti0095"><label>5.</label><p id="par0285">boolean FT_SetExecutionName(text execution_name, integer loc_stat_data=1);</p></list-item></list></p>
        <p id="par0290">The functions returning Boolean values yield <italic>true</italic> if the processing is successfully performed, and <italic>false</italic> otherwise. The first auxiliary operation is the SQL function <italic>FT_StartCollectStatistics</italic>. After invoking this function, FESTIval starts to collect statistical data in the main memory. If the parameter <italic>rw</italic> is <italic>false</italic>, its default value, the order of reads and writes made on the storage device are not be collected. Otherwise, this order is collected, requiring extra computation. When an user performs the SQL function <italic>FT_StartCollectStatistics</italic>(<italic>false</italic>), and afterwards wants to collect the order of reads and writes, the user should call the SQL function <italic>FT_CollectOrderOfReadWrite</italic>(). This allows users to collect the order of reads and writes only for specific index operations since this collection is expensive; but it is important to understand access patterns.</p>
        <p id="par0295">Collected in-memory statistical data are only stored in the FESTIval's data schema after calling the SQL function <italic>FT_StoreStatisticalData</italic>, which returns an integer value that consists of the primary key value of the row inserted into the table Execution (i.e., the value of the column <italic>pe_id</italic>). The parameter <italic>apath</italic> is the absolute path of the index file and the parameter <italic>statistic_option</italic> refers to the type of statistical data that is stored. Independently of the value of <italic>statistic_option</italic>, FESTIval stores typical statistical data about the executed index operations (i.e., the attributes of the table Execution). If <italic>statistic_option</italic> is equal to 1, its default value, FESTIval inserts a new tuple in the table Execution only, without any other additional information. Optionally, FESTIval stores a new tuple in the table IndexSnapshot (<italic>statistic_option</italic>=2 or <italic>statistic_option</italic>=4), requiring the traversal of all index pages in order to collect statistical data related to the index structure. Further, FESTIval stores new tuples in the table PrintIndex (<italic>statistic_option</italic>=3 or <italic>statistic_option</italic>=4), also requiring the traversal of all index pages to visualize the index structure. The cost of traversing the tree is not take into account when collecting typical statistical data. Storing data in the tables IndexSnapshot and PrintIndex is particularly useful after the execution of operations that modify the index structure (e.g., insertions, deletions, and updates). As for the parameter <italic>loc_stat_data</italic>, it defines where (i.e., the location) the statistical data should be stored. If its value is equal to 1, its default value, the statistical data is stored directly in the FESTIval's data schema. If its value is equal to 2, the statistical data is stored in an SQL file that can be latter loaded into the FESTIval's data schema. In this case, the absolute path of this SQL file should be informed by using the parameter <italic>file</italic>. Particularly, setting the value 2 for <italic>loc_stat_data</italic> is useful to avoid reads and writes performed on the FESTIval's data schema during the execution of a workload. This aspect is important for SSDs because of the interference between reads and writes <xref rid="bib0065" ref-type="bibr">[13]</xref>, <xref rid="bib0070" ref-type="bibr">[14]</xref>. Hence, the statistical data can be first stored in a file located in other storage device (e.g., an HDD). Finally, at any moment, the user is also able to collect and store statistical data related to the index structure by using the SQL function <italic>FT_StoreIndexSnapshot</italic>. It has almost the same parameters as the SQL function <italic>FT_StoreStatisticalData</italic>, expect for the parameters <italic>execution_id</italic> and <italic>print_index</italic>. The parameter <italic>execution_id</italic> is the primary key value of the table Execution that links the collected statistical data with an execution, while the parameter <italic>print_index</italic> indicates whether the structure of index should be collected and stored in the table PrintIndex or not.</p>
        <p id="par0300">The last auxiliary operation is the SQL function <italic>FT_SetExecutionName</italic>. Its main applicability is to set a name for the execution of a workload through the parameter <italic>execution_name</italic>. By creating workloads with this function, users are able to easily retrieve statistical data of executed workloads by issuing SQL queries on the table Execution. As previously described, the parameter <italic>loc_stat_data</italic> defines where the statistical data should be stored.</p>
        <p id="par0305"><italic>Atomic operations</italic>. They are combinations of some aforementioned functions and help the construction of workloads. An atomic operation is an SQL function that is executed as a unique and indivisible operation, following the principles of the atomicity of database systems <xref rid="bib0170" ref-type="bibr">[34]</xref>. That is, if any function inside an atomic operation fails, the entire atomic operation fails. In general, an atomic operation is formed by the following sequence of operations: (i) <italic>FT_StartCollectStatistics</italic>, (ii) the requested operation, and (iii) <italic>FT_StoreStatisticalData</italic>. The atomic operations of FESTIval start with <italic>FT_A</italic> and are specified as follows:<list list-type="simple" id="lis0025"><list-item id="lsti0100"><label>1.</label><p id="par0310">integer FT_AInsert(text apath, integer pointer, geometry geom, integer statistic_option=1, integer loc_stat_data=1, text file=NULL);</p></list-item><list-item id="lsti0105"><label>2.</label><p id="par0315">integer FT_ADelete(text apath, integer pointer, geometry geom, integer statistic_option=1, integer loc_stat_data=1, text file=NULL);</p></list-item><list-item id="lsti0110"><label>3.</label><p id="par0320">integer FT_AUpdate(text apath, integer old_pointer, geometry old_geom, integer new_pointer, geometry new_geom, integer statistic_option=1, integer loc_stat_data=1, text file=NULL);</p></list-item><list-item id="lsti0115"><label>4.</label><p id="par0325">setof query_result FT_AQuerySpatialIndex(text apath, integer query_type, geometry search_obj, integer predicate, integer proc_option=1, integer statistic_option=1, integer loc_stat_data=1, text file=NULL);</p></list-item></list></p>
        <p id="par0330">Algorithm 1 depicts the source code of the SQL function <italic>FT_AInsert</italic>, which illustrates a first usage of FESTIval's operations. The remaining atomic operations have very similar codifications. In fact, <italic>FT_AInsert</italic>, <italic>FT_ADelete</italic>, <italic>FT_AUpdate</italic>, and <italic>FT_AQuerySpatialIndex</italic> are atomic versions of the functions that respectively insert, delete, update, and query spatial objects from a spatial index. They combine the parameters of the SQL function responsible for executing the index operation and the parameters of <italic>FT_StoreStatisticalData</italic>. They assume that the order of reads and writes is not collected. Hence, collecting this kind of information requires the invocation of the SQL function <italic>FT_CollectOrderOfReadWrite</italic> before executing an atomic operation.<statement id="enun0005"><label>Algorithm 1</label><p id="par0335">The source code of the SQL function <italic>FT_AInsert</italic>, an atomic operation of FESTIval</p></statement></p>
        <p id="par0340">
          <fig id="fig0030">
            <graphic xlink:href="fx2"/>
          </fig>
        </p>
      </sec>
      <sec id="sec0035">
        <title>Creating and executing workloads</title>
        <p id="par0345">FESTIval provides a common design to create workloads. A workload consists of a sequence of index operations and can be created by using the SQL Procedural Language of the PostgreSQL (PL/pgSQL). Hence, users create workloads as user-defined functions in PL/pgSQL and execute them in SQL SELECT statements. Here, we illustrate two examples of workload and describe different scenarios of capturing performance results after executing a workload.</p>
        <p id="par0350">The first workload, depicted in Algorithm 2, executes a sequential insertion of spatial objects stored in a given dataset. That is, it constructs a spatial index by inserting spatial objects one-by-one. Due to the importance of this workload, FESTIval includes this function in its source code. The inputs of <italic>FT_CreateSpatialIndex</italic> are similar to those of the aforementioned SQL functions, except for the Boolean parameters <italic>apply_fai</italic> and <italic>apply_stdbuffer</italic> (line 1) that are employed to decide whether flushing operations should be performed in the end of the index creation. First, <italic>FT_CreateSpatialIndex</italic> extracts needed data about the dataset that is being indexed (line 10). This includes the names of its schema, table, column storing spatial objects, and primary key column. Then, the total number of rows of this table is retrieved (line 11) to identify how many spatial objects should be inserted into the spatial index. Afterwards, statistical data should be collected when executing the next index operations (line 12). The first index operation is the creation of an empty spatial index (line 13). Next, a sequence of insertions is made (lines 15–25). To better manage the main memory, the workload retrieves 100,000 spatial objects by time from the dataset (lines 16 and 17). The loop stops when all spatial objects are inserted into the spatial index (lines 19–21). In the sequence, the workload checks whether a flushing operation should be made in order to write all the remaining in-memory modifications after the insertions (lines 26–31). This includes the specialized in-memory buffer managers of flash-aware spatial indices (lines 26–28), and general buffer managers (lines 29–31). Finally, the workload stores statistical data related to the creation of the spatial index (line 32).<statement id="enun0010"><label>Algorithm 2</label><p id="par0355">The workload written in PL/pgSQL for creating spatial indices</p></statement></p>
        <p id="par0360">
          <fig id="fig0035">
            <graphic xlink:href="fx3"/>
          </fig>
        </p>
        <p id="par0365">Before introducing the second workload, we show how the workload depicted in Algorithm 2 can be employed and how users can collect performance results. For this, we show a set of SQL statements that can be incrementally executed in order to reproduce our example.</p>
        <p id="par0370">In order to provide a name for the execution of <italic>FT_CreateSpatialIndex</italic>, we need to first execute an SQL SELECT statement that invokes <italic>FT_SetExecutionName</italic>, as shown below:<list list-type="simple" id="lis0030"><list-item id="lsti0120"><p id="par0375">SELECT FT_SetExecutionName(‘Creating R-tree on brazil_points2017’);</p></list-item></list></p>
        <p id="par0380">Then, an index can be created by executing <italic>FT_CreateSpatialIndex</italic>. The next SQL SELECT statement creates an R-tree, called <italic>linear_rtree</italic> and stored in <italic>/opt/</italic>, that indexes the spatial objects stored in the dataset identified by <italic>src_id</italic>=7 and with the parameter values <italic>bc_id</italic>=6, <italic>sc_id</italic>=18, and <italic>buf_id</italic>=4. These values are included in <italic>festival-inserts.sql</italic>, which can be loaded into the FESTIval's data schema after installing FESTIval. More precisely, this command builds an R-tree with page (node) size of 4 KB, employing the linear splitting algorithm, and a general LRU buffer of 512 KB. The indexed spatial objects are from the dataset named <italic>brazil_points2017</italic>
<xref rid="bib0155" ref-type="bibr">[31]</xref>. Since this command does not change default values for arguments of <italic>FT_CreateSpatialIndex</italic>, it does not flush any modification remaining in the buffer after the insertions, and it stores statistical data only for the table Execution that is directly inserted into the FESTIval's data schema.<list list-type="simple" id="lis0035"><list-item id="lsti0125"><p id="par0385">SELECT FT_CreateSpatialIndex(1, ‘/opt/linear_rtree’, 7, 6, 18, 4);</p></list-item></list></p>
        <p id="par0390">By issuing SQL SELECT statements, we are also able to retrieve and analyze performance results. For instance, the following command returns the required index time to build the previous R-tree (i.e., <italic>linear_rtree</italic>):<list list-type="simple" id="lis0040"><list-item id="lsti0130"><p id="par0395">SELECT index_time</p></list-item><list-item id="lsti0135"><p id="par0400">FROM fds.execution</p></list-item><list-item id="lsti0140"><p id="par0405">WHERE execution_name = ‘Creating R-tree on brazil_points2017’;</p></list-item></list></p>
        <p id="par0410">Note the importance of setting a name for the execution, which can be used to retrieve performance results of executed workloads. The previous SQL SELECT statement could also include other columns containing statistical values. For instance, the next SQL SELECT statement yields the number of writes and reads required by the creation of the previous R-tree (i.e., <italic>linear_rtree</italic>).<list list-type="simple" id="lis0045"><list-item id="lsti0145"><p id="par0415">SELECT reads_num, writes_num</p></list-item><list-item id="lsti0150"><p id="par0420">FROM fds.execution</p></list-item><list-item id="lsti0155"><p id="par0425">WHERE execution_name = ‘Creating R-tree on brazil_points2017’;</p></list-item></list></p>
        <p id="par0430">If <italic>FT_CreateSpatialIndex</italic> is executed multiple times, we are able to capture average statistical results from these executions. In this case, the index is built with different names but with the same configurations. Assuming that the previous R-tree is created multiple times (with different names, such as <italic>linear_rtree2</italic>, <italic>linear_rtree3</italic>, and so on), the following SQL SELECT statement returns the average index time and its standard deviation of these executions:<list list-type="simple" id="lis0050"><list-item id="lsti0160"><p id="par0435">SELECT avg(index_time), stddev(index_time)</p></list-item><list-item id="lsti0165"><p id="par0440">FROM fds.execution</p></list-item><list-item id="lsti0170"><p id="par0445">WHERE execution_name = ‘Creating R-tree on brazil_points2017’;</p></list-item></list></p>
        <p id="par0450">Comparing performance results between two or more spatial indices is another scenario in which FESTIval helps users. For instance, consider the execution of the following two SQL SELECT statements. The first statement sets a new execution name since we are dealing with a different spatial index, the R*-tree. The second statement creates an R*-tree, named <italic>rstartree</italic> and stored in <italic>/opt/</italic>, using the same node size of 4 KB (i.e., <italic>bc_id</italic>=6) and general LRU buffer of 512 KB (i.e., <italic>buf_id</italic>=4) that indexes the same dataset as the previous R-tree (i.e., <italic>src_id</italic>=7). The specific parameter <italic>sc_id</italic>=60 refers to the configuration of the R*-tree that specifies the reinsertion of 30% of entries according to the CLOSE REINSERT policy. Further, this command does not change default values for arguments of <italic>FT_CreateSpatialIndex</italic>.<list list-type="simple" id="lis0055"><list-item id="lsti0175"><p id="par0455">SELECT FT_SetExecutionName(‘Creating R*-tree on brazil_points2017’);</p></list-item><list-item id="lsti0180"><p id="par0460">SELECT FT_CreateSpatialIndex(2, ‘/opt/rstartree’, 7, 6, 60, 4);</p></list-item></list></p>
        <p id="par0465">Considering that the previous R-tree and R*-tree have been built the same number of times and with different names, we are able to compare their average time of creation as follows:<list list-type="simple" id="lis0060"><list-item id="lsti0185"><p id="par0470">SELECT execution_name, avg(index_time), stddev(index_time)</p></list-item><list-item id="lsti0190"><p id="par0475">FROM fds.execution</p></list-item><list-item id="lsti0195"><p id="par0480">WHERE execution_name IN (‘Creating R-tree on brazil_points2017’,</p></list-item><list-item id="lsti0200"><p id="par0485">‘Creating R*-tree on brazil_points2017’);</p></list-item></list></p>
        <p id="par0490">Another example of execution of <italic>FT_CreateSpatialIndex</italic> is to vary its parameter values in order to collect statistical data related to the index structure, as shown in the next two SQL SELECT statements. The first one denominates the corresponding execution name. The second one creates another R-tree, called <italic>linear_rtree_comp</italic> and stored in <italic>/opt/</italic>, with the same parameter values of the previous R-tree (i.e., <italic>linear_rtree</italic>); but collecting statistical data related to its structure, which is useful to analyze the spatial organization of the index. In addition, FESTIval also stores the nodes of the built index, which is useful to visualize the index by using specialized programs like QGIS.<list list-type="simple" id="lis0065"><list-item id="lsti0205"><p id="par0495">SELECT FT_SetExecutionName(‘Creating R-tree on brazil_points2017’);</p></list-item><list-item id="lsti0210"><p id="par0500">SELECT FT_CreateSpatialIndex(1, ‘/opt/linear_rtree_comp’, 7, 6, 18, 4, false, false, 4);</p></list-item></list></p>
        <p id="par0505">The next SQL SELECT statement shows an example of a query that returns the height, the number of internal and leaf nodes, and the average number of entries per node of the previously built R-tree (considering that only the aforementioned SQL statements were executed):<list list-type="simple" id="lis0070"><list-item id="lsti0215"><p id="par0510">SELECT height, num_internal_nodes, num_leaf_nodes, avg_num_entries_pnode</p></list-item><list-item id="lsti0220"><p id="par0515">FROM fds.execution e, fds.indexsnapshot is</p></list-item><list-item id="lsti0225"><p id="par0520">WHERE e.pe_id = is.pe_id AND execution_name = ‘Creating R-tree on brazil_points2017’;</p></list-item></list></p>
        <p id="par0525">Further, the user is also able to visualize this index by retrieving rows from the PrintIndex. Every row in this table represents an entry of an index page, which has at least a pointer, height, and a geometry object representing its MBR. <xref rid="fig0015" ref-type="fig">Fig. 3</xref> depicts the structure of the built R-tree (i.e., <italic>linear_rtree_comp</italic>) by using the QGIS. Different layers of geometries are employed to see the MBRs of each level of the tree (<xref rid="fig0015" ref-type="fig">Fig. 3</xref>c–e). This visualization is particularly useful to graphically represent indices, such as for educational purposes.<statement id="enun0015"><label>Algorithm 3</label><p id="par0530">The workload written in PL/pgSQL for executing spatial queries</p></statement><fig id="fig0015"><label>Fig. 3</label><caption><p>Visualization of the MBRs of node entries of an R-tree. This R-tree (a) is built over the <italic>brazil_points2017</italic> (b) and has height equal to 3. The entries of each level, from the highest to the lowest level, are shown in (c), (d), and (e), respectively.</p></caption><alt-text id="at0015">Fig. 3</alt-text><graphic xlink:href="gr3"/></fig></p>
        <p id="par0535">
          <fig id="fig0040">
            <graphic xlink:href="fx4"/>
          </fig>
        </p>
        <p id="par0540">Algorithm 3 depicts another workload, named <italic>FT_QueryWorkload</italic>. This workload has been used to understand the impact of SSDs on the spatial indexing context <xref rid="bib0050" ref-type="bibr">[10]</xref>, <xref rid="bib0055" ref-type="bibr">[11]</xref>, <xref rid="bib0140" ref-type="bibr">[28]</xref>, <xref rid="bib0175" ref-type="bibr">[35]</xref>, <xref rid="bib0180" ref-type="bibr">[36]</xref> and to measure the performance gains of eFIND <xref rid="bib0090" ref-type="bibr">[18]</xref>, <xref rid="bib0095" ref-type="bibr">[19]</xref>. Its main goal is to build an index and to execute intersection range queries (IRQs). The employed query windows (stored in the relational table called <italic>generated_rectangle</italic>) are correlated to the indexed dataset <xref rid="bib0155" ref-type="bibr">[31]</xref> and are available at <ext-link ext-link-type="uri" xlink:href="https://github.com/accarniel/FESTIval/wiki/" id="intr0045">https://github.com/accarniel/FESTIval/wiki/</ext-link>. All inputs of this workload have the same meaning of the common inputs of the workload depicted in Algorithm 2. <italic>FT_QueryWorkload</italic> first gets the name of the dataset to be indexed in this workload (line 9). Then, the workload sets the name of the execution (line 10) to identify that the next operation is the index construction (line 11). After building the index, three different sets of IRQs are processed (lines 12–16, lines 17–21, and lines 22–26). To this end, three different sets of query windows are employed. Each set has 100 query windows with specific sizes of the area of the total extent of Brazil. These sizes are 0.001%, 0.01%, and 0.1%, respectively. Considering that the selectivity of a spatial query is the ratio of the number of returned objects and the total objects, these sets of query windows form spatial queries with low, medium, and high selectivity, respectively. Each execution of a spatial query is performed by the atomic operation <italic>FT_AQuerySpatialIndex</italic>. Finally, all statistical data is stored in a file located in the HDD (parameter <italic>file</italic> in lines 11, 15, 20, and 25) since this workload handles the spatial index file stored in an SSD. The use of this workload to validate a flash-aware spatial index is further discussed in the next section.</p>
      </sec>
    </sec>
  </sec>
  <sec id="sec0040">
    <title>Method validation: employing FESTIval to measure the efficiency of eFIND</title>
    <p id="par0545">In this section, we show how <italic>FT_QueryWorkload</italic> (Algorithm 3) is employed to validate eFIND and how the statistical results can be extracted to measure its performance gains. eFIND <xref rid="bib0090" ref-type="bibr">[18]</xref>, <xref rid="bib0095" ref-type="bibr">[19]</xref> is a generic approach that transforms a disk-based spatial index (e.g., the R-tree) into an efficient flash-aware spatial index (e.g., eFIND R-tree). The examples described in this section details a part of the experimental evaluation conducted by us in <xref rid="bib0095" ref-type="bibr">[19]</xref>. These experiments compare eFIND against FAST, which is the closest competitor to eFIND among existing approaches to implementing flash-aware spatial indices. eFIND and FAST are employed to port the traditional R-tree to SSDs, forming the following configurations: the <italic>eFIND R-tree</italic> and the <italic>FAST R-tree</italic>, respectively. The used spatial dataset (i.e., <italic>src_id</italic>) is the <italic>brazil_buildings2017</italic>
<xref rid="bib0155" ref-type="bibr">[31]</xref>, containing 1,485,866 regions that represent the buildings of Brazil. Both configurations employed an in-memory buffer of 512 KB, log size of 10 MB, and the flushing unit size equal to 5. The best parameter values were applied for the remaining specific parameters. This means that we did not vary specific parameter values for each configuration (i.e., <italic>sc_id=50031</italic> for the eFIND R-tree and <italic>sc_id=1323</italic> for the FAST R-tree). On the other hand, basic parameter values (i.e., <italic>bc_id</italic>) are varied to evaluate the eFIND R-tree and the FAST R-tree under page sizes from 2 KB to 32 KB. A generic buffer was not employed in the experiments (i.e., <italic>buf_id=1</italic>). We conducted the experiments on a Kingston SSD V300 of 480 GB.</p>
    <p id="par0550">The next SQL SELECT statements execute the workload depicted in Algorithm 3 to evaluate the performance of the eFIND R-tree and the FAST R-tree, respectively, using the page size equal to 4 KB (i.e., <italic>bc_id=53</italic>). The files <italic>efind_results.sql</italic> and <italic>fast_results.sql</italic>, maintained in an HDD, are employed to store statistical data for the eFIND R-tree and the FAST R-tree, respectively:<list list-type="simple" id="lis0075"><list-item id="lsti0230"><p id="par0555">SELECT FT_QueryWorkload(8, ‘/opt/efind_rtree1’, 5, 53, 50031, 1, ‘/HDD/efind_results.sql’);</p></list-item><list-item id="lsti0235"><p id="par0560">SELECT FT_QueryWorkload(4, ‘/opt/fast_rtree1’, 5, 53, 1323, 1, ‘/HDD/fast_results.sql’);</p></list-item></list></p>
    <p id="par0565">Similar SQL SELECT statements are issued to evaluate the eFIND R-tree and the FAST R-tree for different page sizes. Each SQL SELECT statement is executed 5 times, varying the name of each index file, in order to calculate the average index time of the index construction and the execution of the IRQs. The cache of the PostgreSQL and the operating system is cleaned between the executions.</p>
    <p id="par0570">As previously discussed, collecting statistical data requires the execution of SQL SELECT statements on the FESTIval's data schema. For instance, the next query returns the average index time and its standard deviation to construct an eFIND R-tree for each employed page size:<list list-type="simple" id="lis0080"><list-item id="lsti0240"><p id="par0575">SELECT b.page_size, avg(e.index_time), stddev(e.index_time)</p></list-item><list-item id="lsti0245"><p id="par0580">FROM fds.basicconfiguration b, fds.specializedconfiguration sc,</p></list-item><list-item id="lsti0250"><p id="par0585">fds.indexconfiguration ic, fds.spatialindex si, fds.execution e</p></list-item><list-item id="lsti0255"><p id="par0590">WHERE b.bc_id = ic.bc_id AND sc.sc_id = ic.sc_id AND</p></list-item><list-item id="lsti0260"><p id="par0595">ic.config_id = si.config_id AND si.idx_id = e.idx_id AND</p></list-item><list-item id="lsti0265"><p id="par0600">ic.sc_id = 50031 AND execution_name = ‘Query Worload - Index Creation’</p></list-item><list-item id="lsti0270"><p id="par0605">GROUP BY b.page_size</p></list-item><list-item id="lsti0275"><p id="par0610">ORDER BY b.page_size;</p></list-item></list></p>
    <p id="par0615">The same structure of query can be also used for extracting performance results of the FAST R-tree.</p>
    <p id="par0620">In our analyses, we collected the average of the total elapsed time required to execute each set of 100 IRQs. The following SQL SELECT statement is performed when collecting results for the query windows with 0.001% of the area of Brazil:<list list-type="simple" id="lis0085"><list-item id="lsti0280"><p id="par0625">SELECT t.page_size, avg(t.s), stddev(t.s)</p></list-item><list-item id="lsti0285"><p id="par0630">FROM (</p></list-item><list-item id="lsti0290"><p id="par0635">SELECT si.idx_name, b.page_size, sum(e.index_time) as s</p></list-item><list-item id="lsti0295"><p id="par0640">FROM fds.basicconfiguration b, fds.specializedconfiguration sc,</p></list-item><list-item id="lsti0300"><p id="par0645">fds.indexconfiguration ic, fds.spatialindex si, fds.execution e</p></list-item><list-item id="lsti0305"><p id="par0650">WHERE b.bc_id = ic.bc_id AND sc.sc_id = ic.sc_id AND</p></list-item><list-item id="lsti0310"><p id="par0655">ic.config_id = si.config_id AND si.idx_id = e.idx_id AND ic.sc_id = 50031 AND</p></list-item><list-item id="lsti0315"><p id="par0660">execution_name = ‘Query Worload - Execution of IRQs with Query Windows of 0.001GROUP BY si.idx_name, b.page_size</p></list-item><list-item id="lsti0320"><p id="par0665">) as t</p></list-item><list-item id="lsti0325"><p id="par0670">GROUP BY t.page_size</p></list-item><list-item id="lsti0330"><p id="par0675">ORDER BY t.page_size;</p></list-item></list></p>
    <p id="par0680">The subquery returns the sum of the index time required to process the 100 IRQs with query windows of 0.001% for each built index and page size. Note that we have 5 spatial indices with the same configurations created by the multiple executions of <italic>FT_QueryWorkload</italic>; each spatial index has a different name stored in <italic>idx_name</italic>. Then, the outer query returns the average and the standard deviation of the total elapsed time for each page size. A similar approach is used to extract the performance results of the FAST R-tree.</p>
    <p id="par0685">By using the returned results of the SQL SELECT statements, we can employ data analytics tools (<xref rid="fig0005" ref-type="fig">Fig. 1</xref>) to analyze the performance results. For instance, we can visualize the results by using bar graphs, where the <italic>x</italic>-axis is the first returned column (i.e., <italic>page_size</italic>) and the <italic>y</italic>-axis is the average time with the errors bar for the standard deviation, as shown in <xref rid="fig0020" ref-type="fig">Fig. 4</xref>. In our experiments, the eFIND R-tree overcame the FAST R-tree when building indices in all employed page sizes. Its performance gains were very expressive, ranging from 60% to 77% for the Kingston SSD (<xref rid="fig0020" ref-type="fig">Fig. 4</xref>a). As for the query processing (<xref rid="fig0020" ref-type="fig">Fig. 4</xref>b–d), the eFIND R-tree provided the best performance only for larger pages, showing gains of 22% and 23% for the index pages of 16 KB and 32 KB, respectively. The efficiency of eFIND comes from the use of a set of design goals specified to fully exploit SSD performance <xref rid="bib0090" ref-type="bibr">[18]</xref>.<fig id="fig0020"><label>Fig. 4</label><caption><p>FESTIval was very useful to measure the performance gains of the eFIND R-tree, which reduced the time spent when building spatial indices (a) and when processing IRQs (b, c, and d).</p></caption><alt-text id="at0020">Fig. 4</alt-text><graphic xlink:href="gr4"/></fig></p>
  </sec>
  <sec id="sec0045">
    <title>Conclusions and future work</title>
    <p id="par0690">In this article, we propose FESTIval, a versatile method for conducting experimental evaluations of spatial indices under the same environment. FESTIval is implemented as a PostgreSQL extension and includes the following advantages: (i) the support for disk-based and flash-aware spatial indices that can assume different configurations by setting their corresponding parameter values, (ii) the definition of user-defined workloads by using FESTIval's SQL functions, (iii) the use of any spatial dataset when executing workloads, (iv) the collection of different types of statistical data that are stored in the FESTIval's data schema, and (v) the reproduction of executed experiments.</p>
    <p id="par0695">The positive characteristics of FESTIval allow its use in distinct experimental evaluations, such as experiments for analyzing the impact of SSDs in the spatial indexing context <xref rid="bib0050" ref-type="bibr">[10]</xref>, <xref rid="bib0055" ref-type="bibr">[11]</xref>, and experiments for validating new proposals of spatial indexing on SSDs (e.g., eFIND-based indices <xref rid="bib0090" ref-type="bibr">[18]</xref>, <xref rid="bib0095" ref-type="bibr">[19]</xref>). Moreover, external data analytics tools can access the FESTIval's data schema to generate different types of graphics, to plot maps, and to process statistical data in mathematical models. These aspects are very important when benchmarking spatial indexing structures in spatial database systems and GIS.</p>
    <p id="par0700">Future work will mainly deal with two topics. The first topic relates to the continuous development of FESTIval by including the support for other spatial indexing structures. We plan to provide support for the xBR<sup>+</sup>-tree <xref rid="bib0185" ref-type="bibr">[37]</xref> since this spatial index has been ported to SSDs using FAST and eFIND <xref rid="bib0190" ref-type="bibr">[38]</xref>. As a result, we also plan to include the FAST xBR<sup>+</sup>-tree and the eFIND xBR<sup>+</sup>-tree in FESTIval. The second topic consists of creating a systematic model that recommends the best spatial indices to be employed on SSDs according to a given context (e.g., the type of workload employed in the spatial application). The idea is to integrate this model into FESTIval as SQL functions.</p>
  </sec>
</body>
<back>
  <ref-list id="bibl0005">
    <title>References</title>
    <ref id="bib0005">
      <label>1</label>
      <element-citation publication-type="journal" id="sbref0005">
        <person-group person-group-type="author">
          <name>
            <surname>Gaede</surname>
            <given-names>V.</given-names>
          </name>
          <name>
            <surname>Günther</surname>
            <given-names>O.</given-names>
          </name>
        </person-group>
        <article-title>Multidimensional access methods</article-title>
        <source>ACM Comput. Surv.</source>
        <volume>30</volume>
        <issue>2</issue>
        <year>1998</year>
        <fpage>170</fpage>
        <lpage>231</lpage>
      </element-citation>
    </ref>
    <ref id="bib0010">
      <label>2</label>
      <element-citation publication-type="book" id="sbref0010">
        <person-group person-group-type="author">
          <name>
            <surname>Oosterom</surname>
            <given-names>P.V.A.N.</given-names>
          </name>
        </person-group>
        <chapter-title>Spatial access methods</chapter-title>
        <person-group person-group-type="editor">
          <name>
            <surname>Longley</surname>
            <given-names>P.A.</given-names>
          </name>
          <name>
            <surname>Goodchild</surname>
            <given-names>M.F.</given-names>
          </name>
          <name>
            <surname>Maguire</surname>
            <given-names>D.J.</given-names>
          </name>
          <name>
            <surname>Rhind</surname>
            <given-names>D.W.</given-names>
          </name>
        </person-group>
        <source>Geographical Information Systems: Principles, Techniques, Management and Applications</source>
        <edition>2nd ed.</edition>
        <year>2005</year>
        <fpage>385</fpage>
        <lpage>400</lpage>
      </element-citation>
    </ref>
    <ref id="bib0015">
      <label>3</label>
      <element-citation publication-type="journal" id="sbref0015">
        <person-group person-group-type="author">
          <name>
            <surname>Guttman</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>R-trees: a dynamic index structure for spatial searching</article-title>
        <source>ACM SIGMOD International Conference on Management of Data</source>
        <year>1984</year>
        <fpage>47</fpage>
        <lpage>57</lpage>
      </element-citation>
    </ref>
    <ref id="bib0020">
      <label>4</label>
      <element-citation publication-type="journal" id="sbref0020">
        <person-group person-group-type="author">
          <name>
            <surname>Beckmann</surname>
            <given-names>N.</given-names>
          </name>
          <name>
            <surname>Kriegel</surname>
            <given-names>H.-P.</given-names>
          </name>
          <name>
            <surname>Schneider</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Seeger</surname>
            <given-names>B.</given-names>
          </name>
        </person-group>
        <article-title>The R*-tree: an efficient and robust access method for points and rectangles</article-title>
        <source>ACM SIGMOD International Conference on Management of Data</source>
        <year>1990</year>
        <fpage>322</fpage>
        <lpage>331</lpage>
      </element-citation>
    </ref>
    <ref id="bib0025">
      <label>5</label>
      <element-citation publication-type="journal" id="sbref0025">
        <person-group person-group-type="author">
          <name>
            <surname>Kamel</surname>
            <given-names>I.</given-names>
          </name>
          <name>
            <surname>Faloutsos</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <article-title>Hilbert R-tree: an improved R-tree using fractals</article-title>
        <source>International Conference on Very Large Databases</source>
        <year>1994</year>
        <fpage>500</fpage>
        <lpage>509</lpage>
      </element-citation>
    </ref>
    <ref id="bib0030">
      <label>6</label>
      <element-citation publication-type="journal" id="sbref0030">
        <person-group person-group-type="author">
          <name>
            <surname>Cormer</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <article-title>Ubiquitous B-tree</article-title>
        <source>ACM Comput. Surv.</source>
        <volume>11</volume>
        <issue>2</issue>
        <year>1979</year>
        <fpage>121</fpage>
        <lpage>137</lpage>
      </element-citation>
    </ref>
    <ref id="bib0035">
      <label>7</label>
      <element-citation publication-type="journal" id="sbref0035">
        <person-group person-group-type="author">
          <name>
            <surname>Emrich</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Graf</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Kriegel</surname>
            <given-names>H.-P.</given-names>
          </name>
          <name>
            <surname>Schubert</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Thoma</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <article-title>On the impact of flash SSDs on spatial indexing</article-title>
        <source>International Workshop on Data Management on New Hardware</source>
        <year>2010</year>
        <fpage>3</fpage>
        <lpage>8</lpage>
      </element-citation>
    </ref>
    <ref id="bib0040">
      <label>8</label>
      <element-citation publication-type="journal" id="sbref0040">
        <person-group person-group-type="author">
          <name>
            <surname>Koltsidas</surname>
            <given-names>I.</given-names>
          </name>
          <name>
            <surname>Viglas</surname>
            <given-names>S.D.</given-names>
          </name>
        </person-group>
        <article-title>Spatial data management over flash memory</article-title>
        <source>International Conference on Advances in Spatial and Temporal Databases</source>
        <year>2011</year>
        <fpage>449</fpage>
        <lpage>453</lpage>
      </element-citation>
    </ref>
    <ref id="bib0045">
      <label>9</label>
      <element-citation publication-type="journal" id="sbref0045">
        <person-group person-group-type="author">
          <name>
            <surname>Liu</surname>
            <given-names>Q.</given-names>
          </name>
          <name>
            <surname>Nie</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Bu</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Sun</surname>
            <given-names>Z.</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Xie</surname>
            <given-names>Q.</given-names>
          </name>
        </person-group>
        <article-title>An efficient flash-based remote sense image storage approach for fast access geographic information system</article-title>
        <source>International Conference on Digital Manufacturing Automation</source>
        <year>2012</year>
        <fpage>175</fpage>
        <lpage>178</lpage>
      </element-citation>
    </ref>
    <ref id="bib0050">
      <label>10</label>
      <element-citation publication-type="journal" id="sbref0050">
        <person-group person-group-type="author">
          <name>
            <surname>Carniel</surname>
            <given-names>A.C.</given-names>
          </name>
          <name>
            <surname>Ciferri</surname>
            <given-names>R.R.</given-names>
          </name>
          <name>
            <surname>Ciferri</surname>
            <given-names>C.D.A.</given-names>
          </name>
        </person-group>
        <article-title>The performance relation of spatial indexing on hard disk drives and solid state drives</article-title>
        <source>Brazilian Symposium on GeoInformatics</source>
        <year>2016</year>
        <fpage>263</fpage>
        <lpage>274</lpage>
      </element-citation>
    </ref>
    <ref id="bib0055">
      <label>11</label>
      <element-citation publication-type="journal" id="sbref0055">
        <person-group person-group-type="author">
          <name>
            <surname>Carniel</surname>
            <given-names>A.C.</given-names>
          </name>
          <name>
            <surname>Ciferri</surname>
            <given-names>R.R.</given-names>
          </name>
          <name>
            <surname>Ciferri</surname>
            <given-names>C.D.A.</given-names>
          </name>
        </person-group>
        <article-title>Analyzing the performance of spatial indices on hard disk drives and flash-based solid state drives</article-title>
        <source>J. Inform. Data Manag.</source>
        <volume>8</volume>
        <issue>1</issue>
        <year>2017</year>
        <fpage>34</fpage>
        <lpage>49</lpage>
      </element-citation>
    </ref>
    <ref id="bib0060">
      <label>12</label>
      <element-citation publication-type="journal" id="sbref0060">
        <person-group person-group-type="author">
          <name>
            <surname>Agrawal</surname>
            <given-names>N.</given-names>
          </name>
          <name>
            <surname>Prabhakaran</surname>
            <given-names>V.</given-names>
          </name>
          <name>
            <surname>Wobber</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Davis</surname>
            <given-names>J.D.</given-names>
          </name>
          <name>
            <surname>Manasse</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Panigrahy</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <article-title>Design tradeoffs for SSD performance</article-title>
        <source>USENIX 2008 Annual Technical Conference</source>
        <year>2008</year>
        <fpage>57</fpage>
        <lpage>70</lpage>
      </element-citation>
    </ref>
    <ref id="bib0065">
      <label>13</label>
      <element-citation publication-type="journal" id="sbref0065">
        <person-group person-group-type="author">
          <name>
            <surname>Chen</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Koufaty</surname>
            <given-names>D.A.</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>X.</given-names>
          </name>
        </person-group>
        <article-title>Understanding intrinsic characteristics and system implications of flash memory based solid state drives</article-title>
        <source>ACM SIGMETRICS International Conference on Measurement and Modeling of Computer Systems</source>
        <year>2009</year>
        <fpage>181</fpage>
        <lpage>192</lpage>
      </element-citation>
    </ref>
    <ref id="bib0070">
      <label>14</label>
      <element-citation publication-type="journal" id="sbref0070">
        <person-group person-group-type="author">
          <name>
            <surname>Jung</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Kandemir</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <article-title>Revisiting widely held SSD expectations and rethinking system-level implications</article-title>
        <source>ACM SIGMETRICS International Conference on Measurement and Modeling of Computer Systems</source>
        <year>2013</year>
        <fpage>203</fpage>
        <lpage>216</lpage>
      </element-citation>
    </ref>
    <ref id="bib0075">
      <label>15</label>
      <element-citation publication-type="journal" id="sbref0075">
        <person-group person-group-type="author">
          <name>
            <surname>Chen</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Hou</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <article-title>Internal parallelism of flash memory-based solid-state drives</article-title>
        <source>ACM Trans. Storage</source>
        <volume>12</volume>
        <issue>3</issue>
        <year>2016</year>
        <comment>13:1–13:39</comment>
      </element-citation>
    </ref>
    <ref id="bib0080">
      <label>16</label>
      <element-citation publication-type="journal" id="sbref0080">
        <person-group person-group-type="author">
          <name>
            <surname>Sarwat</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Mokbel</surname>
            <given-names>M.F.</given-names>
          </name>
          <name>
            <surname>Zhou</surname>
            <given-names>X.</given-names>
          </name>
          <name>
            <surname>Nath</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <article-title>Generic and efficient framework for search trees on flash memory storage systems</article-title>
        <source>GeoInformatica</source>
        <volume>17</volume>
        <issue>3</issue>
        <year>2013</year>
        <fpage>417</fpage>
        <lpage>448</lpage>
      </element-citation>
    </ref>
    <ref id="bib0085">
      <label>17</label>
      <element-citation publication-type="journal" id="sbref0085">
        <person-group person-group-type="author">
          <name>
            <surname>Jin</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Xie</surname>
            <given-names>X.</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>N.</given-names>
          </name>
          <name>
            <surname>Yue</surname>
            <given-names>L.</given-names>
          </name>
        </person-group>
        <article-title>Optimizing R-tree for flash memory</article-title>
        <source>Expert Syst. Appl.</source>
        <volume>42</volume>
        <issue>10</issue>
        <year>2015</year>
        <fpage>4676</fpage>
        <lpage>4686</lpage>
      </element-citation>
    </ref>
    <ref id="bib0090">
      <label>18</label>
      <element-citation publication-type="journal" id="sbref0090">
        <person-group person-group-type="author">
          <name>
            <surname>Carniel</surname>
            <given-names>A.C.</given-names>
          </name>
          <name>
            <surname>Ciferri</surname>
            <given-names>R.R.</given-names>
          </name>
          <name>
            <surname>Ciferri</surname>
            <given-names>C.D.A.</given-names>
          </name>
        </person-group>
        <article-title>A generic and efficient framework for spatial indexing on flash-based solid state drives</article-title>
        <source>European Conference on Advances in Databases and Information Systems</source>
        <year>2017</year>
        <fpage>229</fpage>
        <lpage>243</lpage>
      </element-citation>
    </ref>
    <ref id="bib0095">
      <label>19</label>
      <element-citation publication-type="journal" id="sbref0095">
        <person-group person-group-type="author">
          <name>
            <surname>Carniel</surname>
            <given-names>A.C.</given-names>
          </name>
          <name>
            <surname>Ciferri</surname>
            <given-names>R.R.</given-names>
          </name>
          <name>
            <surname>Ciferri</surname>
            <given-names>C.D.A.</given-names>
          </name>
        </person-group>
        <article-title>A generic and efficient framework for flash-aware spatial indexing</article-title>
        <source>Inform. Syst.</source>
        <year>2018</year>
      </element-citation>
    </ref>
    <ref id="bib0100">
      <label>20</label>
      <element-citation publication-type="journal" id="sbref0100">
        <person-group person-group-type="author">
          <name>
            <surname>Kornacker</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Shah</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Hellerstein</surname>
            <given-names>J.M.</given-names>
          </name>
        </person-group>
        <article-title>AMDB: an access method debugging tool</article-title>
        <source>ACM SIGMOD International Conference on Management of Data</source>
        <year>1998</year>
        <fpage>570</fpage>
        <lpage>571</lpage>
      </element-citation>
    </ref>
    <ref id="bib0105">
      <label>21</label>
      <element-citation publication-type="journal" id="sbref0105">
        <person-group person-group-type="author">
          <name>
            <surname>Gurret</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Manolopoulos</surname>
            <given-names>Y.</given-names>
          </name>
          <name>
            <surname>Papadopoulos</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Rigaux</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <article-title>The BASIS system: a benchmarking approach for spatial index structures</article-title>
        <source>International Workshop on Spatio-Temporal Database Management</source>
        <year>1999</year>
        <fpage>152</fpage>
        <lpage>170</lpage>
      </element-citation>
    </ref>
    <ref id="bib0110">
      <label>22</label>
      <element-citation publication-type="journal" id="sbref0110">
        <person-group person-group-type="author">
          <name>
            <surname>Myllymaki</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Kaufman</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>LOCUS: a testbed for dynamic spatial indexing</article-title>
        <source>IEEE Data Eng. Bull. (Special Issue on Indexing of Moving Objects)</source>
        <volume>25</volume>
        <year>2002</year>
        <fpage>48</fpage>
        <lpage>55</lpage>
      </element-citation>
    </ref>
    <ref id="bib0115">
      <label>23</label>
      <element-citation publication-type="journal" id="sbref0115">
        <person-group person-group-type="author">
          <name>
            <surname>Sowell</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Salles</surname>
            <given-names>M.V.</given-names>
          </name>
          <name>
            <surname>Cao</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Demers</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Gehrke</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>An experimental analysis of iterated spatial joins in main memory</article-title>
        <source>VLDB Endowment</source>
        <volume>6</volume>
        <issue>14</issue>
        <year>2013</year>
        <fpage>1882</fpage>
        <lpage>1893</lpage>
      </element-citation>
    </ref>
    <ref id="bib0120">
      <label>24</label>
      <element-citation publication-type="journal" id="sbref0120">
        <person-group person-group-type="author">
          <name>
            <surname>Su</surname>
            <given-names>X.</given-names>
          </name>
          <name>
            <surname>Jin</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Xiang</surname>
            <given-names>X.</given-names>
          </name>
          <name>
            <surname>Cui</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Yue</surname>
            <given-names>L.</given-names>
          </name>
        </person-group>
        <article-title>Flash-DBSim: a simulation tool for evaluating flash-based database algorithms</article-title>
        <source>IEEE International Conference on Computer Science and Information Technology</source>
        <year>2009</year>
        <fpage>185</fpage>
        <lpage>189</lpage>
      </element-citation>
    </ref>
    <ref id="bib0125">
      <label>25</label>
      <element-citation publication-type="journal" id="sbref0125">
        <person-group person-group-type="author">
          <name>
            <surname>Kwon</surname>
            <given-names>S.J.</given-names>
          </name>
          <name>
            <surname>Ranjitkar</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Ko</surname>
            <given-names>Y.-B.</given-names>
          </name>
          <name>
            <surname>Chung</surname>
            <given-names>T.-S.</given-names>
          </name>
        </person-group>
        <article-title>FTL algorithms for NAND-type flash memories</article-title>
        <source>Des. Autom. Embed. Syst.</source>
        <volume>15</volume>
        <issue>3–4</issue>
        <year>2011</year>
        <fpage>191</fpage>
        <lpage>224</lpage>
      </element-citation>
    </ref>
    <ref id="bib0130">
      <label>26</label>
      <element-citation publication-type="journal" id="sbref0130">
        <person-group person-group-type="author">
          <name>
            <surname>Denning</surname>
            <given-names>P.J.</given-names>
          </name>
        </person-group>
        <article-title>Working sets past and present</article-title>
        <source>IEEE Trans. Softw. Eng.</source>
        <volume>SE-6</volume>
        <issue>1</issue>
        <year>1980</year>
        <fpage>64</fpage>
        <lpage>84</lpage>
      </element-citation>
    </ref>
    <ref id="bib0135">
      <label>27</label>
      <element-citation publication-type="journal" id="sbref0135">
        <person-group person-group-type="author">
          <name>
            <surname>Johnson</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Shasha</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <article-title>2Q: a low overhead high performance buffer management replacement algorithm</article-title>
        <source>International Conference on Very Large Databases</source>
        <year>1994</year>
        <fpage>439</fpage>
        <lpage>450</lpage>
      </element-citation>
    </ref>
    <ref id="bib0140">
      <label>28</label>
      <element-citation publication-type="journal" id="sbref0140">
        <person-group person-group-type="author">
          <name>
            <surname>Carniel</surname>
            <given-names>A.C.</given-names>
          </name>
          <name>
            <surname>Silva</surname>
            <given-names>T.B.</given-names>
          </name>
          <name>
            <surname>Bonicenha</surname>
            <given-names>K.L.S.</given-names>
          </name>
          <name>
            <surname>Ciferri</surname>
            <given-names>R.R.</given-names>
          </name>
          <name>
            <surname>Ciferri</surname>
            <given-names>C.D.A.</given-names>
          </name>
        </person-group>
        <article-title>Analyzing the performance of spatial indices on flash memories using a flash simulator</article-title>
        <source>Brazilian Symposium on Databases</source>
        <year>2017</year>
        <fpage>40</fpage>
        <lpage>51</lpage>
      </element-citation>
    </ref>
    <ref id="bib0145">
      <label>29</label>
      <element-citation publication-type="journal" id="sbref0145">
        <person-group person-group-type="author">
          <name>
            <surname>Greene</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <article-title>An implementation and performance analysis of spatial data access methods</article-title>
        <source>International Conference on Data Engineering</source>
        <year>1989</year>
        <fpage>606</fpage>
        <lpage>615</lpage>
      </element-citation>
    </ref>
    <ref id="bib0150">
      <label>30</label>
      <element-citation publication-type="journal" id="sbref0150">
        <person-group person-group-type="author">
          <name>
            <surname>Ang</surname>
            <given-names>C.-H.</given-names>
          </name>
          <name>
            <surname>Tan</surname>
            <given-names>T.C.</given-names>
          </name>
        </person-group>
        <article-title>New linear node splitting algorithm for R-trees</article-title>
        <source>International Symposium on Advances in Spatial Databases</source>
        <year>1997</year>
        <fpage>339</fpage>
        <lpage>349</lpage>
      </element-citation>
    </ref>
    <ref id="bib0155">
      <label>31</label>
      <element-citation publication-type="journal" id="sbref0155">
        <person-group person-group-type="author">
          <name>
            <surname>Carniel</surname>
            <given-names>A.C.</given-names>
          </name>
          <name>
            <surname>Ciferri</surname>
            <given-names>R.R.</given-names>
          </name>
          <name>
            <surname>Ciferri</surname>
            <given-names>C.D.A.</given-names>
          </name>
        </person-group>
        <article-title>Spatial datasets for conducting experimental evaluations of spatial indices</article-title>
        <source>Satellite Events of the Brazilian Symposium on Databases – Dataset Showcase Workshop</source>
        <year>2017</year>
        <fpage>286</fpage>
        <lpage>295</lpage>
      </element-citation>
    </ref>
    <ref id="bib0160">
      <label>32</label>
      <element-citation publication-type="journal" id="sbref0160">
        <person-group person-group-type="author">
          <name>
            <surname>Stonebraker</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Rubenstein</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Guttman</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Application of abstract data types and abstract indices to CAD databases</article-title>
        <source>ACM/IEEE Conference on Engineering Design Applications</source>
        <year>1983</year>
        <fpage>107</fpage>
        <lpage>113</lpage>
      </element-citation>
    </ref>
    <ref id="bib0165">
      <label>33</label>
      <element-citation publication-type="journal" id="sbref0165">
        <person-group person-group-type="author">
          <name>
            <surname>Schneider</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Behr</surname>
            <given-names>T.</given-names>
          </name>
        </person-group>
        <article-title>Topological relationships between complex spatial objects</article-title>
        <source>ACM Trans. Database Syst.</source>
        <volume>31</volume>
        <issue>1</issue>
        <year>2006</year>
        <fpage>39</fpage>
        <lpage>81</lpage>
      </element-citation>
    </ref>
    <ref id="bib0170">
      <label>34</label>
      <element-citation publication-type="journal" id="sbref0170">
        <person-group person-group-type="author">
          <name>
            <surname>Harder</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Reuter</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Principles of transaction-oriented database recovery</article-title>
        <source>ACM Comput. Surv.</source>
        <volume>15</volume>
        <issue>4</issue>
        <year>1993</year>
        <fpage>287</fpage>
        <lpage>317</lpage>
      </element-citation>
    </ref>
    <ref id="bib0175">
      <label>35</label>
      <element-citation publication-type="journal" id="sbref0175">
        <person-group person-group-type="author">
          <name>
            <surname>Carniel</surname>
            <given-names>A.C.</given-names>
          </name>
          <name>
            <surname>Silva</surname>
            <given-names>T.B.</given-names>
          </name>
          <name>
            <surname>Ciferri</surname>
            <given-names>C.D.A.</given-names>
          </name>
        </person-group>
        <article-title>Understanding the applicability of flash simulators on the experimental evaluation of spatial indices</article-title>
        <source>9th Annual Non-Volatile Memories Workshop</source>
        <year>2018</year>
        <fpage>1</fpage>
        <lpage>2</lpage>
      </element-citation>
    </ref>
    <ref id="bib0180">
      <label>36</label>
      <element-citation publication-type="journal" id="sbref0180">
        <person-group person-group-type="author">
          <name>
            <surname>Carniel</surname>
            <given-names>A.C.</given-names>
          </name>
        </person-group>
        <article-title>Spatial indexing on flash-based solid state drives</article-title>
        <source>Proceedings of the VLDB 2018 PhD Workshop</source>
        <year>2018</year>
        <fpage>1</fpage>
        <lpage>4</lpage>
      </element-citation>
    </ref>
    <ref id="bib0185">
      <label>37</label>
      <element-citation publication-type="journal" id="sbref0185">
        <person-group person-group-type="author">
          <name>
            <surname>Roumelis</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Vassilakopoulos</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Corral</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Manolopoulos</surname>
            <given-names>Y.</given-names>
          </name>
        </person-group>
        <article-title>Efficient query processing on large spatial databases: a performance study</article-title>
        <source>J. Syst. Softw.</source>
        <volume>132</volume>
        <year>2017</year>
        <fpage>165</fpage>
        <lpage>185</lpage>
      </element-citation>
    </ref>
    <ref id="bib0190">
      <label>38</label>
      <element-citation publication-type="journal" id="sbref0190">
        <person-group person-group-type="author">
          <name>
            <surname>Carniel</surname>
            <given-names>A.C.</given-names>
          </name>
          <name>
            <surname>Roumelis</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Ciferri</surname>
            <given-names>R.R.</given-names>
          </name>
          <name>
            <surname>Vassilakopoulos</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Corral</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Ciferri</surname>
            <given-names>C.D.A.</given-names>
          </name>
        </person-group>
        <article-title>An efficient flash-aware spatial index for points</article-title>
        <source>Brazilian Symposium on GeoInformatics</source>
        <year>2018</year>
        <fpage>68</fpage>
        <lpage>79</lpage>
      </element-citation>
    </ref>
    <ref id="bib0195">
      <label>39</label>
      <element-citation publication-type="journal" id="sbref0195">
        <person-group person-group-type="author">
          <name>
            <surname>Carniel</surname>
            <given-names>A.C.</given-names>
          </name>
          <name>
            <surname>Ciferri</surname>
            <given-names>R.R.</given-names>
          </name>
          <name>
            <surname>Ciferri</surname>
            <given-names>C.D.A.</given-names>
          </name>
        </person-group>
        <article-title>Experimental evaluation of spatial indices with FESTIval</article-title>
        <source>Satellite Events of the Brazilian Symposium on Databases – Demonstration Track</source>
        <year>2016</year>
        <fpage>123</fpage>
        <lpage>128</lpage>
      </element-citation>
    </ref>
  </ref-list>
  <sec id="sec0055" sec-type="supplementary-material">
    <label>Appendix A</label>
    <title>Supplementary data</title>
    <p id="par0715">The following are the supplementary data to this article:<supplementary-material content-type="local-data" id="upi0005"><media xlink:href="mmc1.pdf"/></supplementary-material></p>
  </sec>
  <ack id="ack0005">
    <title>Acknowledgements</title>
    <p>This study was financed in part by the Coordenação de Aperfeiçoamento de Pessoal de Nível Superior – Brasil (<funding-source id="gs0005">CAPES</funding-source>) – Finance Code 001. This work has also been supported by the Brazilian Federal Research Agency <funding-source id="gs0010">CNPq</funding-source>, as well as by the São Paulo Research Foundation (<funding-source id="gs0015">FAPESP</funding-source>). Anderson C. Carniel has been supported by the grant #2015/26687-8, FAPESP. Ricardo R. Ciferri has been supported by the grant #311868/2015-0, CNPq. Cristina D. A. has been supported by the grant #2018/22277-8, FAPESP.</p>
  </ack>
  <fn-group>
    <fn id="fn0005">
      <label>1</label>
      <p id="npar0005">For more information about writing PostgreSQL extensions, please access related PostgreSQL documentation at <ext-link ext-link-type="uri" xlink:href="https://www.postgresql.org/docs/10/static/extend-extensions.html" id="intr0010">https://www.postgresql.org/docs/10/static/extend-extensions.html</ext-link>.</p>
    </fn>
    <fn id="fn0010">
      <label>2</label>
      <p id="npar0010"><ext-link ext-link-type="uri" xlink:href="https://postgis.net/" id="intr0015">https://postgis.net/</ext-link>.</p>
    </fn>
    <fn id="fn0015">
      <label>3</label>
      <p id="npar0015"><ext-link ext-link-type="uri" xlink:href="http://trac.osgeo.org/geos" id="intr0020">http://trac.osgeo.org/geos</ext-link>.</p>
    </fn>
    <fn id="fn0020">
      <label>4</label>
      <p id="npar0020"><ext-link ext-link-type="uri" xlink:href="https://qgis.org/" id="intr0035">https://qgis.org/</ext-link>.</p>
    </fn>
    <fn id="fn0025">
      <label>5</label>
      <p id="npar0025"><ext-link ext-link-type="uri" xlink:href="https://www.arcgis.com/index.html" id="intr0040">https://www.arcgis.com/index.html</ext-link>.</p>
    </fn>
    <fn id="sec0050" fn-type="supplementary-material">
      <label>Appendix A</label>
      <p id="par0710">Supplementary data associated with this article can be found, in the online version, at <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.mex.2019.10.006" id="intr0050">https://doi.org/10.1016/j.mex.2019.10.006</ext-link>.</p>
    </fn>
  </fn-group>
</back>
