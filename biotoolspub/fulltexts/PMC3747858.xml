<?DTDIdentifier.IdentifierValue http://www.biomedcentral.com/xml/article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3747858</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-14-213</article-id>
    <article-id pub-id-type="pmid">23819480</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-14-213</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>PFClust: a novel parameter free clustering algorithm</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes" equal-contrib="yes" id="A1">
        <name>
          <surname>Mavridis</surname>
          <given-names>Lazaros</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>lazaros.mavridis.lm@gmail.com</email>
      </contrib>
      <contrib contrib-type="author" equal-contrib="yes" id="A2">
        <name>
          <surname>Nath</surname>
          <given-names>Neetika</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>nn223@st-andrews.ac.uk</email>
      </contrib>
      <contrib contrib-type="author" id="A3">
        <name>
          <surname>Mitchell</surname>
          <given-names>John BO</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>jbom@st-andrews.ac.uk</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Biomedical Sciences Research Complex and EaStCHEM School of Chemistry, Purdie Building, University of St Andrews, North Haugh, St Andrews, KY16 9ST, Scotland, UK</aff>
    <pub-date pub-type="collection">
      <year>2013</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>3</day>
      <month>7</month>
      <year>2013</year>
    </pub-date>
    <volume>14</volume>
    <fpage>213</fpage>
    <lpage>213</lpage>
    <history>
      <date date-type="received">
        <day>29</day>
        <month>1</month>
        <year>2013</year>
      </date>
      <date date-type="accepted">
        <day>1</day>
        <month>7</month>
        <year>2013</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2013 Mavridis et al.; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2013</copyright-year>
      <copyright-holder>Mavridis et al.; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1471-2105/14/213"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>We present the algorithm PFClust (Parameter Free Clustering), which is able automatically to cluster data and identify a suitable number of clusters to group them into without requiring any parameters to be specified by the user. The algorithm partitions a dataset into a number of clusters that share some common attributes, such as their minimum expectation value and variance of intra-cluster similarity. A set of <italic>n</italic> objects can be clustered into any number of clusters from one to <italic>n</italic>, and there are many different hierarchical and partitional, agglomerative and divisive, clustering methodologies available that can be used to do this. Nonetheless, automatically determining the number of clusters present in a dataset constitutes a significant challenge for clustering algorithms. Identifying a putative optimum number of clusters to group the objects into involves computing and evaluating a range of clusterings with different numbers of clusters. However, there is no agreed or unique definition of optimum in this context. Thus, we test PFClust on datasets for which an external gold standard of ‘correct’ cluster definitions exists, noting that this division into clusters may be suboptimal according to other reasonable criteria. PFClust is heuristic in the sense that it cannot be described in terms of optimising any single simply-expressed metric over the space of possible clusterings.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We validate PFClust firstly with reference to a number of synthetic datasets consisting of 2D vectors, showing that its clustering performance is at least equal to that of six other leading methodologies – even though five of the other methods are told in advance how many clusters to use. We also demonstrate the ability of PFClust to classify the three dimensional structures of protein domains, using a set of folds taken from the structural bioinformatics database CATH.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>We show that PFClust is able to cluster the test datasets a little better, on average, than any of the other algorithms, and furthermore is able to do this without the need to specify any external parameters. Results on the synthetic datasets demonstrate that PFClust generates meaningful clusters, while our algorithm also shows excellent agreement with the correct assignments for a dataset extracted from the CATH part-manually curated classification of protein domain structures.</p>
      </sec>
    </abstract>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>In pattern recognition, data analysis is used for predicting the behaviour of an unseen test dataset. Amongst problems of this kind, two different types can be clearly distinguished. The first is supervised learning or classification, where a labelled training dataset with known categories is involved. The second kind is unsupervised learning or clustering, where no prior information is available for grouping the dataset. The objective of a clustering algorithm is to partition the given data into mutually exclusive and meaningful [<xref ref-type="bibr" rid="B1">1</xref>] clusters; this can provide a better understanding of the natural structure of the data. Semi-supervised [<xref ref-type="bibr" rid="B2">2</xref>] classification, which combines strategies from both supervised and unsupervised methods, has also grabbed attention in various fields of research as it requires less human effort and gives better accuracy [<xref ref-type="bibr" rid="B3">3</xref>] than unsupervised learning. In this paper, we focus our attention on the challenges faced by clustering algorithms [<xref ref-type="bibr" rid="B4">4</xref>,<xref ref-type="bibr" rid="B5">5</xref>].</p>
    <p>There are numerous clustering algorithms discussed in the literature, traditionally clearly distinguished as either hierarchical [<xref ref-type="bibr" rid="B6">6</xref>] or partitional [<xref ref-type="bibr" rid="B7">7</xref>]. Hierarchical methods group the objects together layer by layer, based on the closeness of the data points as measured by suitable similarity or distance metrics. Hierarchical clustering sequentially partitions the dataset, either by successively dividing an initial single cluster in divisive methods, or by joining together initially unlinked objects in agglomerative algorithms. In a hierarchical method, once two objects are clustered together they remain together at all subsequent levels of the scheme with fewer clusters. Contrastingly, partitional clustering algorithms, such as k-means, do not have a layer by layer structure and objects may sometimes move from one cluster to another.</p>
    <p>The k-means method iteratively assigns each point to the cluster whose centroid is closest to it, recalculates the cluster centroids, and reassigns the points. This process continues until the assignments no longer change at each iteration. k-means tends to generate approximately equally sized clusters, minimising intra-cluster distances; however, its preference for globular clusters and its failure to reproduce clusters of complex shape are limitations [<xref ref-type="bibr" rid="B5">5</xref>].</p>
    <sec>
      <title>Determining the number of clusters</title>
      <p>Automatically determining the number of clusters is a major problem in clustering. A set of <italic>n</italic> objects can be clustered into any number <italic>k</italic> of clusters 1 ≤ <italic>k</italic> ≤ <italic>n</italic> by any of the methods we have discussed. Identifying the optimal number of clusters involves computing a range of different numbers of clusters <italic>k</italic>, with the objective of finding the best value of <italic>k</italic> that gives the optimum clustering. However, there is no agreed or unique definition of optimum in this context. Using internal and external validation measures as described in Handl <italic>et al</italic>. [<xref ref-type="bibr" rid="B5">5</xref>], one could design a protocol for reaching a decision on the best <italic>k</italic>. A gap statistic [<xref ref-type="bibr" rid="B8">8</xref>] addressed this issue by acting as an internal validation measure, and has been applied in bioinformatics [<xref ref-type="bibr" rid="B9">9</xref>]. Though in principle it is not hard to design a workflow to find the best <italic>k</italic>, in practice this is not commonly done. This is partly because there is no consensus as to which of the many different possible measures should be used to compare clusterings with different numbers of clusters, a more difficult problem than the comparison of clusterings with the same <italic>k</italic>. This adds to the difficulty of choosing the best clustering method for finding the structure of a novel dataset.</p>
    </sec>
    <sec>
      <title>Validation</title>
      <p>Validation [<xref ref-type="bibr" rid="B4">4</xref>,<xref ref-type="bibr" rid="B8">8</xref>] plays an important role in deciding the number of clusters, as well as in assessing the performance of the clustering algorithm. Cluster validation is designed to evaluate and compare clustering algorithms by their ability to analyse a dataset. There are many different validation measures. Internal measures like Silhouette width [<xref ref-type="bibr" rid="B9">9</xref>] and Dunn Index [<xref ref-type="bibr" rid="B10">10</xref>,<xref ref-type="bibr" rid="B11">11</xref>] depend on the inherent structure of the data [<xref ref-type="bibr" rid="B12">12</xref>]. External measures, such as the Rand Index [<xref ref-type="bibr" rid="B13">13</xref>] commonly used to evaluate the noise in biological data, depend on comparison with an externally known gold standard classification of the objects.</p>
      <p>Here we propose a novel clustering algorithm, PFClust (<bold>P</bold>arameter <bold>F</bold>ree <bold>Clust</bold>ering), suitable for use where no prior information about the number of clusters is given. As input, only similarity scores within the dataset are required, and evaluation of the clustering is part of the algorithm. A previous study by Akoglu <italic>et al</italic>. [<xref ref-type="bibr" rid="B14">14</xref>] designed a parameter free graph clustering algorithm to find cohesive clusters, PICS. They have shown the efficiency of their method using real-world datasets including data from YouTube and Twitter. Our method shares the property of being parameter-free, but is aimed at classifying objects rather than graphs.</p>
      <p>As the availability of biological information accelerates, it is necessary to find the natural structure or patterns in data in order to understand biological questions. In bioinformatics, grouping proteins based on sequence [<xref ref-type="bibr" rid="B1">1</xref>] or structure is a very common task. Classification of novel proteins [<xref ref-type="bibr" rid="B15">15</xref>] can be performed by using pattern recognition approaches, built on the assumption that some underlying characteristics are considered, while clustering proteins into superfamilies and families. There are numerous classification schemes for protein sequences including PIR-PSD [<xref ref-type="bibr" rid="B16">16</xref>], a freely available database of protein sequence classification mostly applied for functional annotation, and Pfam [<xref ref-type="bibr" rid="B17">17</xref>], a classification of functional protein domains based on hidden Markov models and multiple sequence alignments.</p>
      <p>Extending these ideas to three-dimensional (3D) protein structure provides the interesting task of clustering and classifying protein domain folds. During the early 1990s the Protein Data Bank (PDB) [<xref ref-type="bibr" rid="B18">18</xref>] held only a few thousand 3D crystal structures, and several initiatives for protein fold classification were proposed with CATH [<xref ref-type="bibr" rid="B19">19</xref>] and SCOP [<xref ref-type="bibr" rid="B20">20</xref>] being the best known. These were based on either manual curation (SCOP) or computer-aided manual curation (CATH). Common to both approaches is that the human curator has the final word in the classification decision. With the exponential growth of the number of 3D high resolution structures deposited in the PDB during the last decade [<xref ref-type="bibr" rid="B21">21</xref>], reaching 87,085 structures at the beginning of 2013, the rate-limiting manual part of the curation process restricts our capacity to understand the full structural diversity of proteins. Hence it would be ideal if a fully automated process could classify protein domains and cluster them into structurally similar groups.</p>
    </sec>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <p>Here we describe a partitional algorithm that uses the idea that each cluster can be represented as a non-predetermined distribution of the intra-cluster similarities of its members. The algorithm partitions a dataset into a number of clusters that share some common attributes, such as their minimum expectation value and variance of intra-cluster similarity. It is an agglomerative algorithm, meaning that it starts with separated objects and progressively joins them together to form clusters. PFClust is heuristic in the sense that it cannot be described in terms of optimising any single simply-expressed metric over the space of possible clusterings. Nonetheless, we demonstrate that, over a number of validations on test datasets, it produces clusterings that closely reflect the structure of the test data, and outperforms many well established algorithms in this regard. We have taken a number of design decisions to optimize the algorithm with respect to time efficiency and result stability.</p>
    <p>Since we represent each cluster as the distribution of the similarities between its members, we need to have a clustering criterion in order to separate different clusters and find the cluster structure. The criterion used in this algorithm is the expectation value of the similarity distribution between cluster members. In order to select a suitable threshold, we will need a good approximation to the distribution of mean intra-cluster similarities for all possible clusterings. We can then select the most appropriate threshold value given an internal validation measure. The number of unique clusterings for a dataset with <italic>n</italic> points when we do not know the number of clusters, <italic>O</italic>(<italic>n</italic>), <italic>a priori</italic> is the Bell number:</p>
    <p>
      <disp-formula>
        <mml:math id="M1" name="1471-2105-14-213-i1" overflow="scroll">
          <mml:mrow>
            <mml:mi>o</mml:mi>
            <mml:mfenced open="(" close=")">
              <mml:mi>n</mml:mi>
            </mml:mfenced>
            <mml:mo>=</mml:mo>
            <mml:mstyle displaystyle="true">
              <mml:munderover>
                <mml:mi mathsize="big">∑</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>0</mml:mn>
                </mml:mrow>
                <mml:mi>n</mml:mi>
              </mml:munderover>
              <mml:mrow>
                <mml:mfrac>
                  <mml:mn>1</mml:mn>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                    <mml:mo>!</mml:mo>
                  </mml:mrow>
                </mml:mfrac>
              </mml:mrow>
            </mml:mstyle>
            <mml:mstyle displaystyle="true">
              <mml:munderover>
                <mml:mi mathsize="big">∑</mml:mi>
                <mml:mrow>
                  <mml:mi>j</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>0</mml:mn>
                </mml:mrow>
                <mml:mi>k</mml:mi>
              </mml:munderover>
              <mml:mrow>
                <mml:mfenced open="(" close=")">
                  <mml:mrow>
                    <mml:msup>
                      <mml:mfenced open="(" close=")">
                        <mml:mrow>
                          <mml:mo>−</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                      </mml:mfenced>
                      <mml:mrow>
                        <mml:mi>k</mml:mi>
                        <mml:mo>−</mml:mo>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mfenced open="(" close=")">
                      <mml:msubsup>
                        <mml:mrow/>
                        <mml:mi>j</mml:mi>
                        <mml:mi>k</mml:mi>
                      </mml:msubsup>
                    </mml:mfenced>
                    <mml:msup>
                      <mml:mi>j</mml:mi>
                      <mml:mi>n</mml:mi>
                    </mml:msup>
                  </mml:mrow>
                </mml:mfenced>
              </mml:mrow>
            </mml:mstyle>
          </mml:mrow>
        </mml:math>
      </disp-formula>
    </p>
    <p>where <italic>k</italic> is the number of clusters, inclusive of singletons. This number grows rapidly with the number of points in the dataset. Hence, instead of attempting an exhaustive search of all possible clusterings, we perform a random sampling, where we randomly decide the number of clusters and randomly assign the initial distribution of points amongst clusters. This sampling approach is necessary for efficiency, but introduces a random element to the algorithm. In order to optimize some of our design decisions for the algorithm, we have internally validated using a synthetic dataset of 1500 two-dimensional (2D) vector points.</p>
    <sec>
      <title>Algorithm</title>
      <p>The clustering algorithm consists of two parts. The first part is the randomization, and the second part incorporates both the threshold selection and the actual clustering. Thus, in the first part (panel B of Figure <xref ref-type="fig" rid="F1">1</xref>), 20 thresholds are estimated (<italic>T</italic><sub><italic>1</italic></sub>,…, <italic>T</italic><sub><italic>20</italic></sub>) by a randomization process. In the second part (panels C &amp; D of Figure <xref ref-type="fig" rid="F1">1</xref>), each threshold is used to cluster the data, and the best threshold is selected. This whole process, incorporating both randomization and threshold selection, is carried out four times (panel E of Figure <xref ref-type="fig" rid="F1">1</xref>). If the four resulting clusterings do not agree, the algorithm replaces the least successful of the four runs with a fresh attempt and repeats until convergence. Figure <xref ref-type="fig" rid="F1">1</xref> shows a graphical representation of the clustering algorithm.</p>
      <fig id="F1" position="float">
        <label>Figure 1</label>
        <caption>
          <p><bold>Visual representation of the algorithm.</bold> This figure provides a visual representation of the algorithm as a number of different steps <bold>(A</bold> to <bold>F)</bold>.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-213-1"/>
      </fig>
    </sec>
    <sec>
      <title>Threshold estimation</title>
      <p>Given a dataset Ω = {α<sub><italic>1</italic></sub>,…,α<sub><italic>n</italic></sub>} with <italic>n</italic> members, the threshold values are estimated by multiple random clusterings of the data. Firstly, a random number of clusters <italic>k</italic> (where <italic>1</italic>≤ <italic>k</italic> ≤ <italic>n</italic>) is chosen and each data point α is initially randomly placed in one of the clusters. Now let <italic>X</italic><sub><italic>i</italic></sub> be the distribution of the similarities between the elements of cluster <italic>i</italic>. The mean intra-cluster similarity, which is the expectation value of the distribution <italic>X</italic><sub><italic>i</italic></sub>, is defined so as to exclude self-similarities and can be calculated as:</p>
      <p>
        <disp-formula>
          <mml:math id="M2" name="1471-2105-14-213-i2" overflow="scroll">
            <mml:mrow>
              <mml:mi>E</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:msub>
                  <mml:mi>X</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:msub>
              </mml:mfenced>
              <mml:mo>=</mml:mo>
              <mml:mfrac>
                <mml:mn>1</mml:mn>
                <mml:mfenced open="(" close=")">
                  <mml:mtable columnalign="center">
                    <mml:mtr columnalign="center">
                      <mml:mtd columnalign="center">
                        <mml:msub>
                          <mml:mi>n</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr columnalign="center">
                      <mml:mtd columnalign="center">
                        <mml:mn>2</mml:mn>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:mfenced>
              </mml:mfrac>
              <mml:munderover>
                <mml:mstyle displaystyle="true">
                  <mml:mi mathsize="big">∑</mml:mi>
                </mml:mstyle>
                <mml:mrow>
                  <mml:mi>j</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>2</mml:mn>
                </mml:mrow>
                <mml:msub>
                  <mml:mi>n</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:msub>
              </mml:munderover>
              <mml:mstyle displaystyle="true">
                <mml:munderover>
                  <mml:mi mathsize="big">∑</mml:mi>
                  <mml:mrow>
                    <mml:mi>q</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>j</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:munderover>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>s</mml:mi>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>α</mml:mi>
                        <mml:mi>j</mml:mi>
                      </mml:msub>
                      <mml:mo>,</mml:mo>
                      <mml:msub>
                        <mml:mi>α</mml:mi>
                        <mml:mi>q</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:mstyle>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>where <italic>X</italic><sub><italic>i</italic></sub> is the <italic>i</italic><sup><italic>th</italic></sup> cluster, <italic>n</italic><sub><italic>i</italic></sub> is the number of members of that cluster and <inline-formula><mml:math id="M3" name="1471-2105-14-213-i3" overflow="scroll"><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:msub><mml:mi>α</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>q</mml:mi></mml:msub></mml:mrow></mml:msub></mml:math></inline-formula> is the similarity between elements α<sub>j</sub> and α<sub>q</sub>. In order to estimate an efficient value for <italic>N</italic>, the number of randomizations used for threshold estimation, we selected a dataset and simulated the randomization process. We repeated this ten times for a number of different values of <italic>N</italic>. Figure <xref ref-type="fig" rid="F2">2</xref> shows that using a small number of randomizations greatly affects the shape and sharpness of the distribution. However, increasing <italic>N</italic> greatly affects the execution time of the algorithm, since the randomization is the most expensive part of the calculation. Hence, as a compromise between accuracy and expense, we selected <italic>N</italic> = 1000 as the number of randomizations, since this is the smallest number which gives an acceptably sharp distribution of mean intra-cluster similarities. The intra-cluster mean similarities, <italic>E</italic>[<italic>X</italic><sub><italic>i</italic></sub>], from every individual cluster across the 1000 randomizations are collated into a single distribution. From this distribution, we retrieve 20 threshold values from the 95% - 100% significance levels, that is the 5% of the clusters with the highest mean intra-cluster similarities. We select the ten values corresponding to the following percentiles {95.00%, 97.50%, 99.00%, 99.14%, 99.29%, 99.43%, 99.57%, 99.71%, 99.86% and 100.00%} and ten further thresholds corresponding to the second to eleventh highest values in the distribution of intra-cluster similarities. Using this number of thresholds provides a way of reducing the random element of our sampling.</p>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p><bold>Distribution of the E[X] according to the number of randomizations </bold><bold><italic>N</italic></bold><bold>.</bold> For each value of <italic>N</italic> (<italic>N</italic> = 10, <italic>N</italic> = 10<sup>2</sup>, <italic>N</italic> = 10<sup>3</sup>, <italic>N</italic> = 10<sup>4</sup> &amp;<italic>N</italic> = 10<sup>5</sup>), the randomization process was run independently ten times and the distribution of the E[X] was plotted.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-213-2"/>
      </fig>
    </sec>
    <sec>
      <title>Similarity-based clustering</title>
      <p>Now, for each threshold value <italic>T</italic>, the dataset <italic>Ω</italic> is clustered with a similarity-based clustering. We begin with all elements separated and no clusters defined. The two most similar elements in <italic>Ω</italic> are placed together to form the first cluster. For each of the (<italic>n</italic>-<italic>2</italic>) remaining elements, we compute its average similarity <italic>E</italic>[<italic>X</italic>] to the elements already in cluster 1, and we now identify the element with the highest similarity. If this value is larger than <italic>T</italic>, the algorithm considers adding this most similar element to the given cluster. The element is added if and only if the element’s average similarity compared to the members of that cluster is at least <italic>P</italic>% of <italic>T</italic> and the overall <italic>E</italic>[<italic>X</italic>] of the cluster is also larger than <italic>T</italic>. This process is repeated until no new element can be added to the cluster without <italic>E</italic>[<italic>X</italic>] of the cluster falling below <italic>T</italic>. At this stage, a new cluster is formed from the two most similar remaining elements, provided that their similarity exceeds <italic>T</italic>. This process is continued iteratively until all elements of <italic>Ω</italic> have been clustered, or until the remaining elements cannot form a cluster that has an expectation value of intra-cluster similarity greater than <italic>T</italic>.</p>
      <p>The <italic>P</italic>% of <italic>T</italic> cut-off was selected as a way to restrict the intra-cluster variation of the similarities since, in a very tight cluster, outlier members could be included because, even if they are distant from the other cluster members, the total <italic>E</italic>[<italic>X</italic>] could still be above <italic>T</italic>. In order to estimate the value of <italic>P</italic>, we performed a number of experiments on our dataset with different <italic>P</italic> values. Table <xref ref-type="table" rid="T1">1</xref> shows the results, from which we see that a value of <italic>P</italic> = 85% of <italic>T</italic> gives the optimal results with respect to the Silhouette width as well as the number of clusters, with multi-member clusters and singletons being shown separately.</p>
      <table-wrap position="float" id="T1">
        <label>Table 1</label>
        <caption>
          <p>Comparison of different values of P</p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col align="left"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th align="left">
                <bold>P Value</bold>
              </th>
              <th align="center">
                <bold>Clusters</bold>
              </th>
              <th align="center">
                <bold>Singletons</bold>
              </th>
              <th align="center">
                <bold>Silhouette width</bold>
              </th>
              <th align="center">
                <bold>Avg Std</bold>
              </th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="left" valign="bottom">T<hr/></td>
              <td align="center" valign="bottom">30<hr/></td>
              <td align="center" valign="bottom">6<hr/></td>
              <td align="center" valign="bottom">0.1719<hr/></td>
              <td align="center" valign="bottom">1.1740<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">0.95 × T<hr/></td>
              <td align="center" valign="bottom">10<hr/></td>
              <td align="center" valign="bottom">4<hr/></td>
              <td align="center" valign="bottom">0.5240<hr/></td>
              <td align="center" valign="bottom">4.2715<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">0.90 × T<hr/></td>
              <td align="center" valign="bottom">10<hr/></td>
              <td align="center" valign="bottom">1<hr/></td>
              <td align="center" valign="bottom">0.5650<hr/></td>
              <td align="center" valign="bottom">4.3176<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">0.85 × T<hr/></td>
              <td align="center" valign="bottom">10<hr/></td>
              <td align="center" valign="bottom">0<hr/></td>
              <td align="center" valign="bottom">0.5961<hr/></td>
              <td align="center" valign="bottom">4.6604<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">0.80 × T<hr/></td>
              <td align="center" valign="bottom">10<hr/></td>
              <td align="center" valign="bottom">0<hr/></td>
              <td align="center" valign="bottom">0.5955<hr/></td>
              <td align="center" valign="bottom">4.8175<hr/></td>
            </tr>
            <tr>
              <td align="left">0.75 × T</td>
              <td align="center">10</td>
              <td align="center">0</td>
              <td align="center">0.5955</td>
              <td align="center">4.8175</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>The table summarizes the performance of the different P values for the threshold inclusion rule. The numbers of multi-member clusters and singletons are given separately, so that the total numbers of clusters at each P value are 36, 14, 11, 10, 10, and 10, respectively. The Silhouette width and the average of the standard deviations of the distributions of intra-cluster similarities in each cluster are also shown.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>After the data are assigned to clusters, a final refinement step is applied to all points that have an average similarity score less than <italic>T</italic> when compared to the members of the cluster they have been assigned to. Each such point has its average similarity calculated with every cluster and is assigned to the cluster to which it is most similar (if this is not its original cluster, then the process moves the point to a different cluster; this assignment to a cluster is made even if the point’s average similarity to the members of its new cluster is less than <italic>T</italic>).</p>
    </sec>
    <sec>
      <title>Selecting the best threshold</title>
      <p>For each of the 20 different <italic>T</italic> values, a clustering has been obtained from the algorithm. For each of these clusterings, the mean Silhouette width (averaged over every point in the dataset) and the Dunn Index of the clustering are computed. The Silhouette width is defined for each element <italic>i</italic> as:</p>
      <p>
        <disp-formula>
          <mml:math id="M4" name="1471-2105-14-213-i4" overflow="scroll">
            <mml:mrow>
              <mml:mi>s</mml:mi>
              <mml:mfenced open="(" close=")">
                <mml:mi>i</mml:mi>
              </mml:mfenced>
              <mml:mo>=</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mfenced open="(" close=")">
                    <mml:mi>i</mml:mi>
                  </mml:mfenced>
                  <mml:mo>−</mml:mo>
                  <mml:mi>a</mml:mi>
                  <mml:mfenced open="(" close=")">
                    <mml:mi>i</mml:mi>
                  </mml:mfenced>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="normal">max</mml:mi>
                  <mml:mfenced open="{" close="}">
                    <mml:mrow>
                      <mml:mi>a</mml:mi>
                      <mml:mfenced open="(" close=")">
                        <mml:mi>i</mml:mi>
                      </mml:mfenced>
                      <mml:mo>,</mml:mo>
                      <mml:mi>b</mml:mi>
                      <mml:mfenced open="(" close=")">
                        <mml:mi>i</mml:mi>
                      </mml:mfenced>
                    </mml:mrow>
                  </mml:mfenced>
                </mml:mrow>
              </mml:mfrac>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>where <italic>a</italic>(<italic>i</italic>) is the average dissimilarity, where dissimilarity is 1-similarity, of element <italic>i</italic> with all the other elements of the same cluster and <italic>b</italic>(i) the average dissimilarity of element <italic>i</italic> to all the members of the closest neighbouring cluster. In order to take singletons into account, a negative score (−1) is given to each singleton point in the proposed clustering. The Dunn Index is defined as:</p>
      <p>
        <disp-formula>
          <mml:math id="M5" name="1471-2105-14-213-i5" overflow="scroll">
            <mml:mrow>
              <mml:mi>D</mml:mi>
              <mml:msub>
                <mml:mi>I</mml:mi>
                <mml:mi>m</mml:mi>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mi>min</mml:mi>
                <mml:mrow>
                  <mml:mn>1</mml:mn>
                  <mml:mo>≤</mml:mo>
                  <mml:mi>i</mml:mi>
                  <mml:mo>≤</mml:mo>
                  <mml:mi>m</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mfenced open="{" close="}">
                <mml:mrow>
                  <mml:munder>
                    <mml:mi>min</mml:mi>
                    <mml:mrow>
                      <mml:mn>1</mml:mn>
                      <mml:mo>≤</mml:mo>
                      <mml:mi>j</mml:mi>
                      <mml:mo>≤</mml:mo>
                      <mml:mi>m</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>j</mml:mi>
                      <mml:mo>≠</mml:mo>
                      <mml:mi>i</mml:mi>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mfenced open="{" close="}">
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:mi>δ</mml:mi>
                        <mml:mfenced open="(" close=")">
                          <mml:mrow>
                            <mml:msub>
                              <mml:mi>C</mml:mi>
                              <mml:mi>i</mml:mi>
                            </mml:msub>
                            <mml:mo>,</mml:mo>
                            <mml:msub>
                              <mml:mi>C</mml:mi>
                              <mml:mi>j</mml:mi>
                            </mml:msub>
                          </mml:mrow>
                        </mml:mfenced>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:munder>
                          <mml:mi>max</mml:mi>
                          <mml:mrow>
                            <mml:mn>1</mml:mn>
                            <mml:mo>≤</mml:mo>
                            <mml:mi>k</mml:mi>
                            <mml:mo>≤</mml:mo>
                            <mml:mi>m</mml:mi>
                          </mml:mrow>
                        </mml:munder>
                        <mml:msub>
                          <mml:mi>Δ</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mfrac>
                  </mml:mfenced>
                </mml:mrow>
              </mml:mfenced>
              <mml:mo>∀</mml:mo>
              <mml:mi>i</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:mi>j</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:mi>k</mml:mi>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>where  <italic>δ</italic>(<italic>C</italic><sub><italic>i</italic></sub>, <italic>C</italic><sub><italic>j</italic></sub>) is the inter-cluster distance between the centres of clusters <italic>i</italic> and <italic>j</italic>, and max <sub>1 ≤ <italic>k</italic> ≤ <italic>m</italic></sub>Δ<sub><italic>k</italic></sub> is the maximum cluster size in the dataset, where cluster size is defined as the mean distance between all members of the cluster and the cluster centroid. The cluster centroid is the element with the maximum similarity to the other members of the cluster. The Silhouette width is the main factor used in deciding which threshold produces the best clustering, and the Dunn Index is used only as a tie-breaker to decide cases where two or more clusterings have the same Silhouette width.</p>
    </sec>
    <sec>
      <title>Convergence</title>
      <p>As mentioned above, the algorithm has a random sampling aspect. In order to increase the probability of ultimately finding the best possible clustering, we choose to repeat the process a number of times. In order to decide a number of repetitions that is time efficient and reduces the probability of runs (of the whole multi-repetition procedure) generating different outputs, we performed a single clustering experiment on our dataset. We ran the algorithm (excluding repetitions) 100 times using a dataset of 1500 2D vectors and, considering the event <italic>A</italic> as “seeing the clustering result with the maximum Silhouette width”, we found <italic>p</italic>(<italic>A</italic>) = <italic>76</italic>%. Therefore, if we run the algorithm only once, we have a 24% probability of not finding the best solution. Ideally, we would like to have a very small probability of such an event. Using four repetitions reduces that probability to 0.3%, which is sufficiently small for our needs. Hence, the whole process is repeated four times and the four different clusterings are retrieved and compared. If all four runs give the same clustering, the algorithm is said to have converged and stops. If not, for each of the six different pairs of clusterings chosen from the four clusterings made, a Rand Index between a pair of clusters is calculated as:</p>
      <p>
        <disp-formula>
          <mml:math id="M6" name="1471-2105-14-213-i6" overflow="scroll">
            <mml:mrow>
              <mml:mi mathvariant="italic">Rand</mml:mi>
              <mml:mspace width="0.5em"/>
              <mml:mi mathvariant="italic">Index</mml:mi>
              <mml:mo>=</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:mi>a</mml:mi>
                  <mml:mo>+</mml:mo>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>a</mml:mi>
                  <mml:mo>+</mml:mo>
                  <mml:mi>b</mml:mi>
                  <mml:mo>+</mml:mo>
                  <mml:mi>c</mml:mi>
                  <mml:mo>+</mml:mo>
                  <mml:mi>d</mml:mi>
                </mml:mrow>
              </mml:mfrac>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>where <italic>α</italic> is the number of cases where two elements are members of the same cluster in both clusterings, <italic>b</italic> is the number of cases where two elements are members of different clusters in both clusterings, <italic>c</italic> is the number of cases where a pair of elements are in the same cluster for the first clustering and in different for the second and <italic>d</italic> is the number of cases where a pair of elements are members of different clusters for the first clustering and members of the same cluster for the second clustering. Using all six different pairs of clusterings we calculate the average Rand Index.</p>
      <p>We use the Rand Index because it is a widely accepted measure of concordance between different clusterings (here, the four clusterings produced by the four runs) and not as a maximization metric compared to some original classification. If the average Rand Index is high (&gt;0.99), this means that most of the runs report near-identical clusterings with no significant differences. Hence, this is enough for the algorithm to converge and report the clustering with the highest Silhouette width. As mentioned above we want to be very confident in the resulting clusters, therefore a very strict average Rand Index of 0.99 (which allows for a limited number of differences in assignment of borderline cases) is applied as a cut-off. In the case of an average Rand Index less than 0.99, we consider that we have found significantly different clusterings. Then, an instance of the clustering with the lowest (or equal lowest) Silhouette width is removed, even if this outcome has been found two or three times, and another randomization is done. This procedure is repeated until convergence.</p>
    </sec>
    <sec>
      <title>Pseudocode</title>
      <p>I. Do four times:</p>
      <p>Stage 1: Calculate D (the distribution of E[X]’s).</p>
      <p>1. Do the specified “randomization” 1000 times:</p>
      <p>i. Randomly select a number of clusters <italic>k</italic>.</p>
      <p>ii. Randomly assign each data point α to a cluster <italic>c</italic>.</p>
      <p>iii. ∀ clusters <italic>c</italic>, calculate <italic>E[X]</italic> for the pairwise point-point similarities within <italic>c</italic> and include this value of <italic>E[X]</italic> in <italic>D</italic>.</p>
      <p>2. For each of the ten percentiles {95.00%, 97.50%, 99.00%, 99.14%, 99.29%, 99.43%, 99.57%, 99.71%, 99.86% and 100.00%} of the distribution <italic>D</italic> of intra-cluster similarities, and for ten further thresholds corresponding to the second to eleventh highest values, retrieve a threshold value <italic>T</italic>.</p>
      <p>Stage 1A: Clustering</p>
      <p>i. While any <italic>α</italic> in the dataset remains unclustered:</p>
      <p>a. Join the two most similar currently unclustered elements to form a new cluster, provided criteria in b. are met.</p>
      <p>b. Calculate average similarity of each currently unclustered data point to the current cluster and keep adding the most similar available data point as a member as long as both:</p>
      <p>– <italic>E</italic>[<italic>X</italic>] of the cluster &gt; <italic>T,</italic> and.</p>
      <p>– the average similarity of the new member to the existing members of the current cluster &gt; 0.85×<italic>T.</italic></p>
      <p>Stage 1B: Clustering Refinement</p>
      <p>ii. ∀ <italic>α</italic> ∈ any <italic>c</italic>, retrieve its average similarity with all the members of its current cluster. If this average similarity &lt; <italic>T</italic> then:</p>
      <p>a. If its average similarity with elements of any other cluster is more than that with the parent cluster, move the point <italic>α</italic> to this other cluster.</p>
      <p>iii. Measure the Silhouette width, averaged over all points with singletons each contributing −1, and the Dunn Index for the final clustering for this <italic>T</italic> value.</p>
      <p>3. Return the <italic>T</italic> value and resultant clustering with the best Silhouette width as the result of the run; in the event of a tie, use the Dunn Index to decide.</p>
      <p>II. Repeat until Convergence:</p>
      <p> Stage 2: Convergence (measure the Rand Index between each of the four runs)</p>
      <p>1. If average Rand Index amongst all 6 pairs taken from the 4 clusterings ≥ 0.99, return the clustering with the best Silhouette width as the final result (algorithm converged).</p>
      <p>2. If this average Rand Index &lt; 0.99, the algorithm has not converged and the clustering with the lowest Silhouette width is discarded and we repeat <italic>Stage 1</italic> a single time to generate a new clustering.</p>
    </sec>
    <sec>
      <title>Validation</title>
      <p>In order to validate PFClust, we used a number of synthetic 2D datasets. The first dataset consisted of 3000 2D vectors distributed over 20 groups; for each of these groups, the probability density function falls off with distance from its centre according to a normal distribution. Hence the groups are approximately circular. Each group corresponds to the external gold standard definition of a cluster. We also used subsets of 300 and 450 2D vectors, respectively composed of two and three out of the 20 groups in the 3000 vector dataset. The second dataset consisted of 5000 2D vectors distributed over 15 groups, which vary in shape. Finally, the third dataset consisted of 928 2D vectors distributed over 20 clusters, which all have different member densities. In each dataset, the centres are chosen such that there is no significant overlap between groups, though a handful of outlier points appear within an apparently ‘wrong’ group. We performed three different experiments based on the first dataset, in order to illustrate that the method was not finely tuned for a specific number of clusters or cluster structure. We define similarity as one minus the normalized (such that the most distant point is one unit from the origin of the coordinate system) Euclidean distance between two points. We would therefore expect PFClust to perform optimally where the clusters are approximately circular.</p>
      <p>On all our datasets, we run PFClust as well as six other current state-of-the-art algorithms. These are (i) the hierarchical clustering algorithm Hierarchy [<xref ref-type="bibr" rid="B6">6</xref>]; (ii) the hierarchical AGlomerative NESting (Agnes) [<xref ref-type="bibr" rid="B22">22</xref>], (iii) the partitional k-means clustering algorithm [<xref ref-type="bibr" rid="B7">7</xref>], (iv) Clustering Large Applications (Clara) [<xref ref-type="bibr" rid="B23">23</xref>], which is based on repeated k-mediods clustering of samples, (v) Density-Based Algorithm for Discovering Clusters in Large Spatial Databases (DBSCAN) [<xref ref-type="bibr" rid="B24">24</xref>] and (vi) Model-Based Clustering (Mix Model) [<xref ref-type="bibr" rid="B25">25</xref>]. We used available implementations of each of these methods in the statistical software suite R, [<xref ref-type="bibr" rid="B26">26</xref>] the relevant packages are listed in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>: Table S1. These algorithms cannot all be compared on the ability to find the optimal number of clusters. Only PFClust and DBSCAN amongst the methods considered here can do this, and in fact the latter algorithm requires two parameters to be optimised before it decides the number of clusters. Hence, for the five other methods, we will use the externally defined ‘correct’ number of clusters (this definition including singletons in the count of clusters) as a given parameter and compare how well each algorithm clusters the data compared to the original classification. In order to compare the different clustering approaches, we selected the Rand Index as a measure of agreement between the externally known ‘correct’ clustering and that produced by a clustering algorithm.</p>
      <p>We ran k-means and Clara 100 times each on every dataset and have selected as the final result for each algorithm the one with the best Silhouette width. For the <italic>epsilon</italic> parameter of DBSCAN, the maximum permitted distance between a point and its closest intra-cluster neighbour, we examined all values between 0 and 1 with a step size of 0.001. We also iterated the <italic>min</italic>-<italic>points</italic> parameter, the minimum number of members allowed in a valid cluster, using all integer values from 1 to 100. This resulted in 10<sup>5</sup> clustering outputs, from which the one with the maximum Silhouette width was selected.</p>
      <p>As an addendum to the main work, we tested the use of the Silhouette width as a characteristic measure from which to decide the correct number of clusters. We ran the deterministic methods once each. We also ran the stochastic Clara and k-means algorithms 100 times each for every number of clusters, k, between 2 and 50. The run with the best Silhouette width for a given algorithm was selected, thus deciding the number of clusters to report.</p>
    </sec>
    <sec>
      <title>Protein fold clustering using polar Fourier expansions</title>
      <p>A shape-density superposition algorithm based on Spherical Polar Fourier (SPF) basis functions has recently been published [<xref ref-type="bibr" rid="B27">27</xref>,<xref ref-type="bibr" rid="B28">28</xref>], in which protein shapes are represented as 3D density functions expressed as expansions of orthonormal basis functions:</p>
      <p>
        <disp-formula>
          <mml:math id="M7" name="1471-2105-14-213-i7" overflow="scroll">
            <mml:mrow>
              <mml:mi>ρ</mml:mi>
              <mml:mfenced open="(" close=")">
                <mml:mrow>
                  <mml:mi>r</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>θ</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>φ</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:mo>=</mml:mo>
              <mml:munderover>
                <mml:mstyle displaystyle="true">
                  <mml:mi mathsize="big">∑</mml:mi>
                </mml:mstyle>
                <mml:mi mathvariant="italic">nlm</mml:mi>
                <mml:mi>N</mml:mi>
              </mml:munderover>
              <mml:msub>
                <mml:mi>α</mml:mi>
                <mml:mi mathvariant="italic">nlm</mml:mi>
              </mml:msub>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mi mathvariant="italic">nl</mml:mi>
              </mml:msub>
              <mml:mfenced open="(" close=")">
                <mml:mi>r</mml:mi>
              </mml:mfenced>
              <mml:msub>
                <mml:mi>y</mml:mi>
                <mml:mi mathvariant="italic">lm</mml:mi>
              </mml:msub>
              <mml:mfenced open="(" close=")">
                <mml:mrow>
                  <mml:mi>θ</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>φ</mml:mi>
                </mml:mrow>
              </mml:mfenced>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>where <italic>y</italic><sub><italic>lm</italic></sub> (<italic>θ</italic>, <italic>φ</italic>) are the real spherical harmonics, <italic>N</italic> is the order of the highest polynomial power of the expansion, <italic>R</italic><sub><italic>nl</italic></sub> (<italic>r</italic>) are radial functions, and α<sub><italic>nlm</italic></sub> are the expansion coefficients which are calculated as described previously [<xref ref-type="bibr" rid="B29">29</xref>]. Mavridis <italic>et al</italic>. proposed in the same paper a novel structure-based indexing for existing classification schemes such as CATH [<xref ref-type="bibr" rid="B19">19</xref>] and SCOP [<xref ref-type="bibr" rid="B20">20</xref>]. Their proposed consensus algorithm works well for only some of the cases it was tested on, because of the structural diversity of a number of protein domains assigned to the same superfamilies [<xref ref-type="bibr" rid="B28">28</xref>]. Hence, methods such as SPF would greatly benefit from an automated clustering algorithm, such as PFClust, which could identify the structure of a dataset without any prior knowledge or parameter tuning.</p>
      <p>In order to illustrate that PFClust could be used to provide such a clustering using the SPF descriptors, we performed the following study. We randomly selected 11 CATH superfamilies, which had in total 224 non-redundant representative structures, and used the SPF descriptors to calculate the all-against-all similarity matrix of these protein domains. We then used PFClust to cluster the protein domain structures based on these similarities.</p>
    </sec>
  </sec>
  <sec>
    <title>Results and discussion</title>
    <sec>
      <title>Original dataset</title>
      <p>In this section, we present the resulting clusters from the 1500 2D vector dataset that was used for the general parameter set up of the algorithm. Figure <xref ref-type="fig" rid="F3">3</xref> shows the results of each method on the 1500 2D vector dataset; the mismatched points for each method are shown in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>: Figure S1. From the Rand Index results in Table <xref ref-type="table" rid="T2">2</xref>, we see that Agnes has the lowest (worst) score; that is mainly because Agnes joins two groups into a single cluster (green and yellow). Furthermore, we have a singleton as one cluster (yellow point). Rather better levels of performance are achieved by the Hierarchy and DBSCAN algorithms. However, Hierarchy has trouble in correctly assigning a number of the boundary cases for some pairs of clusters (particularly around the boundary between the orange and cyan clusters, and also that between yellow and green) and DBSCAN assigns a large number of points as singletons. Finally, the best performing algorithms are PFClust, Clara, k-means and Mix Model, which correctly identify all clusters and boundaries. Although the Rand Indices for these methods are very good, they fail to reproduce perfectly the original ‘correct’ classification because the original dataset has a number of outlier points that lie closer to the centres of different groups, such as purple elements in the cyan and orange groups. So, for example, a purple element is so coloured because in the original grouping it was generated from the normal distribution used to define the purple cluster. However, it is located significantly closer to the centre of the cyan cluster, and thus we believe that a rational classifier should consider it cyan. Nonetheless, the gold standard we are using means that we count the rational classification as incorrect.</p>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p><bold>Comparison of different clustering algorithms.</bold> The 1500 2D vector dataset clustered with all seven different clustering algorithms. In frame <bold>A</bold> the original gold standard clustering is shown. In frames <bold>B</bold>,<bold>C</bold>,<bold>D</bold>,<bold>E</bold>,<bold>F</bold>,<bold>G</bold> and <bold>H,</bold> the proposed clusterings by each method are given.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-213-3"/>
      </fig>
      <table-wrap position="float" id="T2">
        <label>Table 2</label>
        <caption>
          <p>Comparison of the clustering methods based on popular metrics</p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th rowspan="2" align="center">
                <bold>Methods</bold>
              </th>
              <th colspan="8" align="center" valign="bottom">
                <bold>Rand index</bold>
                <hr/>
              </th>
            </tr>
            <tr>
              <th align="center">
                <bold>300</bold>
              </th>
              <th align="center">
                <bold>450</bold>
              </th>
              <th align="center">
                <bold>1500</bold>
              </th>
              <th align="center">
                <bold>3000</bold>
              </th>
              <th align="center">
                <bold>5000</bold>
              </th>
              <th align="center">
                <bold>CATH</bold>
              </th>
              <th align="center">
                <bold>Density</bold>
              </th>
              <th align="center">
                <bold>Average</bold>
              </th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="center" valign="bottom">
                <bold>Hierarchy</bold>
                <hr/>
              </td>
              <td align="center" valign="bottom">0.883<hr/></td>
              <td align="center" valign="bottom">0.942<hr/></td>
              <td align="center" valign="bottom">0.896<hr/></td>
              <td align="center" valign="bottom">0.920<hr/></td>
              <td align="center" valign="bottom">0.981<hr/></td>
              <td align="center" valign="bottom">0.964<hr/></td>
              <td align="center" valign="bottom">0.928<hr/></td>
              <td align="center" valign="bottom">0.931<hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">
                <bold>Agnes</bold>
                <hr/>
              </td>
              <td align="center" valign="bottom">0.947<hr/></td>
              <td align="center" valign="bottom">0.973<hr/></td>
              <td align="center" valign="bottom">0.836<hr/></td>
              <td align="center" valign="bottom">0.820<hr/></td>
              <td align="center" valign="bottom">0.976<hr/></td>
              <td align="center" valign="bottom">0.906<hr/></td>
              <td align="center" valign="bottom">0.975<hr/></td>
              <td align="center" valign="bottom">0.919<hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">
                <bold>Clara</bold>
                <hr/>
              </td>
              <td align="center" valign="bottom">0.960<hr/></td>
              <td align="center" valign="bottom">0.980<hr/></td>
              <td align="center" valign="bottom">0.952<hr/></td>
              <td align="center" valign="bottom">0.948<hr/></td>
              <td align="center" valign="bottom">0.987<hr/></td>
              <td align="center" valign="bottom">1.000<hr/></td>
              <td align="center" valign="bottom">0.956<hr/></td>
              <td align="center" valign="bottom">0.969<hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">
                <bold>k-means</bold>
                <hr/>
              </td>
              <td align="center" valign="bottom">0.960<hr/></td>
              <td align="center" valign="bottom">0.980<hr/></td>
              <td align="center" valign="bottom">0.958<hr/></td>
              <td align="center" valign="bottom">0.966<hr/></td>
              <td align="center" valign="bottom">0.986<hr/></td>
              <td align="center" valign="bottom">0.738<hr/></td>
              <td align="center" valign="bottom">0.901<hr/></td>
              <td align="center" valign="bottom">0.927<hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">
                <bold>Mix Model</bold>
                <hr/>
              </td>
              <td align="center" valign="bottom">0.960<hr/></td>
              <td align="center" valign="bottom">0.980<hr/></td>
              <td align="center" valign="bottom">0.959<hr/></td>
              <td align="center" valign="bottom">0.911<hr/></td>
              <td align="center" valign="bottom">0.990<hr/></td>
              <td align="center" valign="bottom">1.000<hr/></td>
              <td align="center" valign="bottom">0.977<hr/></td>
              <td align="center" valign="bottom">0.968<hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">
                <bold>PFClust</bold>
                <hr/>
              </td>
              <td align="center" valign="bottom">0.960<hr/></td>
              <td align="center" valign="bottom">1.000<hr/></td>
              <td align="center" valign="bottom">0.958<hr/></td>
              <td align="center" valign="bottom">0.949<hr/></td>
              <td align="center" valign="bottom">0.986<hr/></td>
              <td align="center" valign="bottom">0.996<hr/></td>
              <td align="center" valign="bottom">0.976<hr/></td>
              <td align="center" valign="bottom">0.975<hr/></td>
            </tr>
            <tr>
              <td align="center">
                <bold>DBSCAN</bold>
              </td>
              <td align="center">0.973</td>
              <td align="center">0.973</td>
              <td align="center">0.930</td>
              <td align="center">0.921</td>
              <td align="center">0.978</td>
              <td align="center">0.977</td>
              <td align="center">0.688</td>
              <td align="center">0.920</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>The table summarizes the comparison between PFClust and the other six clustering algorithms based on the Rand Index between the clustering predicted by the method in question and the original gold standard clusters.</p>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>Validation</title>
      <p>For the first two experiments with the 300 and 450 2D vectors, all methods perform very well, as shown in Figure <xref ref-type="fig" rid="F4">4</xref>, with only the Hierarchy clustering performing a little worse in comparison with the rest, as can be seen in Table <xref ref-type="table" rid="T2">2</xref> with the mismatched points for each method being shown in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>: Figure S2.</p>
      <fig id="F4" position="float">
        <label>Figure 4</label>
        <caption>
          <p><bold>In frames </bold><bold>A (300 2D vectors) and I (450 2D vectors), two of the datasets that were used and their original gold standard clusterings are shown.</bold> In frames <bold>B</bold>, <bold>C</bold>, <bold>D</bold>, <bold>E</bold>, <bold>F</bold>, <bold>G</bold> and <bold>H</bold>, the proposed clusterings by each method for the 300 2D vector dataset are given. In frames <bold>J</bold>, <bold>K</bold>, <bold>L</bold>, <bold>M</bold>, <bold>N</bold>, <bold>O</bold> and <bold>P</bold>, the proposed clusterings by each method are shown for the 450 2D vector dataset.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-213-4"/>
      </fig>
      <p>Table <xref ref-type="table" rid="T2">2</xref> summarizes the results for all methods on all the different datasets used in this study. We can see from the results that PFClust is the top performing algorithm on average with a mean Rand Index of 0.975, though it perfectly reproduces the original clusters for only one dataset (450 2D vectors).</p>
      <p>When we use all 3000 2D vectors, PFClust suggests a different number of clusters from that in the original clustering. In this case, PFClust finds that there are 21 clusters instead of 20 and splits the light green cluster into two, light green and gold. Even though PFClust suggests a different number of clusters, its very good Rand Index means that it still significantly outperforms the other algorithms, except k-means, as can be seen in Table <xref ref-type="table" rid="T2">2</xref>. Hierarchy, Clara and DBSCAN achieve good Rand Indices, though with some errors on the borderline cases. Mix Model gives a Rand Index that is only slightly worse, but assigns a singleton as one of its 20 clusters and, as seen in Figure <xref ref-type="fig" rid="F5">5</xref>, splits the greenish cluster at the top centre of the diagram between its purple and blue neighbours; the mismatched points for each method are shown in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>: Figure S3. DBSCAN identifies the correct number of multi-member clusters, although as with all datasets it additionally has a large number of points assigned as singletons, shown as open circles in Figure <xref ref-type="fig" rid="F5">5</xref>.</p>
      <fig id="F5" position="float">
        <label>Figure 5</label>
        <caption>
          <p><bold>Comparison of different clustering algorithms.</bold> The 3000 2D vector dataset clustered with all seven different clustering algorithms. For DBSCAN, the open circles denote singletons. In frame <bold>A</bold> the original gold standard clustering is shown. In frames <bold>B</bold>,<bold>C</bold>,<bold>D</bold>,<bold>E</bold>,<bold>F</bold>,<bold>G</bold> and <bold>H</bold>, the proposed clusterings by each method are given. </p>
        </caption>
        <graphic xlink:href="1471-2105-14-213-5"/>
      </fig>
      <p>We also performed another validation study on the bigger dataset of 5000 2D vectors distributed over 15 clusters, in order also to compare the algorithms using a dataset that had different shapes and sizes of clusters, as well as the larger number of data points. As suggested by visual inspection of Figure <xref ref-type="fig" rid="F6">6</xref>, the Rand Index results in Table <xref ref-type="table" rid="T2">2</xref> show that all algorithms perform very well, with Mix Model having the best Rand Index. The mismatched points for each method are shown in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>: Figure S4.</p>
      <fig id="F6" position="float">
        <label>Figure 6</label>
        <caption>
          <p><bold>Comparison of different clustering algorithms.</bold> The 5000 2D vector dataset clustered with all seven different clustering algorithms. For DBSCAN, the open circles denote singletons. In frame <bold>A</bold> the original gold standard clustering is shown. In frames <bold>B</bold>,<bold>C</bold>,<bold>D</bold>,<bold>E</bold>,<bold>F</bold>,<bold>G</bold> and <bold>H</bold>, the proposed clusterings by each method are given.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-213-6"/>
      </fig>
      <p>Another challenge for algorithms is describing datasets that have different densities of points in their original clusters; the 928 2D vector dataset consists of 20 clusters whose densities vary. This is a subset of the D31 dataset taken from [<xref ref-type="bibr" rid="B30">30</xref>], which consists of 31 circular clusters with 100 members each. We then chose a 20 cluster subset of the original dataset and from each cluster we randomly selected a different number of members (varying from 5% to 95%).</p>
      <p>In this case, we see from Figure <xref ref-type="fig" rid="F7">7</xref> that PFClust reports 19 clusters instead of the original 20, integrating the black group into the navy blue and the light green. Of the other methods, only Agnes was able to correctly identify all the groups, but due to the misassignment of some borderline cases it did not achieve a very high Rand Index. DBSCAN has major problems assigning the correct clusters (it finds only 10 multi-member ones), joining many clusters together and again leaving a large number of singletons, as seen in Figure <xref ref-type="fig" rid="F7">7</xref>; the mismatched points for each method are shown in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>: Figure S5.</p>
      <fig id="F7" position="float">
        <label>Figure 7</label>
        <caption>
          <p><bold>Comparison of different clustering algorithms.</bold> The 928 2D vector dataset of 20 clusters of varying density, as clustered by the seven different clustering algorithms. For DBSCAN, the open circles denote singletons. In frame <bold>A</bold> the original gold standard clustering is shown. In frames <bold>B</bold>,<bold>C</bold>,<bold>D</bold>,<bold>E</bold>,<bold>F</bold>,<bold>G</bold> and <bold>H</bold>, the proposed clusterings by each method are given.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-213-7"/>
      </fig>
    </sec>
    <sec>
      <title>PFClust – supervised mode</title>
      <p>While we have shown PFClust to be a very powerful and accurate algorithm, it does take longer to cluster a dataset than most alternative approaches. Table <xref ref-type="table" rid="T3">3</xref> shows how the running time of the algorithm until convergence varies with the number of data points. It is easy to see that the run time grows rapidly as the dataset becomes larger and that the clustering takes considerable amounts of CPU time in order to converge, with most of it being spent in the randomization process.</p>
      <table-wrap position="float" id="T3">
        <label>Table 3</label>
        <caption>
          <p>Supervised and Unsupervised timings for PFClust</p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th align="center">
                <bold>Dataset</bold>
              </th>
              <th align="center">
                <bold>Rand index</bold>
              </th>
              <th align="center">
                <bold>Randomizations</bold>
              </th>
              <th align="center">
                <bold>Clustering</bold>
              </th>
              <th align="center">
                <bold>Total execution time (runs)</bold>
              </th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="center" valign="bottom">CATH folds<hr/></td>
              <td align="center" valign="bottom">0.996<hr/></td>
              <td align="center" valign="bottom">4.3 s<hr/></td>
              <td align="center" valign="bottom">1.8 s<hr/></td>
              <td align="center" valign="bottom">25 s<hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">300 2D Vectors<hr/></td>
              <td align="center" valign="bottom">0.960<hr/></td>
              <td align="center" valign="bottom">8 s<hr/></td>
              <td align="center" valign="bottom">2 s<hr/></td>
              <td align="center" valign="bottom">40 s<hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">450 2D Vectors<hr/></td>
              <td align="center" valign="bottom">1.000<hr/></td>
              <td align="center" valign="bottom">25 s<hr/></td>
              <td align="center" valign="bottom">8 s<hr/></td>
              <td align="center" valign="bottom">2 m 38 s<hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">1500 2D Vectors<hr/></td>
              <td align="center" valign="bottom">0.958<hr/></td>
              <td align="center" valign="bottom">13 m 22 s<hr/></td>
              <td align="center" valign="bottom">5 m 47s<hr/></td>
              <td align="center" valign="bottom">1 h 22 m<hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">3000 2D Vectors<hr/></td>
              <td align="center" valign="bottom">0.949<hr/></td>
              <td align="center" valign="bottom">2 h 24 m 27 s<hr/></td>
              <td align="center" valign="bottom">1 h 14 m 38 s<hr/></td>
              <td align="center" valign="bottom">12 h<hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">5000 2D Vectors<hr/></td>
              <td align="center" valign="bottom">0.986<hr/></td>
              <td align="center" valign="bottom">11 h 35 m 30 s<hr/></td>
              <td align="center" valign="bottom">5 h 20 m 20 s<hr/></td>
              <td align="center" valign="bottom">81 h 50 m 30 s<hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">Density Dataset<hr/></td>
              <td align="center" valign="bottom">0.976<hr/></td>
              <td align="center" valign="bottom">6 m 20 s<hr/></td>
              <td align="center" valign="bottom">2 m 15 s<hr/></td>
              <td align="center" valign="bottom">36 m<hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">1500 Supervised<hr/></td>
              <td align="center" valign="bottom">0.958<hr/></td>
              <td align="center" valign="bottom">-<hr/></td>
              <td align="center" valign="bottom">1 m 50 s<hr/></td>
              <td align="center" valign="bottom">2 m 57 s<hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">3000 Supervised<hr/></td>
              <td align="center" valign="bottom">0.951<hr/></td>
              <td align="center" valign="bottom">-<hr/></td>
              <td align="center" valign="bottom">12 m 20 s<hr/></td>
              <td align="center" valign="bottom">20 m 39 s<hr/></td>
            </tr>
            <tr>
              <td align="center">5000 Supervised</td>
              <td align="center">0.986</td>
              <td align="center">-</td>
              <td align="center">1 h 9 m 30 s</td>
              <td align="center">1 h 21 m 36 s</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>The table summarizes the timings for convergence of PFClust with the different datasets. The total execution time typically includes four randomization and four clustering runs, but in the case of the 5000 2D vectors, the “0.99 average Rand Index between the four clusterings” criterion was not met until a fifth run had been carried out. The second column in the table shows the Rand Index of the final clustering against the original gold standard cluster definitions.</p>
      <p>There exist cases when one wants to cluster large groups of data and time efficiency is very important. For those cases, a supervised mode of PFClust has been implemented in order to significantly speed up the process. The supervised mode of PFClust addresses the cost issue by applying an initial clustering on a training set and estimating a number of thresholds that would finally be applied to full dataset. The training set should be a small subset of the data, representing some coherent groups or clusters amongst the full dataset that we wish to cluster.</p>
      <p>PFClust clusters the training set and uses the three best performing thresholds to estimate a total of nine threshold values (these are selected to allow for some variation). Then these nine values are applied on the full dataset and the clustering with the best Silhouette width is reported. Using the supervised version of the algorithm the time-consuming randomization step is removed, which results in a significant speed-up of the total process.</p>
      <p>As a validation of the supervised mode, we used the dataset with the 1500 vectors in 10 groups, the dataset of 3000 vectors distributed over 20 groups, and the larger one of 5000 vectors distributed over 15 groups. Figure <xref ref-type="fig" rid="F8">8</xref> shows the original dataset and the split between training and full sets, as well as the resulting classification by PFClust. A training set of 300 points was selected and PFClust running using the supervised mode clustered the first two datasets very rapidly, compared to the unsupervised version, and with high accuracy. In more detail, for the dataset of 1500 vectors the algorithm took only three minutes to complete and gave an identical clustering to the unsupervised method. For the 3000 vector group it took only 20 minutes, again with a very good Rand Index of 0.951 compared with the original clustering, and in fact very slightly better than the 0.949 achieved by the unsupervised PFClust. Finally, for the larger group the algorithm used a training set of 626 vectors and took 1 hour and 21 minutes to complete, giving again a very good Rand Index of 0.986. In each case, the Rand Indices achieved by the supervised and unsupervised modes of PFClust are virtually identical, but the supervised mode is much faster.</p>
      <fig id="F8" position="float">
        <label>Figure 8</label>
        <caption>
          <p><bold>Performance of PFClust supervised mode.</bold> The 1500, 3000 and 5000 2D vector datasets clustered with PFClust supervised mode. Frames <bold>A</bold>, <bold>C</bold> &amp;<bold>E</bold> show the original datasets, the training sets are coloured in red and the rest in black. Frames <bold>B</bold>, <bold>D</bold> &amp;<bold>F</bold> show the clusterings generated by PFClust supervised mode.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-213-8"/>
      </fig>
    </sec>
    <sec>
      <title>Protein fold clustering using polar Fourier expansions</title>
      <p>When we used PFClust to cluster the 224 protein domains in 11 CATH superfamilies, as shown in Table <xref ref-type="table" rid="T4">4</xref>, the program reported 11 multi-member clusters and one singleton protein domain, i.e., 12 clusters in total. Figure <xref ref-type="fig" rid="F9">9</xref> shows as a heat map the all-against-all similarity matrix of protein domains, each row is colour coded according to the CATH classification and each column according to the PFClust clustering.</p>
      <table-wrap position="float" id="T4">
        <label>Table 4</label>
        <caption>
          <p>CATH superfamilies selected for the study</p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col align="center"/>
            <col align="left"/>
            <col align="center"/>
            <col align="center"/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th align="center" valign="middle">
                <bold>Superfamily</bold>
              </th>
              <th align="left" valign="middle">
                <bold>Name</bold>
              </th>
              <th align="center" valign="middle">
                <bold>Members</bold>
              </th>
              <th align="center" valign="middle">
                <bold>Representative structure</bold>
              </th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="center" valign="bottom">1.20.140.10<hr/></td>
              <td align="left" valign="bottom">Butyryl-CoA Dehydrogenase, subunit A, domain 3<hr/></td>
              <td align="center" valign="bottom">13<hr/></td>
              <td align="center" valign="bottom">
                <disp-formula>
                  <graphic xlink:href="1471-2105-14-213-i8.gif"/>
                </disp-formula>
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center" valign="bottom">1.25.40.20<hr/></td>
              <td align="left" valign="bottom">-<hr/></td>
              <td align="center" valign="bottom">21<hr/></td>
              <td align="center" valign="bottom">
                <disp-formula>
                  <graphic xlink:href="1471-2105-14-213-i9.gif"/>
                </disp-formula>
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center" valign="bottom">2.80.10.50<hr/></td>
              <td align="left" valign="bottom">-<hr/></td>
              <td align="center" valign="bottom">40<hr/></td>
              <td align="center" valign="bottom">
                <disp-formula>
                  <graphic xlink:href="1471-2105-14-213-i10.gif"/>
                </disp-formula>
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center" valign="bottom">2.30.42.10<hr/></td>
              <td align="left" valign="bottom">-<hr/></td>
              <td align="center" valign="bottom">55<hr/></td>
              <td align="center" valign="bottom">
                <disp-formula>
                  <graphic xlink:href="1471-2105-14-213-i11.gif"/>
                </disp-formula>
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center" valign="bottom">2.40.100.10<hr/></td>
              <td align="left" valign="bottom">Cyclophilin<hr/></td>
              <td align="center" valign="bottom">10<hr/></td>
              <td align="center" valign="bottom">
                <disp-formula>
                  <graphic xlink:href="1471-2105-14-213-i12.gif"/>
                </disp-formula>
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center" valign="bottom">2.40.110.10<hr/></td>
              <td align="left" valign="bottom">Butyryl-CoA Dehydrogenase, subunit A, domain 2<hr/></td>
              <td align="center" valign="bottom">7<hr/></td>
              <td align="center" valign="bottom">
                <disp-formula>
                  <graphic xlink:href="1471-2105-14-213-i13.gif"/>
                </disp-formula>
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center" valign="bottom">3.30.500.10<hr/></td>
              <td align="left" valign="bottom">Murine Class I Major Histocompatibility Complex, H2-DB, subunit A, domain 1<hr/></td>
              <td align="center" valign="bottom">13<hr/></td>
              <td align="center" valign="bottom">
                <disp-formula>
                  <graphic xlink:href="1471-2105-14-213-i14.gif"/>
                </disp-formula>
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center" valign="bottom">3.40.50.80<hr/></td>
              <td align="left" valign="bottom">Nucleotide-binding domain of ferredoxin-NADP reductase (FNR) module<hr/></td>
              <td align="center" valign="bottom">14<hr/></td>
              <td align="center" valign="bottom">
                <disp-formula>
                  <graphic xlink:href="1471-2105-14-213-i15.gif"/>
                </disp-formula>
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center" valign="bottom">3.40.50.1220<hr/></td>
              <td align="left" valign="bottom">TPP-binding domain<hr/></td>
              <td align="center" valign="bottom">16<hr/></td>
              <td align="center" valign="bottom">
                <disp-formula>
                  <graphic xlink:href="1471-2105-14-213-i16.gif"/>
                </disp-formula>
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center" valign="bottom">3.90.110.10<hr/></td>
              <td align="left" valign="bottom">L-2-Hydroxyisocaproate Dehydrogenase, subunit A, domain 2<hr/></td>
              <td align="center" valign="bottom">11<hr/></td>
              <td align="center" valign="bottom">
                <disp-formula>
                  <graphic xlink:href="1471-2105-14-213-i17.gif"/>
                </disp-formula>
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center">3.90.79.10</td>
              <td align="left">Nucleoside Triphosphate Pyrophosphohydrolase</td>
              <td align="center">24</td>
              <td align="center">
                <disp-formula>
                  <graphic xlink:href="1471-2105-14-213-i18.gif"/>
                </disp-formula>
              </td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>The 11 CATH superfamilies that were selected to be clustered.</p>
        </table-wrap-foot>
      </table-wrap>
      <fig id="F9" position="float">
        <label>Figure 9</label>
        <caption>
          <p><bold>Heat map of protein domain to protein domain density similarities.</bold> On the row side, the protein domains are coloured according to the CATH classification; on the column side, the protein domains are coloured according to PFClust.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-213-9"/>
      </fig>
      <p>The agreement between PFClust and the CATH classification is nearly perfect with a Rand Index of 0.996. There is only a minor difference between the original classification and the classification of PFClust, where the 1q27A00 protein domain was classified as a singleton, whereas CATH has it assigned to the 3.90.79.10 superfamily. We also tested the other clustering algorithms against this dataset and set the number of clusters to 11 for the five algorithms requiring this parameter. Table <xref ref-type="table" rid="T2">2</xref> summarizes the performance of each method, and Figure <xref ref-type="fig" rid="F10">10</xref> visually shows the agreements and disagreements between the different clustering algorithms. We see that Mix Model and Clara are the top performing clustering algorithms, reproducing the exact CATH classification.</p>
      <fig id="F10" position="float">
        <label>Figure 10</label>
        <caption>
          <p><bold>Clustering comparison between the different algorithms and CATH.</bold> The results of each of the different clustering algorithms as coloured lines, CATH colours represent different CATH superfamilies similarly to Figure <xref ref-type="fig" rid="F9">9</xref>.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-213-10"/>
      </fig>
    </sec>
    <sec>
      <title>Finding the correct number of clusters</title>
      <p>For each of the aforementioned datasets, we tested the use of the Silhouette width as the criterion for identifying the number of clusters – similarly to the way we ran DBSCAN. Since all the algorithms depended on a single parameter <italic>k</italic> (number of clusters, inclusive of singletons), we varied this number from 2 to 50 and the results are shown in Figure <xref ref-type="fig" rid="F11">11</xref>. Note that these data are considered separately and do not contribute to the main results described previously, for which purpose the ‘correct’ number of clusters was instead passed to Hierarchy, Agnes, Clara, k-means and Mix Model as a parameter.</p>
      <fig id="F11" position="float">
        <label>Figure 11</label>
        <caption>
          <p><bold>Using Silhouette width to define the stopping rule.</bold> As an addendum to the main work, we tested the use of the Silhouette width as a characteristic measure from which to decide the correct number of clusters. We ran the deterministic methods once each. We also ran the stochastic Clara and k-means algorithms 100 times each for every number of clusters, k, between 2 and 50. The run with the best Silhouette width for a given algorithm was selected, thus deciding the number of clusters to report.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-213-11"/>
      </fig>
      <p>We see that in most cases, except for the density dataset, at least one method found the correct number of clusters by using the maximum Silhouette width as the stopping criterion. However, no method is consistently able to do this for the different datasets.</p>
    </sec>
  </sec>
  <sec sec-type="conclusions">
    <title>Conclusions</title>
    <p>It has been shown that PFClust can accurately group data according to their similarities without the need for any parameter tuning. Our clustering results on the synthetic datasets not only show that PFClust provides structurally meaningful clusters, but also that it performs best when compared to six other well-known clustering algorithms. Clustering protein domains using a density representation gives excellent agreement with the CATH part-manually curated classification. In the future, the full CATH database could be automatically clustered based on such density representations of protein domains.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors have received funding from WADA. Other than this sponsorship, the authors declare no conflict of interest.</p>
  </sec>
  <sec>
    <title>Authors’ contributions</title>
    <p>LM conceived and implemented the algorithm, carried out the experiments with PFClust and participated in the drafting of the manuscript. LM and NN designed the experimental and validation studies and carried out the comparison of PFClust with the other methods. NN participated in the drafting of the manuscript. JBOM participated in the drafting of the manuscript and provided guidance. All authors read and approved the final manuscript.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="S1">
      <caption>
        <title>Additional file 1: Figure S1</title>
        <p>Comparison of different clustering algorithms; <bold>Figure S2.</bold> Comparison of the 300 and 450 2D vector datasets; <bold>Figure S3.</bold> Comparison of different clustering algorithms; <bold>Figure S4.</bold> Comparison of different clustering algorithms; <bold>Figure S5.</bold> Comparison of different clustering algorithms; <bold>Table S1.</bold> R packages used in the comparison of different clustering methodologies.</p>
      </caption>
      <media xlink:href="1471-2105-14-213-S1.pdf">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>This project has been carried out with the support of WADA. JBOM and NN thank the Scottish Universities Life Sciences Alliance (SULSA) and the Scottish Overseas Research Student Awards Scheme of the Scottish Funding Council (SFC) for financial support. We thank Dr Luna De Ferrari for her valuable comments on this manuscript.</p>
  </sec>
  <sec>
    <title>Availability</title>
    <p>By request to the corresponding author, <email>lazaros.mavridis.lm@gmail.com</email>.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Harlow</surname>
          <given-names>TJ</given-names>
        </name>
        <name>
          <surname>Gogarten</surname>
          <given-names>JP</given-names>
        </name>
        <name>
          <surname>Ragan</surname>
          <given-names>MA</given-names>
        </name>
        <article-title>A hybrid clustering approach to recognition of protein families in 114 microbial genomes</article-title>
        <source>BMC Bioinformatics</source>
        <year>2004</year>
        <volume>5</volume>
        <fpage>45</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-5-45</pub-id>
        <?supplied-pmid 15115543?>
        <pub-id pub-id-type="pmid">15115543</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="book">
        <name>
          <surname>Zhu</surname>
          <given-names>X</given-names>
        </name>
        <article-title>Semi-Supervised Learning Literature Survey</article-title>
        <source>Technical Report 1530, Department of Computer Sciences</source>
        <year>2005</year>
        <publisher-name>Madison: University of Wisconsin</publisher-name>
        <comment>
          <ext-link ext-link-type="uri" xlink:href="http://pages.cs.wisc.edu/~jerryzhu/pub/ssl_survey.pdf">http://pages.cs.wisc.edu/~jerryzhu/pub/ssl_survey.pdf</ext-link>
        </comment>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Pise</surname>
          <given-names>NN</given-names>
        </name>
        <name>
          <surname>Kulkarni</surname>
          <given-names>P</given-names>
        </name>
        <article-title>A Survey of Semi-Supervised Learning Methods</article-title>
        <source>International Conference on Computational Intelligence and Security</source>
        <year>2008</year>
        <volume>30</volume>
        <fpage>34</fpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4724730">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4724730</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Jain</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Murty</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Flynn</surname>
          <given-names>P</given-names>
        </name>
        <article-title>Data clustering: a review</article-title>
        <source>ACM Comput Surv</source>
        <year>1991</year>
        <volume>31</volume>
        <fpage>264</fpage>
        <lpage>323</lpage>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Handl</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Knowles</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Kell</surname>
          <given-names>DB</given-names>
        </name>
        <article-title>Computational cluster validation in post-genomic data analysis</article-title>
        <source>Bioinformatics</source>
        <year>2005</year>
        <volume>21</volume>
        <fpage>3201</fpage>
        <lpage>3212</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bti517</pub-id>
        <?supplied-pmid 15914541?>
        <pub-id pub-id-type="pmid">15914541</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Lance</surname>
          <given-names>BGN</given-names>
        </name>
        <name>
          <surname>Williams</surname>
          <given-names>WT</given-names>
        </name>
        <article-title>A general theory of classificatory sorting strategies 1. Hierarchical systems</article-title>
        <source>Comput J</source>
        <year>1967</year>
        <volume>9</volume>
        <fpage>373</fpage>
        <lpage>380</lpage>
        <pub-id pub-id-type="doi">10.1093/comjnl/9.4.373</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Jain</surname>
          <given-names>AK</given-names>
        </name>
        <article-title>Data clustering: 50 years beyond K-means</article-title>
        <source>Pattern Recognition Letters</source>
        <year>2010</year>
        <volume>31</volume>
        <fpage>651</fpage>
        <lpage>666</lpage>
        <pub-id pub-id-type="doi">10.1016/j.patrec.2009.09.011</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Tibshirani</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Walther</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Hastie</surname>
          <given-names>T</given-names>
        </name>
        <article-title>Estimating the number of clusters in a data set via the gap statistic</article-title>
        <source>Journal of the Royal Statistical Society Series B Statistical Methodology</source>
        <year>2001</year>
        <volume>63</volume>
        <fpage>411</fpage>
        <lpage>423</lpage>
        <pub-id pub-id-type="doi">10.1111/1467-9868.00293</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Giancarlo</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Scaturro</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Utro</surname>
          <given-names>F</given-names>
        </name>
        <article-title>Computational cluster validation for microarray data analysis: experimental assessment of Clest, Consensus Clustering, Figure of Merit. Gap Statistics and Model Explorer</article-title>
        <source>BMC Bioinformatics</source>
        <year>2008</year>
        <volume>9</volume>
        <fpage>462</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-9-462</pub-id>
        <?supplied-pmid 18959783?>
        <pub-id pub-id-type="pmid">18959783</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Rousseeuw</surname>
          <given-names>P</given-names>
        </name>
        <article-title>Silhouettes: a graphical aid to the interpretation and validation of cluster analysis</article-title>
        <source>J Comput Appl Math</source>
        <year>1987</year>
        <volume>20</volume>
        <fpage>53</fpage>
        <lpage>65</lpage>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Dunn</surname>
          <given-names>JC</given-names>
        </name>
        <article-title>A Fuzzy Relative of the ISODATA Process and Its Use in Detecting Compact Well-Separated Clusters</article-title>
        <source>J Cybernetics</source>
        <year>1973</year>
        <volume>3</volume>
        <fpage>32</fpage>
        <lpage>57</lpage>
        <pub-id pub-id-type="doi">10.1080/01969727308546046</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bezdek</surname>
          <given-names>JC</given-names>
        </name>
        <name>
          <surname>Pal</surname>
          <given-names>NR</given-names>
        </name>
        <article-title>Some new indexes of cluster validity</article-title>
        <source>IEEE transactions on systems, man, and cybernetics. Part B, Cybernetics</source>
        <year>1998</year>
        <volume>28</volume>
        <fpage>15</fpage>
        <pub-id pub-id-type="doi">10.1109/3477.658574</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Rand</surname>
          <given-names>WM</given-names>
        </name>
        <article-title>Objective Criteria for the Evaluation of Clustering Methods</article-title>
        <source>J Am Stat Assoc</source>
        <year>1971</year>
        <volume>66</volume>
        <fpage>846</fpage>
        <lpage>850</lpage>
        <pub-id pub-id-type="doi">10.1080/01621459.1971.10482356</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="book">
        <name>
          <surname>Akoglu</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Tong</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Meeder</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Faloutsos</surname>
          <given-names>C</given-names>
        </name>
        <source>PICS: Parameter-free Identification of Cohesive Subgroups in Large Attributed Graphs</source>
        <year>2012</year>
        <publisher-name>Anaheim, CA: SDM</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Shenoy</surname>
          <given-names>SR</given-names>
        </name>
        <name>
          <surname>Jayaram</surname>
          <given-names>B</given-names>
        </name>
        <article-title>Proteins: sequence to structure and function–current status</article-title>
        <source>Curr Protein Pept Sci</source>
        <year>2010</year>
        <volume>11</volume>
        <fpage>498</fpage>
        <lpage>514</lpage>
        <pub-id pub-id-type="doi">10.2174/138920310794109094</pub-id>
        <?supplied-pmid 20887265?>
        <pub-id pub-id-type="pmid">20887265</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Wu</surname>
          <given-names>CH</given-names>
        </name>
        <name>
          <surname>Huang</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Arminski</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Castro-Alvear</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Chen</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Hu</surname>
          <given-names>ZZ</given-names>
        </name>
        <name>
          <surname>Ledley</surname>
          <given-names>RS</given-names>
        </name>
        <name>
          <surname>Lewis</surname>
          <given-names>KC</given-names>
        </name>
        <name>
          <surname>Mewes</surname>
          <given-names>HW</given-names>
        </name>
        <name>
          <surname>Orcutt</surname>
          <given-names>BC</given-names>
        </name>
        <name>
          <surname>Suzek</surname>
          <given-names>BE</given-names>
        </name>
        <name>
          <surname>Tsugita</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Vinayaka</surname>
          <given-names>CR</given-names>
        </name>
        <name>
          <surname>Yeh</surname>
          <given-names>LSL</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Barker</surname>
          <given-names>WC</given-names>
        </name>
        <article-title>The Protein Information Resource: an integrated public resource of functional annotation of proteins</article-title>
        <source>Nucleic Acids Res</source>
        <year>2002</year>
        <volume>30</volume>
        <fpage>35</fpage>
        <lpage>37</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/30.1.35</pub-id>
        <?supplied-pmid 11752247?>
        <pub-id pub-id-type="pmid">11752247</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Finn</surname>
          <given-names>RD</given-names>
        </name>
        <name>
          <surname>Mistry</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Tate</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Coggill</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Heger</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Pollington</surname>
          <given-names>JE</given-names>
        </name>
        <name>
          <surname>Gavin</surname>
          <given-names>OL</given-names>
        </name>
        <name>
          <surname>Gunasekaran</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Ceric</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Forslund</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Holm</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Sonnhammer</surname>
          <given-names>ELL</given-names>
        </name>
        <name>
          <surname>Eddy</surname>
          <given-names>SR</given-names>
        </name>
        <name>
          <surname>Bateman</surname>
          <given-names>A</given-names>
        </name>
        <article-title>The Pfam protein families database</article-title>
        <source>Nucleic Acids Res</source>
        <year>2010</year>
        <volume>38</volume>
        <fpage>D211</fpage>
        <lpage>D222</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkp985</pub-id>
        <?supplied-pmid 19920124?>
        <pub-id pub-id-type="pmid">19920124</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Berman</surname>
          <given-names>HM</given-names>
        </name>
        <name>
          <surname>Westbrook</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Feng</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Gilliland</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Bhat</surname>
          <given-names>TN</given-names>
        </name>
        <name>
          <surname>Weissig</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Shindyalov</surname>
          <given-names>IN</given-names>
        </name>
        <name>
          <surname>Bourne</surname>
          <given-names>PE</given-names>
        </name>
        <article-title>The Protein Data Bank</article-title>
        <source>Nucleic Acids Res</source>
        <year>2000</year>
        <volume>28</volume>
        <fpage>235</fpage>
        <lpage>242</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/28.1.235</pub-id>
        <?supplied-pmid 10592235?>
        <pub-id pub-id-type="pmid">10592235</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Cuff</surname>
          <given-names>AL</given-names>
        </name>
        <name>
          <surname>Sillitoe</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Lewis</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Redfern</surname>
          <given-names>OC</given-names>
        </name>
        <name>
          <surname>Garratt</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Thornton</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Orengo</surname>
          <given-names>CA</given-names>
        </name>
        <article-title>The CATH classification revisited–architectures reviewed and new ways to characterize structural divergence in superfamilies</article-title>
        <source>Nucleic Acids Res</source>
        <year>2009</year>
        <volume>37</volume>
        <fpage>D310</fpage>
        <lpage>314</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkn877</pub-id>
        <?supplied-pmid 18996897?>
        <pub-id pub-id-type="pmid">18996897</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Murzin</surname>
          <given-names>AG</given-names>
        </name>
        <name>
          <surname>Brenner</surname>
          <given-names>SE</given-names>
        </name>
        <name>
          <surname>Hubbard</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Chothia</surname>
          <given-names>C</given-names>
        </name>
        <article-title>SCOP: a structural classification of proteins database for the investigation of sequences and structures</article-title>
        <source>J Mol Biol</source>
        <year>1995</year>
        <volume>247</volume>
        <fpage>536</fpage>
        <lpage>540</lpage>
        <?supplied-pmid 7723011?>
        <pub-id pub-id-type="pmid">7723011</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Berman</surname>
          <given-names>HM</given-names>
        </name>
        <article-title>The Protein Data Bank: a historical perspective</article-title>
        <source>Acta Crystallographica Section A Foundations of Crystallography</source>
        <year>2008</year>
        <volume>64</volume>
        <fpage>88</fpage>
        <lpage>95</lpage>
        <pub-id pub-id-type="doi">10.1107/S0108767307035623</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="book">
        <name>
          <surname>Kaufman</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Rousseeuw</surname>
          <given-names>PJ</given-names>
        </name>
        <source>Finding Groups in Data: An Introduction to Cluster Analysis</source>
        <year>1990</year>
        <publisher-name>New York: Wiley</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Wei</surname>
          <given-names>C</given-names>
        </name>
        <article-title>Empirical Comparison of Fast Clustering Algorithms for Large Data Sets</article-title>
        <source>Experts Systems with Applications</source>
        <year>2003</year>
        <volume>24</volume>
        <fpage>351</fpage>
        <lpage>363</lpage>
        <pub-id pub-id-type="doi">10.1016/S0957-4174(02)00185-9</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="other">
        <name>
          <surname>Ester</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Kriegel</surname>
          <given-names>HP</given-names>
        </name>
        <name>
          <surname>Sander</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Xu</surname>
          <given-names>X</given-names>
        </name>
        <source>A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise. Proceedings of 2nd International Conference on Knowledge Discovery and Data Mining</source>
        <year>1996</year>
        <fpage>226</fpage>
        <lpage>231</lpage>
        <comment>KDD-96</comment>
      </mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Fraley</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Raftery</surname>
          <given-names>AE</given-names>
        </name>
        <article-title>Model-based clustering, discriminant analysis, and density estimation</article-title>
        <source>J Am Stat Assoc</source>
        <year>2002</year>
        <volume>97</volume>
        <fpage>611</fpage>
        <lpage>631</lpage>
        <pub-id pub-id-type="doi">10.1198/016214502760047131</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="book">
        <source>R: A language and environment for statistical computing; R development core team</source>
        <year>2005</year>
        <publisher-name>Vienna, Austria: R foundation for statistical computing</publisher-name>
        <comment>
          <ext-link ext-link-type="uri" xlink:href="http://www.r-project.org/">http://www.r-project.org/</ext-link>
        </comment>
        <?supplied-pmid 23519455?>
      </mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="other">
        <name>
          <surname>Mavridis</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Ritchie</surname>
          <given-names>DW</given-names>
        </name>
        <article-title>3D-Blast: 3D protein structure alignment, comparison, and classification using spherical polar fourier correlations</article-title>
        <source>Pac Symp Biocomput</source>
        <year>2010</year>
        <fpage>281</fpage>
        <lpage>292</lpage>
        <pub-id pub-id-type="pmid">19908380</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Mavridis</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Ghoorah</surname>
          <given-names>AW</given-names>
        </name>
        <name>
          <surname>Venkatraman</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Ritchie</surname>
          <given-names>DW</given-names>
        </name>
        <article-title>Representing and comparing protein folds and fold families using three-dimensional shape-density representations</article-title>
        <source>Proteins: Structure, Function and Bioinformatics</source>
        <year>2011</year>
        <volume>80</volume>
        <fpage>530</fpage>
        <lpage>545</lpage>
      </mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Ritchie</surname>
          <given-names>DW</given-names>
        </name>
        <name>
          <surname>Kemp</surname>
          <given-names>GJ</given-names>
        </name>
        <article-title>Protein docking using spherical polar Fourier correlations</article-title>
        <source>Proteins</source>
        <year>2000</year>
        <volume>39</volume>
        <fpage>178</fpage>
        <lpage>194</lpage>
        <pub-id pub-id-type="doi">10.1002/(SICI)1097-0134(20000501)39:2&lt;178::AID-PROT8&gt;3.0.CO;2-6</pub-id>
        <?supplied-pmid 10737939?>
        <pub-id pub-id-type="pmid">10737939</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Veenman</surname>
          <given-names>CJ</given-names>
        </name>
        <name>
          <surname>Reinders</surname>
          <given-names>MJT</given-names>
        </name>
        <name>
          <surname>Backer</surname>
          <given-names>E</given-names>
        </name>
        <article-title>A maximum variance cluster algorithm</article-title>
        <source>Pattern Analysis and Machine Intelligence, IEEE Transactions</source>
        <year>2002</year>
        <volume>24</volume>
        <fpage>1273</fpage>
        <lpage>1280</lpage>
        <pub-id pub-id-type="doi">10.1109/TPAMI.2002.1033218</pub-id>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
