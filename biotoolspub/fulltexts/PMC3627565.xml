<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <?epub January-28-2013?>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Nucleic Acids Res</journal-id>
    <journal-id journal-id-type="iso-abbrev">Nucleic Acids Res</journal-id>
    <journal-id journal-id-type="publisher-id">nar</journal-id>
    <journal-id journal-id-type="hwp">nar</journal-id>
    <journal-title-group>
      <journal-title>Nucleic Acids Research</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">0305-1048</issn>
    <issn pub-type="epub">1362-4962</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3627565</article-id>
    <article-id pub-id-type="pmid">23358824</article-id>
    <article-id pub-id-type="doi">10.1093/nar/gkt005</article-id>
    <article-id pub-id-type="publisher-id">gkt005</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methods Online</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Fast and accurate read mapping with approximate seeds and multiple backtracking</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Siragusa</surname>
          <given-names>Enrico</given-names>
        </name>
        <xref ref-type="aff" rid="gkt005-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="gkt005-AFF1">
          <sup>2</sup>
        </xref>
        <xref ref-type="corresp" rid="gkt005-COR1">*</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Weese</surname>
          <given-names>David</given-names>
        </name>
        <xref ref-type="aff" rid="gkt005-AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Reinert</surname>
          <given-names>Knut</given-names>
        </name>
        <xref ref-type="aff" rid="gkt005-AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
    </contrib-group>
    <aff id="gkt005-AFF1"><sup>1</sup>Department of Mathematics and Computer Science, Freie Universität Berlin, Takustr. 9, 14195 Berlin, Germany and <sup>2</sup>Max Planck Institute for Molecular Genetics, Ihnestr. 63-73, 14195 Berlin, Germany</aff>
    <author-notes>
      <corresp id="gkt005-COR1">*To whom correspondence should be addressed. Tel: <phone>+49 3083 875 244</phone>; Fax: <fax>+49 3083 875 218</fax>; Email: <email>enrico.siragusa@fu-berlin.de</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>4</month>
      <year>2013</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>28</day>
      <month>1</month>
      <year>2013</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>28</day>
      <month>1</month>
      <year>2013</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>41</volume>
    <issue>7</issue>
    <fpage>e78</fpage>
    <lpage>e78</lpage>
    <history>
      <date date-type="received">
        <day>12</day>
        <month>7</month>
        <year>2012</year>
      </date>
      <date date-type="rev-recd">
        <day>16</day>
        <month>11</month>
        <year>2012</year>
      </date>
      <date date-type="accepted">
        <day>28</day>
        <month>12</month>
        <year>2012</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2013. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2013</copyright-year>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by-nc/3.0/">
        <license-p><!--CREATIVE COMMONS-->This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/3.0/">http://creativecommons.org/licenses/by-nc/3.0/</ext-link>), which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p>We present Masai, a read mapper representing the state-of-the-art in terms of speed and accuracy. Our tool is an order of magnitude faster than RazerS 3 and mrFAST, 2–4 times faster and more accurate than Bowtie 2 and BWA. The novelties of our read mapper are filtration with approximate seeds and a method for multiple backtracking. Approximate seeds, compared with exact seeds, increase filtration specificity while preserving sensitivity. Multiple backtracking amortizes the cost of searching a large set of seeds by taking advantage of the repetitiveness of next-generation sequencing data. Combined together, these two methods significantly speed up approximate search on genomic data sets. Masai is implemented in C++ using the SeqAn library. The source code is distributed under the BSD license and binaries for Linux, Mac OS X and Windows can be freely downloaded from <ext-link ext-link-type="uri" xlink:href="http://www.seqan.de/projects/masai">http://www.seqan.de/projects/masai</ext-link>.</p>
    </abstract>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>INTRODUCTION</title>
    <p>Next-generation sequencing allows to produce billions of base pairs within days in the form of reads of length 100 bp and more. It is an invaluable technology for a multitude of applications in biomedicine, e.g. detection of SNPs and large genomic variations, targeted or <italic>de novo</italic> genome or transcriptome assembly, isoform prediction and quantification, identification of transcription factor binding sites or methylation patterns. In many of these applications, mapping sequenced reads to their potential origin in a reference genome is the first fundamental step preceding downstream analyses.</p>
    <p>Because of sequencing errors and genomic variations, not all reads occur exactly in a reference genome. Therefore, approximate occurrences must be considered, and algorithms for approximate string matching tolerating mismatches and indels must be applied to solve the problem. Furthermore, because of homologous and low complexity regions, not all reads occur uniquely in a reference genome. Therefore, in some applications, e.g. CNVs calling, all approximate occurrences that could be potential origins must be considered.</p>
    <sec>
      <title>Previous work</title>
      <p>All current read mappers can be broadly classified as best-mappers or all-mappers. Tools in the first class aim at finding the best mapping location for a read according to a scoring scheme eventually taking base quality values into account, whereas those in the second class aim at enumerating a comprehensive set of locations.</p>
      <p>Most prominent best-mappers are based on backtracking algorithms for approximate string matching (<xref ref-type="bibr" rid="gkt005-B1">1</xref>). Substrings of the reference genome within an absolute number of errors from a read are recursively enumerated using a suffix or prefix tree of the reference genome. As the time complexity of backtracking grows exponentially with the absolute number of errors considered, this method alone is impractical when mapping reads whole reads with moderate error rates. Hence, popular best-mappers (<xref ref-type="bibr" rid="gkt005-B2 gkt005-B3 gkt005-B4">2–4</xref>) apply heuristics to reduce and prioritize enumeration and are optimized to return one or a few best mapping locations.</p>
      <p>Conversely, most prominent all-mappers are based on filtering algorithms for approximate string matching (<xref ref-type="bibr" rid="gkt005-B1">1</xref>). Seeds are sampled from given reads and used as anchors to quickly determine, with the help of an index, locations of the reference genome candidate to contain approximate occurrences. Each candidate location is subsequently verified with an online method (<xref ref-type="bibr" rid="gkt005-B5">5</xref>). Increasing the error rate in filtering algorithms leads to a decrease of the seed length, which in turn deteriorates filtration efficiency. Current all-mappers (<xref ref-type="bibr" rid="gkt005-B6 gkt005-B7 gkt005-B8 gkt005-B9">6–9</xref>) are usually slower than best-mappers, but conversely they are able to report all asked mapping locations in reasonable time.</p>
    </sec>
    <sec>
      <title>Our contribution</title>
      <p>We present Masai, a read mapper that combines for the first time filtering with backtracking. Our filtering approach is based on non-heuristic and full-sensitive filtration strategies using exact and approximate seeds, which are searched in the reference genome via backtracking. Approximate seeds, compared with exact seeds, increase filtration specificity while preserving sensitivity. Moreover, we introduce a multiple backtracking method, which speeds up filtration by searching all seeds simultaneously with the help of an additional index. Combined together, these methods yield a flexible and efficient filter that significantly speeds up approximate search on genomic data sets.</p>
      <p>Masai targets all-mapping, but eventually it can be used as a best-mapper achieving even better runtimes. We extensively compared Masai with popular read mappers on simulated and real data sets. Compared with considered all-mappers, Masai is an order of magnitude faster and has comparable sensitivity. In addition, Masai is more accurate than considered best-mappers and 2–4 times faster than Bowtie 2 (<xref ref-type="bibr" rid="gkt005-B2">2</xref>) and BWA (<xref ref-type="bibr" rid="gkt005-B3">3</xref>). Masai is implemented in C++ using the SeqAn library and distributed under the BSD license. It can be downloaded from <ext-link ext-link-type="uri" xlink:href="http://www.seqan.de/projects/masai">http://www.seqan.de/projects/masai</ext-link>.</p>
    </sec>
  </sec>
  <sec sec-type="materials|methods">
    <title>MATERIALS AND METHODS</title>
    <p>To map reads to a reference genome, we proceed as follows.</p>
    <p>We first construct a conceptual suffix tree of the reference genome, store it on disk and reuse it for each read mapping job. Any data structure equivalent to the generalized suffix tree in terms of allowing a top-down traversal can be used to this intent. We implemented a generic algorithm using the suffix array (<xref ref-type="bibr" rid="gkt005-B10">10</xref>), the enhanced suffix array (Esa) (<xref ref-type="bibr" rid="gkt005-B11">11</xref>) and the FM-index (<xref ref-type="bibr" rid="gkt005-B12">12</xref>).</p>
    <p>At mapping time, we choose a filtration strategy according to the reference genome and the specified error rate. Our filtration strategies are based on (<xref ref-type="bibr" rid="gkt005-B13">13</xref>), make use of exact and approximate non-overlapping seeds and are guaranteed to be full-sensitive by the pigeonhole principle. In <xref ref-type="fig" rid="gkt005-F1">Figure 1</xref>, we show an example providing two alternative filtration strategies.
<fig id="gkt005-F1" position="float"><label>Figure 1.</label><caption><p>Filtration strategies. A read <italic>r</italic> occurs in the reference genome <italic>g</italic> within edit distance 5. (<bold>a</bold>) If we partition <italic>r</italic> in six seeds, at least one seed (in white) occurs exactly in <italic>g</italic>. (<bold>b</bold>) Alternatively, if we partition <italic>r</italic> in three seeds, at least one seed (in white) occurs within edit distance 1 in <italic>g</italic>.</p></caption><graphic xlink:href="gkt005f1p"/></fig></p>
    <p>Therefore, we partition all reads and their reverse complements in non-overlapping seeds and subsequently arrange all seeds in a conceptual radix tree. The time spent to construct the radix tree is easily justified, as the tree allows us to perform multiple backtracking. We indeed apply our multiple backtracking algorithm to the radix tree, to search simultaneously all seeds in the suffix tree of the reference genome.</p>
    <p>Finally, we perform seed extension on each seed reported by the multiple backtracking algorithm. We extend both ends of each seed using a banded version of Myers bit-vector algorithm (<xref ref-type="bibr" rid="gkt005-B14">14</xref>) presented in (<xref ref-type="bibr" rid="gkt005-B6">6</xref>).</p>
    <p>In the following of this section, we give a detailed explanation of each mapping step.</p>
    <sec>
      <title>Seeds</title>
      <p>We now consider formally the read mapping problem. Given a reference genome <italic>g</italic>, a set of reads <inline-formula><inline-graphic xlink:href="gkt005i1.jpg"/></inline-formula> and an absolute number of errors <italic>k</italic> consisting of indels and mismatches, for each read <inline-formula><inline-graphic xlink:href="gkt005i2.jpg"/></inline-formula>, find all mapping locations where <italic>r</italic> approximately occurs in <italic>g</italic> within <italic>k</italic> errors.</p>
      <sec>
        <title>Exact seeds</title>
        <p>A simple solution to the problem is provided by a filtering algorithm proposed in (<xref ref-type="bibr" rid="gkt005-B15">15</xref>), which reduces an approximate search into smaller exact searches. Each read <italic>r</italic> is partitioned into <italic>k + 1</italic> non-overlapping seeds, which are searched in <italic>g</italic> with the help of an index. As each edit operation can affect at most one seed, for the pigeonhole principle, each approximate occurrence of <italic>r</italic> in <italic>g</italic> contains an exact occurrence of some seed. However, the converse is not true; consequently, we must verify whether any candidate location induced by an occurrence of some seed corresponds to an approximate occurrence of <italic>r</italic> in <italic>g</italic>.</p>
        <p>Filtration specificity in terms of candidate locations to verify is strongly correlated to seed length. As we want to maximize the length of the shortest seed, we let the minimum seed length be <inline-formula><inline-graphic xlink:href="gkt005i3.jpg"/></inline-formula>. If we want to improve filtration specificity by increasing seed length, we resort to approximate seeds.</p>
      </sec>
      <sec>
        <title>Approximate seeds</title>
        <p>A more involved filtering algorithm proposed in <bold>(</bold><xref ref-type="bibr" rid="gkt005-B13">13</xref><bold>)</bold> reduces an approximate search into smaller approximate searches. We partition <italic>r</italic> into <inline-formula><inline-graphic xlink:href="gkt005i4.jpg"/></inline-formula> non-overlapping seeds. According to the pigeonhole principle<bold>,</bold> each approximate occurrence of <italic>r</italic> in <italic>g</italic> then contains an approximate occurrence of some seed within distance <inline-formula><inline-graphic xlink:href="gkt005i5.jpg"/></inline-formula>.</p>
        <p>Moreover, we search <inline-formula><inline-graphic xlink:href="gkt005i6.jpg"/></inline-formula> seeds within distance <inline-formula><inline-graphic xlink:href="gkt005i7.jpg"/></inline-formula> and the remaining seeds within distance <inline-formula><inline-graphic xlink:href="gkt005i8.jpg"/></inline-formula>. To prove full sensitivity, it suffices to see that, if none of the seeds occurs within its assigned distance, the total distance must be at least <inline-formula><inline-graphic xlink:href="gkt005i9.jpg"/></inline-formula>. Hence, all approximate occurrences of <italic>r</italic> in <italic>g</italic> within distance <italic>k</italic> will be found.</p>
        <p>Seeds are searched approximately by backtracking on a suffix tree. We will introduce two efficient multiple backtracking algorithms to search exactly or approximately a set of seeds.</p>
      </sec>
      <sec>
        <title>Filtration strategies</title>
        <p>With approximate seeds, we are free to choose the number of seeds <italic>s</italic>, which in turn enforces the minimum seed length l to be <inline-formula><inline-graphic xlink:href="gkt005i10.jpg"/></inline-formula>. Or vice versa, we fix l, which enforces <italic>s</italic> to be <inline-formula><inline-graphic xlink:href="gkt005i11.jpg"/></inline-formula>. The resulting filter is flexible, indeed by increasing l filtration becomes more specific at the expense of a higher filtration time.</p>
        <p>The optimal seed length <italic>l</italic> depends on the reference genome as well as on read length and the absolute number of errors. When mapping current next-generation sequencing data sets on short-to-medium length genomes, e.g. bacterial genomes, exact seeds are still more efficient than approximate seeds. Conversely on larger genomes, e.g. mammalian genomes, approximate seeds outperform exact seeds by an order of magnitude. Filtration results are provided in the <ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/lookup/suppl/doi:10.1093/nar/gkt005/-/DC1">Supplementary Table S6</ext-link>.</p>
      </sec>
    </sec>
    <sec>
      <title>Indices</title>
      <p>We make use of two fundamental data structures, radix and suffix trees. Here, we present these indices and give most important implementation details.</p>
      <sec>
        <title>Radix tree</title>
        <p>The radix tree (<xref ref-type="bibr" rid="gkt005-B16">16</xref>) is a lexicographically ordered tree data structure representing a set of strings. It can be built in time and space linear in the total length of the strings. Assume w.l.o.g. that each string in the set is padded with a distinct terminator symbol, not being part of the string alphabet. The radix tree has one node designated as the root and one leaf per string in the set. Every internal node has more than one child, and edges are labeled with non-empty strings. Each path from the root to an internal node spells a different substring. Consequently, prefixes common to distinct strings are compressed.</p>
      </sec>
      <sec>
        <title>Suffix tree</title>
        <p>The suffix tree (<xref ref-type="bibr" rid="gkt005-B17">17</xref>) of a string is the radix tree of all the suffixes of the string itself. It can be built in time and space linear in the length of the string (<xref ref-type="bibr" rid="gkt005-B18">18</xref>).</p>
        <p>The suffix tree is used for exact search. A pattern is found by starting in the root node and following the path spelling the pattern. If such path is found, each leaf below the last traversed node points to a distinct occurrence of the pattern in the text.</p>
        <p>Approximate search is performed on the suffix tree by means of backtracking (<xref ref-type="bibr" rid="gkt005-B19">19</xref>,<xref ref-type="bibr" rid="gkt005-B20">20</xref>). A top-down traversal of the suffix tree spells incrementally all substrings present in the text. The distance between the pattern and the spelled text is incrementally computed while traversing a branch of the suffix tree. If the pattern approximately matches the spelled text, each leaf below the last traversed node points to a distinct approximate occurrence of the pattern in the text. Conversely, if the remaining suffix of the pattern cannot lead to any approximate occurrence, the branch is pruned, and the traversal proceeds on the next branch.</p>
      </sec>
      <sec>
        <title>Implementation</title>
        <p>We implemented a generic suffix tree top-down traversal on the suffix array (<xref ref-type="bibr" rid="gkt005-B10">10</xref>), the Esa (<xref ref-type="bibr" rid="gkt005-B11">11</xref>) and the FM-index (<xref ref-type="bibr" rid="gkt005-B12">12</xref>). The Esa preserves the asymptotic performances of the suffix tree and consumes, as implemented in SeqAn, <inline-formula><inline-graphic xlink:href="gkt005i12.jpg"/></inline-formula> bytes for a sequence of length <italic>n</italic>. Nevertheless, the suffix array, despite consuming <inline-formula><inline-graphic xlink:href="gkt005i13.jpg"/></inline-formula> bytes and being theoretically slower, always showed better performance than the Esa (<ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/lookup/suppl/doi:10.1093/nar/gkt005/-/DC1">Supplementary Table S7</ext-link>). The FM-index implicitly represents a prefix trie in only <inline-formula><inline-graphic xlink:href="gkt005i14.jpg"/></inline-formula> bytes and provides constant time node traversal while being slower than the other two data structures.</p>
        <p>We prefer the suffix array because it provides a good compromise between speed and memory consumption, but nevertheless leaves the possibility to choose among the aforementioned data structures. We construct the (generalized) suffix array using an adaptation of the DC7 algorithm (<xref ref-type="bibr" rid="gkt005-B21">21</xref>) to multiple sequences. For construction of the Esa or FM-index, we additionally use the algorithms proposed in (<xref ref-type="bibr" rid="gkt005-B11">11</xref>,<xref ref-type="bibr" rid="gkt005-B22">22</xref>) and (<xref ref-type="bibr" rid="gkt005-B23">23</xref>). Similarly, to all read mappers relying on an index of the reference genome, we build the index of the reference genome only once, store it on disk and reuse it for each mapping job.</p>
        <p>We implemented a lazy radix tree based on the wotd-algorithm (<xref ref-type="bibr" rid="gkt005-B24">24</xref>), as a radix tree is a partial suffix tree only containing certain suffixes. The radix tree is constructed in linear time by subsequent radix sort steps. However, when performing multiple backtracking with exact seeds, the radix tree construction time dominates the overall filtration time. Therefore, in this case, we resort to the <italic>q</italic>-gram index to emulate the radix tree. We build the <italic>q</italic>-gram index efficiently and in linear time by bucket sort. Below depth <italic>q</italic>, the properties of the radix tree are lost; however, multiple backtracking is still applicable.</p>
      </sec>
    </sec>
    <sec>
      <title>Multiple backtracking</title>
      <p>We now introduce a method for multiple off-line approximate string matching to search simultaneously a set of patterns in a text. We start by introducing an algorithm for multiple off-line exact string matching and later extend it to approximate string matching.</p>
      <p>For simplicity of exposition, we describe the algorithms working on tries, although they are easily extendable to work on trees. Hence, in the following, we assume the text sequence and the set of patterns to be pre-processed respectively, using a suffix trie <italic>G</italic> and a radix trie <italic>S</italic>. Given a node <italic>x</italic>, we denote with label (<italic>x</italic>) the label of the edge entering into <italic>x</italic>, with <inline-formula><inline-graphic xlink:href="gkt005i17a.jpg"/></inline-formula>(<italic>x</italic>) the set of children of <italic>x</italic> which are internal nodes, with <inline-formula><inline-graphic xlink:href="gkt005i17b.jpg"/></inline-formula>(<italic>x</italic>) the set of children of <italic>x</italic> which are leaves, and with <inline-formula><inline-graphic xlink:href="gkt005i17c.jpg"/></inline-formula>(<italic>x</italic>) the set of leaves of the subtree rooted in <italic>x</italic>. Note that entering edges of internal nodes are labeled with alphabet symbols, while entering edges of leaves are labeled with terminator symbols.</p>
      <sec>
        <title>Exact search</title>
        <p>Algorithm 1 takes as input two nodes <italic>g</italic>, <italic>s</italic>, respectively, of <italic>G</italic>, <italic>S</italic> and reports all pairs of leaves <inline-formula><inline-graphic xlink:href="gkt005i17.jpg"/></inline-formula> such that the path from <italic>s</italic> to <italic>l</italic><sub>s</sub> spells a prefix of the path from <italic>g</italic> to <italic>l</italic><sub>g</sub>.</p>
        <p>Consequently, by applying Algorithm 1 on the root nodes of <italic>G</italic>, <italic>S</italic>, we obtain all pairs of leaves <inline-formula><inline-graphic xlink:href="gkt005i18.jpg"/></inline-formula> such that the pattern pointed by <italic>l<sub>s</sub></italic> occurs in the text at the position pointed by <italic>l<sub>g</sub></italic>.</p>
        <p>
          <boxed-text id="gkt005-BOX1" position="float">
            <caption>
              <title><bold>Algorithm 1</bold> Multiple exact search.</title>
            </caption>
            <p>1: <bold>procedure</bold> S<sc>earch</sc> (<italic>g</italic>, <italic>s</italic>)</p>
            <p>2:  <bold>report</bold>
<inline-formula><inline-graphic xlink:href="gkt005i19a.jpg"/></inline-formula></p>
            <p>3:  <bold>for all</bold>
<inline-formula><inline-graphic xlink:href="gkt005i20.jpg"/></inline-formula>
<bold>do</bold></p>
            <p>4:   <bold>if</bold>
<inline-formula><inline-graphic xlink:href="gkt005i21.jpg"/></inline-formula>
<bold>then</bold></p>
            <p>5:    S<sc>earch</sc>
<inline-formula><inline-graphic xlink:href="gkt005i22.jpg"/></inline-formula></p>
            <p>6:   <bold>end if</bold></p>
            <p>7: <bold>end procedure</bold></p>
          </boxed-text>
        </p>
      </sec>
      <sec>
        <title>Approximate search</title>
        <p>Algorithm 2 takes an additional input argument <italic>k</italic>, which denotes the maximum number of mismatches left and computes the union of all paths within <italic>k</italic> mismatches in the subtrees rooted in <italic>g</italic>, <italic>s</italic>. It reports all pairs of leaves <inline-formula><inline-graphic xlink:href="gkt005i23.jpg"/></inline-formula> such that the path from <italic>s</italic> to <italic>l</italic><sub>s</sub> spells a prefix of the path from <italic>g</italic> to <italic>l</italic><sub>g</sub> with at most <italic>k</italic> mismatches.</p>
        <p>Therefore, by applying Algorithm 2 on the root nodes of <italic>G</italic>, <italic>S</italic>, we obtain all pairs of leaves <inline-formula><inline-graphic xlink:href="gkt005i24.jpg"/></inline-formula> such that the pattern pointed by <italic>l<sub>s</sub></italic> occurs within <italic>k</italic> mismatches in the text at the position pointed by <italic>l<sub>g</sub></italic>.</p>
        <p>
          <boxed-text id="gkt005-BOX2" position="float">
            <caption>
              <title><bold>Algorithm 2</bold> Multiple approximate search.</title>
            </caption>
            <p>1:  <bold>procedure</bold> S<sc>earch</sc> (<italic>g</italic>, <italic>s</italic>, <italic>k</italic>)</p>
            <p>2:  <bold>if</bold>
<italic>k</italic> = 0 <bold>then</bold></p>
            <p>3:  S<sc>earch</sc> (<italic>g</italic>, <italic>s</italic>)</p>
            <p>4:  <bold>else</bold></p>
            <p>5:   <bold>report</bold>
<inline-formula><inline-graphic xlink:href="gkt005i25a.jpg"/></inline-formula></p>
            <p>6:   <bold>for all</bold>
<inline-formula><inline-graphic xlink:href="gkt005i26.jpg"/></inline-formula>
<bold>do</bold></p>
            <p>7:    <bold>for all</bold>
<inline-formula><inline-graphic xlink:href="gkt005i27.jpg"/></inline-formula>
<bold>do</bold></p>
            <p>8:     <bold>if</bold>
<inline-formula><inline-graphic xlink:href="gkt005i28.jpg"/></inline-formula>
<bold>then</bold></p>
            <p>9:      S<sc>earch</sc>
<inline-formula><inline-graphic xlink:href="gkt005i29.jpg"/></inline-formula></p>
            <p>10:     <bold>else</bold></p>
            <p>11:      S<sc>earch</sc>
<inline-formula><inline-graphic xlink:href="gkt005i30.jpg"/></inline-formula></p>
            <p>12:     <bold>end if</bold></p>
            <p>13: <bold>end if</bold></p>
            <p>14: <bold>end procedure</bold></p>
          </boxed-text>
        </p>
        <p>For <italic>k</italic> = 0, lines 5–12 of Algorithm 2 are equivalent to Algorithm 1. However, Algorithm 1 is preferred to Algorithm 2 because it traverses only edges spelling common strings instead of all pairs of edges, and it is thus more efficient. <xref ref-type="fig" rid="gkt005-F2">Figure 2</xref> depicts a run of Algorithm 2.
<fig id="gkt005-F2" position="float"><label>Figure 2.</label><caption><p>Multiple backtracking. (<bold>a</bold>) A part of the suffix trie representing the text GGTAACGGTGCGGGC (<ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/lookup/suppl/doi:10.1093/nar/gkt005/-/DC1">Supplementary Figure S1</ext-link>). Numbers on the leaves are suffix positions in the text, whereas letters on the inner nodes are arbitrary and serve to distinguish nodes from each other. (<bold>b</bold>) The trie representing the set of patterns {GGTT, GTAT, GTGG}, respectively numbered {0, 1, 2}. Labels on the leaves show pattern numbers, whereas labels on the inner nodes are again arbitrary identifiers. (<bold>c</bold>) Recursive calls performed by Algorithm 2 called with arguments {<italic>g</italic>, <italic>s</italic>, 1}. Edges represent comparisons performed by Algorithm 2 at line 10 or by Algorithm 1 at line 6, nodes with curly brackets represent recursive calls, rectangular leaves represent approximate matches reported. In this example, pattern numbered 0 (GGTT) matches the text twice, at positions 0 and 6, within 1 mismatch. For simplicity, we omitted terminator symbols in the picture.</p></caption><graphic xlink:href="gkt005f2p"/></fig></p>
        <p>Algorithm 2 only considers mismatches, but it can be extended to allow indels, e.g. similarly to (<xref ref-type="bibr" rid="gkt005-B13">13</xref>). In Masai, Algorithm 2 is implemented only for mismatches, consequently full sensitivity is not attained when using approximate seeds and considering mapping locations with indels. However, in the ‘Results’ section, we show that such implementation detail sacrifices &lt;1% sensitivity.</p>
      </sec>
    </sec>
    <sec>
      <title>Seed extension</title>
      <p>We use a banded version of Myers bit-vector algorithm (<xref ref-type="bibr" rid="gkt005-B14">14</xref>) already presented in (<xref ref-type="bibr" rid="gkt005-B6">6</xref>). Myers’ algorithm is an efficient dynamic programming (DP) alignment algorithm (<xref ref-type="bibr" rid="gkt005-B25">25</xref>) for edit distance. Instead of computing DP cells one after another, it encodes the whole DP column in two bit vectors and computes the adjacent column in a constant number of 12 logical and 3 arithmetical operations. We implemented a bit-parallel version that computes only a diagonal band of the DP matrix and is faster and more specific than the original algorithm by Myers. More details can be found in the <ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/lookup/suppl/doi:10.1093/nar/gkt005/-/DC1">Supplementary Section S2</ext-link>.</p>
      <p>However, differently from (<xref ref-type="bibr" rid="gkt005-B6">6</xref>), instead of performing a semi-global alignment to verify a parallelogram surrounding the seed, we perform a global alignment on both ends of a seed. Given a seed occurring with <italic>e</italic> errors, we first perform seed extension on the left side within an error threshold of <inline-formula><inline-graphic xlink:href="gkt005i31.jpg"/></inline-formula> errors. Only if the seed extension on the left side succeeds, we perform a seed extension on the right side within the remaining error threshold. Moreover, we first compute the longest common prefix on each side of the seed and let the global alignment algorithm start from the first mismatching positions. We observed that this approach is up to two times faster than (<xref ref-type="bibr" rid="gkt005-B6">6</xref>).</p>
    </sec>
  </sec>
  <sec sec-type="results">
    <title>RESULTS</title>
    <p>We thoroughly compared Masai with the best-mappers Bowtie 2, BWA and Soap 2 as well as with the all-mappers RazerS 3, Hobbes, mrFAST and SHRiMP 2. We remark that Bowtie 2, BWA, Soap 2 and SHRiMP 2 rely on scoring schemes taking into account base quality values, whereas Masai, RazerS 3, Hobbes and mrFAST use edit distance. When relevant, read mappers that accept an absolute number of errors (Masai, mrFAST, Hobbes and Soap 2) or an error rate (RazerS 3) were configured accordingly. We used default parameters, except where stated otherwise (<ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/lookup/suppl/doi:10.1093/nar/gkt005/-/DC1">Supplementary Section S3</ext-link>).</p>
    <p>We performed runtime experiments on real data. All read sets are given by their SRA/ENA ID. As references, we used whole genomes of <italic>Escherichia coli</italic> (NCBI NC_000913.2), <italic>Caenorhabditis elegans</italic> (WormBase WS195), <italic>Drosophila melanogaster</italic> (FlyBase release 5.42) and <italic>H</italic><italic>omo sapiens</italic> (GRCh37.p2). The mapping times were measured on a cluster of nodes with 72 GB RAM and 2 Intel Xeon X5650 processors running Linux 3.2.0. For running time comparison, we ran the tools using a single thread and used local disks for I/O.</p>
    <sec>
      <title>Rabema benchmark</title>
      <p>We first used the Rabema benchmark (<xref ref-type="bibr" rid="gkt005-B26">26</xref>) (v1.1) for a thorough evaluation and comparison of read mapping sensitivity. Similarly to (<xref ref-type="bibr" rid="gkt005-B2">2</xref>), we used the read simulator Mason (<xref ref-type="bibr" rid="gkt005-B27">27</xref>) with default profile settings to simulate from each whole genome 100 k reads of length 100 bp having sequencing errors distributed like in a typical Illumina run (<ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/lookup/suppl/doi:10.1093/nar/gkt005/-/DC1">Supplementary Section S4</ext-link>).</p>
      <p>The benchmark contains the categories all, all-best, any-best, precision and recall. In the categories all, all-best and any-best, a read mapper had to find all, all of the best or any of the best edit distance locations for each read. The categories precision and recall required a read mapper to find the original location of each read, which is a measure independent of the used scoring model, e.g. edit distance or quality based. A read is mapped correctly if the mapper reported its original location, and it is mapped uniquely if the mapper reported only one location. Rabema defines recall to be the fraction of reads that were correctly mapped and precision to be the fraction of uniquely mapped reads that were mapped correctly.</p>
      <p>The benchmark was performed for an error rate of 5%, which corresponds to edit distance 5 for reads of length 100 bp. Therefore, we built a Rabema gold standard for each data set by running RazerS 3 in full-sensitive mode up to edit distance 5. We further classified mapping locations in each category by their edit distance.</p>
      <p>For a more fair and thorough comparison, we also configured BWA and Bowtie 2 as all-mappers (Soap 2 could not be configured accordingly). To this extent, we parametrized them to be highly sensitive and output all found mapping locations. As BWA and Bowtie 2 were not designed to be used as all-mappers, they spent much more time than proper all-mappers, i.e. up to 3 h in a run compared with several minutes. The aim here is to investigate read mapping sensitivity, and therefore we do not report running times.</p>
      <p>Results for <italic>H. sapiens</italic> are shown in <xref ref-type="table" rid="gkt005-T1">Table 1</xref>. Additional results for <italic>E. coli</italic>, <italic>C. elegans</italic> and <italic>D. Melanogaster</italic> are shown in the <ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/lookup/suppl/doi:10.1093/nar/gkt005/-/DC1">Supplementary Tables S3</ext-link>, <ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/lookup/suppl/doi:10.1093/nar/gkt005/-/DC1">S4</ext-link>, <ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/lookup/suppl/doi:10.1093/nar/gkt005/-/DC1">S5</ext-link>.
<table-wrap id="gkt005-T1" position="float"><label>Table 1.</label><caption><p>Rabema benchmark results</p></caption><table frame="hsides" rules="groups"><tbody align="left"><tr><td rowspan="1" colspan="1"><inline-graphic xlink:href="gkt005t1.jpg"/></td></tr></tbody></table><table-wrap-foot><fn id="gkt005-TF1"><p>Rabema scores in percentage (average fraction of edit distance locations reported per read). Large numbers show total scores in each Rabema category, and small numbers show the category scores separately for reads with <inline-formula><inline-graphic xlink:href="gkt005i87.jpg"/></inline-formula> errors.</p></fn></table-wrap-foot></table-wrap></p>
      <sec>
        <title>Best-mappers</title>
        <p>Masai showed the best recall values, not loosing &gt;3.3% recall on edit distance 5. Conversely, recall values of BWA and Bowtie 2 dropped significantly with increasing edit distance up to loosing 15.4 and 11.5%, respectively, on edit distance 5. As expected, Soap 2 turned out to be inadequate for mapping reads of length 100 bp at this error rates.</p>
        <p>Precision values have less variance than recall values. Masai showed the best precision values with 97.8%, followed by Soap 2 with 97.7%, and BWA with 97.5%. Interestingly, Bowtie 2 showed the worst precision values, loosing up to 5.6% on edit distance 5.</p>
      </sec>
      <sec>
        <title>All-mappers</title>
        <p>As expected, RazerS 3 showed full sensitivity and mrFAST lost only a minimal percentage of mapping locations. Overall, Masai did not loose &gt;0.1% of all mapping locations. In particular, Masai was full sensitive for low-error locations, and it lost only a small percentage of high-error locations, i.e. its loss was limited to 0.1 and 1.4% of mapping locations at edit distance 4 and 5.</p>
        <p>On the other side, BWA and Bowtie 2 missed 35 and 45% of all mapping locations at edit distance 5, and their recall values as all-mappers did not substantially increase. Likewise, SHRiMP 2 could not enumerate all mapping locations, although its recall values were good. Again Hobbes had the worst performance.</p>
        <p>We remark that Masai is not full sensitive whenever approximate seeds are used, e.g. on <italic>H. sapiens</italic>. Indeed, Masai lost 0.1% overall sensitivity in respect to RazerS 3. Conversely, full sensitivity is attained whenever exact seeds are used, e.g. on <italic>E. coli</italic>, <italic>C. elegans</italic> and <italic>D. Melanogaster</italic> (<ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/lookup/suppl/doi:10.1093/nar/gkt005/-/DC1">Supplementary Tables S3</ext-link>, <ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/lookup/suppl/doi:10.1093/nar/gkt005/-/DC1">S4</ext-link>, <ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/lookup/suppl/doi:10.1093/nar/gkt005/-/DC1">S5</ext-link>). In general, RazerS 3 should be used when full sensitivity is required, i.e. for read mapper benchmarking. However, our results show that Masai can replace RazerS 3 or mrFAST as an all-mapper in practical setups.</p>
      </sec>
    </sec>
    <sec>
      <title>Variant detection</title>
      <p>The second experiment analyses the applicability of Masai and other read mappers in genomic variation pipelines. Similarly to (<xref ref-type="bibr" rid="gkt005-B9">9</xref>), we simulated from the whole human genome 5 million reads of length 100 bp containing sequencing errors, SNPs and indels such that each read had an edit distance of at most 5 to its genomic origin. To distribute sequencing errors according to a typical Illumina run, we used the read simulator Mason. The reads were grouped according to the numbers of contained SNPs and indels, where the class <inline-formula><inline-graphic xlink:href="gkt005i88.jpg"/></inline-formula> consists of all reads with <italic>s</italic> SNPs and <italic>i</italic> indels. We mapped the reads with each tool and measured its sensitivity in each class.</p>
      <p>We say that a read is mapped correctly if a mapping location has been reported within 10 bp of its genomic origin. It is considered to map uniquely if only one location was reported by the mapper. For each class, we define recall to be the fraction of reads that were correctly mapped and precision to be the fraction of uniquely mapped reads that were mapped correctly. <xref ref-type="table" rid="gkt005-T2">Table 2</xref> shows the results for each read mapper and class.
<table-wrap id="gkt005-T2" position="float"><label>Table 2.</label><caption><p>Variant detection results</p></caption><table frame="hsides" rules="groups"><tbody align="left"><tr><td rowspan="1" colspan="1"><inline-graphic xlink:href="gkt005t2.jpg"/></td></tr></tbody></table><table-wrap-foot><fn id="gkt005-TF2"><p>We show the percentages of found origins (recall) and fraction of unique reads mapped to their origin (precision) classed by reads with <italic>s</italic> SNPs and <italic>i</italic> indels <inline-formula><inline-graphic xlink:href="gkt005i89.jpg"/></inline-formula>.</p></fn></table-wrap-foot></table-wrap></p>
      <sec>
        <title>Best-mappers</title>
        <p>Among best-mappers, Masai showed the highest precision and recall in all classes. In particular, Masai did not loose &gt;3.2% recall in class (<xref ref-type="bibr" rid="gkt005-B4">4</xref>,0), whether Bowtie 2 and BWA lost 17.5 and 14.9%, respectively, and Soap 2 was not able to map any read.</p>
        <p>Interestingly, we observed that recall values of Bowtie 2, BWA and Soap 2 were negatively correlated with the amount of genomic variation. For instance, in the Rabema benchmark, Bowtie 2 lost 7.2 and 11.5%, respectively, of mapping locations at distance 4 and 5, but in this experiment, it lost 17.5% recall in class (<xref ref-type="bibr" rid="gkt005-B4">4</xref>,0). We noticed a similar trend for BWA and Soap 2. These tools rely on quality values to guess the best mapping location for a read and tend to prefer alignments, which can be explained by sequencing errors instead of true genomic variations. The low performance of Soap 2 is also owing to its limitation to at most 2 mismatches and no support for indels.</p>
      </sec>
      <sec>
        <title>All-mappers</title>
        <p>Looking at all-mappers results, Masai showed 100% precision and recall in all classes, except for classes (<xref ref-type="bibr" rid="gkt005-B2">2</xref>,0) and (<xref ref-type="bibr" rid="gkt005-B1">1</xref>,<xref ref-type="bibr" rid="gkt005-B1">1</xref>) where it lost only 0.1 and 0.7% recall. Masai is therefore roughly comparable with the full-sensitive read mappers RazerS 3 and mrFAST. SHRiMP 2 showed 100% precision in all classes but lost between 0.3 and 0.8% recall in each class. Hobbes had the lowest performance among all-mappers. It appears to have problems with indels; indeed, it lost 9.5% recall in class (0,<xref ref-type="bibr" rid="gkt005-B3">3</xref>).</p>
      </sec>
    </sec>
    <sec>
      <title>Performance on real data</title>
      <p>In the last experiment, we focused on comparing read mappers performance on real data. To this end, we mapped the first <inline-formula><inline-graphic xlink:href="gkt005i90.jpg"/></inline-formula> reads from an Illumina lane of <italic>E. coli</italic> (ERR022075, Genome Analyzer IIx), <italic>D. melanogaster</italic> (SRR497711, HiSeq 2000), <italic>C. elegans</italic> (SRR065390, Genome Analyzer II) and <italic>H. sapiens</italic> (ERR012100, Genome Analyzer II). To measure scalability, we also mapped the full <inline-formula><inline-graphic xlink:href="gkt005i91.jpg"/></inline-formula> (ERR012100) and <inline-formula><inline-graphic xlink:href="gkt005i92.jpg"/></inline-formula> (ERR161544, HiSeq 2000) <italic>H. sapiens</italic> data sets. Whenever possible, we asked mappers to map reads within edit distance 5. We measured running times, peak memory consumptions, mapped reads and Rabema any-best scores.</p>
      <p>We could not measure precision and recall values, as real reads have unknown origins. Therefore, for the evaluation, we adopted the commonly used measure of percentage of mapped reads, i.e. the fraction of reads for which the read mapper reports a mapping location. However, as some mappers report mapping locations without constraints on the number of errors, we also included Rabema any-best scores. The Rabema any-best benchmark assigns a point for a read if the mapper reports at least one mapping location with the optimal (minimum) number of errors. Final Rabema any-best scores are normalized by the number of reads.</p>
      <p>In this evaluation, we are interested on the capability of the mapper to retrieve the location of a single read without the help of read pairs, which can of course disambiguate mapping locations of the partner.</p>
      <p>Results for <italic>C. elegans</italic> and <italic>H. sapiens</italic> are shown in <xref ref-type="table" rid="gkt005-T3">Table 3</xref>. Additional results for <italic>E. coli</italic>, <italic>D. melanogaster</italic> and two large (<inline-formula><inline-graphic xlink:href="gkt005i130.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="gkt005i131.jpg"/></inline-formula> reads) <italic>H. sapiens</italic> data sets are shown in the <ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/lookup/suppl/doi:10.1093/nar/gkt005/-/DC1">Supplementary Table S1</ext-link>.
<table-wrap id="gkt005-T3" position="float"><label>Table 3.</label><caption><p>Runtime results</p></caption><table frame="hsides" rules="groups"><tbody align="left"><tr><td rowspan="1" colspan="1"><inline-graphic xlink:href="gkt005t3.jpg"/></td></tr></tbody></table><table-wrap-foot><fn id="gkt005-TF3"><p>Results of mapping <inline-formula><inline-graphic xlink:href="gkt005i127.jpg"/></inline-formula> Illumina reads. Mapped reads: In large, we show the percentage of mapped reads and in small the cumulative percentage of reads that were mapped with <inline-formula><inline-graphic xlink:href="gkt005i128.jpg"/></inline-formula> errors. Rabema any-best: In large, we show the percentage of reads mapped with the minimal number of errors (up to 5%) and in small the percentage of reads that were mapped with <inline-formula><inline-graphic xlink:href="gkt005i129.jpg"/></inline-formula> errors. Remarks: SHRiMP 2 was not able to map the <italic>H. sapiens</italic> data set within 4 days. Hobbes constantly crashed and was not able to map completely neither the <italic>C. Elegans</italic> nor the <italic>H. sapiens</italic> data set.</p></fn></table-wrap-foot></table-wrap></p>
      <sec>
        <title>Best-mappers</title>
        <p>On the <italic>C. elegans</italic> data set, Masai was 7.7 times faster than Bowtie 2, 8.2 times faster than BWA and 1.5 times faster than Soap 2. On the <italic>H. sapiens</italic> data set, Masai was 2.6 times faster than Bowtie 2, 3.6 times faster than BWA but 2.1 times slower than Soap 2. On one hand, Soap 2 was not able to map a consistent fraction of reads because of its limitation to two mismatches. On the other hand, Bowtie 2 reported more mapped reads than Masai but, taking any-best scores into account, it reported less mapping locations than Masai. In fact, Bowtie 2 uses a scoring scheme based on quality values and does not impose a maximal error rate threshold. On the <italic>C. elegans</italic> and <italic>H. sapiens</italic> data sets, Bowtie 2 missed 22.0 and 20.7% of reads, respectively, mappable at edit distance 5.</p>
      </sec>
      <sec>
        <title>All-mappers</title>
        <p>On the <italic>C. elegans</italic> data set, Masai was 2.0 times faster than RazerS 3, 10.9 times faster than Hobbes, 6.3 times faster than mrFAST and 50.1 times faster than SHRiMP 2. Hobbes constantly crashed and mapped less reads than all other mappers in this category. Likewise for Bowtie 2, also SHRiMP 2 does not impose a maximal error rate threshold and reported more mapped reads than Masai. However, its Rabema any-best score was inferior to Masai. This could be owing to the use of a different scoring scheme where two mismatches cost less than opening a gap. Anyway, this hypothesis does not explain why SHRiMP 2 did not report some mapping locations at distance 0.</p>
        <p>On the <italic>H. sapiens</italic> data set, Masai was 11.9 times faster than RazerS 3, 14.6 times faster than mrFAST and 7.6 times faster than Hobbes. The current implementation of Hobbes often crashed and mapped only half of the reads. SHRiMP 2 was not able to map the <italic>H. sapiens</italic> data set within 4 days.</p>
      </sec>
      <sec>
        <title>Memory requirements</title>
        <p>In all, 20 GB of main memory are required to map a block of <inline-formula><inline-graphic xlink:href="gkt005i132.jpg"/></inline-formula> reads on <italic>H. sapiens</italic> using a suffix array index. The reference genome consumes 3 GB, its suffix array index 15 GB and <inline-formula><inline-graphic xlink:href="gkt005i133.jpg"/></inline-formula> reads along with the radix tree ∼2 GB. Alternatively, the FM-index lowers the memory consumption of <italic>H. sapiens</italic> index to 4 GB. Therefore, 9 GB of main memory are sufficient to map <inline-formula><inline-graphic xlink:href="gkt005i134.jpg"/></inline-formula> reads (<ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/lookup/suppl/doi:10.1093/nar/gkt005/-/DC1">Supplementary Table S7</ext-link>). Suffix array indices of <italic>C. elegans</italic>, <italic>D. melanogaster</italic> and <italic>E. coli</italic> are not problematic in size, as they consume only 479 MB, 575 MB and 23 MB.</p>
        <p>On low memory machines and clusters, larger read set can be always processed in blocks of appropriate size. Thus, the standard memory requirement for <italic>H. sapiens</italic> is 20 GB of main memory. Nonetheless, we mapped two huge data sets at once, merely to measure scalability. On the full ERR012100 data set (<inline-formula><inline-graphic xlink:href="gkt005i135.jpg"/></inline-formula> reads), Masai required 31 GB of main memory, whereas on the ERR161544 <italic>H. sapiens</italic> data set (<inline-formula><inline-graphic xlink:href="gkt005i136.jpg"/></inline-formula> reads), Masai required 52 GB of main memory (<ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/lookup/suppl/doi:10.1093/nar/gkt005/-/DC1">Supplementary Table S2</ext-link>).</p>
      </sec>
    </sec>
  </sec>
  <sec sec-type="discussion">
    <title>DISCUSSION</title>
    <p>We showed that, on one hand, Masai is faster and more accurate than the best-mappers Bowtie 2 and BWA, whereas on the other hand, Masai is slightly slower but substantially more accurate than Soap 2. Masai’s accuracy becomes considerable in presence of genomic variation; therefore, we strongly advise to use Masai in small and large genomic variation pipelines.</p>
    <p>At the same time, we showed that Masai is significantly faster than any other all-mapper while being almost full sensitive. Consequently, Masai brings all-mapping within feasible times, although with a higher memory footprint.</p>
    <p>We finally remark that performance on short reference genomes (<ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/lookup/suppl/doi:10.1093/nar/gkt005/-/DC1">Supplementary Table S1</ext-link>) is relevant for metagenomics. On <italic>E. coli</italic>, Masai outperforms Bowtie 2 and BWA by an order of magnitude. Therefore, we strongly advise to use Masai also in metagenomic pipelines.</p>
    <p>Masai is implemented in C++ using the SeqAn library. The source code is distributed under the BSD license, and binaries for Linux, Mac OS X and Windows can be freely downloaded from <ext-link ext-link-type="uri" xlink:href="http://www.seqan.de/projects/masai">http://www.seqan.de/projects/masai</ext-link>.</p>
  </sec>
  <sec>
    <title>SUPPLEMENTARY DATA</title>
    <p><ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/lookup/suppl/doi:10.1093/nar/gkt005/-/DC1">Supplementary Data</ext-link> are available at NAR Online: Supplementary Tables 1–7 and Supplementary Figures 1–3.</p>
  </sec>
  <sec>
    <title>FUNDING</title>
    <p><funding-source>International Max Planck Research School for Computational Biology and Scientific Computing</funding-source> (to E.S.); the <funding-source>Federal Ministry of Education and Research</funding-source> [<award-id>16V0080</award-id> to D.W.]. Funding for open access charge: <funding-source>International Max Planck Research School for Computational Biology and Scientific Computing</funding-source>.</p>
    <p><italic>Conflict of interest statement.</italic> None declared.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="PMC_1" content-type="local-data">
      <caption>
        <title>Supplementary Data</title>
      </caption>
      <media mimetype="text" mime-subtype="html" xlink:href="supp_41_7_e78__index.html"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="pdf" xlink:href="supp_gkt005_nar-02348-met-k-2012-File016.pdf"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>ACKNOWLEDGEMENTS</title>
    <p>The authors thank Manuel Holtgrewe for his joint work on experimental evaluations. They are grateful to Jochen Singer for providing them with a generic FM-index implementation.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="gkt005-B1">
      <label>1</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Navarro</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Baeza-Yates</surname>
            <given-names>RA</given-names>
          </name>
          <name>
            <surname>Sutinen</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Tarhio</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Indexing methods for approximate string matching</article-title>
        <source>IEEE Data Eng. Bull.</source>
        <year>2001</year>
        <volume>24</volume>
        <fpage>19</fpage>
        <lpage>27</lpage>
      </element-citation>
    </ref>
    <ref id="gkt005-B2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Langmead</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>Fast gapped-read alignment with Bowtie 2</article-title>
        <source>Nat. Methods</source>
        <year>2012</year>
        <volume>9</volume>
        <fpage>357</fpage>
        <lpage>359</lpage>
        <pub-id pub-id-type="pmid">22388286</pub-id>
      </element-citation>
    </ref>
    <ref id="gkt005-B3">
      <label>3</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Fast and accurate short read alignment with Burrows-Wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>1754</fpage>
        <lpage>1760</lpage>
        <pub-id pub-id-type="pmid">19451168</pub-id>
      </element-citation>
    </ref>
    <ref id="gkt005-B4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Yu</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Lam</surname>
            <given-names>T-W</given-names>
          </name>
          <name>
            <surname>Yiu</surname>
            <given-names>S-M</given-names>
          </name>
          <name>
            <surname>Kristiansen</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>SOAP2: an improved ultrafast tool for short read alignment</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>1966</fpage>
        <lpage>1967</lpage>
        <pub-id pub-id-type="pmid">19497933</pub-id>
      </element-citation>
    </ref>
    <ref id="gkt005-B5">
      <label>5</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Navarro</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>A guided tour to approximate string matching</article-title>
        <source>ACM Comput. Surv.</source>
        <year>2001</year>
        <volume>33</volume>
        <fpage>31</fpage>
        <lpage>88</lpage>
      </element-citation>
    </ref>
    <ref id="gkt005-B6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Weese</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Holtgrewe</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Reinert</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>RazerS 3: faster, fully sensitive read mapping</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <fpage>2592</fpage>
        <lpage>2599</lpage>
        <pub-id pub-id-type="pmid">22923295</pub-id>
      </element-citation>
    </ref>
    <ref id="gkt005-B7">
      <label>7</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ahmadi</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Behm</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Honnalli</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Weng</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Xie</surname>
            <given-names>X</given-names>
          </name>
        </person-group>
        <article-title>Hobbes: optimized gram-based methods for efficient read alignment</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2012</year>
        <volume>40</volume>
        <fpage>e41</fpage>
        <pub-id pub-id-type="pmid">22199254</pub-id>
      </element-citation>
    </ref>
    <ref id="gkt005-B8">
      <label>8</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Alkan</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Kidd</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Marques-Bonet</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Aksay</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Antonacci</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Hormozdiari</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Kitzman</surname>
            <given-names>JO</given-names>
          </name>
          <name>
            <surname>Baker</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Malig</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Mutlu</surname>
            <given-names>O</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Personalized copy number and segmental duplication maps using next-generation sequencing</article-title>
        <source>Nat. Genet.</source>
        <year>2009</year>
        <volume>41</volume>
        <fpage>1061</fpage>
        <lpage>1067</lpage>
        <pub-id pub-id-type="pmid">19718026</pub-id>
      </element-citation>
    </ref>
    <ref id="gkt005-B9">
      <label>9</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>David</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Dzamba</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Lister</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Ilie</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Brudno</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>SHRiMP2: sensitive yet practical SHort Read Mapping</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <fpage>1011</fpage>
        <lpage>1012</lpage>
        <pub-id pub-id-type="pmid">21278192</pub-id>
      </element-citation>
    </ref>
    <ref id="gkt005-B10">
      <label>10</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Manber</surname>
            <given-names>U</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Suffix arrays: a new method for on-line string searches</article-title>
        <source>SODA</source>
        <year>1990</year>
        <fpage>319</fpage>
        <lpage>327</lpage>
      </element-citation>
    </ref>
    <ref id="gkt005-B11">
      <label>11</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Abouelhoda</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Kurtz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Ohlebusch</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Replacing suffix trees with enhanced suffix arrays</article-title>
        <source>J. Discrete Algorithms</source>
        <year>2004</year>
        <volume>2</volume>
        <issue>1</issue>
        <fpage>53</fpage>
        <lpage>86</lpage>
      </element-citation>
    </ref>
    <ref id="gkt005-B12">
      <label>12</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Ferragina</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>An experimental study of an opportunistic index</article-title>
        <source>Proceedings of the Twelfth Annual ACM-SIAM Symposium on Discrete Algorithms, Washington, D.C., USA</source>
        <year>2001</year>
        <publisher-loc>Philadelphia, PA, USA</publisher-loc>
        <publisher-name>Society for Industrial and Applied Mathematics</publisher-name>
        <fpage>269</fpage>
        <lpage>278</lpage>
      </element-citation>
    </ref>
    <ref id="gkt005-B13">
      <label>13</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Navarro</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Baeza-Yates</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>A hybrid indexing method for approximate string matching</article-title>
        <source>J. Discrete Algorithms</source>
        <year>2000</year>
        <volume>1</volume>
        <fpage>205</fpage>
        <lpage>239</lpage>
      </element-citation>
    </ref>
    <ref id="gkt005-B14">
      <label>14</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Myers</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>A fast bit-vector algorithm for approximate string matching based on dynamic programming</article-title>
        <source>J. ACM</source>
        <year>1999</year>
        <volume>46</volume>
        <fpage>395</fpage>
        <lpage>415</lpage>
      </element-citation>
    </ref>
    <ref id="gkt005-B15">
      <label>15</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Baeza-Yates</surname>
            <given-names>RA</given-names>
          </name>
          <name>
            <surname>Navarro</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Faster approximate string matching</article-title>
        <source>Algorithmica</source>
        <year>1999</year>
        <volume>23</volume>
        <fpage>127</fpage>
        <lpage>158</lpage>
      </element-citation>
    </ref>
    <ref id="gkt005-B16">
      <label>16</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Morrison</surname>
            <given-names>DR</given-names>
          </name>
        </person-group>
        <article-title>PATRICIA-Practical algorithm to retrieve information coded in alphanumeric</article-title>
        <source>J. ACM</source>
        <year>1968</year>
        <volume>15</volume>
        <fpage>514</fpage>
        <lpage>534</lpage>
      </element-citation>
    </ref>
    <ref id="gkt005-B17">
      <label>17</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Weiner</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Linear pattern matching algorithms</article-title>
        <source>SWAT (FOCS) IEEE</source>
        <year>1973</year>
        <publisher-loc>Los Alamitos, CA, USA</publisher-loc>
        <publisher-name>IEEE Computer Society</publisher-name>
        <fpage>1</fpage>
        <lpage>11</lpage>
      </element-citation>
    </ref>
    <ref id="gkt005-B18">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ukkonen</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>On-line construction of suffix trees</article-title>
        <source>Algorithmica</source>
        <year>1995</year>
        <volume>14</volume>
        <fpage>249</fpage>
        <lpage>260</lpage>
      </element-citation>
    </ref>
    <ref id="gkt005-B19">
      <label>19</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Ukkonen</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Apostolico</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Crochemore</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Galil</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Manber</surname>
            <given-names>U</given-names>
          </name>
        </person-group>
        <article-title>Approximate string-matching over suffix trees</article-title>
        <source>Lecture Notes in Computer Science</source>
        <year>1993</year>
        <volume>Vol. 684</volume>
        <publisher-loc>Ukkonen, Esko</publisher-loc>
        <publisher-name>Springer Berlin Heidelberg</publisher-name>
        <fpage>228</fpage>
        <lpage>242</lpage>
      </element-citation>
    </ref>
    <ref id="gkt005-B20">
      <label>20</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Baeza-Yates</surname>
            <given-names>RA</given-names>
          </name>
          <name>
            <surname>Gonnet</surname>
            <given-names>GH</given-names>
          </name>
        </person-group>
        <article-title>A fast algorithm on average for all-against-all sequence matching</article-title>
        <source>SPIRE/CRIWG IEEE</source>
        <year>1999</year>
        <publisher-name>IEEE Computer Society Press</publisher-name>
        <fpage>16</fpage>
        <lpage>23</lpage>
      </element-citation>
    </ref>
    <ref id="gkt005-B21">
      <label>21</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dementiev</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Kärkkäinen</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Mehnert</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Sanders</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Better external memory suffix array construction</article-title>
        <source>J. Exp. Algorithmics</source>
        <year>2008</year>
        <volume>12</volume>
        <comment>3.4:1–3.4:24</comment>
      </element-citation>
    </ref>
    <ref id="gkt005-B22">
      <label>22</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Kasai</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Arimura</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Arikawa</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Park</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>Linear-time longest-common-prefix computation in suffix arrays and its applications</article-title>
        <source>CPM</source>
        <year>2001</year>
        <publisher-loc>London, UK</publisher-loc>
        <publisher-name>Springer-Verlag</publisher-name>
        <fpage>181</fpage>
        <lpage>192</lpage>
      </element-citation>
    </ref>
    <ref id="gkt005-B23">
      <label>23</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Grossi</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Gupta</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Vitter</surname>
            <given-names>JS</given-names>
          </name>
        </person-group>
        <article-title>High-order entropy-compressed text indexes</article-title>
        <source>Proceedings of the 14th annual ACM-SIAM symposium on Discrete algorithms</source>
        <year>2003</year>
        <comment>Society for Industrial and Applied Mathematics SODA ’03, Philadelphia, PA pp. 841–850</comment>
      </element-citation>
    </ref>
    <ref id="gkt005-B24">
      <label>24</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Giegerich</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Kurtz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Stoye</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Efficient implementation of lazy suffix trees</article-title>
        <source>Softw. Pract. Exper.</source>
        <year>2003</year>
        <volume>33</volume>
        <fpage>1035</fpage>
        <lpage>1049</lpage>
      </element-citation>
    </ref>
    <ref id="gkt005-B25">
      <label>25</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Needleman</surname>
            <given-names>SB</given-names>
          </name>
          <name>
            <surname>Wunsch</surname>
            <given-names>CD</given-names>
          </name>
        </person-group>
        <article-title>A general method applicable to the search for similarities in the amino acid sequence of two proteins</article-title>
        <source>J. Mol. Biol.</source>
        <year>1970</year>
        <volume>48</volume>
        <fpage>443</fpage>
        <lpage>453</lpage>
        <pub-id pub-id-type="pmid">5420325</pub-id>
      </element-citation>
    </ref>
    <ref id="gkt005-B26">
      <label>26</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Holtgrewe</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Emde</surname>
            <given-names>A-K</given-names>
          </name>
          <name>
            <surname>Weese</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Reinert</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>A novel and well-defined benchmarking method for second generation read mapping</article-title>
        <source>BMC Bioinformatics</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>210</fpage>
        <pub-id pub-id-type="pmid">21615913</pub-id>
      </element-citation>
    </ref>
    <ref id="gkt005-B27">
      <label>27</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Holtgrewe</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Mason—a read simulator for second generation sequencing data. Technical report TR-B-10-06</article-title>
        <year>2010</year>
        <comment>Institut für Mathematik und Informatik, Freie Universität Berlin</comment>
      </element-citation>
    </ref>
  </ref-list>
</back>
