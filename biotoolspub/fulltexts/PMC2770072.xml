<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlm.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-title>BMC Bioinformatics</journal-title>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">2770072</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-10-329</article-id>
    <article-id pub-id-type="pmid">19821978</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-10-329</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>PLAST: parallel local alignment search tool for database comparison</article-title>
    </title-group>
    <contrib-group>
      <contrib id="A1" corresp="yes" contrib-type="author">
        <name>
          <surname>Nguyen</surname>
          <given-names>Van Hoa</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>vhnguyen@irisa.fr</email>
      </contrib>
      <contrib id="A2" corresp="yes" contrib-type="author">
        <name>
          <surname>Lavenier</surname>
          <given-names>Dominique</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>lavenier@irisa.fr</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Symbiose team-project, INRIA/IRISA, Campus de Beaulieu, 35042 Rennes Cedex, France</aff>
    <aff id="I2"><label>2</label>ENS Cachan Bretagne, Campus de Ker Lann, 35170 Bruz, France</aff>
    <pub-date pub-type="collection">
      <year>2009</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>12</day>
      <month>10</month>
      <year>2009</year>
    </pub-date>
    <volume>10</volume>
    <fpage>329</fpage>
    <lpage>329</lpage>
    <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10/329"/>
    <history>
      <date date-type="received">
        <day>18</day>
        <month>2</month>
        <year>2009</year>
      </date>
      <date date-type="accepted">
        <day>12</day>
        <month>10</month>
        <year>2009</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright Â© 2009 Nguyen and Lavenier; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2009</copyright-year>
      <copyright-holder>Nguyen and Lavenier; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p>
        <!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>
               Nguyen
               Van Hoa
               
               vhnguyen@irisa.fr
            </dc:author><dc:title>
            PLAST: parallel local alignment search tool for database comparison
         </dc:title><dc:date>2009</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 10(1): 329-. (2009)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2009)10:1&#x0003c;329&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>-->
      </license>
    </permissions>
    <abstract>
      <sec>
        <title>Background</title>
        <p>Sequence similarity searching is an important and challenging task in molecular biology and next-generation sequencing should further strengthen the need for faster algorithms to process such vast amounts of data. At the same time, the internal architecture of current microprocessors is tending towards more parallelism, leading to the use of chips with two, four and more cores integrated on the same die. The main purpose of this work was to design an effective algorithm to fit with the parallel capabilities of modern microprocessors.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>A parallel algorithm for comparing large genomic banks and targeting middle-range computers has been developed and implemented in PLAST software. The algorithm exploits two key parallel features of existing and future microprocessors: the SIMD programming model (SSE instruction set) and the multithreading concept (multicore). Compared to multithreaded BLAST software, tests performed on an 8-processor server have shown speedup ranging from 3 to 6 with a similar level of accuracy.</p>
      </sec>
      <sec>
        <title>Conclusion</title>
        <p>A parallel algorithmic approach driven by the knowledge of the internal microprocessor architecture allows significant speedup to be obtained while preserving standard sensitivity for similarity search problems.</p>
      </sec>
    </abstract>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>Genomic sequence comparison is a central task in computational biology for identifying closely related protein or DNA sequences. Similarities between sequences are commonly used, for instance, to identify functionality of new genes or to annotate new genomes. Algorithms designed to identify such similarities have long been available and still represent an active research domain, since this task remains critical for many bioinformatics studies.</p>
    <p>Two avenues of research are generally explored to improve these algorithms, depending on the target application. The first aims to increase sensitivity, while the second seeks to minimize computation time. With next generation sequencing technology, the challenge is not only to develop new algorithms capable of managing large amounts of sequences, but also to imagine new methods for processing this mass of data as quickly as possible [<xref ref-type="bibr" rid="B1">1</xref>].</p>
    <p>The well-known Smith-Waterman (SW) algorithm, developed in 1981, is one of the first proposals to detect local similarities [<xref ref-type="bibr" rid="B2">2</xref>]. It uses a dynamic programming technique and has a quadratic complexity with respect to sequence length. A great effort has been made to obtain fast implementation on specialized hardware. Rognes [<xref ref-type="bibr" rid="B3">3</xref>] and Farrar [<xref ref-type="bibr" rid="B4">4</xref>] exploited the fine-grained parallelism of SIMD technology. Their implementations are respectively up to 6 and 13 times faster than the SSEARCH implementation [<xref ref-type="bibr" rid="B5">5</xref>]. More recent works use SIMD coprocessors, such as Graphics Processing Units (GPU) [<xref ref-type="bibr" rid="B6">6</xref>] or the CELL Broadband Engine [<xref ref-type="bibr" rid="B7">7</xref>]. Despite various attempts to accelerate the SW algorithm, its long computation time remains a major drawback. To increase speed, programs based on powerful heuristic methods, such as FASTA [<xref ref-type="bibr" rid="B5">5</xref>] or BLAST [<xref ref-type="bibr" rid="B8">8</xref>] have been developed. These greatly reduce execution time while maintaining a high level of sensitivity. Again, hardware coprocessors have been proposed to speed up these programs. These mostly use FPGA chips such as the SeqCruncher accelerator [<xref ref-type="bibr" rid="B9">9</xref>], the Mercury BLASTP implementation [<xref ref-type="bibr" rid="B10">10</xref>], the FPGA/FLASH board [<xref ref-type="bibr" rid="B11">11</xref>] or the specific FPGA-based BLAST platforms proposed in [<xref ref-type="bibr" rid="B12">12</xref>]. Implementation on the Cell Broadband Engine has also been experimented to make good use of the fine-grained parallelism of the BLASTP program [<xref ref-type="bibr" rid="B13">13</xref>].</p>
    <p>The PLAST program is a pure software implementation designed to exploit the internal parallel features of modern microprocessors. The sequence comparison algorithm has been structured to group together the most time consuming parts inside small critical sections that have good properties for parallelism. The resulting code is both well-suited for fine-grained (SIMD programming model) and medium-grained parallelization (multithreaded programming model). The first level of parallelism is supported by SSE instructions. The second is exploited with the multicore architecture of the microprocessors.</p>
    <p>PLAST has been primarily designed to compare large protein or DNA banks. Unlike BLAST, it is not optimized to perform large database scanning. It is intended more for use in intensive comparison processes such as bioinformatics workflows, for example, to annotate new sequenced genomes. Different versions have been developed based on the BLAST family model: PLASTP for comparing two protein banks, TPLASTN for comparing one protein bank with one translated DNA bank (or genome) and PLASTX for comparing one translated DNA bank with one protein bank. The input format is the well-known FASTA format. No pre-processing (such as formatdb) is required.</p>
    <p>Like BLAST, the PLAST algorithm detects alignment using a seed heuristic method, but does so in a slightly different way. Consequently, it does not provide the same alignments, especially when there is little similarity between two sequences: some alignments are found by PLAST and not by BLAST, others are found by BLAST and not by PLAST. Nonetheless, comparable selectivity and sensitivity were measured using ROC curve, coverage versus error plot, and missed alignments.</p>
    <p>Compared to BLAST (with its multithreading option activated), a speedup ranging from 3 to 6 can be obtained, depending on the amount and nature of the data to be processed. Furthermore, PLAST provides the best performance when large databases are involved.</p>
  </sec>
  <sec>
    <title>Implementation</title>
    <p>PLAST implements a three-step, seed-based algorithm: (1) indexing, (2) ungapped extension and (3) gapped extension. An overview of the PLAST algorithm is presented below, followed by a more detailed description of the three steps.</p>
    <sec>
      <title>Overview of the PLAST algorithm</title>
      <p>Like BLAST, the PLAST algorithm is based on a seed-based heuristic to detect similarities between two protein sequences. This heuristic supposes that two proteins sharing sufficient similarities include at least one identical common word of W amino acids. Then, from this specific word, larger similarities can be found by extending the search on the left and right hand sides. These words are called seeds because they are the starting point of the search alignment procedure.</p>
      <p>The first step of the PLAST algorithm is to index the two protein banks using the subset seed concept [<xref ref-type="bibr" rid="B14">14</xref>]. Two tables of <italic>T </italic>entries are constructed, where <italic>T </italic>is the number of all possible subset seed keys. Each key entry is associated with a list of positions corresponding to all the occurrences of this subset seed in the bank.</p>
      <p>The second step computes all the possible seed extensions. For each seed key, the two entries of the two tables are considered and each position of one list is compared with all the positions of the other list. In this context, comparing means computing small ungapped alignments by extending the subset seed on both sides.</p>
      <p>The third step computes alignments including the gap penalty. This step is only triggered if the previous step has detected significant local similarity.</p>
      <p>Based on these three steps, the principle of the PLAST algorithm can be described (sequentially) as follows:</p>
      <p>Algorithm 1</p>
      <p>1: <italic>IT</italic><sub>0 </sub>â Index (bank-0)</p>
      <p>2: <italic>IT</italic><sub>1 </sub>â Index (bank-1)</p>
      <p>3: for all possible seed key k</p>
      <p>4: Â Â Â <italic>IL</italic><sub>0 </sub>â <italic>IT</italic><sub>0</sub>[<italic>k</italic>]</p>
      <p>5: Â Â Â <italic>IL</italic><sub>1 </sub>â <italic>IT</italic><sub>1</sub>[<italic>k</italic>]</p>
      <p>6: Â Â Â for all elements i in <italic>IL</italic><sub>0</sub></p>
      <p>7: Â Â Â Â Â Â for all elements j in <italic>IL</italic><sub>1</sub></p>
      <p>8: Â Â Â Â Â Â Â Â Â if ungapped_extension (<italic>IL</italic><sub>0</sub>[<italic>i</italic>], <italic>IL</italic><sub>1</sub>[<italic>j</italic>])</p>
      <p>9: Â Â Â Â Â Â Â Â Â Â Â Â then gapped_extension (<italic>IL</italic><sub>0</sub>[<italic>i</italic>], <italic>IL</italic><sub>1</sub>[<italic>j</italic>])</p>
      <p>Actually, this algorithm has great parallelism potential, since the computations of the 3 <monospace>for all</monospace> nested loops are independent. Basically, each seed extension can be performed in parallel. Thus, this implementation considers a first level of parallelism, called medium-grained parallelism, which is geared to multicore architectures and based on the multithreaded programming model. P threads corresponding to P available physical cores have the task of computing seed extensions simultaneously. This scheme corresponds to the parallelization of the outer <monospace>for all</monospace> loop (line 3). The algorithm is split into P+1 threads as given in Algorithm 2.</p>
      <p><bold>Algorithm 2 </bold>PLAST algorithm</p>
      <p>Main thread</p>
      <p>1: <italic>IT</italic><sub>0 </sub>â Index (bank-0)</p>
      <p>2: <italic>IT</italic><sub>1 </sub>â Index (bank-1)</p>
      <p>3: create P extension threads</p>
      <p>4: K = 0</p>
      <p>5: wait until K &gt;= T</p>
      <p>6: Â Â Â merge thread results</p>
      <p>P extension threads</p>
      <p>1: <monospace>while (K&lt;T)</monospace></p>
      <p>2: k = K++</p>
      <p>3: <italic>IL</italic><sub>0 </sub>â <italic>IT</italic><sub>0 </sub>[<italic>k</italic>]</p>
      <p>4: <italic>IL</italic><sub>1 </sub>â <italic>IT</italic><sub>1 </sub>[<italic>k</italic>]</p>
      <p>5: Â Â Â for all elements i in <italic>IL</italic><sub>0</sub></p>
      <p>6: Â Â Â Â Â Â for all elements j in <italic>IL</italic><sub>1</sub></p>
      <p>7: Â Â Â Â Â Â Â Â Â if ungapped_extension (<italic>IL</italic><sub>0</sub>[<italic>i</italic>], <italic>IL</italic><sub>1</sub>[<italic>j</italic>])</p>
      <p>8: Â Â Â Â Â Â Â Â Â Â Â Â then gapped_extension (<italic>IL</italic><sub>0</sub>[<italic>i</italic>], <italic>IL</italic><sub>1</sub>[<italic>j</italic>])</p>
      <p>First, the main thread constructs two indexes before creating P extension threads. It sets a shared variable K to 0 (line 4), representing the key of the first subset seed value, and waits until all subset seed values have been processed. The extension threads increase K (line 2) and compute the extension related to K. The instruction <monospace>k = K++</monospace> is atomic in order to prevent two threads from having the same <monospace>K</monospace> value. The last action of the main thread is to merge the results provided by each extension thread.</p>
      <p>A second level of parallelism, called fine-grained parallelism, can be found in the two nested <monospace>for all</monospace> loops (lines 5 and 6, extension threads). Again, each seed extension between all the positions of the two index lists can be carried out simultaneously. Furthermore, this computation is very <italic>regular </italic>in that a score is systematically computed in the seed neighborhood. The value of this score indicates whether the alignments are significant or not. This regular computation is done using the SSE instruction set (Streaming SIMD Extensions) now available on all microprocessors. In this implementation, it allows the processor to calculate 16 scores in parallel.</p>
      <p>Each step is now described in more detail.</p>
    </sec>
    <sec>
      <title>Step 1: bank indexing</title>
      <p>Each protein bank is indexed using the same data structure as that shown in Figure <xref ref-type="fig" rid="F1">1</xref>. A list is made of all the positions in the protein bank of each seed key. A relative position, computed as the difference between two successive positions, is stored to minimize index size. As a result, the difference can be stored on a short integer (two bytes), rather than as an absolute position on a standard 4-byte integer. For infrequent subset seeds, however, the difference may exceed the dynamic range of short integers (2<sup>16</sup>). To circumvent this problem, false positive subset seed occurrences are added between two distance positions. The overhead introduced by these extra occurrences increases the size of the list by about 2%.</p>
      <fig position="float" id="F1">
        <label>Figure 1</label>
        <caption>
          <p><bold>Bank indexing</bold>. Fragment of indexing scheme. For each seed key, a list of relative occurrence positions is stored on short integers.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-329-1"/>
      </fig>
      <p>A subset seed is a word of W characters built by grouping together some amino acids [<xref ref-type="bibr" rid="B14">14</xref>]. The following 4-character subset seed structure can be considered as an example:</p>
      <p>â¢ character 1: A,C,D,E,F,G,H,I,K,L,M,N,P,Q,R,S,T,V,W,Y</p>
      <p>â¢ character 2: c = {C,F,Y,W,M,L,I,V}, g = {G,P,A,T,S,N,H,Q,E,D,R,K}</p>
      <p>â¢ character 3: A,C,f = {F,Y,W},G,i = {I,V},m = {M,L},n = {N,H},P,q = {Q,E,D},r = {R,K},t = {T,S}</p>
      <p>â¢ character 4: A,C,D,E,F,G,H,I,K,L,M,N,P,Q,R,S,T,V,W,Y</p>
      <p>Here, the second character of a subset seed is either c or g. For example, the subset seed AcGL represents the words ACGL, AFGL, AYGL, AWGL, AMGL, ALGL, AIGL and AVGL in the 20 amino acid alphabet.</p>
      <p>Whereas the BLAST algorithm requires two neighboring seeds of 3 amino acids to start the computation of an alignment, only one subset seed of 4 characters is used here. This offers the advantage of greatly simplifying computation by eliminating data dependencies and making it much more suitable for parallelism. An extension starts as soon as two identical subset seeds are found in two different protein sequences, thereby avoiding the need for any extra computation for managing pairs of seeds. In [<xref ref-type="bibr" rid="B14">14</xref>], it is shown that this subset seed structure and the BLAST approach exhibit comparable sensitivity.</p>
      <p>PLAST requires 4 Ã 20<sup><italic>W </italic></sup>+ 2.02 Ã <italic>n </italic>bytes to index one sequence database, where W is the size of the subset seed being used (usually from 3 to 4) and <italic>n </italic>is the number of amino acids in the sequence database. To allow comparison of very large databases, PLAST automatically splits them into smaller fragments, which fit with the processor memory. Hence, databases of any size can be processed without further pre-processing.</p>
    </sec>
    <sec>
      <title>Step 2: Ungapped extension</title>
      <p>As stated earlier, BLAST ungapped extension is run when two close seeds are detected. The extension starts from one seed and extends in both directions. The extension terminates when a running score falls below a threshold value. This technique allows BLAST to limit search space efficiently. As the size of the extension regions can vary from one sequence to another, however, this technique is not suitable for regular computation targeting SSE instructions.</p>
      <p>The approach adopted here is different, performing an extension on a predefined size L, both on the left and on the right hand sides of the subset seed. More precisely, for a seed key k in the two index tables, <italic>IL</italic>0 has <italic>K</italic><sub>0 </sub>elements and <italic>IL</italic>1 has <italic>K</italic><sub>1 </sub>elements, meaning that <italic>K</italic><sub>0 </sub>Ã <italic>K</italic><sub>1 </sub>extensions must be processed. Thus, two blocks of subsequences <italic>BLK</italic>0<sub><italic>k </italic></sub>and <italic>BLK</italic>1<sub><italic>k </italic></sub>are constructed. Each subsequence is composed of a seed of W characters with its right and left extensions of L characters, as illustrated in Figure <xref ref-type="fig" rid="F2">2</xref>. Based on this data structure, the ungapped extension procedure between the <italic>i</italic><sup><italic>th </italic></sup>subsequence of <italic>BLK</italic>0<sub><italic>k </italic></sub>and the <italic>j</italic><sup><italic>th </italic></sup>subsequence of <italic>BLK</italic>1<sub><italic>k </italic></sub>is given in Algorithm 3.</p>
      <fig position="float" id="F2">
        <label>Figure 2</label>
        <caption>
          <p><bold>Subsequence block</bold>. Fragment of subsequence block. For each seed key, a list of subsequences is constructed. Each subsequence contains a seed and its right and left neighborhood.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-329-2"/>
      </fig>
      <p>The aim of this procedure is to compute a score related to the similarity between two protein subsequences of length (<italic>W </italic>+ 2 Ã <italic>L</italic>). It is split into two phases. The first computes a score by extending the right neighborhood (line 4-7). The maximal value is computed and set as the initial score for the left extension (line 9-12). At the end, the maximal score is compared to a predefined threshold value <italic>Ï</italic>. If it is greater than <italic>Ï</italic>, the couple of subsequences (<italic>BLK</italic>0<sub><italic>k</italic></sub>[<italic>i</italic>], <italic>BLK</italic>1<sub><italic>k</italic></sub>[<italic>j</italic>]) is a candidate for further processing (gapped extension).</p>
      <p><bold>Algorithm 3 </bold>ungapped extension procedure</p>
      <p>1: <italic>S</italic><sub>0 </sub>â <italic>BLK</italic>0<sub><italic>k</italic></sub>[<italic>i</italic>]</p>
      <p>2: <italic>S</italic><sub>1 </sub>â <italic>BLK</italic>1<sub><italic>k</italic></sub>[<italic>j</italic>]</p>
      <p>3: <italic>score </italic>â 0; <italic>max_score </italic>â 0</p>
      <p>4: for <italic>x </italic>= 1 to <italic>W </italic>+ <italic>L</italic></p>
      <p>5: Â Â Â <italic>score </italic>â <italic>score</italic>+ Sub (<italic>S</italic><sub>0</sub>[<italic>x</italic>], <italic>S</italic><sub>1</sub>[<italic>x</italic>])</p>
      <p>6: Â Â Â if <italic>score </italic>&gt; <italic>max_score </italic>then <italic>max_score </italic>â <italic>score </italic>endif</p>
      <p>7: endfor</p>
      <p>8: <italic>score </italic>â <italic>max_score</italic></p>
      <p>9: for <italic>x </italic>= <italic>W </italic>+ <italic>L </italic>+ 1 to 2 Ã <italic>L </italic>+ <italic>W</italic></p>
      <p>10: Â Â Â <italic>score </italic>â <italic>score</italic>+ Sub (<italic>S</italic><sub>0</sub>[<italic>x</italic>], <italic>S</italic><sub>1</sub>[<italic>x</italic>])</p>
      <p>11: Â Â Â if <italic>score </italic>&gt; <italic>max_score </italic>then <italic>max_score </italic>â <italic>score </italic>endif</p>
      <p>12: endfor</p>
      <p>13: if <italic>max_score </italic>â¥ <italic>Ï </italic>then return true endif</p>
      <p>14: return false</p>
      <p>Remember that for a specific seed key k, there are <italic>K</italic><sub>0 </sub>Ã <italic>K</italic><sub>1 </sub>extensions to process, and that all extensions can be computed in parallel (no data dependencies between these <italic>K</italic><sub>0 </sub>Ã <italic>K</italic><sub>1 </sub>processes). Hence, SSE instructions can be advantageously used to parallelize this procedure. The idea is to compute N scores in parallel using a SIMD scheme. In this processing mode, a score fits into 1 or 2 bytes and the SIMD register of the microprocessor simultaneously contains N scores. The extension procedure can thus be run in parallel between N subsequences of <italic>BLK</italic>0<sub><italic>k </italic></sub>and one subsequence of <italic>BLK</italic>1<sub><italic>k</italic></sub>.</p>
      <p>In the implementation considered here, 16 scores are simultaneously computed on a 128-bit-wide register, forcing the score to fit between 0 and 255 (8 bits). As the score is computed on short subsequences, it rarely overflows. However, SSE instructions support saturating arithmetic on 8-bit unsigned values. Thus, if the result of an operation becomes greater than 255, it is automatically adjusted to 255.</p>
      <p>The last point that needs to be considered is how to manage negative scores. Owing to the limited precision provided by a single byte value, SSE instructions consider only unsigned 8-bit integers. To avoid negative values, bias calculation is performed based on the smallest value of the scoring matrix. This approach is described in Rognes [<xref ref-type="bibr" rid="B3">3</xref>] and Farrar [<xref ref-type="bibr" rid="B4">4</xref>]. Figure <xref ref-type="fig" rid="F3">3</xref> describes the pseudocode of the ungapped extension procedure for two blocks of subsequences.</p>
      <fig position="float" id="F3">
        <label>Figure 3</label>
        <caption>
          <p><bold>pseudocode for <italic>ungapped extension</italic></bold>. The pseudocode of ungapped extension procedure for 2 blocks of subsequences. Sixteen extensions are simultaneously processed and a score is stored on an 8-bit unsigned byte integer.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-329-3"/>
      </fig>
    </sec>
    <sec>
      <title>Step 3: gapped extension</title>
      <p>Ungapped alignments with significant similarities are passed in to this step to extend alignments with gap errors further. A significant amount of time can be spent on this activity, as shown by a BLASTP profiling study in [<xref ref-type="bibr" rid="B15">15</xref>], representing up to 30% of the total execution time. Parallelizing this step is also important to minimize overall execution time.</p>
      <p>This is achieved as follows: the gapped extension is split into two sub-steps. In the first, <italic>small </italic>gapped extensions are considered. They are constrained by the number of permissible <italic>Ï </italic>gaps with <italic>Î» </italic>extensions to restrict the search space. The search space is also limited to a neighborhood of L amino acids on each side of the subset seed (L = 64). Again, if the score exceeds a threshold value, a full gapped extension (second sub-step) is computed using the NCBI-BLAST procedure. In this way, the results are similar to the BLAST output.</p>
      <p>The reason for splitting this step into two stages is to make the computation more regular and, in this way, exhibit greater parallelism. The first part consists in computing many small gapped alignments where the search space is identical. The strategy is the same as the <italic>banded Smith Waterman </italic>algorithm strategy in WU-BLAST [<xref ref-type="bibr" rid="B16">16</xref>] with the <italic>band length Î» </italic>and the <italic>band width Ï</italic>. If the score of the left and right extensions exceeds a specified threshold <italic>Ï</italic><sub><italic>sg</italic></sub>, the second step using the full dynamic programming procedure is launched.</p>
      <p>Small gapped extensions are also independent. SSE instructions may therefore be used again to compute a large number of them simultaneously. The ungapped alignments coming from step 2 are stored in a list. When this list contains at least K ungapped alignments, they are processed in SIMD mode.</p>
      <p>Unlike ungapped extensions, however, pairs of subsequences are quite similar since a significant similarity has been detected during step 2. In addition, the length of the subsequences is longer (128 amino acids). Consequently, the score is unlikely to fit the range of an 8-bit integer. Thus, in this procedure, only 8 scores are computed in parallel, each score being stored in a 16-bit signed short integer. Figure <xref ref-type="fig" rid="F4">4</xref> shows the pseudocode of the small gapped extension procedure.</p>
      <fig position="float" id="F4">
        <label>Figure 4</label>
        <caption>
          <p><bold>pseudocode for <italic>small gapped extension</italic></bold>. The pseudocode of small gapped extension procedure. Eight extensions are simultaneously processed and a score is stored on a 16-bit signed short integer.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-329-4"/>
      </fig>
      <p>An important point to be noted is that step 2 can generate many ungapped alignments belonging to the same final alignment, especially when strong similarities occur. In this case, several subset seeds are naturally included in the same alignment. With the approach discussed here, these subset seeds are systematically processed, even if they overlap, leading to high redundancy. To generate only one final alignment, a sorted list of all alignments already computed is stored in memory. Then, before launching a full gapped extension, a check is performed to see whether the small gap alignment to be extended is not included in the final alignment list. This list is common to all the extension threads.</p>
    </sec>
    <sec>
      <title>Statistical model</title>
      <p>Like BLAST, PLAST uses Karlin-Altschul statistics [<xref ref-type="bibr" rid="B17">17</xref>,<xref ref-type="bibr" rid="B18">18</xref>] to evaluate the statistical significance of gapped alignments. An E-value is then associated to each alignment and is computed following the BLAST methodology. Since PLAST manages two banks, one is considered as a list of independent queries (-i option) and the other as the database (-d option). Compositions-based statistic [<xref ref-type="bibr" rid="B19">19</xref>] is also available for PLASTP and TPLASTN programs.</p>
    </sec>
  </sec>
  <sec>
    <title>Results and Discussion</title>
    <p>This section presents the results of the experiments conducted on three versions of the PLAST algorithm for protein comparison: PLASTP, TPLASTN and PLASTX.</p>
    <p>Sensitivity and selectivity were first evaluated using the receiver operating characteristic (<italic>ROC</italic>) and coverage versus errors per query (<italic>EPQ</italic>). Measurements show that results are comparable to BLAST (release 2.2.18). Execution time was then analyzed on standard multicore processors and also compared to BLAST. A speedup of 3 to 6 was achieved depending on the size and nature of the data.</p>
    <sec>
      <title>Receiver operating characteristic evaluation</title>
      <p>First, the ROC statistical measure for PLASTP was computed using the method described in [<xref ref-type="bibr" rid="B20">20</xref>]. The data set was the SCOP database (release 1.73) with a maximum percentage identity of 40%, downloaded from the ASTRAL SCOP website [<xref ref-type="bibr" rid="B21">21</xref>,<xref ref-type="bibr" rid="B22">22</xref>]. This data set includes 7,678 sequences from 1,601 families. The 7,678 SCOP sequences are compared to the data set, and the results of all searches are pooled by E-value. True positives are query-subject pairs in the same family. Self-hits are ignored. For increasing E-value, the ROC score, for <italic>n </italic>false positives, is defined as:</p>
      <p>
        <disp-formula>
          <graphic xlink:href="1471-2105-10-329-i1.gif"/>
        </disp-formula>
      </p>
      <p>T is the total number of true positives in the data set, i is the rank of the false positives, and t<sub><italic>i </italic></sub>is the number of true positives ranked ahead of the <italic>i</italic>th false positive.</p>
      <p>The ROC curve was calculated for both PLASTP and BLASTP with the BLOSUM62 scoring matrix and gap penalty of 11-1 and with the BLOSUM50 scoring matrix and gap penalty of 13-2. Also, in both cases, the SEG filtering was disabled. The E-value was set to 10. The ROC curves of PLASTP and BLASTP are compared in Figure <xref ref-type="fig" rid="F5">5(A)</xref>.</p>
      <fig position="float" id="F5">
        <label>Figure 5</label>
        <caption>
          <p><bold>ROC curve</bold>. (A) The ROC curves for the SCOP/ASTRAL40 data set of PLASTP and BLASTP. (B) The ROC curves for the Yeast data set of TPLASTN and TBLASTN. The ROC<sub>10000 </sub>score in (A) and ROC<sub>250 </sub>score in (B) for each program are shown in parentheses after the program name.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-329-5"/>
      </fig>
      <p>For computing the TPLASTN ROC curve, the data set was composed of the yeast (Saccharomyces cerevisiae) genome and a set of 102 proteins [<xref ref-type="bibr" rid="B23">23</xref>]. We used 102 proteins as queries against the yeast genome and, again, the results of all searches are pooled by E-value. All alignments were marked as true or false positives according to a careful human expert annotation [<xref ref-type="bibr" rid="B23">23</xref>]. Figure <xref ref-type="fig" rid="F5">5(B)</xref> shows the TPLASTN ROC curve.</p>
      <p>As it can be seen, the PLAST and BLAST ROC curves are very close, but not identical. BLAST performs a little bit well than PLAST when its E-value is set to a high value. Actually, one of the main objectives of PLAST is to be included inside bioinformatics workflows to process large amount of data for automatic analysis, such as genome annotation. In that case, to increase confidence, the E-value is set to a much lower value. For example, setting the E-value to 10<sup>-3 </sup>in the previous ROC analysis provides identical ROC curves between PLASTP and BLASTP (see Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>).</p>
    </sec>
    <sec>
      <title>Coverage versus error plot</title>
      <p>The coverage versus error plot was also used for evaluating the selectivity of PLAST. Instead of taking all alignments with a fixed E-value threshold, as in the ROC curve analysis, the E-value threshold was varied from 10<sup>-50 </sup>to 10. Then for each threshold value, two parameters were measured: the coverage and errors per query (EPQ). The coverage is the number of true positives divided by the total number of true positives available in the data set. The EPQ is the number of false positives divided by the number of queries. The same two data sets were used for computing the coverage versus error plot for PLASTP, TPLASTN, BLASTP and TBLASTN. Figure <xref ref-type="fig" rid="F6">6</xref> shows performance plots. Again, the plots obtained for the two program families, are very close.</p>
      <fig position="float" id="F6">
        <label>Figure 6</label>
        <caption>
          <p><bold>Coverage versus error plot</bold>. (A) The coverage versus error plots for the SCOP/ASTRAL40 data set of PLASTP and BLASTP. (B) The coverage versus error plots for the Yeast data set of TPLASTN and TBLASTN.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-329-6"/>
      </fig>
    </sec>
    <sec>
      <title>Execution time</title>
      <p>In order to evaluate the ability of PLAST to manage large amounts of data, three data sets were made to test the PLASTP, TPLASTN and PLASTX programs, i.e. one data set for each program:</p>
    </sec>
    <sec>
      <title>Data set #1: PLASTP</title>
      <p>â¢ PROT-GB1-NR contains 2,977,744 protein sequences representing the first volume of the Genbank nonredundant protein database (1,000 Mega aa);</p>
      <p>â¢ PROT-SCOP-1K, PROT-SCOP-3K and PROT-SCOP-10K contain respectively 1,000 protein sequences (0.185 Mega aa), 3,000 protein sequences (0.434 Mega aa) and 10,000 protein sequences (1.871 Mega aa) selected from the SCOP database.</p>
    </sec>
    <sec>
      <title>Data set #2: TPLASTN</title>
      <p>â¢ DNA-HUMAN-CHR1 is human chromosome 1 (NCBI Mar. 2008, 220 Mega nt);</p>
      <p>â¢ PROT-GB-1K, PROT-GB-3K and PROT-GB-10K contain respectively 1,000 protein sequences (0.336 Mega aa), 3,000 protein sequences (1.025 Mega aa) and 10,000 protein sequences (3.433 Mega aa) selected from the Genbank nonredundant protein database.</p>
    </sec>
    <sec>
      <title>Data set #3: PLASTX</title>
      <p>â¢ SWPROT is UniProtKB/Swiss-Protis (Release 56.2, 398,181 protein sequences, 144 Mega aa);</p>
      <p>â¢ DNA-GB-1K, DNA-GB-3K and DNA-GB-10K contain respectively 1,000 DNA sequences (1.031 Mega nt), 3,000 DNA sequences (3.172 Mega nt) and 10,000 DNA sequences (10.175 Mega nt) selected from the gbvrl Genbank division.</p>
      <p>The hardware platform is a 2.6 GHz Xeon Core 2 Quad processor with 8 GB of RAM running Linux Fedora 7. This platform is thus able to run 8 threads in parallel. The Xeon Core 2 processor has a standard SSE instruction set.</p>
    </sec>
    <sec>
      <title>Comparison with BLAST</title>
      <p>Each PLAST program was run with its specific fiata set. For the purpose of comparison, the BLASTP, TBLASTN and BLASTX programs (release 2.2.18) were also run with the same data set, with the multithreading option enabled (-a option). <bold>blastall </bold>was run as follows:</p>
      <p>blastall -p program of BLAST -m 8 -a number of threads -e E-value</p>
      <p>Experiments were performed on three runs:</p>
      <p>â¢ # threads = 2, E-value = 10<sup>-3 </sup>(Table <xref ref-type="table" rid="T1">1</xref>)</p>
      <table-wrap position="float" id="T1">
        <label>Table 1</label>
        <caption>
          <p>Multicore with 2 threads and E-value equal to 10<sup>-3</sup></p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td/>
              <td align="center" colspan="3">
                <bold>protein vs protein</bold>
              </td>
              <td align="center" colspan="3">
                <bold>protein vs DNA</bold>
              </td>
              <td align="center" colspan="3">
                <bold>DNA vs protein</bold>
              </td>
            </tr>
            <tr>
              <td/>
              <td colspan="9">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center">
                <bold>query bank</bold>
              </td>
              <td align="center">
                <bold>BLASTP</bold>
              </td>
              <td align="center">
                <bold>PLASTP</bold>
              </td>
              <td align="center">
                <bold>speedup</bold>
              </td>
              <td align="center">
                <bold>TBLASTN</bold>
              </td>
              <td align="center">
                <bold>TPLASTN</bold>
              </td>
              <td align="center">
                <bold>speedup</bold>
              </td>
              <td align="center">
                <bold>BLASTX</bold>
              </td>
              <td align="center">
                <bold>PLASTX</bold>
              </td>
              <td align="center">
                <bold>speedup</bold>
              </td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">1K</td>
              <td align="center">4380</td>
              <td align="center">1446</td>
              <td align="center">3.02</td>
              <td align="center">805</td>
              <td align="center">319</td>
              <td align="center">2.52</td>
              <td align="center">2261</td>
              <td align="center">554</td>
              <td align="center">4.08</td>
            </tr>
            <tr>
              <td align="center">3K</td>
              <td align="center">10860</td>
              <td align="center">2602</td>
              <td align="center">4.17</td>
              <td align="center">2344</td>
              <td align="center">556</td>
              <td align="center">4.21</td>
              <td align="center">6989</td>
              <td align="center">1591</td>
              <td align="center">4.39</td>
            </tr>
            <tr>
              <td align="center">10K</td>
              <td align="center">52131</td>
              <td align="center">12415</td>
              <td align="center">4.19</td>
              <td align="center">7971</td>
              <td align="center">1416</td>
              <td align="center">5.26</td>
              <td align="center">21667</td>
              <td align="center">4981</td>
              <td align="center">4.34</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Comparison of performance of BLAST and PLAST families running with 2 threads. The E-value cutoff is set to 10<sup>-3 </sup>and option "-m8" of BLAST is enabled. BLAST is run in multithread mode (-a 2). Execution times are given in seconds.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>â¢ # threads = 8, E-value = 10<sup>-3 </sup>(Table <xref ref-type="table" rid="T2">2</xref>)</p>
      <table-wrap position="float" id="T2">
        <label>Table 2</label>
        <caption>
          <p>Multicore with 8 threads and E-value equal to 10<sup>-3</sup></p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td/>
              <td align="center" colspan="3">
                <bold>protein vs protein</bold>
              </td>
              <td align="center" colspan="3">
                <bold>protein vs DNA</bold>
              </td>
              <td align="center" colspan="3">
                <bold>DNA vs protein</bold>
              </td>
            </tr>
            <tr>
              <td/>
              <td colspan="9">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center">
                <bold>query bank</bold>
              </td>
              <td align="center">
                <bold>BLASTP</bold>
              </td>
              <td align="center">
                <bold>PLASTP</bold>
              </td>
              <td align="center">
                <bold>speedup</bold>
              </td>
              <td align="center">
                <bold>TBLASTN</bold>
              </td>
              <td align="center">
                <bold>TPLASTN</bold>
              </td>
              <td align="center">
                <bold>speedup</bold>
              </td>
              <td align="center">
                <bold>BLASTX</bold>
              </td>
              <td align="center">
                <bold>PLASTX</bold>
              </td>
              <td align="center">
                <bold>speedup</bold>
              </td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">1K</td>
              <td align="center">1530</td>
              <td align="center">506</td>
              <td align="center">3.02</td>
              <td align="center">384</td>
              <td align="center">117</td>
              <td align="center">3.28</td>
              <td align="center">651</td>
              <td align="center">174</td>
              <td align="center">3.74</td>
            </tr>
            <tr>
              <td align="center">3K</td>
              <td align="center">4206</td>
              <td align="center">898</td>
              <td align="center">4.46</td>
              <td align="center">1068</td>
              <td align="center">186</td>
              <td align="center">5.74</td>
              <td align="center">1999</td>
              <td align="center">451</td>
              <td align="center">4.43</td>
            </tr>
            <tr>
              <td align="center">10K</td>
              <td align="center">21450</td>
              <td align="center">3807</td>
              <td align="center">5.60</td>
              <td align="center">3659</td>
              <td align="center">428</td>
              <td align="center">8.54</td>
              <td align="center">6237</td>
              <td align="center">1418</td>
              <td align="center">4.39</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Comparison of performance of BLAST and PLAST families running with 8 threads. The E-value cutoff is set to 10<sup>-3 </sup>and option "-m8" of BLAST is enabled. BLAST is run in multithread mode (-a 8). Execution times are given in seconds.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>â¢ # threads = 2, E-value = 10 (Table <xref ref-type="table" rid="T3">3</xref>)</p>
      <table-wrap position="float" id="T3">
        <label>Table 3</label>
        <caption>
          <p>Multicore with 2 threads and E-value equal to 10</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td/>
              <td align="center" colspan="3">
                <bold>protein vs protein</bold>
              </td>
              <td align="center" colspan="3">
                <bold>protein vs DNA</bold>
              </td>
              <td align="center" colspan="3">
                <bold>DNA vs protein</bold>
              </td>
            </tr>
            <tr>
              <td/>
              <td colspan="9">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center">
                <bold>query bank</bold>
              </td>
              <td align="center">
                <bold>BLASTP</bold>
              </td>
              <td align="center">
                <bold>PLASTP</bold>
              </td>
              <td align="center">
                <bold>speedup</bold>
              </td>
              <td align="center">
                <bold>TBLASTN</bold>
              </td>
              <td align="center">
                <bold>TPLASTN</bold>
              </td>
              <td align="center">
                <bold>speedup</bold>
              </td>
              <td align="center">
                <bold>BLASTX</bold>
              </td>
              <td align="center">
                <bold>PLASTX</bold>
              </td>
              <td align="center">
                <bold>speedup</bold>
              </td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">1K</td>
              <td align="center">4836</td>
              <td align="center">1521</td>
              <td align="center">3.17</td>
              <td align="center">1003</td>
              <td align="center">360</td>
              <td align="center">2.78</td>
              <td align="center">2286</td>
              <td align="center">558</td>
              <td align="center">4.08</td>
            </tr>
            <tr>
              <td align="center">3K</td>
              <td align="center">12298</td>
              <td align="center">2861</td>
              <td align="center">4.29</td>
              <td align="center">2881</td>
              <td align="center">632</td>
              <td align="center">4.55</td>
              <td align="center">7010</td>
              <td align="center">1631</td>
              <td align="center">4.29</td>
            </tr>
            <tr>
              <td align="center">10K</td>
              <td align="center">58145</td>
              <td align="center">14004</td>
              <td align="center">4.15</td>
              <td align="center">9480</td>
              <td align="center">1631</td>
              <td align="center">5.81</td>
              <td align="center">21774</td>
              <td align="center">5002</td>
              <td align="center">4.35</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Comparison of performance of BLAST and PLAST families running with 2 threads. The E-value cutoff is set to 10 and option "-m8" of BLAST is enabled. BLAST is run in multithread mode (-a 2). Execution times are given in seconds.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>In all cases, the BLOSUM62 matrix was used with gap-open penalty and gap-extension penalty set respectively to 11 and 1 (default BLAST parameters). Tables <xref ref-type="table" rid="T1">1</xref> to <xref ref-type="table" rid="T3">3</xref> show the time spent (in seconds) for each run and the speedup of PLAST compared to BLAST.</p>
      <p>An E-value of 10<sup>-3 </sup>is a reasonable value when performing intensive sequence comparison. However, setting the E-value to 10 had no significant impact on the execution time.</p>
      <p>It can be seen that for each experiment, significant speedup is obtained compared to BLAST. More precisely, the speedup obtained (each measure was performed with an identical number of threads) increased with the size of the data set.</p>
      <p>To evaluate PLAST sensitivity for large databases, sets of alignments reported by PLAST and BLAST were compared using two large sets of data: GB1-NR versus PROT-SCOP-1K (PLASTP) and SWPROT versus DNA-GB-1K (PLASTX). Two alignments are considered equivalent if they overlap by more than 70%. An alignment A is included in an alignment B if alignment A belongs to alignment B. A misalignment occurs if an alignment found by one program is not found by the other. The E-value threshold was varied from 10 to 10<sup>-3</sup>. For each threshold value, the misalignments of PLAST and BLAST were calculated for the two data sets as follows:</p>
      <p>â¢ PLAST<sub><italic>miss </italic></sub>= BLAST<sub><italic>total </italic></sub>- BLAST<sub><italic>include </italic></sub>- Identical</p>
      <p>â¢ BLAST<sub><italic>miss </italic></sub>= PLAST<sub><italic>total </italic></sub>- PLAST<sub><italic>include </italic></sub>- Identical</p>
      <p>where BLAST<sub><italic>total </italic></sub>and PLAST<sub><italic>total </italic></sub>are the numbers of alignments found respectively by BLAST and PLAST; BLAST<sub><italic>include </italic></sub>and PLAST<sub><italic>include </italic></sub>are the numbers of alignments included respectively in PLAST<sub><italic>total </italic></sub>and BLAST<sub><italic>total </italic></sub>of BLAST and PLAST; Identical is the number of equivalent alignments between BLAST and PLAST. The results are shown in Tables <xref ref-type="table" rid="T4">4</xref> and <xref ref-type="table" rid="T5">5</xref>. See Additional file <xref ref-type="supplementary-material" rid="S2">2</xref> for results on the 3K and 10K data sets.</p>
      <table-wrap position="float" id="T4">
        <label>Table 4</label>
        <caption>
          <p>Misalignments of PLASTP and BLASTP</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td align="center">
                <bold>E-value</bold>
              </td>
              <td align="center">
                <bold>10</bold>
              </td>
              <td align="center">
                <bold>1</bold>
              </td>
              <td align="center">
                <bold>10</bold>
                <sup>
                  <bold>-1</bold>
                </sup>
              </td>
              <td align="center">
                <bold>10</bold>
                <sup>
                  <bold>-2</bold>
                </sup>
              </td>
              <td align="center">
                <bold>10</bold>
                <sup>
                  <bold>-3</bold>
                </sup>
              </td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">BLASTP<sub><italic>total</italic></sub></td>
              <td align="center">556570</td>
              <td align="center">507225</td>
              <td align="center">462673</td>
              <td align="center">423919</td>
              <td align="center">394887</td>
            </tr>
            <tr>
              <td align="center">PLASTP<sub><italic>total</italic></sub></td>
              <td align="center">537892</td>
              <td align="center">497933</td>
              <td align="center">464238</td>
              <td align="center">422466</td>
              <td align="center">394636</td>
            </tr>
            <tr>
              <td align="center">Identical</td>
              <td align="center">513096</td>
              <td align="center">477982</td>
              <td align="center">442854</td>
              <td align="center">409437</td>
              <td align="center">383746</td>
            </tr>
            <tr>
              <td align="center">BLASTP<sub><italic>include</italic></sub></td>
              <td align="center">11227</td>
              <td align="center">9135</td>
              <td align="center">7586</td>
              <td align="center">6181</td>
              <td align="center">5259</td>
            </tr>
            <tr>
              <td align="center">PLASTP<sub><italic>include</italic></sub></td>
              <td align="center">3880</td>
              <td align="center">2868</td>
              <td align="center">2277</td>
              <td align="center">1570</td>
              <td align="center">1250</td>
            </tr>
            <tr>
              <td align="center">BLASTP<sub><italic>miss</italic></sub></td>
              <td align="center">20916 (3.9%)</td>
              <td align="center">17083 (3.4%)</td>
              <td align="center">19271 (4.1%)</td>
              <td align="center">9640 (2.2%)</td>
              <td align="center">10890 (2.7%)</td>
            </tr>
            <tr>
              <td align="center">PLASTP<sub><italic>miss</italic></sub></td>
              <td align="center">32247 (5.9%)</td>
              <td align="center">20108 (4.0%)</td>
              <td align="center">12232 (2.6%)</td>
              <td align="center">8301 (1.9%)</td>
              <td align="center">5882 (1.4%)</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Misalignments of PLASTP and BLASTP for GB1-NR versus PROT-SCOP-1K for different E-values.</p>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap position="float" id="T5">
        <label>Table 5</label>
        <caption>
          <p>Misalignments of PLASTX and BLASTX</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td align="center">
                <bold>E-value</bold>
              </td>
              <td align="center">
                <bold>10</bold>
              </td>
              <td align="center">
                <bold>1</bold>
              </td>
              <td align="center">
                <bold>10</bold>
                <sup>
                  <bold>-1</bold>
                </sup>
              </td>
              <td align="center">
                <bold>10</bold>
                <sup>
                  <bold>-2</bold>
                </sup>
              </td>
              <td align="center">
                <bold>10</bold>
                <sup>
                  <bold>-3</bold>
                </sup>
              </td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">BLASTX<sub><italic>total</italic></sub></td>
              <td align="center">127124</td>
              <td align="center">104474</td>
              <td align="center">96559</td>
              <td align="center">91760</td>
              <td align="center">88127</td>
            </tr>
            <tr>
              <td align="center">PLASTX<sub><italic>total</italic></sub></td>
              <td align="center">123425</td>
              <td align="center">101789</td>
              <td align="center">96051</td>
              <td align="center">90736</td>
              <td align="center">87085</td>
            </tr>
            <tr>
              <td align="center">Identical</td>
              <td align="center">113336</td>
              <td align="center">98660</td>
              <td align="center">93267</td>
              <td align="center">89285</td>
              <td align="center">85982</td>
            </tr>
            <tr>
              <td align="center">BLASTX<sub><italic>include</italic></sub></td>
              <td align="center">1694</td>
              <td align="center">1240</td>
              <td align="center">972</td>
              <td align="center">794</td>
              <td align="center">655</td>
            </tr>
            <tr>
              <td align="center">PLASTX<sub><italic>include</italic></sub></td>
              <td align="center">1317</td>
              <td align="center">823</td>
              <td align="center">591</td>
              <td align="center">398</td>
              <td align="center">268</td>
            </tr>
            <tr>
              <td align="center">BLASTX<sub><italic>miss</italic></sub></td>
              <td align="center">8772 (7.5%)</td>
              <td align="center">2306 (2.2%)</td>
              <td align="center">2193 (2.2%)</td>
              <td align="center">1053 (1.0%)</td>
              <td align="center">835 (0.9%)</td>
            </tr>
            <tr>
              <td align="center">PLASTX<sub><italic>miss</italic></sub></td>
              <td align="center">12094 (9.5%)</td>
              <td align="center">4574 (4.3%)</td>
              <td align="center">2701 (2.8%)</td>
              <td align="center">1681 (1.8%)</td>
              <td align="center">1490 (1.6%)</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Misalignments of PLASTX and BLASTX for SWPROT versus DNA-GB-1K for different E-values.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>The two programs do not find exactly the same alignments. This is due to the difference between the heuristics used to discover the seeds. Nonetheless, for the small E-values generally encountered when using PLAST, the results are very close.</p>
    </sec>
    <sec>
      <title>PLAST performance analysis</title>
      <p>Table <xref ref-type="table" rid="T6">6</xref> shows the execution time (in seconds) of the three PLAST programs relative to the number of threads and data sets. A first point is that performance increases with the size the data set, whatever the number of threads. This is mainly due to the architecture of the algorithm, which presents great computational locality, especially in step 2 (ungapped extension). This locality favors the use of the memory cache system and minimizes external memory access, which is a slow process compared to the processor internal clock frequency.</p>
      <table-wrap position="float" id="T6">
        <label>Table 6</label>
        <caption>
          <p>Execution time of the three PLAST programs</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td align="center">
                <bold>program</bold>
              </td>
              <td align="center" colspan="3">
                <bold>PLASTP</bold>
              </td>
              <td align="center" colspan="3">
                <bold>TPLASTN</bold>
              </td>
              <td align="center" colspan="3">
                <bold>PLASTX</bold>
              </td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">query bank</td>
              <td align="center">1K</td>
              <td align="center">3K</td>
              <td align="center">10K</td>
              <td align="center">1K</td>
              <td align="center">3K</td>
              <td align="center">10K</td>
              <td align="center">1K</td>
              <td align="center">3K</td>
              <td align="center">10K</td>
            </tr>
            <tr>
              <td align="center">1 thread</td>
              <td align="center">2704</td>
              <td align="center">5024</td>
              <td align="center">24374</td>
              <td align="center">570</td>
              <td align="center">1053</td>
              <td align="center">2810</td>
              <td align="center">1081</td>
              <td align="center">3090</td>
              <td align="center">9730</td>
            </tr>
            <tr>
              <td align="center">2 threads</td>
              <td align="center">1446</td>
              <td align="center">2602</td>
              <td align="center">12415</td>
              <td align="center">319</td>
              <td align="center">556</td>
              <td align="center">1416</td>
              <td align="center">554</td>
              <td align="center">1591</td>
              <td align="center">4981</td>
            </tr>
            <tr>
              <td align="center">4 threads</td>
              <td align="center">847</td>
              <td align="center">1480</td>
              <td align="center">7370</td>
              <td align="center">188</td>
              <td align="center">310</td>
              <td align="center">773</td>
              <td align="center">303</td>
              <td align="center">842</td>
              <td align="center">2620</td>
            </tr>
            <tr>
              <td align="center">8 threads</td>
              <td align="center">506</td>
              <td align="center">898</td>
              <td align="center">3807</td>
              <td align="center">117</td>
              <td align="center">186</td>
              <td align="center">428</td>
              <td align="center">174</td>
              <td align="center">451</td>
              <td align="center">1418</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Performance of the three PLAST programs running with multithreading mode. The E-value cutoff is set to 10<sup>-3</sup>. Execution times are given in seconds.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>A second point is the scalability of the PLAST algorithm when the number of threads increases. Figure <xref ref-type="fig" rid="F7">7</xref> depicts speedup as a function of the number of threads. It clearly highlights limitations due to the sequential indexing part of the program as explained by Table <xref ref-type="table" rid="T7">7</xref>, which shows the time required for step 1 as a percentage of overall execution time. As stated by Amdahl's law [<xref ref-type="bibr" rid="B24">24</xref>], the speedup of a program using multiple processors is limited by the time required for the sequential fraction (P) of the program. The maximum speedup is bounded by 1/(1 - <italic>P</italic>). Here, even if the indexing part represents a small fraction of the execution time, it represents a serious obstacle for the next generation of microprocessors, which will include a great number of cores on the same die.</p>
      <fig position="float" id="F7">
        <label>Figure 7</label>
        <caption>
          <p><bold>Speedup of the three PLAST programs</bold>. Speedup of the three PLAST programs relative to the number of threads and data sets. The E-value cutoff is set to 10<sup>-3</sup>.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-329-7"/>
      </fig>
      <table-wrap position="float" id="T7">
        <label>Table 7</label>
        <caption>
          <p>Percentage of indexing time overall in the three PLAST programs</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td align="center">
                <bold>program</bold>
              </td>
              <td align="center" colspan="3">
                <bold>PLASTP</bold>
              </td>
              <td align="center" colspan="3">
                <bold>TPLASTN</bold>
              </td>
              <td align="center" colspan="3">
                <bold>PLASTX</bold>
              </td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">query bank</td>
              <td align="center">1K</td>
              <td align="center">3K</td>
              <td align="center">10K</td>
              <td align="center">1K</td>
              <td align="center">3K</td>
              <td align="center">10K</td>
              <td align="center">1K</td>
              <td align="center">3K</td>
              <td align="center">10K</td>
            </tr>
            <tr>
              <td align="center">Indexing time (1 thread)</td>
              <td align="center">3.0%</td>
              <td align="center">1.6%</td>
              <td align="center">0.3%</td>
              <td align="center">6.5%</td>
              <td align="center">3.5%</td>
              <td align="center">1.4%</td>
              <td align="center">1.2%</td>
              <td align="center">0.4%</td>
              <td align="center">0.1%</td>
            </tr>
            <tr>
              <td align="center">Indexing time (8 threads)</td>
              <td align="center">15.8%</td>
              <td align="center">8.9%</td>
              <td align="center">2.1%</td>
              <td align="center">31.6%</td>
              <td align="center">19.9%</td>
              <td align="center">8.9%</td>
              <td align="center">7.5%</td>
              <td align="center">2.9%</td>
              <td align="center">1.0%</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Percentage of indexing time overall in the three PLAST programs with number of threads equal to 1 and 8.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>To measure the benefit of the SSE accelerations, profiling was performed, as shown in Figure <xref ref-type="fig" rid="F8">8</xref>. The same data set was used. The reference (100%) was the execution time without the use of the SSE instructions. More details can be found in Additional file <xref ref-type="supplementary-material" rid="S3">3</xref> to compare single-thread and non-SSE execution time between BLAST and PLAST.</p>
      <fig position="float" id="F8">
        <label>Figure 8</label>
        <caption>
          <p><bold>PLAST profile</bold>. The profiles of the three PLAST programs, with and without SSE instructions. Each PLAST program was run with its specific data set: (A) PLASTP; (B) TPLASTN; (C) PLASTX.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-329-8"/>
      </fig>
      <p>It can be seen that the ungapped extension represents a high percentage of computation time and that it can be considerably reduced with the SSE instructions. SSE instructions have a more modest impact on gap extensions.</p>
    </sec>
  </sec>
  <sec>
    <title>Conclusion</title>
    <p>PLAST primarily focuses on intensive sequence comparison applications, unlike BLAST, which is well optimized for scanning large genomic databases. It has been designed to manage large amounts of data and provides the best performance for such applications.</p>
    <p>PLAST is faster than BLAST, while providing comparable sensitivity with the same Karlin-Altschul statistics model. Results are not strictly identical since the heuristics for detecting alignments are different, even if both are based on seed techniques. PLAST integrates a 4-character subset seed approach while BLAST starts an extension when two 3-character seeds are located in a close neighborhood.</p>
    <p>BLAST and PLAST do not exactly target the same bioinformatics applications, even if PLAST aims to produce identical results. BLAST performs fast and sensitive scans of genomic databases. To detect low similarities, the user can set a high E-value and then analyse and interpret alignments. In that case, BLAST is better suited than PLAST since sensitivity is a little bit better.</p>
    <p>On the other hand, PLAST performs fast bank to bank comparison and results are expected to be piped to further automatic analysis. In this context, the E-value is generally set to a much lower value, leading PLAST to produce similar results compared to BLAST.</p>
    <p>PLAST has been designed to target the current and next generations of microprocessors that are - and will remain - parallel machines. Two types of parallelism are taken into consideration: multithreading (targeting multi- and manycore architectures) and SIMD (use of SSE instructions). These two modes of parallelism are combined to obtain maximum performance from the architecture of current and future microprocessors. For instance, the next generation of the new Intel set of SSE instructions, called AVX [<xref ref-type="bibr" rid="B25">25</xref>], which extends the SIMD integer registers to 256 bits and 512 bits, will be directly operational through the PLAST implementation. Similarly, advanced micro architectures, like the Intel Larrabee project [<xref ref-type="bibr" rid="B26">26</xref>] or the China Goldson-T manycore project [<xref ref-type="bibr" rid="B27">27</xref>], prefigure tomorrow's parallel hardware platforms, where PLAST parallelism will be fully exploited.</p>
    <p>Since bank indexing is done on-the-fly, PLAST requires no preformatting processes (such as formatdb) before it can be run. The two banks simply need to be in the widely used FASTA format. On the other hand, PLAST does not print alignments in the default BLAST output format. The main reason for this is that PLAST is not intended for interactive use, but rather as a building block in the primary stages of computational workflows for more advanced bioinformatics studies. Hence, the default PLAST output corresponds to the "-m 8" BLAST option, which simply summarizes the features of all alignments. This format is comprehensive for humans and very easy to handle for computers.</p>
    <p>PLAST is a 3-step algorithm where the two most time-consuming steps have been parallelized. On an 8-core architecture, corresponding to a current medium-range platform, good speedup is achieved. For larger configurations with 16 or 32 cores, speedup will be limited by the indexing part which, in the current implementation, is a purely sequential part. The next PLAST challenge is to parallelize this step.</p>
    <p>The PLAST family programs are currently focusing on protein sequences. PLASTN is not yet included in the current package. Work is still in progress to achieve an efficient version that takes into account the specifics of DNA sequences, especially for the ungapped step extension.</p>
  </sec>
  <sec>
    <title>Availability and requirements</title>
    <p>Project name: PLAST</p>
    <p>Project home page: http://www.irisa.fr/symbiose/projects/plast</p>
    <p>Operating system(s): Linux</p>
    <p>Programming language: C</p>
    <p>License: CECILL</p>
    <p>Restrictions for use by non-academics: none.</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>Both authors contributed to the design of the PLAST algorithm. The C implementation was mostly done by VHN. All authors read and approved the final manuscript.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="S1">
      <caption>
        <title>Additional file 1</title>
        <p><bold>Supplementary ROC curve</bold>. The ROC curves for the SCOP/ASTRAL40 data set of PLASTP and BLASTP with E-value of 10<sup>-3 </sup>and ROC curves for the Yeast data set of TPLASTN and TBLASTN with E-value of 1.</p>
      </caption>
      <media xlink:href="1471-2105-10-329-S1.PDF" mimetype="text" mime-subtype="plain">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="S2">
      <caption>
        <title>Additional file 2</title>
        <p><bold>Misalignments of PLAST and BLAST</bold>. The sensitivity results of BLAST and PLAST for four large sets of data: GB1-NR versus PROT-SCOP-3K, GB1-NR versus PROT-SCOP-10K, SWPROT versus DNA-GB-3K and SWPROT versus DNA-GB-10K.</p>
      </caption>
      <media xlink:href="1471-2105-10-329-S2.PDF" mimetype="text" mime-subtype="plain">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="S3">
      <caption>
        <title>Additional file 3</title>
        <p><bold>Single-threaded performance</bold>. The comparison of performance of BLAST and PLAST families running with single-threaded and non-SSE.</p>
      </caption>
      <media xlink:href="1471-2105-10-329-S3.PDF" mimetype="text" mime-subtype="plain">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <sec>
      <title>Acknowledgements</title>
      <p>The authors would like to thank A/Prof Laurent NoÃ© from Lille 1 University for all his valuable comments and suggestions to improve this manuscript and for providing various subset seeds.</p>
    </sec>
  </ack>
  <ref-list>
    <ref id="B1">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pop</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>Bioinformatics challenges of new sequencing technology</article-title>
        <source>Trends in Genetics</source>
        <year>2008</year>
        <volume>24</volume>
        <fpage>142</fpage>
        <lpage>149</lpage>
        <pub-id pub-id-type="pmid">18262676</pub-id>
      </citation>
    </ref>
    <ref id="B2">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smith</surname>
            <given-names>TF</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>MS</given-names>
          </name>
        </person-group>
        <article-title>Identification of common molecular subsequences</article-title>
        <source>Journal of Molecular Biology</source>
        <year>1981</year>
        <volume>147</volume>
        <fpage>195</fpage>
        <lpage>197</lpage>
        <pub-id pub-id-type="pmid">7265238</pub-id>
        <pub-id pub-id-type="doi">10.1016/0022-2836(81)90087-5</pub-id>
      </citation>
    </ref>
    <ref id="B3">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rognes</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Seeberg</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Six-fold speed-up of Smith-Waterman sequence database searches using parallel processing on common microprocessors</article-title>
        <source>Bioinformatics</source>
        <year>2000</year>
        <volume>16</volume>
        <fpage>699</fpage>
        <lpage>706</lpage>
        <pub-id pub-id-type="pmid">11099256</pub-id>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/16.8.699</pub-id>
      </citation>
    </ref>
    <ref id="B4">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Farrar</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Striped Smith-Waterman speeds database searches six times over other SIMD implementations</article-title>
        <source>Bioinformatics</source>
        <year>2007</year>
        <volume>23</volume>
        <fpage>156</fpage>
        <lpage>161</lpage>
        <pub-id pub-id-type="pmid">17110365</pub-id>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btl582</pub-id>
      </citation>
    </ref>
    <ref id="B5">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pearson</surname>
            <given-names>WR</given-names>
          </name>
        </person-group>
        <article-title>Searching protein sequence libraries: comparison of the sensitivity and selectivity of the Smith-Waterman and FASTA algorithms</article-title>
        <source>Genomics</source>
        <year>1991</year>
        <volume>11</volume>
        <fpage>635</fpage>
        <lpage>650</lpage>
        <pub-id pub-id-type="pmid">1774068</pub-id>
        <pub-id pub-id-type="doi">10.1016/0888-7543(91)90071-L</pub-id>
      </citation>
    </ref>
    <ref id="B6">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Liu</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Schmidt</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Voss</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Schroeder</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Muller-Wittig</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>Bio-sequence database scanning on a GPU</article-title>
        <source>Proceedings of the 20th IEEE International Parallel &amp; Distributed Processing Symposium</source>
        <year>2006</year>
      </citation>
    </ref>
    <ref id="B7">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Sachdeva</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Kistler</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Speight</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Tzeng</surname>
            <given-names>TK</given-names>
          </name>
        </person-group>
        <article-title>Exploring the viability of the Cell Broadband Engine for bioinformatics applications</article-title>
        <source>Proceedings of IEEE International Parallel and Distributed Processing Symposium, CA, USA</source>
        <year>2007</year>
        <fpage>1</fpage>
        <lpage>8</lpage>
      </citation>
    </ref>
    <ref id="B8">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
          <name>
            <surname>Gish</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>EW</given-names>
          </name>
          <name>
            <surname>Lipman</surname>
            <given-names>DJ</given-names>
          </name>
        </person-group>
        <article-title>Basic local alignment search tool</article-title>
        <source>J Mol Biol</source>
        <year>1990</year>
        <volume>215</volume>
        <fpage>403</fpage>
        <lpage>410</lpage>
        <pub-id pub-id-type="pmid">2231712</pub-id>
      </citation>
    </ref>
    <ref id="B9">
      <citation citation-type="other">
        <article-title>Timelogic SeqCruncherâ¢ PCIe accelerator card</article-title>
        <ext-link ext-link-type="uri" xlink:href="http://www.timelogic.com/seqcruncher.html"/>
      </citation>
    </ref>
    <ref id="B10">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Jacob</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Lancaster</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Buhler</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Chamberlain</surname>
            <given-names>RD</given-names>
          </name>
        </person-group>
        <article-title>FPGA-accelerated seed generation in Mercury BLASTP</article-title>
        <source>Proceedings of 15th Annual IEEE Symposium on Field-Programmable Custom Computing Machines</source>
        <year>2007</year>
        <fpage>95</fpage>
        <lpage>106</lpage>
      </citation>
    </ref>
    <ref id="B11">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lavenier</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Georges</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>X</given-names>
          </name>
        </person-group>
        <article-title>A reconfigurable index FLASH memory tailored to seed-based genomic sequence somparison algorithms</article-title>
        <source>VLSI Signal Processing</source>
        <year>2007</year>
        <volume>48</volume>
        <fpage>255</fpage>
        <lpage>269</lpage>
      </citation>
    </ref>
    <ref id="B12">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Fei</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Yong</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Jinbo</surname>
            <given-names>X</given-names>
          </name>
        </person-group>
        <article-title>FPGA-based accelerators for BLAST families with multi-seeds detection and parallel extension</article-title>
        <source>Proceedings of the 2nd International Conference in Bioinformatics and Biomedical Engineering</source>
        <year>2008</year>
        <fpage>58</fpage>
        <lpage>62</lpage>
      </citation>
    </ref>
    <ref id="B13">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Zhang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Schmidt</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Mueller-Wittig</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>Accelerating BLASTP on the Cell Broadband Engines</article-title>
        <source>Proceedings of Pattern Recognition in Bioinformatics, Third IAPR International Conference</source>
        <year>2008</year>
        <fpage>460</fpage>
        <lpage>470</lpage>
      </citation>
    </ref>
    <ref id="B14">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Roytberg</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Gambin</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Noe</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Lasota</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Furletova</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Szczurek</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Kucherov</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>On subset seeds for protein alignment</article-title>
        <source>IEEE/ACM Trans Comput Biol Bioinformatics</source>
        <year>2009</year>
        <volume>6</volume>
        <fpage>483</fpage>
        <lpage>494</lpage>
      </citation>
    </ref>
    <ref id="B15">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
          <name>
            <surname>Madden</surname>
            <given-names>TL</given-names>
          </name>
          <name>
            <surname>SchÃ¤ffer</surname>
            <given-names>AA</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Lipman</surname>
            <given-names>DJ</given-names>
          </name>
        </person-group>
        <article-title>Gapped BLAST and PSI-BLAST: a new generation of protein database search programs</article-title>
        <source>Nucleic Acids Research</source>
        <year>1997</year>
        <volume>25</volume>
        <fpage>3389</fpage>
        <lpage>3402</lpage>
        <pub-id pub-id-type="pmid">9254694</pub-id>
      </citation>
    </ref>
    <ref id="B16">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chao</surname>
            <given-names>KM</given-names>
          </name>
          <name>
            <surname>Pearson</surname>
            <given-names>WR</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>WC</given-names>
          </name>
        </person-group>
        <article-title>Aligning two sequences within a specified diagonal band</article-title>
        <source>Computer Applications in the Biosciences</source>
        <year>1992</year>
        <volume>8</volume>
        <fpage>481</fpage>
        <lpage>487</lpage>
        <pub-id pub-id-type="pmid">1422882</pub-id>
      </citation>
    </ref>
    <ref id="B17">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
          <name>
            <surname>Gish</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>Local alignment statistics</article-title>
        <source>Methods Enzymol</source>
        <year>1996</year>
        <volume>266</volume>
        <fpage>460</fpage>
        <lpage>480</lpage>
        <pub-id pub-id-type="pmid">8743700</pub-id>
      </citation>
    </ref>
    <ref id="B18">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Karlin</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
        </person-group>
        <article-title>Methods for assessing the statistical significance of molecular sequence features by using general scoring schemes</article-title>
        <source>Proc Natl Acad Sci USA</source>
        <year>1990</year>
        <volume>87</volume>
        <fpage>2264</fpage>
        <lpage>2268</lpage>
        <pub-id pub-id-type="pmid">2315319</pub-id>
      </citation>
    </ref>
    <ref id="B19">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Yu</surname>
            <given-names>YK</given-names>
          </name>
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
        </person-group>
        <article-title>The construction of amino acid substitution matrices for the comparison of proteins with non-standard compositions</article-title>
        <source>Bioinformatics</source>
        <year>2005</year>
        <volume>21</volume>
        <fpage>902</fpage>
        <lpage>911</lpage>
        <pub-id pub-id-type="pmid">15509610</pub-id>
      </citation>
    </ref>
    <ref id="B20">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Yu</surname>
            <given-names>YK</given-names>
          </name>
          <name>
            <surname>Gertz</surname>
            <given-names>EM</given-names>
          </name>
          <name>
            <surname>Agarwala</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Schaffer</surname>
            <given-names>AA</given-names>
          </name>
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
        </person-group>
        <article-title>Retrieval accuracy, statistical significance and compositional similarity in protein sequence database searches</article-title>
        <source>Nucleic Acids Research</source>
        <year>2006</year>
        <volume>34</volume>
        <fpage>5966</fpage>
        <lpage>5973</lpage>
        <pub-id pub-id-type="pmid">17068079</pub-id>
      </citation>
    </ref>
    <ref id="B21">
      <citation citation-type="other">
        <article-title>ASTRAL SCOP release 1.73</article-title>
        <ext-link ext-link-type="uri" xlink:href="http://astral.berkeley.edu/scopseq-1.73.html"/>
      </citation>
    </ref>
    <ref id="B22">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chandonia</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Hon</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Walker</surname>
            <given-names>NS</given-names>
          </name>
          <name>
            <surname>Conte</surname>
            <given-names>LL</given-names>
          </name>
          <name>
            <surname>Koehl</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Levitt</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Brenner</surname>
            <given-names>SE</given-names>
          </name>
        </person-group>
        <article-title>The ASTRAL compendium in 2004</article-title>
        <source>Nucleic Acids Research</source>
        <year>2004</year>
        <fpage>D189</fpage>
        <lpage>192</lpage>
        <pub-id pub-id-type="pmid">14681391</pub-id>
      </citation>
    </ref>
    <ref id="B23">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gertz</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Yu</surname>
            <given-names>YK</given-names>
          </name>
          <name>
            <surname>Agarwala</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Schaffer</surname>
            <given-names>AA</given-names>
          </name>
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
        </person-group>
        <article-title>Composition-based statistics and translated nucleotide searches: Improving the TBLASTN module of BLAST</article-title>
        <source>BMC Biology</source>
        <year>2006</year>
        <volume>4</volume>
        <fpage>41</fpage>
        <pub-id pub-id-type="pmid">17156431</pub-id>
      </citation>
    </ref>
    <ref id="B24">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Amdahl</surname>
            <given-names>GM</given-names>
          </name>
        </person-group>
        <article-title>Limits of Expectation</article-title>
        <source>International Journal of High Performance Computing Applications</source>
        <year>1988</year>
        <volume>2</volume>
        <fpage>88</fpage>
        <lpage>94</lpage>
      </citation>
    </ref>
    <ref id="B25">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Firasta</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Buxton</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Jinbo</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Nasri</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Kuo</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Intel<sup>Â® </sup>AVX: new frontiers in performance improvements and energy efficiency</article-title>
        <year>2008</year>
        <ext-link ext-link-type="uri" xlink:href="http://isdlibrary.intel-dispatch.com/isd/1563/AVX.pdf"/>
      </citation>
    </ref>
    <ref id="B26">
      <citation citation-type="other">
        <article-title>Larrabee microarchitecture</article-title>
        <ext-link ext-link-type="uri" xlink:href="http://www.intel.com/technology/visual/microarch.htm"/>
      </citation>
    </ref>
    <ref id="B27">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hu</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>FX</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>LS</given-names>
          </name>
        </person-group>
        <article-title>Microarchitecture of the Godson-2 processor</article-title>
        <source>J Comput SAstralAstralci &amp; Techno</source>
        <year>2005</year>
        <volume>20</volume>
        <fpage>243</fpage>
        <lpage>249</lpage>
      </citation>
    </ref>
  </ref-list>
</back>
