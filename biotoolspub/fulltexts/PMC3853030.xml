<?DTDIdentifier.IdentifierValue http://www.biomedcentral.com/xml/article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3853030</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-14-272</article-id>
    <article-id pub-id-type="pmid">24021088</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-14-272</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methodology Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Levenshtein error-correcting barcodes for multiplexed DNA sequencing</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes" id="A1">
        <name>
          <surname>Buschmann</surname>
          <given-names>Tilo</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>tilo.buschmann@tu-dresden.de</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Bystrykh</surname>
          <given-names>Leonid V</given-names>
        </name>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>L.Bystrykh@umcg.nl</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Institute for Medical Informatics and Biometry (IMB), Faculty of Medicine Carl Gustav Carus, Dresden University of Technology, Dresden, Germany</aff>
    <aff id="I2"><label>2</label>Laboratory of Ageing Biology and Stem Cells, European Research Institute for the Biology of Ageing, University Medical Center Groningen, University of Groningen, Groningen, The Netherlands</aff>
    <pub-date pub-type="collection">
      <year>2013</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>11</day>
      <month>9</month>
      <year>2013</year>
    </pub-date>
    <volume>14</volume>
    <fpage>272</fpage>
    <lpage>272</lpage>
    <history>
      <date date-type="received">
        <day>15</day>
        <month>2</month>
        <year>2013</year>
      </date>
      <date date-type="accepted">
        <day>30</day>
        <month>8</month>
        <year>2013</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2013 Buschmann and Bystrykh; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2013</copyright-year>
      <copyright-holder>Buschmann and Bystrykh; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1471-2105/14/272"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>High-throughput sequencing technologies are improving in quality, capacity and costs, providing versatile applications in DNA and RNA research. For small genomes or fraction of larger genomes, DNA samples can be mixed and loaded together on the same sequencing track. This so-called multiplexing approach relies on a specific DNA tag or barcode that is attached to the sequencing or amplification primer and hence appears at the beginning of the sequence in every read. After sequencing, each sample read is identified on the basis of the respective barcode sequence.</p>
        <p>Alterations of DNA barcodes during synthesis, primer ligation, DNA amplification, or sequencing may lead to incorrect sample identification unless the error is revealed and corrected. This can be accomplished by implementing error correcting algorithms and codes. This barcoding strategy increases the total number of correctly identified samples, thus improving overall sequencing efficiency. Two popular sets of error-correcting codes are Hamming codes and Levenshtein codes.</p>
      </sec>
      <sec>
        <title>Result</title>
        <p>Levenshtein codes operate only on words of known length. Since a DNA sequence with an embedded barcode is essentially one continuous long word, application of the classical Levenshtein algorithm is problematic. In this paper we demonstrate the decreased error correction capability of Levenshtein codes in a DNA context and suggest an adaptation of Levenshtein codes that is proven of efficiently correcting nucleotide errors in DNA sequences. In our adaption we take the DNA context into account and redefine the word length whenever an insertion or deletion is revealed. In simulations we show the superior error correction capability of the new method compared to traditional Levenshtein and Hamming based codes in the presence of multiple errors.</p>
      </sec>
      <sec>
        <title>Conclusion</title>
        <p>We present an adaptation of Levenshtein codes to DNA contexts capable of correction of a pre-defined number of insertion, deletion, and substitution mutations. Our improved method is additionally capable of recovering the new length of the corrupted codeword and of correcting on average more random mutations than traditional Levenshtein or Hamming codes.</p>
        <p>As part of this work we prepared software for the flexible generation of DNA codes based on our new approach. To adapt codes to specific experimental conditions, the user can customize sequence filtering, the number of correctable mutations and barcode length for highest performance.</p>
      </sec>
    </abstract>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>High-throughput sequencing is an increasingly popular technique due to steadily improving sequencing capacity and decreasing costs. Since modern machines are (at the time of writing this manuscript) capable of generating up to 8 ∗ 10<sup>9</sup> base pairs (8 Gbp) total read length in one lane, it might exceed required capacity for many research protocols focused on smaller scale sequencing applications, for instance those focused on selective DNA sampling for SNP analysis [<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B2">2</xref>], miRNA expression profiling [<xref ref-type="bibr" rid="B3">3</xref>], cellular barcoding [<xref ref-type="bibr" rid="B4">4</xref>], profiling repeated elements [<xref ref-type="bibr" rid="B5">5</xref>] and retroviral vector integration sites in the genome [<xref ref-type="bibr" rid="B6">6</xref>], as well as complete sequencing of microbial [<xref ref-type="bibr" rid="B7">7</xref>] and other small genomes [<xref ref-type="bibr" rid="B8">8</xref>].</p>
    <p>In such cases many samples are combined in a single batch and sequenced as one sample. Using this multiplexed format, specific sample tags, also called barcodes, are added to the amplification or sequencing primer to discriminate all sub-samples in the mixture. After sequencing, reads can be identified by reading barcodes, allowing the sorting and separating of all sequence reads into original samples. The protocol is efficient as long as barcodes can be read robustly [<xref ref-type="bibr" rid="B9">9</xref>].</p>
    <p>It is known, however, that multiple errors can occur with DNA sequencing due to defects in primer synthesis, the ligation process, sample pre-amplification, and finally sequencing. These errors can be either nucleotide substitutions or small insertions and deletions [<xref ref-type="bibr" rid="B10">10</xref>]. In addition to common sources of error, some sequencing platforms show elevated error rates in specific situations, such as indels of identical bases in Roche 454 Pyrosequencing [<xref ref-type="bibr" rid="B11">11</xref>] or random indels in PacBio sequencing technology [<xref ref-type="bibr" rid="B12">12</xref>]. Although any randomly picked synthetic nucleotide sequence can be used as a barcode, this approach is problematic because all basic parameters of the corresponding oligonucleotide, namely minimal distance, GC content, sequence redundancy etc. cannot be properly controlled [<xref ref-type="bibr" rid="B13">13</xref>].</p>
    <p>In recent years several papers were published attempting to utilize general coding theory of binary error-correcting codes. The major advantage of those codes over “naive” tags is the possibility to detect and correct a limited number of errors. In addition they also ensure a constant minimal distance. Other parameters, such as GC content and sequence redundancy, are generally more uniform in error-correcting codes than in randomly generated tags.</p>
    <p>Probably the first attempt to create a systematic error-correcting code for DNA barcodes was made by Hamady et al. [<xref ref-type="bibr" rid="B7">7</xref>], based on the original Hamming binary code [<xref ref-type="bibr" rid="B14">14</xref>,<xref ref-type="bibr" rid="B15">15</xref>]. The authors adapted Hamming codes for a DNA context by representing each DNA base by two consecutive binary digits. Although being popular for a while, this barcode was later found to be flawed [<xref ref-type="bibr" rid="B13">13</xref>,<xref ref-type="bibr" rid="B16">16</xref>]: in a proposed configuration one third of all single errors occurring at the DNA level caused 2 bit changes (2 errors) in the code. By definition those 2 bit errors could not be corrected. As an alternative, Krishnan et al. proposed to use binary, linear error-correcting codes for DNA barcoding applications [<xref ref-type="bibr" rid="B16">16</xref>]. Those codes provide larger minimal distance and better error-correcting capacity. This allowed correction of DNA errors even if there were 2-bit errors in the code. Recently one of us proposed to adapt Hamming binary code to the DNA quaternary metric, thus preserving minimal distance and capability to correct single errors on the DNA level [<xref ref-type="bibr" rid="B13">13</xref>]. Both applications [<xref ref-type="bibr" rid="B13">13</xref>,<xref ref-type="bibr" rid="B16">16</xref>], however, were dedicated to the linear perfect codes capable of correcting nucleotide substitutions only. As indicated above, insertions and deletions (indels) might be a persistent problem for at least some sequencing platforms. Therefore it is very important to design a code resistant to this type of error as well. In this manuscript we provide a code, which we call the Sequence-Levenshtein code, capable of correcting all types of errors, including insertions and deletions. This code largely follows ideas from the Levenshtein code [<xref ref-type="bibr" rid="B17">17</xref>]. Unlike previous attempts at adapting Levenshtein [<xref ref-type="bibr" rid="B18">18</xref>], it is specifically designed for the DNA context. As a consequence it shows significant improvements in recovering errors in DNA sequence compared to other codes of the same kind.</p>
  </sec>
  <sec sec-type="methods">
    <title>Method</title>
    <sec>
      <title>Barcode preparation</title>
      <p>Barcodes were constructed as DNA sequences of fixed length <italic>n</italic> from the 4 different bases. Here, we encoded DNA bases A, C, G, T as numbers 0, 1, 2, and 3 in a quaternary alphabet and therefore avoided the binary-quaternary conversions used by others [<xref ref-type="bibr" rid="B7">7</xref>,<xref ref-type="bibr" rid="B16">16</xref>]. The number of all possible combinations, and therefore the size of the maximum barcode set was 4<sup><italic>n</italic></sup>, e.g. an unfiltered 8-mer barcode set could have been used for 4<sup>8</sup> = 65536 unique samples. For the calculation of maximal set sizes of barcodes of length <italic>n</italic>, we initially generated the full set of all possible barcodes with our custom software written in Java. This initial barcode set was then filtered to exclude barcodes with GC-content of less than 40% or more than 60%, perfect self-complementation, or more than two sequential repetitions of the same base.</p>
    </sec>
    <sec>
      <title>Error-correcting codes</title>
      <p>Error-correcting DNA barcode sets were constructed using only a subset of the 4<sup><italic>n</italic></sup> maximal combinations, while carefully meeting some specific error-correcting properties. Commonly, this subset is called <italic>code</italic> and the individual barcodes in the set are called <italic>codewords</italic>.</p>
      <p>A very popular code for the correction of substitution errors is based on the idea of <italic>linear codes</italic> (e.g. Hamming codes [<xref ref-type="bibr" rid="B14">14</xref>,<xref ref-type="bibr" rid="B15">15</xref>] or Reed-Solomon codes [<xref ref-type="bibr" rid="B19">19</xref>]). This type of code consists only of codewords that differ in at least three positions from each other (called the <italic>Minimum Hamming Distance</italic>, denoted as <inline-formula><mml:math id="M1" name="1471-2105-14-272-i1" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup></mml:math></inline-formula>). Figures <xref ref-type="fig" rid="F1">1</xref>(A-C) depict the Hamming distance and its application in DNA context.</p>
      <fig id="F1" position="float">
        <label>Figure 1</label>
        <caption>
          <p><bold>Barcode correction using Hamming and Levenshtein distances. </bold><bold>(A)</bold> Hamming distance between two example codewords. <bold>(B)</bold> Example linear code of four codewords with the minimal Hamming distance <inline-formula><mml:math id="M2" name="1471-2105-14-272-i2" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula>. <bold>(C)</bold> A mutation is corrected on the basis of the minimal distance between barcodes and mutated sequence. <bold>(D,E,F)</bold> The same for Levenshtein distance and an example Levenshtein code with the minimum Levenshtein distance <inline-formula><mml:math id="M3" name="1471-2105-14-272-i3" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula>.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-272-1"/>
      </fig>
      <p>Figure <xref ref-type="fig" rid="F1">1</xref>(B) gives an example of a linear code that has a minimal Hamming distance of 3 and corrects 1 substitution error. A substitution error and its correction is shown in Figure <xref ref-type="fig" rid="F1">1</xref>(C): The barcode “ACT” mutates at position 3 and the base “T” became substituted with the base “G”. The Hamming distance to the original barcode “ACT” is 1, while it is greater for all other barcodes of this linear code. Therefore correct decoding and identification of the original barcode is possible. In general, more substitution errors can be corrected by constructing codes with a larger minimal distance between codewords. To correct <italic>k</italic> errors, the minimum Hamming distance <inline-formula><mml:math id="M4" name="1471-2105-14-272-i4" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup></mml:math></inline-formula> of the codewords needs to be at least 2 ∗ <italic>k</italic> + 1.</p>
      <p>As in the case of linear codes, Levenshtein-based codes guarantee a specific minimum distance <inline-formula><mml:math id="M5" name="1471-2105-14-272-i5" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup></mml:math></inline-formula> between any codewords [<xref ref-type="bibr" rid="B17">17</xref>]. The difference is in the distance definition: Levenshtein based codes also include insertions and deletions that need to occur to transform one word to another word, as depicted in Figure <xref ref-type="fig" rid="F1">1</xref>(D). Levenshtein-based codes consisting of codewords with a minimum Levenshtein distance <inline-formula><mml:math id="M6" name="1471-2105-14-272-i6" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>&gt;</mml:mo><mml:mn>2</mml:mn><mml:mo>∗</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula> can correct <italic>k</italic> insertions, deletions, and substitutions. Figure <xref ref-type="fig" rid="F1">1</xref>(E) depicts an example code with <inline-formula><mml:math id="M7" name="1471-2105-14-272-i7" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula> that corrects 1 insertion, deletion, or substitution error when not in context of other DNA. Figure <xref ref-type="fig" rid="F1">1</xref>(F) shows such a correction: The last base of barcode “GCG” becomes deleted and is read as “GC”. The Levenshtein distance to the original barcode “GCG” is 1, while it is greater for all other barcodes of this Levenshtein code. Therefore correct decoding and identification of the original barcode is possible.</p>
      <p>For the purpose of this paper, the <italic>error-correction capability</italic> of a code is the number and types of errors that a code (per design) guarantees to correct in a specific scenario. The actual error-correction capabilities in realistic scenarios (e.g. biological experiments, PCR and sequencing data) will be studied separately.</p>
    </sec>
    <sec>
      <title>Sequence-Levenshtein distance</title>
      <p>We adapted the Levenshtein distances in such a way that the DNA context is taken into account and the length of the new mutated barcode in the sequence read is correctly identified. In the worst case, any barcode embedded in the sequence read will be surrounded by the sample sequence such that it decreases its distance to other sequences in the set.</p>
      <p>The Sequence-Levenshtein distance between two arbitrary words A and B is the minimum number of the following three operations: </p>
      <p>• Substitutions</p>
      <p>• Deletions</p>
      <p>• Insertions</p>
      <p>which results in word <inline-formula><mml:math id="M8" name="1471-2105-14-272-i8" overflow="scroll"><mml:mi>Ā</mml:mi></mml:math></inline-formula>, finalized by applying one of the following operations exactly once: </p>
      <p>• Truncating <inline-formula><mml:math id="M9" name="1471-2105-14-272-i9" overflow="scroll"><mml:mi>Ā</mml:mi></mml:math></inline-formula> to match the length of B</p>
      <p>• Elongating <inline-formula><mml:math id="M10" name="1471-2105-14-272-i10" overflow="scroll"><mml:mi>Ā</mml:mi></mml:math></inline-formula> to match the length and bases of B</p>
      <p>The latter two operations do not increase the distance between A and B. It follows, that the distance between A and B is 0 if A is a prefix of B (and vice versa). For the purpose of this distance metric, we define in this case A to be equal to B.</p>
    </sec>
    <sec>
      <title>Barcode computation</title>
      <p>There is no systematic calculation rule for the classic Levenshtein code and codes based on our Sequence-Levenshtein distance. A generation of distance-based codes by an exhaustive search of the set of all possible subsets has two computational bottlenecks that have to be addressed: Firstly, the number of all subsets grows exponential with the length of the codewords and therefore the enumeration of these subsets is prohibitively inefficient. Secondly the distance between any two codewords has to be calculated at least once, making <inline-formula><mml:math id="M11" name="1471-2105-14-272-i11" overflow="scroll"><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> calculations necessary. Distances need to be calculated repeatedly if the complete distance matrix cannot be held in memory.</p>
      <p>We therefore generated codes heuristically with a so-called <italic>greedy closure evolutionary</italic> algorithm first described for this application by Ashlock et al. [<xref ref-type="bibr" rid="B20">20</xref>,<xref ref-type="bibr" rid="B21">21</xref>]. Here, we initialized our code set with a small number (2-4) of random barcodes that fulfill the distance requirement (the so-called <italic>seed</italic>). We then walked through all eligible barcodes in lexicographical order and added the tested barcode to the code set if its distance was at least 2 ∗ <italic>k</italic> + 1 to every other barcode that was already in the code set. Using an evolutionary approach (in the computational sense), we tried a large number of different seeds or altered very successful seeds to find the seed giving the best, i.e. largest code set. Among other heuristic algorithms for the generation of classic Levenshtein codes, this particular method has shown the best results (Houghten <italic>et al</italic>[<xref ref-type="bibr" rid="B22">22</xref>]). The same study revealed that this method yielded nearly-optimal solutions for short codewords (<italic>n</italic> ≤ 5) and it reached approximately one third to one half of the upper limit of code sizes for longer codewords (5 &lt; <italic>n</italic> ≤ 12) [<xref ref-type="bibr" rid="B22">22</xref>,<xref ref-type="bibr" rid="B23">23</xref>].</p>
      <p>We also optimized the calculation of the Sequence-Levenshtein distance. We adapted the dynamic programming approach to the classical Levenshtein distance [<xref ref-type="bibr" rid="B24">24</xref>] and reached approximately the same performance (see Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>: Supplement). Additionally, we minimized the number of operations with the approach developed by Allison (<italic>Lazy Programming</italic>, [<xref ref-type="bibr" rid="B25">25</xref>]).</p>
    </sec>
    <sec>
      <title>Simulations</title>
      <p>We simulated three scenarios both with classical Levenshtein codes and modified Sequence-Levenshtein codes: </p>
      <p>• In <italic>Simulation 1</italic> the application of classical Levenshtein codes in DNA context was assessed. A large number of barcodes of the same length was generated at random, followed by a random sample sequence. Every barcode was mutated with a single random in/del/sub error and then attempted to be decoded. As the length of the received codeword was unknown, the codeword of equal length to the generated DNA barcodes was used. If decoding did not work (i.e. there was no DNA barcode with a distance of 1 to the received codeword), codewords of the length <italic>n</italic> - 1 and <italic>n</italic> + 1 were tried. If ambiguities still existed, we decided randomly.</p>
      <p>• In <italic>Simulation 2</italic> the error correction capabilities of Sequence-Levenshtein codes were tested. Every code used in this manuscript was included, up to a length of 12nt for 1 and 2 correctable errors. We iterated through every possible error (1 error, respectively 2 errors; insertions, substitutions, and deletions) and decoded the resulting DNA barcode.</p>
      <p>• In an experimental setup, more than one error might occur. Therefore, in <italic>Simulation 3</italic> a large number of classic Levenshtein and new Sequence-Levenshtein barcodes was simulated, where every base had a chance <italic>p</italic> of being mutated with equal likelihood for substitutions, insertions and deletions. Every base was equally likely to be inserted.</p>
    </sec>
  </sec>
  <sec sec-type="results">
    <title>Results</title>
    <sec>
      <title>Classic Levenshtein codes fail in DNA context</title>
      <p>Levenshtein-based codes have one mandatory condition: The length of the codewords and the received words need to be known. While we know the length of the DNA barcodes because we construct them ourselves, the length of the received codeword is not available as the barcode is embedded into the DNA sequence. If the DNA barcode is shortened during processing, the first base of the sample DNA sequence takes the place of the last base of the DNA barcode. If the DNA barcode is elongated, the last base of the DNA barcode now becomes the first base of the sample DNA sequence. There is no inherent separation between DNA barcode and sample sequence to detect this change in length and thus traditional Levenshtein correction fails. To show this, we construct two codewords <italic>c</italic><sub><italic>A</italic></sub> and <italic>c</italic><sub><italic>B</italic></sub> whose Levenshtein distance is 3 but is reduced by the inference of the remaining sample DNA sequence.</p>
      <p>We construct the codewords <italic>c</italic><sub><italic>A</italic></sub> = “CAGG” and <italic>c</italic><sub><italic>B</italic></sub> = “CGTC” with a Levenshtein-distance <italic>d</italic><sub><italic>L</italic></sub> (<italic>c</italic><sub><italic>A</italic></sub>,<italic>c</italic><sub><italic>B</italic></sub>) = 3. In an exemplary biological experiment, <italic>c</italic><sub><italic>A</italic></sub> could be used as a barcode and within it could be followed by “CA” so that the whole DNA sequence reads “CAGG|CA...”. If the base “A” at the second position of <italic>c</italic><sub><italic>A</italic></sub> becomes deleted, the base “C” (previously on position 5) would succeed the base at position 4 so that the sequenced DNA <italic>c</italic><sub>received</sub> now would read: “CGGC|A...” (Figure <xref ref-type="fig" rid="F2">2</xref>). Because the deletion would remain undetected, we could try to find a correction for <italic>c</italic><sub>received</sub> = CGGC. Consequently, the codeword <italic>c</italic><sub><italic>B</italic></sub> is actually closer to the manipulated received sequence (<italic>d</italic><sub><italic>L</italic></sub>(<italic>c</italic><sub><italic>B</italic></sub>,<italic>c</italic><sub>received</sub>) = 1) than codeword <italic>c</italic><sub><italic>A</italic></sub> (<italic>d</italic><sub><italic>L</italic></sub> (<italic>c</italic><sub><italic>A</italic></sub>,<italic>c</italic><sub>received</sub>) = 2) and there is no possibility to find the actual chain of mutations because the only criteria in correcting errors is the minimal distance. Trying to guess the real length of the corrupted barcode gives ambiguous results as Table <xref ref-type="table" rid="T1">1</xref> shows.</p>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p><bold>Deficiency of Levenshtein Codes in DNA context.</bold> Classical Levenshtein-based codes fail in DNA context as the word boundary is not decodable. Here, the original barcode “CAGG” becomes corrupted through a deletion. The new barcode “CGGC” is now closer to the wrong barcode “CGTC” on the left as opposed to the original barcode “CAGG” on the right.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-272-2"/>
      </fig>
      <table-wrap position="float" id="T1">
        <label>Table 1</label>
        <caption>
          <p>Distances of the received codeword at various presumed word lengths</p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col align="left"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th align="center" valign="bottom">
                <bold>Presumed</bold>
                <hr/>
              </th>
              <th align="center" valign="bottom">
                <bold>Presumed</bold>
                <hr/>
              </th>
              <th colspan="2" align="center" valign="bottom">
                <bold>Candidate</bold>
                <hr/>
              </th>
            </tr>
            <tr>
              <th align="center">
                <bold>word length</bold>
              </th>
              <th align="center">
                <bold>word boundary</bold>
              </th>
              <th colspan="2" align="center">
                <bold>barcodes</bold>
              </th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">
                <bold>“CAGG”</bold>
                <hr/>
              </td>
              <td align="center" valign="bottom">
                <bold>“CGTC”</bold>
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center" valign="bottom">3<hr/></td>
              <td align="center" valign="bottom">“CGG|CA”<hr/></td>
              <td align="center" valign="bottom">1<hr/></td>
              <td align="center" valign="bottom">2<hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">4<hr/></td>
              <td align="center" valign="bottom">“CGGC|A”<hr/></td>
              <td align="center" valign="bottom">2<hr/></td>
              <td align="center" valign="bottom">1<hr/></td>
            </tr>
            <tr>
              <td align="center">5</td>
              <td align="center">“CGGCA|”</td>
              <td align="center">3</td>
              <td align="center">2</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>We compare two candidate barcodes “CAGG” and “CGTC” with different presumed word lengths and boundaries. Levenshtein distances for word boundaries presumed at 3 and 4 conflict and an unambiguous identification of the original used barcode is not possible.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>We generalized this problem in Simulation 1 (Figure <xref ref-type="fig" rid="F3">3</xref>): Barcodes based on classical Levenshtein codes with a minimal distance <inline-formula><mml:math id="M12" name="1471-2105-14-272-i12" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula> failed to correct indel errors on average in 26% of the cases (see Methods for details). This error level is very close to <inline-formula><mml:math id="M13" name="1471-2105-14-272-i13" overflow="scroll"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:math></inline-formula>, the probability of the adverse base to be inserted or the adverse base to be added to the barcode after a deletion. Accordingly, classical Levenshtein-based codes correctly decoded barcodes that were corrupted once if the codes have the guaranteed capability to correct two errors, but failed on average in 6.5% of two-corruption cases. This error level is explained by the probability of inserting or complementing the two random worst-case bases, which is <inline-formula><mml:math id="M14" name="1471-2105-14-272-i14" overflow="scroll"><mml:msup><mml:mrow><mml:mfenced open="(" close=")"><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>16</mml:mn></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mn>0.0625</mml:mn></mml:math></inline-formula>.</p>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p><bold>Simulation of Levenshtein Codes in DNA context.</bold> Levenshtein codes with a minimal distance <inline-formula><mml:math id="M15" name="1471-2105-14-272-i15" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula> failed to correct indel errors on average in 26% of the cases while Levenshtein codes with a minimal distance <inline-formula><mml:math id="M16" name="1471-2105-14-272-i16" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:math></inline-formula> always corrected one indel error but failed to decode two indel errors in about 6.5% of the cases.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-272-3"/>
      </fig>
      <p>Clarke and Ferreira previously showed that Levenshtein codes with a minimal distance <inline-formula><mml:math id="M17" name="1471-2105-14-272-i17" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:math></inline-formula> can robustly correct at least one error in a context scenario with fixed-length decoding as applied here [<xref ref-type="bibr" rid="B26">26</xref>]. Henceforth, we will delineate the <italic>guaranteed minimal error-correction capability</italic> of Levenshtein codes specifically in DNA context under this assumption, so that Levenshtein codes with <inline-formula><mml:math id="M18" name="1471-2105-14-272-i18" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:math></inline-formula> guarantee to correct at least one error, those with a minimal distance <inline-formula><mml:math id="M19" name="1471-2105-14-272-i19" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>9</mml:mn></mml:math></inline-formula> guarantee to correct at least two errors in DNA context.</p>
    </sec>
    <sec>
      <title>Sequence-Levenshtein distance</title>
      <p>With the adapted Sequence-Levenshtein metric, the distance between the previously considered codewords “CAGG” and “CGTC” is now <italic>d</italic><sub><italic>SL</italic></sub> (“CAGG”,“CGTC”) = 2: Delete second base “A” of “CAGG” to get “CGG” and substitute third base “G” with “T” to get “CGT”. In the worst case the remaining sample sequence will start with base “C”, so that if we elongate with “C” then get “CGTC”. Therefore, “CAGG” and “CGTC” cannot be part of the same error correcting code.</p>
      <p>The formal definition of our Sequence-Levenshtein metric allowed us to prove that it is indeed a “distance metric” (see Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>: Supplement), so that codes based on this distance can correct <italic>k</italic> substitutions and indels in DNA context if their minimum distance is at least <inline-formula><mml:math id="M20" name="1471-2105-14-272-i20" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">SL</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>∗</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>Sequence-Levenshtein code example and decoding</title>
      <p>An example of a Sequence-Levenshtein code with 4 bases for the correction of 1 error yielded 4 barcodes: “TTCC”, “ACAC”, “CGAA”, and “TAGG”. Suppose, we use “TTCC” as the barcode and the base “T” at the second position becomes deleted during sequencing. In our example, exemplary sample reads have the length <italic>m</italic> = 10 and the sequence read is “TCC|ATGCATA” ( <xref ref-type="fig" rid="F4">4</xref>). To decode this example, we calculate the distance between the word “TCCATGCATA” and the words “TTCC”, “ACAC”, “CGAA”, and “TAGG” with the results in Table <xref ref-type="table" rid="T2">2</xref>. The column “operations” is the listing of the possible operations that corrupted the barcode.</p>
      <fig id="F4" position="float">
        <label>Figure 4</label>
        <caption>
          <p>Operations in Sequence-Levenshtein distance.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-272-4"/>
      </fig>
      <table-wrap position="float" id="T2">
        <label>Table 2</label>
        <caption>
          <p>Example decoding results</p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col align="left"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th align="left">
                <bold>Candidate barcode</bold>
              </th>
              <th align="left">
                <bold>Distance to “TCCATGCATA”</bold>
              </th>
              <th align="center">
                <bold>Possible chain of operations</bold>
              </th>
              <th align="center">
                <bold>Resulting word boundary</bold>
              </th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="left" valign="bottom">“TTCC”<hr/></td>
              <td align="left" valign="bottom">1<hr/></td>
              <td align="center" valign="bottom">del(2),elong(“ATGCATA”)<hr/></td>
              <td align="center" valign="bottom">3 (“TCC|ATGCATA”)<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">“ACAC”<hr/></td>
              <td align="left" valign="bottom">2<hr/></td>
              <td align="center" valign="bottom">sub(“T”,1),del(3),elong(“ATGCATA”)<hr/></td>
              <td align="center" valign="bottom">3 (“TCC|ATGCATA”)<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">“CGAA”<hr/></td>
              <td align="left" valign="bottom">3<hr/></td>
              <td align="center" valign="bottom">ins(“T”,1),sub(“C”,3),del(5),elong(“TGCATA”)<hr/></td>
              <td align="center" valign="bottom">4 (“TCCA|TGCATA”)<hr/></td>
            </tr>
            <tr>
              <td align="left">“TAGG”</td>
              <td align="left">3</td>
              <td align="center">sub(“C”,2),sub(“C”,3),sub(“A”,4),elong(“TGCATA”)</td>
              <td align="center">4 (“TCCA|TGCATA”)</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Table shows the results of decoding the example sequence read “TCCATGCATA” for four different candidate barcodes “TTCC”, “ACAC”, “CGAA”, and “TAGG”. The real original barcode “TTCC” has the shortest Sequence-Levenshtein distance to this sequence read and the word boundary is estimated correctly at 3.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>It is apparent that the difference between the number of insertion and deletion operations is the difference between the barcode length and the starting part of the sample sequence, which allowed the identification of the starting position of the sample sequence, as shown in column four of Table <xref ref-type="table" rid="T2">2</xref>.</p>
    </sec>
    <sec>
      <title>Sequence-Levenshtein codes useful for DNA applications</title>
      <p>We calculated and verified a number of Sequence-Levenshtein codes for different sequence lengths and compared them to codes with higher Levenshtein distance that were designed for the correction of at least this particular number of errors (the <italic>guaranteed error correction capability</italic> in DNA context). Figure <xref ref-type="fig" rid="F5">5</xref> depicts the number of DNA barcodes that we generated for the correction of at least 1 or 2 insertion, deletion, and substitution errors with our Sequence-Levenshtein distance and with the classic Levenshtein distance. For comparison purposes, we also added the number of barcodes of the classical Levenshtein code with a distance <inline-formula><mml:math id="M21" name="1471-2105-14-272-i21" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula> that does not guarantee to correct at least one error reliably in DNA context.</p>
      <fig id="F5" position="float">
        <label>Figure 5</label>
        <caption>
          <p><bold>Number of Barcodes vs Barcode Length.</bold> Barcodes based on the Sequence-Levenshtein distance resulted in barcodes with a magnitude higher numbers then Levenshtein barcodes for the same length of the barcode and the same guaranteed minimal error correction capability. The guaranteed correction of one additional error shrunk the number of barcodes by almost two magnitudes.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-272-5"/>
      </fig>
      <p>For codewords of length 8nt, 4<sup>8</sup> = 65536 possible combinations of DNA bases can be generated. Of those, 14600 met the required chemical properties as described in the Methods section. Finally, with the Sequence-Levenshtein distance a maximum barcode set of 188 elements for the correction of one error in DNA context could be generated. This is equivalent to a code rate of <inline-formula><mml:math id="M22" name="1471-2105-14-272-i22" overflow="scroll"><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mtext mathvariant="italic">log</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mn>188</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext mathvariant="italic">log</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mn>65536</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mfrac><mml:mo>≈</mml:mo><mml:mn>0.472</mml:mn></mml:math></inline-formula>. For classical Levenshtein codes, we could generate 552 barcodes, the equivalent of a code rate of <inline-formula><mml:math id="M23" name="1471-2105-14-272-i23" overflow="scroll"><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mtext mathvariant="italic">log</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mn>552</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext mathvariant="italic">log</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mn>65536</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mfrac><mml:mo>≈</mml:mo><mml:mn>0.569</mml:mn></mml:math></inline-formula>. We found that the code rate increased with barcode length for both Levenshtein and Sequence-Levenshtein based codes (see Additional <xref ref-type="supplementary-material" rid="S1">1</xref>: Figure S1).</p>
      <p>Figure <xref ref-type="fig" rid="F5">5</xref> shows that our modified Sequence-Levenshtein codes scaled up to more than 20,000 possible barcodes with one guaranteed correctable error. This would satisfy the needs of the most complex sample multiplexing setups. Alternatively, for a medium-sized experiment of only 48 samples, the length of the barcode did not need to exceed 7 bases (77 barcodes). Conversely, we could increase the robustness of the code to 2 correctable errors and generate 90 11-nt-long barcodes. Compared to classic Levenshtein codes, we produced one order of magnitude more barcodes for the same length and guaranteed minimal number of correctable errors.</p>
    </sec>
    <sec>
      <title>Simulation for correctness and the decoding rate</title>
      <p>In Simulation 2, we simulated all possible 1 or 2 mutations for every Sequence-Levenshtein barcode used in this manuscript up to a length of 12 with the guaranteed capability to correct 1 or 2 errors and found that the original barcode could be decoded correctly in every case.</p>
      <p>We also used this simulation to measure the speed of decoding random sequence reads with our unoptimized Java-based prototype implementation. As a general result, the number of decoded sequence reads per seconds depended on three parameters: </p>
      <p>• Length of the sequence read: longer was slower</p>
      <p>• Length of barcodes: longer was slower</p>
      <p>• Number of used barcodes: more barcodes were slower</p>
      <p>In the slowest simulation with 20,894 12-nt-long barcodes and 14-nt-long sequence reads, we decoded 20 sequence reads per second while we decoded approximately 190,000 sequence reads per second with four 4-nt-long barcodes.</p>
    </sec>
    <sec>
      <title>Experimental simulation</title>
      <p>In Simulation 3, we analyzed the behavior and limits of Sequence-Levenshtein codes under the assumption that multiple mutations of barcodes are possible. The results are depicted in Figure <xref ref-type="fig" rid="F6">6</xref>. The theoretical expected average number of mutations <italic>μ</italic><sub><italic>M</italic></sub> for each barcode of length <italic>n</italic> and per-base mutation probability <italic>p</italic> was <italic>μ</italic><sub><italic>M</italic></sub> = <italic>p</italic> ∗ <italic>n</italic>, which we also confirmed on average in all simulation runs. As a consequence, the number of mutations in a barcode of a sequence read increased linearly with the length of the barcode, leading to a higher number of mismatches during the decoding phase (Figure <xref ref-type="fig" rid="F6">6</xref>(A)).</p>
      <fig id="F6" position="float">
        <label>Figure 6</label>
        <caption>
          <p><bold>Results of Simulation 3. </bold><bold>(A)</bold> Number of correct matches after decoding depending on base mutation probability rate <italic>p</italic> for different error correction codes and barcode lengths. <bold>(B)</bold> Number correct matches after decoding depending on base mutation probability rate <italic>p</italic> for the fixed number of 48 barcodes simulated with the smallest eligible error correction codes: Levenshtein code with <inline-formula><mml:math id="M24" name="1471-2105-14-272-i24" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula>, length 6; Sequence-Levenshtein code with <inline-formula><mml:math id="M25" name="1471-2105-14-272-i25" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">SL</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula>, length 7; Levenshtein code with minimum distance <inline-formula><mml:math id="M26" name="1471-2105-14-272-i26" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:math></inline-formula>, length 9; Sequence-Levenshtein code with minimum distance <inline-formula><mml:math id="M27" name="1471-2105-14-272-i27" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">SL</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:math></inline-formula>, length 11.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-272-6"/>
      </fig>
      <p>Sequence-Levenshtein codes have been decoded correctly at a better rate than classical Levenshtein codes of the same barcode length and the same minimal distance (<inline-formula><mml:math id="M28" name="1471-2105-14-272-i28" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">SL</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula> and <inline-formula><mml:math id="M29" name="1471-2105-14-272-i29" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">SL</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:math></inline-formula> respectively). Furthermore, both classical Levenshtein codes and Sequence-Levenshtein codes with a higher minimal distance (<inline-formula><mml:math id="M30" name="1471-2105-14-272-i30" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">SL</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:math></inline-formula> and <inline-formula><mml:math id="M31" name="1471-2105-14-272-i31" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:math></inline-formula>) decoded barcodes correctly more often than the same codes with a smaller minimal distance (<inline-formula><mml:math id="M32" name="1471-2105-14-272-i32" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">SL</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula> and <inline-formula><mml:math id="M33" name="1471-2105-14-272-i33" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula>). Notably, although Sequence-Levenshtein codes with <inline-formula><mml:math id="M34" name="1471-2105-14-272-i34" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">SL</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula> were designed for the same guaranteed minimal number of correctable errors in DNA context as classic Levenshtein codes with <inline-formula><mml:math id="M35" name="1471-2105-14-272-i35" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:math></inline-formula>, the latter outperformed the former when a random number of mutations was considered. All these effects were more pronounced for median base mutation probabilities <italic>p</italic> ∈ [ 0.2,0.8].</p>
      <p>In practice, the choice of the barcode length and the type of error correction (<inline-formula><mml:math id="M36" name="1471-2105-14-272-i36" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">SL</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula> or <inline-formula><mml:math id="M37" name="1471-2105-14-272-i37" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">SL</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:math></inline-formula>) is based on the number of samples that one wants to sequence in parallel. We therefore repeated simulation 3 on 48 barcodes from six different error correcting codes that supported this number of parallel samples: a classic Levenshtein code with <inline-formula><mml:math id="M38" name="1471-2105-14-272-i38" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula> and length 6; a classic Levenshtein code with <inline-formula><mml:math id="M39" name="1471-2105-14-272-i39" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:math></inline-formula> and length 9; a Sequence-Levenshtein code with <inline-formula><mml:math id="M40" name="1471-2105-14-272-i40" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">SL</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula> and length 7; a Sequence-Levenshtein code with minimum distance <inline-formula><mml:math id="M41" name="1471-2105-14-272-i41" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">SL</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:math></inline-formula> and length 11, a linear code of length 5, and finally a code of length 3 that offered no correction (see Additional  <xref ref-type="supplementary-material" rid="S1">1</xref>: Table S2 for details). The result is depicted in Figure <xref ref-type="fig" rid="F6">6</xref>(B). It shows that the new Sequence-Levenshtein codes outperformed classical Levenshtein codes of the equivalent minimal distances as well as the linear code despite requiring longer barcodes. The same was true for the comparison of Sequence-Levenshtein codes with minimal distances <inline-formula><mml:math id="M42" name="1471-2105-14-272-i42" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">SL</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:math></inline-formula> and <inline-formula><mml:math id="M43" name="1471-2105-14-272-i43" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">SL</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula>. Apparently, in this case the added robustness of larger distances and the change to the classical Levenshtein distance outweighed the drawbacks of longer barcodes.</p>
    </sec>
  </sec>
  <sec sec-type="discussion">
    <title>Discussion</title>
    <p>Historically error-correcting codes were first made in binary metric to correct program-reading errors in early type computers in the 1950s [<xref ref-type="bibr" rid="B14">14</xref>,<xref ref-type="bibr" rid="B27">27</xref>]. Levenshtein was one of the first in attempting to resolve more natural problems such as insertions and deletions [<xref ref-type="bibr" rid="B17">17</xref>]. Whereas computer codes were gradually evolving (in data transfer and processing, mobile, satellite communications, etc.), an application for DNA studies was far from successful. A few authors rediscovered Hamming code while making a theory of oligonucleotide design for microarrays [<xref ref-type="bibr" rid="B28">28</xref>,<xref ref-type="bibr" rid="B29">29</xref>]. This however was not implemented in commercially available microarrays. Similarly, currently available barcoded primers from, for instance, Illumina look like a random design devoid of any theoretical (error-correcting) considerations [<xref ref-type="bibr" rid="B13">13</xref>]. The first attempt to implement Hamming code into DNA barcode design failed due to improper binary-tertiary conversion protocol [<xref ref-type="bibr" rid="B7">7</xref>]. Later, this problem was resolved by adapting the Hamming concept to quaternary format [<xref ref-type="bibr" rid="B13">13</xref>]. Alternatively, Krishnan et al. used binary, linear error-correcting codes with longer minimal distances for DNA barcode design [<xref ref-type="bibr" rid="B16">16</xref>]. Whereas a noticeable progress was achieved with linear/perfect codes mentioned above, a proper application of Levenshtein codes for DNA barcodes had not yet been demonstrated. The major obstacle in these implementations was the problem of word recognition in the continuous context of DNA. As this inherent failure is not addressed in the literature on Levenshtein-based error correction in DNA barcodes (e.g. [<xref ref-type="bibr" rid="B18">18</xref>]), we at best assume that some form of separating sequence is used between the DNA barcode and the sample DNA, and at worst no correction of this failure was attempted. The drawback of separating sequences is obvious: they do not come with any correction ability by themselves and elongate the DNA sequence at the same time, increasing the error rate for the sample DNA. The use of separating sequences is therefore not ideal.</p>
    <p>By simulating equally likely substitutions, deletions, and insertions we tested the robustness of Sequence-Levenshtein distance based codes. We found that the error correction of Sequence-Levenshtein barcodes was, on average, more reliable than comparable Levenshtein-based codes. Although the probabilities of mutation rates in experimental sequencing data or in biological samples might considerably deviate from equal, it very much depends on the organism and the sequencing platform. Therefore it is not easy to create a “real life” simulation of sequencing errors. In our mutation study we ignored possible differences in mutation rates solely to test as many possible mutations on as many possible DNA combinations as possible. As a result the revealed rates of successful error corrections will not necessarily correspond to those in a real sequencing data.</p>
    <p>Sequence-Levenshtein codes can be further improved in the following ways. Firstly, as barcode libraries are often constructed only once and then reused for later experiments, it is desirable to construct barcode sets that correct <italic>k</italic> errors with a maximum subset that corrects <italic>k + 1</italic> errors. Thus, if the number of parallel processed samples in an experiment is very low, the more robust <italic>k + 1 </italic> subset is used. This code construction is easily achieved by modifying the evolutionary greedy search algorithm to favor barcode sets with a large robust <italic>k + 1</italic> subset. Secondly, not every error occurs with the same probability: some substitutions are more likely than others, e.g. DNA/RNA sequences are more likely to be altered at the end of the read than at the beginning. An advanced version of this code would therefore use probabilities of operations as a distance measure and construct codes that, while not guaranteeing error correction, will correct more errors on average with shorter barcodes.</p>
  </sec>
  <sec sec-type="conclusions">
    <title>Conclusion</title>
    <p>We propose a solution to the problem of the word size definition in the continuous context of DNA and a definition of a modified Levenshtein distance which we name “Sequence-Levenshtein distance”. This new distance measure takes into account the interference of appended sample sequences and the resulting shorter distances between barcodes.</p>
    <p>This approach allows for the detection of the length of the corrupted barcode and the recovery of the start of the appended sample sequence. However, this imposes more strict rules for the selection of barcode sets eligible for error correction. We show that the application of these new barcodes decreases mismatching in multiplexing experiments considerably, increasing the robustness of experimental results. For further experimental validation and application, we provide barcode sets of different lengths and guaranteed error-correcting capabilities that will satisfy current size-needs of most experimental setups as well as software to decode sequence reads which is, in its current implementation, highly efficient.</p>
    <p>Our Sequence-Levenshtein software package is a versatile tool to flexibly generate barcode sets of different sizes and robustness, simulate expected mismatch rates for individual next generation sequencing technologies, and decode millions of sequence reads in a short time. As such, we believe it offers a valuable research utility to the general public.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>Dresden University of Technology submitted a patent application for the Sequence-Levenshtein technology in Germany (application id 800228609).</p>
  </sec>
  <sec>
    <title>Authors’ contributions</title>
    <p>LVB initiated the re-analysis of classical DNA codes and initiated and inspired the development of the method. TB developed the method. TB developed, ran and analysed the simulations. TB and LVB wrote the manuscript. Both authors read and approved the final manuscript.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="S1">
      <caption>
        <title>Additional file 1</title>
        <p><bold>Supplement.</bold> The supplement contains a proof of the metric property of the Sequence-Levenshtein distance, the dynamic programming algorithm of the Sequence-Levenshtein distance, a figure of code rates depending on barcode lengths, a table of Sequence-Levenshtein code sizes as well as an additional table describing the codes used in Simulation 3.</p>
      </caption>
      <media xlink:href="1471-2105-14-272-S1.pdf">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>We thank Michael Chang, Erik Zwart and Lydia Kuettner for reading and correcting the manuscript.</p>
    <p>The research of Tilo Buschmann was supported by the European Commission project EuroSyStem (200270), Leonid V. Bystrykh was partially supported by an HEM-ID grant (<ext-link ext-link-type="uri" xlink:href="http://www.hemid.eu/">http://www.hemid.eu/</ext-link>) and NIRM grants (<ext-link ext-link-type="uri" xlink:href="http://www.nirm.nl/">http://www.nirm.nl/</ext-link>).</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Young</surname>
          <given-names>AL</given-names>
        </name>
        <name>
          <surname>Abaan</surname>
          <given-names>HO</given-names>
        </name>
        <name>
          <surname>Zerbino</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Mullikin</surname>
          <given-names>JC</given-names>
        </name>
        <name>
          <surname>Birney</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Margulies</surname>
          <given-names>EH</given-names>
        </name>
        <article-title>A new strategy for genome assembly using short sequence reads and reduced representation libraries</article-title>
        <source>Genome Res</source>
        <year>2010</year>
        <volume>14</volume>
        <issue>2</issue>
        <fpage>249</fpage>
        <lpage>256</lpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://genome.cshlp.org/content/20/2/249.abstract">http://genome.cshlp.org/content/20/2/249.abstract</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1101/gr.097956.109</pub-id>
        <?supplied-pmid 20123915?>
        <pub-id pub-id-type="pmid">20123915</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Van Tassell</surname>
          <given-names>CP</given-names>
        </name>
        <name>
          <surname>Smith</surname>
          <given-names>TPL</given-names>
        </name>
        <name>
          <surname>Matukumalli</surname>
          <given-names>LK</given-names>
        </name>
        <name>
          <surname>Taylor</surname>
          <given-names>JF</given-names>
        </name>
        <name>
          <surname>Schnabel</surname>
          <given-names>RD</given-names>
        </name>
        <name>
          <surname>Lawley</surname>
          <given-names>CT</given-names>
        </name>
        <name>
          <surname>Haudenschild</surname>
          <given-names>CD</given-names>
        </name>
        <name>
          <surname>Moore</surname>
          <given-names>SS</given-names>
        </name>
        <name>
          <surname>Warren</surname>
          <given-names>WC</given-names>
        </name>
        <name>
          <surname>Sonstegard</surname>
          <given-names>TS</given-names>
        </name>
        <article-title>SNP discovery and allele frequency estimation by deep sequencing of reduced representation libraries</article-title>
        <source>Nat Meth</source>
        <year>2008</year>
        <volume>14</volume>
        <issue>3</issue>
        <fpage>247</fpage>
        <lpage>252</lpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nmeth.1185">http://dx.doi.org/10.1038/nmeth.1185</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1038/nmeth.1185</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Buermans</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Ariyurek</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>van Ommen</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>den Dunnen</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>’t Hoen</surname>
          <given-names>P</given-names>
        </name>
        <article-title>New methods for next generation sequencing based microRNA expression profiling</article-title>
        <source>BMC Genomics</source>
        <year>2010</year>
        <volume>14</volume>
        <fpage>716</fpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2164/11/716">http://www.biomedcentral.com/1471-2164/11/716</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1186/1471-2164-11-716</pub-id>
        <?supplied-pmid 21171994?>
        <pub-id pub-id-type="pmid">21171994</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bystrykh</surname>
          <given-names>LV</given-names>
        </name>
        <name>
          <surname>Verovskaya</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Zwart</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Broekhuis</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>de Haan</surname>
          <given-names>G</given-names>
        </name>
        <article-title>Counting stem cells: methodological constraints</article-title>
        <source>Nat Meth</source>
        <year>2012</year>
        <volume>14</volume>
        <issue>6</issue>
        <fpage>567</fpage>
        <lpage>574</lpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nmeth.2043">http://dx.doi.org/10.1038/nmeth.2043</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1038/nmeth.2043</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>An</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Davis</surname>
          <given-names>ES</given-names>
        </name>
        <name>
          <surname>Thompson</surname>
          <given-names>TL</given-names>
        </name>
        <name>
          <surname>O?Donnell</surname>
          <given-names>KA</given-names>
        </name>
        <name>
          <surname>Lee</surname>
          <given-names>CY</given-names>
        </name>
        <name>
          <surname>Boeke</surname>
          <given-names>JD</given-names>
        </name>
        <article-title>Plug and play modular strategies for synthetic retrotransposons</article-title>
        <source>Methods</source>
        <year>2009</year>
        <volume>14</volume>
        <issue>3</issue>
        <fpage>227</fpage>
        <lpage>235</lpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://www.sciencedirect.com/science/article/pii/S1046202309001455">http://www.sciencedirect.com/science/article/pii/S1046202309001455</ext-link>] [Transposon Technology]</comment>
        <pub-id pub-id-type="doi">10.1016/j.ymeth.2009.05.013</pub-id>
        <?supplied-pmid 19481606?>
        <pub-id pub-id-type="pmid">19481606</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Uren</surname>
          <given-names>AG</given-names>
        </name>
        <name>
          <surname>Mikkers</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Kool</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>van der Weyden</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Lund</surname>
          <given-names>AH</given-names>
        </name>
        <name>
          <surname>Wilson</surname>
          <given-names>CH</given-names>
        </name>
        <name>
          <surname>Rance</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Jonkers</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>van Lohuizen</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Berns</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Adams</surname>
          <given-names>DJ</given-names>
        </name>
        <article-title>A high-throughput splinkerette-PCR method for the isolation and sequencing of retroviral insertion sites</article-title>
        <source>Nat Protocols</source>
        <year>2009</year>
        <volume>14</volume>
        <issue>5</issue>
        <fpage>789</fpage>
        <lpage>798</lpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nprot.2009.64">http://dx.doi.org/10.1038/nprot.2009.64</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1038/nprot.2009.64</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Hamady</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Walker</surname>
          <given-names>JJ</given-names>
        </name>
        <name>
          <surname>Harris</surname>
          <given-names>JK</given-names>
        </name>
        <name>
          <surname>Gold</surname>
          <given-names>NJ</given-names>
        </name>
        <name>
          <surname>Knight</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Error-correcting barcoded primers for pyrosequencing hundreds of samples in multiplex</article-title>
        <source>Nat Meth</source>
        <year>2008</year>
        <volume>14</volume>
        <issue>3</issue>
        <fpage>235</fpage>
        <lpage>237</lpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nmeth.1184">http://dx.doi.org/10.1038/nmeth.1184</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1038/nmeth.1184</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kircher</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Kelso</surname>
          <given-names>J</given-names>
        </name>
        <article-title>High-throughput DNA sequencing concepts and limitations</article-title>
        <source>BioEssays</source>
        <year>2010</year>
        <volume>14</volume>
        <issue>6</issue>
        <fpage>524</fpage>
        <lpage>536</lpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1002/bies.200900181">http://dx.doi.org/10.1002/bies.200900181</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1002/bies.200900181</pub-id>
        <?supplied-pmid 20486139?>
        <pub-id pub-id-type="pmid">20486139</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Parameswaran</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Jalili</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Tao</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Shokralla</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Gharizadeh</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Ronaghi</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Fire</surname>
          <given-names>AZ</given-names>
        </name>
        <article-title>A pyrosequencing-tailored nucleotide barcode design unveils opportunities for large-scale sample multiplexing</article-title>
        <source>Nucleic Acids Res</source>
        <year>2007</year>
        <volume>14</volume>
        <issue>19</issue>
        <fpage>e130</fpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/content/35/19/e130.abstract">http://nar.oxfordjournals.org/content/35/19/e130.abstract</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1093/nar/gkm760</pub-id>
        <?supplied-pmid 17932070?>
        <pub-id pub-id-type="pmid">17932070</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Nguyen</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Ma</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Pei</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Obert</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Cheng</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Geiger</surname>
          <given-names>T</given-names>
        </name>
        <article-title>Identification of errors introduced during high throughput sequencing of the T cell receptor repertoire</article-title>
        <source>BMC Genomics</source>
        <year>2011</year>
        <volume>14</volume>
        <fpage>106</fpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2164/12/106">http://www.biomedcentral.com/1471-2164/12/106</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1186/1471-2164-12-106</pub-id>
        <?supplied-pmid 21310087?>
        <pub-id pub-id-type="pmid">21310087</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gilles</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Meglecz</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Pech</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Ferreira</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Malausa</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Martin</surname>
          <given-names>JF</given-names>
        </name>
        <article-title>Accuracy and quality assessment of 454 GS-FLX Titanium pyrosequencing</article-title>
        <source>BMC Genomics</source>
        <year>2011</year>
        <volume>14</volume>
        <fpage>245</fpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2164/12/245">http://www.biomedcentral.com/1471-2164/12/245</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1186/1471-2164-12-245</pub-id>
        <?supplied-pmid 21592414?>
        <pub-id pub-id-type="pmid">21592414</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Carneiro</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Russ</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Ross</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Gabriel</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Nusbaum</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>DePristo</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Pacific biosciences sequencing technology for genotyping and variation discovery in human data</article-title>
        <source>BMC Genomics</source>
        <year>2012</year>
        <volume>14</volume>
        <fpage>375</fpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2164/13/375">http://www.biomedcentral.com/1471-2164/13/375</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1186/1471-2164-13-375</pub-id>
        <?supplied-pmid 22863213?>
        <pub-id pub-id-type="pmid">22863213</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bystrykh</surname>
          <given-names>LV</given-names>
        </name>
        <article-title>Generalized DNA barcode design based on hamming codes</article-title>
        <source>PLoS ONE</source>
        <year>2012</year>
        <volume>14</volume>
        <issue>5</issue>
        <fpage>e36852</fpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1371%2Fjournal.pone.0036852">http://dx.doi.org/10.1371%2Fjournal.pone.0036852</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0036852</pub-id>
        <?supplied-pmid 22615825?>
        <pub-id pub-id-type="pmid">22615825</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Hamming</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Error detecting and error correcting codes</article-title>
        <source>Bell Syst Tech J</source>
        <year>1950</year>
        <volume>14</volume>
        <issue>2</issue>
        <fpage>147</fpage>
        <lpage>160</lpage>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="book">
        <name>
          <surname>Hamming</surname>
          <given-names>RW</given-names>
        </name>
        <source>Coding and information theory; 2nd ed</source>
        <year>1986</year>
        <publisher-name>Upper Saddle River, NJ, USA: Prentice-Hall, Inc</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Krishnan</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Sweeney</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Vasic</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Galbraith</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Vasic</surname>
          <given-names>B</given-names>
        </name>
        <article-title>Barcodes for DNA sequencing with guaranteed errorcorrection capability</article-title>
        <source>Electron Lett</source>
        <year>2011</year>
        <volume>14</volume>
        <issue>4</issue>
        <fpage>236</fpage>
        <lpage>237</lpage>
        <pub-id pub-id-type="doi">10.1049/el.2010.3546</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Levenshtein</surname>
          <given-names>V</given-names>
        </name>
        <article-title>Binary codes capable of correcting deletions, insertions and reversals</article-title>
        <source>Sov Phys Dokl</source>
        <year>1966</year>
        <volume>14</volume>
        <fpage>707</fpage>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Faircloth</surname>
          <given-names>BC</given-names>
        </name>
        <name>
          <surname>Glenn</surname>
          <given-names>TC</given-names>
        </name>
        <article-title>Not all sequence tags are created equal: designing and validating sequence identification tags robust to indels</article-title>
        <source>PLoS ONE</source>
        <year>2012</year>
        <volume>14</volume>
        <issue>8</issue>
        <fpage>e42543</fpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1371%2Fjournal.pone.0042543">http://dx.doi.org/10.1371%2Fjournal.pone.0042543</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0042543</pub-id>
        <?supplied-pmid 22900027?>
        <pub-id pub-id-type="pmid">22900027</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Reed</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Solomon</surname>
          <given-names>G</given-names>
        </name>
        <article-title>Polynomial Codes Over Certain Finite Fields</article-title>
        <source>J Soc Ind Appl Math</source>
        <year>1960</year>
        <volume>14</volume>
        <issue>2</issue>
        <fpage>300</fpage>
        <lpage>304</lpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://epubs.siam.org/doi/abs/10.1137/0108018">http://epubs.siam.org/doi/abs/10.1137/0108018</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1137/0108018</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="book">
        <name>
          <surname>Ashlock</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Guo</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Qiu</surname>
          <given-names>F</given-names>
        </name>
        <article-title>Greedy closure evolutionary algorithms</article-title>
        <source>Proceedings of the 2002 Congress on Evolutionary Computation, CEC’02</source>
        <year>2002</year>
        <publisher-name>445 Hoes Lane, Piscataway, NJ 08854, USA: IEEE</publisher-name>
        <fpage>1296</fpage>
        <lpage>1301</lpage>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="book">
        <name>
          <surname>Ashlock</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Houghten</surname>
          <given-names>SK</given-names>
        </name>
        <article-title>DNA error correcting codes: no crossover</article-title>
        <source>Proceedings of the 6th Annual IEEE conference on Computational Intelligence in Bioinformatics and Computational Biology, CIBCB’09</source>
        <year>2009</year>
        <publisher-name>445 Hoes Lane, Piscataway, NJ 08854, USA: IEEE Press</publisher-name>
        <fpage>38</fpage>
        <lpage>45</lpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://dl.acm.org/citation.cfm?id=1688165.1688171">http://dl.acm.org/citation.cfm?id=1688165.1688171</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="book">
        <name>
          <surname>Houghten</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Ashlock</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Lenarz</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Construction of Optimal Edit Metric Codes</article-title>
        <source>Information Theory Workshop, 2006. ITW ’06 Chengdu. IEEE</source>
        <year>2006</year>
        <publisher-name>445 Hoes Lane, Piscataway, NJ 08854, USA</publisher-name>
        <fpage>259</fpage>
        <lpage>263</lpage>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bogdanova</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Brouwer</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Kapralov</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Ostergard</surname>
          <given-names>P</given-names>
        </name>
        <article-title>Error-correcting codes over an alphabet of four elements</article-title>
        <source>Designs Codes Cryptography</source>
        <year>2001</year>
        <volume>14</volume>
        <issue>3</issue>
        <fpage>333</fpage>
        <lpage>342</lpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1023/A%3A1011275112159">http://dx.doi.org/10.1023/A%3A1011275112159</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1023/A:1011275112159</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Wagner</surname>
          <given-names>RA</given-names>
        </name>
        <name>
          <surname>Fischer</surname>
          <given-names>MJ</given-names>
        </name>
        <article-title>The string-to-string correction problem</article-title>
        <source>J ACM</source>
        <year>1974</year>
        <volume>14</volume>
        <fpage>168</fpage>
        <lpage>173</lpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://doi.acm.org/10.1145/321796.321811">http://doi.acm.org/10.1145/321796.321811</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1145/321796.321811</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Allison</surname>
          <given-names>L</given-names>
        </name>
        <article-title>Lazy dynamic-programming can be eager</article-title>
        <source>Inf Process Lett</source>
        <year>1992</year>
        <volume>14</volume>
        <issue>4</issue>
        <fpage>207</fpage>
        <lpage>212</lpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1016/0020-0190(92)90202-7">http://dx.doi.org/10.1016/0020-0190(92)90202-7</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1016/0020-0190(92)90202-7</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="book">
        <name>
          <surname>Clarke</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Ferreira</surname>
          <given-names>H</given-names>
        </name>
        <article-title>Coding for synchronous, fixed length decoding windows in the presence of insertion/deletion errors</article-title>
        <source>AFRICON, 2004. 7th AFRICON Conference in Africa</source>
        <year>2004</year>
        <publisher-name>445 Hoes Lane, Piscataway, NJ 08854, USA: IEEE</publisher-name>
        <fpage>297</fpage>
        <lpage>300</lpage>
        <comment>Vol.1.</comment>
      </mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Golay</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Notes on digital coding</article-title>
        <source>Proc IRE</source>
        <year>1949</year>
        <volume>14</volume>
        <fpage>657</fpage>
      </mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Ben-Dor</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Karp</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Schwikowski</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Yakhini</surname>
          <given-names>Z</given-names>
        </name>
        <article-title>Universal DNA tag systems: a combinatorial design scheme</article-title>
        <source>J Comput Biol</source>
        <year>2000</year>
        <volume>14</volume>
        <issue>3-4</issue>
        <fpage>503</fpage>
        <lpage>519</lpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1089/106652700750050916">http://dx.doi.org/10.1089/106652700750050916</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1089/106652700750050916</pub-id>
        <?supplied-pmid 11108476?>
        <pub-id pub-id-type="pmid">11108476</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Liu</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Gao</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Xu</surname>
          <given-names>J</given-names>
        </name>
        <article-title>DNA sequence design based on template strategy</article-title>
        <source>ChemInform</source>
        <year>2004</year>
        <volume>14</volume>
        <issue>5</issue>
        <fpage>no</fpage>
        <lpage>no</lpage>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1002/chin.200405241">http://dx.doi.org/10.1002/chin.200405241</ext-link>]</comment>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
