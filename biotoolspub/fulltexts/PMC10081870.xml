<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10081870</article-id>
    <article-id pub-id-type="pmid">37010504</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad141</article-id>
    <article-id pub-id-type="publisher-id">btad141</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Applications Note</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Genome Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>dipwmsearch: a Python package for searching di-PWM motifs</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Mille</surname>
          <given-names>Marie</given-names>
        </name>
        <aff><institution>LIRMM, Univ Montpellier, CNRS</institution>, Montpellier, <country country="FR">France</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ripoll</surname>
          <given-names>Julie</given-names>
        </name>
        <aff><institution>LIRMM, Univ Montpellier, CNRS</institution>, Montpellier, <country country="FR">France</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Cazaux</surname>
          <given-names>Bastien</given-names>
        </name>
        <aff><institution>LIRMM, Univ Montpellier, CNRS</institution>, Montpellier, <country country="FR">France</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-3791-3973</contrib-id>
        <name>
          <surname>Rivals</surname>
          <given-names>Eric</given-names>
        </name>
        <aff><institution>LIRMM, Univ Montpellier, CNRS</institution>, Montpellier, <country country="FR">France</country></aff>
        <aff><institution>Institut Français de Bioinformatique, CNRS UAR 3601</institution>, Évry, <country country="FR">France</country></aff>
        <xref rid="btad141-cor1" ref-type="corresp"/>
        <!--rivals@lirmm.fr-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Robinson</surname>
          <given-names>Peter</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad141-cor1">Corresponding author. LIRMM, Univ Montpellier, CNRS, Montpellier, France. E-mail: <email>rivals@lirmm.fr</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>4</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-04-03">
      <day>03</day>
      <month>4</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>03</day>
      <month>4</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>4</issue>
    <elocation-id>btad141</elocation-id>
    <history>
      <date date-type="received">
        <day>15</day>
        <month>11</month>
        <year>2022</year>
      </date>
      <date date-type="rev-recd">
        <day>23</day>
        <month>2</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>12</day>
        <month>3</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>07</day>
        <month>4</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad141.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Seeking probabilistic motifs in a sequence is a common task to annotate putative transcription factor binding sites or other RNA/DNA binding sites. Useful motif representations include position weight matrices (PWMs), dinucleotide PWMs (di-PWMs), and hidden Markov models (HMMs). Dinucleotide PWMs not only combine the simplicity of PWMs—a matrix form and a cumulative scoring function—but also incorporate dependency between adjacent positions in the motif (unlike PWMs which disregard any dependency). For instance to represent binding sites, the HOCOMOCO database provides di-PWM motifs derived from experimental data. Currently, two programs, SPRy-SARUS and MOODS, can search for occurrences of di-PWMs in sequences.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We propose a Python package called <italic toggle="yes">dipwmsearch</italic>, which provides an original and efficient algorithm for this task (it first enumerates matching words for the di-PWM, and then searches these all at once in the sequence, even if the latter contains IUPAC codes). The user benefits from an easy installation via <italic toggle="yes">Pypi</italic> or <italic toggle="yes">conda</italic>, a comprehensive documentation, and executable scripts that facilitate the use of di-PWMs.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p><italic toggle="yes">dipwmsearch</italic> is available at <ext-link xlink:href="https://pypi.org/project/dipwmsearch/" ext-link-type="uri">https://pypi.org/project/dipwmsearch/</ext-link> and <ext-link xlink:href="https://gite.lirmm.fr/rivals/dipwmsearch/" ext-link-type="uri">https://gite.lirmm.fr/rivals/dipwmsearch/</ext-link> under Cecill license.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>European Union’s Horizon 2020 research and innovation program</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="4"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Protein binding sites on nucleic acids (DNA or RNA) share similar, but not identical sequences. The collection of sequences of such binding sites, which in practice is a set of sequences (of identical length), are summarized and represented as a probabilistic motif. Often only a few positions within such sequences are conserved across a majority of their binding sites. Even at a conserved position, when the collection is large enough, alternative nucleotides occur. Hence, for each position of the binding site, it is convenient to summarize its variability as the probability of each nucleotide to occur at this position. The probabilities are estimated from the frequencies of nucleotides at that position in the collection. This explains why the first and most popular probabilistic motif representation is the Position Weight Matrix (PWM) (<xref rid="btad141-B8" ref-type="bibr">Stormo 2000</xref>). A PWM is a matrix containing the weight or score of each nucleotide at each position of the sequence alignment: the weights are log-odd scores of the nucleotide probabilities at each position. Numerous search algorithms are available for PWMs (<xref rid="btad141-B2" ref-type="bibr">Beckstette et al. 2006</xref>; <xref rid="btad141-B3" ref-type="bibr">Korhonen et al. 2009</xref>; <xref rid="btad141-B7" ref-type="bibr">Martin et al. 2018</xref>). However, in a PWM positions are entirely independent one of another; but in reality, neighboring positions are constrained since they influence the shape of DNA, or the propensity to undergo epigenetic modifications, and hence the binding of the protein. Hence, a more complex representation for probabilistic motifs that accounts for local position dependencies was proposed: the dinucleotide PWM (di-PWM) (<xref rid="btad141-B5" ref-type="bibr">Kulakovskiy et al. 2013</xref>). At each position, one records the frequency of all 16 possible dinucleotides (instead of four nucleotides in a PWM). A di-PWM and score computation of a word is illustrated in <xref rid="btad141-F1" ref-type="fig">Fig. 1a</xref>.</p>
    <fig position="float" id="btad141-F1">
      <label>Figure 1</label>
      <caption>
        <p>(a) Enumeration and scanning strategy for a di-PWM. Left part shows how the score of two words are computed by summing the score of their five dinucleotides. If the score lies above the threshold, the word is a valid word and is added to the list for later search. Right part: we build an Aho–Corasick automaton with all valid words in the list, then use the automaton to scan the sequence. (b) Illustration of the branch and bound strategy for the enumeration procedure. We build a trie for words starting with letter <italic toggle="yes">A</italic>, and explore it in Depth-First manner. As soon as a prefix cannot give rise to a valid word, which is determined using the LookAheadMatrix (LAM), we cut the corresponding branch. Only valid words generate a leaf in the trie. (c) Comparison of SPRy-SARUS and dipwmsearch for searching all Human di-PWMs from HOCOMOCO on Human chromosome 15. The violin plot shows the running times over for all di-PWMs and their median for both tools</p>
      </caption>
      <graphic xlink:href="btad141f1" position="float"/>
    </fig>
    <p>For instance, the <italic toggle="yes">HOCOMOCO</italic> database (v11) stores di-PWMs of binding motifs of Human and Mouse transcription factors (292 and 257, respectively), which were directly computed from experimental ChIP-Seq data (<xref rid="btad141-B6" ref-type="bibr">Kulakovskiy et al. 2018</xref>). For detecting new binding sites, it was shown that di-PWMs provide enhance sensitivity compared to classical PWMs (<xref rid="btad141-B5" ref-type="bibr">Kulakovskiy et al. 2013</xref>). di-PWMs also obtained successful results in the DREAM-ENCODE challenge from 2017.</p>
    <p>To our knowledge, only <italic toggle="yes">SPRy-SARUS</italic> and <italic toggle="yes">MOODS</italic> can find occurrences of di-PWMs in long sequences. <italic toggle="yes">SPRy-SARUS</italic> is an efficient standalone Java program to search for di-PWMs, which is coupled with <italic toggle="yes">MoLoTool</italic>, a web tool allowing visual inspection of occurrences in short sequences (<xref rid="btad141-B6" ref-type="bibr">Kulakovskiy et al. 2018</xref>). MOODS, a tool to search for PSSM/PWM, can also handle di-PWMs (<xref rid="btad141-B4" ref-type="bibr">Korhonen et al. 2017</xref>) (v3 available as C++ code and Python package). Both adopt a window scanning strategy, while <italic toggle="yes">dipwmsearch</italic> uses an enumeration strategy.</p>
    <p>Hence, we provide a Python package for searching di-PWM in sequences: it can be easily installed via <italic toggle="yes">conda</italic> and offers several functions that can be used in Python programs. The user can control the minimum score of occurrences found by entering either a score threshold, a ratio threshold, or a <italic toggle="yes">P</italic>-value threshold. After the search, the user can also compute and add the <italic toggle="yes">P</italic>-value of each reported occurrence in the output file. We designed a novel search algorithm that differs from previous approaches. Running time comparisons demonstrate that our algorithm is on par with SPRy-SARUS in practice.</p>
  </sec>
  <sec>
    <title>2 Search algorithm</title>
    <p>Our package provides distinct search algorithms: an optimized scanning algorithm (OS), an enumeration-based algorithm for full di-PWMs (FE), and the core enumeration-based algorithm (CE). We described the FE and CE algorithms below, and explain OS in <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>. The CE algorithm is the most time efficient of all and, by design, uses less memory than FE.</p>
    <p>From an algorithmic viewpoint, we aim at proposing new approaches capable of finding occurrences in long sequences (written over an alphabet containing <italic toggle="yes">σ</italic> symbols) with a limited amount of memory. Before explaining the algorithm, we give some rationale for our approach. Let us consider that in a text <italic toggle="yes">T</italic>, we seek a di-PWM <italic toggle="yes">P</italic> of size <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (for a motif of length <italic toggle="yes">m</italic>) and with a score threshold <italic toggle="yes">t</italic>. An entry <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mo>α</mml:mo><mml:mo>β</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> gives the score of dinucleotide <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo>β</mml:mo></mml:mrow></mml:math></inline-formula> at position <italic toggle="yes">i</italic> in the motif. For the CE algorithm, we need to restrict the matrix <italic toggle="yes">P</italic> to a subset of columns (i.e. to an interval of positions) for any interval <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mn>..</mml:mn><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> with <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
    <sec>
      <title>2.1 Traditional scanning algorithm and enumeration strategy</title>
      <p>In a traditional scanning algorithm, one considers each possible window of length <italic toggle="yes">m</italic> in <italic toggle="yes">T</italic> and computes its score according to <italic toggle="yes">P</italic> (see <xref rid="btad141-F1" ref-type="fig">Fig. 1a</xref>). It takes <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>×</mml:mo><mml:mo>|</mml:mo><mml:mi>T</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time, which is quadratic. The scanning approach implies redundant computation (for instance when processing identical or similar substrings whose score are too low) and often is inefficient. A classical speedup trick uses the LookAheadTable to stop the score computation after viewing only a prefix of the current window (<xref rid="btad141-B2" ref-type="bibr">Beckstette et al. 2006</xref>); it does not improve the worst-case complexity.</p>
      <p>An alternative is to first enumerate all words of length <italic toggle="yes">m</italic> that match <italic toggle="yes">P</italic> with a score <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mo>&gt;</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:math></inline-formula>, which we call <italic toggle="yes">valid words</italic>, and then to search the valid words in <italic toggle="yes">T</italic> using an Aho–Corasick (AC) automaton (<xref rid="btad141-B1" ref-type="bibr">Aho and Corasick 1975</xref>) (or any other algorithm that solves the Set Pattern Matching problem). We implemented this in the enumeration-based algorithm for full di-PWM (FE). We call this global idea the <italic toggle="yes">enumeration strategy</italic>; it concentrates the complexity in the enumeration phase and makes the scanning efficient because it seeks <monospace>only exact</monospace> matches of the valid words—the scanning phase does not compute any score. Nicely, building the Aho–Corasick automaton takes linear time in the cumulated length of valid words, and scanning <italic toggle="yes">T</italic> with it takes linear time in <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>T</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>2.2 Efficiency conditions for the enumeration strategy</title>
      <p>To be efficient, the enumeration strategy needs 1/ a fast enumeration algorithm, 2/ a set of valid words that is small enough for the AC automaton to fit in memory (i.e. to remain fast to build). Below, we exhibit an enumeration algorithm that takes linear time in the output size, and satisfies the first condition. However, the number of valid words depends on the selectivity of the di-PWM <italic toggle="yes">P</italic> with threshold <italic toggle="yes">t</italic>. The least selective position is when the scores of all 16 dinucleotides are equal. It turns out that some di-PWMs from HOCOMOCO contain positions that are not selective, i.e. in which the scores of dinucleotides are almost equally distributed. A closer examination shows in such di-PWMs nonselective positions often occur in intervals of successive positions (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>). For such an interval of say <italic toggle="yes">f</italic> positions, if we consider <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> the restriction of <italic toggle="yes">P</italic> to this interval, almost any possible word of length <italic toggle="yes">f </italic>+<italic toggle="yes"> </italic>1 is a valid word for the di-PWM <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. This may lead to an explosion of valid words for the full di-PWM <italic toggle="yes">P</italic>.</p>
      <p>We propose to identify selective and nonselective positions by considering the standard deviation of their scores: a large deviation means a selective position. To avoid cases with huge set of valid words, we propose to restrict <italic toggle="yes">P</italic> to an interval of selective positions, which we term the <italic toggle="yes">core</italic>. We proceed as follows: first, we compute the standard deviation of scores for all positions, then we select, by exhaustive search among all possible intervals of length at least 10, the interval with the largest average standard deviation. This interval determines the core (which is a smaller di-PWM).</p>
    </sec>
    <sec>
      <title>2.3 Enumeration of valid words: B&amp;B approach and LAM</title>
      <p>For a full di-PWM, we propose an algorithm that explores a trie data structure of valid words using a Branch-and-Bound approach (see <xref rid="btad141-F1" ref-type="fig">Fig. 1b</xref>). We build a trie that spells out prefixes of potential valid words, one letter at a time. After each letter, assume the current prefix has length <italic toggle="yes">k</italic>, we compute the partial score for this prefix. Then, we check the score for the best possible suffix of length <italic toggle="yes">m–k</italic> in an additional matrix called the LAM. If the sum of prefix and suffix scores does not reach the threshold <italic toggle="yes">t</italic>, then extensions of the current branch of the trie are unnecessary. The LookAheadMatrix (or LAM for short) is a precomputed <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mo>σ</mml:mo><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> matrix that depends only on <italic toggle="yes">P</italic>. For a position <italic toggle="yes">i</italic> in <italic toggle="yes">P</italic> and a symbol <italic toggle="yes">α</italic>, the <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LAM</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mo>α</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> stores the best score for a suffix starting with symbol <italic toggle="yes">α</italic> at position <italic toggle="yes">i</italic>. <xref rid="sup1" ref-type="supplementary-material">Supplementary Algorithm S1</xref> computes the LAM in <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time. The LAM has a crucial property: for any stored score value in the LAM, there exists a word that realizes this score. This ensures that only branches of the trie corresponding to valid words are fully built by the enumeration algorithm. Moreover, the amount of computation spent between two successive valid words is bounded by 2<italic toggle="yes">m</italic>, which implies that our algorithm takes linear time in the output size.</p>
      <p>Note that a pendant matrix to the LAM can be built symmetrically to compute the best scores of prefixes of <italic toggle="yes">P</italic>. We call this matrix, the LookBackMatrix or LBM.</p>
      <p>After enumeration, in the search step, the set of valid words for <italic toggle="yes">P</italic> are searched for in <italic toggle="yes">T</italic> using an Aho–Corasick automaton (<xref rid="btad141-B1" ref-type="bibr">Aho and Corasick, 1975</xref>).</p>
    </sec>
    <sec>
      <title>2.4 Adapting the enumeration strategy and search to the core</title>
      <p>The enumeration algorithm and search phase must be adapted to use the core instead of <italic toggle="yes">P</italic>. Assume the core, denoted by <italic toggle="yes">Q</italic>, starts at position <italic toggle="yes">k </italic>+<italic toggle="yes"> </italic>1 in the motif and has length <italic toggle="yes">h–</italic>1. We must enumerate words of length <italic toggle="yes">h</italic> for <italic toggle="yes">Q</italic> that are substrings of valid words of length <italic toggle="yes">m</italic> for <italic toggle="yes">P</italic>. We run the branch &amp; bound algorithm described above to spell out words of length <italic toggle="yes">h</italic> according to <italic toggle="yes">Q</italic>, but we cannot select them on their own score (which is a sum only over <italic toggle="yes">h–</italic>1 positions!). We must use the score of a prefix of <italic toggle="yes">P</italic>, not a prefix of <italic toggle="yes">Q</italic>. Assume the current prefix <italic toggle="yes">w</italic> starts with letter <italic toggle="yes">α</italic> at position <italic toggle="yes">k </italic>+<italic toggle="yes"> </italic>1 and ends with letter <italic toggle="yes">β</italic>; as score, we use <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mtext>score</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">xwy</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic toggle="yes">x</italic> is a highest scoring valid prefix for <italic toggle="yes">P</italic> of length <italic toggle="yes">k</italic> ending with letter <italic toggle="yes">α</italic>, and <italic toggle="yes">y</italic> a highest scoring suffix of length <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mo>|</mml:mo><mml:mi>w</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> starting with letter <italic toggle="yes">β</italic>, and such that <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="italic">xwy</mml:mi><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>. The idea behind is that <italic toggle="yes">xwy</italic> is the best possible word of length <italic toggle="yes">m</italic> with substring <italic toggle="yes">w</italic> (at positions <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>w</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>). The constraints on the letters are implied by the fact that successive positions of a di-PWM score overlapping dinucleotides. We use the LAM to get the contribution of <italic toggle="yes">y</italic> to this score (without knowing <italic toggle="yes">y</italic>) and we use the LBM to get that of <italic toggle="yes">x</italic> (without knowing <italic toggle="yes">x</italic>). The algorithm outputs the set of all words <italic toggle="yes">w</italic> of length <italic toggle="yes">h</italic> that occur in at least one valid word for <italic toggle="yes">P</italic> (at position <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mi>h</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>).</p>
      <p>The search phase builds an AC automaton with this set and scan <italic toggle="yes">T</italic> with it. Each time a match is found, say at position <italic toggle="yes">i</italic>, it computes the score of the window of <italic toggle="yes">T</italic> between positions <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. If the scores reaches the threshold <italic toggle="yes">t</italic> it reports a match of <italic toggle="yes">P</italic> at position <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in <italic toggle="yes">T</italic>, and its score.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>We compared the core enumeration algorithm to SPRy-SARUS in terms of efficiency by searching each Human di-PWM from HOCOMOCO on Human chromosomes 3 and 15 with four different score ratio thresholds (0.8, 0.85, 0.90, and 0.95). The score ratio threshold is a way to set a relative score threshold that is comparable between different di-PWMs (it was developed for PWMs—see the FAQ of JASPAR database). The score threshold <italic toggle="yes">θ</italic> is computed as follows: <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mo>θ</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mtext mathvariant="italic">score</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">max</mml:mtext></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mtext mathvariant="italic">score</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>*</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ratio</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">score</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">min</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, where <italic toggle="yes">score</italic><sub><italic toggle="yes">min</italic></sub> and <italic toggle="yes">score</italic><sub><italic toggle="yes">max</italic></sub> are respectively the minimum and maximum achievable scores for the input di-PWM. Note that <italic toggle="yes">dipwmsearch</italic> provides an alternative to the ratio threshold: the user can give a <italic toggle="yes">P</italic>-value threshold to limit the score of occurrences found.</p>
    <p>First, the results shown in <xref rid="btad141-F1" ref-type="fig">Fig. 1c</xref> confirm that CE algorithm is able to search for any di-PWM with reasonable score ratios. <xref rid="btad141-F1" ref-type="fig">Figure 1c</xref> displays the median search time over all di-PWMs for both tools, and shows first, that <italic toggle="yes">dipwmsearch</italic> offers affordable runtimes whatever the ratio, and second that, while <italic toggle="yes">dipwmsearch</italic> takes longer times than SPRy-SARUS for ratio 0.80, it is as efficient or faster for larger ratios.</p>
    <p>On the violin plot, the set of points for dipwmsearch is needle-like due to the variability of motif length and of information content among HOCOMOCO di-PWMs. Information poor di-PWMs generate longer list of valid words, whose enumeration and storage requires longer time and larger memory, than for information rich di-PWMs. An extreme example of information poor di-PWMs, that of GATA2, is shown in <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>; others, such as MAX_HUMAN (length 23 nuc.), can be spotted looking at the LOGO representations of di-PWMs on HOCOMOCO webpage. Below in the discussion, we emphasize that enumeration of valid words and the core-based strategy can help questioning the information content and the width of some di-PWMs.</p>
  </sec>
  <sec>
    <title>4 Conclusion</title>
    <p>Our Python package, <italic toggle="yes">dipwmsearch</italic>, provides an easy and efficient procedure to find occurrences of di-PWMs in nucleotidic sequences, and well documented snippets. It offers practical advantages compared to an existing solution (like processing IUPAC codes, or an adaptable output—see <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>). Furthermore, it can be enhanced by combining it with other Python packages (e.g. for processing compressed sequence files). Most of all, the installation is straightforward using <italic toggle="yes">pypi</italic> or <italic toggle="yes">conda</italic>. In addition, we presented an original enumeration-based search algorithm that handles di-PWMs even if they contain nonselective positions. Coping with nonselective positions was necessary to make search effective for some di-PWMs, which questions their information content, and in turn their construction process. Examining the core block determined by our CE algorithm, or comparing set of valid words with the occurrences found in practice, can help determining whether the information content and the length of a di-PWM are well adapted or could be improved.</p>
    <p>Several perspectives come to mind. First, once enumerated, the set of valid words can be stored in a file and reused for other searches. Second, the search phase can be streamlined by using a precomputed index of the searched sequence to find valid words, which would be appropriate for a web application that needs to answer numerous di-PWM searches.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad141_Supplementary_Data</label>
      <media xlink:href="btad141_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>We thank N. Romashchenko for advices on packaging <italic toggle="yes">dipwmsearch</italic>.</p>
  </ack>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> is available at <italic toggle="yes">Bioinformatics</italic> online.</p>
    <p>Conflict of interest: None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by European Union’s Horizon 2020 research and innovation program under the Marie Skłodowska-Curie grant agreement [956229 to E.R.]; by Institut National du Cancer (INCA) PLBIO project [2020-116 to J.R. and E.R.]; and by Labex Solutions Numériques, Matérielles et Modélisation pour l'Environnement et le Vivant (NUMEV) for GEM flagship project [ANR 2011-LABX-076 to M.M., J.R., and E.R.].</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad141-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Aho</surname><given-names>A</given-names></string-name>, <string-name><surname>Corasick</surname><given-names>M.</given-names></string-name></person-group><article-title>Efficient string matching: an aid to bibliographic search</article-title>. <source>Commun ACM</source><year>1975</year>;<volume>18</volume>:<fpage>333</fpage>–<lpage>40</lpage>.</mixed-citation>
    </ref>
    <ref id="btad141-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Beckstette</surname><given-names>M</given-names></string-name>, <string-name><surname>Homann</surname><given-names>R</given-names></string-name>, <string-name><surname>Giegerich</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Fast index based algorithms and software for matching position specific scoring matrices</article-title>. <source>BMC Bioinformatics</source><year>2006</year>;<volume>7</volume>:<fpage>389</fpage>. <pub-id pub-id-type="doi">10.1186/1471-2105-7-389</pub-id>.<pub-id pub-id-type="pmid">16930469</pub-id></mixed-citation>
    </ref>
    <ref id="btad141-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Korhonen</surname><given-names>J</given-names></string-name>, <string-name><surname>Martinmäki</surname><given-names>P</given-names></string-name>, <string-name><surname>Pizzi</surname><given-names>C</given-names></string-name></person-group><etal>et al</etal><article-title>MOODS: fast search for position weight matrix matches in DNA sequences</article-title>. <source>Bioinformatics</source><year>2009</year>;<volume>25</volume>:<fpage>3181</fpage>–<lpage>2</lpage>.<pub-id pub-id-type="pmid">19773334</pub-id></mixed-citation>
    </ref>
    <ref id="btad141-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Korhonen</surname><given-names>JH</given-names></string-name>, <string-name><surname>Palin</surname><given-names>K</given-names></string-name>, <string-name><surname>Taipale</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>Fast motif matching revisited: high-order PWMs, SNPs and indels</article-title>. <source>Bioinformatics</source><year>2017</year>;<volume>33</volume>:<fpage>514</fpage>–<lpage>21</lpage>.<pub-id pub-id-type="pmid">28011774</pub-id></mixed-citation>
    </ref>
    <ref id="btad141-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kulakovskiy</surname><given-names>I</given-names></string-name>, <string-name><surname>Levitsky</surname><given-names>V</given-names></string-name>, <string-name><surname>Oshchepkov</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>From binding motifs in chip-seq data to improved models of transcription factor binding sites</article-title>. <source>J Bioinform Comput Biol</source><year>2013</year>;<volume>11</volume>:<fpage>1340004</fpage>.<pub-id pub-id-type="pmid">23427986</pub-id></mixed-citation>
    </ref>
    <ref id="btad141-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kulakovskiy</surname><given-names>IV</given-names></string-name>, <string-name><surname>Vorontsov</surname><given-names>IE</given-names></string-name>, <string-name><surname>Yevshin</surname><given-names>IS</given-names></string-name></person-group><etal>et al</etal><article-title>HOCOMOCO: towards a complete collection of transcription factor binding models for human and mouse via large-scale ChIP-Seq analysis</article-title>. <source>Nucleic Acids Res</source><year>2018</year>;<volume>46</volume>:<fpage>D252</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">29140464</pub-id></mixed-citation>
    </ref>
    <ref id="btad141-B7">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Martin</surname><given-names>D</given-names></string-name>, <string-name><surname>Maillol</surname><given-names>V</given-names></string-name>, <string-name><surname>Rivals</surname><given-names>E.</given-names></string-name></person-group> Fast and accurate genome-scale identification of DNA-binding sites. In: <italic toggle="yes">2018 IEEE International Conference on Bioinformatics and Biomedicine (BIBM)</italic>, <italic toggle="yes">Madrid, Spain</italic>, pp. <fpage>201</fpage>–<lpage>5</lpage>. <year>2018</year>.</mixed-citation>
    </ref>
    <ref id="btad141-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Stormo</surname><given-names>GD.</given-names></string-name></person-group><article-title>DNA binding sites: representation and discovery</article-title>. <source>Bioinformatics</source><year>2000</year>;<volume>16</volume>:<fpage>16</fpage>–<lpage>23</lpage>.<pub-id pub-id-type="pmid">10812473</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
