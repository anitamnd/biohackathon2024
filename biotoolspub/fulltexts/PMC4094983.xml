<?DTDIdentifier.IdentifierValue http://www.biomedcentral.com/xml/article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4094983</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-15-164</article-id>
    <article-id pub-id-type="pmid">24884701</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-15-164</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>WinHAP2: an extremely fast haplotype phasing program for long genotype sequences</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" id="A1">
        <name>
          <surname>Pan</surname>
          <given-names>Weihua</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>whpan@mail.ustc.edu.cn</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Zhao</surname>
          <given-names>Yanan</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>ynzhao92@mail.ustc.edu.cn</email>
      </contrib>
      <contrib contrib-type="author" corresp="yes" id="A3">
        <name>
          <surname>Xu</surname>
          <given-names>Yun</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>xuyun@ustc.edu.cn</email>
      </contrib>
      <contrib contrib-type="author" corresp="yes" id="A4">
        <name>
          <surname>Zhou</surname>
          <given-names>Fengfeng</given-names>
        </name>
        <xref ref-type="aff" rid="I3">3</xref>
        <email>FengfengZhou@gmail.com</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>School of Computer Science and Technology, University of Science and Technology of China, Hefei, Anhui 230027, P.R. China</aff>
    <aff id="I2"><label>2</label>Anhui Province-MOST Co-Key Laboratory of High Performance Computing and Its Application, University of Science and Technology of China, Hefei, Anhui 230027, P.R. China</aff>
    <aff id="I3"><label>3</label>Shenzhen Institutes of Advanced Technology, and Key Lab for Health Informatics, Chinese Academy of Sciences, Shenzhen, Guangdong 518055, P.R. China</aff>
    <pub-date pub-type="collection">
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>30</day>
      <month>5</month>
      <year>2014</year>
    </pub-date>
    <volume>15</volume>
    <fpage>164</fpage>
    <lpage>164</lpage>
    <history>
      <date date-type="received">
        <day>23</day>
        <month>10</month>
        <year>2013</year>
      </date>
      <date date-type="accepted">
        <day>14</day>
        <month>5</month>
        <year>2014</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2014 Pan et al.; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2014</copyright-year>
      <copyright-holder>Pan et al.; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly credited. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1471-2105/15/164"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>The haplotype phasing problem tries to screen for phenotype associated genomic variations from millions of candidate data. Most of the current computer programs handle this problem with high requirements of computing power and memory. By replacing the computation-intensive step of constructing the maximum spanning tree with a heuristics of estimated initial haplotype, we released the WinHAP algorithm version 1.0, which outperforms the other algorithms in terms of both running speed and overall accuracy.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>This work further speeds up the WinHAP algorithm to version 2.0 (WinHAP2) by utilizing the divide-and-conquer strategy and the OpenMP parallel computing mode. WinHAP2 can phase 500 genotypes with 1,000,000 SNPs using just 12.8 MB in memory and 2.5 hours on a personal computer, whereas the other programs require unacceptable memory or running times. The parallel running mode further improves WinHAP2's running speed with several orders of magnitudes, compared with the other programs, including Beagle, SHAPEIT2 and 2SNP.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>WinHAP2 is an extremely fast haplotype phasing program which can handle a large-scale genotyping study with any number of SNPs in the current literature and at least in the near future.</p>
      </sec>
    </abstract>
    <kwd-group>
      <kwd>Haplotype phasing</kwd>
      <kwd>Genotype</kwd>
      <kwd>SNP</kwd>
      <kwd>Long sequence</kwd>
      <kwd>Parallel computing</kwd>
    </kwd-group>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>Single nucleotide polymorphisms (SNPs) are a kind of genomic variations that play an important role in many genetic analysis. Most eukaryotic genomes are diploid and it’s both technically difficult and time consuming to experimentally screen the sequence of alleles in contiguous SNP sites along each copy of the diploid chromosomes, which is called a haplotype. The two nucleotides/alleles for one locus in a chromosome are usually obtained as an unordered pair, which is called a genotype. A haplotype phasing problem is to infer haplotypes from genotypes. Although there are some other methods based on modern sequencing, such as Haplotype-resolved sequencing technology and HaploSeq method, can obtain haplotypes directly rather than computationally infer them, haplotype phasing costs much less money than these methods
[<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B2">2</xref>].</p>
    <p>The existing methods for haplotype phasing problem can be classified into two major categories: combinatorial optimization algorithms
[<xref ref-type="bibr" rid="B3">3</xref>,<xref ref-type="bibr" rid="B4">4</xref>] and statistical methods
[<xref ref-type="bibr" rid="B5">5</xref>]. Combinatorial optimization algorithms focuses on finding the solution based on reasonable biological assumptions. Two models were considered: the Perfect Phylogeny Tree Model and the Maximum Parsimony Model. Maximum Parsimony Model assumed that the number of distinct haplotypes in natural populations was really small or the minimum among all feasible solutions
[<xref ref-type="bibr" rid="B4">4</xref>]. The principle was firstly proposed by Wang and Xu who also presented a branch and bound algorithm under this principle to speed up the problem resolving
[<xref ref-type="bibr" rid="B6">6</xref>]. Many other algorithms try to solve the problem based on this model using either SAT-based formulations or integer linear programming techniques. However, Maximum Parsimony Model has been demonstrated to be NP-complete
[<xref ref-type="bibr" rid="B7">7</xref>] and APX-hard even in very restricted cases
[<xref ref-type="bibr" rid="B8">8</xref>], which means precise solution can only be got with exponential time consuming. Therefore many approximate approaches were also proposed based on this model. Perfect Phylogeny Tree Model changed the haplotype phasing problem to a graph realization problem
[<xref ref-type="bibr" rid="B3">3</xref>,<xref ref-type="bibr" rid="B9">9</xref>]. This model assumed that any SNP mutation happened just once in the whole evolutionary history. As perfect phylogeny trees are usually not unique for a given genotype set, the minimum perfect phylogeny haplotyping (MPPH) rule was proposed
[<xref ref-type="bibr" rid="B7">7</xref>]. MPPH is a combination of Perfect Phylogeny Tree Model and the Maximum Parsimony Model. It tries to reconstruct a perfect phylogeny tree that consists of minimum number of unique haplotypes. Bafna et.al. proved MPPH problem to be NP-hard
[<xref ref-type="bibr" rid="B10">10</xref>]. Although combinatorial optimization algorithms can do well in small datasets, the strong assumption and high time complexity holds back its application in larger datasets
[<xref ref-type="bibr" rid="B11">11</xref>].</p>
    <p>Compared with combinatorial optimization algorithms, statistical methods focus on estimating the haplotype frequencies according to certain statistical theories. An earlier method was EM algorithm
[<xref ref-type="bibr" rid="B5">5</xref>]. It iteratively computes each haplotype’s frequency and estimate the new solution. Then the quality of the solution will be higher and higher. This algorithm worked well on a small data set, but its time cost increased sharply as it should enumerate all feasible solutions. In order to further reduce the computation time requirement, PLEM
[<xref ref-type="bibr" rid="B12">12</xref>] and GERBIL
[<xref ref-type="bibr" rid="B13">13</xref>] use partition-ligation strategy for speed-up. And BPPLEM replaces the uniform strategy with non-uniform strategy based on linkage disequilibrium (LD)
[<xref ref-type="bibr" rid="B14">14</xref>]. In addition, some other statistical theories have also been used to infer the haplotypes, such as Bayesian and MCMC
[<xref ref-type="bibr" rid="B15">15</xref>]. Although statistical methods can process larger datasets than combinatorial optimization algorithms, they usually need to consider lots of feasible haplotypes, which require large amount of storage.</p>
    <p>With the recent innovations in high-throughput gene chip technologies, huge amount of genotype data was produced, leading to a new challenge of handling the large-scale datasets for the haplotype phasing problem. many methods based on Hidden Markov Model (HMM) have been proposed recently, such as Beagle
[<xref ref-type="bibr" rid="B16">16</xref>], HAPI-UR
[<xref ref-type="bibr" rid="B17">17</xref>], SHAPEIT1
[<xref ref-type="bibr" rid="B18">18</xref>] and SHAPEIT2
[<xref ref-type="bibr" rid="B19">19</xref>]. This kind of methods firstly yields feasible haplotypes randomly. Then it iteratively builds HMM according to current haplotypes and gets new haplotypes based on this HMM. Our experiments have shown that while they can get accurate haplotype results for datasets with a large number of homologous sequences, they can’t do well for datasets with small number of long genotype sequences which are very common. That’s because statistical methods need more information to refer to compared with other methods. In addition, some methods combine statistical theories and combinatorial optimization rules. Although it’s impossible to get exact solution based on combinatorial optimization rules for large scale datasets, they are used in some steps of algorithms to help to improve the precision of approximate solutions. For example, 2SNP algorithm finds the most relevant allele for a specific allele by building a phylogeny tree
[<xref ref-type="bibr" rid="B20">20</xref>].</p>
    <p>We proposed the WinHAP algorithm
[<xref ref-type="bibr" rid="B21">21</xref>] by combining probability statistic and combinatorial optimization
[<xref ref-type="bibr" rid="B21">21</xref>]. WinHAP significantly improved the speed of haplotype phasing, while achieving similar or better overall accuracy compared with the other existing programs. But days are still needed for WinHAP to screening the millions of SNPs in the human genome. We further improve the program's running speed and memory efficiency by using the following two strategies. Firstly, a divide-and-conquer strategy is utilized to solve the challenge of huge computer memory required by the existing algorithms. The basic idea is to screen the long chromosomes for haplotypes within the consecutive 1,000-SNP segments. Thus, the memory need of the algorithm is only related with one segment and no longer increases as length of sequences. Secondly, the OpenMP parallel computing mode is implemented to utilize all the computing power in a multi-core computer cluster. The haplotype phasing performance of WinHAP version 2 (WinHAP2) is discussed in the following sections.</p>
    <p>WinHAP2.0 software package is available at <ext-link ext-link-type="uri" xlink:href="http://staff.ustc.edu.cn/~xuyun/winhap/index.htm">http://staff.ustc.edu.cn/~xuyun/winhap/index.htm</ext-link>. We have also uploaded the source code, manual, materials and example datasets onto it. As of now, WinHAP software packages have been downloaded for at least dozens of times and used by biologists from different organizations and institutes around the world, such as Max Planck Institute for Molecular Genetics, Dahlem Centre for Genome Research and Medical Systems Biology, Alacris Theranostics GmbH in Germany, University of Medical Sciences in Poland, Jiangxi Agricultural University and University of Science and Technology of China. Particularly, some users from Huazhong Agricultural University want to process very long sequences with more than 1 million SNPs on personal computers which cannot be done by WinHAP1.0 and nearly all the existing tools except for WinHAP2.0.</p>
  </sec>
  <sec>
    <title>Implementation</title>
    <p>The input to WinHAP2 consists of <italic>n</italic> genotype vectors, each with <italic>m</italic> coordinates corresponding to <italic>m</italic> SNPs. Each genotype vector can be phased to two haplotype vectors with value in {0, 1}, where ‘0’ represents the major allele and ‘1’ the minor allele. A haplotype vector is represented as a string of the alphabet {0, 1}. A genotype vector is represented as a string of alphabet {0, 1, 2, ?}, where ‘0’ and ‘1’ represent the homozygous SNP {0, 0} and {1, 1}, respectively, ‘2’ is a heterozygous SNP {0, 1}, and ‘?’ is a missing SNP.</p>
    <sec>
      <title>Divide-and-conquer strategy</title>
      <p>WinHAP2 utilizes the divide-and-conquer strategy to phase long sequences. The WinHAP algorithm infers haplotypes from the neighboring SNPs, and the comparison with the other programs suggests that little association exists between a pair of remote SNPs. So a segment with fixed number of consecutive SNPs (1,000 by default) is sufficient for inferring haplotypes.With divide-and-conquer strategy, WinHAP2 consists of three phases. In first step, the genotypes are partitioned into segments. In second step, all segments are phased by WinHAP respectively. In last step, the results of all segments are merged into a whole result. Figure 
<xref ref-type="fig" rid="F1">1</xref> shows the overall framework.</p>
      <fig id="F1" position="float">
        <label>Figure 1</label>
        <caption>
          <p><bold>Framework of WinHAP2.</bold> Procedure of WinHAP2 with divide-and-conquer strategy. Explanation see text in this section.</p>
        </caption>
        <graphic xlink:href="1471-2105-15-164-1"/>
      </fig>
      <p>In the first step, we partition genotype datasets sequentially into segments, each of which has the same size<italic>s</italic>. It should be mentioned here that the value of <italic>s</italic> must be neither too large nor too small. Larger <italic>s</italic>is, more memory is cost and then partition will be less meaningful. On the other hand, if <italic>s</italic>is too small, precision of algorithm will be affected. Because it’s possible that there’s no ‘2’ in one segment, which will make it difficult to merge the haplotype result of that segment with others’. Based on our experiments, <italic>s</italic> should be larger than 1,000 sites, while the upper limit of <italic>s</italic>is related with the memory of computer used. For the last segment, as we know, the size of it is less than or equal to <italic>s</italic>. If it is smaller than 1,000 sites, we merge it to the last but one segment.</p>
      <p>In the second step, all segments are phased by WinHAP respectively. WinHAP has three phases: In the first phase which is called simplified 2SNP algorithm, the initial haplotype results are obtained. In the second phase, scalable sliding windows are used to correct some errors in first phase. In the third phase, maximum parsimony principle is used to improve the quality of results further. Two points should be mentioned here. Firstly, in the second phase, precision of the sites near edge is lower than others’ because they can only be covered by sliding windows from one side. Number of this kind of sites becomes much larger in WinHAP2 because each segment has edges. This problem is solved in the third step of WinHAP2. Secondly, the third phase can get better results in WinHAP2, because maximum parsimony principle is not suitable for very long sequences and segmenting makes the sequences shorter.</p>
      <p>In the final step, the results of all segments are merged into a whole result. To ensure the precision of the SNPs at the edge of each segment, a merging strategy is proposed. It’s described in detail in section Method.</p>
    </sec>
    <sec>
      <title>Parallelization</title>
      <p>Due to its nature of local calculation, and its large data size, an OpenMP parallel computing mode is adopted for the time-consuming step of haplotype phasing including step 2 and step 3. As phasing in each segment has no relationship with other segments, parallelization of step 2 is comparatively easy. We just distribute one or several segment to one thread and each thread gets the result respectively. However, parallelization of step3 is harder. For merging is a process involving all segments, how to distribute the assignment to each thread is the key point. To eliminate the relationship between segments, we divide the process into 3 phases. Firstly, we cut the right edge of each segment except last one and save it in file, which can be done by each thread respectively. Secondly, each thread merge the right edge of the former segment and later segment and save the merged each segment. Finally, one thread put all merged segments together, which is hardly time-consuming.</p>
    </sec>
    <sec>
      <title>Time complexity of WinHAP2</title>
      <p>Now, let’s analyze the time complexity of WinHAP2. In the first step, WinHAP2partitions genotypes into segments, which takes <italic>0</italic>(<italic>nm</italic>) time since we have <italic>n</italic> genotypes each with <italic>m</italic> SNPs. In the second step, each segment is phased respectively by WinHAP. According to the analysis in the previous paper
[<xref ref-type="bibr" rid="B21">21</xref>], WinHAP takes <italic>0</italic>(<italic>n</italic><sup>2</sup><italic>m</italic>). So if we use <italic>p</italic> computing cores, it takes <italic>0</italic>(<italic>n</italic><sup>2</sup><italic>m</italic>/<italic>p</italic>). In the last phase, our algorithm merges the results of all segments into a whole result using scalable sliding window. For each two adjacent segments, <italic>l</italic><sub>max</sub>-2 windows are needed. And the computation in one window takes <italic>0</italic>(<italic>n</italic>) time. So the last phase takes <italic>0</italic>(<italic>nk</italic>/<italic>p</italic>), where <italic>k</italic> denotes the number of segments and <italic>p</italic> denotes the number of computing cores. Thus, our algorithm takes <italic>0</italic>(<italic>nm</italic> + <italic>n</italic><sup>2</sup><italic>m</italic>/<italic>p</italic> + <italic>nk</italic>/<italic>p</italic>)~ <italic>0</italic>(<italic>n</italic><sup>2</sup><italic>m</italic>/<italic>p</italic>) in total time.</p>
    </sec>
  </sec>
  <sec>
    <title>Results and discussion</title>
    <sec>
      <title>Datasets</title>
      <p>As the performance of WinHAP processing comparatively small datasets (&lt;1000 SNPs) like ACE
[<xref ref-type="bibr" rid="B22">22</xref>], 5q31
[<xref ref-type="bibr" rid="B23">23</xref>] and CFTR
[<xref ref-type="bibr" rid="B24">24</xref>] has been showed in the previous paper
[<xref ref-type="bibr" rid="B21">21</xref>], only large scale datasets with more than 10,000 SNPs are tested in this paper. However, public real datasets of this scale are very few. So we employ one real dataset, one simulated dataset which is generated by randomly pairing real haplotypes, and simulated datasets of different scale from ‘ms’ software.</p>
    </sec>
    <sec>
      <title>HapMap real dataset</title>
      <p>Firstly, we compared the performances of WinHAP2 and the other Haplotype Phasing programs on the real dataset from International HapMap Project which aims to develop a haplotype map ofthe human genome
[<xref ref-type="bibr" rid="B25">25</xref>]. This dataset consists of 44 pedigrees (father, mother and child), each genotyped at 36,258 SNPs in the 20th chromosome of human. We choose the genotypes of 44 fathers and 44 mothers to get 88 unrelated genotype sequences. As SHAPEIT2 is a newest algorithm for large scale datasets, we want to compare WinHAP2with it. The input of SHAPEIT2 includes recombination rate of each SNP, and HapMap shows a table which includes recombination rate of most SNP in human chromosome. However, there are still some SNPs of this real datasets are not in this table. So we have to choose 32,458 SNPs from original dataset. So it’s a dataset comprising of 88 unrelated genotype sequences, each of which has 32,458 sites.</p>
    </sec>
    <sec>
      <title>HapMap simulated dataset</title>
      <p>We further tested the algorithms with another dataset from HapMap International HapMap Project. It’s a dataset of 120 real haplotype sequences, each of which has 63,810 SNPs in the 20th chromosome of CEU (Utah residents with ancestry from northern and western Europe). We generated the genotype datasets by randomly pairing two haplotypes. To let the simulated genotype dataset be similar to real ones, we only generate 40 sequences. So it’s a dataset comprising of 40 unrelated genotype sequences, each of which has 63,810 sites.</p>
    </sec>
    <sec>
      <title>“<italic>ms</italic>” dataset</title>
      <p>We use well-known Hudson’s software “ms”
[<xref ref-type="bibr" rid="B26">26</xref>] to generate simulated genotype sets with <italic>N</italic> = 50, <italic>N</italic> = 100, <italic>N</italic> = 200, <italic>N</italic> = 500 and <italic>M</italic> = 10,000, <italic>M</italic> = 20,000, <italic>M</italic> = 50,000, <italic>M</italic> = 100,000, <italic>M</italic> = 1,000,000. Here <italic>N</italic> means the number of sequences and <italic>M</italic> means the length of sequences. The parameter“<italic>θ</italic>” is set to 5.0. The recombination parameters “<italic>ρ</italic>” and “nsites” are set to 100 and 2501 respectively.</p>
    </sec>
    <sec>
      <title>Measurement criteria of phasing accuracy</title>
      <p>Usually, the <italic>individual error rate</italic> (IER)
[<xref ref-type="bibr" rid="B15">15</xref>] and the <italic>switch error rate</italic> (SER)
[<xref ref-type="bibr" rid="B13">13</xref>] are used to evaluate the performance of phasing algorithms
[<xref ref-type="bibr" rid="B27">27</xref>,<xref ref-type="bibr" rid="B28">28</xref>]. IER is defined as the percentage of individuals whose genotypes are incorrectly resolved and SER is defined as the ratio between the numbers of switch errors and all the heterozygous loci. The value of IER usually increases along with the increase of genotype length. When the number of SNPs is large enough, the IER value of almost all haplotype phasing approaches is close to 100%. In our experiments, the number of SNPs in all datasets is larger than 10,000, and IER is meaningless for datasets of this scale. So we just use switch error rate (SER) to evaluate the performance of WinHAP2 in this paper.</p>
      <p>We compared our algorithm with three existing programs including SHAPEIT2
[<xref ref-type="bibr" rid="B19">19</xref>], Beagle
[<xref ref-type="bibr" rid="B16">16</xref>] and 2SNP
[<xref ref-type="bibr" rid="B20">20</xref>]. Other algorithms are not tested for either of the following three reasons: (1) can’t produce the results within reasonable time; (2) cannot handle the missing SNPs; (3) can’t process such long sequence.</p>
    </sec>
    <sec>
      <title>Validation on HapMap real dataset</title>
      <p>We run the 2SNP, Beagle, SHAPEIT2 and WinHAP2 on a HapMap real dataset averaged over 100 independent runs. The dataset comprises of 88 unrelated genotype sequences, each of which has 32,458 SNPs. 2SNP and SHAPEIT2 were both run with the default settings. The parameter “nsample” of Beagle was set to 4 and we randomly generated the parameter “seed” in every independent running.</p>
      <p>The performance of various phasing programs on this HapMap real dataset was shown in Table 
<xref ref-type="table" rid="T1">1</xref>. From the result, we can see that although the error rate of WinHAP2 is not the best, it’s similar to others’. But the running time and memory consumption of WinHAP2 are both much lower than others’. While SHAPEIT2gets the lowest error rate, its running time is about 60 times and its memory consumption is 30 times than WinHAP2. In addition to that, the use of SHAPEIT2 has some limit which means that it needs the recombination rate of each SNP, but not all SNPs’ recombination rate can be got. Beagle’s running time is 3 times and memory consumption is more than 100 times than our method. The precision and memory consumption of 2SNP are both the worst among the programs, and its running time is nearly 30 times than our algorithm’s.</p>
      <table-wrap position="float" id="T1">
        <label>Table 1</label>
        <caption>
          <p>Results on HapMap real dataset</p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col align="left"/>
            <col align="left"/>
            <col align="left"/>
            <col align="left"/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th align="left">
                <bold>Software</bold>
              </th>
              <th align="left">
                <bold>SER</bold>
              </th>
              <th align="left">
                <bold>Time </bold>
                <bold>(s)</bold>
              </th>
              <th align="left">
                <bold>Memory</bold>
              </th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="left" valign="bottom">
                <bold>2SNP</bold>
                <hr/>
              </td>
              <td align="left" valign="bottom">0.049<hr/></td>
              <td align="left" valign="bottom">892.70<hr/></td>
              <td align="left" valign="bottom">1.0GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">
                <bold>Beagle</bold>
                <hr/>
              </td>
              <td align="left" valign="bottom">0.032<hr/></td>
              <td align="left" valign="bottom">121.30<hr/></td>
              <td align="left" valign="bottom">396.5 MB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">
                <bold>SHAPEIT2</bold>
                <hr/>
              </td>
              <td align="left" valign="bottom">
                <bold>0.024</bold>
                <hr/>
              </td>
              <td align="left" valign="bottom">1816.20<hr/></td>
              <td align="left" valign="bottom">91.4 MB<hr/></td>
            </tr>
            <tr>
              <td align="left">
                <bold>WinHAP2</bold>
              </td>
              <td align="left">0.039</td>
              <td align="left">
                <bold>32.00</bold>
              </td>
              <td align="left">
                <bold>3.2 MB</bold>
              </td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Bold data means the best result in terms of the corresponding evaluation standard.</p>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>Validation on HapMap simulated dataset</title>
      <p>To test the performance of WinHAP2 on datasets with longer sequences, we run 2SNP, Beagle and WinHAP2 on HapMap simulated dataset. As SHAPEIT2 need the information like recombination rate of each SNP and sex of each individual, it cannot be run on simulated datasets. We constructed a dataset of 40 haplotypes with no missing data from 120 experimentally identified disease haplotypes. Each haplotype has 63,810 SNPs. To ensure the objection of the test, we repeat the sampling and test for 100 times. The parameter “nsample” of BEAGLE was set to 4. All the other parameters were set to the default values.</p>
      <p>Table 
<xref ref-type="table" rid="T2">2</xref> gives the accuracies, running times and memory consumption of the algorithms. Through WinHAP2has higher SER than Beagle, the running speed is about 3 times than Beagle’s and memory consumption is only about one thirtieth of Beagle’s. The precision, running time and memory consumption of 2SNP are all the worst among the algorithms.</p>
      <table-wrap position="float" id="T2">
        <label>Table 2</label>
        <caption>
          <p>Results on HapMap simulated dataset</p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col align="left"/>
            <col align="left"/>
            <col align="left"/>
            <col align="left"/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th align="left">
                <bold>Software</bold>
              </th>
              <th align="left">
                <bold>SER</bold>
              </th>
              <th align="left">
                <bold>Time </bold>
                <bold>(s)</bold>
              </th>
              <th align="left">
                <bold>Memory</bold>
              </th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="left" valign="bottom">
                <bold>2SNP</bold>
                <hr/>
              </td>
              <td align="left" valign="bottom">0.034<hr/></td>
              <td align="left" valign="bottom">1342.10<hr/></td>
              <td align="left" valign="bottom">2.2GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">
                <bold>Beagle</bold>
                <hr/>
              </td>
              <td align="left" valign="bottom">
                <bold>0.022</bold>
                <hr/>
              </td>
              <td align="left" valign="bottom">92.89<hr/></td>
              <td align="left" valign="bottom">622.2 MB<hr/></td>
            </tr>
            <tr>
              <td align="left">
                <bold>WinHAP2</bold>
              </td>
              <td align="left">0.028</td>
              <td align="left">
                <bold>37.92</bold>
              </td>
              <td align="left">
                <bold>2.4 MB</bold>
              </td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Bold data means the best result in terms of the corresponding evaluation standard.</p>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>Validation on ‘ms’ simulated datasets</title>
      <p>To test the performance of WinHAP2 on different size of datasets, we run 2SNP, Beagle and WinHAP2 on ‘ms’ simulated datasets.</p>
      <p>The performance of various phasing algorithms on this ‘ms’ simulated dataset was shown in Table 
<xref ref-type="table" rid="T3">3</xref>. From the result, we can see that SERs of WinHAP2 are similar with and sometimes the same with Beagle’s. The running speed of our algorithm is 3 to 10 times than Beagle’s. In addition, Beagle cannot process 200 sequences with more than 100,000 SNPs or 500 sequences with more than 50,000 SNPs on our machine because of memory overflow. 2SNP cannot process 100 sequences with more than 100,000 SNPs for the similar reason. WinHAP2 can process sequences with 1,000,000 SNPs using only 12.8 MB memory.</p>
      <table-wrap position="float" id="T3">
        <label>Table 3</label>
        <caption>
          <p><bold>Results on</bold> ‘<bold>ms</bold>’ <bold>simulated datasets</bold></p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col align="left"/>
            <col align="left"/>
            <col align="left"/>
            <col align="left"/>
            <col align="left"/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th align="left">
                <bold>Data sets</bold>
              </th>
              <th align="left">
                <bold>Methods</bold>
              </th>
              <th align="left">
                <bold>SER</bold>
              </th>
              <th align="left">
                <bold>Time (s)</bold>
              </th>
              <th align="left">
                <bold>Memory</bold>
              </th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="left" valign="bottom">#genotype = 200<hr/></td>
              <td align="left" valign="bottom">2SNP<hr/></td>
              <td align="left" valign="bottom">0.037<hr/></td>
              <td align="left" valign="bottom">87.8<hr/></td>
              <td align="left" valign="bottom">197.0 MB<hr/></td>
            </tr>
            <tr>
              <td rowspan="2" align="left" valign="bottom">#SNPs = 10,000<hr/></td>
              <td align="left" valign="bottom">Beagle<hr/></td>
              <td align="left" valign="bottom">
                <bold>0.020</bold>
                <hr/>
              </td>
              <td align="left" valign="bottom">121.4<hr/></td>
              <td align="left" valign="bottom">481.7 MB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">WinHAP2<hr/></td>
              <td align="left" valign="bottom">
                <bold>0.020</bold>
                <hr/>
              </td>
              <td align="left" valign="bottom">
                <bold>14.5</bold>
                <hr/>
              </td>
              <td align="left" valign="bottom">
                <bold>5.1 MB</bold>
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left" valign="bottom">#genotype = 200<hr/></td>
              <td align="left" valign="bottom">2SNP<hr/></td>
              <td align="left" valign="bottom">0.035<hr/></td>
              <td align="left" valign="bottom">2472.0<hr/></td>
              <td align="left" valign="bottom">1.7GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">#SNPs = 50,000<hr/></td>
              <td align="left" valign="bottom">Beagle<hr/></td>
              <td align="left" valign="bottom">
                <bold>0.019</bold>
                <hr/>
              </td>
              <td align="left" valign="bottom">582.8<hr/></td>
              <td align="left" valign="bottom">617.6 MB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="left" valign="bottom">WinHAP2<hr/></td>
              <td align="left" valign="bottom">0.024<hr/></td>
              <td align="left" valign="bottom">
                <bold>69.9</bold>
                <hr/>
              </td>
              <td align="left" valign="bottom">
                <bold>5.1 MB</bold>
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left" valign="bottom">#genotype = 500<hr/></td>
              <td align="left" valign="bottom">2SNP<hr/></td>
              <td align="left" valign="bottom">0.023<hr/></td>
              <td align="left" valign="bottom">8404.0<hr/></td>
              <td align="left" valign="bottom">1.7GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">#SNPs = 50,000<hr/></td>
              <td align="left" valign="bottom">Beagle<hr/></td>
              <td align="left" valign="bottom">Out of memory<hr/></td>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="left" valign="bottom"> <hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="left" valign="bottom">WinHAP2<hr/></td>
              <td align="left" valign="bottom">
                <bold>0.012</bold>
                <hr/>
              </td>
              <td align="left" valign="bottom">
                <bold>340.5</bold>
                <hr/>
              </td>
              <td align="left" valign="bottom">
                <bold>12.8 MB</bold>
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left" valign="bottom">#genotype = 500<hr/></td>
              <td align="left" valign="bottom">2SNP<hr/></td>
              <td align="left" valign="bottom">Out of memory<hr/></td>
              <td colspan="2" align="left" valign="bottom"> <hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">#SNPs<hr/></td>
              <td align="left" valign="bottom">Beagle<hr/></td>
              <td align="left" valign="bottom">Out of memory<hr/></td>
              <td colspan="2" align="left" valign="bottom"> <hr/></td>
            </tr>
            <tr>
              <td align="left">=1,000,000</td>
              <td align="left">WinHAP2</td>
              <td align="left">
                <bold>0.012</bold>
              </td>
              <td align="left">
                <bold>9013.6</bold>
              </td>
              <td align="left">
                <bold>12.8 MB</bold>
              </td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Bold data means the best result in terms of the corresponding evaluation standard.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>Figure 
<xref ref-type="fig" rid="F2">2</xref> shows that the memory requirement of WinHAP2 received minor changes for test datasets with different numbers of SNPs. By analyzing the WinHAP2 algorithm, we may hypothesize that its memory requirement per genotype should be a constant, and actually the values (Memory)/(#Genotype) are 0.0364, 0.0600, 0.0255, 0.0255, 0.0256, and 0.0256 for the six datasets in Tables 
<xref ref-type="table" rid="T1">1</xref>,
<xref ref-type="table" rid="T2">2</xref> and
<xref ref-type="table" rid="T3">3</xref>, respectively. Most of current large-scale genotyping studies sampled fewer than tens of thousands of individuals
[<xref ref-type="bibr" rid="B29">29</xref>], and their memory requirement using WinHAP2 is estimated to be ~330 MB. So WinHAP2 can handle a large-scale genotyping study with any number of SNPs in the current literature and at least in the near future.</p>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p><bold>Comparison of memory consumption variation trend of WinHAP2 with other methods.</bold> TopLeft: The number of the sequences in the datasets is 50; TopRight: The number of the sequences in the datasets is 100; DownLeft: The number of the sequences in the datasets is 200; DownRight: The number of the sequences in the datasets is 500. As Beagle and 2SNP cannot get the result for some large datasets in our personal computer, the curves about the two programs lack of some points.</p>
        </caption>
        <graphic xlink:href="1471-2105-15-164-2"/>
      </fig>
    </sec>
    <sec>
      <title>Performance of WinHAP2 using different sizes of segments</title>
      <p>To test how the different sizes of segments affect the accuracy and computation load, we run WinHAP on the HapMap real dataset using different sizes of segments.Figure 
<xref ref-type="fig" rid="F3">3</xref> shows that the accuracy will reduce extremely when the segments are too short. At the same time, the longer the segments are, the more running memory is used. Therefore, the moderate size of segments should be chosen.</p>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p><bold>Performance of WinHAP2 using different sizes of segments. (a)</bold> The relationship between switch error rate and the length of segments; <bold>(b)</bold> The relationship between running time and the length of segments; <bold>(c)</bold> The relationship between memory consumption and the length of segments. Explanation see text in this section.</p>
        </caption>
        <graphic xlink:href="1471-2105-15-164-3"/>
      </fig>
    </sec>
    <sec>
      <title>Performance of parallelization</title>
      <p>We further tested the running speed of parallelized WinHAP2 on a server with 16 computing cores. The program was run on a Linux server with 16 800 MHz computing cores and 23.6GB memory. The dataset is a ms dataset which has 500 genotypes with 1,000,000 SNPs. Figure 
<xref ref-type="fig" rid="F4">4</xref> shows that WinHAP2 using 16 computing cores was more than 15 times faster than the single threaded WinHAP2. Considering the running speed of WinHAP2 with single processor has already been several or dozens of times than other high performance algorithms which has been above showed, the parallelized WinHAP2 with 16 computing cores is over 40 times faster than Beagle, and even 50 to 200 times faster than SHAPEIT2 and 2SNP.</p>
      <fig id="F4" position="float">
        <label>Figure 4</label>
        <caption>
          <p><bold>Performance improvements of parallelized WinHAP2.</bold> Runtimes of parallelized WinHAP2 using 1, 2, 4, 8, and 16 computing cores. The program was run on a Linux server with 16 800 MHz computing cores and 23.6GB memory. The dataset is a ms dataset which has 500 genotypes with 1,000,000SNPs.</p>
        </caption>
        <graphic xlink:href="1471-2105-15-164-4"/>
      </fig>
    </sec>
  </sec>
  <sec sec-type="conclusions">
    <title>Conclusions</title>
    <p>With the development of large-scale sequencing technologies, a large amount of genotype data is being generated. Algorithms for large-scale haplotype phasing are needed. Most of existing programs cannot process extremely large datasets because of either space limit or time consumption.</p>
    <p>In this article, we introduced a computer program, WinHAP2, which achieves significant improvements in running speed and memory requirement, with better or comparable precision, for the haplotype phasing problem. WinHAP2 can handle a large-scale genotyping study with over 1,000,000 SNP sites, which is beyond the capability of the other existing programs.</p>
  </sec>
  <sec sec-type="methods">
    <title>Method</title>
    <sec>
      <title>Merging strategy</title>
      <p>After we get the haplotype results of all segments, we must merge them to obtain the whole haplotype result. Here, we introduce how to merge the haplotype result of the <italic>f</italic><sup>th</sup> segment with that of the (<italic>f</italic> + 1)<sup>th</sup> segment. Let
<inline-formula><mml:math id="M1" name="1471-2105-15-164-i1" overflow="scroll"><mml:mfenced open="〈" close="〉"><mml:mrow><mml:msubsup><mml:mi mathvariant="italic">h</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mi mathvariant="italic">f</mml:mi></mml:msubsup><mml:mover accent="true"><mml:msubsup><mml:mi mathvariant="italic">h</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mi mathvariant="italic">f</mml:mi></mml:msubsup><mml:mo stretchy="true">—</mml:mo></mml:mover></mml:mrow></mml:mfenced></mml:math></inline-formula> and
<inline-formula><mml:math id="M2" name="1471-2105-15-164-i2" overflow="scroll"><mml:mfenced open="〈" close="〉"><mml:mrow><mml:msubsup><mml:mi mathvariant="italic">h</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mrow><mml:mi mathvariant="italic">f</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mover accent="true"><mml:msubsup><mml:mi mathvariant="italic">h</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mrow><mml:mi mathvariant="italic">f</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="true">—</mml:mo></mml:mover></mml:mrow></mml:mfenced></mml:math></inline-formula> denote the haplotype results of <italic>i</italic><sup>th</sup> genotype in <italic>f</italic><sup>th</sup> segment and (<italic>f</italic> + 1)<sup>th</sup> segment, respectively. Then, for <italic>i</italic><sup>th</sup> genotype vector, merging is a process to determine the pairing of
<inline-formula><mml:math id="M3" name="1471-2105-15-164-i3" overflow="scroll"><mml:mfenced open="〈" close="〉"><mml:mrow><mml:msubsup><mml:mi mathvariant="italic">h</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mi mathvariant="italic">f</mml:mi></mml:msubsup><mml:mover accent="true"><mml:msubsup><mml:mi mathvariant="italic">h</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mi mathvariant="italic">f</mml:mi></mml:msubsup><mml:mo stretchy="true">—</mml:mo></mml:mover></mml:mrow></mml:mfenced></mml:math></inline-formula> and
<inline-formula><mml:math id="M4" name="1471-2105-15-164-i4" overflow="scroll"><mml:mfenced open="〈" close="〉"><mml:mrow><mml:msubsup><mml:mi mathvariant="italic">h</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mrow><mml:mi mathvariant="italic">f</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mover accent="true"><mml:msubsup><mml:mi mathvariant="italic">h</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mrow><mml:mi mathvariant="italic">f</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="true">—</mml:mo></mml:mover></mml:mrow></mml:mfenced></mml:math></inline-formula>. For example, if
<inline-formula><mml:math id="M5" name="1471-2105-15-164-i5" overflow="scroll"><mml:mfenced open="〈" close="〉"><mml:mrow><mml:msubsup><mml:mi mathvariant="italic">h</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mi mathvariant="italic">f</mml:mi></mml:msubsup><mml:mover accent="true"><mml:msubsup><mml:mi mathvariant="italic">h</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mi mathvariant="italic">f</mml:mi></mml:msubsup><mml:mo stretchy="true">—</mml:mo></mml:mover></mml:mrow></mml:mfenced></mml:math></inline-formula> = 〈0000001001〉 and
<inline-formula><mml:math id="M6" name="1471-2105-15-164-i6" overflow="scroll"><mml:mfenced open="〈" close="〉"><mml:mrow><mml:msubsup><mml:mi mathvariant="italic">h</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mrow><mml:mi mathvariant="italic">f</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mover accent="true"><mml:msubsup><mml:mi mathvariant="italic">h</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mrow><mml:mi mathvariant="italic">f</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="true">—</mml:mo></mml:mover></mml:mrow></mml:mfenced></mml:math></inline-formula> = 〈0100000001〉, we must determine whether the merged result
<inline-formula><mml:math id="M7" name="1471-2105-15-164-i7" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">h</mml:mi><mml:mover accent="true"><mml:mi mathvariant="italic">h</mml:mi><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> is 〈00000010000100100001〉 or 〈00000000010100101000〉. The scalable sliding window described in the previous paper
[<xref ref-type="bibr" rid="B21">21</xref>] is used to complete it.</p>
      <p>Here, we assume that the length of the scalable sliding window ranges from <italic>l</italic><sub>min</sub> to<italic>l</italic><sub>max</sub>, which can be different from the value in the previous paper
[<xref ref-type="bibr" rid="B21">21</xref>]. At the beginning, the left edge of the window locates at the last site but <italic>l</italic><sub>max</sub>-1 of <italic>f</italic><sup>th</sup> segment and the right edge locates at the first site of (<italic>f</italic> + 1)<sup>th</sup> segment. Then the window slides from left to right and ends when the left edge locates at the last site of the <italic>f</italic><sup>th</sup> segment. At each position, if the window only covers the ‘2’s from one segment, this position should be given up and the window slides to next position. Otherwise, we get the most potable haplotype result of each genotype and compute the weight that corresponds to it. The process and definition of the weight was described in the previous paper
[<xref ref-type="bibr" rid="B21">21</xref>]. During the sliding of the window, we always save the current best weight and the result corresponding to it. At last, the two segments are merged using the result with the best weight.</p>
      <p>However, there’re some exceptional cases that the method upper-mentioned cannot be used. Here, we define another window called scope window <italic>W</italic><sub><italic>f</italic></sub> to explain them. <italic>W</italic><sub><italic>f</italic></sub> represents the whole scope that scalable sliding window slides in, thus its left edge locates at the (<italic>l</italic><sub>max</sub>-1)<sup>th</sup> site from right edge of <italic>f</italic><sup>th</sup> segment and the right edge at the (<italic>l</italic><sub>max</sub>-1)<sup>th</sup> site of (<italic>f</italic> + 1)<sup>th</sup> segment. Let
<inline-formula><mml:math id="M8" name="1471-2105-15-164-i8" overflow="scroll"><mml:msubsup><mml:mi mathvariant="italic">g</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mi mathvariant="italic">f</mml:mi></mml:msubsup></mml:math></inline-formula> and
<inline-formula><mml:math id="M9" name="1471-2105-15-164-i9" overflow="scroll"><mml:msubsup><mml:mi mathvariant="italic">g</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mrow><mml:mi mathvariant="italic">f</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:math></inline-formula> denote the <italic>i</italic><sup>th</sup> genotype of <italic>f</italic><sup>th</sup> segment and the <italic>i</italic><sup>th</sup> genotype of (<italic>f</italic> + 1)<sup>th</sup> segment, respectively. Then three exceptional cases are described as follows:</p>
      <p>Case1: For either
<inline-formula><mml:math id="M10" name="1471-2105-15-164-i10" overflow="scroll"><mml:msubsup><mml:mi mathvariant="italic">g</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mi mathvariant="italic">f</mml:mi></mml:msubsup></mml:math></inline-formula> or
<inline-formula><mml:math id="M11" name="1471-2105-15-164-i11" overflow="scroll"><mml:msubsup><mml:mi mathvariant="italic">g</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mrow><mml:mi mathvariant="italic">f</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:math></inline-formula>, there’s no ‘2’ in <italic>W</italic><sub><italic>f</italic></sub>.</p>
      <p>Case2: For both
<inline-formula><mml:math id="M12" name="1471-2105-15-164-i12" overflow="scroll"><mml:msubsup><mml:mi mathvariant="italic">g</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mi mathvariant="italic">f</mml:mi></mml:msubsup></mml:math></inline-formula> and
<inline-formula><mml:math id="M13" name="1471-2105-15-164-i13" overflow="scroll"><mml:msubsup><mml:mi mathvariant="italic">g</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mrow><mml:mi mathvariant="italic">f</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:math></inline-formula>, there’s no ‘2’ in<italic>W</italic><sub><italic>f</italic></sub>.</p>
      <p>Case3: For either
<inline-formula><mml:math id="M14" name="1471-2105-15-164-i14" overflow="scroll"><mml:msubsup><mml:mi mathvariant="italic">g</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mi mathvariant="italic">f</mml:mi></mml:msubsup></mml:math></inline-formula> or
<inline-formula><mml:math id="M15" name="1471-2105-15-164-i15" overflow="scroll"><mml:msubsup><mml:mi mathvariant="italic">g</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mrow><mml:mi mathvariant="italic">f</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:math></inline-formula>, there’s no ‘2’ .</p>
      <p>For the 3 cases which are showed in Figure 
<xref ref-type="fig" rid="F5">5</xref>, scalable sliding window cannot cover the last ‘2’ in <italic>f</italic><sup>th</sup> segment and the first ‘2’ in (<italic>f</italic> + 1)<sup>th</sup> segment at any position. Therefore, paring of
<inline-formula><mml:math id="M16" name="1471-2105-15-164-i16" overflow="scroll"><mml:mfenced open="〈" close="〉"><mml:mrow><mml:msubsup><mml:mi mathvariant="italic">h</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mi mathvariant="italic">f</mml:mi></mml:msubsup><mml:mover accent="true"><mml:msubsup><mml:mi mathvariant="italic">h</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mi mathvariant="italic">f</mml:mi></mml:msubsup><mml:mo stretchy="true">—</mml:mo></mml:mover></mml:mrow></mml:mfenced></mml:math></inline-formula> and
<inline-formula><mml:math id="M17" name="1471-2105-15-164-i17" overflow="scroll"><mml:mfenced open="〈" close="〉"><mml:mrow><mml:msubsup><mml:mi mathvariant="italic">h</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mrow><mml:mi mathvariant="italic">f</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mover accent="true"><mml:msubsup><mml:mi mathvariant="italic">h</mml:mi><mml:mi mathvariant="italic">i</mml:mi><mml:mrow><mml:mi mathvariant="italic">f</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="true">—</mml:mo></mml:mover></mml:mrow></mml:mfenced></mml:math></inline-formula> cannot be determined by sliding window. For case1 and case2, we use simplified 2SNP algorithm which is described in the previous paper
[<xref ref-type="bibr" rid="B21">21</xref>] to determine the phasing result of the last ‘2’ in <italic>f</italic><sup>th</sup> segment and the first ‘2’ in (<italic>f</italic> + 1)<sup>th</sup> segment. For case3, as it’s impossible to determine the paring, we just choose one randomly. Although, as we know, there is probability of 50 percent to get a wrong choice, it hardly affects the precision because the possibility of case3’s occur is extremely low.</p>
      <fig id="F5" position="float">
        <label>Figure 5</label>
        <caption>
          <p><bold>Three cases in which scalable sliding window cannot merge the segments.</bold> Explanation see text in this section.</p>
        </caption>
        <graphic xlink:href="1471-2105-15-164-5"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>Availability and requirements</title>
    <p><bold>Project name</bold>: WinHAP Software</p>
    <p><bold>Project home page</bold>: <ext-link ext-link-type="uri" xlink:href="http://staff.ustc.edu.cn/~xuyun/winhap/index.htm">http://staff.ustc.edu.cn/~xuyun/winhap/index.htm</ext-link></p>
    <p><bold>Operating systems</bold>: Linux(32bit) or Linux(64bit)</p>
    <p><bold>Programming language</bold>: C, C++</p>
    <p><bold>Other requirements</bold>: none</p>
    <p><bold>Any restrictions to use</bold>: none</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors’ contributions</title>
    <p>WP designed and implemented the software. WP and YX designed some strategies in the software. WP and FZ drafted the manuscript. YZ tested the software. YX and FZ provided feedback on the software development and manuscript. All authors read and approved the final manuscript.</p>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>We are indebted to the WinHAP users who tested the program and proposed improvements to make it more user-friendly. Wenhua Cheng, Jiaoyun Yang and Xinxin Zhang also provided many helpful suggestions. Constructive comments from the reviewers are also appreciated.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>National Natural Science Foundation of China (61033009 and 60970085) and Foreign Scholars in University Research and Teaching Programs (B07033). FZ appreciates the support from by the Strategic Priority Research Program of the Chinese Academy of Sciences (XDB13040400), Shenzhen Peacock Plan (KQCX20130628112914301), Shenzhen Research Grant (ZDSY20120617113021359) and China 973 program (2010CB732606). Computing resources were partly provided by the Dawning supercomputing clusters at SIAT CAS.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Selvaraj</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Dixon</surname>
          <given-names>RJ</given-names>
        </name>
        <name>
          <surname>Bansal</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Ren</surname>
          <given-names>B</given-names>
        </name>
        <article-title>Whole-genome haplotype reconstruction using proximity-ligation and shotgun sequencing</article-title>
        <source>Nat Biotechnol</source>
        <year>2013</year>
        <volume>31</volume>
        <issue>12</issue>
        <fpage>1111</fpage>
        <lpage>1118</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.2728</pub-id>
        <?supplied-pmid 24185094?>
        <pub-id pub-id-type="pmid">24185094</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Adey</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Burton</surname>
          <given-names>JN</given-names>
        </name>
        <name>
          <surname>Kitzman</surname>
          <given-names>JO</given-names>
        </name>
        <name>
          <surname>Hiatt</surname>
          <given-names>JB</given-names>
        </name>
        <name>
          <surname>Lewis</surname>
          <given-names>AP</given-names>
        </name>
        <name>
          <surname>Martin</surname>
          <given-names>BK</given-names>
        </name>
        <name>
          <surname>Qiu</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Lee</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Shendure</surname>
          <given-names>J</given-names>
        </name>
        <article-title>The haplotype-resolved genome and epigenome of the aneuploid HeLa cancer cell line</article-title>
        <source>Nature</source>
        <year>2013</year>
        <volume>500</volume>
        <issue>7461</issue>
        <fpage>207</fpage>
        <lpage>211</lpage>
        <pub-id pub-id-type="doi">10.1038/nature12064</pub-id>
        <?supplied-pmid 23925245?>
        <pub-id pub-id-type="pmid">23925245</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="book">
        <name>
          <surname>Gusfield</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Haplotyping as perfect phylogeny: conceptual framework and efficient solutions</article-title>
        <source>Proceedings of the Sixth Annual International Conference on Computational Biology</source>
        <year>2002</year>
        <publisher-name>New York: ACM</publisher-name>
        <fpage>166</fpage>
        <lpage>175</lpage>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="book">
        <name>
          <surname>Gusfield</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Haplotype inference by pure parsimony</article-title>
        <source>Combinatorial Pattern Matching</source>
        <year>2003</year>
        <publisher-name>Berlin Heidelberg: Springer</publisher-name>
        <fpage>144</fpage>
        <lpage>155</lpage>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Excoffier</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Slatkin</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Maximum-likelihood estimation of molecular haplotype frequencies in a diploid population</article-title>
        <source>Mol Biol Evol</source>
        <year>1995</year>
        <volume>12</volume>
        <issue>5</issue>
        <fpage>921</fpage>
        <lpage>927</lpage>
        <?supplied-pmid 7476138?>
        <pub-id pub-id-type="pmid">7476138</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Wang</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Xu</surname>
          <given-names>Y</given-names>
        </name>
        <article-title>Haplotype inference by maximum parsimony</article-title>
        <source>Bioinformatics</source>
        <year>2003</year>
        <volume>19</volume>
        <issue>14</issue>
        <fpage>1773</fpage>
        <lpage>1780</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btg239</pub-id>
        <?supplied-pmid 14512348?>
        <pub-id pub-id-type="pmid">14512348</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bonizzoni</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Della Vedova</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Dondi</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>J</given-names>
        </name>
        <article-title>The haplotyping problem: an overview of computational models and solutions</article-title>
        <source>J Comput Sci Technol</source>
        <year>2003</year>
        <volume>18</volume>
        <issue>6</issue>
        <fpage>675</fpage>
        <lpage>688</lpage>
        <pub-id pub-id-type="doi">10.1007/BF02945456</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Lancia</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Pinotti</surname>
          <given-names>MC</given-names>
        </name>
        <name>
          <surname>Rizzi</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Haplotyping populations by pure parsimony: Complexity of exact and approximation algorithms</article-title>
        <source>INFORMS J On Computing</source>
        <year>2004</year>
        <volume>16</volume>
        <issue>4</issue>
        <fpage>348</fpage>
        <lpage>359</lpage>
        <pub-id pub-id-type="doi">10.1287/ijoc.1040.0085</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Chung</surname>
          <given-names>RH</given-names>
        </name>
        <name>
          <surname>Gusfield</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Perfect phylogeny haplotyper: haplotype inferral using a tree model</article-title>
        <source>Bioinformatics</source>
        <year>2003</year>
        <volume>19</volume>
        <issue>6</issue>
        <fpage>780</fpage>
        <lpage>781</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btg078</pub-id>
        <?supplied-pmid 12691994?>
        <pub-id pub-id-type="pmid">12691994</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bafna</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Gusfield</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Hannenhalli</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Yooseph</surname>
          <given-names>S</given-names>
        </name>
        <article-title>A note on efficient computation of haplotypes via perfect phylogeny</article-title>
        <source>J Comput Biol</source>
        <year>2004</year>
        <volume>11</volume>
        <issue>5</issue>
        <fpage>858</fpage>
        <lpage>866</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2004.11.858</pub-id>
        <?supplied-pmid 15700406?>
        <pub-id pub-id-type="pmid">15700406</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Jajamovich</surname>
          <given-names>GH</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>X</given-names>
        </name>
        <article-title>Maximum-parsimony haplotype inference based on sparse representations of genotypes</article-title>
        <source>Signal Processing, IEEE Transactions on</source>
        <year>2012</year>
        <volume>60</volume>
        <issue>4</issue>
        <fpage>2013</fpage>
        <lpage>2023</lpage>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Qin</surname>
          <given-names>ZS</given-names>
        </name>
        <name>
          <surname>Niu</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Liu</surname>
          <given-names>JS</given-names>
        </name>
        <article-title>Partition-ligation-expectation-maximization algorithm for haplotype inference with single-nucleotide polymorphisms</article-title>
        <source>Am J Hum Genet</source>
        <year>2002</year>
        <volume>71</volume>
        <issue>5</issue>
        <fpage>1242</fpage>
        <lpage>1247</lpage>
        <pub-id pub-id-type="doi">10.1086/344207</pub-id>
        <?supplied-pmid 12452179?>
        <pub-id pub-id-type="pmid">12452179</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kimmel</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Shamir</surname>
          <given-names>R</given-names>
        </name>
        <article-title>GERBIL: Genotype resolution and block identification using likelihood</article-title>
        <source>Proc Natl Acad Sci U S A</source>
        <year>2005</year>
        <volume>102</volume>
        <issue>1</issue>
        <fpage>158</fpage>
        <lpage>162</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.0404730102</pub-id>
        <?supplied-pmid 15615859?>
        <pub-id pub-id-type="pmid">15615859</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zhao</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Xu</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Chen</surname>
          <given-names>G</given-names>
        </name>
        <article-title>A better block partition and ligation strategy for individual haplotyping</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <issue>23</issue>
        <fpage>2720</fpage>
        <lpage>2725</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btn519</pub-id>
        <?supplied-pmid 18845583?>
        <pub-id pub-id-type="pmid">18845583</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Niu</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Qin</surname>
          <given-names>ZS</given-names>
        </name>
        <name>
          <surname>Xu</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Liu</surname>
          <given-names>JS</given-names>
        </name>
        <article-title>Bayesian haplotype inference for multiple linked single-nucleotide polymorphisms</article-title>
        <source>Am J Hum Genet</source>
        <year>2002</year>
        <volume>70</volume>
        <issue>1</issue>
        <fpage>157</fpage>
        <lpage>169</lpage>
        <pub-id pub-id-type="doi">10.1086/338446</pub-id>
        <?supplied-pmid 11741196?>
        <pub-id pub-id-type="pmid">11741196</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Browning</surname>
          <given-names>SR</given-names>
        </name>
        <name>
          <surname>Browning</surname>
          <given-names>BL</given-names>
        </name>
        <article-title>Rapid and accurate haplotype phasing and missing-data inference for whole-genome association studies by use of localized haplotype clustering</article-title>
        <source>Am J Hum Genet</source>
        <year>2007</year>
        <volume>81</volume>
        <issue>5</issue>
        <fpage>1084</fpage>
        <lpage>1097</lpage>
        <pub-id pub-id-type="doi">10.1086/521987</pub-id>
        <?supplied-pmid 17924348?>
        <pub-id pub-id-type="pmid">17924348</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Williams</surname>
          <given-names>AL</given-names>
        </name>
        <name>
          <surname>Patterson</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Glessner</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Hakonarson</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Reich</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Phasing of many thousands of genotyped samples</article-title>
        <source>Am J Hum Genet</source>
        <year>2012</year>
        <volume>91</volume>
        <issue>2</issue>
        <fpage>238</fpage>
        <lpage>251</lpage>
        <pub-id pub-id-type="doi">10.1016/j.ajhg.2012.06.013</pub-id>
        <?supplied-pmid 22883141?>
        <pub-id pub-id-type="pmid">22883141</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Delaneau</surname>
          <given-names>O</given-names>
        </name>
        <name>
          <surname>Marchini</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Zagury</surname>
          <given-names>JF</given-names>
        </name>
        <article-title>A linear complexity phasing method for thousands of genomes</article-title>
        <source>Nat Methods</source>
        <year>2012</year>
        <volume>9</volume>
        <issue>2</issue>
        <fpage>179</fpage>
        <lpage>181</lpage>
        <pub-id pub-id-type="pmid">22138821</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Delaneau</surname>
          <given-names>O</given-names>
        </name>
        <name>
          <surname>Zagury</surname>
          <given-names>JF</given-names>
        </name>
        <name>
          <surname>Marchini</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Improved whole-chromosome phasing for disease and population genetic studies</article-title>
        <source>Nat Methods</source>
        <year>2013</year>
        <volume>10</volume>
        <issue>1</issue>
        <fpage>5</fpage>
        <lpage>6</lpage>
        <pub-id pub-id-type="doi">10.1038/nchembio.1414</pub-id>
        <?supplied-pmid 23269371?>
        <pub-id pub-id-type="pmid">23269371</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Brinza</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Zelikovsky</surname>
          <given-names>A</given-names>
        </name>
        <article-title>2SNP: scalable phasing based on 2-SNP haplotypes</article-title>
        <source>Bioinformatics</source>
        <year>2006</year>
        <volume>22</volume>
        <issue>3</issue>
        <fpage>371</fpage>
        <lpage>373</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bti785</pub-id>
        <?supplied-pmid 16287933?>
        <pub-id pub-id-type="pmid">16287933</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Xu</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Cheng</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Nie</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Zhou</surname>
          <given-names>F</given-names>
        </name>
        <article-title>WinHAP: an efficient haplotype phasing algorithm based on scalable sliding windows</article-title>
        <source>PLoS One</source>
        <year>2012</year>
        <volume>7</volume>
        <issue>8</issue>
        <fpage>e43163</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0043163</pub-id>
        <?supplied-pmid 22905221?>
        <pub-id pub-id-type="pmid">22905221</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Rieder</surname>
          <given-names>MJ</given-names>
        </name>
        <name>
          <surname>Taylor</surname>
          <given-names>SL</given-names>
        </name>
        <name>
          <surname>Clark</surname>
          <given-names>AG</given-names>
        </name>
        <name>
          <surname>Nickerson</surname>
          <given-names>DA</given-names>
        </name>
        <article-title>Sequence variation in the human angiotensin converting enzyme</article-title>
        <source>Nat Genet</source>
        <year>1999</year>
        <volume>22</volume>
        <issue>1</issue>
        <fpage>59</fpage>
        <lpage>62</lpage>
        <pub-id pub-id-type="doi">10.1038/8760</pub-id>
        <?supplied-pmid 10319862?>
        <pub-id pub-id-type="pmid">10319862</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Daly</surname>
          <given-names>MJ</given-names>
        </name>
        <name>
          <surname>Rioux</surname>
          <given-names>JD</given-names>
        </name>
        <name>
          <surname>Schaffner</surname>
          <given-names>SF</given-names>
        </name>
        <name>
          <surname>Hudson</surname>
          <given-names>TJ</given-names>
        </name>
        <name>
          <surname>Lander</surname>
          <given-names>ES</given-names>
        </name>
        <article-title>High-resolution haplotype structure in the human genome</article-title>
        <source>Nat Genet</source>
        <year>2001</year>
        <volume>29</volume>
        <issue>2</issue>
        <fpage>229</fpage>
        <lpage>232</lpage>
        <pub-id pub-id-type="doi">10.1038/ng1001-229</pub-id>
        <?supplied-pmid 11586305?>
        <pub-id pub-id-type="pmid">11586305</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kerem</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Rommens</surname>
          <given-names>JM</given-names>
        </name>
        <name>
          <surname>Buchanan</surname>
          <given-names>JA</given-names>
        </name>
        <name>
          <surname>Markiewicz</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Cox</surname>
          <given-names>TK</given-names>
        </name>
        <name>
          <surname>Chakravarti</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Buchwald</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Tsui</surname>
          <given-names>LC</given-names>
        </name>
        <article-title>Identification of the cystic fibrosis gene: genetic analysis</article-title>
        <source>Science</source>
        <year>1989</year>
        <volume>245</volume>
        <issue>4922</issue>
        <fpage>1073</fpage>
        <lpage>1080</lpage>
        <pub-id pub-id-type="doi">10.1126/science.2570460</pub-id>
        <?supplied-pmid 2570460?>
        <pub-id pub-id-type="pmid">2570460</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal">
        <collab>International HapMap 3 Consortium</collab>
        <article-title>Integrating common and rare genetic variation in diverse human populations</article-title>
        <source>Nature</source>
        <year>2010</year>
        <volume>467</volume>
        <issue>7311</issue>
        <fpage>52</fpage>
        <lpage>58</lpage>
        <pub-id pub-id-type="doi">10.1038/nature09298</pub-id>
        <?supplied-pmid 20811451?>
        <pub-id pub-id-type="pmid">20811451</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Hudson</surname>
          <given-names>RR</given-names>
        </name>
        <article-title>Generating samples under a Wright-Fisher neutral model of genetic variation</article-title>
        <source>Bioinformatics</source>
        <year>2002</year>
        <volume>18</volume>
        <issue>2</issue>
        <fpage>337</fpage>
        <lpage>338</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/18.2.337</pub-id>
        <?supplied-pmid 11847089?>
        <pub-id pub-id-type="pmid">11847089</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Delaneau</surname>
          <given-names>O</given-names>
        </name>
        <name>
          <surname>Coulonges</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Boelle</surname>
          <given-names>PY</given-names>
        </name>
        <name>
          <surname>Nelson</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Spadoni</surname>
          <given-names>JL</given-names>
        </name>
        <name>
          <surname>Zagury</surname>
          <given-names>JF</given-names>
        </name>
        <article-title>ISHAPE: new rapid and accurate software for haplotyping</article-title>
        <source>BMC Bioinformatics</source>
        <year>2007</year>
        <volume>8</volume>
        <fpage>205</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-8-205</pub-id>
        <?supplied-pmid 17573965?>
        <pub-id pub-id-type="pmid">17573965</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Marchini</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Cutler</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Patterson</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Stephens</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Eskin</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Halperin</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Lin</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Qin</surname>
          <given-names>ZS</given-names>
        </name>
        <name>
          <surname>Munro</surname>
          <given-names>HM</given-names>
        </name>
        <name>
          <surname>Abecasis</surname>
          <given-names>GR</given-names>
        </name>
        <name>
          <surname>Donnelly</surname>
          <given-names>P</given-names>
        </name>
        <collab>for the International HapMap Consortium</collab>
        <article-title>A comparison of phasing algorithms for trios and unrelated individuals</article-title>
        <source>Am J Hum Genet</source>
        <year>2006</year>
        <volume>78</volume>
        <issue>3</issue>
        <fpage>437</fpage>
        <lpage>450</lpage>
        <pub-id pub-id-type="doi">10.1086/500808</pub-id>
        <?supplied-pmid 16465620?>
        <pub-id pub-id-type="pmid">16465620</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Larsson</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Wahlstrand</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Hedblad</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Hedner</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Kjeldsen</surname>
          <given-names>SE</given-names>
        </name>
        <name>
          <surname>Melander</surname>
          <given-names>O</given-names>
        </name>
        <name>
          <surname>Lindahl</surname>
          <given-names>P</given-names>
        </name>
        <article-title>Hypertension and genetic variation in endothelial-specific genes</article-title>
        <source>PLoS One</source>
        <year>2013</year>
        <volume>8</volume>
        <issue>4</issue>
        <fpage>e62035</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0062035</pub-id>
        <?supplied-pmid 23637959?>
        <pub-id pub-id-type="pmid">23637959</pub-id>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
