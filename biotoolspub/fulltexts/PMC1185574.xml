<?open_access?>
<front>
  <?epub 12-August-2005?>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Nucleic Acids Res</journal-id>
    <journal-id journal-id-type="publisher-id">Nucleic Acids Research</journal-id>
    <journal-title>Nucleic Acids Research</journal-title>
    <issn pub-type="ppub">0305-1048</issn>
    <issn pub-type="epub">1362-4962</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">1185574</article-id>
    <article-id pub-id-type="doi">10.1093/nar/gki767</article-id>
    <article-id pub-id-type="pmid">16100379</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Using multiple alignments to improve seeded local alignment algorithms</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Flannick</surname>
          <given-names>Jason</given-names>
        </name>
        <xref ref-type="corresp" rid="cor1">*</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Batzoglou</surname>
          <given-names>Serafim</given-names>
        </name>
      </contrib>
      <aff>
        <institution>Department of Computer Science, Stanford University</institution>
        <addr-line>Stanford, CA 94304, USA</addr-line>
      </aff>
    </contrib-group>
    <author-notes>
      <corresp id="cor1"><sup>*</sup>To whom correspondence should be addressed. Tel: +1 650 289 0295; Fax: +1 650 725 1449; Email: <email>flannick@cs.stanford.edu</email></corresp>
      <fn>
        <p>Correspondence may also be addressed to Serafim Batzoglou. Tel: +1 650 723 3334; Fax +1 650 725 1449; Email: <email>serafim@cs.stanford.edu</email></p>
      </fn>
    </author-notes>
    <!--For NAR: both ppub and collection dates generated for PMC processing 1/27/05 beck-->
    <pub-date pub-type="collection">
      <year>2005</year>
    </pub-date>
    <pub-date pub-type="ppub">
      <year>2005</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>12</day>
      <month>8</month>
      <year>2005</year>
    </pub-date>
    <volume>33</volume>
    <issue>14</issue>
    <fpage>4563</fpage>
    <lpage>4577</lpage>
    <history>
      <date date-type="received">
        <day>08</day>
        <month>6</month>
        <year>2005</year>
      </date>
      <date date-type="rev-recd">
        <day>06</day>
        <month>7</month>
        <year>2005</year>
      </date>
      <date date-type="accepted">
        <day>27</day>
        <month>7</month>
        <year>2005</year>
      </date>
    </history>
    <copyright-statement>© The Author 2005. Published by Oxford University Press. All rights reserved</copyright-statement>
    <copyright-year>2005</copyright-year>
    <license license-type="openaccess">
      <p>The online version of this article has been published under an open access model. Users are entitled to use, reproduce, disseminate, or display the open access version of this article for non-commercial purposes provided that: the original authorship is properly and fully attributed; the Journal and Oxford University Press are attributed as the original place of publication with the correct citation details given; if an article is subsequently reproduced or disseminated not in its entirety but only in part or as a derivative work this must be clearly indicated. For commercial re-use, please contact <email>journals.permissions@oupjournals.org</email></p>
    </license>
    <abstract>
      <p>Multiple alignments among genomes are becoming increasingly prevalent. This trend motivates the development of tools for efficient homology search between a query sequence and a database of multiple alignments. In this paper, we present an algorithm that uses the information implicit in a multiple alignment to dynamically build an index that is weighted most heavily towards the promising regions of the multiple alignment. We have implemented Typhon, a local alignment tool that incorporates our indexing algorithm, which our test results show to be more sensitive than algorithms that index only a sequence. This suggests that when applied on a whole-genome scale, Typhon should provide improved homology searches in time comparable to existing algorithms.</p>
    </abstract>
  </article-meta>
</front>
<body>
  <sec>
    <title>INTRODUCTION</title>
    <p>Sequence alignment is certainly one of the most well-developed and pervasive topics of computational molecular biology. Algorithms in this vein are widely used for tasks varying from the comparative analysis of rodent (<xref ref-type="bibr" rid="b1">1</xref>–<xref ref-type="bibr" rid="b5">5</xref>) and chicken (<xref ref-type="bibr" rid="b6">6</xref>) genomes to the construction of networks of protein interactions (<xref ref-type="bibr" rid="b7">7</xref>). With the current sequencing of many genomes (<xref ref-type="bibr" rid="b8">8</xref>), fast and sensitive sequence alignment algorithms will likely maintain or increase their role in biological research.</p>
    <p>As more and more genomic data has become available, algorithms for locally aligning query sequences to genomic databases have become increasingly important (<xref ref-type="bibr" rid="b9">9</xref>–<xref ref-type="bibr" rid="b13">13</xref>). Because the exact Smith–Waterman (<xref ref-type="bibr" rid="b14">14</xref>) algorithm is impractical for large sequences, database search techniques are almost always based upon the paradigm of seeded alignments. The BLAST algorithm (<xref ref-type="bibr" rid="b10">10</xref>) was pivotal in popularizing such a technique, and it has since been incorporated into many tools, a few of which are BLASTZ (<xref ref-type="bibr" rid="b4">4</xref>), BLAT (<xref ref-type="bibr" rid="b13">13</xref>) and Exonerate (<xref ref-type="bibr" rid="b15">15</xref>). In such algorithms, a set of seeds is first generated between the database and the query. Each seed is then extended to determine whether it is a part of high scoring local alignment. Extensions typically consist of two phases: first the seed is extended into an un-gapped alignment, and if this alignment scores above a threshold, the seed is then extended with the allowance of gaps. An enhancement to this simple model is to extend only pairs of seeds close to each other (<xref ref-type="bibr" rid="b11">11</xref>). Seeds for the BLAST algorithm are traditionally fixed-length words present in both the database and the query, with the word length referred to as the seed's weight. This leads to an inevitable speed/sensitivity trade-off; heavier seeds prune a larger fraction of the search space but miss more alignments than do seeds with a smaller weight.</p>
    <p>In recent years, the introduction of spaced seeds has led to significantly improved local alignment algorithms (<xref ref-type="bibr" rid="b12">12</xref>,<xref ref-type="bibr" rid="b16">16</xref>–<xref ref-type="bibr" rid="b20">20</xref>). Spaced seeds allow non-contiguous patterns of matching nucleotides to initiate a local alignment, and algorithms have been developed (<xref ref-type="bibr" rid="b17">17</xref>–<xref ref-type="bibr" rid="b22">22</xref>) to compute the probability that a seed will be found within an un-gapped alignment of a given length between two sequences. The optimal seed can then be chosen as the seed that maximizes this probability. It is useful to think of un-gapped alignments of homologous regions as being generated by a probabilistic model that specifies the distribution over matches and mismatches (<xref ref-type="bibr" rid="b17">17</xref>,<xref ref-type="bibr" rid="b20">20</xref>,<xref ref-type="bibr" rid="b22">22</xref>). The model outputs a bit string where each position corresponds to a position in the alignment; the bit is 1 if there is a match in the alignment and 0 if there is a mismatch. While higher-order models are possible (<xref ref-type="bibr" rid="b19">19</xref>), in this article we will focus on models that output a 1 independently in each position with a fixed probability, which is called the similarity level (<xref ref-type="bibr" rid="b12">12</xref>).</p>
    <p>In addition to being provably more sensitive than consecutive seeds in some cases (<xref ref-type="bibr" rid="b21">21</xref>), spaced seeds allow an important new speed/sensitivity trade-off. Rather than lowering the weight of a seed to boost sensitivity, one can index multiple seeds per position and obtain a linear, rather than exponential, rise in the size of the search space (<xref ref-type="bibr" rid="b18">18</xref>,<xref ref-type="bibr" rid="b20">20</xref>). Spaced seed design operates under a resource-constrained paradigm (<xref ref-type="bibr" rid="b17">17</xref>), where the weight and number of seeds is specified and the goal is to design an optimal set of seeds that fits these constraints.</p>
    <p>In this article, we seek to build on these developments by taking advantage of increasing amounts of available genomic data as well as rapidly improving global multiple sequence alignment algorithms (<xref ref-type="bibr" rid="b23">23</xref>–<xref ref-type="bibr" rid="b26">26</xref>). We predict that in the near future, these trends will lead to the proliferation of genomic databases consisting of multiple alignments. Information implicit in an alignment has been used to aid in a variety of bioinformatics tasks (<xref ref-type="bibr" rid="b27">27</xref>–<xref ref-type="bibr" rid="b30">30</xref>), and, similarly, one can hope that a multiple alignment can be utilized to improve database search algorithms. Previous research on searching between multiple alignments has concentrated on position specific scoring schemes (<xref ref-type="bibr" rid="b11">11</xref>,<xref ref-type="bibr" rid="b31">31</xref>,<xref ref-type="bibr" rid="b32">32</xref>). PSI-BLAST (<xref ref-type="bibr" rid="b11">11</xref>) is the most popular such program; given a query sequence, it builds a multiple alignment, or profile, from a set of high scoring alignments of the query to the database. It then uses the constructed profile to iterate searches for improved sensitivity. Approaches in this vein have been successful, but in this paper, our focus is orthogonal to such techniques.</p>
    <p>The problem we tackle is to align a query sequence to a fixed multiple alignment database. As an example, it may be desirable to augment a multiple alignment of mammalian genomes with a newly sequenced mammalian or vertebrate genome. Our approach uses the multiple alignment database to improve search sensitivity over that obtained using only a sequence database. To do this, we extend the resource-constrained paradigm to apply not only to seed design but also to seed allocation; we allow different positions in the database to index different sets of seeds and determine the best way to do so based on the information implicit in the multiple alignment.</p>
    <p>We have implemented a local alignment tool, Typhon, which incorporates our indexing algorithm. Tests on real world data shows that Typhon is substantially more sensitive than standard sequence indexing algorithms as well as algorithms that index multiple alignments without using our dynamic indexing methodology. The performance improvement is most dramatic for indexes with a small number of spaced seeds, which is important for large-scale database searches. Source code for Typhon is available under the GNU public license at <ext-link ext-link-type="uri" xlink:href="http://typhon.stanford.edu"/>.</p>
  </sec>
  <sec>
    <title>ALGORITHMS</title>
    <sec>
      <title>Overview</title>
      <p>We are initially given a multiple alignment, a hypothetical query sequence and a phylogenetic tree of all species in the alignment as well as the query. We convert the multiple alignment into a probabilistic profile, where each position in the profile is a tuple of six numbers (<italic>p</italic><sub>present</sub>, <italic>p</italic><sub>A</sub>, <italic>p</italic><sub>C</sub>, <italic>p</italic><sub>T</sub>, <italic>p</italic><sub>G</sub>, <italic>p</italic><sub>id</sub>). The first number, <italic>p</italic><sub>present</sub>, is the existence probability. It represents the probability that a homologue of the position is present in the query or, equivalently, the probability that the query would align to the position without a gap. The next four values indicate the respective conditional probabilities that the homologous position contains an A, C, G or T, given that there exists a homologous position in the query. The nucleotide with the highest such value is called the consensus character; gaps are ignored when determining this. Note that the consensus character in principle depends on the position of the query in the tree. The final value, <italic>p</italic><sub>id</sub>, is the conditional similarity level (<xref ref-type="bibr" rid="b12">12</xref>) of the position given that there exists a homologous position in the query. In other words, it represents the probability that the corresponding position in the query sequence contains the consensus character of the multiple alignment. For the remainder of this paper, we will use the terms profile and probabilistic profile interchangeably.</p>
      <p>To begin with, we define several terms. A seed of weight <italic>w</italic> is a sequence of possibly non-consecutive positions (<italic>i</italic><sub>1</sub> &lt; ·· &lt; <italic>i<sub>w</sub></italic>); by convention, <italic>i<sub>1</sub></italic> = 0. The span of a seed is defined as <italic>i<sub>w</sub></italic> − <italic>i</italic><sub>1</sub> + 1. We define an un-gapped homology <italic>h</italic> of length <italic>l</italic> beginning at position <italic>p</italic> in sequence <italic>s</italic> and position <italic>q</italic> in sequence <italic>t</italic> as two sub-sequences (<italic>s</italic>[<italic>p</italic>], …, <italic>s</italic>[<italic>p</italic> + <italic>l</italic>]) and (<italic>t</italic>[<italic>q</italic>], …, <italic>t</italic>[<italic>q</italic> + <italic>l</italic>]) that have descended from a common ancestor; one can think of such a homology as a bit string of length <italic>l</italic> with <italic>h</italic>[<italic>i</italic>] = 1 if and only if <italic>s</italic>[<italic>p</italic> + <italic>i</italic>] = t[<italic>q</italic> + <italic>i</italic>]. A seed is said to match the homology at offset <italic>j</italic> if <italic>h</italic>[<italic>j</italic> + <italic>i</italic><sub>1</sub>] = 1, …, <italic>h</italic>[<italic>j</italic> + <italic>i<sub>w</sub></italic>] = 1, and indexing a seed at position <italic>p</italic> in a sequence corresponds to recording in the index the presence of (<italic>s</italic>[<italic>p</italic> + <italic>i</italic><sub>1</sub>], …, <italic>s</italic>[<italic>p</italic> + <italic>i<sub>w</sub></italic>]) at position <italic>p</italic>. A seed matches a homology if we index the seed at every position in the homology and the seed matches the homology at at least one offset. A set of seeds matches a homology if we index every seed in the set at every position in the homology and at least one seed in the set matches the homology.</p>
      <p>We extend these notions to a multiple alignment in a simple manner; homologies are defined to exist between the query and the alignment. An un-gapped homology beginning at position <italic>p</italic> in the alignment and position <italic>q</italic> in the query is a set of sub-sequences, one from each species in the alignment as well as the query, that have all descended from a common ancestor. In this case, we define <italic>h</italic>[<italic>i</italic>] = 1 if and only if the consensus character at position <italic>p</italic> + <italic>i</italic> in the alignment matches the query character at position <italic>q</italic> + <italic>i</italic>. Indexing a seed at a position in a multiple alignment corresponds to recording the presence of the string consisting of the consensus characters of the multiple alignment. The notion of a seed matching a homology follows from these definitions. We observe that more complex definitions of homology between a query and an alignment are possible, but we do not address them here.</p>
      <p>With these definitions, we can formulate our problem as follows:</p>
      <p>Given a probabilistic profile, a set of candidate seeds and a budget <italic>B</italic>, index a subset of the candidate set at each position in the profile such that the average number of seeds indexed per position of the database does not exceed <italic>B</italic>. The goal is to maximize the expected number of homologies matched by at least one seed.</p>
      <p>Without a budget constraint, this value would obviously be maximized by indexing every seed in the candidate set at every position in the alignment. The value of the budget determines the size of the index and, therefore, the expected number of seed matches; higher values will result in more seed extensions and therefore lead to larger running times. Algorithms that build indexes from sequence databases assign the same set of seeds, with cardinality equal to the budget, to each position in the database. Because we have extra information in the multiple alignment, we can be more flexible. Intuitively, we would like to assign more seeds to positions where this increase is most likely to result in additional detected homologies. We must respect the constraint that the average number of seeds indexed per position does not exceed our budget.</p>
      <p>Within a multiple alignment, local rates of conservation vary widely due to both random fluctuations in the number of accumulated mutations as well as differential selective pressures. Both of these effects cause some portions of the multiple alignment to be naturally less likely to contain a match to a homologue in a query sequence. Our algorithm exploits this property to determine how to vary the subset of candidate seeds indexed at each position. Specifically, we use local conservation rates to partition the multiple alignment into regions, which are contiguous blocks of positions whose boundaries reflect changes in the conservation level among species in the alignment (<xref ref-type="fig" rid="fig1">Figure 1</xref>).</p>
      <p>Our approach, then, is to change the set of seeds assigned on a region-by-region basis. By assigning fewer seeds to unpromising regions, we can pay more attention to promising regions and increase sensitivity while still respecting our budget. A high-level outline of our algorithm is shown in <xref ref-type="fig" rid="fig2">Figure 2</xref>. First, we convert the multiple alignment into a probabilistic profile. We then use a hidden Markov model to partition the profile into a set of regions where each region gives us the necessary information to evaluate the probability that a homology will exist in that region as well as the probability that a seed will match the homology. Finally, we choose the set of seeds to assign to each position based upon the region to which it belongs. We aim to assign enough seeds to ensure a high probability of finding a match but not too many to waste our budget when it can be used more effectively elsewhere.</p>
      <p>We note that in theory one could use a different candidate set of seeds for each position. Such an approach would be particularly useful in cases where highly variable similarity levels strongly influence the optimal shape of the candidate seeds. A typical case is coding exons, where seeds with significant 3-periodicity such as the (0,1,2,8,9,11,12,14,15,17,18) seed (17) have been shown to perform well because they accommodate 3rd-base wobble positions. We do not pursue these options here; rather, we fix the candidate set for all regions and vary only the number of seeds assigned to each position.</p>
    </sec>
    <sec>
      <title>Generation of the profile</title>
      <p>Our first goal is to convert the alignment into a probabilistic profile. We assume that we are given a phylogenetic tree and the position in the tree at which we expect the query to lie; we root this tree at the query. For each position, we work our way up from the leaves, obtaining <italic>p</italic><sub>present</sub> and <italic>p</italic><sub>N</sub> for each nucleotide N ∈ {A, C, T, G} at each node in the tree; we obtain <italic>p</italic><sub>id</sub> only at the root. A leaf has <italic>p</italic><sub>present</sub> = 1 if the corresponding sequence is un-gapped at the position in the multiple alignment and 0 otherwise. Furthermore, it has probability <italic>p</italic><sub>N</sub> = 1 for the nucleotide present in the sequence; if <italic>p</italic><sub>present</sub> is 0, then we set <italic>p</italic><sub>N</sub> = 0 for all N.</p>
      <p>As we work up the tree, we obtain <italic>p</italic><sub>present</sub> and <italic>p</italic><sub>N</sub> independently. For each internal node, we obtain <italic>p</italic><sub>N</sub> by applying Felsenstein's algorithm with a Kimura rate matrix (<xref ref-type="bibr" rid="b34">34</xref>–<xref ref-type="bibr" rid="b36">36</xref>). Since some children can have <italic>p</italic><sub>N</sub> = 0 for each nucleotide, we consider only children for which at least one <italic>p</italic><sub>N</sub> is positive. The task of obtaining <italic>p</italic><sub>present</sub> is somewhat more problematic because there is not as well-developed an evolutionary theory for insertions and deletions as there is for nucleotide substitutions. For a node <italic>n</italic>, our method sets <italic>p</italic><sub>present</sub>(<italic>n</italic>) to be a weighted average ∑<sub>i</sub> <italic>w<sub>i</sub></italic> × <italic>p</italic><sub>present</sub>(<italic>n<sub>i</sub></italic>), where the sum is taken over all children of <italic>n</italic>. We choose the weight assigned to a child to be proportional to the inverse of the branch length between the parent and the child and normalize the weights sum to one.</p>
      <p>When we have reached the root, we choose <italic>p</italic><sub>id</sub> as <italic>max</italic><sub>N∈{A, C, T, G}</sub>(<italic>p</italic><sub>N</sub>). This is because the maximum <italic>p</italic><sub>N</sub> corresponds to the conditional probability that the consensus character of the multiple alignment is present at the homologous position in the query, given that there is a homologous position in the query. Because at a given position in the multiple alignment we choose the consensus character as the character to record in the index, the average value of <italic>p</italic><sub>id</sub> obtained in such a way over a region will correspond to the conditional similarity level of the alignment of that region to a homologue in the query.</p>
      <p>It turns out that reconstructing the profile in this manner results in empirically slightly inaccurate values. In particular, it tends to overestimate actual values of <italic>p</italic><sub>id</sub>, which presents difficulties because small changes in the value of <italic>p</italic><sub>id</sub> can have large effects on the estimated hit probability of a seed (<xref ref-type="bibr" rid="b12">12</xref>,<xref ref-type="bibr" rid="b18">18</xref>). Furthermore, such an estimate for <italic>p</italic><sub>present</sub> is heuristic and is not guaranteed to yield accurate predictions.</p>
      <p>A complete treatment of profile reconstruction is beyond the scope of this paper. For our purposes, we plotted the predicted versus experimental values of <italic>p</italic><sub>present</sub> and <italic>p</italic><sub>id</sub> for several species and assessed accuracy. To do this, we began with a multiple alignment, removed one species as the test species, and converted the remaining alignment to a probabilistic profile using the method described above. We then grouped the values of <italic>p</italic><sub>present</sub> and <italic>p</italic><sub>id</sub> as predicted by the profile into a finite set of buckets, each representing a discrete value.</p>
      <p>For each discrete value of <italic>p</italic><sub>present</sub> and <italic>p</italic><sub>id</sub> as predicted by the profile, we calculated the experimental values of <italic>p</italic><sub>present</sub> and <italic>p</italic><sub>id</sub> for the test species as follows. To obtain the experimental <italic>p</italic><sub>present</sub> for a given discrete predicted value, we first counted the total number of positions in the profile at which <italic>p</italic><sub>present</sub> was that value. Of those positions, we counted the number of positions that were un-gapped in the test species. The experimental value was then determined as the latter number divided by the former. The experimental values of <italic>p</italic><sub>id</sub> were obtained similarly.</p>
      <p>If our predictions were perfectly accurate, resulting plots of experimental versus predicted values would show a linear relationship with slope 1. Plots for <italic>p</italic><sub>present</sub> had an extremely high variance and did not appear to follow an obvious pattern, and, based upon these results, we kept our predictions for <italic>p</italic><sub>present</sub> unchanged. Improved predictions are likely possible and can only improve the performance of our algorithm; however, they do not appear immediately available. The plots for <italic>p</italic><sub>id</sub>, on the other hand, did appear to follow a pattern; <xref ref-type="fig" rid="fig3">Figure 3</xref> shows sample plots for <italic>p</italic><sub>id</sub> for two different test species, cat and chicken, obtained from an alignment consisting of human, chimp, baboon, dog, cat, pig, cow and chicken. These plots are similar to plots obtained using other species as test cases.</p>
      <p>We do not attempt to address any possible theoretical foundations for the above plots here, as that would take us far from our current focus. Currently, our chief concern is only to convert our initial predictions into values that will work well when given as input to our indexing algorithm, and we found that fitting an exponential curve of the form <italic>g</italic>(<italic>x</italic>) = αe<sup>β(<italic>x</italic>)</sup> + δ to our data was more than adequate for this purpose in practice. We chose α and δ to fix <italic>g</italic>(0) = 0.25 and <italic>g</italic>(1) = 1; this leaves β as an adjustable parameter. Based upon our observations, a value of β = 4 seems to work fairly well for a variety of species, and we fixed this parameter for all of our tests.</p>
    </sec>
    <sec>
      <title>Region decomposition</title>
      <p>As mentioned above, one advantage of a multiple alignment is that it delineates different regions, each of which can be characterized by a conservation level among the species in the alignment. Therefore, before building an index, our algorithm partitions the probabilistic profile into a set of such regions. For simplicity, we group regions into a finite number of region classes; a region class is a pair of characteristics (<inline-formula><mml:math id="M1"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>present</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M2"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>id</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>), which represent typical values of <italic>p</italic><sub>present</sub> and <italic>p</italic><sub>id</sub>, respectively, for each region in the region class. All regions in a region class index the same set of seeds.</p>
      <p>Partitioning a profile into regions can be done with the aid of a simple Hidden Markov Model, where the states are region classes that emit values of <italic>p</italic><sub>present</sub> and <italic>p</italic><sub>id</sub>. Similar ideas have been explored before (<xref ref-type="bibr" rid="b19">19</xref>,<xref ref-type="bibr" rid="b36">36</xref>); for our purposes here, it is enough that all regions in a region class possess roughly the same properties. It is important that the cardinalities of the region classes be roughly equal so that we have maximum flexibility when assigning seeds; if one region class is enormous, then in order to free enough budget to assign extra seeds to it we must choose to assign fewer seeds to a large number of smaller region classes, which may be undesirable.</p>
      <p>We begin this section by considering a conceptually straightforward approach for decomposing a profile in order to introduce the basic ideas of our method. We then describe how our particular approach extends this idea.</p>
      <p>Suppose that we build an HMM consisting of states for each region class (<inline-formula><mml:math id="M3"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>present</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M4"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>id</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>). Each state emits a position of the profile with values (<italic>p</italic><sub>present</sub>, <italic>p</italic><sub>id</sub>) with probability proportional to <inline-formula><mml:math id="M5"><mml:mrow><mml:mo>exp</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mo>|</mml:mo><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>present</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>present</mml:mtext></mml:mrow></mml:msub><mml:mo>|</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>×</mml:mo><mml:mo>exp</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mo>|</mml:mo><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>id</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>id</mml:mtext></mml:mrow></mml:msub><mml:mo>|</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and transitions to every state other than itself with equal probability. This probability can be chosen to ensure that the optimal Viterbi parse (<xref ref-type="bibr" rid="b33">33</xref>) gives no region shorter than a minimum length; this length should be large enough to ensure that every region is at least larger than the span of our seeds, and we found that a minimum region length of 64 works reasonably well for seeds of span ∼20.</p>
      <p>Once this HMM has been constructed, each position can be assigned to the region class corresponding to the state that emits it in the optimal parse obtained via the Viterbi algorithm. Region boundaries then occurs between two positions that belong to different region classes.</p>
      <p>This basic algorithm suffers from the problem that we must determine the set of region classes at the beginning of the algorithm in order to be able to construct the HMM. The weakness of this approach is shown in <xref ref-type="fig" rid="fig4">Figure 4a</xref>. If we choose to represent each position in the profile as a point (<italic>p</italic><sub>present</sub>, <italic>p</italic><sub>id</sub>), then choosing a set of region classes is conceptually related to partitioning the plane in which the positions lie. All points contained in a rectangle in the partition are closest to the center of a specific region class. By fixing the region classes a priori, we will likely make choices that do not fit the structure of the profile. The chief problem occurs when several region classes are empty and one region class contains many more regions than the others; in this case partitioning achieves little.</p>
      <p>An alternative method is to adaptively choose region classes to match the manner in which the positions are distributed, as shown in <xref ref-type="fig" rid="fig4">Figure 4b</xref>. One way of doing this is to use k-means clustering (<xref ref-type="bibr" rid="b37">37</xref>) and choose region classes corresponding to the resulting clusters. This does not translate directly to our problem, however, as choosing region classes in this manner cannot predict how the profile will actually be decoded by the HMM. Instead, we use a related algorithm that somewhat corrects this problem. This is related to the fundamental idea behind wavelets (<xref ref-type="bibr" rid="b38">38</xref>), which can analyze data dynamically by decomposing a signal into pieces that can be represented at different scales of resolution.</p>
      <p>Our algorithm is shown graphically in <xref ref-type="fig" rid="fig5">Figure 5</xref>. At a high-level, we progressively split the profile into regions belonging to one of two region classes. We perform the decoding at each stage using an HMM exactly as described previously but consisting of only two states. We then decompose each region class further as long as the number of total region classes is less than the maximum number of region classes.</p>
      <p>In detail, at each stage we are faced with decomposing a set of regions, all of which belong to the same region class; in the first stage, there is one region consisting of the entire profile. We construct a simple HMM consisting of two states, which correspond to two new region classes; the transition probabilities are set as described above. In principle, we can apply any training algorithm, such as the Baum–Welch or Viterbi training algorithm (<xref ref-type="bibr" rid="b33">33</xref>), to learn the emission probabilities of each of the two characteristics <inline-formula><mml:math id="M6"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>present</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M7"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>id</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. Once we have determined the values of <inline-formula><mml:math id="M8"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>present</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M9"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>id</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> for the states in the HMM, we can apply the Viterbi algorithm as previously described to partition the original region class into two region classes. We then decompose each of the two new region classes, stopping when the total number of region classes reaches a user specified limit; based on our experience a set of region classes of cardinality 40 works well in practice.</p>
      <p>In practice, learning only the parameter with greater variance before applying the Viterbi algorithm and estimating the other parameter afterwards seems to give slightly better results than learning both parameters at once; this is due in large part to the greater ease in determining the initial parameters of the training algorithm in this case. Such an approach splits region classes more evenly, which is our chief goal in this process.</p>
    </sec>
    <sec>
      <title>Seed indexing</title>
      <p>Once we have the set of regions and region classes, we can proceed to build the index. Our algorithm must determine for each region which subset of the candidate set of seeds will be indexed. Rather than considering each region individually, we consider each region class individually and index the same subset of seeds for every region in the same region class. When it comes time to actually index the set of seeds that has been assigned to a region class, each region is indexed independently; i.e. we never index positions that cause a seed to span two regions. Our goal is to maximize the expected number of homologies in the multiple alignment matched to a homologue in a query.</p>
      <p>We must first infer probable locations of homologies in the alignment, so that such positions can be indexed more aggressively. Our profile is partitioned into a set of regions, not homologies, and we therefore adjust our profile so that maximizing the expected number of regions matched to a homologue in the query approximates the number of homologies matched between the alignment and the query. The change that we must make concerns the length of regions; namely, very long regions are likely to contain more than one homology. In this case, there should be a reward for matching a long region to a homologue that is proportional to the expected number of homologies it contains. In accordance with the idea in (<xref ref-type="bibr" rid="b12">12</xref>) that 64 is a good characteristic length for homologies, we split regions of length longer than 64 into a set of contiguous regions of size 64; the last region is allowed to be slightly larger. This enables us to approximate the number of homologies matched within the original region by the number of new regions matched to a homologue.</p>
      <p>There is only one technical problem with this approach: having many small regions creates many boundaries between the regions. As mentioned above, we do not index positions that cause seeds to span two regions, and, therefore, having many boundaries can decrease our sensitivity if we are not careful. We can circumvent this problem by allowing seeds to span region boundaries if the regions on both sides of the boundary are part of the same region class. Therefore, for the rest of this section we consider only the problem of maximizing the number of regions in the profile matched to a homologue in the query, with the understanding that this approximates the number of homologies matched between the alignment and the query.</p>
      <p>We now begin by describing a general method for solving the seed assignment problem, and we then introduce a greedy approximation that we use in practice. To begin, we determine for each region class and for each number of seeds <italic>j</italic> the expected number of regions within that class matched to a homologue in the query if every position in that region class indexes the <italic>j</italic> candidate seeds that optimize the hitting probability for the region class. We will say that a region class is assigned <italic>j</italic> seeds if every region in that class indexes <italic>j</italic> seeds. This can be represented as a table with a row corresponding to each region class and a column corresponding to each possible subset size. Entry (<italic>i</italic>, <italic>j</italic>) represents the expected number of regions in region class <italic>i</italic> matched to a homologue if region class <italic>i</italic> is assigned <italic>j</italic> seeds.</p>
      <p>We compute this table as follows. For a region class (<inline-formula><mml:math id="M10"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>present</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M11"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>id</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>), the probability that a region within that class matches a homologue is the probability that a homologue exists multiplied by the conditional probability that a set of seeds matches the region and its homologue, given that the homologue exists. The former probability can be approximated by <inline-formula><mml:math id="M12"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>present</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, which gives the average probability that a typical region in the region class has a homologue in a query. The latter is the hitting probability, <italic>p</italic><sub>hit</sub>, which we can compute using dynamic programming. Algorithms for calculating this (<xref ref-type="bibr" rid="b18">18</xref>,<xref ref-type="bibr" rid="b20">20</xref>) require that we specify a region length over which the seeds will be indexed as well as the similarity level of the region. Because all regions are of approximate size 64, we can specify the same length for every region; furthermore, the characteristic <inline-formula><mml:math id="M13"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>id</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> of a region class approximates the similarity level of a typical region in the region class.</p>
      <p>We fill in the first column of the table by computing for each region class <italic>i</italic> the optimal seed. This seed matches any region in the region class to its homologue with approximate conditional probability <inline-formula><mml:math id="M14"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mtext>hit</mml:mtext></mml:mrow><mml:mn>1</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula>, given that the homologue exists; the seed therefore matches each region to a homologue with unconditional probability <inline-formula><mml:math id="M15"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>present</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>×</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mtext>hit</mml:mtext></mml:mrow><mml:mn>1</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula>. If the region class has |<italic>C</italic>| regions, the seed is expected to match <inline-formula><mml:math id="M16"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>present</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>×</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mtext>hit</mml:mtext></mml:mrow><mml:mn>1</mml:mn></mml:msubsup><mml:mo>×</mml:mo><mml:mo>|</mml:mo><mml:mi>C</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> regions to their homologues; we fill in entry (<italic>i</italic>, 1) with this value. Next, we fill in successive columns using the greedy covering procedure described by (<xref ref-type="bibr" rid="b20">20</xref>). Briefly, to fill in column <italic>j</italic> for a region class <italic>i</italic>, we compute the optimal set of seeds of size <italic>j</italic> by augmenting the optimal set of seeds of size <italic>j</italic> − 1 with the seed that optimizes <italic>p</italic><sub>hit</sub> given that the previous <italic>j</italic> − 1 seeds do not match. This set of seeds matches with probability <inline-formula><mml:math id="M17"><mml:mrow><mml:msubsup><mml:mtext>p</mml:mtext><mml:mrow><mml:mtext>hit</mml:mtext></mml:mrow><mml:mi>j</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, so we fill in the table entry (<italic>i</italic>, <italic>j</italic>) with the value <inline-formula><mml:math id="M18"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>present</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mo>×</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mtext>hit</mml:mtext></mml:mrow><mml:mi>j</mml:mi></mml:msubsup><mml:mo>×</mml:mo><mml:mo>|</mml:mo><mml:mi>C</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>Once the table is full, we assign weights and values to each entry. The weight of entry (<italic>i</italic>, <italic>j</italic>) is the total length of all of the regions in region class <italic>i</italic> multiplied by <italic>j</italic>, the number of seeds corresponding to this entry; this represents the amount of budget we use by assigning <italic>j</italic> seeds to region class <italic>i</italic>. The value is the entry in the cell, which represents the expected number of regions in region class <italic>i</italic> matched to a homologue if <italic>j</italic> seeds are indexed. In this manner, each entry can be viewed as an object of a certain weight and value. Any set consisting of at most one object from each row in the table specifies a number of seeds to assign to each region class; if entry (<italic>i</italic>, <italic>j</italic>) is selected, then region class <italic>i</italic> is assigned <italic>j</italic> seeds. The sum of the weights of the objects is equal to the budget used by such an assignment, and the sum of the values of the objects is the expected number of regions matched. Therefore, such a set of objects that has maximum value and total weight less than our budget specifies the optimal set of seeds to index for each region class.</p>
      <p>This problem can be solved exactly in time linear in terms of the size of the database by a solution closely related to that of the Knapsack Problem (<xref ref-type="bibr" rid="b39">39</xref>). In practice, we use a different algorithm to obtain an approximate solution that is both faster and allows us to avoid computing the entire table of values, which is inefficient since we typically index for many region classes a small subset of the candidate seeds. We define the density of an object as its value divided by its weight and select objects in order of decreasing density, disallowing more than one object from a given row.</p>
      <p>In detail, we proceed as follows. In order to choose the set of objects, we begin with a candidate list of objects corresponding only to the first column in the table. At each step in the algorithm, we examine the candidate list and select the object of highest density. If the object we choose corresponds to cell (<italic>i</italic>, <italic>j</italic>), then we remove it from the candidate list and add the object corresponding to cell (<italic>i</italic>, <italic>j</italic> + 1) to the candidate list. Rather than setting the value of the new object to be the value in cell (<italic>i</italic>, <italic>j</italic> + 1) of the table, though, we set its value to be the difference between the values in the cell (<italic>i</italic>, <italic>j</italic> + 1) and cell (<italic>i</italic>, <italic>j</italic>). Similarly, rather than setting its weight to the total length of all regions in region class <italic>i</italic> multiplied by the size of the seed set, we set its weight to be merely the total length of the regions.</p>
      <p>Viewing this step in terms of seed selection, choosing object (<italic>i</italic>, <italic>j</italic>) corresponds to choosing to index <italic>j</italic> seeds for each region in region class <italic>i</italic>. The value of the object added to the candidate set corresponds to the additional number of regions matched to a homologue if <italic>j</italic> + 1 rather than <italic>j</italic> seeds are indexed for region class <italic>i</italic>, and its weight is the amount of budget used by indexing one additional seed. This object can only be added after object (<italic>i</italic>, <italic>j</italic>) is added because the first <italic>j</italic> seeds must be indexed before seed <italic>j</italic> + 1 is indexed. If an object cannot be added because its weight is too high, we remove it from consideration and try to add the object with the next highest density. We stop this process right before we exceed our budget.</p>
      <p>The quality of this approximation depends on the relative weights and values of the objects. For instance, if all the objects are all of similar weight, the algorithm will perform well since it is exact in the case that all objects have the same weight. Similarly, if all objects except those with small values can be chosen without exceeding our budget, the greedy algorithm will perform well because it is not that important which subset of low valued objects it chooses to fill out the budget. In our case, we attempt to partition the region classes into roughly equal sizes, which, in practice, is mostly successful. When some region classes are very large, they typically contain regions with many gaps and consequently have low hitting probabilities. Therefore, in practice either objects of similar weight fill our entire budget, or we are faced with choosing between the objects of low values. In both cases our algorithm works adequately.</p>
    </sec>
  </sec>
  <sec>
    <title>RESULTS</title>
    <sec>
      <title>Assessment</title>
      <p>We evaluated our algorithm on real biological data in an attempt to assess its performance. For this purpose, we implemented Typhon, a fully functional local alignment tool that incorporates our indexing algorithm into a framework supporting BLAST-like un-gapped and gapped extensions as well as other options such as extensions of pairs of seeds on the same diagonal (<xref ref-type="bibr" rid="b11">11</xref>). Typhon applies our indexing algorithm to a database and then scans a query sequence against the database, looking up every pattern in the candidate set at every position in the query. A beta version of Typhon is available at <ext-link ext-link-type="uri" xlink:href="http://typhon.stanford.edu"/>; this website also contains supplementary information and additional experimental results. We stress that our focus in this paper is on the indexing algorithm; any seed-based alignment tool, such as PatternHunter (<xref ref-type="bibr" rid="b12">12</xref>) or BLAST (<xref ref-type="bibr" rid="b11">11</xref>), can incorporate the method used in Typhon. Once the index is built, the local aligner implementation is orthogonal.</p>
      <p>Past performance evaluations of spaced seed local alignment techniques have focused on sensitivity with respect to the Smith–Waterman algorithm (<xref ref-type="bibr" rid="b18">18</xref>). The implication is that the performance of an algorithm is directly correlated with the number of high scoring local alignments that it finds. We believe that this testing methodology is imperfect because it does not attempt to evaluate whether alignments are truly homologous. For example, it is expected to give too much importance to transposable elements and other repeats in a genome. A core principle of Typhon is to incorporate conservation information, which likely indicates homology, to improve alignment algorithms. Therefore, it is desirable to evaluate Typhon based on how many true homologies it can detect between a database and a query.</p>
      <p>One means of testing this is to use known homologous annotations of a database and a query for evaluation purposes; however, there is a dearth of such data, with exons being an exception. Unfortunately, increasing our budget does not allow us to align more exons when considering query species closely related to our database, as even low budgets capture almost all exons capable of being aligned.</p>
      <p>Therefore, we tested Typhon as follows. We first constructed a multiple alignment database using LAGAN (<xref ref-type="bibr" rid="b24">24</xref>) and post-processed it using the refinement techniques of MUSCLE (<xref ref-type="bibr" rid="b40">40</xref>). We then chose three species as query species and globally aligned each to the database using LAGAN. Parts of the alignment to which the query aligns without gaps are likely to be true homologies; while this is not always the case, we expect it to be a reasonable approximation of the set of homologies present between the database and the query. To prune obviously bad alignments, we scored all potential un-gapped alignments and kept only those with positive scores; to score alignments, we constructed the consensus sequence from the database and scored the query against that sequence. While this pruning step may in principle remove some alignments that score low overall but have segments that score high, almost all alignments removed in practice are genuinely low scoring and are potential misalignments (data not shown). We kept each remaining un-gapped alignment as a hypothetical homologous alignment (HHA).</p>
      <p>We evaluated the performance of Typhon by locally aligning each query to the database and determining how many HHAs were overlapped by at least one resulting local alignment. Besides approximating the number of homologies detected, this performance metric is relevant to global alignment algorithms incorporating an anchoring step (<xref ref-type="bibr" rid="b23">23</xref>,<xref ref-type="bibr" rid="b25">25</xref>,<xref ref-type="bibr" rid="b28">28</xref>,<xref ref-type="bibr" rid="b41">41</xref>), as a high number of potentially true anchors helps such aligners. We tested un-gapped extensions as well as gapped extensions for evaluation. The relative performance of the algorithms in all of the tests we ran was unaffected by the extension method used; since un-gapped extensions are somewhat easier to analyze, we report only those results.</p>
      <p>The query sequences we used were the CFTR regions of mouse, pig and fugu obtained from (<xref ref-type="bibr" rid="b42">42</xref>). For each query we tested how many HHAs were identified, and we tested how many exons were identified for fugu as well. The sequences included in the multiple alignment were also obtained from (<xref ref-type="bibr" rid="b42">42</xref>) and consisted of baboon, cat, chicken, chimp, cow, dog, human, mouse, pig and rat; we removed mouse and rat when testing mouse and pig when testing pig. For a phylogenetic tree, we used the tree given in (A. Siepel, 2002, <ext-link ext-link-type="uri" xlink:href="http://www.cse.ucsc.edu/classes/cmps242/Fall02/projects/proj02.html"/>).</p>
      <p>We compared the performance of the Typhon indexing algorithm to the existing scheme that simply indexes every position in the database with the same set of seeds (<xref ref-type="bibr" rid="b12">12</xref>,<xref ref-type="bibr" rid="b17">17</xref>,<xref ref-type="bibr" rid="b18">18</xref>,<xref ref-type="bibr" rid="b20">20</xref>). We refer to this algorithm as STANDARD. We did not test Typhon against existing algorithms such as PatternHunter (<xref ref-type="bibr" rid="b12">12</xref>) or Wu-BLAST (Gish, W., 1996–2004) because, such tests introduce many uncontrolled experimental variables. For instance, each incorporates optimizations that are entirely orthogonal to the indexing algorithm used, which is our chief focus in this paper. Because the code base of STANDARD is identical to that of Typhon, the only variation in our experiments was due to the seeding method used.</p>
      <p>Note that when indexing a multiple alignment, STANDARD indexes the consensus sequence, rather than simply indexing the sequence of a certain species. We show below that STANDARD is significantly more sensitive when indexing a multiple alignment than when indexing the closest species in the alignment to the query, which is by itself a significant reason to index multiple alignments rather than individual sequences.</p>
    </sec>
    <sec>
      <title>Sensitivity comparison</title>
      <p>We tested Typhon versus STANDARD on three query species for varying values of the budget <italic>B</italic> as described above; the database used in these tests was the full multiple alignment. We used patterns of weight 10 and span 18 as well as patterns of weight 11 and span 19; these choices for pattern weights are based on the tests presented in past research on spaced seeds (<xref ref-type="bibr" rid="b12">12</xref>,<xref ref-type="bibr" rid="b17">17</xref>–<xref ref-type="bibr" rid="b20">20</xref>). To handle low complexity regions and repeats, we pre-processed the query using DUST (R. L. Tatusov and D. J. Lipman, unpublished data) and discarded from the index those <italic>k</italic>-mers occurring more frequently than 5 SD above the mean. We chose this discarding technique because we found that it significantly speeds up searches with no loss in sensitivity. We used a candidate set of seeds of size 15 for Typhon and designed the set of seeds using Mandala's greedy covering algorithm (<xref ref-type="bibr" rid="b20">20</xref>). When partitioning the profile into a set of region classes, Typhon used 40 region classes. Complete specification of the parameters we used for scoring alignments can be found as supplementary information on our website.</p>
      <p>For a seed based local aligner, the method used to score alignments is orthogonal to the seeding method. However, the choice can have an impact on performance, particularly in the case of aligning a sequence to a multiple alignment. We focus here on results obtained using consensus scoring, which constructs from the multiple alignment the consensus sequence and then scores hits by standard pairwise alignment scoring. The advantage of this approach is that it allows a comparison of Typhon to sequence to sequence aligners; because the scoring is done between the two sequences, we can use Karlin–Altschul statistics to evaluate the local alignments (<xref ref-type="bibr" rid="b43">43</xref>).</p>
      <p>The number of HHAs identified by Typhon and STANDARD as the parameter <italic>B</italic> is varied is shown for each species in <xref ref-type="table" rid="tbl1">Table 1</xref>; we also show the number of exons identified for fugu. Note that Typhon permits non-integral values for <italic>B</italic>. The number of seed extensions is shown as part of our supplementary results to confirm that Typhon obtains no advantage over STANDARD by performing more seed extensions; both algorithms perform roughly the same number of extensions, which as expected scales linearly with <italic>B</italic>. The total number of alignments found is not shown but was also roughly the same for each method for a given <italic>B</italic>. This is because many alignments found by STANDARD are potentially poor multiple alignments. For example, many alignments for fugu are gapped in half of the species in the database. Such alignments can score reasonably well with consensus scoring but are unlikely to be truly homologous alignments. Indeed, if sum of pairs scoring is used instead, which is more common when performing multiple alignments, Typhon finds significantly more local alignments than STANDARD. Results are shown as supplementary information on our website.</p>
      <p>The results indicate that Typhon achieves the highest gains in sensitivity for distant species; it performs best for fugu, where it is more sensitive using a seed weight of 11 for low budgets than STANDARD using a seed weight of 10. It is more sensitive than STANDARD for mouse, although not as dramatically, and it performs the worst on pig, where it performs roughly the same as STANDARD. This suggests that Typhon is most effective for queries that are far away from each species in the multiple alignment. Because pig has a close relative in cow present in the database, the advantage of Typhon is diminished; similarly, its advantage for fugu is greatest because fugu has no close relatives in the alignment.</p>
      <p>The reason that Typhon is less sensitive for queries with a close relative in the database is two-fold. First, the close relative is likely to dominate the other species in the multiple alignment, so that the extra information in the multiple alignment that Typhon can use is minimal. Second, indexing multiple patterns does not yield a large benefit because one pattern finds most of the true matches; e.g. in STANDARD, <italic>B</italic> = 10 identifies 15% more HHAs than <italic>B</italic> = 1 for mouse but only 2% more for pig. There is simply not much room for improvement; Typhon typically achieves sensitivity gains by skipping a region and reallocating its budget, but for close species skipping a region is very costly while budget reallocation yields minimal gains.</p>
      <p>We note that for all species, Typhon's performance advantage is largest when values of <italic>B</italic> are small. This is important because large values of <italic>B</italic> are less useful for large-scale genome searches, since searches run slower and sensitivity improvements diminish as <italic>B</italic> increases. An example of this can be seen by examining the data for fugu; with a seed weight of 11 and budget of 1, Typhon is almost as sensitive as STANDARD using a seed weight of 10 and budget of 3. Despite similar sensitivities, we would expect Typhon to perform ∼12 times fewer seed extensions in this case.</p>
      <p>Although consensus scoring allows easy comparison to existing pairwise local aligners, many multiple aligners use sum-of-pairs scoring to score alignments. We therefore also tested Typhon using sum-of-pairs scoring. Complete details of these tests can be found as supplementary information on our website, but we summarize here that with respect to HHAs, Typhon increases its advantage over STANDARD for mouse and fugu queries, while the relative performance of the two methods remains roughly the same with pig. In addition, as mentioned above, Typhon finds significantly more alignments in total than STANDARD. This is encouraging, as high sum of pairs scores indicate similarity to many species, unlike high consensus scores. Complete analysis of scoring schemes in a local aligner is a topic for further research, but our results indicate that Typhon is effective using either consensus, sum or pairs scoring.</p>
      <p>Finally we briefly mention an example of how seeds are distributed among region classes. With mouse as a query and a budget of 2, Typhon allocates between 0 and 5 seeds to each region. There is a high correlation between <inline-formula><mml:math id="M19"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>present</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and the number of seeds allocated, while the <inline-formula><mml:math id="M20"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>id</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> value has secondary effects. In some cases, lower values of <inline-formula><mml:math id="M21"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>id</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> cause more seeds to be allocated even in the face of lower <inline-formula><mml:math id="M22"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>present</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>; once region classes with high <inline-formula><mml:math id="M23"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>id</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> values receive a moderate number of seeds, allocating additional seeds leads to diminishing returns. A plot of the number of seeds allocated for each region class is shown as supplementary information on our website.</p>
    </sec>
    <sec>
      <title>Analysis of database types</title>
      <p>Suppose that we have the genomes of several mammals and we have just sequenced a new species. A common next step might be to align the new species to the sequences we already have. Currently, one way of doing so might be to use a local aligner to align the newly sequenced species to the human sequence, due to the importance and sequence quality of the human genome. Another method might use the closest available relative of the query as a database. However, if we have a reference alignment of the already sequenced mammals, it is worthwhile to ask if we can improve sensitivity by aligning the new species directly to the multiple alignment. In other words, do multiple alignment databases allow search sensitivities greater than those permitted by sequence databases, irrespective of the indexing algorithm used?</p>
      <p>To address this question, we tested aligning each query sequence to human as well as to its closest relative using STANDARD; for mouse and fugu it happens that the closest relative in our alignment is human. Because the human sequence is much shorter than the full alignment, the alignment database we used for comparison consisted of the full alignment projected to include only columns un-gapped in human. We tested STANDARD and Typhon on this projected database using consensus scoring to allow direct comparisons to the method that indexes only a sequence. The results are shown in <xref ref-type="table" rid="tbl2">Table 2</xref>.</p>
      <p>The first observation we make is that the two methods that index the multiple alignment are indeed more sensitive than the method that indexes only a sequence. This suggests that, regardless of the indexing method used, using a multiple alignment as a database can boost search sensitivity.</p>
      <p>We next observe that, in these tests, Typhon maintains most of its performance advantage over STANDARD, particularly in the case of small budgets. Some degradation is expected because the filtering of columns that are gapped in human should have some overlap with the filtering performed by Typhon.</p>
      <p>For mouse and pig, the number of identified HHAs in these tests is larger than the number identified in the tests involving the full alignment. This appears to be due to many annotations that are far apart in the full alignment but are joined in the projected alignment. We refrain from stating that if this indicates that it is better to index the projected alignment than the full alignment, as it may be an artifact of the manner in which the alignment is constructed or the quality of the sequences in the alignment. At any rate, an examination of the results for fugu shows that the projected alignment does not always uncover more HHAs.</p>
    </sec>
    <sec>
      <title>Performance comparison</title>
      <p>To ensure that Typhon is a practical algorithm, we ran some tests to measure its running time relative to STANDARD. The running time consists of two components: time spent building the index and time spent scanning the index. To measure both of these, we recorded the CPU time spent building and scanning the index for the tests using mouse as a query with consensus scoring. We ran two tests with seed weight of 10; one used the human sequence and the projected alignment as databases, and the other used the full alignment as a database. The tests were run on a 2.8 GHz Pentium 4 processor with 2 GB of RAM.</p>
      <p>The results of these tests are shown in <xref ref-type="fig" rid="fig6">Figure 6</xref>. In the case of the full alignment Typhon runs faster, and in the case of the smaller database STANDARD performs better. As one might expect, these differences are based almost entirely on the different number of seed extensions performed by each algorithm; this is also evident from <xref ref-type="fig" rid="fig6">Figure 6</xref>. Running times are therefore extremely data dependent and difficult to gauge accurately from simple tests. Our chief point here is that Typhon does not incur a major performance overhead relative to STANDARD. We also stress that Typhon is still a beta version implementation; careful optimizations are almost certainly possible and will most likely improve the performance of Typhon. In addition, as noted in (<xref ref-type="bibr" rid="b20">20</xref>), the overhead of scanning multiple seeds permits substantial parallelization, which may eliminate much of the overhead Typhon faces.</p>
      <p>Typhon does take longer to build the index than STANDARD. Our tests showed that the running times of both algorithms scale roughly linearly with the size of the database, with Typhon running ∼3 to 4 times slower. However, for large sequences, build times are typically much less than scan times, which are quadratic in the size of the sequences. Furthermore, it is likely that the cost of building the index can be in some cases amortized over many query sequences, just as can be the cost of designing optimal spaced seeds (<xref ref-type="bibr" rid="b12">12</xref>). We note that our index is more query specific than standard spaced seed indexes; such indexes are optimized only for a specific similarity level while our indexes are optimized for a given phylogenetic tree. However, if many queries admit the same tree structure and only alter branch lengths, which will often happen if all are distant from the species in the database (e.g. chicken and fugu queries to mammalian genomes), our index is less restricted. In such cases only the absolute values of <italic>p</italic><sub>id</sub> change; this alters the index to a much lesser extent than do cases in which the relative values of <italic>p</italic><sub>id</sub> or <italic>p</italic><sub>present</sub> change across regions.</p>
      <p>We finally note that the space requirements of Typhon are identical to STANDARD except for an overhead for each pattern in the candidate set. This overhead is present due to the need for a lookup table for each such pattern; the size of this table is independent of database size. Full performance results are available as supplementary information on our website.</p>
    </sec>
  </sec>
  <sec>
    <title>DISCUSSION</title>
    <p>In this paper we have argued in favor of using a multiple alignment to improve seeded local alignment techniques. Our results indicate that not only can multiple alignment databases increase search sensitivity irrespective of the search algorithm used, but also they permit improved search algorithms. We have presented an algorithm encapsulated in Typhon, which is a step in this direction.</p>
    <p>We believe that our results are particularly relevant given the current trends in comparative genomics. In the near future, a common task will be to search a database of genomes, such as those consisting of mammals or flies, with a query set of sequences of interest. Such queries may contain a newly sequenced mammalian genome or a set of fly genes and may not have a close relative in the database. Our results indicate that instead of indexing a single representative species from the database, it is more effective to directly query an alignment of the database species. Even if our dynamic indexing algorithm is not employed, reconstructing the consensus sequence of the multiple alignment at the point where the query's immediate ancestor meets the phylogenetic tree is likely to improve sensitivity.</p>
    <p>As our results show, by indexing a multiple alignment we can obtain sensitivities comparable to existing sequence local aligners while performing many fewer seed extensions. This combined improvement of the sensitivity/speed trade-off can be quite significant, especially across a whole-genome search where local alignment extensions consume the majority of the running time. For instance, suppose we use the sequence of mouse as a query mammal and the sequence of rat is not available in our database. If we use a Typhon-generated alignment database consisting of on average two weight-11 seeds per position, we can perform searches in no more than half the time than can an algorithm that searches a human database consisting of any number of weight-10 seeds per position; this performance improvement comes at no cost with respect to sensitivity.</p>
    <p>Because our index is specific to a given query species, our method is most applicable in the case where query sequences are large, such as a newly sequenced whole-genome. In particular, if the tree consisting of the query species and the species in the database changes, we must rebuild the index for optimal performance. However, as mentioned above, if two species cause the tree to change only with respect to branch lengths but not structurally, our algorithm must only reconsider the similarity level between the query and the index. This situation can be common and affects our index much less severely than do cases in which the entire tree structure changes. In future work, it will be useful to examine the exact degree to which the index is affected by non-structural changes in the phylogenetic tree.</p>
    <p>Our work also brings to light several directions for future research. Most notably, our method for constructing the probabilistic profile can be formalized and expanded upon. The interplay of the probabilities <italic>p</italic><sub>present</sub> and <italic>p</italic><sub>id</sub> decoded from the multiple alignment can have dramatic effects on performance, and improvements in obtaining this information will almost certainly improve the results of our algorithm further. It will be interesting to explore with simulations or real data how these values will change if the species in the multiple alignment are varied. Adjacent to these issues is the question of how best to deal with possible errors in the multiple alignment that may mislead Typhon; it may be possible to detect and correct for such problems with a more flexible algorithm.</p>
    <p>In addition, many opportunities exist for algorithmic improvements. First of all, more care in choosing the candidate set of spaced seeds may result in increased sensitivity. It is possible that using higher-order models for seed evaluation as previously suggested (<xref ref-type="bibr" rid="b19">19</xref>) may confer a benefit, especially since the multiple alignment may yield information useful in constructing a model of sequence similarity. In addition, it may be beneficial to use the multiple alignment to identify conserved positions in the alignment and treat those differently than less conserved positions; vector seeds (<xref ref-type="bibr" rid="b22">22</xref>) may be relevant here due to their ability to weight different positions in a seed differently. This would allow seeds to change on a position-by-position basis, as opposed to a region-by-region basis; an intermediate idea might be to allow the set of candidate seeds to vary on a region-by-region basis, rather than fixing the candidate set for all regions. Finally, our method of indexing a multiple alignment by using only consensus characters is restrictive. For instance, if a position has equal probabilities of 2 nucleotides, it might be beneficial for multiple seeds indexed at that position to incorporate different nucleotides.</p>
    <p>Based on the results of this paper, we believe that a complete examination of all issues relevant to the task of indexing a multiple alignment will be fruitful. At this stage in time, our results indicate that Typhon is an attractive alternative to existing local aligners that index sequence databases. Furthermore, the opportunity for future algorithmic developments appears large. We feel that as more sequencing data becomes available, tools for querying multiple alignment databases will become increasingly important.</p>
  </sec>
</body>
<back>
  <ack>
    <p>We thank George Asimenos and Antal Novak for helpful discussions and aid with code design, as well as Arend Sidow for helpful discussions. We also thank two anonymous referees for comments that resulted in an improved manuscript. This work was supported in part by NIH grant U01-HG003162. J.F. was supported in part by an SGF fellowship. S.B. acknowledges support from the NSF CAREER Award and the Alfred P. Sloan Fellowship. Funding to pay the Open Access publication charges for this article was provided by NIH grant U01-HG003162.</p>
    <p><italic>Conflict of interest statement</italic>. None declared.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="b1">
      <label>1</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cooper</surname>
            <given-names>G.M.</given-names>
          </name>
          <name>
            <surname>Brudno</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Stone</surname>
            <given-names>E.A.</given-names>
          </name>
          <name>
            <surname>Dubchak</surname>
            <given-names>I.</given-names>
          </name>
          <name>
            <surname>Batzoglou</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Sidow</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Characterization of evolutionary rates and constraints in three mammalian genomes</article-title>
        <source>Genome Res.</source>
        <year>2004</year>
        <volume>14</volume>
        <fpage>539</fpage>
        <lpage>548</lpage>
        <pub-id pub-id-type="pmid">15059994</pub-id>
      </citation>
    </ref>
    <ref id="b2">
      <label>2</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kent</surname>
            <given-names>W.J.</given-names>
          </name>
          <name>
            <surname>Baertsch</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Hinrichs</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W.</given-names>
          </name>
          <name>
            <surname>Haussler</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <article-title>Evolution's cauldron: duplication, deletion, and rearrangement in the mouse and human genomes</article-title>
        <source>Proc. Natl Acad. Sci. USA</source>
        <year>2003</year>
        <volume>100</volume>
        <fpage>11484</fpage>
        <lpage>11489</lpage>
        <pub-id pub-id-type="pmid">14500911</pub-id>
      </citation>
    </ref>
    <ref id="b3">
      <label>3</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pevzner</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Tesler</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <article-title>Genome rearrangements in mammalian evolution: lessons from human and mouse genomes</article-title>
        <source>Genome Res.</source>
        <year>2003</year>
        <volume>13</volume>
        <fpage>37</fpage>
        <lpage>45</lpage>
        <pub-id pub-id-type="pmid">12529304</pub-id>
      </citation>
    </ref>
    <ref id="b4">
      <label>4</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schwartz</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Kent</surname>
            <given-names>W.J.</given-names>
          </name>
          <name>
            <surname>Smit</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>Z.</given-names>
          </name>
          <name>
            <surname>Baertsch</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Hardison</surname>
            <given-names>R.C.</given-names>
          </name>
          <name>
            <surname>Haussler</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <article-title>Human-mouse alignments with BLASTZ</article-title>
        <source>Genome Res.</source>
        <year>2003</year>
        <volume>13</volume>
        <fpage>103</fpage>
        <lpage>107</lpage>
        <pub-id pub-id-type="pmid">12529312</pub-id>
      </citation>
    </ref>
    <ref id="b5">
      <label>5</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Waterston</surname>
            <given-names>R.H.</given-names>
          </name>
          <name>
            <surname>Lindblad-Toh</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Rogers</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Abril</surname>
            <given-names>J.F.</given-names>
          </name>
          <name>
            <surname>Agarwal</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Agarwala</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Ainscough</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Alexandersson</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>An</surname>
            <given-names>P.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Initial sequencing and comparative analysis of the mouse genome</article-title>
        <source>Nature</source>
        <year>2002</year>
        <volume>420</volume>
        <fpage>520</fpage>
        <lpage>562</lpage>
        <pub-id pub-id-type="pmid">12466850</pub-id>
      </citation>
    </ref>
    <ref id="b6">
      <label>6</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hillier</surname>
            <given-names>L.W.</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W.</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Warren</surname>
            <given-names>W.</given-names>
          </name>
          <name>
            <surname>Harsison</surname>
            <given-names>R.C.</given-names>
          </name>
          <name>
            <surname>Ponting</surname>
            <given-names>C.P.</given-names>
          </name>
          <name>
            <surname>Bork</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Burt</surname>
            <given-names>D.W.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Sequence and comparative analysis of the chicken genome provide unique perspectives on vertebrate evolution</article-title>
        <source>Nature</source>
        <year>2004</year>
        <volume>432</volume>
        <fpage>695</fpage>
        <lpage>716</lpage>
        <pub-id pub-id-type="pmid">15592404</pub-id>
      </citation>
    </ref>
    <ref id="b7">
      <label>7</label>
      <citation citation-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Sharan</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Ideker</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Kelley</surname>
            <given-names>B.P.</given-names>
          </name>
          <name>
            <surname>Shamir</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Karp</surname>
            <given-names>R.M.</given-names>
          </name>
        </person-group>
        <article-title>Identification of protein complexes by comparative analysis of yeast and bacterial protein interaction data</article-title>
        <year>2004</year>
        <volume>vol. 8</volume>
        <conf-name>Proceedings of the Eighth Annual International Conference on Computational Molecular Biology (RECOMB)</conf-name>
        <conf-loc>San Diego, CA</conf-loc>
        <publisher-loc>New York, NY</publisher-loc>
        <publisher-name>ACM Press</publisher-name>
        <fpage>282</fpage>
        <lpage>289</lpage>
      </citation>
    </ref>
    <ref id="b8">
      <label>8</label>
      <citation citation-type="journal">
        <collab>The ENCODE Project Consortium</collab>
        <article-title>The ENCODE Project</article-title>
        <source>Science</source>
        <year>2004</year>
        <volume>306</volume>
        <fpage>636</fpage>
        <lpage>640</lpage>
        <pub-id pub-id-type="pmid">15499007</pub-id>
      </citation>
    </ref>
    <ref id="b9">
      <label>9</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lipman</surname>
            <given-names>D.J.</given-names>
          </name>
          <name>
            <surname>Pearson</surname>
            <given-names>W.R.</given-names>
          </name>
        </person-group>
        <article-title>Rapid and sensitive protein similarity searches</article-title>
        <source>Science</source>
        <year>1985</year>
        <volume>227</volume>
        <fpage>1435</fpage>
        <lpage>1441</lpage>
        <pub-id pub-id-type="pmid">2983426</pub-id>
      </citation>
    </ref>
    <ref id="b10">
      <label>10</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>S.F.</given-names>
          </name>
          <name>
            <surname>Gish</surname>
            <given-names>W.</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W.</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>E.W.</given-names>
          </name>
          <name>
            <surname>Lipman</surname>
            <given-names>D.J.</given-names>
          </name>
        </person-group>
        <article-title>Basic local alignment search tool</article-title>
        <source>J. Mol. Biol.</source>
        <year>1990</year>
        <volume>215</volume>
        <fpage>403</fpage>
        <lpage>410</lpage>
        <pub-id pub-id-type="pmid">2231712</pub-id>
      </citation>
    </ref>
    <ref id="b11">
      <label>11</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>S.F.</given-names>
          </name>
          <name>
            <surname>Madden</surname>
            <given-names>T.L.</given-names>
          </name>
          <name>
            <surname>Schaeffer</surname>
            <given-names>A.A.</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>Z.</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W.</given-names>
          </name>
          <name>
            <surname>Lipman</surname>
            <given-names>D.J.</given-names>
          </name>
        </person-group>
        <article-title>Gapped BLAST and PSI-BLAST: a new generation of protein database search programs</article-title>
        <source>Nucleic Acids Res.</source>
        <year>1997</year>
        <volume>25</volume>
        <fpage>3389</fpage>
        <lpage>3402</lpage>
        <pub-id pub-id-type="pmid">9254694</pub-id>
      </citation>
    </ref>
    <ref id="b12">
      <label>12</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ma</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Tromp</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <article-title>PatternHunter: faster and more sensitive homology search</article-title>
        <source>Bioinformatics</source>
        <year>2002</year>
        <volume>18</volume>
        <fpage>440</fpage>
        <lpage>445</lpage>
        <pub-id pub-id-type="pmid">11934743</pub-id>
      </citation>
    </ref>
    <ref id="b13">
      <label>13</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kent</surname>
            <given-names>W.J.</given-names>
          </name>
        </person-group>
        <article-title>BLAT–The BLAST-like alignment tool</article-title>
        <source>Genome Res.</source>
        <year>2002</year>
        <volume>12</volume>
        <fpage>656</fpage>
        <lpage>664</lpage>
        <pub-id pub-id-type="pmid">11932250</pub-id>
      </citation>
    </ref>
    <ref id="b14">
      <label>14</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smith</surname>
            <given-names>T.F.</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>M.S.</given-names>
          </name>
        </person-group>
        <article-title>Identification of common molecular subsequences</article-title>
        <source>J. Mol. Biol.</source>
        <year>1981</year>
        <volume>147</volume>
        <fpage>195</fpage>
        <lpage>197</lpage>
        <pub-id pub-id-type="pmid">7265238</pub-id>
      </citation>
    </ref>
    <ref id="b15">
      <label>15</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Slater</surname>
            <given-names>G.S.</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E.</given-names>
          </name>
        </person-group>
        <article-title>Automated generation of heuristics for biological sequence comparison</article-title>
        <source>BMC Bioinformatics</source>
        <year>2005</year>
        <volume>6</volume>
        <fpage>31</fpage>
        <pub-id pub-id-type="pmid">15713233</pub-id>
      </citation>
    </ref>
    <ref id="b16">
      <label>16</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Brown</surname>
            <given-names>D.G.</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Ma</surname>
            <given-names>B.</given-names>
          </name>
        </person-group>
        <article-title>A tutorial of recent developments in the seeding of local alignment</article-title>
        <source>J. Bioinform. Comput. Biol.</source>
        <year>2004</year>
        <volume>2</volume>
        <fpage>819</fpage>
        <lpage>842</lpage>
        <pub-id pub-id-type="pmid">15617167</pub-id>
      </citation>
    </ref>
    <ref id="b17">
      <label>17</label>
      <citation citation-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Buhler</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Keich</surname>
            <given-names>U.</given-names>
          </name>
          <name>
            <surname>Sun</surname>
            <given-names>Y.</given-names>
          </name>
        </person-group>
        <article-title>Designing seeds for similarity search in genomic DNA</article-title>
        <year>2003</year>
        <volume>vol. 7</volume>
        <conf-name>Proceedings of the Seventh Annual International Conference on Computational Molecular Biology (RECOMB)</conf-name>
        <conf-loc>Berlin, Germany</conf-loc>
        <publisher-loc>New York, NY</publisher-loc>
        <publisher-name>ACM Press</publisher-name>
        <fpage>67</fpage>
        <lpage>75</lpage>
      </citation>
    </ref>
    <ref id="b18">
      <label>18</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Ma</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Kisman</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Tromp</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>PatternHunter II: highly sensitive and fast homology search</article-title>
        <source>J. Bioinform. Comput. Biol.</source>
        <year>2003</year>
        <volume>2</volume>
        <fpage>417</fpage>
        <lpage>439</lpage>
      </citation>
    </ref>
    <ref id="b19">
      <label>19</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Brejova</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Brown</surname>
            <given-names>D.G.</given-names>
          </name>
          <name>
            <surname>Vinar</surname>
            <given-names>T.</given-names>
          </name>
        </person-group>
        <article-title>Optimal spaced seeds for homologous coding regions</article-title>
        <source>J. Bioinform. Comput. Biol.</source>
        <year>2004</year>
        <volume>1</volume>
        <fpage>595</fpage>
        <lpage>610</lpage>
        <pub-id pub-id-type="pmid">15290755</pub-id>
      </citation>
    </ref>
    <ref id="b20">
      <label>20</label>
      <citation citation-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Sun</surname>
            <given-names>Y.</given-names>
          </name>
          <name>
            <surname>Buhler</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>Designing multiple simultaneous seeds for DNA similarity search</article-title>
        <year>2004</year>
        <volume>vol. 8</volume>
        <conf-name>Proceedings of the Eighth Annual International Conference on Computational Molecular Biology (RECOMB)</conf-name>
        <conf-loc>San Diego, CA</conf-loc>
        <publisher-loc>New York, NY</publisher-loc>
        <publisher-name>ACM Press</publisher-name>
        <fpage>76</fpage>
        <lpage>84</lpage>
      </citation>
    </ref>
    <ref id="b21">
      <label>21</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Choi</surname>
            <given-names>K.P.</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>L.</given-names>
          </name>
        </person-group>
        <article-title>Sensitivity analysis and efficient method for identifying optimal spaced seeds</article-title>
        <source>Journal of Computer and System Sciences</source>
        <year>2004</year>
        <volume>68</volume>
        <fpage>22</fpage>
        <lpage>40</lpage>
      </citation>
    </ref>
    <ref id="b22">
      <label>22</label>
      <citation citation-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Brejova</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Brown</surname>
            <given-names>D.G.</given-names>
          </name>
          <name>
            <surname>Vinar</surname>
            <given-names>T.</given-names>
          </name>
        </person-group>
        <article-title>Vector seeds: An extension to spaced seeds allows substantial improvements in sensitivity and specificity</article-title>
        <year>2003</year>
        <volume>vol. 2812</volume>
        <conf-name>Proceedings of WABI (Workshop on Algorithms in Bioinformatics)</conf-name>
        <publisher-loc>Budapest, Hungary</publisher-loc>
        <publisher-name>Springer-Verlag</publisher-name>
        <fpage>39</fpage>
        <lpage>54</lpage>
      </citation>
    </ref>
    <ref id="b23">
      <label>23</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Brudno</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Do</surname>
            <given-names>C.B.</given-names>
          </name>
          <name>
            <surname>Cooper</surname>
            <given-names>G.M.</given-names>
          </name>
          <name>
            <surname>Kim</surname>
            <given-names>M.F.</given-names>
          </name>
          <name>
            <surname>Davydov</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Green</surname>
            <given-names>E.D.</given-names>
          </name>
          <name>
            <surname>Sidow</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Batzoglou</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <article-title>NISC Comparative Sequencing Program</article-title>
        <source>Genome Res.</source>
        <year>2003</year>
        <volume>13</volume>
        <fpage>721</fpage>
        <lpage>731</lpage>
        <comment>LAGAN and Multi-LAGAN: efficient tools for large-scale multiple alignment of genomic DNA</comment>
        <pub-id pub-id-type="pmid">12654723</pub-id>
      </citation>
    </ref>
    <ref id="b24">
      <label>24</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Blanchette</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Kent</surname>
            <given-names>W.J.</given-names>
          </name>
          <name>
            <surname>Riemer</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Elnitski</surname>
            <given-names>L.</given-names>
          </name>
          <name>
            <surname>Smit</surname>
            <given-names>A.F.</given-names>
          </name>
          <name>
            <surname>Roskin</surname>
            <given-names>K.M.</given-names>
          </name>
          <name>
            <surname>Baertsch</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Rosenbloom</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Clawson</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Green</surname>
            <given-names>E.D.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Aligning multiple genomic sequences with the threaded blockset aligner</article-title>
        <source>Genome Res.</source>
        <year>2004</year>
        <volume>14</volume>
        <fpage>708</fpage>
        <lpage>715</lpage>
        <pub-id pub-id-type="pmid">15060014</pub-id>
      </citation>
    </ref>
    <ref id="b25">
      <label>25</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bray</surname>
            <given-names>N.</given-names>
          </name>
          <name>
            <surname>Pachter</surname>
            <given-names>L.</given-names>
          </name>
        </person-group>
        <article-title>MAVID: constrained ancestral alignment of multiple sequences</article-title>
        <source>Genome Res.</source>
        <year>2004</year>
        <volume>14</volume>
        <fpage>693</fpage>
        <lpage>699</lpage>
        <pub-id pub-id-type="pmid">15060012</pub-id>
      </citation>
    </ref>
    <ref id="b26">
      <label>26</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Raphael</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Zhi</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Tang</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Pevzner</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <article-title>A novel method for multiple alignment of sequences with repeated and shuffled elements</article-title>
        <source>Genome Res.</source>
        <year>2004</year>
        <volume>14</volume>
        <fpage>2336</fpage>
        <lpage>2346</lpage>
        <pub-id pub-id-type="pmid">15520295</pub-id>
      </citation>
    </ref>
    <ref id="b27">
      <label>27</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Loots</surname>
            <given-names>G.G.</given-names>
          </name>
          <name>
            <surname>Ovcharenko</surname>
            <given-names>I.</given-names>
          </name>
        </person-group>
        <article-title>rVista 2.0: evolutionary analysis of transcription factor binding sites</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2004</year>
        <volume>32</volume>
        <fpage>W217</fpage>
        <lpage>W221</lpage>
        <pub-id pub-id-type="pmid">15215384</pub-id>
      </citation>
    </ref>
    <ref id="b28">
      <label>28</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Batzoglou</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Pachter</surname>
            <given-names>L.</given-names>
          </name>
          <name>
            <surname>Mesirov</surname>
            <given-names>J.P.</given-names>
          </name>
          <name>
            <surname>Berger</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Lander</surname>
            <given-names>E.S.</given-names>
          </name>
        </person-group>
        <article-title>Human and mouse gene structure: comparative analysis and application to exon prediction</article-title>
        <source>Genome Res.</source>
        <year>2000</year>
        <volume>10</volume>
        <fpage>950</fpage>
        <lpage>958</lpage>
        <pub-id pub-id-type="pmid">10899144</pub-id>
      </citation>
    </ref>
    <ref id="b29">
      <label>29</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Korf</surname>
            <given-names>I.</given-names>
          </name>
          <name>
            <surname>Flicek</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Duan</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Brent</surname>
            <given-names>M.R.</given-names>
          </name>
        </person-group>
        <article-title>Integrating genomic homology into gene structure prediction</article-title>
        <source>Bioinformatics</source>
        <year>2001</year>
        <volume>17</volume>
        <fpage>S140</fpage>
        <lpage>S148</lpage>
        <pub-id pub-id-type="pmid">11473003</pub-id>
      </citation>
    </ref>
    <ref id="b30">
      <label>30</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Simon</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Stone</surname>
            <given-names>E.A.</given-names>
          </name>
          <name>
            <surname>Sidow</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Inference of functional regions in proteins by quantification of evolutionary constraints</article-title>
        <source>Proc. Natl Acad. Sci. USA</source>
        <year>2002</year>
        <volume>99</volume>
        <fpage>2912</fpage>
        <lpage>2917</lpage>
        <pub-id pub-id-type="pmid">11880638</pub-id>
      </citation>
    </ref>
    <ref id="b31">
      <label>31</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gribskov</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>McLachlan</surname>
            <given-names>A.M.</given-names>
          </name>
          <name>
            <surname>Eisenberg</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <article-title>Profile Analysis: detection of distantly related proteins</article-title>
        <source>Proc. Natl Acad. Sci. USA</source>
        <year>1987</year>
        <volume>84</volume>
        <fpage>4355</fpage>
        <lpage>4358</lpage>
        <pub-id pub-id-type="pmid">3474607</pub-id>
      </citation>
    </ref>
    <ref id="b32">
      <label>32</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pietrokovski</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <article-title>Searching databases of conserved sequence regions by aligning protein multiple-alignments</article-title>
        <source>Nucleic Acids Res.</source>
        <year>1996</year>
        <volume>24</volume>
        <fpage>3836</fpage>
        <lpage>3845</lpage>
        <pub-id pub-id-type="pmid">8871566</pub-id>
      </citation>
    </ref>
    <ref id="b33">
      <label>33</label>
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Durbin</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Eddy</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Krogh</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Mitchison</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <source>Biological Sequence Analysis</source>
        <year>1998</year>
        <edition>1st edn</edition>
        <publisher-loc>Cambridge, UK</publisher-loc>
        <publisher-name>Cambridge University Press</publisher-name>
      </citation>
    </ref>
    <ref id="b34">
      <label>34</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kimura</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <article-title>A simple method for estimating evolutionary rates of base substitutions through comparative studies of nucleotide sequences</article-title>
        <source>J. Mol. Evol.</source>
        <year>1980</year>
        <volume>16</volume>
        <fpage>111</fpage>
        <lpage>120</lpage>
        <pub-id pub-id-type="pmid">7463489</pub-id>
      </citation>
    </ref>
    <ref id="b35">
      <label>35</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Felsenstein</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>Evolutionary trees from DNA sequences: a maximum likelihood approach</article-title>
        <source>J. Mol. Evol.</source>
        <year>1981</year>
        <volume>17</volume>
        <fpage>368</fpage>
        <lpage>376</lpage>
        <pub-id pub-id-type="pmid">7288891</pub-id>
      </citation>
    </ref>
    <ref id="b36">
      <label>36</label>
      <citation citation-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W.</given-names>
          </name>
        </person-group>
        <article-title>Significance of inter-species matches when evolutionary rate varies</article-title>
        <year>2002</year>
        <volume>vol. 6</volume>
        <conf-name>Proceedings of the Sixth Annual International Conference on Computational Biology (RECOMB)</conf-name>
        <conf-loc>Washington, DC, USA</conf-loc>
        <publisher-loc>New York, NY</publisher-loc>
        <publisher-name>ACM Press</publisher-name>
        <fpage>216</fpage>
        <lpage>224</lpage>
      </citation>
    </ref>
    <ref id="b37">
      <label>37</label>
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Boggess</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Narcowich</surname>
            <given-names>F.J.</given-names>
          </name>
        </person-group>
        <source>First Course in Wavelets with Fourier Analysis</source>
        <year>2001</year>
        <edition>1st edn</edition>
        <publisher-loc>Upper Saddle River, NJ</publisher-loc>
        <publisher-name>Prentice Hall</publisher-name>
      </citation>
    </ref>
    <ref id="b38">
      <label>38</label>
      <citation citation-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>MacQueen</surname>
            <given-names>J.B.</given-names>
          </name>
        </person-group>
        <article-title>Some methods for classification and analysis of multivariate observations</article-title>
        <year>1967</year>
        <volume>vol. 1</volume>
        <conf-name>Berkeley Symposium on Mathematical Statistics and Probability</conf-name>
        <conf-loc>Berkeley, CA</conf-loc>
        <publisher-loc>Berkeley, CA</publisher-loc>
        <publisher-name>University of California Press</publisher-name>
        <fpage>281</fpage>
        <lpage>297</lpage>
      </citation>
    </ref>
    <ref id="b39">
      <label>39</label>
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Kleinberg</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Tardos</surname>
            <given-names>E.</given-names>
          </name>
        </person-group>
        <source>Algorithm Design</source>
        <year>2005</year>
        <edition>1st edn</edition>
        <publisher-loc>San Francisco, CA</publisher-loc>
        <publisher-name>Addison Wesley</publisher-name>
      </citation>
    </ref>
    <ref id="b40">
      <label>40</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Edgar</surname>
            <given-names>R.C.</given-names>
          </name>
        </person-group>
        <article-title>MUSCLE: multiple sequence alignment with high accuracy and high throughput</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2004</year>
        <volume>32</volume>
        <fpage>1792</fpage>
        <lpage>1797</lpage>
        <pub-id pub-id-type="pmid">15034147</pub-id>
      </citation>
    </ref>
    <ref id="b41">
      <label>41</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Delcher</surname>
            <given-names>A.L.</given-names>
          </name>
          <name>
            <surname>Phillippy</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Carlton</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>S.L.</given-names>
          </name>
        </person-group>
        <article-title>Fast algorithms for large-scale genome alignment and comparison</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2002</year>
        <volume>30</volume>
        <fpage>2478</fpage>
        <lpage>2483</lpage>
        <pub-id pub-id-type="pmid">12034836</pub-id>
      </citation>
    </ref>
    <ref id="b42">
      <label>42</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Thomas</surname>
            <given-names>J.W.</given-names>
          </name>
          <name>
            <surname>Touchman</surname>
            <given-names>J.W.</given-names>
          </name>
          <name>
            <surname>Blakesley</surname>
            <given-names>R.W.</given-names>
          </name>
          <name>
            <surname>Bouffard</surname>
            <given-names>G.G.</given-names>
          </name>
          <name>
            <surname>Beckstrom-Sternberg</surname>
            <given-names>S.M.</given-names>
          </name>
          <name>
            <surname>Margulies</surname>
            <given-names>E.H.</given-names>
          </name>
          <name>
            <surname>Blanchette</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Siepel</surname>
            <given-names>A.C.</given-names>
          </name>
          <name>
            <surname>Thomas</surname>
            <given-names>P.J.</given-names>
          </name>
          <name>
            <surname>McDowell</surname>
            <given-names>J.C.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Comparative analyses of multi-species sequencing from targeted genomic regions</article-title>
        <source>Nature</source>
        <year>2003</year>
        <volume>424</volume>
        <fpage>788</fpage>
        <lpage>793</lpage>
        <pub-id pub-id-type="pmid">12917688</pub-id>
      </citation>
    </ref>
    <ref id="b43">
      <label>43</label>
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Karlin</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Altschul</surname>
            <given-names>S.F.</given-names>
          </name>
        </person-group>
        <article-title>Methods for assessing the statistical significance of molecular sequence features by using general scoring schemes</article-title>
        <source>Proc. Natl Acad. Sci. USA</source>
        <year>1990</year>
        <volume>87</volume>
        <fpage>2264</fpage>
        <lpage>2268</lpage>
        <pub-id pub-id-type="pmid">2315319</pub-id>
      </citation>
    </ref>
  </ref-list>
  <sec sec-type="display-objects">
    <title>Figures and Tables</title>
    <fig id="fig1" position="float">
      <label>Figure 1</label>
      <caption>
        <p>Sample region boundaries. Boundaries between the two regions in the multiple alignment reflect the changes in conservation among the species in the alignment. Both (<bold>a</bold>) and (<bold>b</bold>) are taken from real data. In the first case, the latter region is more likely to yield alignments to a query sequence, while in the second case, the former region is more likely to yield alignments.</p>
      </caption>
      <graphic xlink:href="gki767f1"/>
    </fig>
    <fig id="fig2" position="float">
      <label>Figure 2</label>
      <caption>
        <p>High-level diagram of the Typhon algorithm for indexing a multiple alignment. The overall flow of Typhon consists of three main algorithmic components; above, data is shown in ovals and methods are shown in rectangles. Given a tree and query, the multiple alignment is first converted into a probabilistic profile. Then, the profile is decoded recursively using a simple Hidden Markov Model. Finally, the regions are assigned a set of seeds to index.</p>
      </caption>
      <graphic xlink:href="gki767f2"/>
    </fig>
    <fig id="fig3" position="float">
      <label>Figure 3</label>
      <caption>
        <p>Plots of predicted versus experimental profile values. For use in correcting predictions of profile values, we plotted predicted versus experimental values of (<bold>a</bold>) <italic>p</italic><sub>id</sub> for cat and (<bold>b</bold>) <italic>p</italic><sub>id</sub> for chicken. Although not shown, we examined plots for other species, which are similar. Plots for <italic>p</italic><sub>present</sub> did not obey an immediate pattern and thus did not lead us to change our predictions. Each cross represents a plotted data point; shown also is the function we used for converting our initial predictions of <italic>p</italic><sub>id</sub> to our final predictions, as well as the linear fit that would be suitable if our predictions matched the experimental values.</p>
      </caption>
      <graphic xlink:href="gki767f3"/>
    </fig>
    <fig id="fig4" position="float">
      <label>Figure 4</label>
      <caption>
        <p>Alternative decomposition of the profile into region classes; region classes can be determined from a profile in several ways. Each cross represents a position in the profile plotted as a point (<italic>p</italic><sub>present</sub>, <italic>p</italic><sub>id</sub>). The squares represent the region class values <inline-formula><mml:math id="M24"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>present</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M25"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>id</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, and the lines roughly delineate portions of the plane that are closest to a particular region class. (<bold>a</bold>) When the set of region classes is fixed, the resulting decomposition does not always capture the structure of the profile. In this case, five out of sixteen region classes contain almost no positions and the region class values do not necessarily represent the average profile values of all positions in the region class. (<bold>b</bold>) An adaptive decomposition can adjust based on the structure of the profile. Here, only one out of sixteen classes contains few positions; the remaining can be distributed to help refine the region of space where most points lie. Furthermore, the region class values more accurately represent the positions in the region class. Note that the goal of this partitioning algorithm is not to cluster points, but to generate a set of region classes that each contain similar number of positions.</p>
      </caption>
      <graphic xlink:href="gki767f4"/>
    </fig>
    <fig id="fig5" position="float">
      <label>Figure 5</label>
      <caption>
        <p>High-level outline of our algorithm for decoding the profile. The algorithm we use for decoding the probabilistic profile into a set of regions consists of a series of recursive stages. At each level, we choose to partition the portion of the profile shown in black into two different region classes that differ either in <inline-formula><mml:math id="M26"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>present</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> or <inline-formula><mml:math id="M27"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mtext>id</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. We then recursively split each of the two classes until we have partitioned the profile into enough different region classes.</p>
      </caption>
      <graphic xlink:href="gki767f5"/>
    </fig>
    <fig id="fig6" position="float">
      <label>Figure 6</label>
      <caption>
        <p>Running time and seed extension comparison of indexing algorithms. The performance of both Typhon and STANDARD is highly data dependent. Above are plots of scan times as database size is varied. In all tests using alignment databases the alignment consisted of baboon, cat, chicken, chimp, cow, dog, human and pig. We used mouse as a query and seed weights of 10. Tests were run on a 2.8 GHz Pentium 4 processor with 2 GB of RAM. (<bold>a</bold>) CPU time spent scanning the index and (<bold>b</bold>) seed extensions performed when using the full alignment (4.2 Mbp) as an index are shown, as well as (<bold>c</bold>) CPU time spent scanning the index and (<bold>d</bold>) seed extensions performed when using the projected alignment (1.8 Mbp) as an index. Shown also is performance while scanning a database consisting of solely the human sequence, which is the same length as the projected alignment.</p>
      </caption>
      <graphic xlink:href="gki767f6a"/>
      <graphic xlink:href="gki767f6b"/>
    </fig>
    <table-wrap id="tbl1" position="float">
      <label>Table 1</label>
      <caption>
        <p>Sensitivity comparison of indexing algorithms</p>
      </caption>
      <table frame="hsides" rules="groups">
        <thead>
          <tr>
            <th align="left" colspan="1" rowspan="1">Budget</th>
            <th colspan="8" align="left" rowspan="1"><italic>w</italic> = 10</th>
            <th colspan="8" align="left" rowspan="1"><italic>w</italic> = 11</th>
          </tr>
          <tr>
            <th colspan="1" rowspan="1"/>
            <th colspan="4" align="left" rowspan="1">Fugu</th>
            <th colspan="2" align="left" rowspan="1">Mouse HHAs</th>
            <th colspan="2" align="left" rowspan="1">Pig HHAs</th>
            <th colspan="4" align="left" rowspan="1">Fugu</th>
            <th colspan="2" align="left" rowspan="1">Mouse HHAs</th>
            <th colspan="2" align="left" rowspan="1">Pig HHAs</th>
          </tr>
          <tr>
            <th colspan="1" rowspan="1"/>
            <th colspan="2" align="left" rowspan="1">HHAs</th>
            <th colspan="2" align="left" rowspan="1">Exons</th>
            <th colspan="1" rowspan="1"/>
            <th colspan="1" rowspan="1"/>
            <th colspan="1" rowspan="1"/>
            <th colspan="1" rowspan="1"/>
            <th colspan="2" align="left" rowspan="1">HHAs</th>
            <th colspan="2" align="left" rowspan="1">Exons</th>
            <th colspan="1" rowspan="1"/>
            <th colspan="1" rowspan="1"/>
            <th colspan="1" rowspan="1"/>
            <th colspan="1" rowspan="1"/>
          </tr>
          <tr>
            <th colspan="1" rowspan="1"/>
            <th align="left" colspan="1" rowspan="1">S</th>
            <th align="left" colspan="1" rowspan="1">T</th>
            <th align="left" colspan="1" rowspan="1">S</th>
            <th align="left" colspan="1" rowspan="1">T</th>
            <th align="left" colspan="1" rowspan="1">S</th>
            <th align="left" colspan="1" rowspan="1">T</th>
            <th align="left" colspan="1" rowspan="1">S</th>
            <th align="left" colspan="1" rowspan="1">T</th>
            <th align="left" colspan="1" rowspan="1">S</th>
            <th align="left" colspan="1" rowspan="1">T</th>
            <th align="left" colspan="1" rowspan="1">S</th>
            <th align="left" colspan="1" rowspan="1">T</th>
            <th align="left" colspan="1" rowspan="1">S</th>
            <th align="left" colspan="1" rowspan="1">T</th>
            <th align="left" colspan="1" rowspan="1">S</th>
            <th align="left" colspan="1" rowspan="1">T</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left" colspan="1" rowspan="1">1</td>
            <td align="left" colspan="1" rowspan="1">56</td>
            <td align="left" colspan="1" rowspan="1">68</td>
            <td align="left" colspan="1" rowspan="1">57</td>
            <td align="left" colspan="1" rowspan="1">74</td>
            <td align="left" colspan="1" rowspan="1">2020</td>
            <td align="left" colspan="1" rowspan="1">2137</td>
            <td align="left" colspan="1" rowspan="1">6006</td>
            <td align="left" colspan="1" rowspan="1">5998</td>
            <td align="left" colspan="1" rowspan="1">48</td>
            <td align="left" colspan="1" rowspan="1">64</td>
            <td align="left" colspan="1" rowspan="1">46</td>
            <td align="left" colspan="1" rowspan="1">69</td>
            <td align="left" colspan="1" rowspan="1">1856</td>
            <td align="left" colspan="1" rowspan="1">2060</td>
            <td align="left" colspan="1" rowspan="1">5930</td>
            <td align="left" colspan="1" rowspan="1">5949</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">1.5</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">69</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">75</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">2240</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">6049</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">65</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">71</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">2158</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">6027</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">2</td>
            <td align="left" colspan="1" rowspan="1">61</td>
            <td align="left" colspan="1" rowspan="1">69</td>
            <td align="left" colspan="1" rowspan="1">65</td>
            <td align="left" colspan="1" rowspan="1">76</td>
            <td align="left" colspan="1" rowspan="1">2190</td>
            <td align="left" colspan="1" rowspan="1">2259</td>
            <td align="left" colspan="1" rowspan="1">6074</td>
            <td align="left" colspan="1" rowspan="1">6079</td>
            <td align="left" colspan="1" rowspan="1">51</td>
            <td align="left" colspan="1" rowspan="1">65</td>
            <td align="left" colspan="1" rowspan="1">52</td>
            <td align="left" colspan="1" rowspan="1">72</td>
            <td align="left" colspan="1" rowspan="1">2089</td>
            <td align="left" colspan="1" rowspan="1">2208</td>
            <td align="left" colspan="1" rowspan="1">6044</td>
            <td align="left" colspan="1" rowspan="1">6034</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">3</td>
            <td align="left" colspan="1" rowspan="1">66</td>
            <td align="left" colspan="1" rowspan="1">69</td>
            <td align="left" colspan="1" rowspan="1">70</td>
            <td align="left" colspan="1" rowspan="1">77</td>
            <td align="left" colspan="1" rowspan="1">2258</td>
            <td align="left" colspan="1" rowspan="1">2295</td>
            <td align="left" colspan="1" rowspan="1">6089</td>
            <td align="left" colspan="1" rowspan="1">6086</td>
            <td align="left" colspan="1" rowspan="1">56</td>
            <td align="left" colspan="1" rowspan="1">67</td>
            <td align="left" colspan="1" rowspan="1">61</td>
            <td align="left" colspan="1" rowspan="1">74</td>
            <td align="left" colspan="1" rowspan="1">2186</td>
            <td align="left" colspan="1" rowspan="1">2248</td>
            <td align="left" colspan="1" rowspan="1">6067</td>
            <td align="left" colspan="1" rowspan="1">6079</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">5</td>
            <td align="left" colspan="1" rowspan="1">68</td>
            <td align="left" colspan="1" rowspan="1">69</td>
            <td align="left" colspan="1" rowspan="1">72</td>
            <td align="left" colspan="1" rowspan="1">77</td>
            <td align="left" colspan="1" rowspan="1">2302</td>
            <td align="left" colspan="1" rowspan="1">2325</td>
            <td align="left" colspan="1" rowspan="1">6104</td>
            <td align="left" colspan="1" rowspan="1">6096</td>
            <td align="left" colspan="1" rowspan="1">61</td>
            <td align="left" colspan="1" rowspan="1">67</td>
            <td align="left" colspan="1" rowspan="1">67</td>
            <td align="left" colspan="1" rowspan="1">75</td>
            <td align="left" colspan="1" rowspan="1">2256</td>
            <td align="left" colspan="1" rowspan="1">2286</td>
            <td align="left" colspan="1" rowspan="1">6083</td>
            <td align="left" colspan="1" rowspan="1">6084</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">7</td>
            <td align="left" colspan="1" rowspan="1">68</td>
            <td align="left" colspan="1" rowspan="1">69</td>
            <td align="left" colspan="1" rowspan="1">75</td>
            <td align="left" colspan="1" rowspan="1">77</td>
            <td align="left" colspan="1" rowspan="1">2324</td>
            <td align="left" colspan="1" rowspan="1">2339</td>
            <td align="left" colspan="1" rowspan="1">6121</td>
            <td align="left" colspan="1" rowspan="1">6098</td>
            <td align="left" colspan="1" rowspan="1">63</td>
            <td align="left" colspan="1" rowspan="1">67</td>
            <td align="left" colspan="1" rowspan="1">70</td>
            <td align="left" colspan="1" rowspan="1">75</td>
            <td align="left" colspan="1" rowspan="1">2283</td>
            <td align="left" colspan="1" rowspan="1">2312</td>
            <td align="left" colspan="1" rowspan="1">6105</td>
            <td align="left" colspan="1" rowspan="1">6089</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">10</td>
            <td align="left" colspan="1" rowspan="1">69</td>
            <td align="left" colspan="1" rowspan="1">69</td>
            <td align="left" colspan="1" rowspan="1">76</td>
            <td align="left" colspan="1" rowspan="1">77</td>
            <td align="left" colspan="1" rowspan="1">2338</td>
            <td align="left" colspan="1" rowspan="1">2346</td>
            <td align="left" colspan="1" rowspan="1">6135</td>
            <td align="left" colspan="1" rowspan="1">6115</td>
            <td align="left" colspan="1" rowspan="1">66</td>
            <td align="left" colspan="1" rowspan="1">67</td>
            <td align="left" colspan="1" rowspan="1">74</td>
            <td align="left" colspan="1" rowspan="1">75</td>
            <td align="left" colspan="1" rowspan="1">2301</td>
            <td align="left" colspan="1" rowspan="1">2320</td>
            <td align="left" colspan="1" rowspan="1">6118</td>
            <td align="left" colspan="1" rowspan="1">6092</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <fn>
          <p>Shown here are sensitivity results for mouse, fugu and pig using an alignment of baboon, cat, chicken, chimp, cow, dog, human, mouse, pig and rat as a database. For STANDARD and Typhon the number of HHAs overlapped by an alignment is shown for various values of <italic>B</italic>, the average number of seeds indexed at each position. The columns labeled S show results for STANDARD while the columns labeled T show results for Typhon. For each test the best performing method is shown in bold; we tested seed weights of 10 and 11. HHAs were generated as described in the text by eliminating corresponding annotations with consensus scores &lt;0 There were in total 10 801 HHAs that could potentially be identified for mouse, 852 for fugu and 11 873 for pig. There were 116 exons that could be identified for fugu.</p>
        </fn>
      </table-wrap-foot>
    </table-wrap>
    <table-wrap id="tbl2" position="float">
      <label>Table 2</label>
      <caption>
        <p>Sensitivity comparison of databases</p>
      </caption>
      <table frame="hsides" rules="groups">
        <thead>
          <tr>
            <th align="left" colspan="1" rowspan="1">Budget</th>
            <th colspan="6" align="left" rowspan="1">Fugu</th>
            <th colspan="3" align="left" rowspan="1">Mouse HHAs</th>
            <th colspan="4" align="left" rowspan="1">Pig HHAs</th>
          </tr>
          <tr>
            <th colspan="1" rowspan="1"/>
            <th colspan="3" align="left" rowspan="1">HHAs</th>
            <th colspan="3" align="left" rowspan="1">Exons</th>
            <th colspan="1" rowspan="1"/>
            <th colspan="1" rowspan="1"/>
            <th colspan="1" rowspan="1"/>
            <th colspan="1" rowspan="1"/>
            <th colspan="1" rowspan="1"/>
            <th colspan="1" rowspan="1"/>
            <th colspan="1" rowspan="1"/>
          </tr>
          <tr>
            <th colspan="1" rowspan="1"/>
            <th align="left" colspan="1" rowspan="1">H</th>
            <th align="left" colspan="1" rowspan="1">S</th>
            <th align="left" colspan="1" rowspan="1">T</th>
            <th align="left" colspan="1" rowspan="1">H</th>
            <th align="left" colspan="1" rowspan="1">S</th>
            <th align="left" colspan="1" rowspan="1">T</th>
            <th align="left" colspan="1" rowspan="1">H</th>
            <th align="left" colspan="1" rowspan="1">S</th>
            <th align="left" colspan="1" rowspan="1">T</th>
            <th align="left" colspan="1" rowspan="1">H</th>
            <th align="left" colspan="1" rowspan="1">C</th>
            <th align="left" colspan="1" rowspan="1">S</th>
            <th align="left" colspan="1" rowspan="1">T</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td colspan="14" align="left" rowspan="1"><italic>w</italic> = 10</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">    1</td>
            <td align="left" colspan="1" rowspan="1">57</td>
            <td align="left" colspan="1" rowspan="1">58</td>
            <td align="left" colspan="1" rowspan="1">61</td>
            <td align="left" colspan="1" rowspan="1">54</td>
            <td align="left" colspan="1" rowspan="1">56</td>
            <td align="left" colspan="1" rowspan="1">65</td>
            <td align="left" colspan="1" rowspan="1">2771</td>
            <td align="left" colspan="1" rowspan="1">3151</td>
            <td align="left" colspan="1" rowspan="1">3298</td>
            <td align="left" colspan="1" rowspan="1">7166</td>
            <td align="left" colspan="1" rowspan="1">8651</td>
            <td align="left" colspan="1" rowspan="1">8709</td>
            <td align="left" colspan="1" rowspan="1">8709</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">    1.5</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">69</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">71</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">3473</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">8715</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">    2</td>
            <td align="left" colspan="1" rowspan="1">64</td>
            <td align="left" colspan="1" rowspan="1">63</td>
            <td align="left" colspan="1" rowspan="1">71</td>
            <td align="left" colspan="1" rowspan="1">64</td>
            <td align="left" colspan="1" rowspan="1">64</td>
            <td align="left" colspan="1" rowspan="1">74</td>
            <td align="left" colspan="1" rowspan="1">3045</td>
            <td align="left" colspan="1" rowspan="1">3450</td>
            <td align="left" colspan="1" rowspan="1">3528</td>
            <td align="left" colspan="1" rowspan="1">7361</td>
            <td align="left" colspan="1" rowspan="1">8721</td>
            <td align="left" colspan="1" rowspan="1">8751</td>
            <td align="left" colspan="1" rowspan="1">8749</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">    3</td>
            <td align="left" colspan="1" rowspan="1">69</td>
            <td align="left" colspan="1" rowspan="1">69</td>
            <td align="left" colspan="1" rowspan="1">72</td>
            <td align="left" colspan="1" rowspan="1">69</td>
            <td align="left" colspan="1" rowspan="1">70</td>
            <td align="left" colspan="1" rowspan="1">75</td>
            <td align="left" colspan="1" rowspan="1">3140</td>
            <td align="left" colspan="1" rowspan="1">3573</td>
            <td align="left" colspan="1" rowspan="1">3630</td>
            <td align="left" colspan="1" rowspan="1">7439</td>
            <td align="left" colspan="1" rowspan="1">8748</td>
            <td align="left" colspan="1" rowspan="1">8760</td>
            <td align="left" colspan="1" rowspan="1">8761</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">    5</td>
            <td align="left" colspan="1" rowspan="1">71</td>
            <td align="left" colspan="1" rowspan="1">71</td>
            <td align="left" colspan="1" rowspan="1">72</td>
            <td align="left" colspan="1" rowspan="1">70</td>
            <td align="left" colspan="1" rowspan="1">72</td>
            <td align="left" colspan="1" rowspan="1">77</td>
            <td align="left" colspan="1" rowspan="1">3262</td>
            <td align="left" colspan="1" rowspan="1">3661</td>
            <td align="left" colspan="1" rowspan="1">3691</td>
            <td align="left" colspan="1" rowspan="1">7499</td>
            <td align="left" colspan="1" rowspan="1">8765</td>
            <td align="left" colspan="1" rowspan="1">8771</td>
            <td align="left" colspan="1" rowspan="1">8772</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">    7</td>
            <td align="left" colspan="1" rowspan="1">71</td>
            <td align="left" colspan="1" rowspan="1">71</td>
            <td align="left" colspan="1" rowspan="1">72</td>
            <td align="left" colspan="1" rowspan="1">72</td>
            <td align="left" colspan="1" rowspan="1">75</td>
            <td align="left" colspan="1" rowspan="1">77</td>
            <td align="left" colspan="1" rowspan="1">3303</td>
            <td align="left" colspan="1" rowspan="1">3708</td>
            <td align="left" colspan="1" rowspan="1">3719</td>
            <td align="left" colspan="1" rowspan="1">7520</td>
            <td align="left" colspan="1" rowspan="1">8771</td>
            <td align="left" colspan="1" rowspan="1">8778</td>
            <td align="left" colspan="1" rowspan="1">8775</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">    10</td>
            <td align="left" colspan="1" rowspan="1">72</td>
            <td align="left" colspan="1" rowspan="1">72</td>
            <td align="left" colspan="1" rowspan="1">72</td>
            <td align="left" colspan="1" rowspan="1">74</td>
            <td align="left" colspan="1" rowspan="1">76</td>
            <td align="left" colspan="1" rowspan="1">77</td>
            <td align="left" colspan="1" rowspan="1">3328</td>
            <td align="left" colspan="1" rowspan="1">3727</td>
            <td align="left" colspan="1" rowspan="1">3735</td>
            <td align="left" colspan="1" rowspan="1">7554</td>
            <td align="left" colspan="1" rowspan="1">8775</td>
            <td align="left" colspan="1" rowspan="1">8789</td>
            <td align="left" colspan="1" rowspan="1">8790</td>
          </tr>
          <tr>
            <td colspan="14" align="left" rowspan="1"><italic>w</italic> = 11</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">    1</td>
            <td align="left" colspan="1" rowspan="1">48</td>
            <td align="left" colspan="1" rowspan="1">49</td>
            <td align="left" colspan="1" rowspan="1">56</td>
            <td align="left" colspan="1" rowspan="1">48</td>
            <td align="left" colspan="1" rowspan="1">47</td>
            <td align="left" colspan="1" rowspan="1">58</td>
            <td align="left" colspan="1" rowspan="1">2522</td>
            <td align="left" colspan="1" rowspan="1">2909</td>
            <td align="left" colspan="1" rowspan="1">3062</td>
            <td align="left" colspan="1" rowspan="1">6755</td>
            <td align="left" colspan="1" rowspan="1">8492</td>
            <td align="left" colspan="1" rowspan="1">8665</td>
            <td align="left" colspan="1" rowspan="1">8656</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">    1.5</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">65</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">64</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">3297</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">–</td>
            <td align="left" colspan="1" rowspan="1">8666</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">    2</td>
            <td align="left" colspan="1" rowspan="1">52</td>
            <td align="left" colspan="1" rowspan="1">52</td>
            <td align="left" colspan="1" rowspan="1">65</td>
            <td align="left" colspan="1" rowspan="1">54</td>
            <td align="left" colspan="1" rowspan="1">52</td>
            <td align="left" colspan="1" rowspan="1">69</td>
            <td align="left" colspan="1" rowspan="1">2850</td>
            <td align="left" colspan="1" rowspan="1">3286</td>
            <td align="left" colspan="1" rowspan="1">3379</td>
            <td align="left" colspan="1" rowspan="1">6976</td>
            <td align="left" colspan="1" rowspan="1">8576</td>
            <td align="left" colspan="1" rowspan="1">8734</td>
            <td align="left" colspan="1" rowspan="1">8731</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">    3</td>
            <td align="left" colspan="1" rowspan="1">58</td>
            <td align="left" colspan="1" rowspan="1">59</td>
            <td align="left" colspan="1" rowspan="1">68</td>
            <td align="left" colspan="1" rowspan="1">61</td>
            <td align="left" colspan="1" rowspan="1">61</td>
            <td align="left" colspan="1" rowspan="1">73</td>
            <td align="left" colspan="1" rowspan="1">3013</td>
            <td align="left" colspan="1" rowspan="1">3431</td>
            <td align="left" colspan="1" rowspan="1">3497</td>
            <td align="left" colspan="1" rowspan="1">7145</td>
            <td align="left" colspan="1" rowspan="1">8646</td>
            <td align="left" colspan="1" rowspan="1">8750</td>
            <td align="left" colspan="1" rowspan="1">8749</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">    5</td>
            <td align="left" colspan="1" rowspan="1">64</td>
            <td align="left" colspan="1" rowspan="1">64</td>
            <td align="left" colspan="1" rowspan="1">69</td>
            <td align="left" colspan="1" rowspan="1">66</td>
            <td align="left" colspan="1" rowspan="1">67</td>
            <td align="left" colspan="1" rowspan="1">75</td>
            <td align="left" colspan="1" rowspan="1">3131</td>
            <td align="left" colspan="1" rowspan="1">3545</td>
            <td align="left" colspan="1" rowspan="1">3591</td>
            <td align="left" colspan="1" rowspan="1">7355</td>
            <td align="left" colspan="1" rowspan="1">8723</td>
            <td align="left" colspan="1" rowspan="1">8759</td>
            <td align="left" colspan="1" rowspan="1">8759</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">    7</td>
            <td align="left" colspan="1" rowspan="1">66</td>
            <td align="left" colspan="1" rowspan="1">66</td>
            <td align="left" colspan="1" rowspan="1">70</td>
            <td align="left" colspan="1" rowspan="1">68</td>
            <td align="left" colspan="1" rowspan="1">70</td>
            <td align="left" colspan="1" rowspan="1">75</td>
            <td align="left" colspan="1" rowspan="1">3215</td>
            <td align="left" colspan="1" rowspan="1">3610</td>
            <td align="left" colspan="1" rowspan="1">3644</td>
            <td align="left" colspan="1" rowspan="1">7382</td>
            <td align="left" colspan="1" rowspan="1">8735</td>
            <td align="left" colspan="1" rowspan="1">8775</td>
            <td align="left" colspan="1" rowspan="1">8771</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">    10</td>
            <td align="left" colspan="1" rowspan="1">69</td>
            <td align="left" colspan="1" rowspan="1">69</td>
            <td align="left" colspan="1" rowspan="1">70</td>
            <td align="left" colspan="1" rowspan="1">71</td>
            <td align="left" colspan="1" rowspan="1">74</td>
            <td align="left" colspan="1" rowspan="1">75</td>
            <td align="left" colspan="1" rowspan="1">3271</td>
            <td align="left" colspan="1" rowspan="1">3665</td>
            <td align="left" colspan="1" rowspan="1">3688</td>
            <td align="left" colspan="1" rowspan="1">7405</td>
            <td align="left" colspan="1" rowspan="1">8739</td>
            <td align="left" colspan="1" rowspan="1">8782</td>
            <td align="left" colspan="1" rowspan="1">8773</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <fn>
          <p>For mouse, fugu and pig, we examined the relative performances of sequence and multiple alignment databases. The multiple alignment used consisted of baboon, cat, chicken, chimp, cow, dog, human, mouse, pig and rat. The sequence database consisted solely of the closest sequence in the alignment to the query, and the multiple alignment database consisted of the multiple alignment projected to remove columns gapped in the closest sequence. Columns labeled H present results using STANDARD with human as the database, C present results using STANDARD with cow as the database, S present results using STANDARD with the projected alignment as the database, and T present results using Typhon with the projected alignment as the database. The testing methodology was the same as that used for tests comparing sensitivity results on the full alignment. There were in total 10 678 HHAs that could potentially be identified for mouse, 848 for fugu and 11 094 for pig.</p>
        </fn>
      </table-wrap-foot>
    </table-wrap>
  </sec>
</back>
