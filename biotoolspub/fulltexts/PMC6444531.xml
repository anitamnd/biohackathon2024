<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6444531</article-id>
    <article-id pub-id-type="publisher-id">2717</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-019-2717-5</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methodology Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>NITPicker: selecting time points for follow-up experiments</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-1685-6909</contrib-id>
        <name>
          <surname>Ezer</surname>
          <given-names>Daphne</given-names>
        </name>
        <address>
          <email>dezer@turing.ac.uk</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Keir</surname>
          <given-names>Joseph</given-names>
        </name>
        <address>
          <email>jk434@cam.ac.uk</email>
        </address>
        <xref ref-type="aff" rid="Aff3">3</xref>
      </contrib>
      <aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0000 8809 1613</institution-id><institution-id institution-id-type="GRID">grid.7372.1</institution-id><institution>Department of Statistics, University of Warwick, </institution></institution-wrap>Coventry, CV4 7AL UK </aff>
      <aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 5903 3632</institution-id><institution-id institution-id-type="GRID">grid.499548.d</institution-id><institution>The Alan Turing Institute, </institution></institution-wrap>London, NW1 2DB UK </aff>
      <aff id="Aff3"><label>3</label><institution-wrap><institution-id institution-id-type="ISNI">0000000121885934</institution-id><institution-id institution-id-type="GRID">grid.5335.0</institution-id><institution>Department of Applied Mathematics and Theoretical Physics, University of Cambridge, </institution></institution-wrap>Cambridge, CB3 0WA UK </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>2</day>
      <month>4</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>2</day>
      <month>4</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2019</year>
    </pub-date>
    <volume>20</volume>
    <elocation-id>166</elocation-id>
    <history>
      <date date-type="received">
        <day>22</day>
        <month>10</month>
        <year>2018</year>
      </date>
      <date date-type="accepted">
        <day>6</day>
        <month>3</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2019</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is distributed under the terms of the Creative Commons Attribution 4.0 International License(<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver(<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p>The design of an experiment influences both what a researcher can measure, as well as how much confidence can be placed in the results. As such, it is vitally important that experimental design decisions do not systematically bias research outcomes. At the same time, making optimal design decisions can produce results leading to statistically stronger conclusions. Deciding <italic>where</italic> and <italic>when</italic> to sample are among the most critical aspects of many experimental designs; for example, we might have to choose the time points at which to measure some quantity in a time series experiment. Choosing times which are too far apart could result in missing short bursts of activity. On the other hand, there may be time points which provide very little information regarding the overall behaviour of the quantity in question.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>In this study, we develop a tool called NITPicker (Next Iteration Time-point Picker) for selecting optimal time points (or spatial points along a single axis), that eliminates some of the biases caused by human decision-making, while maximising information about the shape of the underlying curves. NITPicker uses ideas from the field of functional data analysis. NITPicker is available on the Comprehensive R Archive Network (CRAN) and code for drawing figures is available on Github (<ext-link ext-link-type="uri" xlink:href="https://github.com/ezer/NITPicker">https://github.com/ezer/NITPicker</ext-link>).</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>NITPicker performs well on diverse real-world datasets that would be relevant for varied biological applications, including designing follow-up experiments for longitudinal gene expression data, weather pattern changes over time, and growth curves.</p>
      </sec>
      <sec>
        <title>Electronic supplementary material</title>
        <p>The online version of this article (10.1186/s12859-019-2717-5) contains supplementary material, which is available to authorized users.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Time series</kwd>
      <kwd>Longitudinal</kwd>
      <kwd>Experimental design</kwd>
      <kwd>Functional data analysis</kwd>
      <kwd>RNA-seq</kwd>
      <kwd>Dynamics</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/501100000727</institution-id>
            <institution>Trinity College, University of Cambridge</institution>
          </institution-wrap>
        </funding-source>
        <award-id>NA</award-id>
      </award-group>
    </funding-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/501100000266</institution-id>
            <institution>Engineering and Physical Sciences Research Council</institution>
          </institution-wrap>
        </funding-source>
        <award-id>EP/S001360/1</award-id>
      </award-group>
    </funding-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100012338</institution-id>
            <institution>Alan Turing Institute</institution>
          </institution-wrap>
        </funding-source>
        <award-id>TU/A/000017</award-id>
      </award-group>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2019</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p>In many areas of experimental science, scientists are interested in the behaviour of some system under a wide range of conditions. For instance, a plant biologist might be interested in measuring gene expression in a set of mutant plant varieties under various environmental conditions, such as varying temperature, watering treatments and light intensities, in what is called a factorial (or multi-factor) experimental design (Fig. <xref rid="Fig1" ref-type="fig">1</xref>a), but these types of experiments can be very expensive [<xref ref-type="bibr" rid="CR1">1</xref>].
<fig id="Fig1"><label>Fig. 1</label><caption><p>Time point selection is an important part of experimental design. <bold>a</bold> Here is an example of a multi-factor experimental design. <bold>b</bold> Given a set of high resolution time courses, sampled at <bold>τ</bold><sub><italic>n</italic></sub> we try to find a subset of time points <bold>t</bold><sub><italic>m</italic></sub> for future follow-up investigations. <bold>c</bold> In this paper, we define good time points as those that enable us to best infer the shape of the function. <bold>d</bold> The time points in a high resolution time course are represented by nodes. In the case shown (i), there are four time points in the high resolution time course. (ii) In the follow-up experiment, time points 2 and 4 are chosen, corresponding to a particular path through the network. The length of this path is the sum of <italic>edge</italic>(0,2), <italic>edge</italic>(2,4) and <italic>edge</italic>(4,5)</p></caption><graphic xlink:href="12859_2019_2717_Fig1_HTML" id="MO1"/></fig></p>
    <p>To complicate matters even more, there are a large number of experiments which do not simply measure some discrete quantity, but instead aim to measure a <italic>function</italic>. Typically, researchers are interested in the behaviour of a quantity <italic>over time</italic> (or, in some cases, space). For example, many genes’ expression levels vary over time in intricate ways, especially since genes are often expressed in bursts. The shape of the burst provides insight into the regulatory mechanisms governing it [<xref ref-type="bibr" rid="CR2">2</xref>, <xref ref-type="bibr" rid="CR3">3</xref>]. Even the degree to which a gene is sensitive to an environmental condition is often time-dependent; for instance, there are a different set of <italic>Arabidopsis thaliana</italic> genes that are sensitive to light at night and during the day [<xref ref-type="bibr" rid="CR4">4</xref>].</p>
    <p>Ideally, a scientist would want to sample at a large number of time points under each experimental condition, but this might not be feasible, especially if the experiments are expensive to run. In such circumstances, the scientist might conduct a small number of high resolution time course experiments, and then use the information gathered to select a subset of time points for further investigation under the entire range of experimental conditions (Fig. <xref rid="Fig1" ref-type="fig">1</xref>b). For example, many high resolution time course experiments have recently been published as part of large projects or consortia, including the high resolution time courses of fruit fly [<xref ref-type="bibr" rid="CR5">5</xref>], roundworm [<xref ref-type="bibr" rid="CR6">6</xref>], or mammalian lung development [<xref ref-type="bibr" rid="CR7">7</xref>], but a small lab that is interested in repeating the experiment under slightly different conditions might not be able to afford to use as many time points. Choosing the right subset of time points is clearly important from the point of view of accuracy, but it will also determine what <italic>kinds</italic> of gene expression perturbations can be observed in the follow-up experiments. For example, if a gene were to have a burst of expression in the first experiment, it would be reasonable for the biologist to select the time point corresponding to the peak of the burst for follow-up experiments (Fig. <xref rid="Fig1" ref-type="fig">1</xref>c). Then, if the gene shifts the timing of its peak gene expression in the experimental condition, this change would be detected by the experiment, although it would not be possible to relate this to a change in the timing of the peak expression using this measurement alone. On the other hand, if the peak gene expression is the same, but the shape of the distribution changes, the biologist would not be able to detect any change at all (Fig. <xref rid="Fig1" ref-type="fig">1</xref>c). Clearly, it would be beneficial to select time points that help us accurately determine the full gene expression profile, while remaining sensitive to the expected types of perturbations.</p>
    <p>In this paper, we develop a new statistical tool, called NITPicker, which selects informative time points for follow-up experiments given a set of example curves from a high resolution time course (Fig. <xref rid="Fig1" ref-type="fig">1</xref>d). NITPicker uses methods from functional data analysis to find these optimal points, and improves on current approaches for selecting time points for follow-up experiments. The growing field of functional data analysis is focused on developing new statistical techniques to analyse data sampled from continuous curves [<xref ref-type="bibr" rid="CR8">8</xref>, <xref ref-type="bibr" rid="CR9">9</xref>]. In our case, in order to determine the relative importance of each time point for follow-up experiments, we need to know what types of curves we might observe under different experimental conditions. If all possible curves are equally likely to be observed in the new experimental conditions, then any set of time points would be equally sensible to select for the follow-up experiments. In reality, we can expect the observed curves to arise from some non-uniform probability density function of curves, whose parameters we must attempt to infer from the example curves that are available.</p>
    <p>Some previous methods for selecting time points for follow-up experiments imagine that all the biological material is collected at each of the original time points and stored, but that the material from each time point is sequenced sequentially based on previous outcomes [<xref ref-type="bibr" rid="CR10">10</xref>, <xref ref-type="bibr" rid="CR11">11</xref>]. However, this is rarely a practical experimental strategy, as it can result in a large amount of wasted time and effort, since biological material is collected at every time point, including those points which are not used in the later analysis. Also, sequencing in parallel can be much quicker and less expensive than sequencing sequentially.</p>
    <p>The recent Time Point Selection (TPS) method developed by [<xref ref-type="bibr" rid="CR12">12</xref>] is a substantial improvement in that it does not depend on this sequential experimental design strategy, and it considers the full shape of the gene expression profile, a strategy also used by NITPicker (Fig. <xref rid="Fig1" ref-type="fig">1</xref>d). However, it has three downsides that might limit its use in practice. First, it uses a greedy search strategy for finding time points, which might be prone to finding local optima rather than global optima. In NITPicker, we identify that an optimisation problem described by [<xref ref-type="bibr" rid="CR12">12</xref>] is in fact the same as a simpler problem in computer science – finding the shortest path through a directed acyclic graph – which can be solved directly by a dynamic programming algorithm (specifically, a modified Viterbi algorithm).</p>
    <p>Second, TPS attempts to find the time points which lead to the most accurate fit <italic>for the data in the training set</italic>, so it might not generalise to new gene expression profiles that differ even slightly from the training set. As such, it is useful for follow-up experiments which attempt to repeat the original experiment at a lower resolution. However, in many experimental situations, we are interested in selecting the time points which provide the most information about <italic>how the curve changes</italic> in experimental conditions. For this reason, in NITPicker we use the training set to develop a probability distribution of gene expression curves [<xref ref-type="bibr" rid="CR13">13</xref>], which allows us to address the slightly different (and more frequently encountered) question of finding the optimal time points for detecting and modelling <italic>perturbations</italic> of the data.</p>
    <p>Third, TPS directly uses gene expression profiles from the high resolution time course to select the new time points, a strategy which is potentially vulnerable to experimental noise. On the one hand, we can imagine a scenario in which, for some period of time, the data is very noisy, before later settling down. In this case, TPS is almost certain to select time points in the noisy region (allowing us to more accurately model the noise), despite this providing very little useful information. On the other hand, individual anomalies in the data might cause TPS to select the associated time points. Since NITPicker uses a probability density over gene expression curves [<xref ref-type="bibr" rid="CR13">13</xref>], this decreases the risk of overfitting the training set, avoiding the latter problem. We also adapt NITPicker for use in the former scenario, by fitting the <italic>inverse coefficient of variation</italic> rather than the data itself.</p>
    <p>Ji and Muller [<xref ref-type="bibr" rid="CR14">14</xref>] developed a similar method to TPS, which has expanded utility since it can find the best time points for performing a linear regression, something that we do not address in this manuscript. Another benefit is that they smooth the functions using functional Principle Component Analysis (fPCA), which we also apply. However, they also suffer from some of the same issues as TPS. Namely, (i) they do not find a probability distribution in the space of functions, but instead fit to the input data directly and (ii) they use either an exhaustive search that is extremely slow or a greedy algorithm that does not guarantee optimality, rather than a dynamic programming algorithm that finds the optimal solution in a reasonable runtime.</p>
    <p>In summary, NITPicker does not get trapped in local optima, addresses a wider range of experimental design questions, and is less sensitive to noise in the training set.</p>
  </sec>
  <sec id="Sec2" sec-type="results">
    <title>Results</title>
    <sec id="Sec3">
      <title>NITPicker can select time points that describe the shape of a curve</title>
      <p>NITPicker is a tool that uses a small number of high resolution time course experiments to select a small set of time points to analyse in follow-up experiments. In order to determine how well NITPicker performs in practice, we apply it to three real-world examples that address the three different experimental design questions corresponding to the <italic>f</italic><sub>1</sub>, <italic>f</italic><sub>2</sub> and <italic>f</italic><sub>3</sub> metrics defined the “<xref rid="Sec8" ref-type="sec">Methods</xref>” section. More specifically, these metrics correspond with the goals of selecting a subset of time points that i) accurately describe the shape of the curve ii) accurately describe the difference between an experimental and control condition and iii) perform goals (i) and (ii) but with preference towards regions of the time series that are less noisy.</p>
      <p>First, we test the performance of NITPicker when minimising <italic>f</italic><sub>1</sub>, which means that we are trying to accurately model the shape of the curves. As this is the same problem proposed by [<xref ref-type="bibr" rid="CR12">12</xref>], we compared the performance of NITPicker to their TPS method, using three different datasets – the same lung gene expression dataset used in [<xref ref-type="bibr" rid="CR12">12</xref>], the gene expression of direct targets of the circadian clock gene ELF4 in a longitudinal <italic>Arabidopsis</italic> study across two days at different temperatures [<xref ref-type="bibr" rid="CR15">15</xref>], and the gene expression profiles of developmental genes in a <italic>C. elegans</italic> developmental time-course [<xref ref-type="bibr" rid="CR6">6</xref>] (Fig. <xref rid="Fig2" ref-type="fig">2</xref>a). In this case, we are presented with an RNA-seq experiment in only one experimental condition, but containing a large number of genes. Within each dataset, the selected subset of genes have similar functional roles, so a reasonable hypothesis appears to be that the corresponding gene expression curves are all drawn from a single probability distribution over curves. To determine if this is an accurate model, we randomly split the dataset into two equal partitions of genes – a training set and a testing set. We then use NITPicker or TPS to select the a subset of eight time points based on the training set, and calculate the L2-error on the genes in the testing set. We repeated this procedure fifty times for each dataset. NITPicker performs equally well as TPS on the less structured lung data, and significantly better than TPS on the more structured <italic>Arabidopsis</italic> and <italic>C. elegans</italic> datasets. This result held even when only a third of the data was used for training and two-thirds was used for testing (Fig. <xref rid="Fig2" ref-type="fig">2</xref>b).
<fig id="Fig2"><label>Fig. 2</label><caption><p>Time point selection for gene expression data. <bold>a</bold> The gene expression curves in the lung, <italic>C. elegans</italic>, and <italic>Arabidopsis</italic> datasets used to test NITPicker. <bold>b</bold> After selecting 8 time points using the training data, the log(L2-error) was calculated on the test data. The training and testing sets were split 50-50, unless specified</p></caption><graphic xlink:href="12859_2019_2717_Fig2_HTML" id="MO2"/></fig></p>
    </sec>
    <sec id="Sec4">
      <title>NITPicker can select time points that distinguish between experimental and control conditions</title>
      <p>In functional data analysis, two of the standard datasets for testing new algorithms are the Canada weather dataset [<xref ref-type="bibr" rid="CR8">8</xref>] and the Berkeley growth dataset [<xref ref-type="bibr" rid="CR16">16</xref>], both of which provide additional examples of real world data with a functional form. Biologists are often interested in how genes and environments interact to produce phenotypes. We have already shown how NITPicker can be applied to gene expression data, but now we show that it can be applicable in understanding environmental data (such as temperature over time) and phenotypic data (growth curves).</p>
      <p>The Canada dataset contains the average temperature measured each month across a number of Canadian cities, and we use this to test NITPicker’s performance when minimising <italic>f</italic><sub>2</sub> (see “<xref rid="Sec9" ref-type="sec">Defining good time points</xref>” subsection in the methods section for the definitions of the mathematical quantities referred to here). Suppose that we are interested in the difference in weather between cities in Canada and Resolute, one of its most northerly and coldest cities. In other words, we will be finding the value of <italic>f</italic><sub>2</sub>, where <italic>g</italic> is the weather of Resolute and <italic>w</italic> is the weather of the other Canadian cities. Suppose (for the sake of illustrating our methods) that we are in a position to sample the weather patterns in some new cities in Canada, but we can only afford to measure the weather in 5 of the 12 months. The raw data is shown in Fig. <xref rid="Fig3" ref-type="fig">3</xref>a, showing that we can generate a sensible probability density function for temperature curves in Canada. The best months to sample according to NITPicker are drawn as vertical lines.
<fig id="Fig3"><label>Fig. 3</label><caption><p>Applying NITPicker. <bold>a</bold> Monthly temperatures from a set of cities in Canada are shown in black. For the purpose of this paper, we consider the ‘control’ condition to be the temperature of Resolute, Canada, which is shown in red. A probability distribution of curves was constructed on the basis of the temperature curves for all cities – curves sampled from this probability distribution are indicated in dashed-blue lines. The vertical lines represent the ‘best time points’ to sample from, according to NITPicker. <bold>b</bold> For each of ten replicates, we selected the time points to sample using half the city curves, and scored the selection of time points on the other half of the city curves. For each city in the test set, we calculated the <italic>L</italic><sup>2</sup>-error between the curve generated by sampling every month and the curve generated by linear interpolation between the selected subset of time points. <bold>c</bold> Here we present an example of how we evaluate a test set for a selection of time points (vertical bars) selected by NITPicker (i), random (ii), and evenly sampled (iii). The coloured-in area displays the error that arrises from sampling only at the designated time points. <bold>d</bold> The growth rate of boys and girls from the Berkeley growth dataset were used to develop probability distributions of curves for boys and girls, with sampled curves shown in <bold>e</bold>. <bold>f</bold> We were interested in estimating the shape of the inverse coefficient of variation, shown in this figure. The selected time points are shown as vertical bars in D-F. <bold>g</bold> We used half the boy curves and half the girl curves to select time points to sample from, and to train a DD-classifier [<xref ref-type="bibr" rid="CR18">18</xref>, <xref ref-type="bibr" rid="CR19">19</xref>], and then calculated the percent accuracy on the other half of the boy and girl curves. This procedure was repeated 30 times with each method of selecting time points (selecting all the time points, 5 time points with NITPicker, 5 time points randomly, and 5 time points evenly)</p></caption><graphic xlink:href="12859_2019_2717_Fig3_HTML" id="MO3"/></fig></p>
      <p>To test the accuracy of the approach, we randomly split the cities into two equally sized groups – a training set and a testing set. We use the training set to select a subset of time points using NITPicker, and then we test the strength of these time points on the test set of cities. More specifically, we evaluate the <italic>L</italic><sup>2</sup>-distance between the curves produced by sampling at all points and those produced by sampling only at the time points selected by NITPicker. We find that NITPicker-selected time points perform better on the testing set than either randomly sampled points or evenly sampled points (Fig. <xref rid="Fig3" ref-type="fig">3</xref>b), an example illustrating this is shown in Fig. <xref rid="Fig3" ref-type="fig">3</xref>c. This demonstrates that NITPicker can be used successfully to select time points that help distinguish between a control curve and a distribution of curves from experimental conditions.</p>
    </sec>
    <sec id="Sec5">
      <title>NITPicker can avoid time points with noisy values</title>
      <p>Growth curves are important in a number of different disciplines in biology, from childhood development [<xref ref-type="bibr" rid="CR16">16</xref>] to plant sciences [<xref ref-type="bibr" rid="CR17">17</xref>]. The third dataset represents growth data from a group of boys and girls (Fig. <xref rid="Fig3" ref-type="fig">3</xref>d) – despite the unusual shape of the curves, it is possible to develop a reasonable probability distribution of growth curves (Fig. <xref rid="Fig3" ref-type="fig">3</xref>e). The largest variance in growth rates is found in the early years; however, from the point of view of distinguishing the two populations, the most informative difference in growth rates between boys and girls is seen during adolescence. Suppose that we want to sample at time points that can help us accurately determine the difference in growth rates between girls and boys. In other words, we don’t mind if the shape of the curve is less accurate in periods of time with lots of variability, but we wish to accurately estimate the shape of the difference between girls and boys in periods of time with less variability within each population – for this we are interested in minimising <italic>f</italic><sub>3</sub> (see Fig. <xref rid="Fig3" ref-type="fig">3</xref>f, and see “<xref rid="Sec9" ref-type="sec">Defining good time points</xref>” subsection for the definition of <italic>f</italic><sub>3</sub>). The point of this exercise is to select time points that help us estimate the shape of the difference between girl and boy curves; however, as by-product of the procedure we might hope that we can select time points that are reasonable at predicting whether an individual growth curve comes from a boy or a girl. Similar to our analysis for the Canada dataset, we split the curves into training and testing sets, but this time we not only select a set of time points using the training set, but we also train a classifier commonly used to classify functional data [<xref ref-type="bibr" rid="CR18">18</xref>, <xref ref-type="bibr" rid="CR19">19</xref>]. Although, as expected, the best classifier used all the time points, NITPicker-selected time points could be used to develop a more accurate classifier than selecting time points either evenly or randomly (Fig. <xref rid="Fig3" ref-type="fig">3</xref>g).</p>
    </sec>
  </sec>
  <sec id="Sec6" sec-type="discussion">
    <title>Discussion</title>
    <p>In this paper we have presented NITPicker, an algorithm for selecting a subset of time points in time course experiment in a variety of experimental design situations. In contrast to previous strategies [<xref ref-type="bibr" rid="CR10">10</xref>–<xref ref-type="bibr" rid="CR12">12</xref>], NITPicker takes full advantage of the <italic>functional</italic> nature of the data to produce a non-parametric probability distribution over curves [<xref ref-type="bibr" rid="CR13">13</xref>], which is then used to select the optimal time points. This approach minimises the risk of over-fitting the data, while also being better adapted to the situation in which the new time points are being selected for use in experiments which are run under <italic>different conditions</italic> to those used to collect the original data.</p>
    <p>The goal of NITPicker is to select points so that, if you interpolate between data sampled at these time points, you form an accurate representation of the underlying curve. This goal is distinct from the closely related, but fundamentally different goal of finding a small set of points that allow the researcher to reconstruct the rest of the curve, which is sometimes referred to as <italic>trajectory reconstruction</italic> (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S1a). For instance, it is possible that a time point’s value might be highly correlated to a much later time point’s value, so that in theory only one of these time points must be sampled, and the value at the second time point can be inferred. In this case, a method such as the one proposed by [<xref ref-type="bibr" rid="CR14">14</xref>] might suggest sampling at a smaller number of time points; however, a downside is that the scientist would not be able to directly observe the curve, so they would need to trust that the previously observed correlations between time points will continue to hold under new experimental conditions. If the goal of the scientist is to sample at a few points, and then reconstruct the underlying curve using a predetermined method (such a spline fitting), then NITPicker is the appropriate tool.</p>
    <p>Similarly, NITPicker does not find the time points that are the best time points for distinguishing between control groups and experimental groups, because the goal is to accurately characterise the profile of the temporal differences between the experimental and control group over time. Many biologists are not interested in diagnosing the type of exposure, but are instead interested in learning how the experimental groups differ from one another. However, we show that as a side effect, the time points that are selected can distinguish between experimental groups better than random or evenly selected time points (Fig. <xref rid="Fig3" ref-type="fig">3</xref>). If the goal of the researcher is to be able to distinguish between experimental and control groups, a binary classifier would be a more appropriate tool.</p>
    <p>NITPicker is especially designed to find good time points for new experiments, so if there are lots of temporal shifts in the curves it will find time points that will be useful in the case of similar types of temporal shifts (Additional file <xref rid="MOESM2" ref-type="media">2</xref>: Figure S2b). This might be especially useful for researchers who study systems where the same features are expected to appear in all samples over the time series, but the timing of those features might vary.</p>
    <p>The output of NITPicker depends on which curves are included in the analysis. To ensure that the selected time points are most reflective of biologically interesting behaviours, the biologist can choose to only include curves that are less noisy or that are most relevant for the biological question at hand. For example, a biologist might focus on genes that are regulated by a certain transcription factor or that have a specific gene ontology of interest. To filter noisy curves, it might be a good idea to use a tool like edge [<xref ref-type="bibr" rid="CR20">20</xref>] to identify curves that smoothly change their level over the time course. Finally, a biologist may have some strategy to quantify the importance of genes, and these weights can be provided to NITPicker. NITPicker can take as few as three high resolution time series as input, and this creates reasonable probability distributions of simple curves (See Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S1). However, it is important to always visualise the probability distributions of curves using the <italic>getPerturbation</italic> function in the NITPicker package, to ensure that these seem to accurately reflect the observed data. The more high resolution curves are available under different experimental conditions, the more likely it will be that the optimal time points are selected for future experiments.</p>
    <p>NITPicker uses a dynamic programming algorithm to select the optimal time points, which provides an efficient method that is guaranteed to find the optimal solution (unlike the greedy algorithm used in TPS [<xref ref-type="bibr" rid="CR12">12</xref>]). One of the downsides of using this dynamic programming algorithm is that it only outputs the predicted optimal set of time points, but does not provide an easy way of evaluating the confidence in this prediction. We tested NITPicker on a variety of simulated and real-life datasets, and demonstrated the flexibility of this tool by addressing different experimental design questions in each case.</p>
  </sec>
  <sec id="Sec7" sec-type="conclusion">
    <title>Conclusion</title>
    <p>NITPicker provides a useful tool for selecting informative time points that avoids the pitfalls of ad hoc human decisions. Specifically, it can select the optimal time points to address a variety of different experimental goals, including accurately predicting the shape of a curve, accurately predicting the perturbations to some base-line curve, or selecting time points which are most informative (i.e. avoiding regions of random noise). By choosing time points using NITPicker, researchers are likely to obtain results with more statistical power, while at the same time avoiding bias.</p>
  </sec>
  <sec id="Sec8">
    <title>Methods</title>
    <sec id="Sec9">
      <title>Defining good time points</title>
      <p>In order to compare the strengths and weaknesses of each heuristic, we need to clearly define of what constitutes a <italic>good</italic> time point to select. One possible strategy would be to try to select a set of time points that are best able to distinguish the shape of the curves. For this we select a criteria very similar to that presented by [<xref ref-type="bibr" rid="CR12">12</xref>] and [<xref ref-type="bibr" rid="CR14">14</xref>] in that we want to minimise the <italic>L</italic><sup>2</sup>-distance between the curve generated by sampling at all the time points, and the curve generated by sampling only at a subset of time points. However, the other methods minimise this distance over all curves in the training set – instead, we use the training set to generate a probability density over the space of curves, and then minimise the expected distance. Some of the advantages of this approach have already been mentioned in the introduction.</p>
      <p>First, we will describe the functions that the NITPicker algorithm minimises, so that the overall goal of NITPicker is clear from the beginning. We will start by describing the input functions (<italic>w</italic>) in terms of a set of parameters (<italic>μ</italic>). However, there are many ways of parameterising a function – for instance, any function can be represented as a linear combination of a Fourier, B-spline, or polynomial basis, and the parameters that specify the function would be the relevant coefficients (such as <italic>a</italic><sub>0</sub>, <italic>a</italic><sub>1</sub>, and <italic>a</italic><sub>2</sub> in <italic>y</italic>(<italic>t</italic>)=<italic>a</italic><sub>0</sub>+<italic>a</italic><sub>1</sub><italic>x</italic>(<italic>t</italic>)+<italic>a</italic><sub>2</sub><italic>x</italic><sup>2</sup>(<italic>t</italic>) if the function was a quadratic function). At this stage, we do not describe how the functions are parameterised, but our choice is described in detail in “<xref rid="Sec10" ref-type="sec">Defining a non-parametric probability density function of curves</xref>” section. In brief, we parameterise the curves by the functional principle components of the x-axis and y-axis deformations from the mean curve.</p>
      <p>Suppose that we have an initial high resolution time course, with data sampled at times <bold><italic>τ</italic></bold>={<italic>τ</italic><sub>1</sub>,<italic>τ</italic><sub>2</sub>,...<italic>τ</italic><sub><italic>N</italic></sub>}. We must select a subset of these time points, which we will call <bold><italic>t</italic></bold>={<italic>t</italic><sub>1</sub>,<italic>t</italic><sub>2</sub>,...<italic>t</italic><sub><italic>M</italic></sub>}, so as to minimise the expected error: 
<disp-formula id="Equ1"><label>1</label><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ f_{1}(\boldsymbol{t}):= \int ||w(t;\boldsymbol{\tau}, \mu)-w(t;\boldsymbol{t}, \mu) ||^{2}_{L^{2}(t,[\tau_{1},\tau_{N}])}P(\mu) \mathrm{d} \mu  $$ \end{document}</tex-math><mml:math id="M2"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">t</mml:mi><mml:mo>)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo>∫</mml:mo><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mi>w</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">τ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi><mml:mo>)</mml:mo><mml:mo>−</mml:mo><mml:mi>w</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">t</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi><mml:mo>)</mml:mo><mml:mo>|</mml:mo><mml:munderover><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub><mml:mo>]</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:munderover><mml:mi>P</mml:mi><mml:mo>(</mml:mo><mml:mi>μ</mml:mi><mml:mo>)</mml:mo><mml:mi mathvariant="normal">d</mml:mi><mml:mi>μ</mml:mi></mml:math><graphic xlink:href="12859_2019_2717_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>where <italic>w</italic>(<italic>t</italic>;<bold><italic>t</italic></bold>,<italic>μ</italic>) is a gene expression function evaluated at the time <italic>t</italic>, parameterised by a set of parameters <italic>μ</italic> and interpolated between time points in the set <bold><italic>t</italic></bold> (either through a linear interpolation or spline), and <italic>P</italic>(<italic>μ</italic>)d<italic>μ</italic> is a probability measure on the space of parameters (i.e. <italic>P</italic>(<italic>μ</italic>) is the probability density associated with the set of parameters <italic>μ</italic>). We use the standard notation for <italic>L</italic><sup>2</sup> norms, that is, given a function <italic>w</italic>(<italic>t</italic>;<italic>μ</italic>) of time <italic>t</italic> and some parameters <italic>μ</italic> we define 
<disp-formula id="Equa"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$||w(t;\mu)||_{L^{2}(t, [\tau_{1}, \tau_{2}])} := \left(\int_{\tau_{1}}^{\tau_{2}} \left(w(t;\mu)\right)^{2} \mathrm{d} t \right)^{\frac{1}{2}} $$ \end{document}</tex-math><mml:math id="M4"><mml:mrow><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mi>w</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi>μ</mml:mi><mml:mo>)</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>]</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:munderover><mml:mrow><mml:mo>∫</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:mi>w</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi>μ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi mathvariant="normal">d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:msup></mml:mrow></mml:math><graphic xlink:href="12859_2019_2717_Article_Equa.gif" position="anchor"/></alternatives></disp-formula> In many cases we are not necessarily interested in the shape of the curve, but rather the difference between the control and an experimental condition. Let <italic>g</italic>(<bold><italic>t</italic></bold>,<italic>ν</italic>) be the gene expression curve in the control condition, parameterised by <italic>ν</italic> and sampled at time points <italic>t</italic>. Then we want to minimize the expected error in the difference: 
<disp-formula id="Equ2"><label>2</label><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ \begin{aligned} f_{2}(\boldsymbol{t}) &amp;:= \iint|| \left(g(t;\boldsymbol{t}, \nu)-w(t;\boldsymbol{t}, \mu)\right) -(g(t;\boldsymbol{\tau}, \nu) \\ &amp;\quad-w(t;\boldsymbol{\tau}, \mu)) ||^{2}_{L_{2}(t,[\tau_{1},\tau_{N}])} P_{1}(\mu)P_{2}(\nu)\mathrm{d}\mu \mathrm{d}\nu \end{aligned}  $$ \end{document}</tex-math><mml:math id="M6"><mml:mspace width="-15.0pt"/><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">t</mml:mi><mml:mo>)</mml:mo></mml:mtd><mml:mtd><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo>∬</mml:mo><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">t</mml:mi><mml:mo>,</mml:mo><mml:mi>ν</mml:mi><mml:mo>)</mml:mo><mml:mo>−</mml:mo><mml:mi>w</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">t</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mfenced><mml:mo>−</mml:mo><mml:mo>(</mml:mo><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">τ</mml:mi><mml:mo>,</mml:mo><mml:mi>ν</mml:mi><mml:mo>)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="1em"/><mml:mo>−</mml:mo><mml:mi>w</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">τ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi><mml:mo>)</mml:mo><mml:mo>)</mml:mo><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub><mml:mo>]</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>μ</mml:mi><mml:mo>)</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>ν</mml:mi><mml:mo>)</mml:mo><mml:mi mathvariant="normal">d</mml:mi><mml:mi>μ</mml:mi><mml:mi mathvariant="normal">d</mml:mi><mml:mi>ν</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="12859_2019_2717_Article_Equ2.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>If there is only one ‘control’ curve (for instance, if the scientists have not included replicates), then there would only be one possible value for the parameters <italic>ν</italic> and the equation is simplified to: 
<disp-formula id="Equ3"><label>3</label><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ \begin{aligned} &amp; f_{2}(\boldsymbol{t}) := \int|| \left(g(t;\boldsymbol{t})-w(t;\boldsymbol{t}, \mu)\right) \\ &amp;\phantom{\sum_{m=1}^{M}\int_{\nu} \int_{\mu}||} -\left(g(t;\boldsymbol{\tau})-w(t;\boldsymbol{\tau}, \mu) \right) ||^{2}_{L_{2}(t,[\tau_{1},\tau_{N}])} P(\mu) \mathrm{d}\mu \end{aligned}  $$ \end{document}</tex-math><mml:math id="M8"><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">t</mml:mi><mml:mo>)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo>∫</mml:mo><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">t</mml:mi><mml:mo>)</mml:mo><mml:mo>−</mml:mo><mml:mi>w</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">t</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mfenced></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>−</mml:mo><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">τ</mml:mi><mml:mo>)</mml:mo><mml:mo>−</mml:mo><mml:mi>w</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">τ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mfenced><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub><mml:mo>]</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mi>P</mml:mi><mml:mo>(</mml:mo><mml:mi>μ</mml:mi><mml:mo>)</mml:mo><mml:mi mathvariant="normal">d</mml:mi><mml:mi>μ</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="12859_2019_2717_Article_Equ3.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>Note that <italic>f</italic><sub>1</sub> is a special case of <italic>f</italic><sub>2</sub> where <italic>g</italic>(<italic>t</italic>;<bold><italic>t</italic></bold>)=0.</p>
      <p>If there are periods of time with different amounts of random variability, then we might wish to sample less frequently in areas that have lots of variability – we might accept having less accuracy in predicting the shape of the curves in noisy regions if we can accurately model their shapes in regions with less noise. To accomplish this, we should attempt to find the shape of the curve representing the difference between the control and experimental conditions <italic>normalised by the variance</italic>. In other words, we minimise the expected error in the <italic>inverse of the coefficient of variation</italic>. We first define <italic>z</italic>: 
<disp-formula id="Equ4"><label>4</label><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ \begin{aligned} &amp;z(t;\boldsymbol{t}, \boldsymbol{\tau}, \nu, \mu) := \left(g(t;\boldsymbol{t}, \nu)-w(t;\boldsymbol{t}, \mu)\right) \\ &amp;\phantom{z(t;\boldsymbol{t}, \boldsymbol{\tau}, \nu, \mu) :=} - \left(g(t; \boldsymbol{\tau}, \nu)-w(t;\boldsymbol{\tau}, \mu) \right) \end{aligned}  $$ \end{document}</tex-math><mml:math id="M10"><mml:mtable><mml:mtr><mml:mtd><mml:mtable><mml:mtr><mml:mtd><mml:mi>z</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">t</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">τ</mml:mi><mml:mo>,</mml:mo><mml:mi>ν</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi><mml:mo>)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">t</mml:mi><mml:mo>,</mml:mo><mml:mi>ν</mml:mi><mml:mo>)</mml:mo><mml:mo>−</mml:mo><mml:mi>w</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">t</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mfenced></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>−</mml:mo><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">τ</mml:mi><mml:mo>,</mml:mo><mml:mi>ν</mml:mi><mml:mo>)</mml:mo><mml:mo>−</mml:mo><mml:mi>w</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">τ</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mfenced></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="12859_2019_2717_Article_Equ4.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>and then: 
<disp-formula id="Equ5"><label>5</label><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ \begin{aligned} &amp;f_{3}(\boldsymbol{t}):= \\ &amp;\iint \bigg|\bigg| \frac{z(t;\boldsymbol{t}, \boldsymbol{\tau}, \nu, \mu)}{ \sqrt{\text{Var} (z(t;\boldsymbol{t}, \boldsymbol{\tau}, \nu, \mu))}} \bigg|\bigg|^{2}_{L_{2}(t, [\tau_{1}, \tau_{N}])} P_{1}(\mu)P_{2}(\nu)\mathrm{d}\mu \mathrm{d}\nu \end{aligned}  $$ \end{document}</tex-math><mml:math id="M12"><mml:mspace width="-12.0pt"/><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">t</mml:mi><mml:mo>)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>∬</mml:mo><mml:mstyle mathsize="2.03em"><mml:mfenced close="" open="|" separators=""><mml:mrow/></mml:mfenced></mml:mstyle><mml:mstyle mathsize="2.03em"><mml:mfenced close="" open="|" separators=""><mml:mrow/></mml:mfenced></mml:mstyle><mml:mfrac><mml:mrow><mml:mi>z</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">t</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">τ</mml:mi><mml:mo>,</mml:mo><mml:mi>ν</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mtext>Var</mml:mtext><mml:mo>(</mml:mo><mml:mi>z</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">t</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">τ</mml:mi><mml:mo>,</mml:mo><mml:mi>ν</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac><mml:mstyle mathsize="2.03em"><mml:mfenced close="" open="|" separators=""><mml:mrow/></mml:mfenced></mml:mstyle><mml:munderover><mml:mrow><mml:mstyle mathsize="2.03em"><mml:mfenced close="" open="|" separators=""><mml:mrow/></mml:mfenced></mml:mstyle></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub><mml:mo>]</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>μ</mml:mi><mml:mo>)</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>ν</mml:mi><mml:mo>)</mml:mo><mml:mi mathvariant="normal">d</mml:mi><mml:mi>μ</mml:mi><mml:mi mathvariant="normal">d</mml:mi><mml:mi>ν</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="12859_2019_2717_Article_Equ5.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>where the variance is itself a function of <italic>t</italic>: it is the variance of the function <italic>z</italic>(<italic>t</italic>;<bold><italic>τ</italic></bold>,<bold><italic>t</italic></bold>,<italic>ν</italic>,<italic>μ</italic>) with respect to the probability measure <italic>P</italic><sub>1</sub>(<italic>μ</italic>)d<italic>μ</italic><italic>P</italic><sub>2</sub>(<italic>ν</italic>)d<italic>ν</italic>.</p>
      <p>There are many criteria that might be used to determine the “optimal” set of time points to select, but for the purpose of this manuscript we focus on these three criteria, as they are intuitive, relatively simple, and – as we shall see later – the best solution can be computed exactly with a dynamic programming algorithm. Note also that our algorithm can easily be adapted to deal with many other criteria. For example, if it is important to accurately measure both the curve <italic>and its first</italic><italic>s</italic> derivatives, then we can simply replace the <italic>L</italic><sup>2</sup> norms in the above expressions with the norms associated with the Sobolev spaces <italic>H</italic><sup><italic>s</italic></sup>. Additionally, if the scientist can quantify the <italic>importance</italic> of each gene, they can add weights, for instance by multiplying each <italic>x</italic><sub><italic>i</italic></sub>(<italic>t</italic>) in <italic>f</italic><sub>1</sub> by its corresponding weight.</p>
    </sec>
    <sec id="Sec10">
      <title>Defining a non-parametric probability density function of curves</title>
      <p>In order to effectively find the subset of time points that minimise <italic>f</italic><sub>1</sub>, <italic>f</italic><sub>2</sub>, or <italic>f</italic><sub>3</sub>, we need a method to derive, from a set of example curves, the probability of observing particular curves in future experiments.</p>
      <p>First, suppose that we have chosen some way of parameterising curves using a set of parameters <italic>μ</italic>. Let <italic>g</italic><sub><italic>a</italic></sub>(<italic>t</italic>) be the curve produced in the <italic>a</italic>-th high resolution time course experiment, and let <inline-formula id="IEq1"><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mu _{g_{a}}$\end{document}</tex-math><mml:math id="M14"><mml:msub><mml:mrow><mml:mi>μ</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="12859_2019_2717_Article_IEq1.gif"/></alternatives></inline-formula> be the associated parameters. Given the whole set of such parameters associated with all the high resolution time courses, we want to generate a probability density function <italic>P</italic>(<italic>μ</italic>) on the parameter space.</p>
      <p>In some cases, a scientist might have a model in mind that describes the functions – in this case they can directly fit the parameters. However, in most cases we’ve encountered scientists do not have such a model, nor can one be justified on theoretical grounds, so we need a <italic>non-parametric</italic> way of defining a probability distribution of functions given a set of examples. In the discipline of functional data analysis, techniques have been developed to define these probability distributions – see [<xref ref-type="bibr" rid="CR13">13</xref>] – a process that involves first aligning the functions (“registration”) and then parameterising the horizontal and vertical shifts (using functional Principle Component Analysis). Both the horizontal and vertical shifts are parameterised, so curves that are sampled from the probability density function of curves will have similar x-axis and y-axis deformations as the original curves. For completeness, we will summarise their protocol below (Additional file <xref rid="MOESM3" ref-type="media">3</xref>: Figure S3).</p>
      <p>First, we take a set of known functions (our set of high resolution functions, <italic>g</italic><sub><italic>a</italic></sub>(<italic>t</italic>)) and <italic>align</italic> them. In order to effectively align the gene expression curves in a shape preserving way, we define a distance between curves in terms of the square root slope function (SRSF): 
<disp-formula id="Equb"><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$q(t)=\text{sign}(\dot{f}(t))\sqrt{|\dot{f}(t)|} $$ \end{document}</tex-math><mml:math id="M16"><mml:mrow><mml:mi>q</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mtext>sign</mml:mtext><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mo>˙</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>)</mml:mo><mml:msqrt><mml:mrow><mml:mo>|</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mo>˙</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:msqrt></mml:mrow></mml:math><graphic xlink:href="12859_2019_2717_Article_Equb.gif" position="anchor"/></alternatives></disp-formula> Note that, given <italic>q</italic>(<italic>t</italic>) and the initial value <italic>f</italic>(0), we can recover the corresponding function <italic>f</italic>(<italic>t</italic>) via <inline-formula id="IEq2"><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$f(t)=f(0)+\int _{0}^{t}{q(s)|q(s)|}ds$\end{document}</tex-math><mml:math id="M18"><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:munderover><mml:mrow><mml:mo>∫</mml:mo></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:munderover><mml:mi>q</mml:mi><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:mo>)</mml:mo><mml:mo>|</mml:mo><mml:mi>q</mml:mi><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:mo>)</mml:mo><mml:mo>|</mml:mo><mml:mtext mathvariant="italic">ds</mml:mtext></mml:math><inline-graphic xlink:href="12859_2019_2717_Article_IEq2.gif"/></alternatives></inline-formula>.</p>
      <p>Now, we define the <italic>y</italic>-distance between functions <italic>h</italic><sub>1</sub> and <italic>h</italic><sub>2</sub> as 
<disp-formula id="Equ6"><label>6</label><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$  D_{y}(h_{1}, h_{2}):=\inf_{\gamma \in \Gamma}||q_{1}(t)-(q_{2} \circ \gamma)(t) \sqrt{\dot{\gamma}(t)}||_{L^{2}(t, [\tau_{1}, \tau_{n}])}  $$ \end{document}</tex-math><mml:math id="M20"><mml:mspace width="-12.0pt"/><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>inf</mml:mo></mml:mrow><mml:mrow><mml:mi>γ</mml:mi><mml:mo>∈</mml:mo><mml:mi>Γ</mml:mi></mml:mrow></mml:munder><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>−</mml:mo><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>∘</mml:mo><mml:mi>γ</mml:mi><mml:mo>)</mml:mo><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:msqrt><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>γ</mml:mi></mml:mrow><mml:mo>˙</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msqrt><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>]</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:math><graphic xlink:href="12859_2019_2717_Article_Equ6.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>where <italic>γ</italic> is a function defining the amount of <italic>x</italic>-axis warp, and <italic>Γ</italic>⊂<italic>L</italic><sup>2</sup> is the set of <italic>warping functions</italic>. <italic>γ</italic>∈<italic>Γ</italic> must have some special properties: (i) <italic>γ</italic>(<italic>t</italic>)∈[0,1] (ii) <italic>γ</italic> is monotonically increasing (i.e its slope is positive) (iii) <inline-formula id="IEq3"><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$||\gamma (t)||_{L^{2}(t)}=1\phantom {\dot {i}\!}$\end{document}</tex-math><mml:math id="M22"><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mi>γ</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math><inline-graphic xlink:href="12859_2019_2717_Article_IEq3.gif"/></alternatives></inline-formula>. Because of this last point, the warping functions must lie on the <italic>unit sphere in</italic>
<italic>L</italic><sup>2</sup>, which can be thought of as an infinite-dimensional sphere.</p>
      <p>Given a function <italic>g</italic><sub>(mean)</sub> (see [<xref ref-type="bibr" rid="CR13">13</xref>] for the appropriate <italic>g</italic><sub>(mean)</sub>), a dynamic programming algorithm is used to find a vector of functions <bold><italic>γ</italic></bold>=(<italic>γ</italic><sub><italic>a</italic></sub>(<italic>t</italic>)), where <italic>γ</italic><sub><italic>a</italic></sub> corresponds to the warping function found when computing <italic>D</italic><sub><italic>y</italic></sub>(<italic>g</italic><sub>(mean)</sub>,<italic>g</italic><sub><italic>a</italic></sub>) (see Eq. <xref rid="Equ6" ref-type="">6</xref>). It also provides us with a set of aligned functions <italic>f</italic><sub><italic>a</italic></sub> and a corresponding set of aligned <italic>q</italic> functions <italic>q</italic><sub><italic>a</italic></sub>. SRSF is a continuous alignment algorithm that ensures that the aligned curves are differentiable, so it does not lead to alignment artefacts observed when applying feature registration or discrete dynamic time warping algorithms.</p>
      <p>We would like use the set of warping functions <italic>γ</italic><sub><italic>a</italic></sub> to define a probability density function on (some subset of) <italic>Γ</italic>. However, <italic>Γ</italic> is not a linear space: given two warping function <italic>γ</italic><sub>1</sub> and <italic>γ</italic><sub>2</sub>, their sum <italic>γ</italic><sub>1</sub>+<italic>γ</italic><sub>2</sub> cannot be interpreted as a warping function, since it will not lie on the unit sphere in <italic>L</italic><sup>2</sup>. Hence, we cannot immediately apply functional Principal Component Analysis. Instead, we linearise the space <italic>Γ</italic> by first finding the centroid of the points <italic>γ</italic><sub><italic>a</italic></sub> on the surface of the sphere (the “Karcher mean”, <italic>γ</italic><sub>(mean)</sub>). Note that this is itself a function of <italic>t</italic>. Next, we use the <italic>exponential map</italic> at <italic>γ</italic><sub>(mean)</sub>, which provides us with a map from the tangent space at <italic>γ</italic><sub>(mean)</sub> (which <italic>is</italic> a linear space) to the sphere itself. More precisely, given a tangent vector to the sphere, we find the point on the sphere reached by exponentiating this tangent vector, using the Lie-group structure (under composition) of the unit sphere in <italic>L</italic><sup>2</sup>. In this way, we can associate a vector in the tangent space at <italic>γ</italic><sub>(mean)</sub> to each of the warping functions <italic>γ</italic><sub><italic>a</italic></sub>. This linearisation step should not affect small perturbations, but may exaggerate the differences between pairs of outliers– any two curves that differ substantially from the other curves will be considered farther apart from each other than in reality.</p>
      <p>Now, to decrease the dimensionality of the space (and to decrease the number of free parameters in the model), we can perform a functional Principle Component Analysis (fPCA) of this linearised space, then fit an independent normal distribution along each principle axis. This gives us a probability density on the tangent space. Finally, we can use the exponential map again to map this probability density function directly onto the sphere.</p>
      <p>An fPCA can also be performed on the y-axis deformations. This time, the functions defining the <italic>y</italic>-axis deformations are simply functions in <italic>L</italic><sup>2</sup>, which is already a linear space, so we don’t need to perform the linearisation step.</p>
      <p>fPCA is a method that finds an eigenbasis of functions (principle components), and orders them by the amount of variance that they can explain. Each function can then be expressed as a linear combination of the top principle component functions, plus an error term. Neglecting the error term has the effect of smoothing the resulting curves. Therefore, this step also makes the method more resilient to experimental noise. One of the reasons we treat x-axis and y-axis deformations separately is that fPCA only considers variance in terms of y-axis deformations, not x-axis deformations. Ji and Muller [<xref ref-type="bibr" rid="CR14">14</xref>] also uses fPCA, but without separating the x- and y-axis deformations first. Also, [<xref ref-type="bibr" rid="CR14">14</xref>] use it for smoothing, rather than for parameterising a probability density of functions.</p>
      <p>In summary, this strategy results in <italic>μ</italic> being defined as the space of fPCA coordinates, associated with both <italic>x</italic>- and <italic>y</italic>-deformations. <italic>P</italic>(<italic>μ</italic>) is then given by the multivariate normal distribution with a diagonalised covariance matrix.</p>
      <p>To estimate the integrals involved in the definitions of <italic>f</italic><sub>1</sub>, <italic>f</italic><sub>2</sub> or <italic>f</italic><sub>3</sub>, we take <italic>J</italic> samples from the probability distributions defined above. For example, we estimate <italic>f</italic>(<bold><italic>t</italic></bold>) as 
<disp-formula id="Equc"><alternatives><tex-math id="M23">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$f_{\text{est}}(\boldsymbol{t})= \frac{1}{J} \sum_{j=1}^{J} || w(t; \boldsymbol{\tau}, \mu_{j}) - w(t; \boldsymbol{t}, \mu_{j}) ||^{2}_{L^{2}(t, [\tau_{1},\tau_{N}])} $$ \end{document}</tex-math><mml:math id="M24"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>est</mml:mtext></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi mathvariant="bold-italic">t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>J</mml:mi></mml:mrow></mml:mfrac><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>J</mml:mi></mml:mrow></mml:munderover><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mi>w</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">τ</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>μ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>−</mml:mo><mml:mi>w</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>μ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msub><mml:mo>]</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math><graphic xlink:href="12859_2019_2717_Article_Equc.gif" position="anchor"/></alternatives></disp-formula> where <italic>μ</italic><sub><italic>j</italic></sub> is the set of parameters corresponding to the <italic>j</italic>-th sample drawn from <italic>P</italic>(<italic>μ</italic>). By default we set J to 1000. Note that since we are minimising <italic>f</italic>, the factor of <inline-formula id="IEq4"><alternatives><tex-math id="M25">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\frac {1}{J}$\end{document}</tex-math><mml:math id="M26"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>J</mml:mi></mml:mrow></mml:mfrac></mml:math><inline-graphic xlink:href="12859_2019_2717_Article_IEq4.gif"/></alternatives></inline-formula> can be dropped.</p>
      <p>The benefit of this approach is that it allows the user define very complicated functions for <italic>w</italic>(<italic>g</italic>,<italic>μ</italic>) and <italic>P</italic>(<italic>μ</italic>), and still be able to apply NITPicker. The downside of this approach is its random nature, which means that we don’t know the error between the actual value of the integral and this estimate, although we can be confident that <italic>f</italic><sub>(est)</sub> is close to <italic>f</italic> if <italic>J</italic> is sufficiently large.</p>
    </sec>
    <sec id="Sec11">
      <title>NITPicker algorithm</title>
      <p>A dynamic programming algorithm can be employed to find the set of <italic>m</italic> time points <bold><italic>t</italic></bold> that minimise <italic>f</italic>(<bold><italic>t</italic></bold>) (where <italic>f</italic>=<italic>f</italic><sub>1</sub>, <italic>f</italic><sub>2</sub> or <italic>f</italic><sub>3</sub>). In essence, the problem is identical to finding the path that minimises the distance in a directed acyclic graph that contains exactly <italic>m</italic> edges, which can be calculated with a modified Viterbi algorithm (Fig. <xref rid="Fig1" ref-type="fig">1</xref>d). Consider a graph with <italic>N</italic>+2 ordered nodes – a ‘start’ node, <italic>N</italic> nodes that represent each time point in the high resolution time course, and an ‘end’ node. For ease of notation, we index the start node with 0 and the end node with <italic>N</italic>+1. Each node is connected by edges that point to all the nodes that are ahead of it, and we set the value of the edge joining node <italic>i</italic> to node <italic>k</italic> to be: 
<disp-formula id="Equ7"><label>7</label><alternatives><tex-math id="M27">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ \textit{edge}(i, k)=\sum_{j=1}^{J}||[w(t; \boldsymbol{\tau}, \mu_{j}) - w(t; \{\tau_{i}, \tau_{k}\}, \mu_{j})]||^{2}_{L^{2}(t, [\tau_{i},\tau_{k}])}  $$ \end{document}</tex-math><mml:math id="M28"><mml:mspace width="-12.0pt"/><mml:mtext mathvariant="italic">edge</mml:mtext><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>J</mml:mi></mml:mrow></mml:munderover><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mo>[</mml:mo><mml:mi>w</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold-italic">τ</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>μ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>−</mml:mo><mml:mi>w</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>;</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>μ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>]</mml:mo><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>]</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:math><graphic xlink:href="12859_2019_2717_Article_Equ7.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>In other words, the value of the edge joining node <italic>i</italic> to node <italic>k</italic> is the <italic>L</italic><sup>2</sup>-error caused by selecting times <italic>τ</italic><sub><italic>i</italic></sub> and <italic>τ</italic><sub><italic>k</italic></sub> and none of the times in between.</p>
      <p>Now we need to find the shortest path with <italic>K</italic> edges that goes from the start node to the end node. An <italic>N</italic> by <italic>N</italic> by <italic>K</italic> table can be assembled where each element is: 
<disp-formula id="Equ8"><label>8</label><alternatives><tex-math id="M29">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ \Theta(i, j, k)=\min_{\ell = 0,1,\ldots,i} \Big(\Theta(\ell, j-1, k-1)+\textit{edge}(i, j) \Big)  $$ \end{document}</tex-math><mml:math id="M30"><mml:mi>Θ</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>min</mml:mo></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:mstyle mathsize="1.61em"><mml:mfenced close="" open="(" separators=""><mml:mrow/></mml:mfenced></mml:mstyle><mml:mi>Θ</mml:mi><mml:mo>(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">edge</mml:mtext><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo><mml:mstyle mathsize="1.61em"><mml:mfenced close="" open=")" separators=""><mml:mrow/></mml:mfenced></mml:mstyle></mml:math><graphic xlink:href="12859_2019_2717_Article_Equ8.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>and <italic>Θ</italic>(0,<italic>j</italic>,0)=0, <italic>Θ</italic>(<italic>i</italic>&gt;0,<italic>j</italic>,0)=<italic>∞</italic>. In other words, the value of <italic>Θ</italic>(<italic>i</italic>,<italic>j</italic>,<italic>k</italic>) is the minimum error when going from <italic>τ</italic><sub>0</sub> to <italic>τ</italic><sub><italic>i</italic></sub> and then immediately to <italic>τ</italic><sub><italic>j</italic></sub>, using exactly <italic>k</italic> edges.</p>
      <p>The value of <italic>f</italic><sub>est</sub>(<bold><italic>t</italic></bold>) is <italic>Θ</italic>(<italic>N</italic>+1,<italic>N</italic>+1,<italic>K</italic>). As we construct the table <italic>Θ</italic>, we also save another matrix <italic>Θ</italic><sub><italic>min</italic></sub>, with entries given by <italic>Θ</italic><sub><italic>min</italic></sub>(<italic>j</italic>,<italic>k</italic>)= min<italic>i</italic><italic>Θ</italic>(<italic>i</italic>,<italic>j</italic>,<italic>k</italic>). The value of <italic>Θ</italic><sub><italic>min</italic></sub>(<italic>j</italic>,<italic>k</italic>) is then the minimum <italic>L</italic><sup>2</sup>-error when going from <italic>τ</italic><sub>0</sub> to <italic>τ</italic><sub><italic>j</italic></sub> using <italic>k</italic> steps. We also construct a similar <italic>N</italic> by <italic>K</italic> matrix <italic>Θ</italic><sub><italic>trace</italic></sub>(<italic>j</italic>,<italic>k</italic>), with entries given by the value of <italic>i</italic> which minimises <italic>Θ</italic>(<italic>i</italic>,<italic>j</italic>,<italic>k</italic>). This can then be used to find the time points: we set <italic>t</italic><sub><italic>k</italic></sub>=<italic>Θ</italic><sub><italic>trace</italic></sub>(<italic>N</italic>+1,<italic>k</italic>), and then <italic>t</italic><sub><italic>k</italic>−1</sub>=<italic>Θ</italic><sub><italic>trace</italic></sub>(<italic>t</italic><sub><italic>k</italic></sub>,<italic>k</italic>−1).</p>
      <p>Note that the value of <italic>edge</italic>(<italic>i</italic>,<italic>j</italic>) actually depends on the previous <italic>R</italic> time points if a spline of degree <italic>R</italic> is used. However, the index of the previous <italic>R</italic> best nodes given edge (<italic>i</italic>,<italic>j</italic>) can be easily computed from the traceback matrix, although this makes NITPicker run much more slowly. Furthermore, using a spline of degree greater than one can produce edge-effects, especially in the beginning of the sequence as we use the deBoor algorithm to calculate the spline [<xref ref-type="bibr" rid="CR21">21</xref>]. This problem can be reduced by running the dynamic programming algorithm twice – once forward and once backwards.</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Additional files</title>
    <sec id="Sec12">
      <p>
        <supplementary-material content-type="local-data" id="MOESM1">
          <media xlink:href="12859_2019_2717_MOESM1_ESM.pdf">
            <label>Additional file 1</label>
            <caption>
              <p><bold>Figure S1</bold>: Examples of probability densities of functions with three example curves. NITPicker can be run with as few as three high resolution time courses. In order to see if it performs reasonably under these circumstances, we randomly chose triplets of skewed Gaussian curves with varied means (right), skews (middle) and standard deviations (left) and these are shown in red. Sampled curves (100) from the probability density of functions are shown in grey. These seem like reasonable predictions given the input data. (PDF 422 kb)</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
      <p>
        <supplementary-material content-type="local-data" id="MOESM2">
          <media xlink:href="12859_2019_2717_MOESM2_ESM.pdf">
            <label>Additional file 2</label>
            <caption>
              <p><bold>Figure S2</bold>: Why a biologist might want to use the time point selection criteria used by NITPicker. The smooth black and red curves show the original high resolution time course data. The horizontal dotted lines indicate the time points that might be selected under the indicated method. (A) NITPicker selects points that describe the shape of the curve, rather than points that can be used to reconstruct the curve. It might be possible to infer the shape of the curve with fewer points than suggested by NITPicker (top), but you would not have direct observations as to the shape of the curve (unlike NITPicker–bottom), so this relies on greater trust that the model will continue to hold under new experimental conditions. (B) Other methods find the best time points for the observed data, so they might overfit (top). In this case, NITPicker would observe that there is a lot of variability in the peak in the early time course and would pick more evenly spaced time points in this region for follow up experiments (bottom). (PDF 18 kb)</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
      <p>
        <supplementary-material content-type="local-data" id="MOESM3">
          <media xlink:href="12859_2019_2717_MOESM3_ESM.pdf">
            <label>Additional file 3</label>
            <caption>
              <p><bold>Figure S3</bold>: Flowchart of algorithm for generating a probability densities of functions. This is the exact same procedure used by [<xref ref-type="bibr" rid="CR13">13</xref>], but is included here for completeness. First, the curves are aligned in order to dissect and quantify the x-axis and y-axis shifts in the curves. Then, these x-axis and y-axis shifts are parameterised by their functional Principle Components, and this is used to generate curves that have similar x-axis and y-axis shifts to the original curves. (PDF 11 kb)</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
    </sec>
  </sec>
</body>
<back>
  <glossary>
    <title>Abbreviations</title>
    <def-list>
      <def-item>
        <term>CRAN</term>
        <def>
          <p>Comprehensive R archive network</p>
        </def>
      </def-item>
      <def-item>
        <term>fPCA</term>
        <def>
          <p>Functional principle component analysis</p>
        </def>
      </def-item>
      <def-item>
        <term>NITPicker</term>
        <def>
          <p>Next iteration time-point picker</p>
        </def>
      </def-item>
      <def-item>
        <term>SRSF</term>
        <def>
          <p>Square root slope function</p>
        </def>
      </def-item>
      <def-item>
        <term>TPS</term>
        <def>
          <p>Time point selection</p>
        </def>
      </def-item>
    </def-list>
  </glossary>
  <ack>
    <title>Acknowledgements</title>
    <p>We would like to thank my colleagues at the Sainsbury Laboratory in University of Cambridge and the Cambridge plant science department, and Dr. Philip Wigge for helping encourage participation. We would also like to thank Shahin Travakoli for his advice on the manuscript.</p>
    <sec id="d29e3513">
      <title>Funding</title>
      <p>This research was funded by a Trinity College Junior Research Fellowship, University of Cambridge; Alan Turing Institute Research Fellowship under EPSRC Research grant (TU/A/000017); EPSRC Innovation Fellowship (EP/S001360/1). The funding bodies did not play any roles in the design of the study, the collection, analysis, and interpretation of data or in writing the manuscript.</p>
    </sec>
    <sec id="d29e3518" sec-type="data-availability">
      <title>Availability of data and materials</title>
      <p>All data come from supplemental tables of the cited manuscripts. The gene expression data is available in the supplementary material of [<xref ref-type="bibr" rid="CR6">6</xref>, <xref ref-type="bibr" rid="CR12">12</xref>, <xref ref-type="bibr" rid="CR15">15</xref>] and the weather and growth datasets can be found in the <italic>fda</italic> package in R.</p>
    </sec>
    <sec id="d29e3535">
      <title>Ethics and consent to participate</title>
      <p>Not applicable.</p>
    </sec>
  </ack>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>DE proposed the project, analysed the data, developed and programmed the method and wrote the manuscript. JK helped develop the method and wrote the manuscript. All authors have read and approved the manuscript.</p>
  </notes>
  <notes notes-type="COI-statement">
    <sec>
      <title>Consent for publication</title>
      <p>Not applicable.</p>
    </sec>
    <sec>
      <title>Competing interests</title>
      <p>The authors declare that they have no competing interests.</p>
    </sec>
    <sec>
      <title>Publisher’s Note</title>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </sec>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lundstedt</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Seifert</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Abramo</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Thelin</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Nyström</surname>
            <given-names>Å</given-names>
          </name>
          <name>
            <surname>Pettersen</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Bergman</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Experimental design and optimization</article-title>
        <source>Chemom Intell Lab Syst.</source>
        <year>1998</year>
        <volume>42</volume>
        <issue>1-2</issue>
        <fpage>3</fpage>
        <lpage>40</lpage>
        <pub-id pub-id-type="doi">10.1016/S0169-7439(98)00065-3</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Nicolas</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Phillips</surname>
            <given-names>NE</given-names>
          </name>
          <name>
            <surname>Naef</surname>
            <given-names>F</given-names>
          </name>
        </person-group>
        <article-title>What shapes eukaryotic transcriptional bursting?</article-title>
        <source>Mol BioSyst</source>
        <year>2017</year>
        <volume>13</volume>
        <issue>7</issue>
        <fpage>1280</fpage>
        <lpage>90</lpage>
        <pub-id pub-id-type="doi">10.1039/C7MB00154A</pub-id>
        <pub-id pub-id-type="pmid">28573295</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3</label>
      <mixed-citation publication-type="other">Ezer D, Moignard V, Göttgens B, Adryan B. Determining Physical Mechanisms of Gene Expression Regulation from Single Cell Gene Expression Data. PLoS Comput Biol. 2016;12(8):e1005072.</mixed-citation>
    </ref>
    <ref id="CR4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rugnone</surname>
            <given-names>ML</given-names>
          </name>
          <name>
            <surname>Faigon Soverna</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Sanchez</surname>
            <given-names>SE</given-names>
          </name>
          <name>
            <surname>Schlaen</surname>
            <given-names>RG</given-names>
          </name>
          <name>
            <surname>Hernando</surname>
            <given-names>CE</given-names>
          </name>
          <name>
            <surname>Seymour</surname>
            <given-names>DK</given-names>
          </name>
          <name>
            <surname>Mancini</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Chernomoretz</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Weigel</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Mas</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Yanovsky</surname>
            <given-names>MJ</given-names>
          </name>
        </person-group>
        <article-title>LNK genes integrate light and clock signaling networks at the core of the Arabidopsis oscillator</article-title>
        <source>Proc Natl Acad Sci</source>
        <year>2013</year>
        <volume>110</volume>
        <issue>29</issue>
        <fpage>12120</fpage>
        <lpage>5</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.1302170110</pub-id>
        <pub-id pub-id-type="pmid">23818596</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Graveley</surname>
            <given-names>BR</given-names>
          </name>
          <name>
            <surname>Brooks</surname>
            <given-names>AN</given-names>
          </name>
          <name>
            <surname>Carlson</surname>
            <given-names>JW</given-names>
          </name>
          <name>
            <surname>Duff</surname>
            <given-names>MO</given-names>
          </name>
          <name>
            <surname>Landolin</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Yang</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Artieri</surname>
            <given-names>CG</given-names>
          </name>
          <name>
            <surname>Van Baren</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Boley</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Booth</surname>
            <given-names>BW</given-names>
          </name>
          <name>
            <surname>Brown</surname>
            <given-names>JB</given-names>
          </name>
          <name>
            <surname>Cherbas</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Davis</surname>
            <given-names>CA</given-names>
          </name>
          <name>
            <surname>Dobin</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Lin</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Malone</surname>
            <given-names>JH</given-names>
          </name>
          <name>
            <surname>Mattiuzzo</surname>
            <given-names>NR</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Sturgill</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Tuch</surname>
            <given-names>BB</given-names>
          </name>
          <name>
            <surname>Zaleski</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Blanchette</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Dudoit</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Eads</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Green</surname>
            <given-names>RE</given-names>
          </name>
          <name>
            <surname>Hammonds</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Jiang</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Kapranov</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Langton</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Perrimon</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Sandler</surname>
            <given-names>JE</given-names>
          </name>
          <name>
            <surname>Wan</surname>
            <given-names>KH</given-names>
          </name>
          <name>
            <surname>Willingham</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Zou</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Andrews</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Bickel</surname>
            <given-names>PJ</given-names>
          </name>
          <name>
            <surname>Brenner</surname>
            <given-names>SE</given-names>
          </name>
          <name>
            <surname>Brent</surname>
            <given-names>MR</given-names>
          </name>
          <name>
            <surname>Cherbas</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Gingeras</surname>
            <given-names>TR</given-names>
          </name>
          <name>
            <surname>Hoskins</surname>
            <given-names>RA</given-names>
          </name>
          <name>
            <surname>Kaufman</surname>
            <given-names>TC</given-names>
          </name>
          <name>
            <surname>Oliver</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Celniker</surname>
            <given-names>SE</given-names>
          </name>
        </person-group>
        <article-title>The developmental transcriptome of Drosophila melanogaster</article-title>
        <source>Nature</source>
        <year>2011</year>
        <volume>471</volume>
        <issue>7339</issue>
        <fpage>473</fpage>
        <lpage>9</lpage>
        <pub-id pub-id-type="doi">10.1038/nature09715</pub-id>
        <pub-id pub-id-type="pmid">21179090</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Boeck</surname>
            <given-names>ME</given-names>
          </name>
          <name>
            <surname>Huynh</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Gevirtzman</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Thompson</surname>
            <given-names>OA</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Kasper</surname>
            <given-names>DM</given-names>
          </name>
          <name>
            <surname>Reinke</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Hillier</surname>
            <given-names>LW</given-names>
          </name>
          <name>
            <surname>Waterston</surname>
            <given-names>RH</given-names>
          </name>
        </person-group>
        <article-title>The time-resolved transcriptome of C. Elegans</article-title>
        <source>Genome Res</source>
        <year>2016</year>
        <volume>26</volume>
        <issue>10</issue>
        <fpage>1441</fpage>
        <lpage>50</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.202663.115</pub-id>
        <pub-id pub-id-type="pmid">27531719</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ardini-Poleske</surname>
            <given-names>ME</given-names>
          </name>
          <name>
            <surname>Clark</surname>
            <given-names>RF</given-names>
          </name>
          <name>
            <surname>Ansong</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Carson</surname>
            <given-names>JP</given-names>
          </name>
          <name>
            <surname>Corley</surname>
            <given-names>RA</given-names>
          </name>
          <name>
            <surname>Deutsch</surname>
            <given-names>GH</given-names>
          </name>
          <name>
            <surname>Hagood</surname>
            <given-names>JS</given-names>
          </name>
          <name>
            <surname>Kaminski</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Mariani</surname>
            <given-names>TJ</given-names>
          </name>
          <name>
            <surname>Potter</surname>
            <given-names>SS</given-names>
          </name>
          <name>
            <surname>Pryhuber</surname>
            <given-names>GS</given-names>
          </name>
          <name>
            <surname>Warburton</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Whitsett</surname>
            <given-names>JA</given-names>
          </name>
          <name>
            <surname>Palmer</surname>
            <given-names>SM</given-names>
          </name>
          <name>
            <surname>Ambalavanan</surname>
            <given-names>N</given-names>
          </name>
          <collab>the LungMAP Consortium</collab>
        </person-group>
        <article-title>LungMAP: The Molecular Atlas of Lung Development Program</article-title>
        <source>Am J Physiol Lung Cell Mol Physiol</source>
        <year>2017</year>
        <volume>313</volume>
        <issue>5</issue>
        <fpage>L733</fpage>
        <lpage>L740</lpage>
        <pub-id pub-id-type="doi">10.1152/ajplung.00139.2017</pub-id>
        <pub-id pub-id-type="pmid">28798251</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8</label>
      <mixed-citation publication-type="other">Ramsay J, Silverman BW, Vol. 9. Functional Data Analysis; 2005, p. 428.</mixed-citation>
    </ref>
    <ref id="CR9">
      <label>9</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>J-L</given-names>
          </name>
          <name>
            <surname>Chiou</surname>
            <given-names>J-M</given-names>
          </name>
          <name>
            <surname>Mueller</surname>
            <given-names>H-G</given-names>
          </name>
        </person-group>
        <article-title>Review of Functional Data Analysis</article-title>
        <source>Ann Rev Stat Appl</source>
        <year>2016</year>
        <volume>3</volume>
        <fpage>257</fpage>
        <lpage>95</lpage>
        <pub-id pub-id-type="doi">10.1146/annurev-statistics-041715-033624</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rosa</surname>
            <given-names>BA</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Major</surname>
            <given-names>IT</given-names>
          </name>
          <name>
            <surname>Qin</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Optimal timepoint sampling in high-throughput gene expression experiments</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <issue>21</issue>
        <fpage>2773</fpage>
        <lpage>81</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts511</pub-id>
        <pub-id pub-id-type="pmid">22923305</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11</label>
      <mixed-citation publication-type="other">Singh R, Palmer N, Gifford D, Berger B, Bar-Joseph Z. ICML ’05 Proceedings of the 22nd international conference on Machine learning. Bonn; 2005. p. 832–39 10.1145/1102351.1102456.</mixed-citation>
    </ref>
    <ref id="CR12">
      <label>12</label>
      <mixed-citation publication-type="other">Kleyman M, Sefer E, Nicola T, Espinoza C, Chhabra D, Hagood JS, Kaminski N, Ambalavanan N, Bar-Joseph Z. Selecting the most appropriate time points to profile in high-throughput studies. eLife. 2017;6:e18541.</mixed-citation>
    </ref>
    <ref id="CR13">
      <label>13</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Tucker</surname>
            <given-names>JD</given-names>
          </name>
          <name>
            <surname>Wu</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Srivastava</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Generative models for functional data using phase and amplitude separation</article-title>
        <source>Comput Stat Data Anal</source>
        <year>2013</year>
        <volume>61</volume>
        <fpage>50</fpage>
        <lpage>66</lpage>
        <pub-id pub-id-type="doi">10.1016/j.csda.2012.12.001</pub-id>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ji</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Muller</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Optimal designs for longitudinal and functional data</article-title>
        <source>J R Stat Soc Ser B Stat Methodol</source>
        <year>2017</year>
        <volume>79</volume>
        <issue>3</issue>
        <fpage>859</fpage>
        <lpage>76</lpage>
        <pub-id pub-id-type="doi">10.1111/rssb.12192</pub-id>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15</label>
      <mixed-citation publication-type="other">Ezer D, Jung JH, Lan H, Biswas S, Gregoire L, Box MS, Charoensawan V, Cortijo S, Lai X, Stöckle D, Zubieta C, Jaeger KE, Wigge PA. The evening complex coordinates environmental and endogenous signals in Arabidopsis. Nat Plants. 2017;3:17087.</mixed-citation>
    </ref>
    <ref id="CR16">
      <label>16</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <collab>Tuddenham RD</collab>
          <collab>Snyder MM</collab>
        </person-group>
        <article-title>Physical growth of California boys and girls from birth to eighteen years</article-title>
        <source>Publ Child Dev Univ Calif</source>
        <year>1954</year>
        <volume>1</volume>
        <issue>2</issue>
        <fpage>183</fpage>
        <lpage>364</lpage>
        <?supplied-pmid 13217130?>
        <pub-id pub-id-type="pmid">13217130</pub-id>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hunt</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Causton</surname>
            <given-names>DR</given-names>
          </name>
          <name>
            <surname>Shipley</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Askew</surname>
            <given-names>AP</given-names>
          </name>
        </person-group>
        <article-title>A modern tool for classical plant growth analysis</article-title>
        <source>Ann Bot</source>
        <year>2002</year>
        <volume>90</volume>
        <issue>4</issue>
        <fpage>485</fpage>
        <lpage>8</lpage>
        <pub-id pub-id-type="doi">10.1093/aob/mcf214</pub-id>
        <pub-id pub-id-type="pmid">12324272</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cuesta-Albertos</surname>
            <given-names>JA</given-names>
          </name>
          <name>
            <surname>Febrero-Bande</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Oviedo de la Fuente</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>The ddg-classifier in the functional setting</article-title>
        <source>Test</source>
        <year>2016</year>
        <volume>26</volume>
        <fpage>119</fpage>
        <lpage>42</lpage>
        <pub-id pub-id-type="doi">10.1007/s11749-016-0502-6</pub-id>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Cuesta-Albertos</surname>
            <given-names>JA</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>RY</given-names>
          </name>
        </person-group>
        <article-title>DD-classifier: Nonparametric classification procedure based on DD-plot</article-title>
        <source>J Am Stat Assoc</source>
        <year>2012</year>
        <volume>107</volume>
        <issue>498</issue>
        <fpage>737</fpage>
        <lpage>53</lpage>
        <pub-id pub-id-type="doi">10.1080/01621459.2012.688462</pub-id>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Leek</surname>
            <given-names>JT</given-names>
          </name>
          <name>
            <surname>Monsen</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Dabney</surname>
            <given-names>AR</given-names>
          </name>
          <name>
            <surname>Storey</surname>
            <given-names>JD</given-names>
          </name>
        </person-group>
        <article-title>Edge: extraction and analysis of differential gene expression</article-title>
        <source>Bioinformatics</source>
        <year>2006</year>
        <volume>22</volume>
        <issue>4</issue>
        <fpage>507</fpage>
        <lpage>8</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btk005</pub-id>
        <pub-id pub-id-type="pmid">16357033</pub-id>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>R</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>de Boor</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>A Practical Guide to Splines,</article-title>
        <source>Math Comput</source>
        <year>1980</year>
        <volume>34</volume>
        <issue>149</issue>
        <fpage>325</fpage>
        <pub-id pub-id-type="doi">10.2307/2006241</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
