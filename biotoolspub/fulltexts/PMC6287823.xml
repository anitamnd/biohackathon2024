<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d3 20150301//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 39.96?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">PLoS One</journal-id>
    <journal-id journal-id-type="iso-abbrev">PLoS ONE</journal-id>
    <journal-id journal-id-type="publisher-id">plos</journal-id>
    <journal-id journal-id-type="pmc">plosone</journal-id>
    <journal-title-group>
      <journal-title>PLoS ONE</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1932-6203</issn>
    <publisher>
      <publisher-name>Public Library of Science</publisher-name>
      <publisher-loc>San Francisco, CA USA</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6287823</article-id>
    <article-id pub-id-type="publisher-id">PONE-D-18-19477</article-id>
    <article-id pub-id-type="doi">10.1371/journal.pone.0208073</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Computer and Information Sciences</subject>
        <subj-group>
          <subject>Computing Systems</subject>
          <subj-group>
            <subject>Quantum Computing</subject>
            <subj-group>
              <subject>Qubits</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Computer and Information Sciences</subject>
        <subj-group>
          <subject>Computing Systems</subject>
          <subj-group>
            <subject>Quantum Computing</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Physical Sciences</subject>
        <subj-group>
          <subject>Mathematics</subject>
          <subj-group>
            <subject>Discrete Mathematics</subject>
            <subj-group>
              <subject>Combinatorics</subject>
              <subj-group>
                <subject>Permutation</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Engineering and Technology</subject>
        <subj-group>
          <subject>Electronics Engineering</subject>
          <subj-group>
            <subject>Logic Circuits</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Research Facilities</subject>
          <subj-group>
            <subject>Information Centers</subject>
            <subj-group>
              <subject>Libraries</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Physical Sciences</subject>
        <subj-group>
          <subject>Physics</subject>
          <subj-group>
            <subject>Thermodynamics</subject>
            <subj-group>
              <subject>Entropy</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Mathematical and Statistical Techniques</subject>
          <subj-group>
            <subject>Fourier Analysis</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Computer and Information Sciences</subject>
        <subj-group>
          <subject>Operating Systems</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Quantum++: A modern C++ quantum computing library</article-title>
      <alt-title alt-title-type="running-head">Quantum++</alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-4172-9186</contrib-id>
        <name>
          <surname>Gheorghiu</surname>
          <given-names>Vlad</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Software</role>
        <xref ref-type="aff" rid="aff001">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="aff002">
          <sup>2</sup>
        </xref>
        <xref ref-type="corresp" rid="cor001">*</xref>
      </contrib>
    </contrib-group>
    <aff id="aff001">
      <label>1</label>
      <addr-line>softwareQ Inc., Kitchener ON, Canada</addr-line>
    </aff>
    <aff id="aff002">
      <label>2</label>
      <addr-line>Institute for Quantum Computing, University of Waterloo, Waterloo ON, Canada</addr-line>
    </aff>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Lamata</surname>
          <given-names>Lucas</given-names>
        </name>
        <role>Editor</role>
        <xref ref-type="aff" rid="edit1"/>
      </contrib>
    </contrib-group>
    <aff id="edit1">
      <addr-line>University of the Basque Country, SPAIN</addr-line>
    </aff>
    <author-notes>
      <fn fn-type="COI-statement" id="coi001">
        <p><bold>Competing Interests: </bold>Dr. Vlad Gheorghiu is the CEO, President and Co-Founder of softwareQ Inc. There are no competing interests with softwareQ Inc. This does not alter the author’s adherence to PLOS ONE policies on sharing data and materials.</p>
      </fn>
      <corresp id="cor001">* E-mail: <email>vlad@softwareq.ca</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <year>2018</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>10</day>
      <month>12</month>
      <year>2018</year>
    </pub-date>
    <volume>13</volume>
    <issue>12</issue>
    <elocation-id>e0208073</elocation-id>
    <history>
      <date date-type="received">
        <day>30</day>
        <month>6</month>
        <year>2018</year>
      </date>
      <date date-type="accepted">
        <day>12</day>
        <month>11</month>
        <year>2018</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2018 Vlad Gheorghiu</copyright-statement>
      <copyright-year>2018</copyright-year>
      <copyright-holder>Vlad Gheorghiu</copyright-holder>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
      </license>
    </permissions>
    <self-uri content-type="pdf" xlink:href="pone.0208073.pdf"/>
    <abstract>
      <p>Quantum++ is a modern general-purpose multi-threaded quantum computing library written in C++11 and composed solely of header files. The library is not restricted to qubit systems or specific quantum information processing tasks, being capable of simulating arbitrary quantum processes. The main design factors taken in consideration were the ease of use, portability, and performance. The library’s simulation capabilities are only restricted by the amount of available physical memory. On a typical machine (Intel i5 8Gb RAM) Quantum++ can successfully simulate the evolution of 25 qubits in a pure state or of 12 qubits in a mixed state reasonably fast. The library also includes support for classical reversible logic, being able to simulate classical reversible operations on billions of bits. This latter feature may be useful in testing quantum circuits composed solely of Toffoli gates, such as certain arithmetic circuits.</p>
    </abstract>
    <funding-group>
      <funding-statement>I acknowledge financial support from Industry Canada and from the Natural Sciences and Engineering Research Council of Canada (NSERC).</funding-statement>
    </funding-group>
    <counts>
      <fig-count count="2"/>
      <table-count count="3"/>
      <page-count count="27"/>
    </counts>
    <custom-meta-group>
      <custom-meta id="data-availability">
        <meta-name>Data Availability</meta-name>
        <meta-value>Data are available from GitHub: <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">https://github.com/vsoftco/qpp</ext-link>.</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
  <notes>
    <title>Data Availability</title>
    <p>Data are available from GitHub: <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">https://github.com/vsoftco/qpp</ext-link>.</p>
  </notes>
</front>
<body>
  <sec id="sec001">
    <title>1 Introduction</title>
    <p>Quantum computing is a disruptive technology that promises great benefits for a plethora of applications, ranging from medicine and chemistry to machine learning and simulation of physical systems. However, today’s most advanced quantum computers are not yet large enough for performing universal quantum computation, hence their applicability is still limited. Being able to simulate small sized quantum computers is therefore of paramount importance, as it allows the scientist or engineer to understand better the results she or he would expect from a quantum machine of similar size, as well as providing a better understanding of quantum computing itself. Below we describe a quantum computing library that can be used in research or exploratory work in quantum information and computation.</p>
    <p><ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link>, available online at <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">https://github.com/vsoftco/qpp</ext-link>, is a C++11 general purpose quantum computing library, composed solely of header files. It uses the <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> linear algebra library and, if available, the <ext-link ext-link-type="uri" xlink:href="http://openmp.org/">OpenMP</ext-link> multi-processing library. For additional <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> documentation see <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/dox/">http://eigen.tuxfamily.org/dox/</ext-link>. For a simple <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> quick ASCII reference see <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/dox/AsciiQuickReference.txt">http://eigen.tuxfamily.org/dox/AsciiQuickReference.txt</ext-link>.</p>
    <p>The simulator defines a large collection of (template) quantum computing related functions and a few useful classes. The main data types are complex vectors and complex matrices, which we will describe below. Most functions operate on such vectors/matrices passed by value and <underline>always</underline> return the result by value, without ever mutating their arguments. The design is inspired from functional programming, where functions do not mutate their arguments and do not have side effects. Those design choices make the library ideal to use or integrate in multi-processing frameworks. Collection of objects are implemented via the standard library container <monospace>std::vector&lt;&gt;</monospace>, instantiated accordingly.</p>
    <p>We decided to avoid using a complicated class hierarchy and focus on a functional style-like approach, as we believe the latter is more suitable for a relatively small API and allows the user to focus on the quantum algorithm design rather than on object-oriented design. In addition, there is absolutely no need for explicit memory allocations or usage of (raw) pointers. All allocations, initializations and release of resources are performed by the library, hence the user is not at risk of forgetting to de-allocate memory, use un-initialized objects, or overflowing buffers, which are the most common, dangerous and hard to diagnose mistakes in the world of C and C++ programming.</p>
    <p>Although there are many available quantum computing libraries/simulators written in various programming languages, see [<xref rid="pone.0208073.ref001" ref-type="bibr">1</xref>] for a comprehensive list, what makes <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> different is the ease of use, portability and high performance. The library is not restricted to specific quantum information tasks, but it is intended to be multi-purpose and capable of simulating arbitrary quantum processes. We have chosen the C++ programming language (standard C++11) in implementing the library as it is by now a mature standard, fully (or almost fully) implemented by the most common compilers, and highly portable.</p>
    <p>Other unique features of <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> include the ability of simulating classical reversible networks up to billions of bits (this feature may be useful in testing quantum circuits composed solely of Toffoli gates, such as certain arithmetic circuits in e.g. [<xref rid="pone.0208073.ref002" ref-type="bibr">2</xref>]), strong multi-threading abilities, as well as built-in support for higher dimensional systems (qudits) that allows treating qubits and qudits on the same footing.</p>
    <p>In the reminder of this manuscript we describe the main features of the library, “in a nutshell” fashion, via a series of simple examples. We assume that the reader is familiar with the basic concepts of quantum mechanics/quantum information. For a comprehensive introduction to the latter see e.g. [<xref rid="pone.0208073.ref003" ref-type="bibr">3</xref>]. This document is not intended to be a comprehensive documentation, but only a brief introduction to the library and its main features. For a detailed reference see the manual available as a <monospace>.pdf</monospace> file in <monospace>./doc/refman.pdf</monospace>. For detailed installation instructions as well as for additional information regarding the library see the Wiki page at <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp/wiki">https://github.com/vsoftco/qpp/wiki</ext-link>. If you are interesting in contributing, or for any comments or suggestions, please contact me.</p>
    <p><ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> is free software: you can redistribute it and/or modify it under the terms of the MIT License <ext-link ext-link-type="uri" xlink:href="https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</ext-link>.</p>
  </sec>
  <sec id="sec002">
    <title>2 Installation</title>
    <p>To get started with <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link>, first install the <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> library from <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org">http://eigen.tuxfamily.org</ext-link> into your home directory, as <monospace>$HOME/eigen</monospace>. Here we implicitly assume that you use a UNIX-like system, although everything should translate into Windows as well, with slight modifications. You can change the name of the directory, but in the current document we will use <monospace>$HOME/eigen</monospace> as the location of the <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> library. Next, download the <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> library from <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp/">https://github.com/vsoftco/qpp/</ext-link> and unzip it into the home directory as <monospace>$HOME/qpp</monospace>. Finally, make sure that your compiler supports C++11 and preferably <ext-link ext-link-type="uri" xlink:href="http://openmp.org/">OpenMP</ext-link>. For a compiler we recommend <ext-link ext-link-type="uri" xlink:href="https://gcc.gnu.org/">g++</ext-link> version 5.0 or later or <ext-link ext-link-type="uri" xlink:href="http://clang.llvm.org">clang</ext-link> version 3.7 or later (previous versions of <ext-link ext-link-type="uri" xlink:href="http://clang.llvm.org">clang</ext-link> do not support <ext-link ext-link-type="uri" xlink:href="http://openmp.org/">OpenMP</ext-link>).</p>
    <p>We next build a simple minimal example to test that the installation was successful. Create a directory called <monospace>$HOME/testing</monospace>, and inside it create the file <monospace>minimal.cpp</monospace>, with the content listed in <xref ref-type="boxed-text" rid="pone.0208073.box001">Listing 1</xref>. A verbatim copy of the above program is also available at <monospace>$HOME/qpp/examples/minimal.cpp</monospace>.</p>
    <boxed-text id="pone.0208073.box001" position="float" orientation="portrait">
      <sec id="sec003">
        <title>Listing 1. Minimal example</title>
        <p>
          <monospace>1 // Minimal example//</monospace>
        </p>
        <p>
          <monospace>2 // Source: ./examples/minimal.cpp</monospace>
        </p>
        <p>
          <monospace>3 #include &lt;iostream&gt;</monospace>
        </p>
        <p>
          <monospace>4</monospace>
        </p>
        <p>
          <monospace>5 #include “qpp.h”</monospace>
        </p>
        <p>
          <monospace>6</monospace>
        </p>
        <p>
          <monospace>7 int main() {</monospace>
        </p>
        <p>
          <monospace>8  using namespace qpp;</monospace>
        </p>
        <p>
          <monospace>9  std::cout &lt;&lt; “Hello Quantum++!\nThis is the |0&gt; state:\n”;</monospace>
        </p>
        <p>
          <monospace>10  std::cout &lt;&lt; disp(st.z0) &lt;&lt; ‘\n’;</monospace>
        </p>
        <p>
          <monospace>11 }</monospace>
        </p>
      </sec>
    </boxed-text>
    <p>Next, compile the file using a C++11 compliant compiler. In the following, we assume that you use <ext-link ext-link-type="uri" xlink:href="https://gcc.gnu.org/">g++</ext-link>, but the building instructions are similar for other compilers. From the directory <monospace>$HOME/testing</monospace> type</p>
    <p>
      <monospace>g++ -std = c++11 -O3 -Wall -Wextra -pedantic -isystem $HOME/eigen\</monospace>
    </p>
    <p>
      <monospace>-I $HOME/qpp/include minimal.cpp -o minimal</monospace>
    </p>
    <p>Your compile command may differ from the above, depending on the C++ compiler and operating system. If everything went fine, the above command should build an executable <monospace>minimal</monospace> in <monospace>$HOME/testing</monospace>, which can be run by typing <monospace>./minimal</monospace>. The output should be similar to the following:</p>
    <boxed-text id="pone.0208073.box002" position="float" orientation="portrait">
      <sec id="sec004">
        <title><xref ref-type="boxed-text" rid="pone.0208073.box001">Listing 1</xref> output</title>
        <p>
          <monospace>Hello Quantum++!</monospace>
        </p>
        <p>
          <monospace>This is the |0&gt; state:</monospace>
        </p>
        <p>
          <monospace>1</monospace>
        </p>
        <p>
          <monospace>0</monospace>
        </p>
      </sec>
    </boxed-text>
    <p>In line 5 of <xref ref-type="boxed-text" rid="pone.0208073.box001">Listing 1</xref> we include the main header file of the library <monospace>qpp.h</monospace> This header file includes all other necessary internal <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> header files. In line 10 we display the state |0〉 represented by the singleton <monospace>st.z0</monospace> in a nice format using the display manipulator <monospace>disp()</monospace>.</p>
  </sec>
  <sec id="sec005">
    <title>3 Data types, constants and global objects</title>
    <p>All header files of <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> are located inside the <monospace>./include</monospace> directory. All functions, classes and global objects defined by the library belong to the <monospace>namespace qpp</monospace>. To avoid additional typing, we will omit the prefix <monospace>qpp::</monospace> in the rest of this document. We recommend the using of <monospace>using namespace qpp;</monospace> in your main <monospace>.cpp</monospace> file.</p>
    <sec id="sec006">
      <title>3.1 Data types</title>
      <p>The most important data types are defined in the header file <monospace>types.h</monospace>. We list them in <xref rid="pone.0208073.t001" ref-type="table">Table 1</xref>.</p>
      <table-wrap id="pone.0208073.t001" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0208073.t001</object-id>
        <label>Table 1</label>
        <caption>
          <title>User-defined data types.</title>
        </caption>
        <alternatives>
          <graphic id="pone.0208073.t001g" xlink:href="pone.0208073.t001"/>
          <table frame="box" rules="all" border="0">
            <colgroup span="1">
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
            </colgroup>
            <tbody>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>idx</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">Index (non-negative integer), alias for <monospace>std::size_t</monospace></td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>bigint</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">Big integer, alias for <monospace>long long int</monospace></td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>cplx</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">Complex number, alias for <monospace>std::complex&lt;double&gt;</monospace></td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>cmat</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">Complex dynamic matrix, alias for <monospace>Eigen::MatrixXcd</monospace></td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>dmat</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">Double dynamic matrix, alias for <monospace>Eigen::MatrixXd</monospace></td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>ket</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">Complex dynamic column vector, alias for <monospace>Eigen::VectorXcd</monospace></td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>bra</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">Complex dynamic row vector, alias for <monospace>Eigen::RowVectorXcd</monospace></td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>dyn_mat&lt;Scalar&gt;</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">Dynamic matrix template alias over the field <monospace>Scalar</monospace>, alias for <monospace>Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic&gt;</monospace></td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>dyn_col_vect&lt;Scalar&gt;</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">Dynamic column vector template alias over the field <monospace>Scalar</monospace>, alias for <monospace>Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1&gt;</monospace></td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>dyn_row_vect&lt;Scalar&gt;</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">Dynamic row vector template alias over the field <monospace>Scalar</monospace>, alias for <monospace>Eigen::Matrix&lt;Scalar, 1, Eigen::Dynamic&gt;</monospace></td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
    </sec>
    <sec id="sec007">
      <title>3.2 Constants</title>
      <p>The important constants are defined in the header file <monospace>constants.h</monospace> and are listed in <xref rid="pone.0208073.t002" ref-type="table">Table 2</xref>.</p>
      <table-wrap id="pone.0208073.t002" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0208073.t002</object-id>
        <label>Table 2</label>
        <caption>
          <title>User-defined constants.</title>
        </caption>
        <alternatives>
          <graphic id="pone.0208073.t002g" xlink:href="pone.0208073.t002"/>
          <table frame="box" rules="all" border="0">
            <colgroup span="1">
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
            </colgroup>
            <tbody>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>constexpr idx maxn = 64;</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">Maximum number of allowed qu(d)its (subsystems)</td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>constexpr double pi = 3.1415…;</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">
                  <italic>π</italic>
                </td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>constexpr double ee = 2.7182…;</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1"><italic>e</italic>, base of natural logarithms</td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>constexpr double eps = 1e-12;</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">Used in comparing floating point values to zero</td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>constexpr double chop = 1e-10;</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">Used in display manipulators to set numbers to zero</td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>constexpr double infty = …;</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">Used to denote infinity in double precision</td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>constexpr cplx operator“”_i</monospace>
                  <break/>
                  <monospace>(unsigned long long int x)</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">User-defined literal for the imaginary number <inline-formula id="pone.0208073.e001"><alternatives><graphic id="pone.0208073.e001g" xlink:href="pone.0208073.e001"/><mml:math id="M1"><mml:mrow><mml:mi>i</mml:mi><mml:mo>≔</mml:mo><mml:msqrt><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msqrt></mml:mrow></mml:math></alternatives></inline-formula></td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>constexpr cplx operator“”_i</monospace>
                  <break/>
                  <monospace>(unsigned long double int x)</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">User-defined literal for the imaginary number <inline-formula id="pone.0208073.e002"><alternatives><graphic id="pone.0208073.e002g" xlink:href="pone.0208073.e002"/><mml:math id="M2"><mml:mrow><mml:mi>i</mml:mi><mml:mo>≔</mml:mo><mml:msqrt><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msqrt></mml:mrow></mml:math></alternatives></inline-formula></td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>cplx omega(idx D)</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1"><italic>D</italic>-th root of unity <italic>e</italic><sup>2<italic>πi</italic>/<italic>D</italic></sup></td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
    </sec>
    <sec id="sec008">
      <title>3.3 Singleton classes and their global instances</title>
      <p>Some useful classes are defined as singletons and their instances are globally available, being initialized at runtime in the header file <monospace>qpp.h</monospace>, before <monospace>main()</monospace>. They are listed in <xref rid="pone.0208073.t003" ref-type="table">Table 3</xref>.</p>
      <table-wrap id="pone.0208073.t003" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0208073.t003</object-id>
        <label>Table 3</label>
        <caption>
          <title>Global singleton classes and instances.</title>
        </caption>
        <alternatives>
          <graphic id="pone.0208073.t003g" xlink:href="pone.0208073.t003"/>
          <table frame="box" rules="all" border="0">
            <colgroup span="1">
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
            </colgroup>
            <tbody>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>const Init&amp; init = Init::get_instance();</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">Library initialization</td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>const Codes&amp; codes = Codes::get_instance();</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">Quantum error correcting codes</td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>const Gates&amp; gt = Gates::get_instance();</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">Quantum gates</td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>const States&amp; st = States::get_instance();</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">Quantum states</td>
              </tr>
              <tr>
                <td align="left" style="border-right:thick" rowspan="1" colspan="1">
                  <monospace>RandomDevices&amp; rdevs =</monospace>
                  <break/>
                  <monospace>RandomDevices::get_thread_local_instance();</monospace>
                </td>
                <td align="left" rowspan="1" colspan="1">Random devices/generators/engines</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
    </sec>
  </sec>
  <sec id="sec009">
    <title>4 Simple examples</title>
    <p>All of the examples of this section are copied verbatim from the directory <monospace>./examples</monospace> and are fully compilable. For convenience, the location of the source file is displayed in the first line of each example as a C++ comment. The examples are simple and demonstrate the main features of <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link>. They cover only a small part of library functions, but enough to get the interested user started. For an extensive reference of all library functions, including various overloads, the user should consult the complete reference <monospace>./doc/refman.pdf</monospace>. See also the rest of the examples (not discussed in this document) in <monospace>./examples/</monospace>. for more comprehensive code snippets.</p>
    <sec id="sec010">
      <title>4.1 Gates and states</title>
      <p>Let us introduce the main objects used by <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link>: gates, states and basic operations. Consider the code in <xref ref-type="boxed-text" rid="pone.0208073.box003">Listing 2</xref>.</p>
      <boxed-text id="pone.0208073.box003" position="float" orientation="portrait">
        <sec id="sec011">
          <title>Listing 2. Gates and states</title>
          <p>
            <monospace>1 // Gates and states</monospace>
          </p>
          <p>
            <monospace>2 // Source: ./examples/gates_states.cpp</monospace>
          </p>
          <p>
            <monospace>3 #include &lt;iostream&gt;</monospace>
          </p>
          <p>
            <monospace>4</monospace>
          </p>
          <p>
            <monospace>5 #include “qpp.h”</monospace>
          </p>
          <p>
            <monospace>6</monospace>
          </p>
          <p>
            <monospace>7 int main() {</monospace>
          </p>
          <p>
            <monospace>8  using namespace qpp;</monospace>
          </p>
          <p>
            <monospace>9  ket psi = st.z0; // |0&gt; state</monospace>
          </p>
          <p>
            <monospace>10  cmat U = gt.X;</monospace>
          </p>
          <p>
            <monospace>11  ket result = U * psi;</monospace>
          </p>
          <p>
            <monospace>12</monospace>
          </p>
          <p>
            <monospace>13  std::cout &lt;&lt; “&gt;&gt; The result of applying the bit-flip gate X on |0&gt; is:\n”;</monospace>
          </p>
          <p>
            <monospace>14  std::cout &lt;&lt; disp(result) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>15</monospace>
          </p>
          <p>
            <monospace>16  psi = 10_ket;   // |10&gt; state</monospace>
          </p>
          <p>
            <monospace>17  U = gt.CNOT;  // Controlled-NOT</monospace>
          </p>
          <p>
            <monospace>18  result = U * psi;</monospace>
          </p>
          <p>
            <monospace>19</monospace>
          </p>
          <p>
            <monospace>20  std::cout &lt;&lt; “&gt;&gt; The result of applying the gate CNOT on |10&gt; is:\n”;</monospace>
          </p>
          <p>
            <monospace>21  std::cout &lt;&lt; disp(result) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>22</monospace>
          </p>
          <p>
            <monospace>23  U = randU();</monospace>
          </p>
          <p>
            <monospace>24  std::cout &lt;&lt; “&gt;&gt; Generating a random one-qubit gate U:\n”;</monospace>
          </p>
          <p>
            <monospace>25  std::cout &lt;&lt; disp(U) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>26</monospace>
          </p>
          <p>
            <monospace>27  result = applyCTRL(psi, U, {0}, {1}); // Controlled-U</monospace>
          </p>
          <p>
            <monospace>28  std::cout &lt;&lt; “&gt;&gt; The result of applying the CTRL-U gate on |10&gt; is:\n”;</monospace>
          </p>
          <p>
            <monospace>29  std::cout &lt;&lt; disp(result) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>30 }</monospace>
          </p>
        </sec>
      </boxed-text>
      <p>A possible output is:</p>
      <boxed-text id="pone.0208073.box004" position="float" orientation="portrait">
        <sec id="sec012">
          <title><xref ref-type="boxed-text" rid="pone.0208073.box003">Listing 2</xref> output</title>
          <p>
            <monospace>&gt;&gt; The result of applying the bit-flip gate X on |0&gt; is:</monospace>
          </p>
          <p>
            <monospace>0</monospace>
          </p>
          <p>
            <monospace>1</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; The result of applying the gate CNOT on |10&gt; is:</monospace>
          </p>
          <p>
            <monospace>0</monospace>
          </p>
          <p>
            <monospace>0</monospace>
          </p>
          <p>
            <monospace>0</monospace>
          </p>
          <p>
            <monospace>1</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Generating a random one-qubit gate U:</monospace>
          </p>
          <p>
            <monospace>-0.251227 − 0.849866i -0.0204441 − 0.462811i</monospace>
          </p>
          <p>
            <monospace>-0.0716251 + 0.457692i 0.343895 − 0.816777i</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; The result of applying the CTRL-U gate on |10&gt; is:</monospace>
          </p>
          <p>
            <monospace>        0</monospace>
          </p>
          <p>
            <monospace>        0</monospace>
          </p>
          <p>
            <monospace>-0.251227 − 0.849866i</monospace>
          </p>
          <p>
            <monospace>-0.0716251 + 0.457692i</monospace>
          </p>
        </sec>
      </boxed-text>
      <p>In line 5 of <xref ref-type="boxed-text" rid="pone.0208073.box003">Listing 2</xref> we bring the namespace <monospace>qpp</monospace> into the global namespace.</p>
      <p>In line 9 we use the <monospace>States</monospace> singleton <monospace>st</monospace> to declare <monospace>psi</monospace> as the zero eigenvector |0〉 of the <italic>Z</italic> Pauli operator. In line 10 we use the <monospace>Gates</monospace> singleton <monospace>gt</monospace> and assign to <monospace>U</monospace> the bit flip gate <monospace>gt.X</monospace>. In line 11 we compute the result of the operation <italic>X</italic>|0〉, and display the result |1〉 in lines 13 and 14. In line 14 we use the display manipulator <monospace>disp()</monospace>, which is especially useful when displaying complex matrices, as it displays the entries of the latter in the form <italic>a</italic> + <italic>bi</italic>, in contrast to the form (<italic>a</italic>, <italic>b</italic>) used by the C++ standard library. The manipulator also accepts additional parameters that allows e.g. setting to zero numbers smaller than some given value (useful to chop small values), and it is in addition overloaded for standard containers, iterators and C-style arrays.</p>
      <p>In line 16 we reassign to <monospace>psi</monospace> the state |10〉 via the user-defined literal <monospace>ket operator“” _ket()</monospace>. We could have also used the <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> insertion operator</p>
      <p>
        <monospace>ket psi(4); // specify the dimension before insertion of elements via &lt;&lt;</monospace>
      </p>
      <p>
        <monospace>psi &lt;&lt; 0, 0, 1, 0;</monospace>
      </p>
      <p specific-use="continuation">or the <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> library function <monospace>mket()</monospace>. In line 17 we declare a gate <monospace>U</monospace> as the Controlled-NOT with control as the first subsystem, and target as the last, using the global singleton <monospace>gt</monospace>. In line 18 we declare the ket <monospace>result</monospace> as the result of applying the Controlled-NOT gate to the state |10〉, i.e. |11〉. We then display the result of the computation in lines 20 and 21.</p>
      <p>Next, in line 23 we generate a random unitary gate via the function <monospace>randU()</monospace>, then in line 27 apply the Controlled-U, with control as the first qubit and target as the second qubit, to the state <monospace>psi</monospace>. Finally, we display the result in lines 28 and 29.</p>
    </sec>
    <sec id="sec013">
      <title>4.2 Measurements</title>
      <p>Let us now complicate things a bit and introduce measurements. Consider the example in <xref ref-type="boxed-text" rid="pone.0208073.box005">Listing 3</xref>.</p>
      <boxed-text id="pone.0208073.box005" position="float" orientation="portrait">
        <sec id="sec014">
          <title>Listing 3. Measurements</title>
          <p>
            <monospace>1 // Measurements</monospace>
          </p>
          <p>
            <monospace>2 // Source: ./examples/measurements.cpp</monospace>
          </p>
          <p>
            <monospace>3 #include &lt;iostream&gt;</monospace>
          </p>
          <p>
            <monospace>4 #include &lt;tuple&gt;</monospace>
          </p>
          <p>
            <monospace>5</monospace>
          </p>
          <p>
            <monospace>6 #include “qpp.h”</monospace>
          </p>
          <p>
            <monospace>7</monospace>
          </p>
          <p>
            <monospace>8 int main() {</monospace>
          </p>
          <p>
            <monospace>9  using namespace qpp;</monospace>
          </p>
          <p>
            <monospace>10  ket psi = 00_ket;</monospace>
          </p>
          <p>
            <monospace>11  cmat U = gt.CNOT * kron(gt.H, gt.Id2);</monospace>
          </p>
          <p>
            <monospace>12  ket result = U * psi; // we have the Bell state (|00&gt; + |11&gt;) / sqrt(2)</monospace>
          </p>
          <p>
            <monospace>13</monospace>
          </p>
          <p>
            <monospace>14  std::cout &lt;&lt; “&gt;&gt; We just produced the Bell state:\n”;</monospace>
          </p>
          <p>
            <monospace>15  std::cout &lt;&lt; disp(result) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>16</monospace>
          </p>
          <p>
            <monospace>17  // apply a bit flip on the second qubit</monospace>
          </p>
          <p>
            <monospace>18  result = apply(result, gt.X, {1}); // we produced (|01&gt; + |10&gt;) / sqrt(2)</monospace>
          </p>
          <p>
            <monospace>19  std::cout &lt;&lt; “&gt;&gt; We produced the Bell state:\n”;</monospace>
          </p>
          <p>
            <monospace>20  std::cout &lt;&lt; disp(result) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>21</monospace>
          </p>
          <p>
            <monospace>22  // measure the first qubit in the X basis</monospace>
          </p>
          <p>
            <monospace>23  auto measured = measure(result, gt.H, {0});</monospace>
          </p>
          <p>
            <monospace>24  std::cout &lt;&lt; “&gt;&gt; Measurement result: “&lt;&lt; std::get&lt;0&gt;(measured) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>25  std::cout &lt;&lt; “&gt;&gt; Probabilities: “;</monospace>
          </p>
          <p>
            <monospace>26  std::cout &lt;&lt; disp(std::get&lt;1&gt;(measured), “,”) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>27  std::cout &lt;&lt; “&gt;&gt; Resulting states: \n”;</monospace>
          </p>
          <p>
            <monospace>28  for (auto&amp;&amp; it: std::get&lt;2&gt;(measured))</monospace>
          </p>
          <p>
            <monospace>29   std::cout &lt;&lt; disp(it) &lt;&lt; “\n\n”;</monospace>
          </p>
          <p>
            <monospace>30 }</monospace>
          </p>
        </sec>
      </boxed-text>
      <p>A possible output is:</p>
      <boxed-text id="pone.0208073.box006" position="float" orientation="portrait">
        <sec id="sec015">
          <title><xref ref-type="boxed-text" rid="pone.0208073.box005">Listing 3</xref> output</title>
          <p>
            <monospace>&gt;&gt; We just produced the Bell state:</monospace>
          </p>
          <p>
            <monospace>0.707107</monospace>
          </p>
          <p>
            <monospace>   0</monospace>
          </p>
          <p>
            <monospace>   0</monospace>
          </p>
          <p>
            <monospace>0.707107</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; We produced the Bell state:</monospace>
          </p>
          <p>
            <monospace>   0</monospace>
          </p>
          <p>
            <monospace>0.707107</monospace>
          </p>
          <p>
            <monospace>0.707107</monospace>
          </p>
          <p>
            <monospace>   0</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Measurement result: 1</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Probabilities: [0.5, 0.5]</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Resulting states:</monospace>
          </p>
          <p>
            <monospace>0.707107</monospace>
          </p>
          <p>
            <monospace>0.707107</monospace>
          </p>
          <p>
            <monospace>-0.707107</monospace>
          </p>
          <p>
            <monospace>0.707107</monospace>
          </p>
        </sec>
      </boxed-text>
      <p>In line 11 of <xref ref-type="boxed-text" rid="pone.0208073.box005">Listing 3</xref> we use the function <monospace>kron()</monospace> to create the tensor product (Kronecker product) of the Hadamard gate on the first qubit and identity on the second qubit, then we left-multiply it by the Controlled-NOT gate. In line 12 we compute the result of the operation <italic>CNOT</italic><sub><italic>ab</italic></sub>(<italic>H</italic> ⊗ <italic>I</italic>)|00〉, which is the Bell state <inline-formula id="pone.0208073.e003"><alternatives><graphic xlink:href="pone.0208073.e003.jpg" id="pone.0208073.e003g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M3"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:mn>00</mml:mn><mml:mo>〉</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mn>11</mml:mn><mml:mo>〉</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mrow></mml:math></alternatives></inline-formula>. We display it in lines 14 and 15.</p>
      <p>In line 18 we use the function <monospace>apply()</monospace> to apply the gate <italic>X</italic> on the second qubit of the previously produced Bell state. Note that <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> uses the C/C++ numbering convention, with indexes starting from zero. The function <monospace>apply()</monospace> takes as its third parameter a list of subsystems, and in our case <monospace>{1}</monospace> denotes the <underline>second</underline> subsystem, not the first. The function <monospace>apply()</monospace>, as well as many other functions that we will encounter, have a variety of useful overloads, see <monospace>doc/refman.pdf</monospace> for a detailed library reference. In lines 19 and 20 we display the newly created Bell state.</p>
      <p>In line 23 we use the function <monospace>measure()</monospace> to perform a measurement of the first qubit (subsystem <monospace>{0}</monospace>) in the <italic>X</italic> basis. You may be confused by the apparition of <monospace>gt.H</monospace>, however this overload of the function <monospace>measure()</monospace> takes as its second parameter the measurement basis, specified as the columns of a complex matrix. In our case, the eigenvectors of the <italic>X</italic> operator are just the columns of the Hadamard matrix. As mentioned before, as all other library functions, <monospace>measure()</monospace> returns by value, hence it does not modify its argument. The return of <monospace>measure</monospace> is a tuple consisting of the measurement result, the outcome probabilities, and the possible output states. Technically <monospace>measure()</monospace> returns a tuple of 3 elements</p>
      <p>
        <monospace>std::tuple&lt;qpp::idx, std::vector&lt;double&gt;, std::vector&lt;qpp::cmat&gt;&gt;</monospace>
      </p>
      <p>The first element represents the measurement result, the second the possible output probabilities and the third the output states. Instead of using this cumbersome type definition, we use the new C++11 <monospace>auto</monospace> keyword to infer the type of the result <monospace>measured</monospace> returned by <monospace>measure()</monospace>. In lines 24–29 we use the standard <monospace>std::get&lt;&gt;()</monospace> function to retrieve each element of the tuple, then display the measurement result, the probabilities and the resulting output states.</p>
    </sec>
    <sec id="sec016">
      <title>4.3 Quantum operations</title>
      <p>In <xref ref-type="boxed-text" rid="pone.0208073.box007">Listing 4</xref> we introduce quantum operations: quantum channels, as well as the partial trace and partial transpose operations.</p>
      <boxed-text id="pone.0208073.box007" position="float" orientation="portrait">
        <sec id="sec017">
          <title>Listing 4. Quantum operations</title>
          <p>
            <monospace>1 // Quantum operations</monospace>
          </p>
          <p>
            <monospace>2 // Source: ./examples/quantum_operations.cpp</monospace>
          </p>
          <p>
            <monospace>3 #include &lt;iostream&gt;</monospace>
          </p>
          <p>
            <monospace>4 #include &lt;vector&gt;</monospace>
          </p>
          <p>
            <monospace>5</monospace>
          </p>
          <p>
            <monospace>6 #include “qpp.h”</monospace>
          </p>
          <p>
            <monospace>7</monospace>
          </p>
          <p>
            <monospace>8 int main() {</monospace>
          </p>
          <p>
            <monospace>9  using namespace qpp;</monospace>
          </p>
          <p>
            <monospace>10  cmat rho = st.pb00; // projector onto the Bell state (|00&gt; + |11&gt;) / sqrt(2)</monospace>
          </p>
          <p>
            <monospace>11  std::cout &lt;&lt; “&gt;&gt; Initial state:\n”;</monospace>
          </p>
          <p>
            <monospace>12  std::cout &lt;&lt; disp(rho) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>13</monospace>
          </p>
          <p>
            <monospace>14  // partial transpose of first subsystem</monospace>
          </p>
          <p>
            <monospace>15  cmat rhoTA = ptranspose(rho, {0});</monospace>
          </p>
          <p>
            <monospace>16  std::cout &lt;&lt; “&gt;&gt; Eigenvalues of the partial transpose”</monospace>
          </p>
          <p>
            <monospace>17      &lt;&lt; “of Bell-0 state are:\n”;</monospace>
          </p>
          <p>
            <monospace>18  std::cout &lt;&lt; disp(transpose(hevals(rhoTA))) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>19</monospace>
          </p>
          <p>
            <monospace>20  std::cout &lt;&lt; “&gt;&gt; Measurement channel with 2 Kraus operators:\n”;</monospace>
          </p>
          <p>
            <monospace>21  std::vector&lt;cmat&gt; Ks{st.pz0, st.pz1}; // 2 Kraus operators</monospace>
          </p>
          <p>
            <monospace>22  std::cout &lt;&lt; disp(Ks[0]) &lt;&lt; “\nand\n” &lt;&lt; disp(Ks[1]) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>23</monospace>
          </p>
          <p>
            <monospace>24  std::cout &lt;&lt; “&gt;&gt; Superoperator matrix of the channel:\n”;</monospace>
          </p>
          <p>
            <monospace>25  std::cout &lt;&lt; disp(kraus2super(Ks)) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>26</monospace>
          </p>
          <p>
            <monospace>27  std::cout &lt;&lt; “&gt;&gt; Choi matrix of the channel:\n”;</monospace>
          </p>
          <p>
            <monospace>28  std::cout &lt;&lt; disp(kraus2choi(Ks)) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>29</monospace>
          </p>
          <p>
            <monospace>30  // apply the channel onto the first subsystem</monospace>
          </p>
          <p>
            <monospace>31  cmat rhoOut = apply(rho, Ks, {0});</monospace>
          </p>
          <p>
            <monospace>32  std::cout &lt;&lt; “&gt;&gt; After applying the measurement channel”</monospace>
          </p>
          <p>
            <monospace>33      &lt;&lt; “on the first qubit:\n”;</monospace>
          </p>
          <p>
            <monospace>34  std::cout &lt;&lt; disp(rhoOut) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>35</monospace>
          </p>
          <p>
            <monospace>36  // take the partial trace over the second subsystem</monospace>
          </p>
          <p>
            <monospace>37  cmat rhoA = ptrace(rhoOut, {1});</monospace>
          </p>
          <p>
            <monospace>38  std::cout &lt;&lt; “&gt;&gt; After partially tracing down the second subsystem:\n”;</monospace>
          </p>
          <p>
            <monospace>39  std::cout &lt;&lt; disp(rhoA) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>40</monospace>
          </p>
          <p>
            <monospace>41  // compute the von-Neumann entropy</monospace>
          </p>
          <p>
            <monospace>42  double ent = entropy(rhoA);</monospace>
          </p>
          <p>
            <monospace>43  std::cout &lt;&lt; “&gt;&gt; Entropy: “&lt;&lt; ent &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>44 }</monospace>
          </p>
        </sec>
      </boxed-text>
      <p>The output of this program is:</p>
      <boxed-text id="pone.0208073.box008" position="float" orientation="portrait">
        <sec id="sec018">
          <title><xref ref-type="boxed-text" rid="pone.0208073.box007">Listing 4</xref> output</title>
          <p>
            <monospace>&gt;&gt; Initial state:</monospace>
          </p>
          <p>
            <monospace>0.5 0 0 0.5</monospace>
          </p>
          <p>
            <monospace> 0 0 0 0</monospace>
          </p>
          <p>
            <monospace> 0 0 0 0</monospace>
          </p>
          <p>
            <monospace>0.5 0 0 0.5</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Eigenvalues of the partial transpose of Bell-0 state are:</monospace>
          </p>
          <p>
            <monospace>-0.5 0.5 0.5 0.5</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Measurement channel with 2 Kraus operators:</monospace>
          </p>
          <p>
            <monospace>1 0</monospace>
          </p>
          <p>
            <monospace>0 0</monospace>
          </p>
          <p>
            <monospace>and</monospace>
          </p>
          <p>
            <monospace>0 0</monospace>
          </p>
          <p>
            <monospace>0 1</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Superoperator matrix of the channel:</monospace>
          </p>
          <p>
            <monospace>1 0 0 0</monospace>
          </p>
          <p>
            <monospace>0 0 0 0</monospace>
          </p>
          <p>
            <monospace>0 0 0 0</monospace>
          </p>
          <p>
            <monospace>0 0 0 1</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Choi matrix of the channel:</monospace>
          </p>
          <p>
            <monospace>1 0 0 0</monospace>
          </p>
          <p>
            <monospace>0 0 0 0</monospace>
          </p>
          <p>
            <monospace>0 0 0 0</monospace>
          </p>
          <p>
            <monospace>0 0 0 1</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; After applying the measurement channel on the first qubit:</monospace>
          </p>
          <p>
            <monospace>0.5 0 0 0</monospace>
          </p>
          <p>
            <monospace> 0 0 0 0</monospace>
          </p>
          <p>
            <monospace> 0 0 0 0</monospace>
          </p>
          <p>
            <monospace> 0 0 0 0.5</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; After partially tracing down the second subsystem:</monospace>
          </p>
          <p>
            <monospace>0.5  0</monospace>
          </p>
          <p>
            <monospace> 0 0.5</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Entropy: 1</monospace>
          </p>
        </sec>
      </boxed-text>
      <p>The example should by now be self-explanatory. In line 10 of <xref ref-type="boxed-text" rid="pone.0208073.box007">Listing 4</xref> we define the input state <monospace>rho</monospace> as the projector onto the Bell state <inline-formula id="pone.0208073.e004"><alternatives><graphic xlink:href="pone.0208073.e004.jpg" id="pone.0208073.e004g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M4"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:mn>00</mml:mn><mml:mo>〉</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mn>11</mml:mn><mml:mo>〉</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mrow></mml:math></alternatives></inline-formula>, then display it in lines 11 and 12.</p>
      <p>In lines 15–18 we partially transpose the first qubit, then display the eigenvalues of the resulting matrix <monospace>rhoTA</monospace>.</p>
      <p>In lines 20–22 we define a quantum channel <monospace>Ks</monospace> consisting of two Kraus operators: |0〉〈0| and |1〉〈1|, then display the latter. Note that <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> uses the <monospace>std::vector&lt;cmat&gt;</monospace> container to store the Kraus operators and define a quantum channel.</p>
      <p>In lines 24–28 we display the superoperator matrix as well as the Choi matrix of the channel <monospace>Ks</monospace>.</p>
      <p>Next, in lines 31–34 we apply the channel <monospace>Ks</monospace> to the first qubit of the input state <monospace>rho</monospace>, then display the output state <monospace>rhoOut</monospace>.</p>
      <p>In lines 37–39 we take the partial trace of the output state <monospace>rhoOut</monospace>, then display the resulting state <monospace>rhoA</monospace>.</p>
      <p>Finally, in lines 42 and 43 we compute the von-Neumann entropy of the resulting state and display it.</p>
    </sec>
    <sec id="sec019">
      <title>4.4 Timing</title>
      <p>To facilitate simple timing tasks, <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> provides a <monospace>Timer&lt;&gt;</monospace> class that uses internally a <monospace>std::steady_clock</monospace>. The program in <xref ref-type="boxed-text" rid="pone.0208073.box009">Listing 5</xref> demonstrate its usage.</p>
      <boxed-text id="pone.0208073.box009" position="float" orientation="portrait">
        <sec id="sec020">
          <title>Listing 5. Timing</title>
          <p>
            <monospace>1 // Timing</monospace>
          </p>
          <p>
            <monospace>2 // Source: ./examples/timing.cpp</monospace>
          </p>
          <p>
            <monospace>3 #include &lt;iomanip&gt;</monospace>
          </p>
          <p>
            <monospace>4 #include &lt;iostream&gt;</monospace>
          </p>
          <p>
            <monospace>5 #include &lt;vector&gt;</monospace>
          </p>
          <p>
            <monospace>6</monospace>
          </p>
          <p>
            <monospace>7 #include “qpp.h”</monospace>
          </p>
          <p>
            <monospace>8</monospace>
          </p>
          <p>
            <monospace>9 int main() {</monospace>
          </p>
          <p>
            <monospace>10  using namespace qpp;</monospace>
          </p>
          <p>
            <monospace>11  std::cout &lt;&lt; std::setprecision(8); // increase the default output precision</monospace>
          </p>
          <p>
            <monospace>12</monospace>
          </p>
          <p>
            <monospace>13  // get the first codeword from Shor’s [[9,1,3]] code</monospace>
          </p>
          <p>
            <monospace>14  ket c0 = codes.codeword(Codes::Type::NINE_QUBIT_SHOR, 0);</monospace>
          </p>
          <p>
            <monospace>15</monospace>
          </p>
          <p>
            <monospace>16  Timer&lt;&gt; t;             // declare and start a timer</monospace>
          </p>
          <p>
            <monospace>17  std::vector&lt;idx&gt; perm = randperm(9); // declare a random permutation</monospace>
          </p>
          <p>
            <monospace>18  ket c0perm = syspermute(c0, perm);  // permute the system</monospace>
          </p>
          <p>
            <monospace>19  t.toc();              // stops the timer</monospace>
          </p>
          <p>
            <monospace>20  std::cout &lt;&lt; “&gt;&gt; Permuting subsystems according to “&lt;&lt; disp(perm, “, “);</monospace>
          </p>
          <p>
            <monospace>21  std::cout &lt;&lt; “\n&gt;&gt; It took “&lt;&lt; t &lt;&lt; “seconds to permute the subsytems. \n”;</monospace>
          </p>
          <p>
            <monospace>22</monospace>
          </p>
          <p>
            <monospace>23  t.tic();   // restart the timer</monospace>
          </p>
          <p>
            <monospace>24  std::cout &lt;&lt; “&gt;&gt; Inverse permutation: ”;</monospace>
          </p>
          <p>
            <monospace>25  std::cout &lt;&lt; disp(invperm(perm), “, “) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>26  ket c0invperm = syspermute(c0perm, invperm(perm)); // permute again</monospace>
          </p>
          <p>
            <monospace>27  std::cout &lt;&lt; “&gt;&gt; It took “&lt;&lt; t.toc();</monospace>
          </p>
          <p>
            <monospace>28  std::cout &lt;&lt; “seconds to un-permute the subsystems. \n”;</monospace>
          </p>
          <p>
            <monospace>29</monospace>
          </p>
          <p>
            <monospace>30  std::cout &lt;&lt; “&gt;&gt; Norm difference: “&lt;&lt; norm(c0invperm − c0) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>31 }</monospace>
          </p>
        </sec>
      </boxed-text>
      <p>A possible output of this program is:</p>
      <boxed-text id="pone.0208073.box010" position="float" orientation="portrait">
        <sec id="sec021">
          <title><xref ref-type="boxed-text" rid="pone.0208073.box009">Listing 5</xref> output</title>
          <p>
            <monospace>&gt;&gt; Permuting subsystems according to [7, 5, 3, 4, 2, 6, 0, 8, 1]</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; It took 0.000161381 seconds to permute the subsytems.</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Inverse permutation: [6, 8, 4, 2, 3, 1, 5, 0, 7]</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; It took 0.000104443 seconds to un-permute the subsystems.</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Norm difference: 0</monospace>
          </p>
        </sec>
      </boxed-text>
      <p>In line 11 of <xref ref-type="boxed-text" rid="pone.0208073.box009">Listing 5</xref> we change the default output precision from 4 to 8 decimals after the delimiter.</p>
      <p>In line 14 we use the <monospace>Codes</monospace> singleton <monospace>codes</monospace> to retrieve in <monospace>c0</monospace> the first codeword of the Shor’s [[9, 1, 3]] quantum error correcting code.</p>
      <p>In line 16 we declare an instance <monospace>timer</monospace> of the class <monospace>Timer&lt;&gt;</monospace>. In line 17 we declare a random permutation <monospace>perm</monospace> via the function <monospace>randperm()</monospace>. In line 18 we permute the codeword according to the permutation <monospace>perm</monospace> using the function <monospace>syspermute()</monospace> and store the result. In line 19 we stop the timer. In line 20 we display the permutation, using an overloaded form of the <monospace>disp()</monospace> manipulator for C++ standard library containers. The latter takes a <monospace>std::string</monospace> as its second parameter to specify the delimiter between the elements of the container. In line 21 we display the elapsed time using the <monospace>ostream operator&lt;&lt;()</monospace> operator overload for <monospace>Timer&lt;&gt;</monospace> instances.</p>
      <p>Next, in line 23 we reset the timer, then display the inverse permutation of <monospace>perm</monospace> in lines 24 and 25. In line 26 we permute the already permuted state <monospace>c0perm</monospace> according to the inverse permutation of <monospace>perm</monospace>, and store the result in <monospace>c0invperm</monospace>. In lines 27 and 28 we display the elapsed time. Note that in line 27 we used directly <monospace>t.toc()</monospace> in the stream insertion operator, since, for convenience, the member function <monospace>Timer&lt;&gt;::toc()</monospace> returns a <monospace>const Timer&lt;&gt;&amp;</monospace>.</p>
      <p>Finally, in line 30, we verify that by permuting and permuting again using the inverse permutation we recover the initial codeword, i.e. the norm difference has to be zero.</p>
    </sec>
    <sec id="sec022">
      <title>4.5 Input/Output</title>
      <p>We now introduce the input/output functions of <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link>, as well as the input/output interfacing with <ext-link ext-link-type="uri" xlink:href="http://www.mathworks.com/products/matlab/">MATLAB</ext-link>. The program in <xref ref-type="boxed-text" rid="pone.0208073.box011">Listing 6</xref> saves a matrix in both <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> internal format as well as in <ext-link ext-link-type="uri" xlink:href="http://www.mathworks.com/products/matlab/">MATLAB</ext-link> format, then loads it back and tests that the norm difference between the saved/loaded matrix is zero.</p>
      <boxed-text id="pone.0208073.box011" position="float" orientation="portrait">
        <sec id="sec023">
          <title>Listing 6. Input/output</title>
          <p>
            <monospace>1 // Input/output</monospace>
          </p>
          <p>
            <monospace>2 // Source: ./examples/input_output.cpp</monospace>
          </p>
          <p>
            <monospace>3 #include &lt;iostream&gt;</monospace>
          </p>
          <p>
            <monospace>4</monospace>
          </p>
          <p>
            <monospace>5 #include “qpp.h”</monospace>
          </p>
          <p>
            <monospace>6 #include “MATLAB/matlab.h” // must be explicitly included</monospace>
          </p>
          <p>
            <monospace>7</monospace>
          </p>
          <p>
            <monospace>8 int main() {</monospace>
          </p>
          <p>
            <monospace>9  using namespace qpp;</monospace>
          </p>
          <p>
            <monospace>10  // Quantum++ native input/output</monospace>
          </p>
          <p>
            <monospace>11  cmat rho = randrho(256);        // an 8 qubit density operator</monospace>
          </p>
          <p>
            <monospace>12  save(rho, “rho.dat”);          // save it</monospace>
          </p>
          <p>
            <monospace>13  cmat loaded_rho = load&lt;cmat&gt;(“rho.dat”); // load it back</monospace>
          </p>
          <p>
            <monospace>14  // display the difference in norm, should be 0</monospace>
          </p>
          <p>
            <monospace>15  std::cout &lt;&lt; “&gt;&gt; Norm difference load/save: “;</monospace>
          </p>
          <p>
            <monospace>16  std::cout &lt;&lt; norm(loaded_rho − rho) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>17</monospace>
          </p>
          <p>
            <monospace>18  // interfacing with MATLAB</monospace>
          </p>
          <p>
            <monospace>19  saveMATLAB(rho, “rho.mat”, “rho”, “w”);</monospace>
          </p>
          <p>
            <monospace>20  loaded_rho = loadMATLAB&lt;cmat&gt;(“rho.mat”, “rho”);</monospace>
          </p>
          <p>
            <monospace>21  // display the difference in norm, should be 0</monospace>
          </p>
          <p>
            <monospace>22  std::cout &lt;&lt; “&gt;&gt; Norm difference MATLAB load/save:”;</monospace>
          </p>
          <p>
            <monospace>23  std::cout &lt;&lt; norm(loaded_rho − rho) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>24 }</monospace>
          </p>
        </sec>
      </boxed-text>
      <p>The output of this program is:</p>
      <boxed-text id="pone.0208073.box012" position="float" orientation="portrait">
        <sec id="sec024">
          <title><xref ref-type="boxed-text" rid="pone.0208073.box011">Listing 6</xref> output</title>
          <p>
            <monospace>&gt;&gt; Norm difference load/save: 0</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Norm difference MATLAB load/save: 0</monospace>
          </p>
        </sec>
      </boxed-text>
      <p>Note that in order to use the <ext-link ext-link-type="uri" xlink:href="http://www.mathworks.com/products/matlab/">MATLAB</ext-link> input/output interface support, you need to explicitly include the header file <monospace>MATLAB/matlab.h</monospace>, and you also need to have <ext-link ext-link-type="uri" xlink:href="http://www.mathworks.com/products/matlab/">MATLAB</ext-link> or <ext-link ext-link-type="uri" xlink:href="http://www.mathworks.com/products/matlab/">MATLAB</ext-link> compiler installed, otherwise the program fails to compile. See the Wiki for extensive details about compiling with <ext-link ext-link-type="uri" xlink:href="http://www.mathworks.com/products/matlab/">MATLAB</ext-link> support.</p>
    </sec>
    <sec id="sec025">
      <title>4.6 Qudit teleportation</title>
      <p>As mentioned before, <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> treats qubits and qudits on the same footing. Below is a relatively more advanced self- documented example that implements the teleportation protocol for qudits.</p>
      <boxed-text id="pone.0208073.box013" position="float" orientation="portrait">
        <sec id="sec026">
          <title>Listing 7. Qudit teleporation</title>
          <p>
            <monospace>1 // Qudit teleporation</monospace>
          </p>
          <p>
            <monospace>2 // Source: ./examples/teleport_qudit.cpp</monospace>
          </p>
          <p>
            <monospace>3 #include &lt;cmath&gt;</monospace>
          </p>
          <p>
            <monospace>4 #include &lt;iostream&gt;</monospace>
          </p>
          <p>
            <monospace>5 #include &lt;tuple&gt;</monospace>
          </p>
          <p>
            <monospace>6 #include &lt;vector&gt;</monospace>
          </p>
          <p>
            <monospace>7</monospace>
          </p>
          <p>
            <monospace>8 #include “qpp.h”</monospace>
          </p>
          <p>
            <monospace>9</monospace>
          </p>
          <p>
            <monospace>10 int main() {</monospace>
          </p>
          <p>
            <monospace>11  using namespace qpp;</monospace>
          </p>
          <p>
            <monospace>12  idx D = 3; // size of the system</monospace>
          </p>
          <p>
            <monospace>13  std::cout &lt;&lt; “&gt;&gt; Qudit teleportation, D = “&lt;&lt; D &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>14</monospace>
          </p>
          <p>
            <monospace>15  ket mes_AB = st.mes(D); // maximally entangled state resource</monospace>
          </p>
          <p>
            <monospace>16</monospace>
          </p>
          <p>
            <monospace>17  // circuit that measures in the qudit Bell basis</monospace>
          </p>
          <p>
            <monospace>18  cmat Bell_aA =</monospace>
          </p>
          <p>
            <monospace>19   adjoint(gt.CTRL(gt.Xd(D), {0}, {1}, 2, D) * kron(gt.Fd(D), gt.Id(D)));</monospace>
          </p>
          <p>
            <monospace>20</monospace>
          </p>
          <p>
            <monospace>21  ket psi_a = randket(D); // random qudit state</monospace>
          </p>
          <p>
            <monospace>22  std::cout &lt;&lt; “&gt;&gt; Initial state:\n”;</monospace>
          </p>
          <p>
            <monospace>23  std::cout &lt;&lt; disp(psi_a) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>24</monospace>
          </p>
          <p>
            <monospace>25  ket input_aAB = kron(psi_a, mes_AB); // joint input state aAB</monospace>
          </p>
          <p>
            <monospace>26  // output before measurement</monospace>
          </p>
          <p>
            <monospace>27  ket output_aAB = apply(input_aAB, Bell_aA, {0, 1}, D);</monospace>
          </p>
          <p>
            <monospace>28</monospace>
          </p>
          <p>
            <monospace>29  // measure on aA</monospace>
          </p>
          <p>
            <monospace>30  auto measured_aA = measure(output_aAB, gt.Id(D * D), {0, 1}, D);</monospace>
          </p>
          <p>
            <monospace>31  idx m = std::get&lt;0&gt;(measured_aA); // measurement result</monospace>
          </p>
          <p>
            <monospace>32</monospace>
          </p>
          <p>
            <monospace>33  std::vector&lt;idx&gt; midx = n2multiidx(m, {D, D});</monospace>
          </p>
          <p>
            <monospace>34  std::cout &lt;&lt; “&gt;&gt; Alice measurement result: “;</monospace>
          </p>
          <p>
            <monospace>35  std::cout &lt;&lt; m &lt;&lt; “-&gt; “&lt;&lt; disp(midx, “”) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>36  std::cout &lt;&lt; “&gt;&gt; Alice measurement probabilities: “;</monospace>
          </p>
          <p>
            <monospace>37  std::cout &lt;&lt; disp(std::get&lt;1&gt;(measured_aA), “, “) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>38</monospace>
          </p>
          <p>
            <monospace>39  // conditional result on B before correction</monospace>
          </p>
          <p>
            <monospace>40  ket output_m_B = std::get&lt;2&gt;(measured_aA)[m];</monospace>
          </p>
          <p>
            <monospace>41</monospace>
          </p>
          <p>
            <monospace>42  // perform the correction on B</monospace>
          </p>
          <p>
            <monospace>43  cmat correction_B =</monospace>
          </p>
          <p>
            <monospace>44   powm(gt.Zd(D), midx[0]) * powm(adjoint(gt.Xd(D)), midx[1]);</monospace>
          </p>
          <p>
            <monospace>45  std::cout &lt;&lt; “&gt;&gt; Bob must apply the correction operator Z^“&lt;&lt; midx[0]</monospace>
          </p>
          <p>
            <monospace>46     &lt;&lt; “X^” &lt;&lt; (D − midx[1]) % D &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>47  ket psi_B = correction_B * output_m_B;</monospace>
          </p>
          <p>
            <monospace>48</monospace>
          </p>
          <p>
            <monospace>49  // display the output</monospace>
          </p>
          <p>
            <monospace>50  std::cout &lt;&lt; “&gt;&gt; Bob final state (after correction): \n”;</monospace>
          </p>
          <p>
            <monospace>51  std::cout &lt;&lt; disp(psi_B) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>52</monospace>
          </p>
          <p>
            <monospace>53  // verification</monospace>
          </p>
          <p>
            <monospace>54  std::cout &lt;&lt; “&gt;&gt; Norm difference: “&lt;&lt; norm(psi_B − psi_a) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>55 }</monospace>
          </p>
        </sec>
      </boxed-text>
      <p>The output of this program is:</p>
      <boxed-text id="pone.0208073.box014" position="float" orientation="portrait">
        <sec id="sec027">
          <title><xref ref-type="boxed-text" rid="pone.0208073.box013">Listing 7</xref> output</title>
          <p>
            <monospace>&gt;&gt; Qudit teleportation, D = 3</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Initial state:</monospace>
          </p>
          <p>
            <monospace>0.305468 + 0.0132564i</monospace>
          </p>
          <p>
            <monospace>-0.274931 − 0.690466i</monospace>
          </p>
          <p>
            <monospace>-0.537024 − 0.256493i</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Alice measurement result: 2 -&gt; [0 2]</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Alice measurement probabilities: [0.111111, 0.111111, 0.111111, 0.111111,</monospace>
          </p>
          <p>
            <monospace> 0.111111, 0.111111, 0.111111, 0.111111, 0.111111]</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Bob must apply the correction operator Z^0 X^1</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Bob final state (after correction):</monospace>
          </p>
          <p>
            <monospace>0.305468 + 0.0132564i</monospace>
          </p>
          <p>
            <monospace>-0.274931 − 0.690466i</monospace>
          </p>
          <p>
            <monospace>-0.537024 − 0.256493i</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Norm difference: 1.23512e-15</monospace>
          </p>
        </sec>
      </boxed-text>
    </sec>
    <sec id="sec028">
      <title>4.7 Exceptions</title>
      <p>Most <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> functions throw exceptions in the case of unrecoverable errors, such as out-of-range input parameters, input/output errors etc. The exceptions are handled via the class <monospace>Exception</monospace>, derived from <monospace>std::exception</monospace>. The exception types are hard-coded inside the strongly-typed enumeration (enum class) <monospace>Exception::Type</monospace>. If you want to add more exceptions, augment the enumeration <monospace>Exception::Type</monospace> and also modify accordingly the member function <monospace>Exception::construct_exception_msg_()</monospace>, which constructs the exception message displayed via the overridden virtual function <monospace>Exception::what()</monospace>. <xref ref-type="boxed-text" rid="pone.0208073.box015">Listing 8</xref> illustrates the basics of exception handling in <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link>.</p>
      <boxed-text id="pone.0208073.box015" position="float" orientation="portrait">
        <sec id="sec029">
          <title>Listing 8. Exceptions</title>
          <p>
            <monospace>1 // Exceptions</monospace>
          </p>
          <p>
            <monospace>2 // Source: ./examples/exceptions.cpp</monospace>
          </p>
          <p>
            <monospace>3 #include &lt;exception&gt;</monospace>
          </p>
          <p>
            <monospace>4 #include &lt;iostream&gt;</monospace>
          </p>
          <p>
            <monospace>5</monospace>
          </p>
          <p>
            <monospace>6 #include “qpp.h”</monospace>
          </p>
          <p>
            <monospace>7</monospace>
          </p>
          <p>
            <monospace>8 int main() {</monospace>
          </p>
          <p>
            <monospace>9  using namespace qpp;</monospace>
          </p>
          <p>
            <monospace>10  cmat rho = randrho(16); // 4 qubits (subsystems)</monospace>
          </p>
          <p>
            <monospace>11  try {</monospace>
          </p>
          <p>
            <monospace>12    // the line below throws qpp::exception::SubsysMismatchDims</monospace>
          </p>
          <p>
            <monospace>13    double mInfo = qmutualinfo(rho, {0}, {4});</monospace>
          </p>
          <p>
            <monospace>14    std::cout &lt;&lt; “&gt;&gt; Mutual information between first and last subsystem: “;</monospace>
          </p>
          <p>
            <monospace>15    std::cout &lt;&lt; mInfo &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>16  } catch (const std::exception&amp; e) {</monospace>
          </p>
          <p>
            <monospace>17    std::cout &lt;&lt; “&gt;&gt; Exception caught: “&lt;&lt; e.what() &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>18  }</monospace>
          </p>
          <p>
            <monospace>19 }</monospace>
          </p>
        </sec>
      </boxed-text>
      <p>The output of this program is:</p>
      <boxed-text id="pone.0208073.box016" position="float" orientation="portrait">
        <sec id="sec030">
          <title><xref ref-type="boxed-text" rid="pone.0208073.box015">Listing 8</xref> output</title>
          <p>
            <monospace>&gt;&gt; Exception caught: IN qpp::qmutualinfo(): Subsystems mismatch dimensions!</monospace>
          </p>
        </sec>
      </boxed-text>
      <p>In line 10 of <xref ref-type="boxed-text" rid="pone.0208073.box015">Listing 8</xref> we define a random density matrix on four qubits (dimension 16). In line 13, we compute the mutual information between the first and the 5-th subsystem (which does not exist). Line 13 throws an exception of type <monospace>qpp::exception::SubsysMismatchDim</monospace> exception, as there are only four systems. We next catch the exception in line 16 via the <monospace>std::exception</monospace> standard exception base class. We could have also used the Quantum++ exception base class <monospace>qpp::exception::Exception</monospace>, however using the <monospace>std::exception</monospace> allows the catching of other exceptions, not just of the type <monospace>Exception</monospace>. Finally, in line 17 we display the corresponding exception message.</p>
    </sec>
    <sec id="sec031">
      <title>4.8 Classical reversible logic</title>
      <p><ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> provides support for classical reversible logic and circuits via two classes, <monospace>Dynamic_bitset</monospace> and <monospace>Bit_circuit</monospace>. The first is similar to the standard library <monospace>std::bitset</monospace>, with the exception that the length of the bitset can be specified at runtime, whereas the latter is used to describe a classical reversible bit circuit and provides the required interface for applying gates, retrieving bit values etc. The example in <xref ref-type="boxed-text" rid="pone.0208073.box017">Listing 9</xref> is self-explanatory.</p>
      <boxed-text id="pone.0208073.box017" position="float" orientation="portrait">
        <sec id="sec032">
          <title>Listing 9. Classical reversible logic</title>
          <p>
            <monospace>1 // Reversible classical circuits</monospace>
          </p>
          <p>
            <monospace>2 // Source: ./examples/reversible.cpp</monospace>
          </p>
          <p>
            <monospace>3 #include &lt;iostream&gt;</monospace>
          </p>
          <p>
            <monospace>4</monospace>
          </p>
          <p>
            <monospace>5 #include “qpp.h”</monospace>
          </p>
          <p>
            <monospace>6</monospace>
          </p>
          <p>
            <monospace>7 int main() {</monospace>
          </p>
          <p>
            <monospace>8  using namespace qpp;</monospace>
          </p>
          <p>
            <monospace>9  std::cout &lt;&lt; “&gt;&gt; Classical reversible circuits. “;</monospace>
          </p>
          <p>
            <monospace>10  std::cout &lt;&lt; “Bits are labeled from right to left,\n “;</monospace>
          </p>
          <p>
            <monospace>11  std::cout &lt;&lt; “i.e. bit zero is the least significant bit (rightmost).\n”;</monospace>
          </p>
          <p>
            <monospace>12</monospace>
          </p>
          <p>
            <monospace>13  Dynamic_bitset bits{4};            // 4 classical bits</monospace>
          </p>
          <p>
            <monospace>14  std::cout &lt;&lt; “&gt;&gt; Initial bitset:\n\t” &lt;&lt; bits &lt;&lt; ‘\n’; // display them</monospace>
          </p>
          <p>
            <monospace>15</monospace>
          </p>
          <p>
            <monospace>16  bits.rand(); // randomize the bits</monospace>
          </p>
          <p>
            <monospace>17  std::cout &lt;&lt; “&gt;&gt; After randomization:\n\t” &lt;&lt; bits &lt;&lt; ‘\n’; // display them</monospace>
          </p>
          <p>
            <monospace>18</monospace>
          </p>
          <p>
            <monospace>19  Bit_circuit bit_circuit{bits}; // bit circuit</monospace>
          </p>
          <p>
            <monospace>20</monospace>
          </p>
          <p>
            <monospace>21  std::cout &lt;&lt; “&gt;&gt; Apply X_0, followed by CNOT_02, CNOT_13 and TOF_013\n”;</monospace>
          </p>
          <p>
            <monospace>22  bit_circuit.X(0); // apply a NOT gate on first bit</monospace>
          </p>
          <p>
            <monospace>23  bit_circuit.CNOT({0, 2}).CNOT({1, 3}).TOF({0, 1, 3}); // sequence operations</monospace>
          </p>
          <p>
            <monospace>24</monospace>
          </p>
          <p>
            <monospace>25  std::cout &lt;&lt; “&gt;&gt; Final bit circuit:\n\t” &lt;&lt; bit_circuit &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>26  std::cout &lt;&lt; “&gt;&gt; 3rd bit: “&lt;&lt; bit_circuit.get(2) &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>27  std::cout &lt;&lt; “&gt;&gt; CNOT count: “&lt;&lt; bit_circuit.gate_count.CNOT &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>28</monospace>
          </p>
          <p>
            <monospace>29  bit_circuit.reset(); // resets the circuit</monospace>
          </p>
          <p>
            <monospace>30  std::cout &lt;&lt; “&gt;&gt; Reseted circuit:\n\t” &lt;&lt; bit_circuit &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>31  std::cout &lt;&lt; “&gt;&gt; CNOT count: “&lt;&lt; bit_circuit.gate_count.CNOT &lt;&lt; ‘\n’;</monospace>
          </p>
          <p>
            <monospace>32 }</monospace>
          </p>
        </sec>
      </boxed-text>
      <p>The output of this program is:</p>
      <boxed-text id="pone.0208073.box018" position="float" orientation="portrait">
        <sec id="sec033">
          <title><xref ref-type="boxed-text" rid="pone.0208073.box017">Listing 9</xref> output</title>
          <p>
            <monospace>&gt;&gt; Classical reversible circuits. Bits are labeled from right to left,</monospace>
          </p>
          <p>
            <monospace> i.e. bit zero is the least significant bit (rightmost).</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Initial bitset:</monospace>
          </p>
          <p>
            <monospace>  0000</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; After randomization:</monospace>
          </p>
          <p>
            <monospace>  0110</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Apply X_0, followed by CNOT_02, CNOT_13 and TOF_013</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Final bit circuit:</monospace>
          </p>
          <p>
            <monospace>  0011</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; 3rd bit: 0</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; CNOT count: 2</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; Reseted circuit:</monospace>
          </p>
          <p>
            <monospace>  0000</monospace>
          </p>
          <p>
            <monospace>&gt;&gt; CNOT count: 0</monospace>
          </p>
        </sec>
      </boxed-text>
    </sec>
  </sec>
  <sec id="sec034">
    <title>5 Advanced topics</title>
    <sec id="sec035">
      <title>5.1 Aliasing</title>
      <p>Aliasing occurs whenever the same <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> matrix/vector appears on both sides of the assignment operator, and happens because of <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link>’s lazy evaluation system. Examples that exhibit aliasing:</p>
      <p>
        <monospace>mat = 2 * mat;</monospace>
      </p>
      <p specific-use="continuation">or</p>
      <p>
        <monospace>mat = mat.transpose();</monospace>
      </p>
      <p>Aliasing <underline>does not</underline> occur in statements like</p>
      <p>
        <monospace>mat = f(mat);</monospace>
      </p>
      <p specific-use="continuation">where <monospace>f()</monospace> returns by value. Aliasing produces in general unexpected results, and should be avoided at all costs.</p>
      <p>Whereas the first line produces aliasing, it is not dangerous, since the assignment is done in a one-to-one manner, i.e. each element (<italic>i</italic>, <italic>j</italic>) on the left hand side of the assignment operator is solely a function of the the <underline>same</underline> (<italic>i</italic>, <italic>j</italic>) element on the right hand side, i.e. <italic>mat</italic>(<italic>i</italic>, <italic>j</italic>) = <italic>f</italic>(<italic>mat</italic>(<italic>i</italic>, <italic>j</italic>)), ∀<italic>i</italic>, <italic>j</italic>. The problem appears whenever coefficients are being combined and overlap, such as in the second example, where <italic>mat</italic>(<italic>i</italic>, <italic>j</italic>) = <italic>mat</italic>(<italic>j</italic>, <italic>i</italic>), ∀<italic>i</italic>, <italic>j</italic>. To avoid aliasing, use the member function <monospace>eval()</monospace> to transform the right hand side object into a temporary, such as</p>
      <p>
        <monospace>mat = 2 * mat.eval();</monospace>
      </p>
      <p>In general, aliasing can not be detected at compile time, but can be detected at runtime whenever the compile flag <monospace>EIGEN_NO_DEBUG</monospace> is not set. <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> does not set this flag in debug mode. We highly recommend to first compile your program in debug mode to detect aliasing run-time assertions, as well as other possible issues that may have escaped you, such as assigning a matrix to another matrix of mismatching dimensions etc.</p>
      <p>For more details about aliasing, see the official <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> documentation at <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/dox/group__TopicAliasing.html">http://eigen.tuxfamily.org/dox/group__TopicAliasing.html</ext-link>.</p>
    </sec>
    <sec id="sec036">
      <title>5.2 Type deduction via <monospace>auto</monospace></title>
      <p>Avoid the usage of <monospace>auto</monospace> when working with <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> expressions, e.g. avoid writing code like</p>
      <p>
        <monospace>auto mat = A * B + C;</monospace>
      </p>
      <p specific-use="continuation">but write instead</p>
      <p>
        <monospace>cmat mat = A * B + C;</monospace>
      </p>
      <p specific-use="continuation">or</p>
      <p>
        <monospace>auto mat = (A * B + C).eval();</monospace>
      </p>
      <p specific-use="continuation">to force evaluation, as otherwise you may get unexpected results. The “problem” lies in the <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> lazy evaluation system and reference binding, see e.g. <ext-link ext-link-type="uri" xlink:href="http://stackoverflow.com/q/26705446/3093378">http://stackoverflow.com/q/26705446/3093378</ext-link> for more details. In short, the reference to the internal data represented by the expression <monospace>A * B + C</monospace> is dangling at the end of the <monospace>auto mat = A * B + C;</monospace> statement.</p>
    </sec>
    <sec id="sec037">
      <title>5.3 Optimizations</title>
      <p>Whenever testing your application, we recommend compiling in debug mode, as <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> run-time assertions can provide extremely helpful feedback on potential issues. Whenever the code is production-ready, you should <underline>always</underline> compile with optimization flags turned on, such as <monospace>-O3</monospace> (for <ext-link ext-link-type="uri" xlink:href="https://gcc.gnu.org/">g++</ext-link>) and <monospace>-DEIGEN_NO_DEBUG</monospace>. You should also turn on the <ext-link ext-link-type="uri" xlink:href="http://openmp.org/">OpenMP</ext-link> (if available) multi-processing flag (<monospace>-fopenmp</monospace> for <ext-link ext-link-type="uri" xlink:href="https://gcc.gnu.org/">g++</ext-link>), as it enables multi-core/multi-processing with shared memory. <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> uses multi-processing when available, e.g. in matrix multiplication. <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> also uses multi-processing in computationally-intensive functions.</p>
      <p>Since most <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> functions return by value, in assignments of the form</p>
      <p>
        <monospace>mat = f(another_mat);</monospace>
      </p>
      <p specific-use="continuation">there is an additional copy assignment operator when assigning the temporary returned by <monospace>f()</monospace> back to <monospace>mat</monospace>. As far as we are aware, this extra copy operation is not elided. Unfortunately, <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> does not yet support move semantics, which would have got rid of this additional assignment via the corresponding move assignment operator. If in the future <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> will support move semantics, the additional assignment operator will be “free”, and you won’t have to modify any existing code to enable the optimization; the <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> move assignment operator should take care of it for you.</p>
      <p>Note that in a line of the form</p>
      <p>
        <monospace>cmat mat = f(another_mat);</monospace>
      </p>
      <p specific-use="continuation">most compilers perform return value optimization (RVO), i.e. the temporary on the right hand side is constructed directly inside the object <monospace>mat</monospace>, the copy constructor being elided.</p>
    </sec>
    <sec id="sec038">
      <title>5.4 Extending Quantum++</title>
      <p>Most <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> operate on <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> matrices/vectors, and return either a matrix or a scalar. In principle, you may be tempted to write a new function such as</p>
      <p>
        <monospace>cmat f(const cmat&amp; A){…}</monospace>
      </p>
      <p>The problem with the approach above is that <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> uses <underline>expression templates</underline> as the type of each expression, i.e. different expressions have in general different types, see the official <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> documentation at <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/dox/TopicFunctionTakingEigenTypes.html">http://eigen.tuxfamily.org/dox/TopicFunctionTakingEigenTypes.html</ext-link> for more details. The correct way to write a generic function that is guaranteed to work with any matrix expression is to make the function template and declare the input parameter as <monospace>Eigen::MatrixBase&lt;Derived&gt;</monospace>, where <monospace>Derived</monospace> is the template parameter. For example, the <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link>
<monospace>transpose()</monospace> function is defined as</p>
      <boxed-text id="pone.0208073.box019" position="float" orientation="portrait">
        <p>
          <monospace>1 template&lt;typename Derived&gt;</monospace>
        </p>
        <p>
          <monospace>2 dyn_mat&lt;typename Derived::Scalar&gt;</monospace>
        </p>
        <p>
          <monospace>3 transpose(const Eigen::MatrixBase&lt;Derived&gt;&amp; A){</monospace>
        </p>
        <p>
          <monospace>4  const dyn_mat&lt;typename Derived::Scalar&gt;&amp; rA = A.derived();</monospace>
        </p>
        <p>
          <monospace>5</monospace>
        </p>
        <p>
          <monospace>6  // check zero-size</monospace>
        </p>
        <p>
          <monospace>7  if (!internal::check_nonzero_size(rA))</monospace>
        </p>
        <p>
          <monospace>8   throw Exception(“qpp::transpose()”, Exception::Type::ZERO_SIZE);</monospace>
        </p>
        <p>
          <monospace>9</monospace>
        </p>
        <p>
          <monospace>10  return rA.transpose();</monospace>
        </p>
        <p>
          <monospace>11 }</monospace>
        </p>
      </boxed-text>
      <p>It takes an <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> matrix expression, line 3, and returns a dynamic matrix over the scalar field of the expression, line 2. In line 4 we implicitly convert the input expression <monospace>A</monospace> to a dynamic matrix <monospace>rA</monospace> over the same scalar field as the expression, via binding to a <monospace>const</monospace> reference, therefore paying no copying cost. We then use <monospace>rA</monospace> instead of the original expression <monospace>A</monospace> in the rest of the function. Note that most of the time it is adequate to use the original expression, however there are some cases where you may get a compile time error if the expression is not explicitly cast to a matrix. For consistency, we use this reference binding trick in the code of all <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> functions.</p>
    </sec>
  </sec>
  <sec id="sec039">
    <title>6 Benchmarks</title>
    <p>In this section we compare the performance of <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> with two other widely used quantum software platforms that allow quantum simulation, namely IBM’s <ext-link ext-link-type="uri" xlink:href="https://qiskit.org">Qiskit</ext-link> and the open source <ext-link ext-link-type="uri" xlink:href="http://qutip.org">QuTiP</ext-link>. More specifically, we benchmark the time required to perform two widely used quantum operations, namely the partial trace and the quantum Fourier transform, respectively, as a function of the number of input qubits and number of CPU cores. Note that both vanilla versions of <ext-link ext-link-type="uri" xlink:href="https://qiskit.org">Qiskit</ext-link> and <ext-link ext-link-type="uri" xlink:href="http://qutip.org">QuTiP</ext-link> do not seem to be using parallelization, so for a fair comparison the reader should only compare with the single-threaded curve(s) generated for <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link>. All benchmark plots use logarithmic (base 2) scales for the time scale (expressed in seconds). We used an 8 core x86-64 Linux machine running Debian 9.5, with an Intel(R) Core(TM) i7-7700K CPU running at 4.20GHz and 16Gb of RAM. <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> was compiled with <ext-link ext-link-type="uri" xlink:href="https://gcc.gnu.org/">g++</ext-link> 6.3, whereas the <ext-link ext-link-type="uri" xlink:href="https://qiskit.org">Qiskit</ext-link> and <ext-link ext-link-type="uri" xlink:href="http://qutip.org">QuTiP</ext-link> simulators were run using <ext-link ext-link-type="uri" xlink:href="https://www.python.org">Python</ext-link> 3.5. All benchmark code from this section is available online at <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp/tree/master/stress_tests">https://github.com/vsoftco/qpp/tree/master/stress_tests</ext-link>.</p>
    <sec id="sec040">
      <title>6.1 Partial trace</title>
      <p>In this subsection we benchmark how long it takes to perform a partial trace over the first qubit of an <italic>n</italic>-qubit matrix. Note that <ext-link ext-link-type="uri" xlink:href="https://qiskit.org">Qiskit</ext-link> does not provide a native partial trace function, so we only benchmark against <ext-link ext-link-type="uri" xlink:href="http://qutip.org">QuTiP</ext-link>. The results are displayed in <xref ref-type="fig" rid="pone.0208073.g001">Fig 1</xref>.</p>
      <fig id="pone.0208073.g001" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0208073.g001</object-id>
        <label>Fig 1</label>
        <caption>
          <title>Partial trace on <italic>n</italic> qubits.</title>
          <p>Some minor irregularities (spikes) in the plot are most likely due to the fact that the machine we ran the experiments on is not real-time, and the operating system may have performed job scheduling during that time. Note that the single core version of <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> over-performs <ext-link ext-link-type="uri" xlink:href="http://qutip.org">QuTiP</ext-link>. Remark also that <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> scales well with the number of CPU cores.</p>
        </caption>
        <graphic xlink:href="pone.0208073.g001"/>
      </fig>
    </sec>
    <sec id="sec041">
      <title>6.2 Quantum Fourier transform</title>
      <p>In this subsection we benchmark how long it takes to perform a quantum Fourier transform over the first qubit of an <italic>n</italic>-qubit matrix. The results are displayed in <xref ref-type="fig" rid="pone.0208073.g002">Fig 2</xref>.</p>
      <fig id="pone.0208073.g002" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0208073.g002</object-id>
        <label>Fig 2</label>
        <caption>
          <title>Quantum Fourier transform on <italic>n</italic> qubits.</title>
          <p>Some minor irregularities (spikes) in the plot are most likely due to the fact that the machine we ran the experiments is not real-time, and the operating system may have performed job scheduling during that time. Note that the single core version of <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> over-performs <ext-link ext-link-type="uri" xlink:href="https://qiskit.org">Qiskit</ext-link> by a large margin. <ext-link ext-link-type="uri" xlink:href="http://qutip.org">QuTiP</ext-link> seems to be faster in this case than <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link>. The most likely explanation is that the former uses sparse matrices during computation, whereas the latter does not. However, <ext-link ext-link-type="uri" xlink:href="http://qutip.org">QuTiP</ext-link> runs out of memory on our machine after 21 qubits, whereas <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> can simulate up to 28 qubits without problems (of course trading the space for longer running time). Remark also that <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> scales well with the number of CPU cores.</p>
        </caption>
        <graphic xlink:href="pone.0208073.g002"/>
      </fig>
    </sec>
    <sec id="sec042">
      <title>6.3 Discussion</title>
      <p>The fundamental data types in <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> are non-sparse vectors and matrices. Most computationally-intensive activity performed by the library involves operations on such vectors and matrices. Whenever possible, the task is delegated to the highly-optimized <ext-link ext-link-type="uri" xlink:href="http://eigen.tuxfamily.org/">Eigen 3</ext-link> linear algebra library, e.g. when multiplying 2 matrices together. In addition, most loops in the code are parallelized via the <ext-link ext-link-type="uri" xlink:href="http://openmp.org/">OpenMP</ext-link> multi-processing library, if the corresponding flag is present at compile time. Those optimizations make <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> highly efficient on multiple cores, as the benchmarks in Figs <xref ref-type="fig" rid="pone.0208073.g001">1</xref> and <xref ref-type="fig" rid="pone.0208073.g002">2</xref> show.</p>
      <p>As one of our referees pointed out, <ext-link ext-link-type="uri" xlink:href="http://qutip.org">QuTiP</ext-link> performs relatively poorly for small number of qubits, most likely because of overhead introduced by the Python interpreter. What is surprising is that both <ext-link ext-link-type="uri" xlink:href="http://qutip.org">QuTiP</ext-link> and <ext-link ext-link-type="uri" xlink:href="https://qiskit.org">Qiskit</ext-link> seem to be single-cored, even though, at least for <ext-link ext-link-type="uri" xlink:href="http://qutip.org">QuTiP</ext-link>, one would expect aggressive parallelization via the <ext-link ext-link-type="uri" xlink:href="http://www.netlib.org/blas/">BLAS</ext-link> library, as mentioned by <ext-link ext-link-type="uri" xlink:href="http://qutip.org/docs/3.0.1/installation.html#optimized-blas-librariesl">http://qutip.org/docs/3.0.1/installation.html#optimized-blas-librariesl</ext-link>. Most likely the vanilla version of <ext-link ext-link-type="uri" xlink:href="http://qutip.org">QuTiP</ext-link> comes with a <ext-link ext-link-type="uri" xlink:href="http://www.numpy.org">NumPy</ext-link> library which is not built against <ext-link ext-link-type="uri" xlink:href="http://www.netlib.org/blas/">BLAS</ext-link>.</p>
    </sec>
  </sec>
  <sec id="sec043">
    <title>7 Long term maintenance</title>
    <p>We plan to keep all future releases of <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> open source. We will continue to host the project on <ext-link ext-link-type="uri" xlink:href="https://github.com">GitHub</ext-link> or on an equivalent versioning control system. We will publish new stable releases of the software whenever enough improvements or features have been accumulated since the previous stable release. We plan to keep <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> active and we welcome everyone interested to collaborate.</p>
  </sec>
  <sec id="sec044">
    <title>8 Conclusions and future directions</title>
    <p>As you may have already seen, <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> consists mainly of a collection of functions and few classes. There is no complicated class hierarchy, and you can regard the <ext-link ext-link-type="uri" xlink:href="https://github.com/vsoftco/qpp">Quantum++</ext-link> API as a low/medium-level API. You may extend it to incorporate graphical input, e.g. use a graphical library such as <ext-link ext-link-type="uri" xlink:href="http://qt-project.org/">Qt</ext-link>, or build a more sophisticated library on top of it. We recommend to read the source code and make yourself familiar with the library before deciding to extend it. You should also check the complete reference manual <monospace>./doc/refman.pdf</monospace> for an extensive documentation of all functions and classes.</p>
    <p>An interesting future direction is to allow GPU parallelization, however at the time of the writing this was beyond the scope of this project.</p>
  </sec>
</body>
<back>
  <ack>
    <p>I acknowledge financial support from Industry Canada and from the Natural Sciences and Engineering Research Council of Canada (NSERC). I thank Sara Zafar Jafarzadeh and Kassem Kalach for carefully reading this manuscript and providing very useful suggestions.</p>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="pone.0208073.ref001">
      <label>1</label>
      <mixed-citation publication-type="other">List of QC simulators;. <ext-link ext-link-type="uri" xlink:href="http://www.quantiki.org/wiki/List_of_QC_simulators">http://www.quantiki.org/wiki/List_of_QC_simulators</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0208073.ref002">
      <label>2</label>
      <mixed-citation publication-type="other">Roetteler M, Naehrig M, Svore KM, Lauter K. Quantum resource estimates for computing elliptic curves discrete logarithms; arXiv:1706.06752 [quant-ph], 2017.</mixed-citation>
    </ref>
    <ref id="pone.0208073.ref003">
      <label>3</label>
      <mixed-citation publication-type="book"><name><surname>Nielsen</surname><given-names>MA</given-names></name>, <name><surname>Chuang</surname><given-names>IL</given-names></name>. <source>Quantum Computation and Quantum Information</source>. <edition>5th ed</edition><publisher-loc>Cambridge</publisher-loc>: <publisher-name>Cambridge University Press</publisher-name>; <year>2000</year>.</mixed-citation>
    </ref>
  </ref-list>
</back>
