<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10563143</article-id>
    <article-id pub-id-type="pmid">37713474</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad572</article-id>
    <article-id pub-id-type="publisher-id">btad572</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>FrameD: framework for DNA-based data storage design, verification, and validation</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-5200-5909</contrib-id>
        <name>
          <surname>Volkel</surname>
          <given-names>Kevin D</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/conceptualization" degree-contribution="lead">Conceptualization</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Data curation" vocab-term-identifier="https://credit.niso.org/contributor-roles/data-curation" degree-contribution="lead">Data curation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Formal analysis" vocab-term-identifier="https://credit.niso.org/contributor-roles/formal-analysis" degree-contribution="lead">Formal analysis</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Methodology" vocab-term-identifier="https://credit.niso.org/contributor-roles/methodology" degree-contribution="lead">Methodology</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Software" vocab-term-identifier="https://credit.niso.org/contributor-roles/software" degree-contribution="lead">Software</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Validation" vocab-term-identifier="https://credit.niso.org/contributor-roles/validation" degree-contribution="lead">Validation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Visualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/visualization" degree-contribution="lead">Visualization</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - original draft" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-original-draft" degree-contribution="lead">Writing - original draft</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="lead">Writing - review &amp; editing</role>
        <aff><institution>Department of Electrical and Computer Engineering, North Carolina State University</institution>, Raleigh, NC, 27606, <country country="US">United States</country></aff>
        <xref rid="btad572-cor1" ref-type="corresp"/>
        <!--kvolkel@ncsu.edu-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Lin</surname>
          <given-names>Kevin N</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="supporting">Writing - review &amp; editing</role>
        <aff><institution>Department of Chemical and Biomolecular Engineering, North Carolina State University</institution>, Raleigh, NC, 27695, <country country="US">United States</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Hook</surname>
          <given-names>Paul W</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="supporting">Writing - review &amp; editing</role>
        <aff><institution>Department of Biomedical Engineering, Johns Hopkins University</institution>, Baltimore, MD, 21218, <country country="US">United States</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-2083-6027</contrib-id>
        <name>
          <surname>Timp</surname>
          <given-names>Winston</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Funding acquisition" vocab-term-identifier="https://credit.niso.org/contributor-roles/funding-acquisition" degree-contribution="equal">Funding acquisition</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="https://credit.niso.org/contributor-roles/investigation" degree-contribution="equal">Investigation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Project administration" vocab-term-identifier="https://credit.niso.org/contributor-roles/project-administration" degree-contribution="equal">Project administration</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Supervision" vocab-term-identifier="https://credit.niso.org/contributor-roles/supervision" degree-contribution="supporting">Supervision</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="supporting">Writing - review &amp; editing</role>
        <aff><institution>Department of Biomedical Engineering, Johns Hopkins University</institution>, Baltimore, MD, 21218, <country country="US">United States</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8958-1232</contrib-id>
        <name>
          <surname>Keung</surname>
          <given-names>Albert J</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Funding acquisition" vocab-term-identifier="https://credit.niso.org/contributor-roles/funding-acquisition" degree-contribution="equal">Funding acquisition</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="https://credit.niso.org/contributor-roles/investigation" degree-contribution="equal">Investigation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Project administration" vocab-term-identifier="https://credit.niso.org/contributor-roles/project-administration" degree-contribution="equal">Project administration</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Supervision" vocab-term-identifier="https://credit.niso.org/contributor-roles/supervision" degree-contribution="supporting">Supervision</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="supporting">Writing - review &amp; editing</role>
        <aff><institution>Department of Chemical and Biomolecular Engineering, North Carolina State University</institution>, Raleigh, NC, 27695, <country country="US">United States</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8975-0294</contrib-id>
        <name>
          <surname>Tuck</surname>
          <given-names>James M</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/conceptualization" degree-contribution="lead">Conceptualization</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Funding acquisition" vocab-term-identifier="https://credit.niso.org/contributor-roles/funding-acquisition" degree-contribution="equal">Funding acquisition</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="https://credit.niso.org/contributor-roles/investigation" degree-contribution="equal">Investigation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Project administration" vocab-term-identifier="https://credit.niso.org/contributor-roles/project-administration" degree-contribution="equal">Project administration</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Resources" vocab-term-identifier="https://credit.niso.org/contributor-roles/resources" degree-contribution="lead">Resources</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Software" vocab-term-identifier="https://credit.niso.org/contributor-roles/software" degree-contribution="supporting">Software</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Supervision" vocab-term-identifier="https://credit.niso.org/contributor-roles/supervision" degree-contribution="lead">Supervision</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - original draft" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-original-draft" degree-contribution="lead">Writing - original draft</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="lead">Writing - review &amp; editing</role>
        <aff><institution>Department of Electrical and Computer Engineering, North Carolina State University</institution>, Raleigh, NC, 27606, <country country="US">United States</country></aff>
        <xref rid="btad572-cor1" ref-type="corresp"/>
        <!--jtuck@ncsu.edu-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Kelso</surname>
          <given-names>Janet</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad572-cor1">Corresponding authors. Department of Electrical and Computer Engineering, North Carolina State University, 890 Oval Drive Raleigh, NC, 27606, United States. E-mails: <email>kvolkel@ncsu.edu</email> (K.D.V.) and <email>jtuck@ncsu.edu</email> (J.M.T.)</corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>10</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-09-15">
      <day>15</day>
      <month>9</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>15</day>
      <month>9</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>10</issue>
    <elocation-id>btad572</elocation-id>
    <history>
      <date date-type="received">
        <day>28</day>
        <month>3</month>
        <year>2023</year>
      </date>
      <date date-type="rev-recd">
        <day>27</day>
        <month>7</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>04</day>
        <month>9</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>13</day>
        <month>9</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>10</day>
        <month>10</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad572.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>DNA-based data storage is a quickly growing field that hopes to harness the massive theoretical information density of DNA molecules to produce a competitive next-generation storage medium suitable for archival data. In recent years, many DNA-based storage system designs have been proposed. Given that no common infrastructure exists for simulating these storage systems, comparing many different designs along with many different error models is increasingly difficult. To address this challenge, we introduce FrameD, a simulation infrastructure for DNA storage systems that leverages the underlying modularity of DNA storage system designs to provide a framework to express different designs while being able to reuse common components.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We demonstrate the utility of FrameD and the need for a common simulation platform using a case study. Our case study compares designs that utilize strand copies differently, some that align strand copies using multiple sequence alignment algorithms and others that do not. We found that the choice to include multiple sequence alignment in the pipeline is dependent on the error rate and the type of errors being injected and is not always beneficial. In addition to supporting a wide range of designs, FrameD provides the user with transparent parallelism to deal with a large number of reads from sequencing and the need for many fault injection iterations. We believe that FrameD fills a void in the tools publicly available to the DNA storage community by providing a modular and extensible framework with support for massive parallelism. As a result, it will help accelerate the design process of future DNA-based storage systems.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>The source code for FrameD along with the data generated during the demonstration of FrameD is available in a public Github repository at <ext-link xlink:href="https://github.com/dna-storage/framed" ext-link-type="uri">https://github.com/dna-storage/framed</ext-link>, (<ext-link xlink:href="https://dx.doi.org/10.5281/zenodo.7757762" ext-link-type="uri">https://dx.doi.org/10.5281/zenodo.7757762</ext-link>).</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Science Foundation</institution>
            <institution-id institution-id-type="DOI">10.13039/100000001</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>1901324</award-id>
        <award-id>2027655</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>The world is generating data faster and in larger quantities than ever before, raising concerns that traditional storage technologies will not scale to keep up with demand. In the search for new technologies, DNA has gained broad interest due to its superior density and longevity compared to magnetic tape and hard disk drives. Since the early work of <xref rid="btad572-B7" ref-type="bibr">Church <italic toggle="yes">et al.</italic> (2012)</xref> and <xref rid="btad572-B10" ref-type="bibr">Goldman <italic toggle="yes">et al.</italic> (2013)</xref> demonstrating the ability to store information in DNA strands using modern DNA technology, there have been a range of studies answering important questions such as data addressability (<xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B18" ref-type="bibr">2020, Tomek <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B23" ref-type="bibr">2021, Lin <italic toggle="yes">et al.</italic> 2020</xref>), synthesis efficiency (<xref rid="btad572-B1" ref-type="bibr">Anavy <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B6" ref-type="bibr">Choi <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>), DNA reusability (<xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B14" ref-type="bibr">Lin <italic toggle="yes">et al.</italic> 2020</xref>), error rates associated with a variety of techniques (<xref rid="btad572-B11" ref-type="bibr">Grass <italic toggle="yes">et al.</italic> 2015</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B16" ref-type="bibr">Matange <italic toggle="yes">et al.</italic> 2021</xref>), and the density that can be achieved in DNA molecules (<xref rid="btad572-B10" ref-type="bibr">Goldman <italic toggle="yes">et al.</italic> 2013</xref>, <xref rid="btad572-B9" ref-type="bibr">Erlich and Zielinski 2017</xref>, <xref rid="btad572-B1" ref-type="bibr">Anavy <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B6" ref-type="bibr">Choi <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>). This vast knowledge base of DNA-based data storage comes with an equally expansive space of possible implementation approaches for which little if any consensus has been reached. Compounding the problem of choosing any one approach is the fact that there is a lack of common infrastructure that enables the comparison of these designs in a fair and reproducible manner.</p>
    <p>To address the growing need for tools to analyze and compare DNA storage systems, we present FrameD, a software framework for designing, verifying, and validating DNA storage system designs. FrameD is not a library of every conceivable error correction algorithm, instead, it provides a fault-injection-based test bed in which DNA storage systems can be evaluated. Constructing FrameD requires several considerations. One being FrameD’s flexibility in terms of what DNA storage systems can be represented. To address this issue, we use current literature to inform the construction of a model that can be used as a basis in which a range of DNA storage systems can be expressed. With this model, we are able to implement an execution back-end that executes a set of encoding steps that adhere to the model’s interfaces. Thus, for an encoding to be used in FrameD, a user need only follow the interface specification. This execution model back-end also provides transparent support for necessary bookkeeping steps like DNA strand indexing and dropout inference, allowing the user to focus on the details of their algorithms.</p>
    <p>Another issue that needs to be considered when simulating DNA storage systems is computational scale issues that arise from several sources. One source is the size of the possible parameter space of interest with regards to an encoding/decoding algorithm, as exploring combinations of parameters can easily lead to exponential growth in the number of experiments. Another source of computational scale arises from the necessity to perform fault injection experiments 1000’s of times to achieve narrow confidence intervals on key outcomes such as strand and file decode rates. Compounding each source of computational overhead is the scale of sequencing data that needs to be processed. To support scalability, FrameD utilizes batch jobs to parallelize individual configuration simulations and Message Passing Interface (MPI) to parallelize units of work within those batch jobs like strand decoding and fault injection iterations. FrameD implements the parallelization support transparently such that users do not need to manage parallelization communication. Instead, the user just specifies their configurations and the computational resources to allocate to each.</p>
    <p>We demonstrate the utility of FrameD by performing a comparison between three designs across two error models representing different sequencing technology. We evaluate 240 total configurations, generating a total of 654 million fault-injected DNA strands, and analyze the read and write density trade-off between the three designs. Our results show that the optimal design approach depends on the designer’s read and write cost targets and the target sequencing technology, and bolsters our claim that a common simulation infrastructure is needed.</p>
  </sec>
  <sec>
    <title>2 The case for DNA storage simulation infrastructure</title>
    <p>Before discussing details of FrameD, we present a study of current literature to further motivate the need for a DNA simulation infrastructure and to understand the basic components that such an infrastructure will need to support. For our review, we choose 13 previous works that implement end-to-end DNA storage systems. We selected these works because they are representative of different approaches that have been taken since the revival of DNA data storage started by Goldman <italic toggle="yes">et al.</italic>’s work. Thus, we should be able to make conclusions about consistent approaches taken in DNA storage design, while also being able to account for the inclusion of novel techniques from each individual work. Detailed organization of these works is presented in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>.</p>
    <p>We find that transformations applied to information can be organized hierarchically in two levels. At the first level, we identify two broad categories we refer to as “<bold>Single Strand”</bold> and “<bold>Multi-Strand”</bold> transformations. Single Strand transformations focus on processing information stored in a single molecule of DNA, while the Multi-Strand processes relate to processing information stored within a group of molecules.</p>
    <p>Under the Single Strand category, we found three typical transformation steps: “<bold>Binary Transformation”</bold>, “<bold>Transcoding”</bold>, and “<bold>Functional Site Encoding”</bold>. Each of these sub-categories modify the data present on a single DNA molecule in their own way. A Binary Transformation modifies the raw digital information before it is represented as DNA molecule. Such modifications typically included parity checks (<xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>), Reed–Solomon codes (<xref rid="btad572-B11" ref-type="bibr">Grass <italic toggle="yes">et al.</italic> 2015</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>), and base conversions from the typical Base-2 binary representation of digital information to a numerical base that may be more convenient for a certain Reed-Solomon field (<xref rid="btad572-B11" ref-type="bibr">Grass <italic toggle="yes">et al.</italic> 2015</xref>, <xref rid="btad572-B1" ref-type="bibr">Anavy <italic toggle="yes">et al.</italic> 2019</xref>). The Transcoding category consists of processes that represent the digital source information in terms of a DNA molecule. While transcoding can be as simple as a base-conversion to base-4 (<xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>), approaches typically consider constraints such as GC balance (<xref rid="btad572-B24" ref-type="bibr">Yazdi <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad572-B19" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>) and homopolymers (<xref rid="btad572-B10" ref-type="bibr">Goldman <italic toggle="yes">et al.</italic> 2013</xref>, <xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>), yielding a range of options with different error correction and density properties. The final Single Strand pass, Functional Site Encoding, is not inherently dependent on the raw information stored but instead includes DNA substrings in the stored molecules to facilitate functionality. Functionality encoding includes adding primers for polymerase chain reaction (PCR) random access (<xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>), T7 promotor sites for RNA transcription (<xref rid="btad572-B14" ref-type="bibr">Lin <italic toggle="yes">et al.</italic> 2020</xref>), and restriction sites for DNA fragmentation (<xref rid="btad572-B23" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2021</xref>).</p>
    <p>Under the Multi-Strand category, we determined three distinct processing steps: “<bold>Outer Code”</bold>, “<bold>Consolidation”</bold>, and “<bold>Reconstruction”</bold>. The Outer Code step is similar to the Binary Transformation step of the single strand category, except error correction codes like Reed–Solomon are applied using the data of a group of strands so that errors can be corrected using information dispersed across DNA molecules (<xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B19" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>, <xref rid="btad572-B23" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2021</xref>). This error correction technique is crucial for dealing with the occurrence of missing DNA molecules, a common error mode of DNA storage systems (<xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B19" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>). Another issue that a DNA storage system design must address is the reconstruction of the order of information. Representing arbitrarily large sets of information requires storing subsets of information on individual DNA molecules because synthetic DNA of arbitrary length is not feasible to synthesize. Provided mixtures of DNA molecules are not guaranteed to be sequenced in any particular order, a Reconstruction strategy is needed to map a DNA molecule to its place in the complete dataset. Because of its optimality regarding density (<xref rid="btad572-B13" ref-type="bibr">Heckel <italic toggle="yes">et al.</italic> 2017</xref>), an “<bold>indexing”</bold> strategy that stores an ordering integer in each strand is a common approach (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>). Lastly, because DNA storage systems typically generate multiple copies of each transcoded DNA molecule by way of synthesis, sequencing, or amplification (<xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B24" ref-type="bibr">Yazdi <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>), a processing step which we call Consolidation is required to generate one final representative of the information of a stored DNA molecule. This can be as simple as detecting and removing bad strands using error correction until finding a valid strand (<xref rid="btad572-B10" ref-type="bibr">Goldman <italic toggle="yes">et al.</italic> 2013</xref>, <xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B19" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>), or bioinformatics tools such as multiple sequence alignment (MSA) algorithms can be employed to determine a consensus sequence (<xref rid="btad572-B24" ref-type="bibr">Yazdi <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>).</p>
    <p>From this discussion, we can immediately see that the transformation of information within a DNA storage system can be described by a small set of general categories. This indicates that an infrastructure which provides support for routing this information between these categories can be effective in representing many unique DNA storage systems.</p>
    <p>Given this observation, we consider how prior works in DNA storage simulation support general encoding and simulation environments. DNA-Storalator is a DNA storage system simulator that focuses on evaluating clustering and reconstruction algorithms that work to construct a representative DNA strand from a cluster of noisy versions. However, DNA-Storalator does not offer support for the evaluation of Outer, Binary Transformation, or Transcoding codecs (<xref rid="btad572-B5" ref-type="bibr">Chaykin <italic toggle="yes">et al.</italic> 2022</xref>). Furthermore, the only error models supported are those which are generated by wet-lab experiments (<xref rid="btad572-B21" ref-type="bibr">Sabary <italic toggle="yes">et al.</italic> 2021</xref>). While these may be accurate for a given DNA storage system implementation, allowing for user-defined error models allows for testing codecs over a wider set of cases. DNAssim offers flexible fault and coverage models, along with outer code evaluation. However, DNAssim does not consider the complex space of inner code design and chooses to only use binary to base-4 conversion as its transcoding method (<xref rid="btad572-B15" ref-type="bibr">Marelli <italic toggle="yes">et al.</italic> 2023</xref>). Another simulator is DeSP; however, it is only a tool that provides error injections and strand distribution changes, and so it is not a framework for evaluating different encoding designs (<xref rid="btad572-B25" ref-type="bibr">Yuan <italic toggle="yes">et al.</italic> 2022</xref>). In the following sections, we discuss how FrameD provides a framework in which a rich space of encodings can be evaluated using flexible error models in a scalable environment.</p>
  </sec>
  <sec>
    <title>3 FrameD</title>
    <p>We leverage categorical overlap of designs by understanding that there is a logical ordering in which the information transformations can be applied. This ordering is illustrated in <xref rid="btad572-F1" ref-type="fig">Fig. 1</xref>, where information flows from left to right. First, information in a file is broken into contiguous pieces called “<bold>packets”</bold>. Packets serve as the scope for the outer encoding, allowing for designers to choose a granularity for the outer error correction algorithm. Before the outer code is applied, the packet is broken down into “<bold>base-sequences”</bold>, contiguous sections of information that will be stored on each DNA molecule. A packet’s base-sequences are then processed by the outer code, which generates indices automatically for each base-sequence while also adding additional error correction base-sequences. FrameD defaults to basic incremental integers for indexing, but provides the designer the interface to implement special indexes like the Luby Seed for Fountain codes. Each indexed base-sequence is passed through the “<bold>inner-encoder”</bold>, a series of steps consisting of the Single Strand operations.</p>
    <fig position="float" id="btad572-F1">
      <label>Figure 1.</label>
      <caption>
        <p>Model used by FrameD to represent encoding for DNA storage systems. Included in this figure is an example of the state of information throughout the pipeline, where initially data is in its original byte representation, then converted to base-3 and subsequently DNA, and finally stored with prepend/appended DNA strings typically done for PCR primer functionality.</p>
      </caption>
      <graphic xlink:href="btad572f1" position="float"/>
    </fig>
    <p>The decode phase is mostly identical to encoding, except that the transformations made by each pass are reversed. However, decoding must have a mechanism to deal with multiple copies per encoded strand. We found two approaches that can be taken. One is to first cluster the DNA strands input to the decoder based on similarity scores like edit distance or using a MinHash-based approaches (<xref rid="btad572-B20" ref-type="bibr">Rashtchian <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>). Then MSA algorithms, such as Muscle, can be used to aggregate information across strands and help resolve errors through consensus voting (<xref rid="btad572-B8" ref-type="bibr">Edgar 2004</xref>, <xref rid="btad572-B24" ref-type="bibr">Yazdi <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>). To account for these approaches, we provide users the ability to add MSA and clustering steps to the pipeline before the inner encoding is reversed. This process is outlined in the <xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref>. Another approach is to consolidate the strands after completing the inner code, throwing out strands that may violate error checks, and coming to a consensus on the digital representation of information. FrameD supports the use of either approach, or even both.</p>
    <p>The pipelined approach of FrameD provides DNA storage system designers several benefits. By implementing the routing of information between components, the designer can focus on their algorithms as long as it adheres to the pipeline’s information transformation interface. Further, by breaking larger steps, e.g. inner code, down into smaller sub-components, a new unique inner code can be constructed by modifying just a single component without needing to re-implement the other algorithms that constitute the inner code. For example, one could change their Binary Transformation pass while keeping the same implementations of the Transcoding and Functional Site Encoding passes. As long as the new component adheres to its prescribed interface given the type of transformation it performs, no other work is required outside of implementing the new algorithm.</p>
    <p><xref rid="btad572-F1" ref-type="fig">Figure 1</xref> shows only three components within the inner encoding and one outer code component; however, we point out that both can consist of an arbitrary number. That is, Outer Codes, Binary Transformations, and Functional Site Encoding can be cascaded an arbitrary amount. For example, one may have two binary transformations, one to modify the numerical base representation of data and another one to convert to a Reed–Solomon code. We leave out Transcoding from this list, since transcoding binary information to DNA can only occur once. Details on how indexing is supported in cascaded Outer Codes is discussed in the <xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref>. FrameD also leverages transformation type interfaces to provide validation checks for the designer to ensure that there is a logical arrangement of components.</p>
    <sec>
      <title>3.1 Fault injection workflow</title>
      <p>FrameD includes a simulation tool based on a fault injection methodology for evaluating DNA storage system designs. Fault injection simulation provides several benefits over the analytical model. Fault injection experiments provide the ability to quickly estimate properties of specific steps of the encoding/decoding processes. For example, fault injection experiments can determine a rate at which strands can be successfully decoded using a specified error model. This information can be used to verify analytical results or to derive parameters for a full-scale DNA storage system. Fault injection models are also more flexible, where changing an encoding or error model can make deriving a new analytical model difficult. Lastly, a fault injection framework exercises actual algorithm implementations against strands with errors in them, allowing for benchmarking and debugging that an analytical model cannot provide.</p>
      <p><xref rid="btad572-F2" ref-type="fig">Figure 2</xref> overviews the workflow of using FrameD for fault injection. First, a user develops a JSON configuration file which includes a path to the binary data to be converted to DNA, along with details of three general categories of parameters that control simulation behavior: (i) encoder/decoder parameters that configure the behavior of encoding/decoding components, (ii) fault distribution parameters that configure the simulated channel’s error model, and (iii) copy distribution parameters that configure the model used to represent strand copies that arise in the storage system. Within this configuration file, users can specify a parameter sweep to explore combinations of parameters such as error rate and inner code rates, and the fault injection tool will generate individual simulation jobs (batch jobs) for each unique parameter combination.</p>
      <fig position="float" id="btad572-F2">
        <label>Figure 2.</label>
        <caption>
          <p>End-to-end workflow of performing fault injection simulation using FrameD.</p>
        </caption>
        <graphic xlink:href="btad572f2" position="float"/>
      </fig>
      <p>During the evaluation of a simulation job, the input binary data is passed through the encoder to generate a library of synthetic DNA strands that subsequently sample the copy and error model distributions. The noisy set of strands passes through decoding, during which an attempt to reconstruct the original file is made, and information on errors and their locations are captured.</p>
      <p>The output of fault injection consists of a set of files placed in a unique directory for each unique parameter combination. This set of files specifies the parameters that were used for the experiment. This allows us to keep records of all parameters used for all experiments easily. In addition to these files, a statistics file is output by the simulation, aggregating counters that are used to track events during simulation such as decode failures, location of byte-errors within strands, location of base errors within strands, etc. FrameD allows statistics to be largely user-defined so that appropriate statistics can be chosen for a given experiment. (We do not list every statistic collected, since they are easy to change.) In the following section, we outline how this is done in FrameD. Our documentation provides a tutorial on fault injection using FrameD.</p>
    </sec>
    <sec>
      <title>3.2 Generating statistics</title>
      <p>The fault injection tool of FrameD captures general system-level information out of the box such as file decode rate and total byte-errors in the final file. Designers can also further leverage FrameD to generate custom statistics of a strand’s information at various points of the pipeline. The mechanism to achieve this is called a <bold>probe</bold>. A probe is a special pipeline component that does not modify information, but can interrogate the state of strands as they are encoded/decoded. To calculate error rates, a probe can capture the state of the information as it is encoded. This snapshot of the information can then be used as a comparison point during decoding to calculate statistics. Such statistics can be versatile and cover a wide range of error types including errors within the bases of a strand and the errors within bytes after decoding strands. A detailed example is provided in the <xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref>.</p>
    </sec>
    <sec>
      <title>3.3 Analyzing NGS data</title>
      <p>While this paper focuses on the <italic toggle="yes">in silico</italic> fault simulation tool of FrameD, we recognize that users of this framework would likely want to leverage the probes they created for fault injection simulation to analyze sequencing data from real experiments. In addition to the fault injection tool, we provide a tool that evaluates FrameD pipelines against next-generation sequencing (NGS) data. This additional tool allows developers the opportunity to determine which encoded DNA strand that a sequencing read originated from. This is something that is not known <italic toggle="yes">a priori</italic> and has to be computed since determining errors and their positions requires baseline information to compare against. Computing this mapping can be as simple as pairing a decoded index with the sequencing read identifier, or by computing the best alignments to a known set of strands (<xref rid="btad572-B21" ref-type="bibr">Sabary <italic toggle="yes">et al.</italic> 2021</xref>). Our codebase includes a mapping probe to perform this analysis along with detailed documentation on how to leverage it within FrameD for NGS data analysis.</p>
    </sec>
    <sec>
      <title>3.4 Handling computational scale</title>
      <p>When performing fault injection simulations, and decoding strands from real sequencing data, computational scalability quickly becomes an issue. FrameD enables scalability by identifying parallel units of work within the general flow of information in the framework. This allows any design to leverage paralellization transparently since FrameD can handle all communication of data. FrameD identifies parallelizaiton at three levels shown in <xref rid="btad572-F3" ref-type="fig">Fig. 3</xref>.</p>
      <fig position="float" id="btad572-F3">
        <label>Figure 3.</label>
        <caption>
          <p>Hierarchical parallelism leveraged by FrameD. Items grouped in the same level, e.g. MSA and inner decode, represent work that can be done in parallel using the same MPI ranks. <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>F</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>S</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>P</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> represent the total number of fault injection iterations, clusters, strands, and packets, respectively.</p>
        </caption>
        <graphic xlink:href="btad572f3" position="float"/>
      </fig>
      <p>In the first level, FrameD creates and submits individual batch jobs that can be processed by high-performance computing (HPC) workload managers like the <bold>“Slurm Workload Manager”</bold> or <bold>“IBM Spectrum LSF”</bold>. Within each batch job, FrameD can be configured to allocate compute resources in the form of MPI ranks to both fault injection iterations (second level) and work done during fault injection simulations like decoding individual strands, packet outer codes, and sequence alignment (third level). Allocation is up to the user. A user may allocate more MPI ranks to fault injection iterations if individual decode tasks are small, or the user may allocate most ranks to decoding to deal with sequencing data or to benchmark their pipeline. We utilize MPI at these levels due to its ease of communication and scalability. By targeting these clear large-grain units of work we can reach large numbers of computational cores while also keeping those resources busy.</p>
      <p>We recognize that there may be other user-defined opportunities for parallelization. For example, consolidating DNA strands using a clustering approach may benefit from MPI-based parallelization (<xref rid="btad572-B20" ref-type="bibr">Rashtchian <italic toggle="yes">et al.</italic> 2017</xref>). Because communication patterns are specific to such algorithms, we provide the user with the MPI communicator that is allocated to the given fault injection iteration. This allows the user to implement their own custom parallelization if so desired. See <xref rid="sup1" ref-type="supplementary-material">Supplementary Figure S4</xref> for FrameD’s communication patterns.</p>
      <p>While FrameD aids in scaling the number of strands and fault injection experiments performed, we point out that the rate in which information will be decoded/encoded will be greatly influenced by the chosen algorithms and their implementation details. A major implementation detail impacting performance is the chosen language, and while FrameD is fully implemented in Python, the implementation of a component can be in any language as long as it has an interface to Python. We find this to be an acceptable strategy since the infrastructure of FrameD is only focused on moving information between components that perform a bulk of the computation, which can be handled by a higher performing language.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Choosing designs with FrameD</title>
    <p>To demonstrate FrameD, we perform an analysis that serves as an example of how a DNA storage system designer may use the framework to determine the most cost-effective approach from a set of choices. In our example, we consider three different pipelines and two different error channel models, which are detailed in <xref rid="btad572-T1" ref-type="table">Table 1</xref>. Our encoder configurations are based on approaches taken in existing literature, and each leverages sequencing depth and resolves errors within a strand differently. The <bold>RS</bold> pipeline is representative of approaches that utilize conventional Reed–Solomon inner-error correction that deal with errors within strands post clustering and MSA (<xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>). Pipeline <bold>“HEDGES”</bold> contrasts with “<bold>RS”</bold> by directly resolving base errors within a strand with a convolutional code (HEDGES) without applying MSA first (<xref rid="btad572-B19" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>). Lastly, we consider an approach, “<bold>HEDGES-MSA”</bold>, that combines information aggregation of MSA with the convolutional inner encoding to remove remaining errors. For all MSA operations, we utilize Muscle (<xref rid="btad572-B8" ref-type="bibr">Edgar 2004</xref>). Provided each approach leverages error correction and sequencing depth differently, we are interested in studying whether or not there are benefits as the sequencing depth and error rate of the system evolve.</p>
    <table-wrap position="float" id="btad572-T1">
      <label>Table 1.</label>
      <caption>
        <p>Table of simulated parameters.<xref rid="tblfn1" ref-type="table-fn"><sup>a</sup></xref></p>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="char" char="(" span="1"/>
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="char" char="(" span="1"/>
          <col valign="top" align="center" span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="1" colspan="1">Pipeline Name</th>
            <th align="center" rowspan="1" colspan="1">Index length</th>
            <th align="center" rowspan="1" colspan="1">Binary transformation</th>
            <th align="center" rowspan="1" colspan="1">Transcoding</th>
            <th align="center" rowspan="1" colspan="1">Outer code</th>
            <th align="center" rowspan="1" colspan="1">MSA</th>
            <th align="center" rowspan="1" colspan="1">Depth</th>
            <th align="center" rowspan="1" colspan="1">Inner configuration</th>
            <th align="center" rowspan="1" colspan="1">Error model</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">
              <bold>“RS”</bold>
            </td>
            <td rowspan="1" colspan="1">4 bytes</td>
            <td rowspan="1" colspan="1">Randomize, <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td>
            <td rowspan="1" colspan="1"> <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mo>Ψ</mml:mo><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi mathvariant="script">B</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow><mml:mo>;</mml:mo><mml:mrow><mml:msubsup><mml:mi mathvariant="script">D</mml:mi><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:math></inline-formula></td>
            <td rowspan="1" colspan="1"> <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td>
            <td rowspan="1" colspan="1">Muscle</td>
            <td rowspan="1" colspan="1">[3–30]</td>
            <td rowspan="1" colspan="1">(1,55), (9,47) (14,42), (28,28)</td>
            <td rowspan="1" colspan="1">i.i.d.(1,5,10%), DNArSim</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">
              <bold>“HEDGES”</bold>
            </td>
            <td rowspan="1" colspan="1">4 bytes</td>
            <td rowspan="1" colspan="1">N/A</td>
            <td rowspan="1" colspan="1">HEDGES</td>
            <td rowspan="1" colspan="1"> <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td>
            <td rowspan="1" colspan="1">N/A</td>
            <td rowspan="1" colspan="1">N/A</td>
            <td rowspan="1" colspan="1">(0.167,4), (0.25,9) (0.5,24), (0.75,39)</td>
            <td rowspan="1" colspan="1">i.i.d.(1,5,10%), DNArSim</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">
              <bold>“HEDGES-MSA”</bold>
            </td>
            <td rowspan="1" colspan="1">4 bytes</td>
            <td rowspan="1" colspan="1">N/A</td>
            <td rowspan="1" colspan="1">HEDGES</td>
            <td rowspan="1" colspan="1"> <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td>
            <td rowspan="1" colspan="1">Muscle</td>
            <td rowspan="1" colspan="1">[3–30]</td>
            <td rowspan="1" colspan="1">(0.167,4), (0.25,9) (0.5,24), (0.75,39)</td>
            <td rowspan="1" colspan="1">i.i.d.(1,5,10%), DNArSim</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <fn id="tblfn1">
          <label>a</label>
          <p>For “<bold>RS</bold>” pipelines, the inner configuration tuples <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> indicate a <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> configuration of <italic toggle="yes">x</italic> redundant bytes per strand and <italic toggle="yes">y</italic> data bytes per strand. Similarly, for the “<bold>HEDGES</bold>” configurations, an <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> tuple indicates a code rate of <italic toggle="yes">x</italic> and bytes per strand of <italic toggle="yes">y</italic>. </p>
        </fn>
        <fn id="tblfn51">
          <p><inline-formula id="IE9000"><mml:math id="IM9000" display="inline" overflow="scroll"><mml:mi>R</mml:mi><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:math></inline-formula> indicates a Reed-Solomon code over the field <inline-formula id="IE9001"><mml:math id="IM9001" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, for the <bold>“RS”</bold> pipeline Randomize means we randomize binary information prior to the Reed-Solomon inner-error correction, and <inline-formula id="IE9002"><mml:math id="IM9002" display="inline" overflow="scroll"><mml:mstyle displaystyle="false"><mml:mo>Ψ</mml:mo><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi mathvariant="script">B</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow><mml:mo>;</mml:mo><mml:mrow><mml:msubsup><mml:mi mathvariant="script">D</mml:mi><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mstyle></mml:math></inline-formula> denotes a map between binary integers of length 2 (<inline-formula id="IE9003"><mml:math id="IM9003" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi mathvariant="script">B</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>) and DNA strings of length 1 (<inline-formula id="IE9004"><mml:math id="IM9004" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi mathvariant="script">D</mml:mi><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>).</p>
        </fn>
      </table-wrap-foot>
    </table-wrap>
    <p>DNA storage system designers are also faced with various technologies for writing/reading DNA, each with different error characteristics which can impact decoder choice. To demonstrate the evaluation of multiple error channels for the same pipelines, we consider two commonly used error models. One is a simple independent and identically distributed (i.i.d.) model for insertions, substitutions, and deletions. This model is typically used when considering NGS DNA readout (<xref rid="btad572-B19" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>, <xref rid="btad572-B25" ref-type="bibr">Yuan <italic toggle="yes">et al.</italic> 2022</xref>). However, it has been shown that an i.i.d. channel does not well represent nanopore errors due to the lack of support for burst errors (<xref rid="btad572-B12" ref-type="bibr">Hamoum <italic toggle="yes">et al.</italic> 2021</xref>). To study whether burst errors may change the choice of decoder, we also consider a publicly available model, DNArSim (<ext-link xlink:href="https://github.com/BHam-1/DNArSim" ext-link-type="uri">https://github.com/BHam-1/DNArSim</ext-link>), which describes conditional error probabilities that are derived from real sequencing data.</p>
    <p>A key piece of FrameD that enables our analysis is parallelism support which allows us to simulate 240 unique pipeline configurations, totaling over 650M fault-injected DNA strands, in a reasonable time frame on a HPC cluster. All simulations were completed within 4 days on an HPC cluster with specs outlined in <xref rid="btad572-T2" ref-type="table">Table 2</xref>. To verify that our infrastructure aids in scaling to larger simulations, we perform scalability experiments on one pipeline configuration with the core type fixed to <bold>“Intel Xeon Gold6226R”</bold>. We picked the “<bold>RS (9,47)”</bold> pipeline with read depth 25× and fault rate 10%. For this study, we simulate the pipeline only 368 times, and for a single core, we measured 20 325 s to complete the simulation. Because 1 MPI rank is allocated for scheduling, 31 additional compute ranks will populate all cores of a node. In this case the experiment finishes in 802 s (25.3× speedup). In the previous cases, we are able to exclusively use a node with no outside job interference; however, for multiple node runs we are not due to our cluster being a shared system. For 92 compute ranks, we measured a 65.99× speedup. These speedups indicate that FrameD is scalable.</p>
    <table-wrap position="float" id="btad572-T2">
      <label>Table 2.</label>
      <caption>
        <p>Overview of HPC system used for simulations, parallelization parameters, and simulation characteristics.<xref rid="tblfn2" ref-type="table-fn"><sup>a</sup></xref></p>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="center" span="1"/>
        </colgroup>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">Node architecture</td>
            <td rowspan="1" colspan="1">2 Intel Gold 6226/6130 192 GB RAM per node </td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Number of batch jobs</td>
            <td rowspan="1" colspan="1">240</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">MPI ranks to parallelize fault injection iterations</td>
            <td rowspan="1" colspan="1">128</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Fault injection iterations/pipeline</td>
            <td rowspan="1" colspan="1">1024</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Total strands generated</td>
            <td rowspan="1" colspan="1">654.7 million</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Binary data/fault injection run</td>
            <td rowspan="1" colspan="1">2.78 kB</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Minimum inner code samples</td>
            <td rowspan="1" colspan="1">51 200</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <fn id="tblfn2">
          <label>a</label>
          <p>MPI parallelization was utilized for only fault injection iterations.</p>
        </fn>
      </table-wrap-foot>
    </table-wrap>
    <p>We note that FrameD only provides the infrastructure for scalability, and that efficiently executing parallel units of work requires understanding the computational resources needed by each rank. For example, developers should be aware if utilizing all cores of a node exhausts all memory when parallelizing multiple instances of the inner code, and thus allocate ranks to their compute system appropriately. In our studied pipelines, we did not observe this need, however.</p>
    <p>This experiment also relies on other properties of FrameD. Importantly, the error model modularity allows us to apply multiple error models to each pipeline, and allows us to adopt significant portions of DNArSim with minor modifications to fit FrameD’s interface. This demonstrates FrameD’s ability to incorporate existing model implementations. Probes also play a major role in this analysis by providing decoding success rates of inner-error correction algorithms, a key value when determining storage system cost.</p>
    <p>In all experiments, we control for strand length by modulating the number of bits of each base-sequence when we change the density of the encoding. This ensures that all designs fall in a strand length space that is reasonable given the practical limitations of DNA synthesis technologies (<xref rid="btad572-B3" ref-type="bibr">Bishop <italic toggle="yes">et al.</italic> 2017</xref>). In our experiments, strand lengths fall in the range of 240–242 bp. We use ideal clustering in our experiments to isolate MSA error correction from approximations made by clustering algorithms (<xref rid="btad572-B20" ref-type="bibr">Rashtchian <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>).</p>
    <sec>
      <title>4.1 Comparing pipelines</title>
      <p>We compare pipelines by calculating the read and write code rates required for each pipeline to meet a target Mean Time to Failure (MTTF) of 10<sup>9</sup> accesses on 1 MB of data. We refer to these rates in terms of read and write density, each with units bits/base, and calculate them as the ratio of total bits read/written to the total number of bases read/written. Given that synthesis and sequencing cost is proportional to the number of bases, these metrics allow for technology-independent cost comparisons. A higher density is better. Write density is derived from the redundancy allocated to the inner and outer code. While read density considers encoding redundancy, it also considers the number of copies for each strand that were sequenced. We point out that the densities used for comparison are different from those provided in <xref rid="btad572-T1" ref-type="table">Table 1</xref> for the inner codes. While the rate of the inner code influences the success rate of decoding individual strands for a given channel error, additional outer code error correction is required to develop a robust system to meet reliability targets. Thus, our final code rate is a single metric that factors in both the code rate of the inner codes shown in <xref rid="btad572-T1" ref-type="table">Table 1</xref>, and the code rate necessary for the outer code after measuring strand decode probabilities from fault injection. Detailed calculations can be found in the <xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> section.</p>
      <p>With this analysis relying on estimating the decode rate of strands through the inner code, there must be enough inner code samples to build reasonable confidence for these rates. Controlling for a consistent strand length across inner encoding densities leads to some pipelines simulating more strands given a constant input binary file. However, we ensure that each inner code is simulated against at least 51k fault-injected strands.</p>
      <p>Lastly, our analysis does not consider the impact on the outer code from physical strand dropouts that can arise throughout the DNA storage life cycle (<xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>). FrameD supports dropout modeling, but our focus in this case study is on the inner code’s ability to cope with errors in the channel. Thus, the outer code is entirely provisioned based on how well each inner code is able to decode strands without error. However, our design choices hold when factoring in dropouts if assuming a fixed dropout rate per pipeline.</p>
    </sec>
  </sec>
  <sec>
    <title>5 Results</title>
    <p>To visualize the comparison of pipeline designs across sequencing depths, we plot the Pareto front for each pipeline with respect to read and write density. A Pareto front provides the design points that optimally trade off one cost for another such that a point is included if it provides an improvement in at least one cost. If a configuration offers no benefit, it is left out. Thus, every point in <xref rid="btad572-T1" ref-type="table">Table 1</xref> will not make it to the frontier. The pipeline frontiers for the i.i.d. error model for three error rates are shown in <xref rid="btad572-F4" ref-type="fig">Fig. 4</xref>. In this figure, each pipeline has a different color, and a point shape represents a configuration of the inner code of the pipeline. The black line connecting points represents the complete frontier across all pipelines.</p>
    <fig position="float" id="btad572-F4">
      <label>Figure 4.</label>
      <caption>
        <p>Optimal density design points for the three studied pipelines across the three studied i.i.d. error rates, 1%, 5%, and 10%. The dotted black line represents the total frontier composed of points from all of the studied pipelines. Each pipeline configuration is labeled by its inner code redundancy.</p>
      </caption>
      <graphic xlink:href="btad572f4" position="float"/>
    </fig>
    <p>For the lowest fault rate (1%), we find that the “<bold>RS”</bold> pipeline with 1 redundancy byte for error detection provides the best write density. This configuration indicates that MSA is able to resolve a majority of errors. However, at a read density of 0.4 this pipeline’s write density drops and gets overtaken in optimality by the “<bold>HEDGES”</bold> pipeline. This happens because MSA alone is not able to keep up with the HEDGES code’s error correction at lower read depths, requiring the “<bold>RS”</bold> pipeline to use considerably more outer encoding overhead. Interestingly, adding MSA to an inner code is not always best as shown by “<bold>HEDGES”</bold> enveloping “<bold>HEDGES-MSA”</bold>. The reason stems from the HEDGES code’s high decode rate of single strands at this error rate such that it is more likely to decode a strand by applying the code multiple times rather than aggregating the information in MSA.</p>
    <p>As the i.i.d. rate increases, MSA-based approaches become more prominent. For example, when the error rate is 5%, “<bold>HEDGES-MSA”</bold> outperforms “<bold>HEDGES”</bold> for the same inner code configuration. This is because it is now more cost-effective to use sequencing depth to reduce the per-base error rate with MSA, rather than applying the HEDGES code individually to each sequenced copy. The same occurs for a 10% error rate. Still, a pattern emerges where a non-optimal “<bold>HEDGES-MSA”</bold> approach becomes enveloped again by the “<bold>HEDGES”</bold> pipeline with the same configuration. We conclude from this that the optimality of using HEDGES with or without MSA is highly dependent on the error rate of the storage system, a conclusion a designer will not be able to come to without a simulation framework like FrameD.</p>
    <p>A pattern that emerges for “<bold>HEDGES”</bold> configurations is that when read density is increased by decreasing sequencing depth, at a certain point it no longer becomes cost-effective due to ballooning outer code overhead, making lower density inner codes preferred. This can be seen for a fault rate of 5% between “<bold>HEDGES:0.75”</bold> and “<bold>HEDGES:0.5”</bold>. However, this is not the case for “<bold>RS”</bold>, as no configurations that utilize less dense Reed–Solomon codes for error correction appear in <xref rid="btad572-F4" ref-type="fig">Fig. 4</xref>. This indicates that Reed–Solomon as an inner code is ineffective against insertions and deletions. We demonstrate this further in the <xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref>.</p>
    <p><xref rid="btad572-F5" ref-type="fig">Figure 5</xref> compares the three pipelines for nanopore-based fault injection. In contrast with the i.i.d. frontier, the complete frontier consists of points only from “<bold>HEDGES-MSA”</bold>. The main driving force of this is that nanopore sequencing has a higher frequency of burst errors compared to the i.i.d. model. Burst errors generate a decoder mismatch with the HEDGES code since this algorithm relies on guessing errors based on an i.i.d. error model. Thus, the HEDGES code experiences a large decode rate decrease unless MSA is applied beforehand to help resolve bursts. Another interesting component of <xref rid="btad572-F5" ref-type="fig">Fig. 5</xref> is that there is no configuration that just relies on MSA to resolve errors. These results showcase that with FrameD designers are able to define weaknesses in decoding algorithms and determine better pipeline combinations when faced with designing for different sequencing devices.</p>
    <fig position="float" id="btad572-F5">
      <label>Figure 5.</label>
      <caption>
        <p>Optimal frontiers obtained when the error injection model is based on nanopore sequencing technology.</p>
      </caption>
      <graphic xlink:href="btad572f5" position="float"/>
    </fig>
  </sec>
  <sec>
    <title>6 Conclusion</title>
    <p>We have shown that as work continues in the area of DNA storage systems there is an increasing number of unique pipelines that overlap in the components that they use. We introduce FrameD to address the void of tools available to the DNA data storage community, enabling the modularization of common algorithms and integrating fault injection models to provide a basis for fair system comparisons. Because of its foundation in the literature of DNA storage systems, FrameD provides designers with the ability to simulate a wide variety of storage systems. FrameD also provides transparent support for the parallelization of computational units of work such as individual strands and fault injection iterations, enabling the use of scalable high-performance computing systems. These features are demonstrated in our analysis of three pipelines that utilize the same components in different combinations across two error models representing different sequencing devices. In our analysis, the optimal pipeline choice and configuration depends both on the cost targets set by the designer and the target sequencing device. This highlights the basic need for DNA storage designers to have tools that can compare designs across a range of environments.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad572_Supplementary_Data</label>
      <media xlink:href="btad572_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>J.T. and A.K. are co-founders of DNAli Data Technologies. W.T. has two patents (8748091 and 8394584) licensed to ONT. W.T. has received travel funds to speak at symposia organized by ONT.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by the National Science Foundation [1901324 to K.V., K.L., A.K., J.T., 2027655 to K.V., K.L., A.K., J.T., P.H., W.T.].</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad572-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Anavy</surname><given-names>L</given-names></string-name>, <string-name><surname>Vaknin</surname><given-names>I</given-names></string-name>, <string-name><surname>Atar</surname><given-names>O</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Data storage in DNA with fewer synthesis cycles using composite DNA letters</article-title>. <source>Nat Biotechnol</source>  <year>2019</year>;<volume>37</volume>:<fpage>1229</fpage>–<lpage>36</lpage>.<pub-id pub-id-type="pmid">31501560</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Antkowiak</surname><given-names>PL</given-names></string-name>, <string-name><surname>Lietard</surname><given-names>J</given-names></string-name>, <string-name><surname>Darestani</surname><given-names>MZ</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Low cost DNA data storage using photolithographic synthesis and advanced information reconstruction and error correction</article-title>. <source>Nat Commun</source>  <year>2020</year>;<volume>11</volume>:<fpage>5345</fpage>.<pub-id pub-id-type="pmid">33093494</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B3">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Bishop</surname><given-names>B</given-names></string-name>, <string-name><surname>Mccorkle</surname><given-names>N</given-names></string-name>, <string-name><surname>Zhirnov</surname><given-names>V.</given-names></string-name></person-group>  <italic toggle="yes">Technology Working Group Meeting on Future DNA Synthesis Technologies</italic>, Durham, NC: Semiconductor Research Corporation, Arlington, VA, <year>2017</year>, p. <fpage>39</fpage>.</mixed-citation>
    </ref>
    <ref id="btad572-B4">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Bornholt</surname><given-names>J</given-names></string-name>, <string-name><surname>Lopez</surname><given-names>R</given-names></string-name>, <string-name><surname>Carmean</surname><given-names>DM</given-names></string-name></person-group>  <etal>et al</etal> A DNA-based archival storage system. In<italic toggle="yes">: Proceedings of the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS ’16</italic>. New York, NY: ACM, Atlanta, GA, <year>2016</year>, <fpage>637</fpage>–<lpage>49</lpage>. ISBN 978-1-4503-4091-5.</mixed-citation>
    </ref>
    <ref id="btad572-B5">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Chaykin</surname><given-names>G</given-names></string-name>, <string-name><surname>Furman</surname><given-names>N</given-names></string-name>, <string-name><surname>Sabary</surname><given-names>O</given-names></string-name></person-group>  <etal>et al</etal> DNA-Storalator: End-to-End DNA Storage Simulator. In: <italic toggle="yes">Non-Volatile Memories Workshop 2022</italic>, Oakland, CA: University of Calidfornia, San Diego, CA, <year>2022</year>.</mixed-citation>
    </ref>
    <ref id="btad572-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Choi</surname><given-names>Y</given-names></string-name>, <string-name><surname>Ryu</surname><given-names>T</given-names></string-name>, <string-name><surname>Lee</surname><given-names>AC</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>High information capacity DNA-based data storage with augmented encoding characters using degenerate bases</article-title>. <source>Sci Rep</source>  <year>2019</year>;<volume>9</volume>:<fpage>6582</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">31036920</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Church</surname><given-names>GM</given-names></string-name>, <string-name><surname>Gao</surname><given-names>Y</given-names></string-name>, <string-name><surname>Kosuri</surname><given-names>S.</given-names></string-name></person-group>  <article-title>Next-generation digital information storage in DNA</article-title>. <source>Science</source>  <year>2012</year>;<volume>337</volume>:<fpage>1628</fpage>.<pub-id pub-id-type="pmid">22903519</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Edgar</surname><given-names>RC.</given-names></string-name></person-group>  <article-title>MUSCLE: a multiple sequence alignment method with reduced time and space complexity</article-title>. <source>BMC Bioinformatics</source>  <year>2004</year>;<volume>5</volume>:<fpage>113</fpage>.<pub-id pub-id-type="pmid">15318951</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Erlich</surname><given-names>Y</given-names></string-name>, <string-name><surname>Zielinski</surname><given-names>D.</given-names></string-name></person-group>  <article-title>DNA fountain enables a robust and efficient storage architecture</article-title>. <source>Science</source>  <year>2017</year>;<volume>355</volume>:<fpage>950</fpage>–<lpage>4</lpage>.<pub-id pub-id-type="pmid">28254941</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Goldman</surname><given-names>N</given-names></string-name>, <string-name><surname>Bertone</surname><given-names>P</given-names></string-name>, <string-name><surname>Chen</surname><given-names>S</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Towards practical, high-capacity, low-maintenance information storage in synthesized DNA</article-title>. <source>Nature</source>  <year>2013</year>;<volume>494</volume>:<fpage>77</fpage>–<lpage>80</lpage>.<pub-id pub-id-type="pmid">23354052</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Grass</surname><given-names>RN</given-names></string-name>, <string-name><surname>Heckel</surname><given-names>R</given-names></string-name>, <string-name><surname>Puddu</surname><given-names>M</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Robust chemical preservation of digital information on DNA in silica with error-correcting codes</article-title>. <source>Angew Chem Int Ed Engl</source>  <year>2015</year>;<volume>54</volume>:<fpage>2552</fpage>–<lpage>5</lpage>.<pub-id pub-id-type="pmid">25650567</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B12">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Hamoum</surname><given-names>B</given-names></string-name>, <string-name><surname>Dupraz</surname><given-names>E</given-names></string-name>, <string-name><surname>Conde-Canencia</surname><given-names>L</given-names></string-name></person-group>  <etal>et al</etal> Channel model with memory for DNA data storage with nanopore sequencing. In: <italic toggle="yes">2021 11th International Symposium on Topics in Coding (ISTC)</italic>, New York, NY: IEEE, Quebec, Canada, <year>2021</year>, <fpage>1</fpage>–<lpage>5</lpage>.</mixed-citation>
    </ref>
    <ref id="btad572-B13">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Heckel</surname><given-names>R</given-names></string-name>, <string-name><surname>Shomorony</surname><given-names>I</given-names></string-name>, <string-name><surname>Ramchandran</surname><given-names>K</given-names></string-name></person-group>  <etal>et al</etal> Fundamental limits of DNA storage systems. In: <italic toggle="yes">2017 IEEE International Symposium on Information Theory (ISIT)</italic>, New York, NY: IEEE, Aachen, Germany, <year>2017</year>, 3130–3134. ISSN: <fpage>2157</fpage>–<lpage>8117</lpage>.</mixed-citation>
    </ref>
    <ref id="btad572-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lin</surname><given-names>KN</given-names></string-name>, <string-name><surname>Volkel</surname><given-names>K</given-names></string-name>, <string-name><surname>Tuck</surname><given-names>JM</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Dynamic and scalable DNA-based information storage</article-title>. <source>Nat Commun</source>  <year>2020</year>;<volume>11</volume>:<fpage>2981</fpage>.<pub-id pub-id-type="pmid">32532979</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marelli</surname><given-names>A</given-names></string-name>, <string-name><surname>Chiozzi</surname><given-names>T</given-names></string-name>, <string-name><surname>Battistini</surname><given-names>N</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Integrating FPGA acceleration in the DNAssim framework for faster DNA-based data storage simulations</article-title>. <source>Electronics</source>  <year>2023</year>;<volume>12</volume>:<fpage>2621</fpage>.</mixed-citation>
    </ref>
    <ref id="btad572-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Matange</surname><given-names>K</given-names></string-name>, <string-name><surname>Tuck</surname><given-names>JM</given-names></string-name>, <string-name><surname>Keung</surname><given-names>AJ.</given-names></string-name></person-group>  <article-title>DNA stability: a central design consideration for DNA data storage systems</article-title>. <source>Nat Commun</source>  <year>2021</year>;<volume>12</volume>:<fpage>1358</fpage>.<pub-id pub-id-type="pmid">33649304</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Organick</surname><given-names>L</given-names></string-name>, <string-name><surname>Ang</surname><given-names>SD</given-names></string-name>, <string-name><surname>Chen</surname><given-names>Y-J</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Random access in large-scale DNA data storage</article-title>. <source>Nat Biotechnol</source>  <year>2018</year>;<volume>36</volume>:<fpage>242</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">29457795</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Organick</surname><given-names>L</given-names></string-name>, <string-name><surname>Chen</surname><given-names>Y-J</given-names></string-name>, <string-name><surname>Dumas Ang</surname><given-names>S</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Probing the physical limits of reliable DNA data retrieval</article-title>. <source>Nat Commun</source>  <year>2020</year>;<volume>11</volume>:<fpage>616</fpage>.<pub-id pub-id-type="pmid">32001691</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Press</surname><given-names>WH</given-names></string-name>, <string-name><surname>Hawkins</surname><given-names>JA</given-names></string-name>, <string-name><surname>Jones</surname><given-names>SK</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>HEDGES error-correcting code for DNA storage corrects indels and allows sequence constraints</article-title>. <source>Proc Natl Acad Sci U S A</source>  <year>2020</year>;<volume>117</volume>:<fpage>18489</fpage>–<lpage>96</lpage>.<pub-id pub-id-type="pmid">32675237</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B20">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Rashtchian</surname><given-names>C</given-names></string-name>, <string-name><surname>Makarychev</surname><given-names>K</given-names></string-name>, <string-name><surname>Racz</surname><given-names>M</given-names></string-name></person-group>  <etal>et al</etal>  <part-title>Clustering billions of reads for DNA data storage</part-title>. In: <person-group person-group-type="editor"><string-name><surname>Guyon</surname><given-names>I</given-names></string-name></person-group> (ed.), <source>Advances in Neural Information Processing Systems 30</source>. Red Hook, NY: <publisher-name>Curran Associates Inc</publisher-name>, <year>2017</year>, <fpage>3360</fpage>–<lpage>71</lpage>.</mixed-citation>
    </ref>
    <ref id="btad572-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sabary</surname><given-names>O</given-names></string-name>, <string-name><surname>Orlev</surname><given-names>Y</given-names></string-name>, <string-name><surname>Shafir</surname><given-names>R</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>SOLQC: synthetic oligo library quality control tool</article-title>. <source>Bioinformatics</source>  <year>2021</year>;<volume>37</volume>:<fpage>720</fpage>–<lpage>2</lpage>.<pub-id pub-id-type="pmid">32840559</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tomek</surname><given-names>KJ</given-names></string-name>, <string-name><surname>Volkel</surname><given-names>K</given-names></string-name>, <string-name><surname>Simpson</surname><given-names>A</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Driving the scalability of DNA-based information storage systems</article-title>. <source>ACS Synth Biol</source>  <year>2019</year>;<volume>8</volume>:<fpage>1241</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">31117362</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tomek</surname><given-names>KJ</given-names></string-name>, <string-name><surname>Volkel</surname><given-names>K</given-names></string-name>, <string-name><surname>Indermaur</surname><given-names>EW</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Promiscuous molecules for smarter file operations in DNA-based data storage</article-title>. <source>Nat Commun</source>  <year>2021</year>;<volume>12</volume>:<fpage>3518</fpage>.<pub-id pub-id-type="pmid">34112775</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yazdi</surname><given-names>SMHT</given-names></string-name>, <string-name><surname>Gabrys</surname><given-names>R</given-names></string-name>, <string-name><surname>Milenkovic</surname><given-names>O.</given-names></string-name></person-group>  <article-title>Portable and error-free DNA-based data storage</article-title>. <source>Sci Rep</source>  <year>2017</year>;<volume>7</volume>:<fpage>5011</fpage>.<pub-id pub-id-type="pmid">28694453</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yuan</surname><given-names>L</given-names></string-name>, <string-name><surname>Xie</surname><given-names>Z</given-names></string-name>, <string-name><surname>Wang</surname><given-names>Y</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>DeSP: a systematic DNA storage error simulation pipeline</article-title>. <source>BMC Bioinformatics</source>  <year>2022</year>;<volume>23</volume>:<fpage>185</fpage>.<pub-id pub-id-type="pmid">35581548</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10563143</article-id>
    <article-id pub-id-type="pmid">37713474</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad572</article-id>
    <article-id pub-id-type="publisher-id">btad572</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>FrameD: framework for DNA-based data storage design, verification, and validation</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-5200-5909</contrib-id>
        <name>
          <surname>Volkel</surname>
          <given-names>Kevin D</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/conceptualization" degree-contribution="lead">Conceptualization</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Data curation" vocab-term-identifier="https://credit.niso.org/contributor-roles/data-curation" degree-contribution="lead">Data curation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Formal analysis" vocab-term-identifier="https://credit.niso.org/contributor-roles/formal-analysis" degree-contribution="lead">Formal analysis</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Methodology" vocab-term-identifier="https://credit.niso.org/contributor-roles/methodology" degree-contribution="lead">Methodology</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Software" vocab-term-identifier="https://credit.niso.org/contributor-roles/software" degree-contribution="lead">Software</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Validation" vocab-term-identifier="https://credit.niso.org/contributor-roles/validation" degree-contribution="lead">Validation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Visualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/visualization" degree-contribution="lead">Visualization</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - original draft" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-original-draft" degree-contribution="lead">Writing - original draft</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="lead">Writing - review &amp; editing</role>
        <aff><institution>Department of Electrical and Computer Engineering, North Carolina State University</institution>, Raleigh, NC, 27606, <country country="US">United States</country></aff>
        <xref rid="btad572-cor1" ref-type="corresp"/>
        <!--kvolkel@ncsu.edu-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Lin</surname>
          <given-names>Kevin N</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="supporting">Writing - review &amp; editing</role>
        <aff><institution>Department of Chemical and Biomolecular Engineering, North Carolina State University</institution>, Raleigh, NC, 27695, <country country="US">United States</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Hook</surname>
          <given-names>Paul W</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="supporting">Writing - review &amp; editing</role>
        <aff><institution>Department of Biomedical Engineering, Johns Hopkins University</institution>, Baltimore, MD, 21218, <country country="US">United States</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-2083-6027</contrib-id>
        <name>
          <surname>Timp</surname>
          <given-names>Winston</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Funding acquisition" vocab-term-identifier="https://credit.niso.org/contributor-roles/funding-acquisition" degree-contribution="equal">Funding acquisition</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="https://credit.niso.org/contributor-roles/investigation" degree-contribution="equal">Investigation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Project administration" vocab-term-identifier="https://credit.niso.org/contributor-roles/project-administration" degree-contribution="equal">Project administration</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Supervision" vocab-term-identifier="https://credit.niso.org/contributor-roles/supervision" degree-contribution="supporting">Supervision</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="supporting">Writing - review &amp; editing</role>
        <aff><institution>Department of Biomedical Engineering, Johns Hopkins University</institution>, Baltimore, MD, 21218, <country country="US">United States</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8958-1232</contrib-id>
        <name>
          <surname>Keung</surname>
          <given-names>Albert J</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Funding acquisition" vocab-term-identifier="https://credit.niso.org/contributor-roles/funding-acquisition" degree-contribution="equal">Funding acquisition</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="https://credit.niso.org/contributor-roles/investigation" degree-contribution="equal">Investigation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Project administration" vocab-term-identifier="https://credit.niso.org/contributor-roles/project-administration" degree-contribution="equal">Project administration</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Supervision" vocab-term-identifier="https://credit.niso.org/contributor-roles/supervision" degree-contribution="supporting">Supervision</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="supporting">Writing - review &amp; editing</role>
        <aff><institution>Department of Chemical and Biomolecular Engineering, North Carolina State University</institution>, Raleigh, NC, 27695, <country country="US">United States</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8975-0294</contrib-id>
        <name>
          <surname>Tuck</surname>
          <given-names>James M</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/conceptualization" degree-contribution="lead">Conceptualization</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Funding acquisition" vocab-term-identifier="https://credit.niso.org/contributor-roles/funding-acquisition" degree-contribution="equal">Funding acquisition</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="https://credit.niso.org/contributor-roles/investigation" degree-contribution="equal">Investigation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Project administration" vocab-term-identifier="https://credit.niso.org/contributor-roles/project-administration" degree-contribution="equal">Project administration</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Resources" vocab-term-identifier="https://credit.niso.org/contributor-roles/resources" degree-contribution="lead">Resources</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Software" vocab-term-identifier="https://credit.niso.org/contributor-roles/software" degree-contribution="supporting">Software</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Supervision" vocab-term-identifier="https://credit.niso.org/contributor-roles/supervision" degree-contribution="lead">Supervision</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - original draft" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-original-draft" degree-contribution="lead">Writing - original draft</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="lead">Writing - review &amp; editing</role>
        <aff><institution>Department of Electrical and Computer Engineering, North Carolina State University</institution>, Raleigh, NC, 27606, <country country="US">United States</country></aff>
        <xref rid="btad572-cor1" ref-type="corresp"/>
        <!--jtuck@ncsu.edu-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Kelso</surname>
          <given-names>Janet</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad572-cor1">Corresponding authors. Department of Electrical and Computer Engineering, North Carolina State University, 890 Oval Drive Raleigh, NC, 27606, United States. E-mails: <email>kvolkel@ncsu.edu</email> (K.D.V.) and <email>jtuck@ncsu.edu</email> (J.M.T.)</corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>10</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-09-15">
      <day>15</day>
      <month>9</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>15</day>
      <month>9</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>10</issue>
    <elocation-id>btad572</elocation-id>
    <history>
      <date date-type="received">
        <day>28</day>
        <month>3</month>
        <year>2023</year>
      </date>
      <date date-type="rev-recd">
        <day>27</day>
        <month>7</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>04</day>
        <month>9</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>13</day>
        <month>9</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>10</day>
        <month>10</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad572.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>DNA-based data storage is a quickly growing field that hopes to harness the massive theoretical information density of DNA molecules to produce a competitive next-generation storage medium suitable for archival data. In recent years, many DNA-based storage system designs have been proposed. Given that no common infrastructure exists for simulating these storage systems, comparing many different designs along with many different error models is increasingly difficult. To address this challenge, we introduce FrameD, a simulation infrastructure for DNA storage systems that leverages the underlying modularity of DNA storage system designs to provide a framework to express different designs while being able to reuse common components.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We demonstrate the utility of FrameD and the need for a common simulation platform using a case study. Our case study compares designs that utilize strand copies differently, some that align strand copies using multiple sequence alignment algorithms and others that do not. We found that the choice to include multiple sequence alignment in the pipeline is dependent on the error rate and the type of errors being injected and is not always beneficial. In addition to supporting a wide range of designs, FrameD provides the user with transparent parallelism to deal with a large number of reads from sequencing and the need for many fault injection iterations. We believe that FrameD fills a void in the tools publicly available to the DNA storage community by providing a modular and extensible framework with support for massive parallelism. As a result, it will help accelerate the design process of future DNA-based storage systems.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>The source code for FrameD along with the data generated during the demonstration of FrameD is available in a public Github repository at <ext-link xlink:href="https://github.com/dna-storage/framed" ext-link-type="uri">https://github.com/dna-storage/framed</ext-link>, (<ext-link xlink:href="https://dx.doi.org/10.5281/zenodo.7757762" ext-link-type="uri">https://dx.doi.org/10.5281/zenodo.7757762</ext-link>).</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Science Foundation</institution>
            <institution-id institution-id-type="DOI">10.13039/100000001</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>1901324</award-id>
        <award-id>2027655</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>The world is generating data faster and in larger quantities than ever before, raising concerns that traditional storage technologies will not scale to keep up with demand. In the search for new technologies, DNA has gained broad interest due to its superior density and longevity compared to magnetic tape and hard disk drives. Since the early work of <xref rid="btad572-B7" ref-type="bibr">Church <italic toggle="yes">et al.</italic> (2012)</xref> and <xref rid="btad572-B10" ref-type="bibr">Goldman <italic toggle="yes">et al.</italic> (2013)</xref> demonstrating the ability to store information in DNA strands using modern DNA technology, there have been a range of studies answering important questions such as data addressability (<xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B18" ref-type="bibr">2020, Tomek <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B23" ref-type="bibr">2021, Lin <italic toggle="yes">et al.</italic> 2020</xref>), synthesis efficiency (<xref rid="btad572-B1" ref-type="bibr">Anavy <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B6" ref-type="bibr">Choi <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>), DNA reusability (<xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B14" ref-type="bibr">Lin <italic toggle="yes">et al.</italic> 2020</xref>), error rates associated with a variety of techniques (<xref rid="btad572-B11" ref-type="bibr">Grass <italic toggle="yes">et al.</italic> 2015</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B16" ref-type="bibr">Matange <italic toggle="yes">et al.</italic> 2021</xref>), and the density that can be achieved in DNA molecules (<xref rid="btad572-B10" ref-type="bibr">Goldman <italic toggle="yes">et al.</italic> 2013</xref>, <xref rid="btad572-B9" ref-type="bibr">Erlich and Zielinski 2017</xref>, <xref rid="btad572-B1" ref-type="bibr">Anavy <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B6" ref-type="bibr">Choi <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>). This vast knowledge base of DNA-based data storage comes with an equally expansive space of possible implementation approaches for which little if any consensus has been reached. Compounding the problem of choosing any one approach is the fact that there is a lack of common infrastructure that enables the comparison of these designs in a fair and reproducible manner.</p>
    <p>To address the growing need for tools to analyze and compare DNA storage systems, we present FrameD, a software framework for designing, verifying, and validating DNA storage system designs. FrameD is not a library of every conceivable error correction algorithm, instead, it provides a fault-injection-based test bed in which DNA storage systems can be evaluated. Constructing FrameD requires several considerations. One being FrameD’s flexibility in terms of what DNA storage systems can be represented. To address this issue, we use current literature to inform the construction of a model that can be used as a basis in which a range of DNA storage systems can be expressed. With this model, we are able to implement an execution back-end that executes a set of encoding steps that adhere to the model’s interfaces. Thus, for an encoding to be used in FrameD, a user need only follow the interface specification. This execution model back-end also provides transparent support for necessary bookkeeping steps like DNA strand indexing and dropout inference, allowing the user to focus on the details of their algorithms.</p>
    <p>Another issue that needs to be considered when simulating DNA storage systems is computational scale issues that arise from several sources. One source is the size of the possible parameter space of interest with regards to an encoding/decoding algorithm, as exploring combinations of parameters can easily lead to exponential growth in the number of experiments. Another source of computational scale arises from the necessity to perform fault injection experiments 1000’s of times to achieve narrow confidence intervals on key outcomes such as strand and file decode rates. Compounding each source of computational overhead is the scale of sequencing data that needs to be processed. To support scalability, FrameD utilizes batch jobs to parallelize individual configuration simulations and Message Passing Interface (MPI) to parallelize units of work within those batch jobs like strand decoding and fault injection iterations. FrameD implements the parallelization support transparently such that users do not need to manage parallelization communication. Instead, the user just specifies their configurations and the computational resources to allocate to each.</p>
    <p>We demonstrate the utility of FrameD by performing a comparison between three designs across two error models representing different sequencing technology. We evaluate 240 total configurations, generating a total of 654 million fault-injected DNA strands, and analyze the read and write density trade-off between the three designs. Our results show that the optimal design approach depends on the designer’s read and write cost targets and the target sequencing technology, and bolsters our claim that a common simulation infrastructure is needed.</p>
  </sec>
  <sec>
    <title>2 The case for DNA storage simulation infrastructure</title>
    <p>Before discussing details of FrameD, we present a study of current literature to further motivate the need for a DNA simulation infrastructure and to understand the basic components that such an infrastructure will need to support. For our review, we choose 13 previous works that implement end-to-end DNA storage systems. We selected these works because they are representative of different approaches that have been taken since the revival of DNA data storage started by Goldman <italic toggle="yes">et al.</italic>’s work. Thus, we should be able to make conclusions about consistent approaches taken in DNA storage design, while also being able to account for the inclusion of novel techniques from each individual work. Detailed organization of these works is presented in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>.</p>
    <p>We find that transformations applied to information can be organized hierarchically in two levels. At the first level, we identify two broad categories we refer to as “<bold>Single Strand”</bold> and “<bold>Multi-Strand”</bold> transformations. Single Strand transformations focus on processing information stored in a single molecule of DNA, while the Multi-Strand processes relate to processing information stored within a group of molecules.</p>
    <p>Under the Single Strand category, we found three typical transformation steps: “<bold>Binary Transformation”</bold>, “<bold>Transcoding”</bold>, and “<bold>Functional Site Encoding”</bold>. Each of these sub-categories modify the data present on a single DNA molecule in their own way. A Binary Transformation modifies the raw digital information before it is represented as DNA molecule. Such modifications typically included parity checks (<xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>), Reed–Solomon codes (<xref rid="btad572-B11" ref-type="bibr">Grass <italic toggle="yes">et al.</italic> 2015</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>), and base conversions from the typical Base-2 binary representation of digital information to a numerical base that may be more convenient for a certain Reed-Solomon field (<xref rid="btad572-B11" ref-type="bibr">Grass <italic toggle="yes">et al.</italic> 2015</xref>, <xref rid="btad572-B1" ref-type="bibr">Anavy <italic toggle="yes">et al.</italic> 2019</xref>). The Transcoding category consists of processes that represent the digital source information in terms of a DNA molecule. While transcoding can be as simple as a base-conversion to base-4 (<xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>), approaches typically consider constraints such as GC balance (<xref rid="btad572-B24" ref-type="bibr">Yazdi <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad572-B19" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>) and homopolymers (<xref rid="btad572-B10" ref-type="bibr">Goldman <italic toggle="yes">et al.</italic> 2013</xref>, <xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>), yielding a range of options with different error correction and density properties. The final Single Strand pass, Functional Site Encoding, is not inherently dependent on the raw information stored but instead includes DNA substrings in the stored molecules to facilitate functionality. Functionality encoding includes adding primers for polymerase chain reaction (PCR) random access (<xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>), T7 promotor sites for RNA transcription (<xref rid="btad572-B14" ref-type="bibr">Lin <italic toggle="yes">et al.</italic> 2020</xref>), and restriction sites for DNA fragmentation (<xref rid="btad572-B23" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2021</xref>).</p>
    <p>Under the Multi-Strand category, we determined three distinct processing steps: “<bold>Outer Code”</bold>, “<bold>Consolidation”</bold>, and “<bold>Reconstruction”</bold>. The Outer Code step is similar to the Binary Transformation step of the single strand category, except error correction codes like Reed–Solomon are applied using the data of a group of strands so that errors can be corrected using information dispersed across DNA molecules (<xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B19" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>, <xref rid="btad572-B23" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2021</xref>). This error correction technique is crucial for dealing with the occurrence of missing DNA molecules, a common error mode of DNA storage systems (<xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B19" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>). Another issue that a DNA storage system design must address is the reconstruction of the order of information. Representing arbitrarily large sets of information requires storing subsets of information on individual DNA molecules because synthetic DNA of arbitrary length is not feasible to synthesize. Provided mixtures of DNA molecules are not guaranteed to be sequenced in any particular order, a Reconstruction strategy is needed to map a DNA molecule to its place in the complete dataset. Because of its optimality regarding density (<xref rid="btad572-B13" ref-type="bibr">Heckel <italic toggle="yes">et al.</italic> 2017</xref>), an “<bold>indexing”</bold> strategy that stores an ordering integer in each strand is a common approach (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>). Lastly, because DNA storage systems typically generate multiple copies of each transcoded DNA molecule by way of synthesis, sequencing, or amplification (<xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B24" ref-type="bibr">Yazdi <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>), a processing step which we call Consolidation is required to generate one final representative of the information of a stored DNA molecule. This can be as simple as detecting and removing bad strands using error correction until finding a valid strand (<xref rid="btad572-B10" ref-type="bibr">Goldman <italic toggle="yes">et al.</italic> 2013</xref>, <xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B19" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>), or bioinformatics tools such as multiple sequence alignment (MSA) algorithms can be employed to determine a consensus sequence (<xref rid="btad572-B24" ref-type="bibr">Yazdi <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>).</p>
    <p>From this discussion, we can immediately see that the transformation of information within a DNA storage system can be described by a small set of general categories. This indicates that an infrastructure which provides support for routing this information between these categories can be effective in representing many unique DNA storage systems.</p>
    <p>Given this observation, we consider how prior works in DNA storage simulation support general encoding and simulation environments. DNA-Storalator is a DNA storage system simulator that focuses on evaluating clustering and reconstruction algorithms that work to construct a representative DNA strand from a cluster of noisy versions. However, DNA-Storalator does not offer support for the evaluation of Outer, Binary Transformation, or Transcoding codecs (<xref rid="btad572-B5" ref-type="bibr">Chaykin <italic toggle="yes">et al.</italic> 2022</xref>). Furthermore, the only error models supported are those which are generated by wet-lab experiments (<xref rid="btad572-B21" ref-type="bibr">Sabary <italic toggle="yes">et al.</italic> 2021</xref>). While these may be accurate for a given DNA storage system implementation, allowing for user-defined error models allows for testing codecs over a wider set of cases. DNAssim offers flexible fault and coverage models, along with outer code evaluation. However, DNAssim does not consider the complex space of inner code design and chooses to only use binary to base-4 conversion as its transcoding method (<xref rid="btad572-B15" ref-type="bibr">Marelli <italic toggle="yes">et al.</italic> 2023</xref>). Another simulator is DeSP; however, it is only a tool that provides error injections and strand distribution changes, and so it is not a framework for evaluating different encoding designs (<xref rid="btad572-B25" ref-type="bibr">Yuan <italic toggle="yes">et al.</italic> 2022</xref>). In the following sections, we discuss how FrameD provides a framework in which a rich space of encodings can be evaluated using flexible error models in a scalable environment.</p>
  </sec>
  <sec>
    <title>3 FrameD</title>
    <p>We leverage categorical overlap of designs by understanding that there is a logical ordering in which the information transformations can be applied. This ordering is illustrated in <xref rid="btad572-F1" ref-type="fig">Fig. 1</xref>, where information flows from left to right. First, information in a file is broken into contiguous pieces called “<bold>packets”</bold>. Packets serve as the scope for the outer encoding, allowing for designers to choose a granularity for the outer error correction algorithm. Before the outer code is applied, the packet is broken down into “<bold>base-sequences”</bold>, contiguous sections of information that will be stored on each DNA molecule. A packet’s base-sequences are then processed by the outer code, which generates indices automatically for each base-sequence while also adding additional error correction base-sequences. FrameD defaults to basic incremental integers for indexing, but provides the designer the interface to implement special indexes like the Luby Seed for Fountain codes. Each indexed base-sequence is passed through the “<bold>inner-encoder”</bold>, a series of steps consisting of the Single Strand operations.</p>
    <fig position="float" id="btad572-F1">
      <label>Figure 1.</label>
      <caption>
        <p>Model used by FrameD to represent encoding for DNA storage systems. Included in this figure is an example of the state of information throughout the pipeline, where initially data is in its original byte representation, then converted to base-3 and subsequently DNA, and finally stored with prepend/appended DNA strings typically done for PCR primer functionality.</p>
      </caption>
      <graphic xlink:href="btad572f1" position="float"/>
    </fig>
    <p>The decode phase is mostly identical to encoding, except that the transformations made by each pass are reversed. However, decoding must have a mechanism to deal with multiple copies per encoded strand. We found two approaches that can be taken. One is to first cluster the DNA strands input to the decoder based on similarity scores like edit distance or using a MinHash-based approaches (<xref rid="btad572-B20" ref-type="bibr">Rashtchian <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>). Then MSA algorithms, such as Muscle, can be used to aggregate information across strands and help resolve errors through consensus voting (<xref rid="btad572-B8" ref-type="bibr">Edgar 2004</xref>, <xref rid="btad572-B24" ref-type="bibr">Yazdi <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>). To account for these approaches, we provide users the ability to add MSA and clustering steps to the pipeline before the inner encoding is reversed. This process is outlined in the <xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref>. Another approach is to consolidate the strands after completing the inner code, throwing out strands that may violate error checks, and coming to a consensus on the digital representation of information. FrameD supports the use of either approach, or even both.</p>
    <p>The pipelined approach of FrameD provides DNA storage system designers several benefits. By implementing the routing of information between components, the designer can focus on their algorithms as long as it adheres to the pipeline’s information transformation interface. Further, by breaking larger steps, e.g. inner code, down into smaller sub-components, a new unique inner code can be constructed by modifying just a single component without needing to re-implement the other algorithms that constitute the inner code. For example, one could change their Binary Transformation pass while keeping the same implementations of the Transcoding and Functional Site Encoding passes. As long as the new component adheres to its prescribed interface given the type of transformation it performs, no other work is required outside of implementing the new algorithm.</p>
    <p><xref rid="btad572-F1" ref-type="fig">Figure 1</xref> shows only three components within the inner encoding and one outer code component; however, we point out that both can consist of an arbitrary number. That is, Outer Codes, Binary Transformations, and Functional Site Encoding can be cascaded an arbitrary amount. For example, one may have two binary transformations, one to modify the numerical base representation of data and another one to convert to a Reed–Solomon code. We leave out Transcoding from this list, since transcoding binary information to DNA can only occur once. Details on how indexing is supported in cascaded Outer Codes is discussed in the <xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref>. FrameD also leverages transformation type interfaces to provide validation checks for the designer to ensure that there is a logical arrangement of components.</p>
    <sec>
      <title>3.1 Fault injection workflow</title>
      <p>FrameD includes a simulation tool based on a fault injection methodology for evaluating DNA storage system designs. Fault injection simulation provides several benefits over the analytical model. Fault injection experiments provide the ability to quickly estimate properties of specific steps of the encoding/decoding processes. For example, fault injection experiments can determine a rate at which strands can be successfully decoded using a specified error model. This information can be used to verify analytical results or to derive parameters for a full-scale DNA storage system. Fault injection models are also more flexible, where changing an encoding or error model can make deriving a new analytical model difficult. Lastly, a fault injection framework exercises actual algorithm implementations against strands with errors in them, allowing for benchmarking and debugging that an analytical model cannot provide.</p>
      <p><xref rid="btad572-F2" ref-type="fig">Figure 2</xref> overviews the workflow of using FrameD for fault injection. First, a user develops a JSON configuration file which includes a path to the binary data to be converted to DNA, along with details of three general categories of parameters that control simulation behavior: (i) encoder/decoder parameters that configure the behavior of encoding/decoding components, (ii) fault distribution parameters that configure the simulated channel’s error model, and (iii) copy distribution parameters that configure the model used to represent strand copies that arise in the storage system. Within this configuration file, users can specify a parameter sweep to explore combinations of parameters such as error rate and inner code rates, and the fault injection tool will generate individual simulation jobs (batch jobs) for each unique parameter combination.</p>
      <fig position="float" id="btad572-F2">
        <label>Figure 2.</label>
        <caption>
          <p>End-to-end workflow of performing fault injection simulation using FrameD.</p>
        </caption>
        <graphic xlink:href="btad572f2" position="float"/>
      </fig>
      <p>During the evaluation of a simulation job, the input binary data is passed through the encoder to generate a library of synthetic DNA strands that subsequently sample the copy and error model distributions. The noisy set of strands passes through decoding, during which an attempt to reconstruct the original file is made, and information on errors and their locations are captured.</p>
      <p>The output of fault injection consists of a set of files placed in a unique directory for each unique parameter combination. This set of files specifies the parameters that were used for the experiment. This allows us to keep records of all parameters used for all experiments easily. In addition to these files, a statistics file is output by the simulation, aggregating counters that are used to track events during simulation such as decode failures, location of byte-errors within strands, location of base errors within strands, etc. FrameD allows statistics to be largely user-defined so that appropriate statistics can be chosen for a given experiment. (We do not list every statistic collected, since they are easy to change.) In the following section, we outline how this is done in FrameD. Our documentation provides a tutorial on fault injection using FrameD.</p>
    </sec>
    <sec>
      <title>3.2 Generating statistics</title>
      <p>The fault injection tool of FrameD captures general system-level information out of the box such as file decode rate and total byte-errors in the final file. Designers can also further leverage FrameD to generate custom statistics of a strand’s information at various points of the pipeline. The mechanism to achieve this is called a <bold>probe</bold>. A probe is a special pipeline component that does not modify information, but can interrogate the state of strands as they are encoded/decoded. To calculate error rates, a probe can capture the state of the information as it is encoded. This snapshot of the information can then be used as a comparison point during decoding to calculate statistics. Such statistics can be versatile and cover a wide range of error types including errors within the bases of a strand and the errors within bytes after decoding strands. A detailed example is provided in the <xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref>.</p>
    </sec>
    <sec>
      <title>3.3 Analyzing NGS data</title>
      <p>While this paper focuses on the <italic toggle="yes">in silico</italic> fault simulation tool of FrameD, we recognize that users of this framework would likely want to leverage the probes they created for fault injection simulation to analyze sequencing data from real experiments. In addition to the fault injection tool, we provide a tool that evaluates FrameD pipelines against next-generation sequencing (NGS) data. This additional tool allows developers the opportunity to determine which encoded DNA strand that a sequencing read originated from. This is something that is not known <italic toggle="yes">a priori</italic> and has to be computed since determining errors and their positions requires baseline information to compare against. Computing this mapping can be as simple as pairing a decoded index with the sequencing read identifier, or by computing the best alignments to a known set of strands (<xref rid="btad572-B21" ref-type="bibr">Sabary <italic toggle="yes">et al.</italic> 2021</xref>). Our codebase includes a mapping probe to perform this analysis along with detailed documentation on how to leverage it within FrameD for NGS data analysis.</p>
    </sec>
    <sec>
      <title>3.4 Handling computational scale</title>
      <p>When performing fault injection simulations, and decoding strands from real sequencing data, computational scalability quickly becomes an issue. FrameD enables scalability by identifying parallel units of work within the general flow of information in the framework. This allows any design to leverage paralellization transparently since FrameD can handle all communication of data. FrameD identifies parallelizaiton at three levels shown in <xref rid="btad572-F3" ref-type="fig">Fig. 3</xref>.</p>
      <fig position="float" id="btad572-F3">
        <label>Figure 3.</label>
        <caption>
          <p>Hierarchical parallelism leveraged by FrameD. Items grouped in the same level, e.g. MSA and inner decode, represent work that can be done in parallel using the same MPI ranks. <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>F</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>S</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>P</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> represent the total number of fault injection iterations, clusters, strands, and packets, respectively.</p>
        </caption>
        <graphic xlink:href="btad572f3" position="float"/>
      </fig>
      <p>In the first level, FrameD creates and submits individual batch jobs that can be processed by high-performance computing (HPC) workload managers like the <bold>“Slurm Workload Manager”</bold> or <bold>“IBM Spectrum LSF”</bold>. Within each batch job, FrameD can be configured to allocate compute resources in the form of MPI ranks to both fault injection iterations (second level) and work done during fault injection simulations like decoding individual strands, packet outer codes, and sequence alignment (third level). Allocation is up to the user. A user may allocate more MPI ranks to fault injection iterations if individual decode tasks are small, or the user may allocate most ranks to decoding to deal with sequencing data or to benchmark their pipeline. We utilize MPI at these levels due to its ease of communication and scalability. By targeting these clear large-grain units of work we can reach large numbers of computational cores while also keeping those resources busy.</p>
      <p>We recognize that there may be other user-defined opportunities for parallelization. For example, consolidating DNA strands using a clustering approach may benefit from MPI-based parallelization (<xref rid="btad572-B20" ref-type="bibr">Rashtchian <italic toggle="yes">et al.</italic> 2017</xref>). Because communication patterns are specific to such algorithms, we provide the user with the MPI communicator that is allocated to the given fault injection iteration. This allows the user to implement their own custom parallelization if so desired. See <xref rid="sup1" ref-type="supplementary-material">Supplementary Figure S4</xref> for FrameD’s communication patterns.</p>
      <p>While FrameD aids in scaling the number of strands and fault injection experiments performed, we point out that the rate in which information will be decoded/encoded will be greatly influenced by the chosen algorithms and their implementation details. A major implementation detail impacting performance is the chosen language, and while FrameD is fully implemented in Python, the implementation of a component can be in any language as long as it has an interface to Python. We find this to be an acceptable strategy since the infrastructure of FrameD is only focused on moving information between components that perform a bulk of the computation, which can be handled by a higher performing language.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Choosing designs with FrameD</title>
    <p>To demonstrate FrameD, we perform an analysis that serves as an example of how a DNA storage system designer may use the framework to determine the most cost-effective approach from a set of choices. In our example, we consider three different pipelines and two different error channel models, which are detailed in <xref rid="btad572-T1" ref-type="table">Table 1</xref>. Our encoder configurations are based on approaches taken in existing literature, and each leverages sequencing depth and resolves errors within a strand differently. The <bold>RS</bold> pipeline is representative of approaches that utilize conventional Reed–Solomon inner-error correction that deal with errors within strands post clustering and MSA (<xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>). Pipeline <bold>“HEDGES”</bold> contrasts with “<bold>RS”</bold> by directly resolving base errors within a strand with a convolutional code (HEDGES) without applying MSA first (<xref rid="btad572-B19" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>). Lastly, we consider an approach, “<bold>HEDGES-MSA”</bold>, that combines information aggregation of MSA with the convolutional inner encoding to remove remaining errors. For all MSA operations, we utilize Muscle (<xref rid="btad572-B8" ref-type="bibr">Edgar 2004</xref>). Provided each approach leverages error correction and sequencing depth differently, we are interested in studying whether or not there are benefits as the sequencing depth and error rate of the system evolve.</p>
    <table-wrap position="float" id="btad572-T1">
      <label>Table 1.</label>
      <caption>
        <p>Table of simulated parameters.<xref rid="tblfn1" ref-type="table-fn"><sup>a</sup></xref></p>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="char" char="(" span="1"/>
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="char" char="(" span="1"/>
          <col valign="top" align="center" span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="1" colspan="1">Pipeline Name</th>
            <th align="center" rowspan="1" colspan="1">Index length</th>
            <th align="center" rowspan="1" colspan="1">Binary transformation</th>
            <th align="center" rowspan="1" colspan="1">Transcoding</th>
            <th align="center" rowspan="1" colspan="1">Outer code</th>
            <th align="center" rowspan="1" colspan="1">MSA</th>
            <th align="center" rowspan="1" colspan="1">Depth</th>
            <th align="center" rowspan="1" colspan="1">Inner configuration</th>
            <th align="center" rowspan="1" colspan="1">Error model</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">
              <bold>“RS”</bold>
            </td>
            <td rowspan="1" colspan="1">4 bytes</td>
            <td rowspan="1" colspan="1">Randomize, <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td>
            <td rowspan="1" colspan="1"> <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mo>Ψ</mml:mo><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi mathvariant="script">B</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow><mml:mo>;</mml:mo><mml:mrow><mml:msubsup><mml:mi mathvariant="script">D</mml:mi><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:math></inline-formula></td>
            <td rowspan="1" colspan="1"> <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td>
            <td rowspan="1" colspan="1">Muscle</td>
            <td rowspan="1" colspan="1">[3–30]</td>
            <td rowspan="1" colspan="1">(1,55), (9,47) (14,42), (28,28)</td>
            <td rowspan="1" colspan="1">i.i.d.(1,5,10%), DNArSim</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">
              <bold>“HEDGES”</bold>
            </td>
            <td rowspan="1" colspan="1">4 bytes</td>
            <td rowspan="1" colspan="1">N/A</td>
            <td rowspan="1" colspan="1">HEDGES</td>
            <td rowspan="1" colspan="1"> <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td>
            <td rowspan="1" colspan="1">N/A</td>
            <td rowspan="1" colspan="1">N/A</td>
            <td rowspan="1" colspan="1">(0.167,4), (0.25,9) (0.5,24), (0.75,39)</td>
            <td rowspan="1" colspan="1">i.i.d.(1,5,10%), DNArSim</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">
              <bold>“HEDGES-MSA”</bold>
            </td>
            <td rowspan="1" colspan="1">4 bytes</td>
            <td rowspan="1" colspan="1">N/A</td>
            <td rowspan="1" colspan="1">HEDGES</td>
            <td rowspan="1" colspan="1"> <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td>
            <td rowspan="1" colspan="1">Muscle</td>
            <td rowspan="1" colspan="1">[3–30]</td>
            <td rowspan="1" colspan="1">(0.167,4), (0.25,9) (0.5,24), (0.75,39)</td>
            <td rowspan="1" colspan="1">i.i.d.(1,5,10%), DNArSim</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <fn id="tblfn1">
          <label>a</label>
          <p>For “<bold>RS</bold>” pipelines, the inner configuration tuples <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> indicate a <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> configuration of <italic toggle="yes">x</italic> redundant bytes per strand and <italic toggle="yes">y</italic> data bytes per strand. Similarly, for the “<bold>HEDGES</bold>” configurations, an <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> tuple indicates a code rate of <italic toggle="yes">x</italic> and bytes per strand of <italic toggle="yes">y</italic>. </p>
        </fn>
        <fn id="tblfn51">
          <p><inline-formula id="IE9000"><mml:math id="IM9000" display="inline" overflow="scroll"><mml:mi>R</mml:mi><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:math></inline-formula> indicates a Reed-Solomon code over the field <inline-formula id="IE9001"><mml:math id="IM9001" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, for the <bold>“RS”</bold> pipeline Randomize means we randomize binary information prior to the Reed-Solomon inner-error correction, and <inline-formula id="IE9002"><mml:math id="IM9002" display="inline" overflow="scroll"><mml:mstyle displaystyle="false"><mml:mo>Ψ</mml:mo><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi mathvariant="script">B</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow><mml:mo>;</mml:mo><mml:mrow><mml:msubsup><mml:mi mathvariant="script">D</mml:mi><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mstyle></mml:math></inline-formula> denotes a map between binary integers of length 2 (<inline-formula id="IE9003"><mml:math id="IM9003" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi mathvariant="script">B</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>) and DNA strings of length 1 (<inline-formula id="IE9004"><mml:math id="IM9004" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi mathvariant="script">D</mml:mi><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>).</p>
        </fn>
      </table-wrap-foot>
    </table-wrap>
    <p>DNA storage system designers are also faced with various technologies for writing/reading DNA, each with different error characteristics which can impact decoder choice. To demonstrate the evaluation of multiple error channels for the same pipelines, we consider two commonly used error models. One is a simple independent and identically distributed (i.i.d.) model for insertions, substitutions, and deletions. This model is typically used when considering NGS DNA readout (<xref rid="btad572-B19" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>, <xref rid="btad572-B25" ref-type="bibr">Yuan <italic toggle="yes">et al.</italic> 2022</xref>). However, it has been shown that an i.i.d. channel does not well represent nanopore errors due to the lack of support for burst errors (<xref rid="btad572-B12" ref-type="bibr">Hamoum <italic toggle="yes">et al.</italic> 2021</xref>). To study whether burst errors may change the choice of decoder, we also consider a publicly available model, DNArSim (<ext-link xlink:href="https://github.com/BHam-1/DNArSim" ext-link-type="uri">https://github.com/BHam-1/DNArSim</ext-link>), which describes conditional error probabilities that are derived from real sequencing data.</p>
    <p>A key piece of FrameD that enables our analysis is parallelism support which allows us to simulate 240 unique pipeline configurations, totaling over 650M fault-injected DNA strands, in a reasonable time frame on a HPC cluster. All simulations were completed within 4 days on an HPC cluster with specs outlined in <xref rid="btad572-T2" ref-type="table">Table 2</xref>. To verify that our infrastructure aids in scaling to larger simulations, we perform scalability experiments on one pipeline configuration with the core type fixed to <bold>“Intel Xeon Gold6226R”</bold>. We picked the “<bold>RS (9,47)”</bold> pipeline with read depth 25× and fault rate 10%. For this study, we simulate the pipeline only 368 times, and for a single core, we measured 20 325 s to complete the simulation. Because 1 MPI rank is allocated for scheduling, 31 additional compute ranks will populate all cores of a node. In this case the experiment finishes in 802 s (25.3× speedup). In the previous cases, we are able to exclusively use a node with no outside job interference; however, for multiple node runs we are not due to our cluster being a shared system. For 92 compute ranks, we measured a 65.99× speedup. These speedups indicate that FrameD is scalable.</p>
    <table-wrap position="float" id="btad572-T2">
      <label>Table 2.</label>
      <caption>
        <p>Overview of HPC system used for simulations, parallelization parameters, and simulation characteristics.<xref rid="tblfn2" ref-type="table-fn"><sup>a</sup></xref></p>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="center" span="1"/>
        </colgroup>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">Node architecture</td>
            <td rowspan="1" colspan="1">2 Intel Gold 6226/6130 192 GB RAM per node </td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Number of batch jobs</td>
            <td rowspan="1" colspan="1">240</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">MPI ranks to parallelize fault injection iterations</td>
            <td rowspan="1" colspan="1">128</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Fault injection iterations/pipeline</td>
            <td rowspan="1" colspan="1">1024</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Total strands generated</td>
            <td rowspan="1" colspan="1">654.7 million</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Binary data/fault injection run</td>
            <td rowspan="1" colspan="1">2.78 kB</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Minimum inner code samples</td>
            <td rowspan="1" colspan="1">51 200</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <fn id="tblfn2">
          <label>a</label>
          <p>MPI parallelization was utilized for only fault injection iterations.</p>
        </fn>
      </table-wrap-foot>
    </table-wrap>
    <p>We note that FrameD only provides the infrastructure for scalability, and that efficiently executing parallel units of work requires understanding the computational resources needed by each rank. For example, developers should be aware if utilizing all cores of a node exhausts all memory when parallelizing multiple instances of the inner code, and thus allocate ranks to their compute system appropriately. In our studied pipelines, we did not observe this need, however.</p>
    <p>This experiment also relies on other properties of FrameD. Importantly, the error model modularity allows us to apply multiple error models to each pipeline, and allows us to adopt significant portions of DNArSim with minor modifications to fit FrameD’s interface. This demonstrates FrameD’s ability to incorporate existing model implementations. Probes also play a major role in this analysis by providing decoding success rates of inner-error correction algorithms, a key value when determining storage system cost.</p>
    <p>In all experiments, we control for strand length by modulating the number of bits of each base-sequence when we change the density of the encoding. This ensures that all designs fall in a strand length space that is reasonable given the practical limitations of DNA synthesis technologies (<xref rid="btad572-B3" ref-type="bibr">Bishop <italic toggle="yes">et al.</italic> 2017</xref>). In our experiments, strand lengths fall in the range of 240–242 bp. We use ideal clustering in our experiments to isolate MSA error correction from approximations made by clustering algorithms (<xref rid="btad572-B20" ref-type="bibr">Rashtchian <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>).</p>
    <sec>
      <title>4.1 Comparing pipelines</title>
      <p>We compare pipelines by calculating the read and write code rates required for each pipeline to meet a target Mean Time to Failure (MTTF) of 10<sup>9</sup> accesses on 1 MB of data. We refer to these rates in terms of read and write density, each with units bits/base, and calculate them as the ratio of total bits read/written to the total number of bases read/written. Given that synthesis and sequencing cost is proportional to the number of bases, these metrics allow for technology-independent cost comparisons. A higher density is better. Write density is derived from the redundancy allocated to the inner and outer code. While read density considers encoding redundancy, it also considers the number of copies for each strand that were sequenced. We point out that the densities used for comparison are different from those provided in <xref rid="btad572-T1" ref-type="table">Table 1</xref> for the inner codes. While the rate of the inner code influences the success rate of decoding individual strands for a given channel error, additional outer code error correction is required to develop a robust system to meet reliability targets. Thus, our final code rate is a single metric that factors in both the code rate of the inner codes shown in <xref rid="btad572-T1" ref-type="table">Table 1</xref>, and the code rate necessary for the outer code after measuring strand decode probabilities from fault injection. Detailed calculations can be found in the <xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> section.</p>
      <p>With this analysis relying on estimating the decode rate of strands through the inner code, there must be enough inner code samples to build reasonable confidence for these rates. Controlling for a consistent strand length across inner encoding densities leads to some pipelines simulating more strands given a constant input binary file. However, we ensure that each inner code is simulated against at least 51k fault-injected strands.</p>
      <p>Lastly, our analysis does not consider the impact on the outer code from physical strand dropouts that can arise throughout the DNA storage life cycle (<xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>). FrameD supports dropout modeling, but our focus in this case study is on the inner code’s ability to cope with errors in the channel. Thus, the outer code is entirely provisioned based on how well each inner code is able to decode strands without error. However, our design choices hold when factoring in dropouts if assuming a fixed dropout rate per pipeline.</p>
    </sec>
  </sec>
  <sec>
    <title>5 Results</title>
    <p>To visualize the comparison of pipeline designs across sequencing depths, we plot the Pareto front for each pipeline with respect to read and write density. A Pareto front provides the design points that optimally trade off one cost for another such that a point is included if it provides an improvement in at least one cost. If a configuration offers no benefit, it is left out. Thus, every point in <xref rid="btad572-T1" ref-type="table">Table 1</xref> will not make it to the frontier. The pipeline frontiers for the i.i.d. error model for three error rates are shown in <xref rid="btad572-F4" ref-type="fig">Fig. 4</xref>. In this figure, each pipeline has a different color, and a point shape represents a configuration of the inner code of the pipeline. The black line connecting points represents the complete frontier across all pipelines.</p>
    <fig position="float" id="btad572-F4">
      <label>Figure 4.</label>
      <caption>
        <p>Optimal density design points for the three studied pipelines across the three studied i.i.d. error rates, 1%, 5%, and 10%. The dotted black line represents the total frontier composed of points from all of the studied pipelines. Each pipeline configuration is labeled by its inner code redundancy.</p>
      </caption>
      <graphic xlink:href="btad572f4" position="float"/>
    </fig>
    <p>For the lowest fault rate (1%), we find that the “<bold>RS”</bold> pipeline with 1 redundancy byte for error detection provides the best write density. This configuration indicates that MSA is able to resolve a majority of errors. However, at a read density of 0.4 this pipeline’s write density drops and gets overtaken in optimality by the “<bold>HEDGES”</bold> pipeline. This happens because MSA alone is not able to keep up with the HEDGES code’s error correction at lower read depths, requiring the “<bold>RS”</bold> pipeline to use considerably more outer encoding overhead. Interestingly, adding MSA to an inner code is not always best as shown by “<bold>HEDGES”</bold> enveloping “<bold>HEDGES-MSA”</bold>. The reason stems from the HEDGES code’s high decode rate of single strands at this error rate such that it is more likely to decode a strand by applying the code multiple times rather than aggregating the information in MSA.</p>
    <p>As the i.i.d. rate increases, MSA-based approaches become more prominent. For example, when the error rate is 5%, “<bold>HEDGES-MSA”</bold> outperforms “<bold>HEDGES”</bold> for the same inner code configuration. This is because it is now more cost-effective to use sequencing depth to reduce the per-base error rate with MSA, rather than applying the HEDGES code individually to each sequenced copy. The same occurs for a 10% error rate. Still, a pattern emerges where a non-optimal “<bold>HEDGES-MSA”</bold> approach becomes enveloped again by the “<bold>HEDGES”</bold> pipeline with the same configuration. We conclude from this that the optimality of using HEDGES with or without MSA is highly dependent on the error rate of the storage system, a conclusion a designer will not be able to come to without a simulation framework like FrameD.</p>
    <p>A pattern that emerges for “<bold>HEDGES”</bold> configurations is that when read density is increased by decreasing sequencing depth, at a certain point it no longer becomes cost-effective due to ballooning outer code overhead, making lower density inner codes preferred. This can be seen for a fault rate of 5% between “<bold>HEDGES:0.75”</bold> and “<bold>HEDGES:0.5”</bold>. However, this is not the case for “<bold>RS”</bold>, as no configurations that utilize less dense Reed–Solomon codes for error correction appear in <xref rid="btad572-F4" ref-type="fig">Fig. 4</xref>. This indicates that Reed–Solomon as an inner code is ineffective against insertions and deletions. We demonstrate this further in the <xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref>.</p>
    <p><xref rid="btad572-F5" ref-type="fig">Figure 5</xref> compares the three pipelines for nanopore-based fault injection. In contrast with the i.i.d. frontier, the complete frontier consists of points only from “<bold>HEDGES-MSA”</bold>. The main driving force of this is that nanopore sequencing has a higher frequency of burst errors compared to the i.i.d. model. Burst errors generate a decoder mismatch with the HEDGES code since this algorithm relies on guessing errors based on an i.i.d. error model. Thus, the HEDGES code experiences a large decode rate decrease unless MSA is applied beforehand to help resolve bursts. Another interesting component of <xref rid="btad572-F5" ref-type="fig">Fig. 5</xref> is that there is no configuration that just relies on MSA to resolve errors. These results showcase that with FrameD designers are able to define weaknesses in decoding algorithms and determine better pipeline combinations when faced with designing for different sequencing devices.</p>
    <fig position="float" id="btad572-F5">
      <label>Figure 5.</label>
      <caption>
        <p>Optimal frontiers obtained when the error injection model is based on nanopore sequencing technology.</p>
      </caption>
      <graphic xlink:href="btad572f5" position="float"/>
    </fig>
  </sec>
  <sec>
    <title>6 Conclusion</title>
    <p>We have shown that as work continues in the area of DNA storage systems there is an increasing number of unique pipelines that overlap in the components that they use. We introduce FrameD to address the void of tools available to the DNA data storage community, enabling the modularization of common algorithms and integrating fault injection models to provide a basis for fair system comparisons. Because of its foundation in the literature of DNA storage systems, FrameD provides designers with the ability to simulate a wide variety of storage systems. FrameD also provides transparent support for the parallelization of computational units of work such as individual strands and fault injection iterations, enabling the use of scalable high-performance computing systems. These features are demonstrated in our analysis of three pipelines that utilize the same components in different combinations across two error models representing different sequencing devices. In our analysis, the optimal pipeline choice and configuration depends both on the cost targets set by the designer and the target sequencing device. This highlights the basic need for DNA storage designers to have tools that can compare designs across a range of environments.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad572_Supplementary_Data</label>
      <media xlink:href="btad572_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>J.T. and A.K. are co-founders of DNAli Data Technologies. W.T. has two patents (8748091 and 8394584) licensed to ONT. W.T. has received travel funds to speak at symposia organized by ONT.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by the National Science Foundation [1901324 to K.V., K.L., A.K., J.T., 2027655 to K.V., K.L., A.K., J.T., P.H., W.T.].</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad572-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Anavy</surname><given-names>L</given-names></string-name>, <string-name><surname>Vaknin</surname><given-names>I</given-names></string-name>, <string-name><surname>Atar</surname><given-names>O</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Data storage in DNA with fewer synthesis cycles using composite DNA letters</article-title>. <source>Nat Biotechnol</source>  <year>2019</year>;<volume>37</volume>:<fpage>1229</fpage>–<lpage>36</lpage>.<pub-id pub-id-type="pmid">31501560</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Antkowiak</surname><given-names>PL</given-names></string-name>, <string-name><surname>Lietard</surname><given-names>J</given-names></string-name>, <string-name><surname>Darestani</surname><given-names>MZ</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Low cost DNA data storage using photolithographic synthesis and advanced information reconstruction and error correction</article-title>. <source>Nat Commun</source>  <year>2020</year>;<volume>11</volume>:<fpage>5345</fpage>.<pub-id pub-id-type="pmid">33093494</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B3">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Bishop</surname><given-names>B</given-names></string-name>, <string-name><surname>Mccorkle</surname><given-names>N</given-names></string-name>, <string-name><surname>Zhirnov</surname><given-names>V.</given-names></string-name></person-group>  <italic toggle="yes">Technology Working Group Meeting on Future DNA Synthesis Technologies</italic>, Durham, NC: Semiconductor Research Corporation, Arlington, VA, <year>2017</year>, p. <fpage>39</fpage>.</mixed-citation>
    </ref>
    <ref id="btad572-B4">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Bornholt</surname><given-names>J</given-names></string-name>, <string-name><surname>Lopez</surname><given-names>R</given-names></string-name>, <string-name><surname>Carmean</surname><given-names>DM</given-names></string-name></person-group>  <etal>et al</etal> A DNA-based archival storage system. In<italic toggle="yes">: Proceedings of the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS ’16</italic>. New York, NY: ACM, Atlanta, GA, <year>2016</year>, <fpage>637</fpage>–<lpage>49</lpage>. ISBN 978-1-4503-4091-5.</mixed-citation>
    </ref>
    <ref id="btad572-B5">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Chaykin</surname><given-names>G</given-names></string-name>, <string-name><surname>Furman</surname><given-names>N</given-names></string-name>, <string-name><surname>Sabary</surname><given-names>O</given-names></string-name></person-group>  <etal>et al</etal> DNA-Storalator: End-to-End DNA Storage Simulator. In: <italic toggle="yes">Non-Volatile Memories Workshop 2022</italic>, Oakland, CA: University of Calidfornia, San Diego, CA, <year>2022</year>.</mixed-citation>
    </ref>
    <ref id="btad572-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Choi</surname><given-names>Y</given-names></string-name>, <string-name><surname>Ryu</surname><given-names>T</given-names></string-name>, <string-name><surname>Lee</surname><given-names>AC</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>High information capacity DNA-based data storage with augmented encoding characters using degenerate bases</article-title>. <source>Sci Rep</source>  <year>2019</year>;<volume>9</volume>:<fpage>6582</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">31036920</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Church</surname><given-names>GM</given-names></string-name>, <string-name><surname>Gao</surname><given-names>Y</given-names></string-name>, <string-name><surname>Kosuri</surname><given-names>S.</given-names></string-name></person-group>  <article-title>Next-generation digital information storage in DNA</article-title>. <source>Science</source>  <year>2012</year>;<volume>337</volume>:<fpage>1628</fpage>.<pub-id pub-id-type="pmid">22903519</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Edgar</surname><given-names>RC.</given-names></string-name></person-group>  <article-title>MUSCLE: a multiple sequence alignment method with reduced time and space complexity</article-title>. <source>BMC Bioinformatics</source>  <year>2004</year>;<volume>5</volume>:<fpage>113</fpage>.<pub-id pub-id-type="pmid">15318951</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Erlich</surname><given-names>Y</given-names></string-name>, <string-name><surname>Zielinski</surname><given-names>D.</given-names></string-name></person-group>  <article-title>DNA fountain enables a robust and efficient storage architecture</article-title>. <source>Science</source>  <year>2017</year>;<volume>355</volume>:<fpage>950</fpage>–<lpage>4</lpage>.<pub-id pub-id-type="pmid">28254941</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Goldman</surname><given-names>N</given-names></string-name>, <string-name><surname>Bertone</surname><given-names>P</given-names></string-name>, <string-name><surname>Chen</surname><given-names>S</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Towards practical, high-capacity, low-maintenance information storage in synthesized DNA</article-title>. <source>Nature</source>  <year>2013</year>;<volume>494</volume>:<fpage>77</fpage>–<lpage>80</lpage>.<pub-id pub-id-type="pmid">23354052</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Grass</surname><given-names>RN</given-names></string-name>, <string-name><surname>Heckel</surname><given-names>R</given-names></string-name>, <string-name><surname>Puddu</surname><given-names>M</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Robust chemical preservation of digital information on DNA in silica with error-correcting codes</article-title>. <source>Angew Chem Int Ed Engl</source>  <year>2015</year>;<volume>54</volume>:<fpage>2552</fpage>–<lpage>5</lpage>.<pub-id pub-id-type="pmid">25650567</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B12">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Hamoum</surname><given-names>B</given-names></string-name>, <string-name><surname>Dupraz</surname><given-names>E</given-names></string-name>, <string-name><surname>Conde-Canencia</surname><given-names>L</given-names></string-name></person-group>  <etal>et al</etal> Channel model with memory for DNA data storage with nanopore sequencing. In: <italic toggle="yes">2021 11th International Symposium on Topics in Coding (ISTC)</italic>, New York, NY: IEEE, Quebec, Canada, <year>2021</year>, <fpage>1</fpage>–<lpage>5</lpage>.</mixed-citation>
    </ref>
    <ref id="btad572-B13">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Heckel</surname><given-names>R</given-names></string-name>, <string-name><surname>Shomorony</surname><given-names>I</given-names></string-name>, <string-name><surname>Ramchandran</surname><given-names>K</given-names></string-name></person-group>  <etal>et al</etal> Fundamental limits of DNA storage systems. In: <italic toggle="yes">2017 IEEE International Symposium on Information Theory (ISIT)</italic>, New York, NY: IEEE, Aachen, Germany, <year>2017</year>, 3130–3134. ISSN: <fpage>2157</fpage>–<lpage>8117</lpage>.</mixed-citation>
    </ref>
    <ref id="btad572-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lin</surname><given-names>KN</given-names></string-name>, <string-name><surname>Volkel</surname><given-names>K</given-names></string-name>, <string-name><surname>Tuck</surname><given-names>JM</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Dynamic and scalable DNA-based information storage</article-title>. <source>Nat Commun</source>  <year>2020</year>;<volume>11</volume>:<fpage>2981</fpage>.<pub-id pub-id-type="pmid">32532979</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marelli</surname><given-names>A</given-names></string-name>, <string-name><surname>Chiozzi</surname><given-names>T</given-names></string-name>, <string-name><surname>Battistini</surname><given-names>N</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Integrating FPGA acceleration in the DNAssim framework for faster DNA-based data storage simulations</article-title>. <source>Electronics</source>  <year>2023</year>;<volume>12</volume>:<fpage>2621</fpage>.</mixed-citation>
    </ref>
    <ref id="btad572-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Matange</surname><given-names>K</given-names></string-name>, <string-name><surname>Tuck</surname><given-names>JM</given-names></string-name>, <string-name><surname>Keung</surname><given-names>AJ.</given-names></string-name></person-group>  <article-title>DNA stability: a central design consideration for DNA data storage systems</article-title>. <source>Nat Commun</source>  <year>2021</year>;<volume>12</volume>:<fpage>1358</fpage>.<pub-id pub-id-type="pmid">33649304</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Organick</surname><given-names>L</given-names></string-name>, <string-name><surname>Ang</surname><given-names>SD</given-names></string-name>, <string-name><surname>Chen</surname><given-names>Y-J</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Random access in large-scale DNA data storage</article-title>. <source>Nat Biotechnol</source>  <year>2018</year>;<volume>36</volume>:<fpage>242</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">29457795</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Organick</surname><given-names>L</given-names></string-name>, <string-name><surname>Chen</surname><given-names>Y-J</given-names></string-name>, <string-name><surname>Dumas Ang</surname><given-names>S</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Probing the physical limits of reliable DNA data retrieval</article-title>. <source>Nat Commun</source>  <year>2020</year>;<volume>11</volume>:<fpage>616</fpage>.<pub-id pub-id-type="pmid">32001691</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Press</surname><given-names>WH</given-names></string-name>, <string-name><surname>Hawkins</surname><given-names>JA</given-names></string-name>, <string-name><surname>Jones</surname><given-names>SK</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>HEDGES error-correcting code for DNA storage corrects indels and allows sequence constraints</article-title>. <source>Proc Natl Acad Sci U S A</source>  <year>2020</year>;<volume>117</volume>:<fpage>18489</fpage>–<lpage>96</lpage>.<pub-id pub-id-type="pmid">32675237</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B20">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Rashtchian</surname><given-names>C</given-names></string-name>, <string-name><surname>Makarychev</surname><given-names>K</given-names></string-name>, <string-name><surname>Racz</surname><given-names>M</given-names></string-name></person-group>  <etal>et al</etal>  <part-title>Clustering billions of reads for DNA data storage</part-title>. In: <person-group person-group-type="editor"><string-name><surname>Guyon</surname><given-names>I</given-names></string-name></person-group> (ed.), <source>Advances in Neural Information Processing Systems 30</source>. Red Hook, NY: <publisher-name>Curran Associates Inc</publisher-name>, <year>2017</year>, <fpage>3360</fpage>–<lpage>71</lpage>.</mixed-citation>
    </ref>
    <ref id="btad572-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sabary</surname><given-names>O</given-names></string-name>, <string-name><surname>Orlev</surname><given-names>Y</given-names></string-name>, <string-name><surname>Shafir</surname><given-names>R</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>SOLQC: synthetic oligo library quality control tool</article-title>. <source>Bioinformatics</source>  <year>2021</year>;<volume>37</volume>:<fpage>720</fpage>–<lpage>2</lpage>.<pub-id pub-id-type="pmid">32840559</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tomek</surname><given-names>KJ</given-names></string-name>, <string-name><surname>Volkel</surname><given-names>K</given-names></string-name>, <string-name><surname>Simpson</surname><given-names>A</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Driving the scalability of DNA-based information storage systems</article-title>. <source>ACS Synth Biol</source>  <year>2019</year>;<volume>8</volume>:<fpage>1241</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">31117362</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tomek</surname><given-names>KJ</given-names></string-name>, <string-name><surname>Volkel</surname><given-names>K</given-names></string-name>, <string-name><surname>Indermaur</surname><given-names>EW</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Promiscuous molecules for smarter file operations in DNA-based data storage</article-title>. <source>Nat Commun</source>  <year>2021</year>;<volume>12</volume>:<fpage>3518</fpage>.<pub-id pub-id-type="pmid">34112775</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yazdi</surname><given-names>SMHT</given-names></string-name>, <string-name><surname>Gabrys</surname><given-names>R</given-names></string-name>, <string-name><surname>Milenkovic</surname><given-names>O.</given-names></string-name></person-group>  <article-title>Portable and error-free DNA-based data storage</article-title>. <source>Sci Rep</source>  <year>2017</year>;<volume>7</volume>:<fpage>5011</fpage>.<pub-id pub-id-type="pmid">28694453</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yuan</surname><given-names>L</given-names></string-name>, <string-name><surname>Xie</surname><given-names>Z</given-names></string-name>, <string-name><surname>Wang</surname><given-names>Y</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>DeSP: a systematic DNA storage error simulation pipeline</article-title>. <source>BMC Bioinformatics</source>  <year>2022</year>;<volume>23</volume>:<fpage>185</fpage>.<pub-id pub-id-type="pmid">35581548</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10563143</article-id>
    <article-id pub-id-type="pmid">37713474</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad572</article-id>
    <article-id pub-id-type="publisher-id">btad572</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>FrameD: framework for DNA-based data storage design, verification, and validation</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-5200-5909</contrib-id>
        <name>
          <surname>Volkel</surname>
          <given-names>Kevin D</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/conceptualization" degree-contribution="lead">Conceptualization</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Data curation" vocab-term-identifier="https://credit.niso.org/contributor-roles/data-curation" degree-contribution="lead">Data curation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Formal analysis" vocab-term-identifier="https://credit.niso.org/contributor-roles/formal-analysis" degree-contribution="lead">Formal analysis</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Methodology" vocab-term-identifier="https://credit.niso.org/contributor-roles/methodology" degree-contribution="lead">Methodology</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Software" vocab-term-identifier="https://credit.niso.org/contributor-roles/software" degree-contribution="lead">Software</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Validation" vocab-term-identifier="https://credit.niso.org/contributor-roles/validation" degree-contribution="lead">Validation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Visualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/visualization" degree-contribution="lead">Visualization</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - original draft" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-original-draft" degree-contribution="lead">Writing - original draft</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="lead">Writing - review &amp; editing</role>
        <aff><institution>Department of Electrical and Computer Engineering, North Carolina State University</institution>, Raleigh, NC, 27606, <country country="US">United States</country></aff>
        <xref rid="btad572-cor1" ref-type="corresp"/>
        <!--kvolkel@ncsu.edu-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Lin</surname>
          <given-names>Kevin N</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="supporting">Writing - review &amp; editing</role>
        <aff><institution>Department of Chemical and Biomolecular Engineering, North Carolina State University</institution>, Raleigh, NC, 27695, <country country="US">United States</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Hook</surname>
          <given-names>Paul W</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="supporting">Writing - review &amp; editing</role>
        <aff><institution>Department of Biomedical Engineering, Johns Hopkins University</institution>, Baltimore, MD, 21218, <country country="US">United States</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-2083-6027</contrib-id>
        <name>
          <surname>Timp</surname>
          <given-names>Winston</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Funding acquisition" vocab-term-identifier="https://credit.niso.org/contributor-roles/funding-acquisition" degree-contribution="equal">Funding acquisition</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="https://credit.niso.org/contributor-roles/investigation" degree-contribution="equal">Investigation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Project administration" vocab-term-identifier="https://credit.niso.org/contributor-roles/project-administration" degree-contribution="equal">Project administration</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Supervision" vocab-term-identifier="https://credit.niso.org/contributor-roles/supervision" degree-contribution="supporting">Supervision</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="supporting">Writing - review &amp; editing</role>
        <aff><institution>Department of Biomedical Engineering, Johns Hopkins University</institution>, Baltimore, MD, 21218, <country country="US">United States</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8958-1232</contrib-id>
        <name>
          <surname>Keung</surname>
          <given-names>Albert J</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Funding acquisition" vocab-term-identifier="https://credit.niso.org/contributor-roles/funding-acquisition" degree-contribution="equal">Funding acquisition</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="https://credit.niso.org/contributor-roles/investigation" degree-contribution="equal">Investigation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Project administration" vocab-term-identifier="https://credit.niso.org/contributor-roles/project-administration" degree-contribution="equal">Project administration</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Supervision" vocab-term-identifier="https://credit.niso.org/contributor-roles/supervision" degree-contribution="supporting">Supervision</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="supporting">Writing - review &amp; editing</role>
        <aff><institution>Department of Chemical and Biomolecular Engineering, North Carolina State University</institution>, Raleigh, NC, 27695, <country country="US">United States</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8975-0294</contrib-id>
        <name>
          <surname>Tuck</surname>
          <given-names>James M</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/conceptualization" degree-contribution="lead">Conceptualization</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Funding acquisition" vocab-term-identifier="https://credit.niso.org/contributor-roles/funding-acquisition" degree-contribution="equal">Funding acquisition</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="https://credit.niso.org/contributor-roles/investigation" degree-contribution="equal">Investigation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Project administration" vocab-term-identifier="https://credit.niso.org/contributor-roles/project-administration" degree-contribution="equal">Project administration</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Resources" vocab-term-identifier="https://credit.niso.org/contributor-roles/resources" degree-contribution="lead">Resources</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Software" vocab-term-identifier="https://credit.niso.org/contributor-roles/software" degree-contribution="supporting">Software</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Supervision" vocab-term-identifier="https://credit.niso.org/contributor-roles/supervision" degree-contribution="lead">Supervision</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - original draft" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-original-draft" degree-contribution="lead">Writing - original draft</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="lead">Writing - review &amp; editing</role>
        <aff><institution>Department of Electrical and Computer Engineering, North Carolina State University</institution>, Raleigh, NC, 27606, <country country="US">United States</country></aff>
        <xref rid="btad572-cor1" ref-type="corresp"/>
        <!--jtuck@ncsu.edu-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Kelso</surname>
          <given-names>Janet</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad572-cor1">Corresponding authors. Department of Electrical and Computer Engineering, North Carolina State University, 890 Oval Drive Raleigh, NC, 27606, United States. E-mails: <email>kvolkel@ncsu.edu</email> (K.D.V.) and <email>jtuck@ncsu.edu</email> (J.M.T.)</corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>10</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-09-15">
      <day>15</day>
      <month>9</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>15</day>
      <month>9</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>10</issue>
    <elocation-id>btad572</elocation-id>
    <history>
      <date date-type="received">
        <day>28</day>
        <month>3</month>
        <year>2023</year>
      </date>
      <date date-type="rev-recd">
        <day>27</day>
        <month>7</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>04</day>
        <month>9</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>13</day>
        <month>9</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>10</day>
        <month>10</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad572.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>DNA-based data storage is a quickly growing field that hopes to harness the massive theoretical information density of DNA molecules to produce a competitive next-generation storage medium suitable for archival data. In recent years, many DNA-based storage system designs have been proposed. Given that no common infrastructure exists for simulating these storage systems, comparing many different designs along with many different error models is increasingly difficult. To address this challenge, we introduce FrameD, a simulation infrastructure for DNA storage systems that leverages the underlying modularity of DNA storage system designs to provide a framework to express different designs while being able to reuse common components.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We demonstrate the utility of FrameD and the need for a common simulation platform using a case study. Our case study compares designs that utilize strand copies differently, some that align strand copies using multiple sequence alignment algorithms and others that do not. We found that the choice to include multiple sequence alignment in the pipeline is dependent on the error rate and the type of errors being injected and is not always beneficial. In addition to supporting a wide range of designs, FrameD provides the user with transparent parallelism to deal with a large number of reads from sequencing and the need for many fault injection iterations. We believe that FrameD fills a void in the tools publicly available to the DNA storage community by providing a modular and extensible framework with support for massive parallelism. As a result, it will help accelerate the design process of future DNA-based storage systems.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>The source code for FrameD along with the data generated during the demonstration of FrameD is available in a public Github repository at <ext-link xlink:href="https://github.com/dna-storage/framed" ext-link-type="uri">https://github.com/dna-storage/framed</ext-link>, (<ext-link xlink:href="https://dx.doi.org/10.5281/zenodo.7757762" ext-link-type="uri">https://dx.doi.org/10.5281/zenodo.7757762</ext-link>).</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Science Foundation</institution>
            <institution-id institution-id-type="DOI">10.13039/100000001</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>1901324</award-id>
        <award-id>2027655</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>The world is generating data faster and in larger quantities than ever before, raising concerns that traditional storage technologies will not scale to keep up with demand. In the search for new technologies, DNA has gained broad interest due to its superior density and longevity compared to magnetic tape and hard disk drives. Since the early work of <xref rid="btad572-B7" ref-type="bibr">Church <italic toggle="yes">et al.</italic> (2012)</xref> and <xref rid="btad572-B10" ref-type="bibr">Goldman <italic toggle="yes">et al.</italic> (2013)</xref> demonstrating the ability to store information in DNA strands using modern DNA technology, there have been a range of studies answering important questions such as data addressability (<xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B18" ref-type="bibr">2020, Tomek <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B23" ref-type="bibr">2021, Lin <italic toggle="yes">et al.</italic> 2020</xref>), synthesis efficiency (<xref rid="btad572-B1" ref-type="bibr">Anavy <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B6" ref-type="bibr">Choi <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>), DNA reusability (<xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B14" ref-type="bibr">Lin <italic toggle="yes">et al.</italic> 2020</xref>), error rates associated with a variety of techniques (<xref rid="btad572-B11" ref-type="bibr">Grass <italic toggle="yes">et al.</italic> 2015</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B16" ref-type="bibr">Matange <italic toggle="yes">et al.</italic> 2021</xref>), and the density that can be achieved in DNA molecules (<xref rid="btad572-B10" ref-type="bibr">Goldman <italic toggle="yes">et al.</italic> 2013</xref>, <xref rid="btad572-B9" ref-type="bibr">Erlich and Zielinski 2017</xref>, <xref rid="btad572-B1" ref-type="bibr">Anavy <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B6" ref-type="bibr">Choi <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>). This vast knowledge base of DNA-based data storage comes with an equally expansive space of possible implementation approaches for which little if any consensus has been reached. Compounding the problem of choosing any one approach is the fact that there is a lack of common infrastructure that enables the comparison of these designs in a fair and reproducible manner.</p>
    <p>To address the growing need for tools to analyze and compare DNA storage systems, we present FrameD, a software framework for designing, verifying, and validating DNA storage system designs. FrameD is not a library of every conceivable error correction algorithm, instead, it provides a fault-injection-based test bed in which DNA storage systems can be evaluated. Constructing FrameD requires several considerations. One being FrameD’s flexibility in terms of what DNA storage systems can be represented. To address this issue, we use current literature to inform the construction of a model that can be used as a basis in which a range of DNA storage systems can be expressed. With this model, we are able to implement an execution back-end that executes a set of encoding steps that adhere to the model’s interfaces. Thus, for an encoding to be used in FrameD, a user need only follow the interface specification. This execution model back-end also provides transparent support for necessary bookkeeping steps like DNA strand indexing and dropout inference, allowing the user to focus on the details of their algorithms.</p>
    <p>Another issue that needs to be considered when simulating DNA storage systems is computational scale issues that arise from several sources. One source is the size of the possible parameter space of interest with regards to an encoding/decoding algorithm, as exploring combinations of parameters can easily lead to exponential growth in the number of experiments. Another source of computational scale arises from the necessity to perform fault injection experiments 1000’s of times to achieve narrow confidence intervals on key outcomes such as strand and file decode rates. Compounding each source of computational overhead is the scale of sequencing data that needs to be processed. To support scalability, FrameD utilizes batch jobs to parallelize individual configuration simulations and Message Passing Interface (MPI) to parallelize units of work within those batch jobs like strand decoding and fault injection iterations. FrameD implements the parallelization support transparently such that users do not need to manage parallelization communication. Instead, the user just specifies their configurations and the computational resources to allocate to each.</p>
    <p>We demonstrate the utility of FrameD by performing a comparison between three designs across two error models representing different sequencing technology. We evaluate 240 total configurations, generating a total of 654 million fault-injected DNA strands, and analyze the read and write density trade-off between the three designs. Our results show that the optimal design approach depends on the designer’s read and write cost targets and the target sequencing technology, and bolsters our claim that a common simulation infrastructure is needed.</p>
  </sec>
  <sec>
    <title>2 The case for DNA storage simulation infrastructure</title>
    <p>Before discussing details of FrameD, we present a study of current literature to further motivate the need for a DNA simulation infrastructure and to understand the basic components that such an infrastructure will need to support. For our review, we choose 13 previous works that implement end-to-end DNA storage systems. We selected these works because they are representative of different approaches that have been taken since the revival of DNA data storage started by Goldman <italic toggle="yes">et al.</italic>’s work. Thus, we should be able to make conclusions about consistent approaches taken in DNA storage design, while also being able to account for the inclusion of novel techniques from each individual work. Detailed organization of these works is presented in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>.</p>
    <p>We find that transformations applied to information can be organized hierarchically in two levels. At the first level, we identify two broad categories we refer to as “<bold>Single Strand”</bold> and “<bold>Multi-Strand”</bold> transformations. Single Strand transformations focus on processing information stored in a single molecule of DNA, while the Multi-Strand processes relate to processing information stored within a group of molecules.</p>
    <p>Under the Single Strand category, we found three typical transformation steps: “<bold>Binary Transformation”</bold>, “<bold>Transcoding”</bold>, and “<bold>Functional Site Encoding”</bold>. Each of these sub-categories modify the data present on a single DNA molecule in their own way. A Binary Transformation modifies the raw digital information before it is represented as DNA molecule. Such modifications typically included parity checks (<xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>), Reed–Solomon codes (<xref rid="btad572-B11" ref-type="bibr">Grass <italic toggle="yes">et al.</italic> 2015</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>), and base conversions from the typical Base-2 binary representation of digital information to a numerical base that may be more convenient for a certain Reed-Solomon field (<xref rid="btad572-B11" ref-type="bibr">Grass <italic toggle="yes">et al.</italic> 2015</xref>, <xref rid="btad572-B1" ref-type="bibr">Anavy <italic toggle="yes">et al.</italic> 2019</xref>). The Transcoding category consists of processes that represent the digital source information in terms of a DNA molecule. While transcoding can be as simple as a base-conversion to base-4 (<xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>), approaches typically consider constraints such as GC balance (<xref rid="btad572-B24" ref-type="bibr">Yazdi <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad572-B19" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>) and homopolymers (<xref rid="btad572-B10" ref-type="bibr">Goldman <italic toggle="yes">et al.</italic> 2013</xref>, <xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>), yielding a range of options with different error correction and density properties. The final Single Strand pass, Functional Site Encoding, is not inherently dependent on the raw information stored but instead includes DNA substrings in the stored molecules to facilitate functionality. Functionality encoding includes adding primers for polymerase chain reaction (PCR) random access (<xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>), T7 promotor sites for RNA transcription (<xref rid="btad572-B14" ref-type="bibr">Lin <italic toggle="yes">et al.</italic> 2020</xref>), and restriction sites for DNA fragmentation (<xref rid="btad572-B23" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2021</xref>).</p>
    <p>Under the Multi-Strand category, we determined three distinct processing steps: “<bold>Outer Code”</bold>, “<bold>Consolidation”</bold>, and “<bold>Reconstruction”</bold>. The Outer Code step is similar to the Binary Transformation step of the single strand category, except error correction codes like Reed–Solomon are applied using the data of a group of strands so that errors can be corrected using information dispersed across DNA molecules (<xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B19" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>, <xref rid="btad572-B23" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2021</xref>). This error correction technique is crucial for dealing with the occurrence of missing DNA molecules, a common error mode of DNA storage systems (<xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B19" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>). Another issue that a DNA storage system design must address is the reconstruction of the order of information. Representing arbitrarily large sets of information requires storing subsets of information on individual DNA molecules because synthetic DNA of arbitrary length is not feasible to synthesize. Provided mixtures of DNA molecules are not guaranteed to be sequenced in any particular order, a Reconstruction strategy is needed to map a DNA molecule to its place in the complete dataset. Because of its optimality regarding density (<xref rid="btad572-B13" ref-type="bibr">Heckel <italic toggle="yes">et al.</italic> 2017</xref>), an “<bold>indexing”</bold> strategy that stores an ordering integer in each strand is a common approach (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>). Lastly, because DNA storage systems typically generate multiple copies of each transcoded DNA molecule by way of synthesis, sequencing, or amplification (<xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B24" ref-type="bibr">Yazdi <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>), a processing step which we call Consolidation is required to generate one final representative of the information of a stored DNA molecule. This can be as simple as detecting and removing bad strands using error correction until finding a valid strand (<xref rid="btad572-B10" ref-type="bibr">Goldman <italic toggle="yes">et al.</italic> 2013</xref>, <xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad572-B19" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>), or bioinformatics tools such as multiple sequence alignment (MSA) algorithms can be employed to determine a consensus sequence (<xref rid="btad572-B24" ref-type="bibr">Yazdi <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>).</p>
    <p>From this discussion, we can immediately see that the transformation of information within a DNA storage system can be described by a small set of general categories. This indicates that an infrastructure which provides support for routing this information between these categories can be effective in representing many unique DNA storage systems.</p>
    <p>Given this observation, we consider how prior works in DNA storage simulation support general encoding and simulation environments. DNA-Storalator is a DNA storage system simulator that focuses on evaluating clustering and reconstruction algorithms that work to construct a representative DNA strand from a cluster of noisy versions. However, DNA-Storalator does not offer support for the evaluation of Outer, Binary Transformation, or Transcoding codecs (<xref rid="btad572-B5" ref-type="bibr">Chaykin <italic toggle="yes">et al.</italic> 2022</xref>). Furthermore, the only error models supported are those which are generated by wet-lab experiments (<xref rid="btad572-B21" ref-type="bibr">Sabary <italic toggle="yes">et al.</italic> 2021</xref>). While these may be accurate for a given DNA storage system implementation, allowing for user-defined error models allows for testing codecs over a wider set of cases. DNAssim offers flexible fault and coverage models, along with outer code evaluation. However, DNAssim does not consider the complex space of inner code design and chooses to only use binary to base-4 conversion as its transcoding method (<xref rid="btad572-B15" ref-type="bibr">Marelli <italic toggle="yes">et al.</italic> 2023</xref>). Another simulator is DeSP; however, it is only a tool that provides error injections and strand distribution changes, and so it is not a framework for evaluating different encoding designs (<xref rid="btad572-B25" ref-type="bibr">Yuan <italic toggle="yes">et al.</italic> 2022</xref>). In the following sections, we discuss how FrameD provides a framework in which a rich space of encodings can be evaluated using flexible error models in a scalable environment.</p>
  </sec>
  <sec>
    <title>3 FrameD</title>
    <p>We leverage categorical overlap of designs by understanding that there is a logical ordering in which the information transformations can be applied. This ordering is illustrated in <xref rid="btad572-F1" ref-type="fig">Fig. 1</xref>, where information flows from left to right. First, information in a file is broken into contiguous pieces called “<bold>packets”</bold>. Packets serve as the scope for the outer encoding, allowing for designers to choose a granularity for the outer error correction algorithm. Before the outer code is applied, the packet is broken down into “<bold>base-sequences”</bold>, contiguous sections of information that will be stored on each DNA molecule. A packet’s base-sequences are then processed by the outer code, which generates indices automatically for each base-sequence while also adding additional error correction base-sequences. FrameD defaults to basic incremental integers for indexing, but provides the designer the interface to implement special indexes like the Luby Seed for Fountain codes. Each indexed base-sequence is passed through the “<bold>inner-encoder”</bold>, a series of steps consisting of the Single Strand operations.</p>
    <fig position="float" id="btad572-F1">
      <label>Figure 1.</label>
      <caption>
        <p>Model used by FrameD to represent encoding for DNA storage systems. Included in this figure is an example of the state of information throughout the pipeline, where initially data is in its original byte representation, then converted to base-3 and subsequently DNA, and finally stored with prepend/appended DNA strings typically done for PCR primer functionality.</p>
      </caption>
      <graphic xlink:href="btad572f1" position="float"/>
    </fig>
    <p>The decode phase is mostly identical to encoding, except that the transformations made by each pass are reversed. However, decoding must have a mechanism to deal with multiple copies per encoded strand. We found two approaches that can be taken. One is to first cluster the DNA strands input to the decoder based on similarity scores like edit distance or using a MinHash-based approaches (<xref rid="btad572-B20" ref-type="bibr">Rashtchian <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>). Then MSA algorithms, such as Muscle, can be used to aggregate information across strands and help resolve errors through consensus voting (<xref rid="btad572-B8" ref-type="bibr">Edgar 2004</xref>, <xref rid="btad572-B24" ref-type="bibr">Yazdi <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>). To account for these approaches, we provide users the ability to add MSA and clustering steps to the pipeline before the inner encoding is reversed. This process is outlined in the <xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref>. Another approach is to consolidate the strands after completing the inner code, throwing out strands that may violate error checks, and coming to a consensus on the digital representation of information. FrameD supports the use of either approach, or even both.</p>
    <p>The pipelined approach of FrameD provides DNA storage system designers several benefits. By implementing the routing of information between components, the designer can focus on their algorithms as long as it adheres to the pipeline’s information transformation interface. Further, by breaking larger steps, e.g. inner code, down into smaller sub-components, a new unique inner code can be constructed by modifying just a single component without needing to re-implement the other algorithms that constitute the inner code. For example, one could change their Binary Transformation pass while keeping the same implementations of the Transcoding and Functional Site Encoding passes. As long as the new component adheres to its prescribed interface given the type of transformation it performs, no other work is required outside of implementing the new algorithm.</p>
    <p><xref rid="btad572-F1" ref-type="fig">Figure 1</xref> shows only three components within the inner encoding and one outer code component; however, we point out that both can consist of an arbitrary number. That is, Outer Codes, Binary Transformations, and Functional Site Encoding can be cascaded an arbitrary amount. For example, one may have two binary transformations, one to modify the numerical base representation of data and another one to convert to a Reed–Solomon code. We leave out Transcoding from this list, since transcoding binary information to DNA can only occur once. Details on how indexing is supported in cascaded Outer Codes is discussed in the <xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref>. FrameD also leverages transformation type interfaces to provide validation checks for the designer to ensure that there is a logical arrangement of components.</p>
    <sec>
      <title>3.1 Fault injection workflow</title>
      <p>FrameD includes a simulation tool based on a fault injection methodology for evaluating DNA storage system designs. Fault injection simulation provides several benefits over the analytical model. Fault injection experiments provide the ability to quickly estimate properties of specific steps of the encoding/decoding processes. For example, fault injection experiments can determine a rate at which strands can be successfully decoded using a specified error model. This information can be used to verify analytical results or to derive parameters for a full-scale DNA storage system. Fault injection models are also more flexible, where changing an encoding or error model can make deriving a new analytical model difficult. Lastly, a fault injection framework exercises actual algorithm implementations against strands with errors in them, allowing for benchmarking and debugging that an analytical model cannot provide.</p>
      <p><xref rid="btad572-F2" ref-type="fig">Figure 2</xref> overviews the workflow of using FrameD for fault injection. First, a user develops a JSON configuration file which includes a path to the binary data to be converted to DNA, along with details of three general categories of parameters that control simulation behavior: (i) encoder/decoder parameters that configure the behavior of encoding/decoding components, (ii) fault distribution parameters that configure the simulated channel’s error model, and (iii) copy distribution parameters that configure the model used to represent strand copies that arise in the storage system. Within this configuration file, users can specify a parameter sweep to explore combinations of parameters such as error rate and inner code rates, and the fault injection tool will generate individual simulation jobs (batch jobs) for each unique parameter combination.</p>
      <fig position="float" id="btad572-F2">
        <label>Figure 2.</label>
        <caption>
          <p>End-to-end workflow of performing fault injection simulation using FrameD.</p>
        </caption>
        <graphic xlink:href="btad572f2" position="float"/>
      </fig>
      <p>During the evaluation of a simulation job, the input binary data is passed through the encoder to generate a library of synthetic DNA strands that subsequently sample the copy and error model distributions. The noisy set of strands passes through decoding, during which an attempt to reconstruct the original file is made, and information on errors and their locations are captured.</p>
      <p>The output of fault injection consists of a set of files placed in a unique directory for each unique parameter combination. This set of files specifies the parameters that were used for the experiment. This allows us to keep records of all parameters used for all experiments easily. In addition to these files, a statistics file is output by the simulation, aggregating counters that are used to track events during simulation such as decode failures, location of byte-errors within strands, location of base errors within strands, etc. FrameD allows statistics to be largely user-defined so that appropriate statistics can be chosen for a given experiment. (We do not list every statistic collected, since they are easy to change.) In the following section, we outline how this is done in FrameD. Our documentation provides a tutorial on fault injection using FrameD.</p>
    </sec>
    <sec>
      <title>3.2 Generating statistics</title>
      <p>The fault injection tool of FrameD captures general system-level information out of the box such as file decode rate and total byte-errors in the final file. Designers can also further leverage FrameD to generate custom statistics of a strand’s information at various points of the pipeline. The mechanism to achieve this is called a <bold>probe</bold>. A probe is a special pipeline component that does not modify information, but can interrogate the state of strands as they are encoded/decoded. To calculate error rates, a probe can capture the state of the information as it is encoded. This snapshot of the information can then be used as a comparison point during decoding to calculate statistics. Such statistics can be versatile and cover a wide range of error types including errors within the bases of a strand and the errors within bytes after decoding strands. A detailed example is provided in the <xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref>.</p>
    </sec>
    <sec>
      <title>3.3 Analyzing NGS data</title>
      <p>While this paper focuses on the <italic toggle="yes">in silico</italic> fault simulation tool of FrameD, we recognize that users of this framework would likely want to leverage the probes they created for fault injection simulation to analyze sequencing data from real experiments. In addition to the fault injection tool, we provide a tool that evaluates FrameD pipelines against next-generation sequencing (NGS) data. This additional tool allows developers the opportunity to determine which encoded DNA strand that a sequencing read originated from. This is something that is not known <italic toggle="yes">a priori</italic> and has to be computed since determining errors and their positions requires baseline information to compare against. Computing this mapping can be as simple as pairing a decoded index with the sequencing read identifier, or by computing the best alignments to a known set of strands (<xref rid="btad572-B21" ref-type="bibr">Sabary <italic toggle="yes">et al.</italic> 2021</xref>). Our codebase includes a mapping probe to perform this analysis along with detailed documentation on how to leverage it within FrameD for NGS data analysis.</p>
    </sec>
    <sec>
      <title>3.4 Handling computational scale</title>
      <p>When performing fault injection simulations, and decoding strands from real sequencing data, computational scalability quickly becomes an issue. FrameD enables scalability by identifying parallel units of work within the general flow of information in the framework. This allows any design to leverage paralellization transparently since FrameD can handle all communication of data. FrameD identifies parallelizaiton at three levels shown in <xref rid="btad572-F3" ref-type="fig">Fig. 3</xref>.</p>
      <fig position="float" id="btad572-F3">
        <label>Figure 3.</label>
        <caption>
          <p>Hierarchical parallelism leveraged by FrameD. Items grouped in the same level, e.g. MSA and inner decode, represent work that can be done in parallel using the same MPI ranks. <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>F</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>S</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mi>P</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> represent the total number of fault injection iterations, clusters, strands, and packets, respectively.</p>
        </caption>
        <graphic xlink:href="btad572f3" position="float"/>
      </fig>
      <p>In the first level, FrameD creates and submits individual batch jobs that can be processed by high-performance computing (HPC) workload managers like the <bold>“Slurm Workload Manager”</bold> or <bold>“IBM Spectrum LSF”</bold>. Within each batch job, FrameD can be configured to allocate compute resources in the form of MPI ranks to both fault injection iterations (second level) and work done during fault injection simulations like decoding individual strands, packet outer codes, and sequence alignment (third level). Allocation is up to the user. A user may allocate more MPI ranks to fault injection iterations if individual decode tasks are small, or the user may allocate most ranks to decoding to deal with sequencing data or to benchmark their pipeline. We utilize MPI at these levels due to its ease of communication and scalability. By targeting these clear large-grain units of work we can reach large numbers of computational cores while also keeping those resources busy.</p>
      <p>We recognize that there may be other user-defined opportunities for parallelization. For example, consolidating DNA strands using a clustering approach may benefit from MPI-based parallelization (<xref rid="btad572-B20" ref-type="bibr">Rashtchian <italic toggle="yes">et al.</italic> 2017</xref>). Because communication patterns are specific to such algorithms, we provide the user with the MPI communicator that is allocated to the given fault injection iteration. This allows the user to implement their own custom parallelization if so desired. See <xref rid="sup1" ref-type="supplementary-material">Supplementary Figure S4</xref> for FrameD’s communication patterns.</p>
      <p>While FrameD aids in scaling the number of strands and fault injection experiments performed, we point out that the rate in which information will be decoded/encoded will be greatly influenced by the chosen algorithms and their implementation details. A major implementation detail impacting performance is the chosen language, and while FrameD is fully implemented in Python, the implementation of a component can be in any language as long as it has an interface to Python. We find this to be an acceptable strategy since the infrastructure of FrameD is only focused on moving information between components that perform a bulk of the computation, which can be handled by a higher performing language.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Choosing designs with FrameD</title>
    <p>To demonstrate FrameD, we perform an analysis that serves as an example of how a DNA storage system designer may use the framework to determine the most cost-effective approach from a set of choices. In our example, we consider three different pipelines and two different error channel models, which are detailed in <xref rid="btad572-T1" ref-type="table">Table 1</xref>. Our encoder configurations are based on approaches taken in existing literature, and each leverages sequencing depth and resolves errors within a strand differently. The <bold>RS</bold> pipeline is representative of approaches that utilize conventional Reed–Solomon inner-error correction that deal with errors within strands post clustering and MSA (<xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>). Pipeline <bold>“HEDGES”</bold> contrasts with “<bold>RS”</bold> by directly resolving base errors within a strand with a convolutional code (HEDGES) without applying MSA first (<xref rid="btad572-B19" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>). Lastly, we consider an approach, “<bold>HEDGES-MSA”</bold>, that combines information aggregation of MSA with the convolutional inner encoding to remove remaining errors. For all MSA operations, we utilize Muscle (<xref rid="btad572-B8" ref-type="bibr">Edgar 2004</xref>). Provided each approach leverages error correction and sequencing depth differently, we are interested in studying whether or not there are benefits as the sequencing depth and error rate of the system evolve.</p>
    <table-wrap position="float" id="btad572-T1">
      <label>Table 1.</label>
      <caption>
        <p>Table of simulated parameters.<xref rid="tblfn1" ref-type="table-fn"><sup>a</sup></xref></p>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="char" char="(" span="1"/>
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="char" char="(" span="1"/>
          <col valign="top" align="center" span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="1" colspan="1">Pipeline Name</th>
            <th align="center" rowspan="1" colspan="1">Index length</th>
            <th align="center" rowspan="1" colspan="1">Binary transformation</th>
            <th align="center" rowspan="1" colspan="1">Transcoding</th>
            <th align="center" rowspan="1" colspan="1">Outer code</th>
            <th align="center" rowspan="1" colspan="1">MSA</th>
            <th align="center" rowspan="1" colspan="1">Depth</th>
            <th align="center" rowspan="1" colspan="1">Inner configuration</th>
            <th align="center" rowspan="1" colspan="1">Error model</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">
              <bold>“RS”</bold>
            </td>
            <td rowspan="1" colspan="1">4 bytes</td>
            <td rowspan="1" colspan="1">Randomize, <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td>
            <td rowspan="1" colspan="1"> <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mo>Ψ</mml:mo><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi mathvariant="script">B</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow><mml:mo>;</mml:mo><mml:mrow><mml:msubsup><mml:mi mathvariant="script">D</mml:mi><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:math></inline-formula></td>
            <td rowspan="1" colspan="1"> <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td>
            <td rowspan="1" colspan="1">Muscle</td>
            <td rowspan="1" colspan="1">[3–30]</td>
            <td rowspan="1" colspan="1">(1,55), (9,47) (14,42), (28,28)</td>
            <td rowspan="1" colspan="1">i.i.d.(1,5,10%), DNArSim</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">
              <bold>“HEDGES”</bold>
            </td>
            <td rowspan="1" colspan="1">4 bytes</td>
            <td rowspan="1" colspan="1">N/A</td>
            <td rowspan="1" colspan="1">HEDGES</td>
            <td rowspan="1" colspan="1"> <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td>
            <td rowspan="1" colspan="1">N/A</td>
            <td rowspan="1" colspan="1">N/A</td>
            <td rowspan="1" colspan="1">(0.167,4), (0.25,9) (0.5,24), (0.75,39)</td>
            <td rowspan="1" colspan="1">i.i.d.(1,5,10%), DNArSim</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">
              <bold>“HEDGES-MSA”</bold>
            </td>
            <td rowspan="1" colspan="1">4 bytes</td>
            <td rowspan="1" colspan="1">N/A</td>
            <td rowspan="1" colspan="1">HEDGES</td>
            <td rowspan="1" colspan="1"> <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td>
            <td rowspan="1" colspan="1">Muscle</td>
            <td rowspan="1" colspan="1">[3–30]</td>
            <td rowspan="1" colspan="1">(0.167,4), (0.25,9) (0.5,24), (0.75,39)</td>
            <td rowspan="1" colspan="1">i.i.d.(1,5,10%), DNArSim</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <fn id="tblfn1">
          <label>a</label>
          <p>For “<bold>RS</bold>” pipelines, the inner configuration tuples <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> indicate a <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> configuration of <italic toggle="yes">x</italic> redundant bytes per strand and <italic toggle="yes">y</italic> data bytes per strand. Similarly, for the “<bold>HEDGES</bold>” configurations, an <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> tuple indicates a code rate of <italic toggle="yes">x</italic> and bytes per strand of <italic toggle="yes">y</italic>. </p>
        </fn>
        <fn id="tblfn51">
          <p><inline-formula id="IE9000"><mml:math id="IM9000" display="inline" overflow="scroll"><mml:mi>R</mml:mi><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:math></inline-formula> indicates a Reed-Solomon code over the field <inline-formula id="IE9001"><mml:math id="IM9001" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>8</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, for the <bold>“RS”</bold> pipeline Randomize means we randomize binary information prior to the Reed-Solomon inner-error correction, and <inline-formula id="IE9002"><mml:math id="IM9002" display="inline" overflow="scroll"><mml:mstyle displaystyle="false"><mml:mo>Ψ</mml:mo><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi mathvariant="script">B</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow><mml:mo>;</mml:mo><mml:mrow><mml:msubsup><mml:mi mathvariant="script">D</mml:mi><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mstyle></mml:math></inline-formula> denotes a map between binary integers of length 2 (<inline-formula id="IE9003"><mml:math id="IM9003" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi mathvariant="script">B</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>) and DNA strings of length 1 (<inline-formula id="IE9004"><mml:math id="IM9004" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi mathvariant="script">D</mml:mi><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>).</p>
        </fn>
      </table-wrap-foot>
    </table-wrap>
    <p>DNA storage system designers are also faced with various technologies for writing/reading DNA, each with different error characteristics which can impact decoder choice. To demonstrate the evaluation of multiple error channels for the same pipelines, we consider two commonly used error models. One is a simple independent and identically distributed (i.i.d.) model for insertions, substitutions, and deletions. This model is typically used when considering NGS DNA readout (<xref rid="btad572-B19" ref-type="bibr">Press <italic toggle="yes">et al.</italic> 2020</xref>, <xref rid="btad572-B25" ref-type="bibr">Yuan <italic toggle="yes">et al.</italic> 2022</xref>). However, it has been shown that an i.i.d. channel does not well represent nanopore errors due to the lack of support for burst errors (<xref rid="btad572-B12" ref-type="bibr">Hamoum <italic toggle="yes">et al.</italic> 2021</xref>). To study whether burst errors may change the choice of decoder, we also consider a publicly available model, DNArSim (<ext-link xlink:href="https://github.com/BHam-1/DNArSim" ext-link-type="uri">https://github.com/BHam-1/DNArSim</ext-link>), which describes conditional error probabilities that are derived from real sequencing data.</p>
    <p>A key piece of FrameD that enables our analysis is parallelism support which allows us to simulate 240 unique pipeline configurations, totaling over 650M fault-injected DNA strands, in a reasonable time frame on a HPC cluster. All simulations were completed within 4 days on an HPC cluster with specs outlined in <xref rid="btad572-T2" ref-type="table">Table 2</xref>. To verify that our infrastructure aids in scaling to larger simulations, we perform scalability experiments on one pipeline configuration with the core type fixed to <bold>“Intel Xeon Gold6226R”</bold>. We picked the “<bold>RS (9,47)”</bold> pipeline with read depth 25× and fault rate 10%. For this study, we simulate the pipeline only 368 times, and for a single core, we measured 20 325 s to complete the simulation. Because 1 MPI rank is allocated for scheduling, 31 additional compute ranks will populate all cores of a node. In this case the experiment finishes in 802 s (25.3× speedup). In the previous cases, we are able to exclusively use a node with no outside job interference; however, for multiple node runs we are not due to our cluster being a shared system. For 92 compute ranks, we measured a 65.99× speedup. These speedups indicate that FrameD is scalable.</p>
    <table-wrap position="float" id="btad572-T2">
      <label>Table 2.</label>
      <caption>
        <p>Overview of HPC system used for simulations, parallelization parameters, and simulation characteristics.<xref rid="tblfn2" ref-type="table-fn"><sup>a</sup></xref></p>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="center" span="1"/>
        </colgroup>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">Node architecture</td>
            <td rowspan="1" colspan="1">2 Intel Gold 6226/6130 192 GB RAM per node </td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Number of batch jobs</td>
            <td rowspan="1" colspan="1">240</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">MPI ranks to parallelize fault injection iterations</td>
            <td rowspan="1" colspan="1">128</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Fault injection iterations/pipeline</td>
            <td rowspan="1" colspan="1">1024</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Total strands generated</td>
            <td rowspan="1" colspan="1">654.7 million</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Binary data/fault injection run</td>
            <td rowspan="1" colspan="1">2.78 kB</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Minimum inner code samples</td>
            <td rowspan="1" colspan="1">51 200</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <fn id="tblfn2">
          <label>a</label>
          <p>MPI parallelization was utilized for only fault injection iterations.</p>
        </fn>
      </table-wrap-foot>
    </table-wrap>
    <p>We note that FrameD only provides the infrastructure for scalability, and that efficiently executing parallel units of work requires understanding the computational resources needed by each rank. For example, developers should be aware if utilizing all cores of a node exhausts all memory when parallelizing multiple instances of the inner code, and thus allocate ranks to their compute system appropriately. In our studied pipelines, we did not observe this need, however.</p>
    <p>This experiment also relies on other properties of FrameD. Importantly, the error model modularity allows us to apply multiple error models to each pipeline, and allows us to adopt significant portions of DNArSim with minor modifications to fit FrameD’s interface. This demonstrates FrameD’s ability to incorporate existing model implementations. Probes also play a major role in this analysis by providing decoding success rates of inner-error correction algorithms, a key value when determining storage system cost.</p>
    <p>In all experiments, we control for strand length by modulating the number of bits of each base-sequence when we change the density of the encoding. This ensures that all designs fall in a strand length space that is reasonable given the practical limitations of DNA synthesis technologies (<xref rid="btad572-B3" ref-type="bibr">Bishop <italic toggle="yes">et al.</italic> 2017</xref>). In our experiments, strand lengths fall in the range of 240–242 bp. We use ideal clustering in our experiments to isolate MSA error correction from approximations made by clustering algorithms (<xref rid="btad572-B20" ref-type="bibr">Rashtchian <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad572-B2" ref-type="bibr">Antkowiak <italic toggle="yes">et al.</italic> 2020</xref>).</p>
    <sec>
      <title>4.1 Comparing pipelines</title>
      <p>We compare pipelines by calculating the read and write code rates required for each pipeline to meet a target Mean Time to Failure (MTTF) of 10<sup>9</sup> accesses on 1 MB of data. We refer to these rates in terms of read and write density, each with units bits/base, and calculate them as the ratio of total bits read/written to the total number of bases read/written. Given that synthesis and sequencing cost is proportional to the number of bases, these metrics allow for technology-independent cost comparisons. A higher density is better. Write density is derived from the redundancy allocated to the inner and outer code. While read density considers encoding redundancy, it also considers the number of copies for each strand that were sequenced. We point out that the densities used for comparison are different from those provided in <xref rid="btad572-T1" ref-type="table">Table 1</xref> for the inner codes. While the rate of the inner code influences the success rate of decoding individual strands for a given channel error, additional outer code error correction is required to develop a robust system to meet reliability targets. Thus, our final code rate is a single metric that factors in both the code rate of the inner codes shown in <xref rid="btad572-T1" ref-type="table">Table 1</xref>, and the code rate necessary for the outer code after measuring strand decode probabilities from fault injection. Detailed calculations can be found in the <xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> section.</p>
      <p>With this analysis relying on estimating the decode rate of strands through the inner code, there must be enough inner code samples to build reasonable confidence for these rates. Controlling for a consistent strand length across inner encoding densities leads to some pipelines simulating more strands given a constant input binary file. However, we ensure that each inner code is simulated against at least 51k fault-injected strands.</p>
      <p>Lastly, our analysis does not consider the impact on the outer code from physical strand dropouts that can arise throughout the DNA storage life cycle (<xref rid="btad572-B4" ref-type="bibr">Bornholt <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad572-B17" ref-type="bibr">Organick <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad572-B22" ref-type="bibr">Tomek <italic toggle="yes">et al.</italic> 2019</xref>). FrameD supports dropout modeling, but our focus in this case study is on the inner code’s ability to cope with errors in the channel. Thus, the outer code is entirely provisioned based on how well each inner code is able to decode strands without error. However, our design choices hold when factoring in dropouts if assuming a fixed dropout rate per pipeline.</p>
    </sec>
  </sec>
  <sec>
    <title>5 Results</title>
    <p>To visualize the comparison of pipeline designs across sequencing depths, we plot the Pareto front for each pipeline with respect to read and write density. A Pareto front provides the design points that optimally trade off one cost for another such that a point is included if it provides an improvement in at least one cost. If a configuration offers no benefit, it is left out. Thus, every point in <xref rid="btad572-T1" ref-type="table">Table 1</xref> will not make it to the frontier. The pipeline frontiers for the i.i.d. error model for three error rates are shown in <xref rid="btad572-F4" ref-type="fig">Fig. 4</xref>. In this figure, each pipeline has a different color, and a point shape represents a configuration of the inner code of the pipeline. The black line connecting points represents the complete frontier across all pipelines.</p>
    <fig position="float" id="btad572-F4">
      <label>Figure 4.</label>
      <caption>
        <p>Optimal density design points for the three studied pipelines across the three studied i.i.d. error rates, 1%, 5%, and 10%. The dotted black line represents the total frontier composed of points from all of the studied pipelines. Each pipeline configuration is labeled by its inner code redundancy.</p>
      </caption>
      <graphic xlink:href="btad572f4" position="float"/>
    </fig>
    <p>For the lowest fault rate (1%), we find that the “<bold>RS”</bold> pipeline with 1 redundancy byte for error detection provides the best write density. This configuration indicates that MSA is able to resolve a majority of errors. However, at a read density of 0.4 this pipeline’s write density drops and gets overtaken in optimality by the “<bold>HEDGES”</bold> pipeline. This happens because MSA alone is not able to keep up with the HEDGES code’s error correction at lower read depths, requiring the “<bold>RS”</bold> pipeline to use considerably more outer encoding overhead. Interestingly, adding MSA to an inner code is not always best as shown by “<bold>HEDGES”</bold> enveloping “<bold>HEDGES-MSA”</bold>. The reason stems from the HEDGES code’s high decode rate of single strands at this error rate such that it is more likely to decode a strand by applying the code multiple times rather than aggregating the information in MSA.</p>
    <p>As the i.i.d. rate increases, MSA-based approaches become more prominent. For example, when the error rate is 5%, “<bold>HEDGES-MSA”</bold> outperforms “<bold>HEDGES”</bold> for the same inner code configuration. This is because it is now more cost-effective to use sequencing depth to reduce the per-base error rate with MSA, rather than applying the HEDGES code individually to each sequenced copy. The same occurs for a 10% error rate. Still, a pattern emerges where a non-optimal “<bold>HEDGES-MSA”</bold> approach becomes enveloped again by the “<bold>HEDGES”</bold> pipeline with the same configuration. We conclude from this that the optimality of using HEDGES with or without MSA is highly dependent on the error rate of the storage system, a conclusion a designer will not be able to come to without a simulation framework like FrameD.</p>
    <p>A pattern that emerges for “<bold>HEDGES”</bold> configurations is that when read density is increased by decreasing sequencing depth, at a certain point it no longer becomes cost-effective due to ballooning outer code overhead, making lower density inner codes preferred. This can be seen for a fault rate of 5% between “<bold>HEDGES:0.75”</bold> and “<bold>HEDGES:0.5”</bold>. However, this is not the case for “<bold>RS”</bold>, as no configurations that utilize less dense Reed–Solomon codes for error correction appear in <xref rid="btad572-F4" ref-type="fig">Fig. 4</xref>. This indicates that Reed–Solomon as an inner code is ineffective against insertions and deletions. We demonstrate this further in the <xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref>.</p>
    <p><xref rid="btad572-F5" ref-type="fig">Figure 5</xref> compares the three pipelines for nanopore-based fault injection. In contrast with the i.i.d. frontier, the complete frontier consists of points only from “<bold>HEDGES-MSA”</bold>. The main driving force of this is that nanopore sequencing has a higher frequency of burst errors compared to the i.i.d. model. Burst errors generate a decoder mismatch with the HEDGES code since this algorithm relies on guessing errors based on an i.i.d. error model. Thus, the HEDGES code experiences a large decode rate decrease unless MSA is applied beforehand to help resolve bursts. Another interesting component of <xref rid="btad572-F5" ref-type="fig">Fig. 5</xref> is that there is no configuration that just relies on MSA to resolve errors. These results showcase that with FrameD designers are able to define weaknesses in decoding algorithms and determine better pipeline combinations when faced with designing for different sequencing devices.</p>
    <fig position="float" id="btad572-F5">
      <label>Figure 5.</label>
      <caption>
        <p>Optimal frontiers obtained when the error injection model is based on nanopore sequencing technology.</p>
      </caption>
      <graphic xlink:href="btad572f5" position="float"/>
    </fig>
  </sec>
  <sec>
    <title>6 Conclusion</title>
    <p>We have shown that as work continues in the area of DNA storage systems there is an increasing number of unique pipelines that overlap in the components that they use. We introduce FrameD to address the void of tools available to the DNA data storage community, enabling the modularization of common algorithms and integrating fault injection models to provide a basis for fair system comparisons. Because of its foundation in the literature of DNA storage systems, FrameD provides designers with the ability to simulate a wide variety of storage systems. FrameD also provides transparent support for the parallelization of computational units of work such as individual strands and fault injection iterations, enabling the use of scalable high-performance computing systems. These features are demonstrated in our analysis of three pipelines that utilize the same components in different combinations across two error models representing different sequencing devices. In our analysis, the optimal pipeline choice and configuration depends both on the cost targets set by the designer and the target sequencing device. This highlights the basic need for DNA storage designers to have tools that can compare designs across a range of environments.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad572_Supplementary_Data</label>
      <media xlink:href="btad572_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>J.T. and A.K. are co-founders of DNAli Data Technologies. W.T. has two patents (8748091 and 8394584) licensed to ONT. W.T. has received travel funds to speak at symposia organized by ONT.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by the National Science Foundation [1901324 to K.V., K.L., A.K., J.T., 2027655 to K.V., K.L., A.K., J.T., P.H., W.T.].</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad572-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Anavy</surname><given-names>L</given-names></string-name>, <string-name><surname>Vaknin</surname><given-names>I</given-names></string-name>, <string-name><surname>Atar</surname><given-names>O</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Data storage in DNA with fewer synthesis cycles using composite DNA letters</article-title>. <source>Nat Biotechnol</source>  <year>2019</year>;<volume>37</volume>:<fpage>1229</fpage>–<lpage>36</lpage>.<pub-id pub-id-type="pmid">31501560</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Antkowiak</surname><given-names>PL</given-names></string-name>, <string-name><surname>Lietard</surname><given-names>J</given-names></string-name>, <string-name><surname>Darestani</surname><given-names>MZ</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Low cost DNA data storage using photolithographic synthesis and advanced information reconstruction and error correction</article-title>. <source>Nat Commun</source>  <year>2020</year>;<volume>11</volume>:<fpage>5345</fpage>.<pub-id pub-id-type="pmid">33093494</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B3">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Bishop</surname><given-names>B</given-names></string-name>, <string-name><surname>Mccorkle</surname><given-names>N</given-names></string-name>, <string-name><surname>Zhirnov</surname><given-names>V.</given-names></string-name></person-group>  <italic toggle="yes">Technology Working Group Meeting on Future DNA Synthesis Technologies</italic>, Durham, NC: Semiconductor Research Corporation, Arlington, VA, <year>2017</year>, p. <fpage>39</fpage>.</mixed-citation>
    </ref>
    <ref id="btad572-B4">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Bornholt</surname><given-names>J</given-names></string-name>, <string-name><surname>Lopez</surname><given-names>R</given-names></string-name>, <string-name><surname>Carmean</surname><given-names>DM</given-names></string-name></person-group>  <etal>et al</etal> A DNA-based archival storage system. In<italic toggle="yes">: Proceedings of the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS ’16</italic>. New York, NY: ACM, Atlanta, GA, <year>2016</year>, <fpage>637</fpage>–<lpage>49</lpage>. ISBN 978-1-4503-4091-5.</mixed-citation>
    </ref>
    <ref id="btad572-B5">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Chaykin</surname><given-names>G</given-names></string-name>, <string-name><surname>Furman</surname><given-names>N</given-names></string-name>, <string-name><surname>Sabary</surname><given-names>O</given-names></string-name></person-group>  <etal>et al</etal> DNA-Storalator: End-to-End DNA Storage Simulator. In: <italic toggle="yes">Non-Volatile Memories Workshop 2022</italic>, Oakland, CA: University of Calidfornia, San Diego, CA, <year>2022</year>.</mixed-citation>
    </ref>
    <ref id="btad572-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Choi</surname><given-names>Y</given-names></string-name>, <string-name><surname>Ryu</surname><given-names>T</given-names></string-name>, <string-name><surname>Lee</surname><given-names>AC</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>High information capacity DNA-based data storage with augmented encoding characters using degenerate bases</article-title>. <source>Sci Rep</source>  <year>2019</year>;<volume>9</volume>:<fpage>6582</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">31036920</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Church</surname><given-names>GM</given-names></string-name>, <string-name><surname>Gao</surname><given-names>Y</given-names></string-name>, <string-name><surname>Kosuri</surname><given-names>S.</given-names></string-name></person-group>  <article-title>Next-generation digital information storage in DNA</article-title>. <source>Science</source>  <year>2012</year>;<volume>337</volume>:<fpage>1628</fpage>.<pub-id pub-id-type="pmid">22903519</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Edgar</surname><given-names>RC.</given-names></string-name></person-group>  <article-title>MUSCLE: a multiple sequence alignment method with reduced time and space complexity</article-title>. <source>BMC Bioinformatics</source>  <year>2004</year>;<volume>5</volume>:<fpage>113</fpage>.<pub-id pub-id-type="pmid">15318951</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Erlich</surname><given-names>Y</given-names></string-name>, <string-name><surname>Zielinski</surname><given-names>D.</given-names></string-name></person-group>  <article-title>DNA fountain enables a robust and efficient storage architecture</article-title>. <source>Science</source>  <year>2017</year>;<volume>355</volume>:<fpage>950</fpage>–<lpage>4</lpage>.<pub-id pub-id-type="pmid">28254941</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Goldman</surname><given-names>N</given-names></string-name>, <string-name><surname>Bertone</surname><given-names>P</given-names></string-name>, <string-name><surname>Chen</surname><given-names>S</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Towards practical, high-capacity, low-maintenance information storage in synthesized DNA</article-title>. <source>Nature</source>  <year>2013</year>;<volume>494</volume>:<fpage>77</fpage>–<lpage>80</lpage>.<pub-id pub-id-type="pmid">23354052</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Grass</surname><given-names>RN</given-names></string-name>, <string-name><surname>Heckel</surname><given-names>R</given-names></string-name>, <string-name><surname>Puddu</surname><given-names>M</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Robust chemical preservation of digital information on DNA in silica with error-correcting codes</article-title>. <source>Angew Chem Int Ed Engl</source>  <year>2015</year>;<volume>54</volume>:<fpage>2552</fpage>–<lpage>5</lpage>.<pub-id pub-id-type="pmid">25650567</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B12">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Hamoum</surname><given-names>B</given-names></string-name>, <string-name><surname>Dupraz</surname><given-names>E</given-names></string-name>, <string-name><surname>Conde-Canencia</surname><given-names>L</given-names></string-name></person-group>  <etal>et al</etal> Channel model with memory for DNA data storage with nanopore sequencing. In: <italic toggle="yes">2021 11th International Symposium on Topics in Coding (ISTC)</italic>, New York, NY: IEEE, Quebec, Canada, <year>2021</year>, <fpage>1</fpage>–<lpage>5</lpage>.</mixed-citation>
    </ref>
    <ref id="btad572-B13">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Heckel</surname><given-names>R</given-names></string-name>, <string-name><surname>Shomorony</surname><given-names>I</given-names></string-name>, <string-name><surname>Ramchandran</surname><given-names>K</given-names></string-name></person-group>  <etal>et al</etal> Fundamental limits of DNA storage systems. In: <italic toggle="yes">2017 IEEE International Symposium on Information Theory (ISIT)</italic>, New York, NY: IEEE, Aachen, Germany, <year>2017</year>, 3130–3134. ISSN: <fpage>2157</fpage>–<lpage>8117</lpage>.</mixed-citation>
    </ref>
    <ref id="btad572-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lin</surname><given-names>KN</given-names></string-name>, <string-name><surname>Volkel</surname><given-names>K</given-names></string-name>, <string-name><surname>Tuck</surname><given-names>JM</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Dynamic and scalable DNA-based information storage</article-title>. <source>Nat Commun</source>  <year>2020</year>;<volume>11</volume>:<fpage>2981</fpage>.<pub-id pub-id-type="pmid">32532979</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marelli</surname><given-names>A</given-names></string-name>, <string-name><surname>Chiozzi</surname><given-names>T</given-names></string-name>, <string-name><surname>Battistini</surname><given-names>N</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Integrating FPGA acceleration in the DNAssim framework for faster DNA-based data storage simulations</article-title>. <source>Electronics</source>  <year>2023</year>;<volume>12</volume>:<fpage>2621</fpage>.</mixed-citation>
    </ref>
    <ref id="btad572-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Matange</surname><given-names>K</given-names></string-name>, <string-name><surname>Tuck</surname><given-names>JM</given-names></string-name>, <string-name><surname>Keung</surname><given-names>AJ.</given-names></string-name></person-group>  <article-title>DNA stability: a central design consideration for DNA data storage systems</article-title>. <source>Nat Commun</source>  <year>2021</year>;<volume>12</volume>:<fpage>1358</fpage>.<pub-id pub-id-type="pmid">33649304</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Organick</surname><given-names>L</given-names></string-name>, <string-name><surname>Ang</surname><given-names>SD</given-names></string-name>, <string-name><surname>Chen</surname><given-names>Y-J</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Random access in large-scale DNA data storage</article-title>. <source>Nat Biotechnol</source>  <year>2018</year>;<volume>36</volume>:<fpage>242</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">29457795</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Organick</surname><given-names>L</given-names></string-name>, <string-name><surname>Chen</surname><given-names>Y-J</given-names></string-name>, <string-name><surname>Dumas Ang</surname><given-names>S</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Probing the physical limits of reliable DNA data retrieval</article-title>. <source>Nat Commun</source>  <year>2020</year>;<volume>11</volume>:<fpage>616</fpage>.<pub-id pub-id-type="pmid">32001691</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Press</surname><given-names>WH</given-names></string-name>, <string-name><surname>Hawkins</surname><given-names>JA</given-names></string-name>, <string-name><surname>Jones</surname><given-names>SK</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>HEDGES error-correcting code for DNA storage corrects indels and allows sequence constraints</article-title>. <source>Proc Natl Acad Sci U S A</source>  <year>2020</year>;<volume>117</volume>:<fpage>18489</fpage>–<lpage>96</lpage>.<pub-id pub-id-type="pmid">32675237</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B20">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Rashtchian</surname><given-names>C</given-names></string-name>, <string-name><surname>Makarychev</surname><given-names>K</given-names></string-name>, <string-name><surname>Racz</surname><given-names>M</given-names></string-name></person-group>  <etal>et al</etal>  <part-title>Clustering billions of reads for DNA data storage</part-title>. In: <person-group person-group-type="editor"><string-name><surname>Guyon</surname><given-names>I</given-names></string-name></person-group> (ed.), <source>Advances in Neural Information Processing Systems 30</source>. Red Hook, NY: <publisher-name>Curran Associates Inc</publisher-name>, <year>2017</year>, <fpage>3360</fpage>–<lpage>71</lpage>.</mixed-citation>
    </ref>
    <ref id="btad572-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sabary</surname><given-names>O</given-names></string-name>, <string-name><surname>Orlev</surname><given-names>Y</given-names></string-name>, <string-name><surname>Shafir</surname><given-names>R</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>SOLQC: synthetic oligo library quality control tool</article-title>. <source>Bioinformatics</source>  <year>2021</year>;<volume>37</volume>:<fpage>720</fpage>–<lpage>2</lpage>.<pub-id pub-id-type="pmid">32840559</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tomek</surname><given-names>KJ</given-names></string-name>, <string-name><surname>Volkel</surname><given-names>K</given-names></string-name>, <string-name><surname>Simpson</surname><given-names>A</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Driving the scalability of DNA-based information storage systems</article-title>. <source>ACS Synth Biol</source>  <year>2019</year>;<volume>8</volume>:<fpage>1241</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">31117362</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tomek</surname><given-names>KJ</given-names></string-name>, <string-name><surname>Volkel</surname><given-names>K</given-names></string-name>, <string-name><surname>Indermaur</surname><given-names>EW</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>Promiscuous molecules for smarter file operations in DNA-based data storage</article-title>. <source>Nat Commun</source>  <year>2021</year>;<volume>12</volume>:<fpage>3518</fpage>.<pub-id pub-id-type="pmid">34112775</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yazdi</surname><given-names>SMHT</given-names></string-name>, <string-name><surname>Gabrys</surname><given-names>R</given-names></string-name>, <string-name><surname>Milenkovic</surname><given-names>O.</given-names></string-name></person-group>  <article-title>Portable and error-free DNA-based data storage</article-title>. <source>Sci Rep</source>  <year>2017</year>;<volume>7</volume>:<fpage>5011</fpage>.<pub-id pub-id-type="pmid">28694453</pub-id></mixed-citation>
    </ref>
    <ref id="btad572-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yuan</surname><given-names>L</given-names></string-name>, <string-name><surname>Xie</surname><given-names>Z</given-names></string-name>, <string-name><surname>Wang</surname><given-names>Y</given-names></string-name></person-group>  <etal>et al</etal>  <article-title>DeSP: a systematic DNA storage error simulation pipeline</article-title>. <source>BMC Bioinformatics</source>  <year>2022</year>;<volume>23</volume>:<fpage>185</fpage>.<pub-id pub-id-type="pmid">35581548</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
