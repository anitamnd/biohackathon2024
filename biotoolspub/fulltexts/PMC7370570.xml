<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d1 20130915//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 39.96?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Iperception</journal-id>
    <journal-id journal-id-type="iso-abbrev">Iperception</journal-id>
    <journal-id journal-id-type="publisher-id">IPE</journal-id>
    <journal-id journal-id-type="hwp">spipe</journal-id>
    <journal-title-group>
      <journal-title>i-Perception</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2041-6695</issn>
    <publisher>
      <publisher-name>SAGE Publications</publisher-name>
      <publisher-loc>Sage UK: London, England</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7370570</article-id>
    <article-id pub-id-type="doi">10.1177/2041669520938400</article-id>
    <article-id pub-id-type="publisher-id">10.1177_2041669520938400</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methods</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>bmlTUX: Design and Control of Experiments in Virtual Reality and Beyond</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Bebko</surname>
          <given-names>Adam O.</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-1533-2847</contrib-id>
        <name>
          <surname>Troje</surname>
          <given-names>Nikolaus F.</given-names>
        </name>
        <xref ref-type="corresp" rid="corresp1-2041669520938400"/>
      </contrib>
      <aff id="aff1-2041669520938400">Department of Biology and Centre for Vision Research, York University, Toronto, Ontario, Canada</aff>
    </contrib-group>
    <author-notes>
      <corresp id="corresp1-2041669520938400">Nikolaus F. Troje, York University, Life Science Building, 4700 Keele Street, Toronto, ON M3J1P3, Canada. Email: <email>troje@yorku.ca</email></corresp>
    </author-notes>
    <pub-date pub-type="epub">
      <day>17</day>
      <month>7</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="collection">
      <season>Jul-Aug</season>
      <year>2020</year>
    </pub-date>
    <volume>11</volume>
    <issue>4</issue>
    <elocation-id>2041669520938400</elocation-id>
    <history>
      <date date-type="received">
        <day>17</day>
        <month>12</month>
        <year>2019</year>
      </date>
      <date date-type="accepted">
        <day>9</day>
        <month>6</month>
        <year>2020</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2020</copyright-statement>
      <copyright-year>2020</copyright-year>
      <copyright-holder content-type="society">SAGE Publications Ltd. Manuscript content on this site is licensed under Creative Commons Licenses</copyright-holder>
      <license license-type="creative-commons" xlink:href="https://creativecommons.org/licenses/by/4.0/">
        <license-p>Creative Commons CC BY: This article is distributed under the terms of the Creative Commons Attribution 4.0 License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>) which permits any use, reproduction and distribution of the work without further permission provided the original work is attributed as specified on the SAGE and Open Access pages (<ext-link ext-link-type="uri" xlink:href="https://us.sagepub.com/en-us/nam/open-access-at-sage">https://us.sagepub.com/en-us/nam/open-access-at-sage</ext-link>).</license-p>
      </license>
    </permissions>
    <abstract>
      <p>Advances in virtual reality technology have made it a valuable new tool for vision and perception researchers. Coding virtual reality experiments from scratch can be difficult and time-consuming, so researchers rely on software such as Unity game engine to create and edit virtual scenes. However, Unity lacks built-in tools for controlling experiments. Existing third-party add-ins requires complicated scripts to define experiments. This can be difficult and requires advanced coding knowledge, especially for multifactorial experimental designs. In this article, we describe a new free and open-source tool called the BiomotionLab Toolkit for Unity Experiments (bmlTUX) that provides a simple interface for controlling experiments in Unity. In contrast to existing tools, bmlTUX provides a graphical interface to automatically handle combinatorics, counterbalancing, randomization, mixed designs, and blocking of trial order. The toolbox works <italic>out-of-the-box</italic> since simple experiments can be created with almost no coding. Furthermore, multiple design configurations can be swapped with a drag-and-drop interface allowing researchers to test new configurations iteratively while maintaining the ability to easily revert to previous configurations. Despite its simplicity, bmlTUX remains highly flexible and customizable, catering to coding novices and experts alike.</p>
    </abstract>
    <kwd-group>
      <kwd>3D perception</kwd>
      <kwd>perception</kwd>
      <kwd>virtual reality</kwd>
      <kwd>stereopsis</kwd>
      <kwd>perception/action</kwd>
      <kwd>multisensory/cross-modal processing</kwd>
    </kwd-group>
    <funding-group>
      <award-group id="award1-2041669520938400">
        <funding-source id="funding1-2041669520938400">
          <institution-wrap>
            <institution>NSERC Discovery Grant</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group id="award2-2041669520938400">
        <funding-source id="funding2-2041669520938400">
          <institution-wrap>
            <institution>CFREF Vision: Science to Application</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>cover-date</meta-name>
        <meta-value>July-August 2020</meta-value>
      </custom-meta>
      <custom-meta>
        <meta-name>typesetter</meta-name>
        <meta-value>ts2</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec>
    <title>Introduction</title>
    <p>Recent advances in virtual reality (VR) technology have been driven by a large consumer-oriented market that aims at the development of a new medium for computer games. Head-mounted displays have become affordable, lightweight and user-friendly, screen refresh rates and spatial resolution have improved tremendously, and new tracking technologies reduce lag between head motion and display update below perceptual thresholds (<xref rid="bibr4-2041669520938400" ref-type="bibr">Scarfe &amp; Glennerster, 2019</xref>).</p>
    <p>Not surprisingly, vision research is quickly adopting this new technology (<xref rid="bibr2-2041669520938400" ref-type="bibr">de Gelder et al., 2018</xref>). In contrast to existing display technologies, VR offers a critical new depth cue, active motion parallax, that provides the observer with a location in the virtual scene that behaves like true locations do: It changes in predictable ways as the observer moves (<xref rid="bibr5-2041669520938400" ref-type="bibr">Troje, 2019</xref>; <xref rid="bibr7-2041669520938400" ref-type="bibr">Wexler &amp; Van Boxtel, 2005</xref>). The contingency between observer motion and the resulting change in visual stimulation is critical and technically challenging as it requires an efficient, lag-free integration of measurements of head position and orientation with real-time stimulus generation.</p>
    <p>As with hardware, the software that implements these tasks is geared toward the entertainment industry. Game engines such as Unity and Unreal Engine are widely used for game development. They support development of normal screen-based computer games using both 2D and 3D graphics, but their main strength lies in their ability to control head-mounted displays and provide simple tools to render highly detailed and realistic graphics. In that function, they are also becoming increasingly adopted by vision researchers.</p>
    <p>Both game engines have similar functionality but also unique strengths and weaknesses. Unity is generally more approachable for users without software engineering backgrounds and provides a large quantity of free high-quality online tutorials. For this reason, it seems to be somewhat more popular among research laboratories than Unreal Engine.</p>
    <p>Experiments in vision science are often structured using a factorial design, in which several independent variables are systematically varied, while participant responses are recorded in dependent variables. Participants then go through a series of trials, in which they are presented with different manipulations encoded in the values of one or many independent variables. Factorial designs typically involve some form of counterbalancing wherein enough trials are presented so that participants are exposed to all desired manipulations. Experimenters sometimes create blocks of trials that group trials based on the value of one or more independent variables. In addition, researchers often randomize the order of trials or counterbalance the order of blocks to control for order effects.</p>
    <p>Unity does not provide a straightforward way to implement factorial structures. Coding experiments from scratch is time-consuming and difficult especially for studies using VR (<xref rid="bibr3-2041669520938400" ref-type="bibr">de la Rosa &amp; Breidt, 2018</xref>). In this article, we describe a new Unity plugin called the Biomotion Lab Toolkit for Unity Experiments (bmlTUX) that provides a flexible interface with Unity to simplify the creation of experiments and reduce the amount of coding required. The toolkit supplies the majority of repetitive code that is required for running most experiments, thereby enabling experiments to be created in Unity with minimal coding.</p>
    <p>Two other Unity plugins have recently been published that simplify the process of creating experiments in Unity. The first major tool that was recently released is the Unity Experimental Framework (UXF; <xref rid="bibr1-2041669520938400" ref-type="bibr">Brookes et al., 2019</xref>), which provides a backend platform that greatly simplifies the process of running experiments. This framework handles the code to run trials in the order that the experimenter has specified. However, setting up a simple experiment is not trivial and requires a user-provided text file containing a list of variables and their values. Critically, the experimenter must write complicated code to convert this text file into a sequence of trials including writing code to determine trial order, counterbalancing, randomization, blocking, and so on.</p>
    <p>The second main tool is the Unified Suite for Experiments (USE; <xref rid="bibr6-2041669520938400" ref-type="bibr">Watson et al., 2018</xref>) which provides more flexibility and control over experiment flow compared with UXF. The USE framework is based on a custom engine that can interface with external equipment that synchronizes high-precision timing and measurement. USE also provides easier integration with peripherals and hardware such as digital-analog converters that can interface with brain imaging systems or electrophysiological recording devices. The extra power and flexibility come at the cost of being more difficult to set up compared with UXF, even for very simple experiments. Like UXF, USE also requires a user-provided text file and code that specifies the exact sequence of trials.</p>
    <p>Both existing tools greatly simplify the process of running experiments in Unity, but they do not aid in experimental design and do not provide the combinatorics of a factorial approach. All related functionality must be coded manually by the experimenter (i.e., variable entry, trial order, counterbalancing, randomization, and blocking). This process requires a strong background in coding and can be very time-consuming even for the simplest of experiments. Therefore, changes to the design usually require large changes to the associated code. Difficulty in initial setup and subsequent modification of experiments make testing new ideas and experiments much more difficult and slow down the process of iteration and refinement of experimental design. bmlTUX fills this gap in functionality by providing tools to aid in <italic>both</italic> the design and the execution of experiments in Unity. The toolkit is designed to simplify the setup and reduce the required code needed to get experiments up and running quickly. Unlike the above tools, our system can automatically handle the difficult task of specifying a mixed factorial design with multiple, potentially nested factors and turning it into an executable experiment. It provides the combinatorics of both random and counterbalanced factors, manages mixed designs with both within-subject and between-subject factors, and takes care of blocking and randomization of trial order. This functionality thus removes one of the most difficult aspects of creating experiments. In addition, the toolbox works <italic>out-of-the-box</italic>, meaning that a very simple experiment can be created with less than 20 lines of code (described and shown later). Using more advanced scripting features, the toolkit can be customized indefinitely to provide further custom functionality.</p>
    <p>The toolkit is also designed to facilitate creating experiments incrementally. Variables and manipulations can be added or removed without requiring any changes to an experiment’s code, allowing for fast changes to test out new functionality. Furthermore, a single experiment can save multiple design configurations that can be swapped with a drag-and-drop interface. Therefore, researchers can test new configurations iteratively while maintaining the ability to easily revert to previous configurations if needed.</p>
  </sec>
  <sec id="sec1-2041669520938400">
    <title>Overview</title>
    <p>In our implementation, we keep the control of the experimental flow (<italic>Designer</italic> module) entirely separate from the execution of the experiment itself (<italic>Runner</italic> module). The Designer module maintains a <italic>Design file</italic> that contains the specifics of the experimental design. The interface between the two modules is a <italic>Trial Table,</italic> which is based on the design and specifies all trials and the particular order in which they will be executed for each experimental run. Upon execution, the Runner works through the Trial Table and updates it with the values of the dependent variables collected during the experiment (<xref ref-type="fig" rid="fig1-2041669520938400">Figure 1</xref>).</p>
    <fig id="fig1-2041669520938400" orientation="portrait" position="float">
      <label>Figure 1.</label>
      <caption>
        <p>The Structure of a bmlTUX Experiment. Experimental design is configured in a Design File that is used to construct Trial Tables. Upon execution, a Trial Table is passed to the Custom Execution Scripts that are written by the experimenter. These scripts define how the Unity scene is manipulated in each Trial, Block, and Experiment based on the values of the independent variables. After each trial, the output file is updated. </p>
      </caption>
      <graphic xlink:href="10.1177_2041669520938400-fig1"/>
    </fig>
    <p>The Designer is a set of tools that aids with setting up the experiment’s variables and specifying their roles. The Designer stores the configuration of the experiment in a Design File, which is edited using a graphical user interface requiring no coding. The experimenter can declare all factors that control stimuli, the rules by which they are combined into trials, the rules that determine the order in which trials are presented, and a few other parameters that control experimental flow. At this stage, participant variables (e.g., participant age) and dependent variables (e.g., participant responses) can also be specified. When complete, the Design File contains all information required to generate Trial Tables. Since experimental design generally involves random processes (e.g., randomizing the order of trials), a new Trial Table is typically generated for every participant.</p>
    <p>The Runner reads a Trial Table line by line and executes the experiment by generating the visual stimulus and logging responses from the participant. While the Designer does not require any programming, the Runner requires short <italic>Custom Execution Scripts</italic> written in C# programming language that turn the variables contained in the Trial Table into the desired visual scene and experimental behavior. Separate custom scripts can be passed to the Runner to customize the behavior of the entire experiment, blocks of trials, and individual trials.</p>
    <p>The Design File and Trial Table are stored as editable ASCII files that follow JavaScript Object Notion (JSON) format. Rather than relying on the Designer, they can in principle be created by other means or edited externally and then passed on to the Runner. That way, potential restrictions of the otherwise strictly factorial approach of the Designer can be bypassed.</p>
    <p>Creating a simple experiment typically follows the following process:</p>
    <p>
      <list list-type="bullet" id="list1-2041669520938400">
        <list-item>
          <p>Create a scene in Unity.</p>
        </list-item>
        <list-item>
          <p>Use the included Script Helper Tool to automatically generate a Runner GameObject, a Design File, and all required scripts.</p>
        </list-item>
        <list-item>
          <p>Configure the Design File with independent and dependent variables and information how to determine the order of trials.</p>
        </list-item>
        <list-item>
          <p>Customize the Execution Scripts to manipulate the Unity scene as desired. For simple experiments, this only involves editing the Trial script.</p>
        </list-item>
        <list-item>
          <p>Run the experiment.</p>
        </list-item>
      </list>
    </p>
  </sec>
  <sec id="sec2-2041669520938400">
    <title>Getting and Using the Toolkit</title>
    <p>The toolkit is provided free and open source on GitHub under a Creative Commons Attribution Non-Commercial Share Alike 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc-sa/4.0/">http://creativecommons.org/licenses/by-nc-sa/4.0/</ext-link>).</p>
    <p>The latest release, comprehensive documentation, and an introductory tutorial can be accessed from <ext-link ext-link-type="uri" xlink:href="https://biomotionlab.github.io/TUX/">https://biomotionlab.github.io/TUX/</ext-link>. Additional information can be found at <ext-link ext-link-type="uri" xlink:href="https://www.biomotionlab.ca/tux/">https://www.biomotionlab.ca/tux/</ext-link>.</p>
  </sec>
  <sec id="sec3-2041669520938400">
    <title>Implementation</title>
    <sec id="sec4-2041669520938400">
      <title>Script Helper Tool</title>
      <p>We have included a tool to help set up new experiments. In a new Unity scene, the <italic>Script Helper Tool</italic> can be accessed from the <italic>bmlTUX</italic> menu. This tool can automatically create all required files for a new experiment and will create a Unity GameObject in the scene with the appropriate scripts attached. The Script Helper Tool is not a required part of the toolbox and the advanced users may choose to not use it for the development of experiments. However, it is a very helpful asset for new users, and in the following, we assume that the reader is making use of it.</p>
    </sec>
    <sec id="sec5-2041669520938400">
      <title>The Designer Module</title>
      <p>To access the Designer, the experimenter has to click on the new Design File created by the Script Helper Tool. This will open a Unity inspector window that allows the creation of variables and configuration of other settings (<xref ref-type="fig" rid="fig2-2041669520938400">Figure 2</xref>).</p>
      <fig id="fig2-2041669520938400" orientation="portrait" position="float">
        <label>Figure 2.</label>
        <caption>
          <p>Design File Inspector Interface. Without requiring any code, experimenters can add, remove, and define variables, and adjust randomization, combinatorics, and repetition. An example Trial Table can also be previewed to ensure the design is correctly specified.</p>
        </caption>
        <graphic xlink:href="10.1177_2041669520938400-fig2"/>
      </fig>
      <sec id="sec6-2041669520938400">
        <title>Defining Variables</title>
        <p>The Designer provides a graphical interface within which independent, dependent, and participant variables can be defined, and any counterbalancing, randomization, repetition, and blocking can be configured. Since Unity uses the C# scripting language, which is a statically typed programming language, each variable must be given a data type upon creation. Currently supported types include integer, float (decimal numbers), string (text), and boolean (true/false). There is also support for some Unity classes (Vector3, Vector2, etc.). Unity internally uses the float type for most decimal numbers including time, distances, and rotations, so float variables should be used for variables representing such factors.</p>
      </sec>
      <sec id="sec7-2041669520938400">
        <title>Independent Variables</title>
        <p>Trials are defined by a number of independent variables and the values they can adopt. The Designer enables the experimenter to add new variables using the <italic>Variable Creation</italic> section of the interface. Once created, the experimenter must provide a name and a list of possible values for each variable in the <italic>Values</italic> list. Marking a variable as <italic>Block</italic> affects the order in which trials are run (see trial order section).</p>
      </sec>
      <sec id="sec8-2041669520938400">
        <title>Combining Variables into Trials</title>
        <p>There are several ways by which the toolkit can use to combine the independent variables to form a sequence of trials. Each independent variable can be flagged as <italic>balanced</italic>, <italic>looped, or random</italic>.</p>
        <p><italic>Balanced</italic> variables are added such that each possible value is run at least once. If all variables are set to balanced, then the experiment will be completely counterbalanced such that there will be enough trials to cover every combination of all variable values. For example, a study with 2 variables with 4 levels and 5 levels, respectively, will result in 20 trials (or, if repeated, a multiple thereof) covering every possible combination of values.</p>
        <p><italic>Looped</italic> variables are combined with other variables so that certain values of one variable are tied to certain values of another variable. The toolkit will loop through all values such that there is an equal number of trials with each value. This means that if there are two looped variables, one with <italic>x</italic> possible values and one with <italic>y</italic> possible values, the number of trials will be equal to the lowest common multiple of <italic>x</italic> and <italic>y</italic>. In experiments with both looped variables and balanced variables, all looped variables are added, trials are computed, and then the entire resulting set of looped trials is treated as a single balanced variable for the purposes of counterbalancing.</p>
        <p><italic>Random</italic> variables do not create new trials on their own. If a variable is flagged as random, its value is determined according to a specified probability distribution, but independently of the value of the variable in other trials. If <italic>Even Probability</italic> is selected, all values have an equal likelihood of being selected. If <italic>Custom Probability</italic> is selected, the experimenter can indicate the probability of each value being selected. To make sure that probabilities add up to one, the probability for the last value is calculated automatically. If all independent variables are set to <italic>random</italic> then, by default, the experiment contains only one single trial—unless repetitions are added explicitly (see below).</p>
      </sec>
    </sec>
    <sec id="sec9-2041669520938400">
      <title>Repetitions</title>
      <p>By default, the toolkit creates the minimum number of trials required to satisfy the constraints formulated in the experimental design. This set of trials, however, can be repeated several times. To achieve this, the <italic>Trial Repetition</italic> setting can be adjusted. In other cases, experimenters may want to repeat the entire experiment several times. This can be achieved using the <italic>Experiment Repetition</italic> setting.</p>
      <p>For clarity, we will distinguish <italic>repetitions</italic> from <italic>blocks</italic>. Blocks are a set of trials grouped by a common value of a block variable. In contrast, repetitions are a set of trials created by duplicating all existing trials. With no block variables, the two <italic>repetition</italic> settings are redundant and behave identically. If the design contains block variables they behave differently (see below).</p>
    </sec>
    <sec id="sec10-2041669520938400">
      <title>Block Order</title>
      <p>Due to the different types of repetitions and the existence of blocked variables, there are several order modes available.
<list list-type="bullet" id="list2-2041669520938400"><list-item><p><italic>In Order</italic>: Blocks appear in the order they are created.</p></list-item><list-item><p><italic>Custom Order</italic>: Blocks appear in an experimenter-defined order. See online documentation for details.</p></list-item><list-item><p><italic>Partial Randomization</italic> (only applicable with repetitions added): Block order is shuffled within repetitions. All Blocks are run before being repeated.</p></list-item></list></p>
      <sec id="sec11-2041669520938400">
        <title>Subsettings</title>
        <p>
          <list list-type="bullet" id="list3-2041669520938400">
            <list-item>
              <p>One permutation: A single, random permutation is applied to all repetitions.</p>
            </list-item>
            <list-item>
              <p>Different permutations (default): Block order is shuffled independently for each repetition.</p>
            </list-item>
            <list-item>
              <p><italic>Complete Randomization</italic>: Block order is shuffled, and Experiment Repetitions are shuffled such that they can intermix.</p>
            </list-item>
          </list>
        </p>
      </sec>
    </sec>
    <sec id="sec12-2041669520938400">
      <title>Trial Order and Randomization</title>
      <p>Similar to the block order, the order of the trials within a block can be randomized in different ways:
<list list-type="bullet" id="list4-2041669520938400"><list-item><p><italic>In Order</italic>: Trials appear in the order they are created.</p></list-item><list-item><p><italic>Randomized</italic> (with no Block variables): Trial order is shuffled completely, and repetitions can be intermixed with each other.</p></list-item><list-item><p><italic>Randomized</italic> (with Block variables): Trial order is shuffled but remains grouped by Block.</p></list-item></list></p>
      <sec id="sec13-2041669520938400">
        <title>Subsettings</title>
        <p><list list-type="bullet" id="list5-2041669520938400"><list-item><p><italic>One Permutation</italic>: Trial order is shuffled but will be the exact same for each Block and across repetitions.</p></list-item><list-item><p><italic>Different Permutations</italic> (default): Trial order is shuffled differently for each Block and repetition.</p></list-item></list>During the development of an experiment, it is helpful to set both trial and block randomization to <italic>In Order</italic>. The Trial Table can then be inspected more easily to verify that the intended combinatorics and number of trials are correct.</p>
      </sec>
      <sec id="sec14-2041669520938400">
        <title>Previewing a Design</title>
        <p>Once variables and repetition settings have been configured, a preview of an experimental session can be opened using a button in the Designer Interface. This preview will show a new window displaying an example trial table of the experiment with any randomization applied. This is helpful to preview the number of trials and possible trial orders.</p>
      </sec>
      <sec id="sec15-2041669520938400">
        <title>Dependent Variables</title>
        <p>Dependent variables represent measurements and responses that are collected trial by trial during runtime of the experiment. They are defined in the Designer so that the Runner can update them after each trial and add them to the output file. They can be created in a similar fashion as independent variables and allow the entry of a default value that is used if the experiment fails to record a response.</p>
      </sec>
      <sec id="sec16-2041669520938400">
        <title>Participant Variables</title>
        <p>Participant Variables are variables that do not change over the course of one experimental session. They are typically used to record demographic information from each participant (e.g., age and gender). The toolkit will prompt the experimenter to enter values for the Participant Variables at the start of each experimental session. The allowed possible values can be constrained by checking the <italic>Constrain Values</italic> setting and entering a list of values.</p>
      </sec>
      <sec id="sec17-2041669520938400">
        <title>Finalizing the Design</title>
        <p>Once the configuration of the Designer is complete, the toolkit will create a Trial Table, which specifies the values of all variables for each particular trial and the order in which the trials are executed. Each row of the table is one trial, and each column is one variable. This Trial Table is then passed to the Runner for execution during which it is completed by adding the values of the Dependent Variables.</p>
        <p>The toolkit can generate Trial Tables in two ways, <italic>On-The-Fly</italic> (default) or <italic>Pre-Generated</italic>. On-the-fly generation is completely automatic and will likely fulfill the needs for most experiments. In this mode, the toolkit will automatically generate the experiment’s Trial Table from the Design file at runtime.</p>
        <p>Although the Design File interface provides all needed controls, both the Design File and Trial Table can be stored and accessed as editable human-readable text files. They can be edited by external tools and then passed to the Runner. This enables randomized variables to be known in advance and allows for fine-tuning of the experimental structure and knowledge of the exact trial order before each session begins. In the advanced settings of the Design File inspector, pregenerated Trial Tables can be created, saved to disk, edited, and then loaded at runtime. In this way, potential restrictions of the otherwise factorial approach of the Designer can be bypassed. For more complex experiments, the built-in Trial Table generation scripts can be bypassed completely. That opens the possibility to generate adaptive designs, for instance, staircase methods.</p>
      </sec>
    </sec>
    <sec id="sec18-2041669520938400">
      <title>The Runner Module</title>
      <sec id="sec19-2041669520938400">
        <title>Custom Execution Scripts</title>
        <p>The Runner Module receives the information specified by the Design File and the resulting Trial File. To turn that information into a running experiment, the experimenter has to provide code that is distributed over four different <italic>Custom Execution Scripts</italic>: The <italic>Runner</italic> script plus three additional scripts that specify the behavior of the experiment on the level of individual trials, blocks of trials, and for the whole experiment.</p>
      </sec>
      <sec id="sec20-2041669520938400">
        <title>Runner Script</title>
        <p>The Runner script is attached to a Unity game object in the scene and references the experiment’s Design File and any other Custom Execution Scripts that are defined. When the Unity scene is run, the Runner script is automatically called and begins the experiment.</p>
      </sec>
    </sec>
    <sec id="sec21-2041669520938400">
      <title>Custom Experiment, Block, Trial Scripts</title>
      <p>The script helper tool automatically creates three very basic Custom Execution Scripts that are included with the basic code to run a simple experiment. There are three main hierarchically organized structures that can be customized: <italic>Experiment</italic>, <italic>Block</italic>, and <italic>Trial</italic>. Although the toolkit provides basic scripts for all three categories, most experiments will at minimum require editing the Trial script to describe how the Unity scene should change based on the values of the independent variables in each trial.</p>
      <p>Each Custom Execution Script extends a C# class defined by the toolkit. These classes (Trial, Block, and Experiment) all share a series of automatically called functions where custom behavior can be added. Each script can be extended through three types of such functions: (a) <italic>Preexecution</italic> functions are useful for initialization, instructions, and setup; (b) <italic>Postexecution</italic> functions are useful for cleanup, measurement, and recording responses; and (c) the <italic>Main-execution</italic> function. The Main-execution function can only be customized for Trials, since for Experiments and Blocks, the execution simply consists of running trials. For very simple experiments, the only coding required is writing a custom Main-execution function (<xref ref-type="fig" rid="fig3-2041669520938400">Figure 3</xref>).</p>
      <fig id="fig3-2041669520938400" orientation="portrait" position="float">
        <label>Figure 3.</label>
        <caption>
          <p>Example Trial Script for a Basic Experiment. Note that each trial shows a stimulus of varying colors (L 13-14), and then waits for the user to hit the return key (L 16-20). It creates a subclass of the class Trial that is included in bmlTUX (L 5-10), which already contains all the code for a simple trial to run. This script adds custom behavior to a trial’s main execution function, RunMainCoroutine (L 12). It overrides (customizes) the function such that each trial will execute this custom behavior rather than the built-in code. In a separate script, the custom ExperimentRunner script attached to a GameObject in the Unity scene stores a reference to the Stimulus object (L 1-3). This is all the code needed to run this simple experiment.</p>
        </caption>
        <graphic xlink:href="10.1177_2041669520938400-fig3"/>
      </fig>
      <p>The toolkit automatically provides the values of independent variables to the Trial and Block scripts. Functions can then use these values to appropriately modify the Unity scene for each trial.</p>
      <p>More detailed information about writing custom scripts can be found in the official documentation and tutorials. Note that these custom extension scripts can reference and call objects and functions from any other C# scripts, allowing for more advanced customizations and experimental structures to be coded.</p>
      <sec id="sec22-2041669520938400">
        <title>Running an Experiment</title>
        <p>Once the Designer has been configured and the Runner has been provided with the required scripts, the experiment can be run within the Unity Editor or as a built executable program. When run, the toolkit displays a window showing the Experiment Runner Interface and starts a new experimental session. The interface prompts the experimenter for the location to save the output file, entry of participant variables, and other settings for starting an experimental session. The interface can also provide some additional functionality including the ability to watch the progress of the experiment in real time, and the ability to skip and navigate between trials (<xref ref-type="fig" rid="fig4-2041669520938400">Figure 4</xref>). When the <italic>Start Experiment</italic> button is pressed, the toolkit executes the experiment and runs through all trials. An output file is automatically created, which is basically a copy of the Trial Table with added columns that contain the values of the dependent variable(s).</p>
        <fig id="fig4-2041669520938400" orientation="portrait" position="float">
          <label>Figure 4.</label>
          <caption>
            <p>Runner Interface While Running an Experiment. Current progress through trials and blocks is shown, and measured variables are updated as trials are completed. This interface can be shown on a secondary display if desired.</p>
          </caption>
          <graphic xlink:href="10.1177_2041669520938400-fig4"/>
        </fig>
      </sec>
    </sec>
  </sec>
  <sec sec-type="discussion" id="sec23-2041669520938400">
    <title>Discussion</title>
    <p>Using bmlTUX, an experimenter must write much less code for simple and moderately complicated experiments than would be required using UXF or USE, since it automatically handles the code for configuring variables, counterbalancing, creating the trials, ordering trials, and so on. Although the toolkit simplifies this process greatly, it remains highly customizable and flexible even for very advanced experimental designs. The toolkit drastically reduces the time needed to get an experiment up and running and has powerful features for modifying the experimental design incrementally without hassle. This makes experimental creation in Unity much more approachable to novice coders and much faster for expert coders, particularly in situations where frequent iterative design is desired.bmlTUX enables quickly designing and running experiments in Unity Game Engine, which frees more time to be spent on increasing realism and graphics. Combined with its built-in compatibility with VR frameworks, bmlTUX is an especially useful tool for creating more <italic>naturalistic</italic> vision experiments in virtual environments. Such naturalistic experiments allow experimenters to present realistic visual environments while maintaining a high degree of experimental control (<xref rid="bibr4-2041669520938400" ref-type="bibr">Scarfe &amp; Glennerster 2019</xref>).bmlTUX can store and swap multiple variants of its design with ease using a drag-and-drop interface. This enables experimenters to have multiple working versions of an experiment within the same project that can be interchanged at a moment’s notice. This is especially useful for keeping pared-down versions of experiments for debugging, pilot testing, or training purposes. It is also useful for storing a history of changes to the experimental design over time.</p>
    <p>The toolkit is designed to be approachable by novice-level coders. The interface for configuring the experiment’s variables, the experiment controls, and the automatic creation of trials and blocks is excellent for minimizing the time required to build an experiment, even for experimenters with little coding knowledge. We have pilot-tested the use of the toolkit on several small groups of undergraduate and graduate students with novice-level coding and Unity knowledge, and all were able to design simple experiments after only a few hours of use. We have provided a basic tutorial to help get started and learn the fundamentals of working with the toolkit and have created a wiki page with more detailed documentation of the more advanced features and customizations. Despite being targeted for novice coders, advanced coders will benefit from using bmlTUX due to its flexibility, customizability, fast implementation, and iterative capabilities.</p>
    <p>Despite the flexibility and ease of use of the toolkit, it does have some limitations. For example, USE has much more precise control and measurement of timing events and has built-in tools for helping with integration of external hardware compared with bmlTUX. For research where high-precision timing is important, the USE framework might be more suitable since bmlTUX’s timing accuracy is currently limited to the update rate of the Unity program (usually around 60–120 Hz). In addition, the toolkit is somewhat restricted to factorial designs, whereas USE is more flexible through its Control Structure interface. We made this decision consciously to target a more coding-averse audience, since it simplifies creating custom scripts. However, it means that it may be difficult to implement more complicated procedures such as adaptive staircase designs. Furthermore, although hidden <italic>behind the scenes</italic>, bmlTUX uses loops and coroutines in addition to event systems to control the flow between trials and blocks, whereas UXF and USE rely exclusively on event systems. Although this improves the learning curve for novice coders, advanced coders may find this slightly less expandable for complex projects. There are plans to allow custom scripts to access internal events in a future release.</p>
    <p>bmlTUX provides an approachable and powerful set of tools to create experiments with the Unity Game Engine and caters to both novice and advanced coders. The toolkit simplifies the process of getting experiments up and running quickly without the hassle of complicated scripting.</p>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgements</title>
    <p>The authors would like to thank several colleagues and students who volunteered their time to test the system, tutorials, and documentation especially Xiaoye Wang, Anne Thaler, Max Esser, Johannes Kurz, Harun Karimpur, and Carly King.</p>
  </ack>
  <sec id="sec24-2041669520938400">
    <title>Declaration of Conflicting Interests</title>
    <p>The author(s) declared no potential conflicts of interest with respect to the research, authorship, and/or publication of this article.</p>
  </sec>
  <sec id="sec25-2041669520938400">
    <title>Funding</title>
    <p>The author(s) disclosed receipt of the following financial support for the research, authorship, and/or publication of this article: This work was funded by an NSERC Discovery Grant to NFT and contributions from the CFREF Vision: Science to Application.</p>
  </sec>
  <sec>
    <title>ORCID iD</title>
    <p>Nikolaus F. Troje <ext-link ext-link-type="uri" xlink:href="https://orcid.org/0000-0002-1533-2847">https://orcid.org/0000-0002-1533-2847</ext-link></p>
  </sec>
  <ref-list content-type="nameDate">
    <title>References</title>
    <ref id="bibr1-2041669520938400">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Brookes</surname><given-names>J.</given-names></name><name><surname>Warburton</surname><given-names>M.</given-names></name><name><surname>Alghadier</surname><given-names>M.</given-names></name><name><surname>Mon-Williams</surname><given-names>, M.</given-names></name><name><surname>Mushtaq</surname><given-names>, F.</given-names></name></person-group> (<year>2019</year>). 
<article-title>Studying human behavior with virtual reality: The Unity Experiment Framework</article-title>. <source>Behavior Research Methods</source>, 
<volume>52</volume>, <fpage>455</fpage>–<lpage>463</lpage>. <pub-id pub-id-type="doi">10.3758/s13428-019-01242-0</pub-id></mixed-citation>
    </ref>
    <ref id="bibr2-2041669520938400">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>de Gelder</surname><given-names>B.</given-names></name><name><surname>Kätsyri</surname><given-names>J.</given-names></name><name><surname>de Borst</surname><given-names>A. W.</given-names></name></person-group> (<year>2018</year>) 
<article-title>Virtual reality and the new psychophysics</article-title>. <source>British Journal of Psychology</source>, 
<volume>109</volume>, <fpage>421</fpage>–<lpage>426</lpage>.<pub-id pub-id-type="pmid">29806694</pub-id></mixed-citation>
    </ref>
    <ref id="bibr3-2041669520938400">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>de la Rosa</surname><given-names>S.</given-names></name><name><surname>Breidt</surname><given-names>M.</given-names></name></person-group> (<year>2018</year>) 
<article-title>Virtual Reality: A new track in psychological research</article-title>. <source>British Journal of Psychology</source>, 
<volume>109</volume>, <fpage>427</fpage>–<lpage>430</lpage>.<pub-id pub-id-type="pmid">29748966</pub-id></mixed-citation>
    </ref>
    <ref id="bibr4-2041669520938400">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Scarfe</surname><given-names>P.</given-names></name><name><surname>Glennerster</surname><given-names>A.</given-names></name></person-group> (<year>2019</year>) 
<article-title>The science behind virtual reality displays.</article-title>
<source>Annual Review of Vision Science</source>, 
<volume>5</volume>, <fpage>529</fpage>–<lpage>547</lpage>.</mixed-citation>
    </ref>
    <ref id="bibr5-2041669520938400">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Troje</surname><given-names>N. F.</given-names></name></person-group> (<year>2019</year>) 
<article-title>Reality check</article-title>. <source>Perception</source>, 
<volume>48</volume>(<issue>11</issue>),<fpage>1033</fpage>–<lpage>1038</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org">https://doi.org</ext-link>
<ext-link ext-link-type="uri" xlink:href="http:///10.1177/0301006619879062">/10.1177/0301006619879062</ext-link><pub-id pub-id-type="pmid">31570079</pub-id></mixed-citation>
    </ref>
    <ref id="bibr6-2041669520938400">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Watson</surname><given-names>M. R.</given-names></name><name><surname>Voloh</surname><given-names>B.</given-names></name><name><surname>Thomas</surname><given-names>C. G.</given-names></name><name><surname>Womelsdorf</surname><given-names>T.</given-names></name></person-group> (<year>2018</year>) 
<article-title>USE: An integrative suite for temporally-precise psychophysical experiments in virtual environments</article-title>. <source>bioRxiv</source>. <pub-id pub-id-type="doi">10.1101/434944</pub-id></mixed-citation>
    </ref>
    <ref id="bibr7-2041669520938400">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wexler</surname><given-names>M.</given-names></name><name><surname>Van Boxtel</surname><given-names>J. J.</given-names></name></person-group> (<year>2005</year>). 
<article-title>Depth perception by the active observer</article-title>. <source>Trends in Cognitive Sciences</source>, 
<volume>9</volume>(<issue>9</issue>), <fpage>431</fpage>–<lpage>438</lpage>.<pub-id pub-id-type="pmid">16099197</pub-id></mixed-citation>
    </ref>
  </ref-list>
  <ref-list content-type="nameDate">
    <title>How to cite this article</title>
    <ref id="bibr8-2041669520938400">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bebko</surname><given-names>A. O.</given-names></name><name><surname>Troje</surname><given-names>N. F.</given-names></name></person-group> (<year>2020</year>). 
<article-title>bmlTUX: Design and control of experiments in virtual reality and beyond</article-title>. <source>i-Perception</source>, 
<volume>11</volume>(<issue>4</issue>), <fpage>1</fpage>–<lpage>12</lpage>. <pub-id pub-id-type="doi">10.1177/2041669520938400</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
