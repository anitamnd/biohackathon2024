<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">PeerJ</journal-id>
    <journal-id journal-id-type="iso-abbrev">PeerJ</journal-id>
    <journal-id journal-id-type="publisher-id">peerj</journal-id>
    <journal-id journal-id-type="pmc">peerj</journal-id>
    <journal-title-group>
      <journal-title>PeerJ</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2167-8359</issn>
    <publisher>
      <publisher-name>PeerJ Inc.</publisher-name>
      <publisher-loc>San Diego, USA</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7100596</article-id>
    <article-id pub-id-type="publisher-id">8431</article-id>
    <article-id pub-id-type="doi">10.7717/peerj.8431</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Bioinformatics</subject>
      </subj-group>
      <subj-group subj-group-type="heading">
        <subject>Computational Biology</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>IterCluster: a barcode clustering algorithm for long fragment read analysis</article-title>
    </title-group>
    <contrib-group>
      <contrib id="author-1" contrib-type="author" equal-contrib="yes">
        <name>
          <surname>Weng</surname>
          <given-names>Jiancong</given-names>
        </name>
        <xref ref-type="aff" rid="aff-1">1</xref>
        <xref ref-type="aff" rid="aff-2">2</xref>
      </contrib>
      <contrib id="author-2" contrib-type="author" equal-contrib="yes">
        <name>
          <surname>Chen</surname>
          <given-names>Tian</given-names>
        </name>
        <xref ref-type="aff" rid="aff-2">2</xref>
      </contrib>
      <contrib id="author-3" contrib-type="author">
        <name>
          <surname>Xie</surname>
          <given-names>Yinlong</given-names>
        </name>
        <xref ref-type="aff" rid="aff-2">2</xref>
      </contrib>
      <contrib id="author-4" contrib-type="author">
        <name>
          <surname>Xu</surname>
          <given-names>Xun</given-names>
        </name>
        <xref ref-type="aff" rid="aff-3">3</xref>
      </contrib>
      <contrib id="author-5" contrib-type="author">
        <name>
          <surname>Zhang</surname>
          <given-names>Gengyun</given-names>
        </name>
        <xref ref-type="aff" rid="aff-1">1</xref>
      </contrib>
      <contrib id="author-6" contrib-type="author" corresp="yes">
        <name>
          <surname>Peters</surname>
          <given-names>Brock A.</given-names>
        </name>
        <email>bpeters@completegenomics.com</email>
        <xref ref-type="aff" rid="aff-3">3</xref>
      </contrib>
      <contrib id="author-7" contrib-type="author" corresp="yes">
        <name>
          <surname>Drmanac</surname>
          <given-names>Radoje</given-names>
        </name>
        <email>rade@completegenomics.com</email>
        <xref ref-type="aff" rid="aff-3">3</xref>
      </contrib>
      <aff id="aff-1"><label>1</label><institution>BGI Education Center, University of Chinese Academy of Sciences</institution>, <city>Shenzhen</city>, <country>China</country></aff>
      <aff id="aff-2"><label>2</label><institution>MGI, BGI-Shenzhen</institution>, <city>Shenzhen</city>, <country>China</country></aff>
      <aff id="aff-3"><label>3</label><institution>BGI-Shenzhen</institution>, <city>Shenzhen</city>, <country>China</country></aff>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Khiabanian</surname>
          <given-names>Hossein</given-names>
        </name>
      </contrib>
    </contrib-group>
    <pub-date pub-type="epub" date-type="pub" iso-8601-date="2020-03-24">
      <day>24</day>
      <month>3</month>
      <year iso-8601-date="2020">2020</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2020</year>
    </pub-date>
    <volume>8</volume>
    <elocation-id>e8431</elocation-id>
    <history>
      <date date-type="received" iso-8601-date="2018-10-12">
        <day>12</day>
        <month>10</month>
        <year iso-8601-date="2018">2018</year>
      </date>
      <date date-type="accepted" iso-8601-date="2019-12-18">
        <day>18</day>
        <month>12</month>
        <year iso-8601-date="2019">2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>©2020 Weng et al.</copyright-statement>
      <copyright-year>2020</copyright-year>
      <copyright-holder>Weng et al.</copyright-holder>
      <license xlink:href="https://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, reproduction and adaptation in any medium and for any purpose provided that it is properly attributed. For attribution, the original author(s), title, publication source (PeerJ) and either DOI or URL of the article must be cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="https://peerj.com/articles/8431"/>
    <abstract>
      <p>Recent advances in long fragment read (LFR, also known as linked-read technologies or read-cloud) technologies, such as single tube long fragment reads (stLFR), 10X Genomics Chromium reads, and TruSeq synthetic long-reads, have enabled efficient haplotyping and genome assembly. However, in the case of stLFR and 10X Genomics Chromium reads, the long fragments of a genome are covered sparsely by reads in each barcode and most barcodes are contained in multiple long fragments from different regions, which results in inefficient assembly when using long-range information. Thus, methods to address these shortcomings are vital for capitalizing on the additional information obtained using these technologies. We therefore designed IterCluster, a novel, alignment-free clustering algorithm that can cluster barcodes from the same target region of a genome, using -mer frequency-based features and a Markov Cluster (MCL) approach to identify enough reads in a target region of a genome to ensure sufficient target genome sequence depth. The IterCluster method was validated using BGI stLFR and 10X Genomics chromium reads datasets. IterCluster had a higher precision and recall rate on BGI stLFR data compared to 10X Genomics Chromium read data. In addition, we demonstrated how IterCluster improves the de novo assembly results when using a divide-and-conquer strategy on a human genome data set (scaffold/contig N50 = 13.2 kbp/7.1 kbp vs. 17.1 kbp/11.9 kbp before and after IterCluster, respectively). IterCluster provides a new way for determining LFR barcode enrichment and a novel approach for de novo assembly using LFR data. IterCluster is OpenSource and available on <ext-link ext-link-type="uri" xlink:href="https://github.com/JianCong-WENG/IterCluster">https://github.com/JianCong-WENG/IterCluster</ext-link>.</p>
    </abstract>
    <kwd-group kwd-group-type="author">
      <kwd>Next-generation sequencing</kwd>
      <kwd>Long fragment read</kwd>
      <kwd>De novo assembly</kwd>
      <kwd>Barcode cluster</kwd>
      <kwd>kmer</kwd>
    </kwd-group>
    <funding-group>
      <award-group id="fund-1">
        <funding-source> Shenzhen Peacock Plan</funding-source>
        <award-id>KQTD20150330171505310</award-id>
      </award-group>
      <funding-statement>This work was supported by the Shenzhen Peacock Plan (NO.KQTD20150330171505310). There was no additional external funding received for this study. The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement>
    </funding-group>
  </article-meta>
</front>
<body>
  <sec sec-type="intro">
    <title>Introduction</title>
    <p>The short read length of next-generation sequencing (NGS) technology presents a challenge for aligning programs in terms of how to handle the splicing of repeat sequences during the de novo assembly process. To address this problem, in addition to long-read sequencing, which provides reads that can often span across an entire repeat area, low-cost, low-input DNA library preparation techniques based on co-barcoding methods have been recently developed. These include technologies such as single tube long fragment reads (stLFR) from BGI, 10× Genomics, or TruSeq synthetic long reads (TSLR) from Illumina (<xref rid="ref-14" ref-type="bibr">Wang et al., 2018</xref>; <xref rid="ref-16" ref-type="bibr">Zheng et al., 2016</xref>; <xref rid="ref-13" ref-type="bibr">Voskoboynik et al., 2013</xref>). Using these techniques, a low-input DNA library is first trimmed into a series of long fragments of 10–100 kb in length and short reads from the same long fragment are created that all contain the same barcode. Since each fragment comes from a small fraction of the genome, the probability of a fragment containing identical repeat sequence is also low. Therefore, most of the repeat regions in the genome are covered by fragments with unique signatures. Once these are generated, the short reads are then sequenced using standard high-throughput sequencing technologies. The LFRs generated by these techniques are inseparable from the short read length features of NGS technology, but they provide more long-range information about the same DNA fragment compared to standard NGS short reads, thus providing more information for de novo genome assembly (<xref rid="ref-15" ref-type="bibr">Weisenfeld et al., 2017</xref>; <xref rid="ref-3" ref-type="bibr">Coombe et al., 2018</xref>; <xref rid="ref-6" ref-type="bibr">Kuleshov, Snyder &amp; Batzoglou, 2016</xref>). In addition, LFR techniques have been used in haplotype phase determination and structural variation detection (<xref rid="ref-14" ref-type="bibr">Wang et al., 2018</xref>; <xref rid="ref-16" ref-type="bibr">Zheng et al., 2016</xref>).</p>
    <p>To better explain the data characteristics of LFRs, three distinct coverage types for LFR data, similar to that proposed by Kuleshov, should be considered (<xref rid="ref-6" ref-type="bibr">Kuleshov, Snyder &amp; Batzoglou, 2016</xref>). Specifically, these are local coverage, fragment coverage, and global coverage. Local coverage is the coverage of a long fragment with short reads in the same barcode and global coverage is the coverage of the whole genome with the sum of short reads from each fragment. The fragment coverage is the coverage of a whole genome with long fragments, which is directly related to the nature of the input DNA. In the case of BGI’s stLFR technology, the number of cells used to make a 1 ng human DNA library equates to 300 haploid genomes, meaning the entire genome is covered at 300X depth in this library. Due to the limitation of sequencing cost, the local coverage of each fragment is very low (0.1–0.3) because it just needs to meet the experimental requirements of standard second-generation sequencing. The local coverage of each fragment is too low for each barcode’s reads to completely contain fragment information, with the long-range information being sparse, and this low-sequencing depth cannot achieve the partial assembly of each fragment.</p>
    <p>BGI’s stLFR and 10× Genomics Chromium reads are similar technologies, but they have several distinct characteristics. They are both low-input (about 1 ng) DNA library preparation techniques, and each fragment from these two techniques generates the same number of reads. Compared with 10× Genomics Chromium reads, stLFRs rely more on a co-barcoding technique. stLFRs use the surface of microbeads to create millions of miniaturized compartments in a single tube and enable co-barcoding in reactions with 50 million barcodes. 10× Genomics Chromium reads can only utilize 1 million barcodes, so the number of fragments each barcode used with 10× Genomics Chromium reads are larger than the stLFR methodology at the same DNA-input level. For example, in a human genome library, the average fragments per barcodes is 1.18 using stLFR technology, but is 8.3 using 10× Genomics Chromium reads. The drawback, however, of stLFRs is their high duplicate rate at higher sequencing depths, which can impact downstream applications.</p>
    <p>Unlike BGI’s stLFR and 10× Genomics Chromium reads, TSLR technology guarantees the local coverage (10∼30 X) of each fragment in a barcode by over-sequencing each barcode (<xref rid="ref-13" ref-type="bibr">Voskoboynik et al., 2013</xref>). Each barcode can be assembled separately using a short-read assembler and the assembly complexity is reduced because most of repetitive sequences become unique in a given long fragment. After this subassembly, the long sequences that have been assembled above can then be assembled to generate a whole genome using an overlap-layout-consensus (OLC) assembly strategy and this assembly strategy has been refined using several genomes (<xref rid="ref-13" ref-type="bibr">Voskoboynik et al., 2013</xref>; <xref rid="ref-10" ref-type="bibr">McCoy et al., 2014</xref>; <xref rid="ref-8" ref-type="bibr">Li et al., 2015</xref>). The low local coverage of BGI’s stLFR data and 10× Genomics Chromium reads data make it impossible to achieve subassembly of each barcode and the de novo assembly algorithms designed specifically for BGI’s stLFRs have not been made publically available.</p>
    <p>Given a seed barcode representing a target genomic region, barcode clustering is an effective way to enhance the long-range information derived from LFR data and to enrich all of the reads and barcodes belonging to the same fragment region in the genome. The main purpose of barcode clustering is to capture all of the barcodes in a target genomic region and to filter out all of the reads from the region. In this way, the target region can be assembled independently. Barcode clustering separates the high complexity genome into relatively simple partitions, which reduces the de novo assembly complexity. However, the challenge for barcode clustering is that LFR technology groups reads from several fragment into the same barcode. For example, the data generated by BGI’s stLFR technology contains roughly 1∼3 long fragments per barcode, while data generated by 10× Genomics contains more fragments for each barcode, with an average of six barcodes per fragment. This complicates the problem of barcode clustering, as it causes clusters to generate a large number of false positive barcodes (<xref ref-type="fig" rid="fig-1">Fig. 1C</xref>). In addition, if a seed barcode is contained in multiple fragments, the clustering eventually contains the barcodes from multiple fragment areas.</p>
    <fig id="fig-1" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.7717/peerj.8431/fig-1</object-id>
      <label>Figure 1</label>
      <caption>
        <title>An outline of the IterCluster workflow.</title>
        <p>(A) If the seed barcode contains two fragments (red bars), the cluster contains a sub-cluster from the two regions. The barcodes belonging to the same region are strongly connected, while barcodes from different regions are poorly connected. Markov clustering can achieve further division of the target barcode sub-cluster, so that each sub-cluster only contains barcodes coming from one target region. (B) Using a sub-cluster to get a candidate target barcode. (C) A target barcode directly captured by the seed barcode overlaps with the target region, but barcodes carrying multiple fragments lead to the introduction of a false positive fragment. If these sequences are used as seeds for the next capture, numerous barcodes (yellow bars) without overlap in the target region will be introduced. Using the difference in <italic>k</italic>-mer frequency between the target region and non-target regions, the high frequency unique <italic>k</italic>-mers is selected as the next captured feature value to control the false positive rate of barcodes. IterCluster uses an iterative capture, and each sub-cluster is independently enriched using the <italic>k</italic>-mer frequency diversity selection model to control the rate of false positive barcodes. High frequency unique <italic>k</italic> -mers are selected as seed features for the next round of enrichment, where the number of iterations <italic>k</italic> is set by the user. (D) After <bold><italic>k</italic></bold> iterations, each cluster can be obtained.</p>
      </caption>
      <graphic xlink:href="peerj-08-8431-g001"/>
    </fig>
    <p>Recently, a novel algorithm, Minerva (<xref rid="ref-4" ref-type="bibr">Danko et al., 2019</xref>), provided a solution to these challenges. Minerva focuses on the barcode deconvolution problem utilizing a bipartite graph model. Minerva was designed to partition reads with a single barcode into clusters. Those clusters of reads are labeled with an enhanced barcode. After barcode deconvolution, the number of fragments containing an enhanced barcode can be reduced. Thus, the main purpose of barcode clustering and barcode deconvolution are quite different. Barcode deconvolution is aimed at polishing a single barcode, while barcode cluster focuses on capturing all the reads from a target genome region for helping de novo assembly. Unfortunately, Minerva is only available as a demo program and not very time-efficient. For example, it took more than 10 days to deconvolve a 50-fold human chromosome 19 dataset (<ext-link ext-link-type="uri" xlink:href="https://figshare.com/articles/chr19_read1_fq_gz/7812038">https://figshare.com/articles/chr19_read1_fq_gz/7812038</ext-link>), and it only output 80,000 pairs of enhanced barcode reads using BGI’s stLFR data. Thus, it is impossible for Minerva to finish clustering of a 50-fold whole genome sequencing dataset within an acceptable timeframe.</p>
    <p>To address these limitations of using LFRs, we devised IterCluster, a novel reference- and alignment-free clustering algorithm that can be used to explore the potential relationships between barcodes and can cluster barcodes from the same target region of a genome. We developed a <italic>k</italic>-mer frequency diversity select model to control the false positives generated during barcode clustering, and have used a Markov clustering (MCL) model to ensure that the clustering results only contain barcodes from one fragment area. IterCluster starts with a randomly selected seed barcode and is able to capture other barcodes with overlapping or nearby sequence identity to the seed barcode area. For each generated cluster we filter the non-target region’s reads based on the reads depth difference, and we compared the performance of each cluster de novo assembled independently to all of the reads de novo assembled together in whole human genome data using stLFR technology. Also, we showed that IterCluster had a high recall rate and a suitable accuracy rate for human whole genome data. With IterCluster, we were able to achieve local assembly of a long fragment region, making the subassembly strategy possible in a reasonable timeframe.</p>
  </sec>
  <sec sec-type="materials|methods">
    <title>Materials &amp; Methods</title>
    <sec>
      <title>IterCluster algorithm</title>
      <p>Given a set of long-fragment reads, IterCluster selects appropriate barcodes as the seed and iteratively cluster target barcodes overlapping with the seed barcode. In order to minimize the overlap between clusters in the final clustering result, the target barcode that has become the seed barcode cannot be used as seed in future clusters. The size of each cluster depends on the number of iterations (parameter -k, default 3). The IterCluster algorithm proceeds in three steps: (1) constructing the adjacency matrix between barcodes; (2) generating barcode clusters; (3) extracting the reads of the target regions from each barcode cluster.</p>
      <p>In the first step, we first extract the unique kmer in the genomic data set. The distance between the barcodes is measured by the number of common unique <italic>k</italic>-mers between the barcodes. In terms of time efficiency, IterCluster uses the sparsity of the overlap relationship between barcodes to generate the adjacency matrix.</p>
      <p>In the second step, IterCluster evaluates the quality of the barcode by the unique kmer number and unique <italic>k</italic>-mers proportion, than adds the high quality barcode to the candidate seed list. IterCluster extracts the seed from the candidate seed list and clusters the seed barcode according to the adjacency matrix and the <italic>k</italic>-mers frequency diversity selection model to obtain the preliminary barcode cluster. Because most barcode carry fragments of multiple regions, the preliminary barcode cluster will also carry barcodes from multiple regions. IterCluster uses the Markov clustering model to disassemble each preliminary barcode cluster and obtain a single barcode cluster.</p>
      <p>Finally, IterCluster will count the kmer coverage depth of the reads in each barcode cluster, identify the low coverage depth reads and filter out, and then get the reads in the barcode clustering area.</p>
    </sec>
    <sec>
      <title>Using unique <bold><italic>k</italic></bold>-mer as a similarity measurement</title>
      <p>In the stLFR data, if there are overlaps between a long fragment contained in two barcodes, the read overlap in the two barcodes can be found, as these signify the similarity between barcodes. In measuring the similarity between barcodes, we did not use time-consuming methods such as read alignment between barcodes. Instead, we built a <italic>k</italic>-mer set for each barcode and measured the relation of barcodes based on the similarity of its <italic>k</italic>-mer set. Due to the fact that repeats are widely distributed in the genome, the <italic>k</italic>-mer set generated from a repeat would introduce a false-positive barcode. Therefore, we only select unique <italic>k</italic>-mers as the feature of a barcode based on the <italic>k</italic>-mer frequency distribution. Let K (b) denote the unique <italic>k</italic>-mer set of barcode, the distance between barcodes can be described as: <disp-formula id="NONUM-d2e452"><alternatives><graphic xlink:href="peerj-08-8431-e001.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/><tex-math id="M1">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}\begin{eqnarray*}\mathrm{Dist} ({b}_{1},{b}_{2})=K({b}_{1})\cap K({b}_{2}). \end{eqnarray*}\end{document}</tex-math><mml:math id="mml-NONUM-d2e452"><mml:mstyle displaystyle="true"><mml:mi mathvariant="normal">Dist</mml:mi><mml:mspace width="1em"/><mml:mrow><mml:mfenced separators="" open="(" close=")"><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mfenced></mml:mrow><mml:mo>=</mml:mo><mml:mi>K</mml:mi><mml:mrow><mml:mfenced separators="" open="(" close=")"><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mfenced></mml:mrow><mml:mo>∩</mml:mo><mml:mi>K</mml:mi><mml:mrow><mml:mfenced separators="" open="(" close=")"><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mfenced></mml:mrow><mml:mo>.</mml:mo></mml:mstyle></mml:math></alternatives></disp-formula>
</p>
    </sec>
    <sec>
      <title>A time-efficient way to generate adjacency matrix</title>
      <p>IterCluster implements barcode data clustering based on an adjacency matrix between barcodes. Many solutions to calculate the collective similarity exist, such as a local sensitive hash (<xref rid="ref-2" ref-type="bibr">Charikar, 2002</xref>), which has been applied to the de novo assembly of single-molecule sequencing data (<xref rid="ref-1" ref-type="bibr">Berlin et al., 2015</xref>) and the construction of phylogenetic trees (species trees) (<xref rid="ref-11" ref-type="bibr">Ondov et al., 2016</xref>). Although these techniques can efficiently detect the overlap between barcodes, a probabilistic method inevitably produces a certain error rate, and an absolute common unique <italic>k</italic>-mer number between barcodes cannot be calculated. To calculate the common unique <italic>k</italic>-mer number between barcodes, a simple, time-consuming method is to compute the intersection independently between every two barcodes and the computational complexity of this method is given as: O(<italic>n</italic><sup>2</sup>).</p>
      <p>IterCluster, however, utilizes an innovative algorithm to calculate the absolute common unique <italic>k</italic>-mer number between barcodes. The core logic behind this approach was that the adjacency matrix is sparse and each unique <italic>k</italic>-mer can determine which barcodes are related to each other. IterCluster extracts the unique <italic>k</italic>-mer of a barcode and builds a hash from the unique <italic>k</italic>-mer from each barcode. Barcodes that contain the same unique <italic>k</italic>-mer mean that the number of co-unique <italic>k</italic>-mers between them increases by one. Since there are few barcodes that simultaneously contain the same unique <italic>k</italic>-mer (theoretically less than or equal to the sequencing depth), it takes a constant time to accumulate the number of co-unique <italic>k</italic>-mers between the same unique <italic>k</italic>-mer numbers of supported barcodes. By traversing all of the unique <italic>k</italic>-mers, the absolute value of the co-unique <italic>k</italic>-mers between all of the barcodes can be calculated, and the time complexity of the program is given as: O (<italic>n</italic>) (<xref ref-type="fig" rid="fig-2">Fig. 2</xref>).</p>
      <fig id="fig-2" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.8431/fig-2</object-id>
        <label>Figure 2</label>
        <caption>
          <title>Create a hash mapping from unique <italic>k</italic>-mer to barcode.</title>
          <p>Each row on the table above implies that there is relationship between those barcodes supported by a unique <italic>k</italic>-mer. Because barcodes have less probability of containing the same unique <italic>k</italic>-mer, the time complexity to calculate the relationship between each row of barcodes is O(1), and all row were traversed to calculate the relationship between all barcodes. The time Complexity is O(n).</p>
        </caption>
        <graphic xlink:href="peerj-08-8431-g002"/>
      </fig>
    </sec>
    <sec>
      <title>Barcode enrichment based on a <bold><italic>k</italic></bold>-mer frequency diversity selection model</title>
      <p>We developed an algorithm to iteratively cluster the barcodes from a target area in the genome. The reasoning behind this approach was that the barcodes covering a target area tend to contain unique <italic>k</italic>-mers derived from the target area while the content of unique <italic>k</italic>-mers derived from other areas should be random (<xref ref-type="fig" rid="fig-1">Fig. 1C</xref>), since these barcode cover multiple long-fragment molecule. After each iteration of clustering, the unique <italic>k</italic>-mer frequency of target and non-target areas are significantly different. Using this difference to choose the unique <italic>k</italic>-mers belonging to a target area as a feature of the next round of clustering effectively controls the false-positive rate. IterCluster uses common unique <italic>k</italic>-mers to measure the similarity between barcodes. The number of common unique <italic>k</italic>-mers greater than the parameter <bold><italic>-g</italic></bold> between barcodes is considered to contain the overlapping long fragment molecule. In each iterative clustering process, IterCluster first captures the target barcodes directly overlapping the seed barcode and obtains the target barcode set <bold><italic>T</italic></bold>. Then it statistically determines the frequency of all of the unique <italic>k</italic>-mers of the barcode in <bold><italic>T</italic></bold>. The high-frequency unique <italic>k</italic>-mer set is then selected as the seed unique <italic>k</italic>-mer set for the next iteration and added to the feature <italic>k</italic>-mer set F (<xref rid="table-1" ref-type="table">Table 1</xref>).</p>
      <table-wrap id="table-1" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.8431/table-1</object-id>
        <label>Table 1</label>
        <caption>
          <title>Algorithm for barcode enrichment using a <italic>k</italic>-mer frequency selection model.</title>
          <p><bold><italic>a</italic></bold> is the seed barcode. <bold><italic>b</italic></bold> represents all of the other barcodes. <bold><italic>T</italic></bold> is the target barcode set. <bold><italic>F</italic></bold> is a featured unique <italic>k</italic>-mer set with high frequency in each iteration. <bold><italic>Threshold</italic></bold> is the relation threshold between barcodes, which is controlled by the <bold><italic>g</italic></bold> parameter. <bold><italic>k</italic></bold><sub>1</sub> is the number of iterations.</p>
        </caption>
        <alternatives>
          <graphic xlink:href="peerj-08-8431-g010"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th rowspan="1" colspan="1"><bold>Algorithm 1</bold> IterCluster using <italic>k</italic>-mer frequency select model</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">1. Generate seed barcode <bold><italic>a</italic></bold></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">2. <bold>For</bold> each barcode(<bold><italic>b</italic></bold>):</td>
              </tr>
              <tr>
                <td style="padding-left:2pc;" rowspan="1" colspan="1">3. if common unique <italic>k</italic>-mer (<bold><italic>a</italic></bold><italic>,</italic><bold><italic>b</italic></bold>) &gt;<bold><italic>Threshold</italic></bold>:</td>
              </tr>
              <tr>
                <td style="padding-left:4pc;" rowspan="1" colspan="1">4. add <bold><italic>b</italic></bold> to <bold><italic>T</italic></bold></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">5. <bold>End for</bold></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">6. Statistic unique <italic>k</italic>-mer frequency of reads in <bold><italic>T</italic></bold>, select the unique <italic>k</italic>-mer with high frequency to <bold><italic>F</italic></bold></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">7. <bold>For</bold><bold><italic>k</italic></bold><sub><bold><italic>1</italic></bold></sub> iteration:</td>
              </tr>
              <tr>
                <td style="padding-left:2pc;" rowspan="1" colspan="1">8. Get optional barcode set base on adjacency matrix</td>
              </tr>
              <tr>
                <td style="padding-left:2pc;" rowspan="1" colspan="1">9. <bold>For</bold> each barcode(<bold><italic>b</italic></bold>) in optional barcode set</td>
              </tr>
              <tr>
                <td style="padding-left:3pc;" rowspan="1" colspan="1">10. if common unique <italic>k</italic>-mer (<bold><italic>b</italic></bold><italic>,</italic><bold><italic>F</italic></bold>) &gt;<bold><italic>Threshold</italic></bold>:</td>
              </tr>
              <tr>
                <td style="padding-left:4pc;" rowspan="1" colspan="1">11. add <bold><italic>b</italic></bold> to <bold><italic>T</italic></bold></td>
              </tr>
              <tr>
                <td style="padding-left:2pc;" rowspan="1" colspan="1">12. Statistic unique <italic>k</italic>-mer frequency of reads in <bold><italic>T</italic></bold></td>
              </tr>
              <tr>
                <td style="padding-left:2pc;" rowspan="1" colspan="1">13. Select unique <italic>k</italic>-mer with high frequency to <bold><italic>F</italic></bold></td>
              </tr>
              <tr>
                <td style="padding-left:4pc;" rowspan="1" colspan="1">14. <bold>End for</bold></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">15. <bold>End for</bold></td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
    </sec>
    <sec>
      <title>MCL model</title>
      <p>Since each barcode covers multiple long fragment molecules (<xref ref-type="fig" rid="fig-1">Fig. 1A</xref>), using a seed clustering strategy may result in a barcode set representing more than one target area in the genome. IterCluster uses a Markov clustering model (<xref rid="ref-12" ref-type="bibr">Van Dongen, 2000</xref>) to ensure that the result of seed clustering is a set of barcodes for individual areas (<xref ref-type="fig" rid="fig-1">Fig. 1B</xref>). Specifically, assuming that a seed contains two long fragment molecules from different areas, the target barcode set will contain two clusters from different areas in the genome. However, the barcodes generated from the same area are closely related and barcodes generated from different area are distantly related. Therefore, IterCluster use a Markov clustering model to detect and classify closely-coupled barcode groups after the first clustering iteration (<xref rid="table-2" ref-type="table">Table 2</xref>).</p>
      <table-wrap id="table-2" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.8431/table-2</object-id>
        <label>Table 2</label>
        <caption>
          <title>Algorithm for divide cluster by MCL.</title>
          <p><bold><italic>s</italic></bold> is the matrix expansion coefficient (default is 2). <bold><italic>r</italic></bold> is the matrix inflation coefficient (default is 2). <bold><italic>k</italic></bold> is the column number of M. <bold><italic>p</italic></bold> is each matrix row index. <bold><italic>q</italic></bold> is each matrix column index. <bold><italic>k</italic></bold><sub>2</sub> is the number of iterations.</p>
        </caption>
        <alternatives>
          <graphic xlink:href="peerj-08-8431-g011"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th rowspan="1" colspan="1"><bold>Algorithm 2</bold> Divide cluster by MCL</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">1. Given a target barcode set <bold><italic>T</italic></bold>, build adjacent matrix <bold><italic>M</italic></bold></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">2. <bold>For</bold><bold><italic>k</italic></bold><sub><bold><italic>2</italic></bold></sub> iteration:</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">3. <italic>M</italic> = <italic>M</italic><sup><italic>s</italic></sup></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">4. <inline-formula><alternatives><inline-graphic xlink:href="peerj-08-8431-i001.jpg"/><tex-math id="M2">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}${M}_{pq}=({\Gamma }_{r}M)_{pq}= \frac{({M}_{pq})^{r}}{{\mathop{\sum }\nolimits }_{i=1}^{k}({M}_{iq})^{r}} $\end{document}</tex-math><mml:math id="mml-ieqn-74"><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mfenced separators="" open="(" close=")"><mml:msub><mml:mrow><mml:mi>Γ</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mi>M</mml:mi></mml:mfenced></mml:mrow></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mfenced separators="" open="(" close=")"><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mfenced></mml:mrow></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msubsup><mml:msup><mml:mrow><mml:mrow><mml:mfenced separators="" open="(" close=")"><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mfenced></mml:mrow></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:math></alternatives></inline-formula></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">5. <bold>End for</bold></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">6. extract sub cluster from <bold><italic>M</italic></bold></td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
      <p>MCL algorithm has two main processes, expansion and inflation, which operate on the state transition matrix. When a state transition matrix is <bold><italic>M</italic></bold>, the dimension of <bold><italic>M</italic></bold> is the number of points in the graph. Each list in <bold><italic>M</italic></bold> represents the probability of starting from a certain point at a certain time and arriving at the remaining points at the next time.</p>
      <p>The extended process is to simulate the random walk process. Taking positive integer <bold><italic>e</italic></bold> and multiply the current state transition matrix by <bold><italic>e</italic></bold> times to get a new state transition matrix, which is equivalent to a random walk on the original state transition matrix. This process can be described as: <disp-formula id="NONUM-d2e782"><alternatives><graphic xlink:href="peerj-08-8431-e002.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/><tex-math id="M3">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}\begin{eqnarray*}{M}^{{^{\prime}}}={M}^{e}. \end{eqnarray*}\end{document}</tex-math><mml:math id="mml-NONUM-d2e782"><mml:mstyle displaystyle="true"><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>e</mml:mi></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:mstyle></mml:math></alternatives></disp-formula>
</p>
      <p>The expansion process is a matrix regularization process, which regularizes the columns of the state transition matrix. The processing formula is shown as follow: <disp-formula id="NONUM-d2e808"><alternatives><graphic xlink:href="peerj-08-8431-e003.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/><tex-math id="M4">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}\begin{eqnarray*}({M}^{\ast })_{pq}= \frac{({M}_{pq})^{T}}{\sum _{i=1}^{K}({M}_{iq})^{T}} . \end{eqnarray*}\end{document}</tex-math><mml:math id="mml-NONUM-d2e808"><mml:mstyle displaystyle="true"><mml:msub><mml:mrow><mml:mrow><mml:mfenced separators="" open="(" close=")"><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msup></mml:mfenced></mml:mrow></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mfenced separators="" open="(" close=")"><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mfenced></mml:mrow></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:munderover><mml:mrow><mml:mo mathsize="big" movablelimits="false"> ∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>K</mml:mi></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mrow><mml:mfenced separators="" open="(" close=")"><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mfenced></mml:mrow></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mstyle></mml:math></alternatives></disp-formula>
</p>
      <p>Where <bold><italic>M</italic></bold> is a state transition matrix; <bold><italic>M*</italic></bold> is a regularized matrix; <bold><italic>T</italic></bold> is a relaxation coefficient; <bold><italic>K</italic></bold> is the number of rows of <bold><italic>M</italic></bold>; <bold><italic>P</italic></bold> is a row subscript; <bold><italic>q</italic></bold> is a column subscript. The function above is to regularize the columns of the transfer matrix to get the regularized matrix <bold><italic>M*</italic></bold></p>
      <p>For the <bold><italic>N</italic></bold> target barcodes obtained after the seed barcode’s first clustering iteration, the <bold><italic>N</italic></bold><italic>*</italic><bold><italic>N</italic></bold> adjacency matrix <bold><italic>M</italic></bold> was built and Markov clustering occurred. Finally, the sub-cluster can be found after MCL process.</p>
    </sec>
    <sec>
      <title>Data sources</title>
      <p>We select 2 human genome data sets to evaluate IterCluster’s performance: BGI stLFR data sets and 10× Genomics Chromium linked reads data sets (<xref rid="table-3" ref-type="table">Table 3</xref>). BGI stLFR data were obtained for sample NA12878 from the CNGB Nucleotide Sequence Archive (CNSA) with accession ID: <ext-link ext-link-type="uri" xlink:href="https://db.cngb.org/search/sample/CNS0007594/">CNS0007594</ext-link>. The data were also available from the European Nucleotide Archive with accession ID: <ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/bioproject/?term=PRJEB27414">PRJEB27414</ext-link>.</p>
      <table-wrap id="table-3" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.8431/table-3</object-id>
        <label>Table 3</label>
        <caption>
          <title>Data set properties.</title>
        </caption>
        <alternatives>
          <graphic xlink:href="peerj-08-8431-g012"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col span="1"/>
              <col span="1"/>
              <col span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th rowspan="1" colspan="1"/>
                <th rowspan="1" colspan="1">DataSet1</th>
                <th rowspan="1" colspan="1">DataSet2</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">Technology</td>
                <td rowspan="1" colspan="1">BGI’s single tube LFR</td>
                <td rowspan="1" colspan="1">10× Genomics Chromium reads</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">Barcode number</td>
                <td rowspan="1" colspan="1">1.3 * 10<sup>6</sup></td>
                <td rowspan="1" colspan="1">3.6 * 10<sup>7</sup></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">Sequence depth</td>
                <td rowspan="1" colspan="1">56×</td>
                <td rowspan="1" colspan="1">50×</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">Fragment number of each</td>
                <td rowspan="1" colspan="1">1.18</td>
                <td rowspan="1" colspan="1">8.32</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
      <p>Human Chromium linked reads data from 10× Genomics was obtained for a HGP sample, and were downloaded from the 10× Genomics company website (<ext-link ext-link-type="uri" xlink:href="https://support.10Xgenomics.com/de-novo-assembly/datasets/2.1.0/hgp">https://support.10Xgenomics.com/de-novo-assembly/datasets/2.1.0/hgp</ext-link>).</p>
    </sec>
    <sec>
      <title>Data analysis</title>
      <sec>
        <title>Barcode quality control</title>
        <p>In the stLFR dataset, there has 52872872 barcode, but only 13630103 barcode have more than 10 pair reads, the small barcode can’t find relationship with other barcode because of little unique <italic>k</italic>-mer. After filter small barcode which contain reads less than 10 pair, the barcodes’ reads pair average count is 191. In the 10× Genomics dataset, there has 1394714 barcode, all of them are more than 10 reads pair; the average reads count is 490 for barcode. So it is not necessary to filter small barcode in 10× Genomics dataset.</p>
      </sec>
      <sec>
        <title>Split barcode and reads filter</title>
        <p>We used our own pipeline to split the barcodes from reads and filtered the duplicate reads and adapters with SOAPfilter (v2.2), using the following settings: -<italic>t</italic> 30 -<italic>q</italic> 33 -<italic>p</italic> -<italic>M</italic> 2 –<italic>y</italic> –<italic>F</italic> adpter1 –<italic>R</italic> adapter2 -<italic>f</italic> -1 -<italic>Q</italic> 10, obtaining a unique <italic>k</italic>-mer frequency range of 20∼80 by <italic>k</italic>-merfreq (in-house pipeline) with –<italic>k</italic> 17. The adapter sequence can be found in <xref ref-type="supplementary-material" rid="supplemental-information">Supplemental Information</xref>. Then, we built the barcode’s relation matrix, selecting an initial seed with a unique <italic>k</italic>-mer of (–<italic>r</italic> 0.3) and a <italic>k</italic>-mer count larger than 3000 (-<italic>n</italic> 3000), and then ran IterCluster with the following parameters: -<italic>c</italic> 10 -<italic>k</italic> 3 -<italic>g</italic> 200 -<italic>f</italic>3 -<italic>t</italic> 80 -<italic>a</italic> 2 -<italic>h</italic> 12. Barcodes with read pair numbers less than 10 were deleted.</p>
        <p>The barcodes from reads were extracted using Long Ranger (v2.1.2) and the duplicate reads were filtered using SOAPfilter (v2.2) with the settings -<italic>t</italic> 30 -<italic>q</italic> 33 -<italic>p</italic> -<italic>M</italic> 2 -<italic>f</italic> -1 -<italic>Q</italic> 10. We obtained a unique <italic>k</italic>-mer frequency range 20∼60 by <italic>k</italic>-merfreq with –<italic>k</italic> 17. Then, we built the barcode’s relation matrix and ran IterCluster with the parameters -<italic>c</italic> 60 -<italic>k</italic> 2 -<italic>n</italic> 20000 -<italic>r</italic> 0.3 -<italic>g</italic> 130 -<italic>f</italic> 3 -<italic>t</italic> 45 -<italic>a</italic> 2 -<italic>h</italic> 12.</p>
      </sec>
    </sec>
    <sec>
      <title>Evaluation</title>
      <p>In our IterCluster algorithm evaluation, we build actual positive dataset by aligning reads to genome reference with bwa (<xref rid="ref-7" ref-type="bibr">Li &amp; Durbin, 2009</xref>) to know each barcode’s position on the genomes. According to the range of LFR length and reads count in each barcode (<xref ref-type="fig" rid="fig-3">Fig. 3</xref>), there are so many barcodes have little reads that haven’t enough unique kmer to find other barcodes together. we defined initial seed barcodes that must cover areas where the reads spanned larger than 500 bp in length and had more than 30 paired-ends to represent an LFR fragment and the target barcodes that belong to an LFR fragment need to have more than 5 paired-ends, which can ensure the aggregation ability of the barcode.</p>
      <fig id="fig-3" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.8431/fig-3</object-id>
        <label>Figure 3</label>
        <caption>
          <title>Reads number distribution of each barcodes in BGI’s stLFR and 10× Genomics dataset.</title>
          <p>(A) stLRF barcode’s read count histogram. (B) 10 × barcode’s read count histogram.</p>
        </caption>
        <graphic xlink:href="peerj-08-8431-g003"/>
      </fig>
      <p>After getting the cluster set, compare the IterCluster results with actual positive dataset, count the true positive barcode number that included by cluster set and actual target region barcode set, false positive barcode number that included by cluster set but actual target region barcode set in every random initial seeds’ cluster set target region. And the span region for every initial seed may extend during IterCluster, we decided extend 80 kp∼400 kbp both left and right for the initial seed span region on reference as target region to evaluate. Using a P-R curve to evaluate, determining the Precision and Recall as follows: <disp-formula id="NONUM-d2e1199"><alternatives><graphic xlink:href="peerj-08-8431-e004.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/><tex-math id="M5">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}\begin{eqnarray*}Precision= \frac{True Positive}{True Positive+False Positive} . \end{eqnarray*}\end{document}</tex-math><mml:math id="mml-NONUM-d2e1199"><mml:mstyle displaystyle="true"><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>c</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>T</mml:mi><mml:mi>r</mml:mi><mml:mi>u</mml:mi><mml:mi>e</mml:mi><mml:mspace width="1em"/><mml:mi>P</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>r</mml:mi><mml:mi>u</mml:mi><mml:mi>e</mml:mi><mml:mspace width="1em"/><mml:mi>P</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mo>+</mml:mo><mml:mi>F</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi><mml:mspace width="1em"/><mml:mi>P</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mstyle></mml:math></alternatives></disp-formula>
<disp-formula id="NONUM-d2e1310"><alternatives><graphic xlink:href="peerj-08-8431-e005.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/><tex-math id="M6">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}\begin{eqnarray*}Recall= \frac{True Positive}{True Positive+False Negative} . \end{eqnarray*}\end{document}</tex-math><mml:math id="mml-NONUM-d2e1310"><mml:mstyle displaystyle="true"><mml:mi>R</mml:mi><mml:mi>e</mml:mi><mml:mi>c</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>T</mml:mi><mml:mi>r</mml:mi><mml:mi>u</mml:mi><mml:mi>e</mml:mi><mml:mspace width="1em"/><mml:mi>P</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>r</mml:mi><mml:mi>u</mml:mi><mml:mi>e</mml:mi><mml:mspace width="1em"/><mml:mi>P</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mo>+</mml:mo><mml:mi>F</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi><mml:mspace width="1em"/><mml:mi>N</mml:mi><mml:mi>e</mml:mi><mml:mi>g</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mstyle></mml:math></alternatives></disp-formula>
</p>
    </sec>
    <sec>
      <title>IterCluster for de novo assembly</title>
      <p>In the IterCluster result, there were enough reads data in an LFR cluster set to support de novo assembly. To improve the effect of the assembly, cluster false positive reads were removed using the FalseRemove module according to an average <italic>k</italic>-mer frequency for each LFR, as we assumed that the non-target LFR <italic>k</italic>-mer frequency was lower than a targets LFR. Then, we used SOAPdenovov2 (<xref rid="ref-9" ref-type="bibr">Luo et al., 2012</xref>) to assemble each IterCluster result set. For each subassembly result, we filtered contigs less than 1 kb because these were most likely sequences assembled by false positive reads. After that, we merged each assembly result together, and evaluated the results with QUAST (<xref rid="ref-5" ref-type="bibr">Gurevich et al., 2013</xref>).</p>
    </sec>
  </sec>
  <sec sec-type="results">
    <title>Results</title>
    <sec>
      <title>IterCluster performance</title>
      <p>To evaluate the cluster size after IterCluster in two dataset. We show the barcodes number distribution (<xref ref-type="fig" rid="fig-4">Fig. 4</xref>) and reads number distribution (<xref ref-type="fig" rid="fig-5">Fig. 5</xref>) of BGI stLFR datasets and 10× Chromium reads datasets.</p>
      <fig id="fig-4" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.8431/fig-4</object-id>
        <label>Figure 4</label>
        <caption>
          <title>The distribution of cluster’s barcodes number of BGI’s stLFR and 10× Genomics dataset.</title>
          <p>(A) Generated by IterCluster with parameter -g 300, -k 2, -f 2 in BGI’s stLFR dataset. (B) Generated by IterCluster with parameter -g 150, -k 5, -f 2 in BGI’s stLFR dataset.</p>
        </caption>
        <graphic xlink:href="peerj-08-8431-g004"/>
      </fig>
      <fig id="fig-5" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.8431/fig-5</object-id>
        <label>Figure 5</label>
        <caption>
          <title>The distribution of cluster’s reads number of BGI’s stLFR and 10× Genomics dataset.</title>
          <p>(A) Generated by IterCluster with parameter -g 300, -k 2, -f 2 in BGI’s stLFR dataset. (B) Generated by IterCluster with parameter -g 150, -k 5, -f 2 in BGI’s stLFR dataset.</p>
        </caption>
        <graphic xlink:href="peerj-08-8431-g005"/>
      </fig>
      <p>To evaluate the performance of IterCluster on BGI stLFR datasets and 10× Chromium reads datasets, we plotted R-P to analyze the accuracy and recall of IterCluster. As can be seen from <xref ref-type="fig" rid="fig-6">Figs. 6A</xref>, <xref ref-type="fig" rid="fig-6">6B</xref> IterCluster’s accuracy and recall rate were high compared to baseline (<italic>k</italic> = 1). IterCluster performed better on BGI stLFR data than on 10× Chromium reads data. <xref ref-type="fig" rid="fig-6">Figures 6C</xref> and <xref ref-type="fig" rid="fig-6">6E</xref> shows the performance of different parameters using the BGI stLFR data, where the <italic>f</italic> parameter represents the lowest frequency threshold in the frequency selection model and the g parameter represents the unique <italic>k</italic>-mer number threshold between barcodes with overlap. Increasing the -<italic>f</italic> and -<italic>g</italic> values did not significantly improve the accuracy of IterCluster, but it greatly reduced the recall rate. However, from <xref ref-type="fig" rid="fig-6">Fig. 6F</xref>, we found that a slight increase in the -g value can improve the accuracy and recall rate using 10× Genomics Chromium reads data.</p>
      <fig id="fig-6" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.8431/fig-6</object-id>
        <label>Figure 6</label>
        <caption>
          <title>The preference of IterCluster on stLFR and 10× Genomics Chromium read with different parameter.</title>
          <p>(A) Generated by IterCluster with different -k parameter in BGI’s stLFR dataset. (B) Generated by IterCluster with different -k parameter in 10× Genomics Chromium read dataset. (C) Generated by IterCluster with different -f parameter in BGI’s stLFR dataset. (D) Generated by IterCluster with different -f parameter in 10× Genomics Chromium read dataset. (E) Generated by IterCluster with different -g parameter in BGI’s stLFR dataset. (F) Generated by IterCluster with different -g parameter in 10× Genomics Chromium read dataset.</p>
        </caption>
        <graphic xlink:href="peerj-08-8431-g006"/>
      </fig>
      <fig id="fig-7" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.8431/fig-7</object-id>
        <label>Figure 7</label>
        <caption>
          <title>The preference of IterCluster using stLFR data with different <italic>K</italic> values.</title>
        </caption>
        <graphic xlink:href="peerj-08-8431-g007"/>
      </fig>
      <p>An important factor affecting the precision of IterCluster was the repeat sequences in genome. That is why we choose unique kmers as features. The <italic>K</italic> value (the base number of each kmer) is an important parameter because it determines the specificity of a kmer. We thus studied IterCluster’s performance with different <italic>K</italic> values using BGI’s stLFR data. <xref ref-type="fig" rid="fig-7">Figure 7</xref> shows that IterCluster can achieve higher precision and recall with larger <italic>K</italic> values.</p>
    </sec>
    <sec>
      <title><bold><italic>k</italic></bold>-mer frequency diversity selection model improve clusting</title>
      <p>IterCluster needs to deal with two key issues in clusting: (1) how to determine the overlap between barcodes; (2) how to avoid false positives overlap caused by multiple fragments contained in the same barcode. These two issues are described in detail below.</p>
      <p>In regard to the first issue, because overlap between different barcodes means that these barcodes will contain common unique <italic>k</italic>-mer, we use the number of common unique <italic>k</italic>-mer to measure the distance between barcodes. In the IterCluster, a user-specified common unique <italic>k</italic>-mer threshold (-g parameter) is used to determine whether two barcodes contain overlap. This threshold must be high enough that repeats and sequencing error do not result in false overlaps yet low enough that slight overlaps overlaps between fragments can be detected. This threshold can be estimated by the the distance distribution between all barcodes (<xref ref-type="fig" rid="fig-8">Fig. 8A</xref>).</p>
      <fig id="fig-8" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.8431/fig-8</object-id>
        <label>Figure 8</label>
        <caption>
          <title>An illustration of common unique <italic>k</italic>-mer threshold estimation and minimum unique <italic>k</italic>-mer frequency estimation.</title>
          <p>(A) A histogram of common unique <italic>k</italic>-mer number for 10,000 randomly selected seeds with the user-specific threshold shown as a dashed line for BGI’s stLFR data. All connection which common unique <italic>k</italic>-mer up to 100 was considered to be a true overlap between barcode. The connection which common unique <italic>k</italic>-mer lower than 10 has been calculated but filtered. (B) A histogram of unique <italic>k</italic>-mer frequency for 100 randomly selected clusters’ first iteration for BGI’s stLFR data. The user-specific threshold was shown as a dashed line. All unique <italic>k</italic>-mer with frequency high than 3 within a cluster’s first iteration was considered to be feature unique <italic>k</italic>-mer for next iteration. The unique <italic>k</italic>-mer which frequency is too high (&gt;100) has been filter on this histogram.</p>
        </caption>
        <graphic xlink:href="peerj-08-8431-g008"/>
      </fig>
      <p>Another issue is caused by multiple fragment contained in barcode. Most of target barcodes carry a fragment from seed barcode area but carry fragments from other areas of the genome randomly. Therefore, after each cluster iteration, the feature of the seed barcode area (unique <italic>k</italic>-mer) need to be updated to prevent non-target area’s unique <italic>k</italic>-mer from being used as feature for the next iteration of clusting. When choosing feature unique <italic>k</italic>-mer, IterCluster uses a unique <italic>k</italic>-mer selection model based on <italic>k</italic>-mer frequency diversity. The key idea is that after each iteration of the cluster, the unique <italic>k</italic>-mer frequency from seed barcode area is higher than the unique <italic>k</italic>-mer frequency from non-seed barcode area, because target barcode always has an overlap with seed barcode. Base on frequency diversity, IterCluster provides a user-specified minimum frequency threshold (-f parameter) to filter the unique <italic>k</italic>-mer from non-seed barcode area. This threshold can be estimated from the unique <italic>k</italic>-mer frequency distribution after each clusting iteration (<xref ref-type="fig" rid="fig-8">Fig. 8B</xref>).</p>
      <p>To evaluate the effect of the frequency diversity selection model in controlling false positives, we compared the performance of IterCluster with or without this model (<xref ref-type="fig" rid="fig-9">Fig. 9</xref>). When iteration <italic>k</italic> = 2, the number of unique <italic>k</italic>-mers in non-seed fragment area is still very small, and the frequency selection model has slight effect on IterCluster. However, when the number of iteration increased (<italic>k</italic> = 3), the false positive rate of IterCluster without frequency diversity selection model is significantly increased. This shows that the frequency selection model can control false positive rate with the number of iteration increased.</p>
      <fig id="fig-9" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.8431/fig-9</object-id>
        <label>Figure 9</label>
        <caption>
          <title>The comparison of IterCluster’s performance with and without <italic>k</italic>-mer frequency diversity selection model for BGI’s stLFR data.</title>
          <p>(A) The iteration k was set to 2. (B) The iteration <italic>k</italic> was set to 3.</p>
        </caption>
        <graphic xlink:href="peerj-08-8431-g009"/>
      </fig>
    </sec>
    <sec>
      <title>Runtime and memory cost</title>
      <p>IterCluster’s runtime and memory cost largely depends on the parameter <italic>K</italic>, the kmer size used to calculate the adjacency matrix. The runtime and RAM usage for IterCluster with different <italic>K</italic> values is shown in <xref rid="table-4" ref-type="table">Table 4</xref>. The time and memory cost of IterCluster mainly stem from the adjacency matrix construction step of this algorithm. The larger the <italic>K</italic> value, the more kmer numbers, and the more time is needed to calculate the relation between all kmers. However, changes in K do not greatly affect memory consumption. Although a larger <italic>K</italic> value means a larger hash is needed to map all of the kmers, for each single kmer, the number of barcodes containing the kmer decreases. Therefore, the consumption of memory is stable and only decided by the amount of data. IterCluster is a highly parallel tool, both in the matrix build step and in its clustering step. We demonstrated that IterCluster can finish a 50-fold human whole genome dataset in 4 days with 50 threads.</p>
      <table-wrap id="table-4" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.8431/table-4</object-id>
        <label>Table 4</label>
        <caption>
          <title>Runtime and memory cost of IterCluster with different <italic>K</italic> values.</title>
          <p>IterCluster run on BGIs stLFR data with default parameters and different <italic>K</italic> values. The thread number was set to 50.</p>
        </caption>
        <alternatives>
          <graphic xlink:href="peerj-08-8431-g013"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col span="1"/>
              <col span="1"/>
              <col span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th rowspan="1" colspan="1"/>
                <th rowspan="1" colspan="1">
                  <bold>Memory</bold>
                </th>
                <th rowspan="1" colspan="1">
                  <bold>Time</bold>
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">17-mer</td>
                <td rowspan="1" colspan="1">327G</td>
                <td rowspan="1" colspan="1">73 h</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">15-mer</td>
                <td rowspan="1" colspan="1">333G</td>
                <td rowspan="1" colspan="1">37 h</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">13-mer</td>
                <td rowspan="1" colspan="1">326G</td>
                <td rowspan="1" colspan="1">12 h</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
    </sec>
    <sec>
      <title>IterCluster improves de novo assembly using a divide-and-conquer strategy</title>
      <p>We used IterCluster to improve the de novo assembly of human genome stLFR data from BGI via a divide-and-conquer strategy. First, we ran IterCluster on whole human genome stLFR data with default parameters. For each barcode cluster, we filtered the false positive reads with the FalseRemove module which was also added to our pipeline and assembly tasks were performed independently using SOAPdenovo2 (<xref rid="ref-9" ref-type="bibr">Luo et al., 2012</xref>). After the subassembly of each cluster, the assembly results from different clusters were integrated together. We call this assembly strategy “divide-and-conquer” or subassembly. In comparison to a baseline SOAPdenovo2 assembly using all reads (<xref rid="table-5" ref-type="table">Table 5</xref>), assembly with this divide-and-conquer strategy achieved a longer contig length, as measured by the N50 length metric, of 11.9k, representing a 67% increase over the initial baseline achieved using SOAPdenovo2 assembly from all of the reads. Assembly with our divide-and-conquer strategy achieved a 30% increase in scaffold creation (N50 = 17.1K) and a slight improvement in genome coverage. This suggests that IterCluster uses more of the long-range information present in stLFR data to break down a complex chromosomal genome into multiple simple sub-sections.</p>
      <table-wrap id="table-5" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj.8431/table-5</object-id>
        <label>Table 5</label>
        <caption>
          <title>Comparison of the performance of de novo assembly between divide-and-conquer strategy and normal method.</title>
        </caption>
        <alternatives>
          <graphic xlink:href="peerj-08-8431-g014"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col span="1"/>
              <col span="1"/>
              <col span="1"/>
              <col span="1"/>
              <col span="1"/>
              <col span="1"/>
              <col span="1"/>
              <col span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th rowspan="1" colspan="1"/>
                <th align="center" colspan="3" rowspan="1">
                  <bold>Contigs</bold>
                </th>
                <th align="center" colspan="3" rowspan="1">
                  <bold>Scaffolds</bold>
                </th>
              </tr>
              <tr>
                <th rowspan="1" colspan="1"/>
                <th rowspan="1" colspan="1">
                  <bold>N50(bp)</bold>
                </th>
                <th rowspan="1" colspan="1">
                  <bold>Cov.(%)</bold>
                </th>
                <th rowspan="1" colspan="1">
                  <bold>Misass.(#/sum)</bold>
                </th>
                <th rowspan="1" colspan="1">
                  <bold>N50(bp)</bold>
                </th>
                <th rowspan="1" colspan="1">
                  <bold>Cov.(%)</bold>
                </th>
                <th rowspan="1" colspan="1">
                  <bold>Misass.(#/sum)</bold>
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">Cluster</td>
                <td rowspan="1" colspan="1">
                  <bold>11,937</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>90.67</bold>
                </td>
                <td rowspan="1" colspan="1">4,859/30M</td>
                <td rowspan="1" colspan="1">
                  <bold>17,188</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>91.00</bold>
                </td>
                <td rowspan="1" colspan="1">6,236/58M</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">Uncluster</td>
                <td rowspan="1" colspan="1">7 127</td>
                <td rowspan="1" colspan="1">88.45</td>
                <td rowspan="1" colspan="1">1,626/9M</td>
                <td rowspan="1" colspan="1">13 216</td>
                <td rowspan="1" colspan="1">89.49</td>
                <td rowspan="1" colspan="1">2,819/ 27M</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
    </sec>
  </sec>
  <sec sec-type="discussion">
    <title>Discussion</title>
    <p>Supernova is an efficient and excellent assembly algorithm specifically designed for use with 10× Genomics Chromium reads data that capitalizes on a de Bruijn graph (DBG) strategy, leading to assembly of contigs with N50 up to 100 kb (<xref rid="ref-15" ref-type="bibr">Weisenfeld et al., 2017</xref>). However, stLFR data cannot be assembled using supernova, because supernova only accepts the unique characteristics of 10× Genomics Chromium reads, such as the barcode number and the amount of data for each barcode. The improvement of the contig N50 using a divide-and-conquer assembly strategy suggests that IterCluster can reduce the complexity of de novo assembly through local assembly, and thus provides a platform for de novo assembly using stLFR data. In contrast to TSLR technology, IterCluster capture reads from fragment overlap using a seed and achieves local assembly, so it does not actually improve the local coverage of each fragment and the captured reads contain all of the same haplotype, making it unsuitable for haplotype phasing.</p>
  </sec>
  <sec sec-type="conclusions">
    <title>Conclusions</title>
    <p>We have introduced IterCluster, a novel algorithm providing an optional solution to the barcode cluster problem. IterCluster provides a conservative solution for exploring the potential relationships between barcodes and realizes barcode clustering based on a <italic>k</italic>-mer frequency selection model. Relying on IterCluster, the barcodes of a certain area in the genome can be enriched, thus achieving de novo assembly by a divide-and-conquer strategy.</p>
    <p>The current version of IterCluster provides reasonable performance, but this jumps up to 350 cpu-hours for clustering barcode from some large-scale datasets. Although a time-efficient way to generate adjacency matrices have been developed, the size of an intersection between optional barcodes and a seed must be recalculated, because the feature <italic>k</italic>-mers are updated after each clustering round. A large performance bottleneck is that the recalculation method is naive and precise. Future versions of IterCluster will employ local sensitive hashes (<xref rid="ref-2" ref-type="bibr">Charikar, 2002</xref>) to improve the performance.</p>
    <p>In contrast, IterCluster uses the same relation threshold (<italic>-g</italic>) to capture target barcodes, but using the same relation threshold on each cluster round is unbefitting and future versions will consider more appropriate criteria for capturing barcodes. Also, the same relation threshold was used to measure the relation of each barcode. However, the number of reads and fragments on each barcode are different, and a more appropriate mathematical model is needed to measure the relation between barcodes.</p>
    <p>Overall, we believe that IterCluster is a significant tool for taking advantage of LFR data. LFR data has the potential to improve de novo assembly and to allow local assembly.</p>
  </sec>
  <sec sec-type="supplementary-material" id="supplemental-information">
    <title> Supplemental Information</title>
    <supplementary-material content-type="local-data" id="supp-1">
      <object-id pub-id-type="doi">10.7717/peerj.8431/supp-1</object-id>
      <label>Supplemental Information 1</label>
      <caption>
        <title>IterCluster analysis and evaluation pipeline workflow</title>
      </caption>
      <media xlink:href="peerj-08-8431-s001.docx">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <p>We would like to acknowledge the ongoing contributions and support of MGI’s algorithm team, in particular Jingbo Tang and Weihua Huang for their suggestions towards LFR data analysis and algorithm performance optimization. We would also like to thank BGI-Shenzhen for providing the stLFR data and information about its characteristics. We thank LetPub for its linguistic assistance during the preparation of this manuscript.</p>
  </ack>
  <sec sec-type="additional-information">
    <title>Additional Information and Declarations</title>
    <fn-group content-type="competing-interests">
      <title>Competing Interests</title>
      <fn id="conflict-1" fn-type="COI-statement">
        <p>Jiancong Weng, Tian Chen and Yinlong Xie are employees of MGI. Xun Xu is a group leader of BGI-shenzhen. Brock A. Peters and Radoje Drmanac are scientists at BGI-shenzhen.</p>
      </fn>
    </fn-group>
    <fn-group content-type="author-contributions">
      <title>Author Contributions</title>
      <fn id="contribution-1" fn-type="con">
        <p><xref ref-type="contrib" rid="author-1">Jiancong Weng</xref> performed the experiments, prepared figures and/or tables, authored or reviewed drafts of the paper, develop the software, and approved the final draft.</p>
      </fn>
      <fn id="contribution-2" fn-type="con">
        <p><xref ref-type="contrib" rid="author-2">Tian Chen</xref> analyzed the data, prepared figures and/or tables, and approved the final draft.</p>
      </fn>
      <fn id="contribution-3" fn-type="con">
        <p><xref ref-type="contrib" rid="author-3">Yinlong Xie</xref> and <xref ref-type="contrib" rid="author-5">Gengyun Zhang</xref> conceived and designed the experiments, authored or reviewed drafts of the paper, and approved the final draft.</p>
      </fn>
      <fn id="contribution-4" fn-type="con">
        <p><xref ref-type="contrib" rid="author-4">Xun Xu</xref>, <xref ref-type="contrib" rid="author-6">Brock A. Peters</xref> and <xref ref-type="contrib" rid="author-7">Radoje Drmanac</xref> conceived and designed the experiments, prepared figures and/or tables, coordinated the study, and approved the final draft.</p>
      </fn>
    </fn-group>
    <fn-group content-type="other">
      <title>Data Availability</title>
      <fn id="addinfo-1">
        <p>The following information was supplied regarding data availability:</p>
        <p>Data is available at GitHub: <ext-link ext-link-type="uri" xlink:href="https://github.com/JianCong-WENG/IterCluster">https://github.com/JianCong-WENG/IterCluster</ext-link>.</p>
      </fn>
    </fn-group>
  </sec>
  <ref-list content-type="authoryear">
    <title>References</title>
    <ref id="ref-1">
      <label>Berlin et al. (2015)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Berlin</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Koren</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Chin</surname>
            <given-names>C-S</given-names>
          </name>
          <name>
            <surname>Drake</surname>
            <given-names>JP</given-names>
          </name>
          <name>
            <surname>Landolin</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Phillippy</surname>
            <given-names>AM</given-names>
          </name>
        </person-group>
        <year>2015</year>
        <article-title>Assembling large genomes with single-molecule sequencing and locality-sensitive hashing</article-title>
        <source>Nature Biotechnology</source>
        <volume>33</volume>
        <fpage>623</fpage>
        <lpage>630</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.3238</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-2">
      <label>Charikar (2002)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Charikar</surname>
            <given-names>MS</given-names>
          </name>
        </person-group>
        <year>2002</year>
        <article-title>Similarity estimation techniques from rounding algorithms</article-title>
        <conf-name>Thiry-fourth ACM symposium on theory of computing</conf-name>
        <conf-sponsor>ACM</conf-sponsor>
        <fpage>380</fpage>
        <lpage>388</lpage>
      </element-citation>
    </ref>
    <ref id="ref-3">
      <label>Coombe et al. (2018)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Coombe</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Vandervalk</surname>
            <given-names>BP</given-names>
          </name>
          <name>
            <surname>Chu</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Jackman</surname>
            <given-names>SD</given-names>
          </name>
          <name>
            <surname>Birol</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Warren</surname>
            <given-names>RL</given-names>
          </name>
        </person-group>
        <year>2018</year>
        <article-title>ARKS: chromosome-scale scaffolding of human genome drafts with linked read kmers</article-title>
        <source>BMC Bioinformatics</source>
        <volume>19</volume>
        <issue>1</issue>
        <fpage>234</fpage>
        <pub-id pub-id-type="doi">10.1186/s12859-018-2243-x</pub-id>
        <pub-id pub-id-type="pmid">29925315</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-4">
      <label>Danko et al. (2019)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Danko</surname>
            <given-names>DC</given-names>
          </name>
          <name>
            <surname>Meleshko</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Bezdan</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Mason</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Hajirasouliha</surname>
            <given-names>I</given-names>
          </name>
        </person-group>
        <year>2019</year>
        <article-title>Minerva: an alignment- and reference-free approach to deconvolve linked-reads for metagenomics</article-title>
        <source>Genome Research</source>
        <volume>29</volume>
        <fpage>116</fpage>
        <lpage>124</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.235499.118</pub-id>
        <pub-id pub-id-type="pmid">30523036</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-5">
      <label>Gurevich et al. (2013)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gurevich</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Saveliev</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Vyahhi</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Tesler</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <year>2013</year>
        <article-title>QUAST: quality assessment tool for genome assemblies</article-title>
        <source>Bioinformatics</source>
        <volume>29</volume>
        <fpage>1072</fpage>
        <lpage>1075</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btt086</pub-id>
        <pub-id pub-id-type="pmid">23422339</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-6">
      <label>Kuleshov, Snyder &amp; Batzoglou (2016)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kuleshov</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Snyder</surname>
            <given-names>MP</given-names>
          </name>
          <name>
            <surname>Batzoglou</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <year>2016</year>
        <article-title>Genome assembly from synthetic long read clouds</article-title>
        <source>Bioinformatics</source>
        <volume>32</volume>
        <issue>12</issue>
        <fpage>i216</fpage>
        <lpage>i224</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btw267</pub-id>
        <pub-id pub-id-type="pmid">27307620</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-7">
      <label>Li &amp; Durbin (2009)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <year>2009</year>
        <article-title>Fast and accurate short read alignment with Burrows–Wheeler transform</article-title>
        <source>Bioinformatics</source>
        <volume>25</volume>
        <issue>14</issue>
        <fpage>1754</fpage>
        <lpage>1760</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp324</pub-id>
        <pub-id pub-id-type="pmid">19451168</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-8">
      <label>Li et al. (2015)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Hsieh</surname>
            <given-names>C-L</given-names>
          </name>
          <name>
            <surname>Young</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Ren</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Zhao</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <year>2015</year>
        <article-title>Illumina synthetic long read sequencing allows recovery of missing sequences even in the finished C. elegans genome</article-title>
        <source>Scientific Reports</source>
        <volume>5</volume>
        <fpage>10814</fpage>
        <pub-id pub-id-type="doi">10.1038/srep10814</pub-id>
        <pub-id pub-id-type="pmid">26039588</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-9">
      <label>Luo et al. (2012)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Luo</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Xie</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Huang</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Yuan</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>He</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Pan</surname>
            <given-names>Q</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Tang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Wu</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Shi</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Yu</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Lu</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Han</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Cheung</surname>
            <given-names>DW</given-names>
          </name>
          <name>
            <surname>Yiu</surname>
            <given-names>S-M</given-names>
          </name>
          <name>
            <surname>Peng</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Xiaoqian</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Liao</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Yang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Lam</surname>
            <given-names>T-W</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <year>2012</year>
        <article-title>SOAPdenovo2: an empirically improved memory-efficient short-read de novo assembler</article-title>
        <source>GigaScience</source>
        <volume>1</volume>
        <issue>1</issue>
        <fpage>18</fpage>
        <pub-id pub-id-type="doi">10.1186/2047-217X-1-18</pub-id>
        <pub-id pub-id-type="pmid">23587118</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-10">
      <label>McCoy et al. (2014)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>McCoy</surname>
            <given-names>RC</given-names>
          </name>
          <name>
            <surname>Taylor</surname>
            <given-names>RW</given-names>
          </name>
          <name>
            <surname>Blauwkamp</surname>
            <given-names>TA</given-names>
          </name>
          <name>
            <surname>Kelley</surname>
            <given-names>JL</given-names>
          </name>
          <name>
            <surname>Kertesz</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Pushkarev</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Petrov</surname>
            <given-names>DA</given-names>
          </name>
          <name>
            <surname>Fiston-Lavier</surname>
            <given-names>A-S</given-names>
          </name>
        </person-group>
        <year>2014</year>
        <article-title>Illumina TruSeq synthetic long-reads empower de novo assembly and resolve complex, highly-repetitive transposable elements</article-title>
        <source>PLOS ONE</source>
        <volume>9</volume>
        <elocation-id>e106689</elocation-id>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0106689</pub-id>
        <pub-id pub-id-type="pmid">25188499</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-11">
      <label>Ondov et al. (2016)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ondov</surname>
            <given-names>BD</given-names>
          </name>
          <name>
            <surname>Treangen</surname>
            <given-names>TJ</given-names>
          </name>
          <name>
            <surname>Melsted</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Mallonee</surname>
            <given-names>AB</given-names>
          </name>
          <name>
            <surname>Bergman</surname>
            <given-names>NH</given-names>
          </name>
          <name>
            <surname>Koren</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Phillippy</surname>
            <given-names>AM</given-names>
          </name>
        </person-group>
        <year>2016</year>
        <article-title>Mash: fast genome and metagenome distance estimation using MinHash</article-title>
        <source>Genome Biology</source>
        <volume>17</volume>
        <issue>1</issue>
        <fpage>132</fpage>
        <pub-id pub-id-type="doi">10.1186/s13059-016-0997-x</pub-id>
        <pub-id pub-id-type="pmid">27323842</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-12">
      <label>Van Dongen (2000)</label>
      <element-citation publication-type="thesis">
        <person-group person-group-type="author">
          <name>
            <surname>Van Dongen</surname>
            <given-names>SM</given-names>
          </name>
        </person-group>
        <year>2000</year>
        <article-title>Graph clustering by flow simulation</article-title>
        <source>Ph.D. thesis</source>
        <institution>University of Utrecht</institution>
      </element-citation>
    </ref>
    <ref id="ref-13">
      <label>Voskoboynik et al. (2013)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Voskoboynik</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Neff</surname>
            <given-names>NF</given-names>
          </name>
          <name>
            <surname>Sahoo</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Newman</surname>
            <given-names>AM</given-names>
          </name>
          <name>
            <surname>Pushkarev</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Koh</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Passarelli</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Fan</surname>
            <given-names>HC</given-names>
          </name>
          <name>
            <surname>Mantalas</surname>
            <given-names>GL</given-names>
          </name>
          <name>
            <surname>Palmeri</surname>
            <given-names>KJ</given-names>
          </name>
          <name>
            <surname>Ishizuka</surname>
            <given-names>KJ</given-names>
          </name>
          <name>
            <surname>Gissi</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Griggio</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Ben-Shlomo</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Corey</surname>
            <given-names>DM</given-names>
          </name>
          <name>
            <surname>Penland</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>White</surname>
            <given-names>RA</given-names>
          </name>
          <name>
            <surname>Weissman</surname>
            <given-names>IL</given-names>
          </name>
          <name>
            <surname>Quake</surname>
            <given-names>SR</given-names>
          </name>
        </person-group>
        <year>2013</year>
        <article-title>The genome sequence of the colonial chordate, Botryllus schlosseri</article-title>
        <source>eLife</source>
        <volume>2</volume>
        <issue>192</issue>
        <fpage>1953</fpage>
        <lpage>1965</lpage>
      </element-citation>
    </ref>
    <ref id="ref-14">
      <label>Wang et al. (2018)</label>
      <element-citation publication-type="working-paper">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Chin</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Cheng</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Wu</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Mao</surname>
            <given-names>Q</given-names>
          </name>
          <name>
            <surname>Tang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Sun</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Lam</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Zhou</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Fan</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Zou</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Anderson</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Xie</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Drmanac</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Nguyen</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Xu</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Villarosa</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Gablenz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Barua</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Nguyen</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Tian</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Qi</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Dong</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Alexeev</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Yang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Kristiansen</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Xu</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Drmanac</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Peters</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <year>2018</year>
        <article-title>Single tube bead-based DNA co-barcoding for cost effective and accurate sequencing, haplotyping, and assembly</article-title>
        <source>bioRxiv</source>
        <fpage>324392</fpage>
      </element-citation>
    </ref>
    <ref id="ref-15">
      <label>Weisenfeld et al. (2017)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Weisenfeld</surname>
            <given-names>NI</given-names>
          </name>
          <name>
            <surname>Kumar</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Shah</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Church</surname>
            <given-names>DM</given-names>
          </name>
          <name>
            <surname>Jaffe</surname>
            <given-names>DB</given-names>
          </name>
        </person-group>
        <year>2017</year>
        <article-title>Direct determination of diploid genome sequences</article-title>
        <source>Genome Research</source>
        <volume>27</volume>
        <fpage>757</fpage>
        <lpage>767</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.214874.116</pub-id>
        <pub-id pub-id-type="pmid">28381613</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-16">
      <label>Zheng et al. (2016)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zheng</surname>
            <given-names>GXY</given-names>
          </name>
          <name>
            <surname>Lau</surname>
            <given-names>BT</given-names>
          </name>
          <name>
            <surname>Schnall-Levin</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Jarosz</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Bell</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Hindson</surname>
            <given-names>CM</given-names>
          </name>
          <name>
            <surname>Kyriazopoulou-Panagiotopoulou</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Masquelier</surname>
            <given-names>DA</given-names>
          </name>
          <name>
            <surname>Merrill</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Terry</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Mudivarti</surname>
            <given-names>PA</given-names>
          </name>
          <name>
            <surname>Wyatt</surname>
            <given-names>PW</given-names>
          </name>
          <name>
            <surname>Bharadwaj</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Makarewicz</surname>
            <given-names>AJ</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Belgrader</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Price</surname>
            <given-names>AD</given-names>
          </name>
          <name>
            <surname>Lowe</surname>
            <given-names>AJ</given-names>
          </name>
          <name>
            <surname>Marks</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Vurens</surname>
            <given-names>GM</given-names>
          </name>
          <name>
            <surname>Hardenbol</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Montesclaros</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Luo</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Greenfield</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Wong</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Birch</surname>
            <given-names>DE</given-names>
          </name>
          <name>
            <surname>Short</surname>
            <given-names>SW</given-names>
          </name>
          <name>
            <surname>Bjornson</surname>
            <given-names>KP</given-names>
          </name>
          <name>
            <surname>Patel</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Hopmans</surname>
            <given-names>ES</given-names>
          </name>
          <name>
            <surname>Wood</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Kaur</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Lockwood</surname>
            <given-names>GK</given-names>
          </name>
          <name>
            <surname>Stafford</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Delaney</surname>
            <given-names>JP</given-names>
          </name>
          <name>
            <surname>Wu</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Ordonez</surname>
            <given-names>HS</given-names>
          </name>
          <name>
            <surname>Grimes</surname>
            <given-names>SM</given-names>
          </name>
          <name>
            <surname>Greer</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>JY</given-names>
          </name>
          <name>
            <surname>Belhocine</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Giorda</surname>
            <given-names>KM</given-names>
          </name>
          <name>
            <surname>Heaton</surname>
            <given-names>WH</given-names>
          </name>
          <name>
            <surname>McDermott</surname>
            <given-names>GP</given-names>
          </name>
          <name>
            <surname>Bent</surname>
            <given-names>ZW</given-names>
          </name>
          <name>
            <surname>Meschi</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Kondov</surname>
            <given-names>NO</given-names>
          </name>
          <name>
            <surname>Wilson</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Bernate</surname>
            <given-names>JA</given-names>
          </name>
          <name>
            <surname>Gauby</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Kindwall</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Bermejo</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Fehr</surname>
            <given-names>AN</given-names>
          </name>
          <name>
            <surname>Chan</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Saxonov</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Ness</surname>
            <given-names>KD</given-names>
          </name>
          <name>
            <surname>Hindson</surname>
            <given-names>BJ</given-names>
          </name>
          <name>
            <surname>Ji</surname>
            <given-names>HP</given-names>
          </name>
        </person-group>
        <year>2016</year>
        <article-title>Haplotyping germline and cancer genomes with high-throughput linked-read sequencing</article-title>
        <source>Nature Biotechnology</source>
        <volume>34</volume>
        <fpage>303</fpage>
        <lpage>311</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.3432</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
