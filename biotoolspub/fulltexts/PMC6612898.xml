<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6612898</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btz393</article-id>
    <article-id pub-id-type="publisher-id">btz393</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Ismb/Eccb 2019 Conference Proceedings</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Systems Biology and Networks</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>MCS<sup>2</sup>: minimal coordinated supports for fast enumeration of minimal cut sets in metabolic networks</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Miraskarshahi</surname>
          <given-names>Reza</given-names>
        </name>
        <xref ref-type="aff" rid="btz393-aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Zabeti</surname>
          <given-names>Hooman</given-names>
        </name>
        <xref ref-type="aff" rid="btz393-aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Stephen</surname>
          <given-names>Tamon</given-names>
        </name>
        <xref ref-type="aff" rid="btz393-aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Chindelevitch</surname>
          <given-names>Leonid</given-names>
        </name>
        <xref ref-type="aff" rid="btz393-aff1">1</xref>
        <xref ref-type="corresp" rid="btz393-cor1"/>
        <!--<email>leonid@sfu.ca</email>-->
      </contrib>
    </contrib-group>
    <aff id="btz393-aff1"><label>1</label>School of Computing Science, Simon Fraser University, Burnaby, BC, Canada</aff>
    <aff id="btz393-aff2"><label>2</label>Department of Mathematics, Simon Fraser University, Burnaby, BC, Canada</aff>
    <author-notes>
      <corresp id="btz393-cor1">To whom correspondence should be addressed. <email>leonid@sfu.ca</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2019-07-05">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>35</volume>
    <issue>14</issue>
    <fpage>i615</fpage>
    <lpage>i623</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2019. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2019</copyright-year>
      <license license-type="cc-by-nc" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btz393.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Constraint-based modeling of metabolic networks helps researchers gain insight into the metabolic processes of many organisms, both prokaryotic and eukaryotic. Minimal cut sets (MCSs) are minimal sets of reactions whose inhibition blocks a target reaction in a metabolic network. Most approaches for finding the MCSs in constrained-based models require, either as an intermediate step or as a byproduct of the calculation, the computation of the set of elementary flux modes (EFMs), a convex basis for the valid flux vectors in the network. Recently, Ballerstein <italic>et al.</italic> proposed a method for computing the MCSs of a network without first computing its EFMs, by creating a dual network whose EFMs are a superset of the MCSs of the original network. However, their dual network is always larger than the original network and depends on the target reaction. Here we propose the construction of a different dual network, which is typically smaller than the original network and is independent of the target reaction, for the same purpose. We prove the correctness of our approach, minimal coordinated support (MCS<sup>2</sup>), and describe how it can be modified to compute the few smallest MCSs for a given target reaction.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We compare MCS<sup>2</sup> to the method of Ballerstein <italic>et al.</italic> and two other existing methods. We show that MCS<sup>2</sup> succeeds in calculating the full set of MCSs in many models where other approaches cannot finish within a reasonable amount of time. Thus, in addition to its theoretical novelty, our approach provides a practical advantage over existing methods.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>MCS<sup>2</sup> is freely available at <ext-link ext-link-type="uri" xlink:href="https://github.com/RezaMash/MCS">https://github.com/RezaMash/MCS</ext-link> under the GNU 3.0 license.</p>
      </sec>
      <sec id="s4">
        <title>Supplementary information</title>
        <p><xref ref-type="supplementary-material" rid="sup1">Supplementary data</xref> are available at <italic>Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">NSERC Discovery Grant</named-content>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">Sloan Foundation Fellowship</named-content>
        </funding-source>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Constraint-based modeling of metabolic networks has been a major subfield of systems biology thanks to its ability to identify key qualitative characteristics of networks for analyzing and extracting useful information (<xref rid="btz393-B4" ref-type="bibr">Bordbar <italic>et al.</italic>, 2014</xref>; <xref rid="btz393-B22" ref-type="bibr">Lewis <italic>et al.</italic>, 2012</xref>; <xref rid="btz393-B27" ref-type="bibr">Price <italic>et al.</italic>, 2004</xref>). A metabolic network is a collection of chemical reactions which comprise the metabolic activities (i.e. the biochemical transformation of molecules into other molecules for the purpose of maintenance and growth) of a specific organism. One important application of metabolic network analysis is to find interventions that can block a reaction of interest, typically referred to as the <italic>target reaction</italic>, with applications in drug target identification (<xref rid="btz393-B11" ref-type="bibr">Harder <italic>et al.</italic>, 2016</xref>; <xref rid="btz393-B12" ref-type="bibr">Hartman <italic>et al.</italic>, 2014</xref>; <xref rid="btz393-B15" ref-type="bibr">Imielinski and Belta, 2008</xref>; <xref rid="btz393-B36" ref-type="bibr">Trinh <italic>et al.</italic>, 2006</xref>; <xref rid="btz393-B40" ref-type="bibr">von Kamp and Klamt, 2017</xref>) and metabolic engineering (<xref rid="btz393-B25" ref-type="bibr">Mahadevan <italic>et al.</italic>, 2015</xref>). When this is achieved by disabling one or more other reactions, the disabled reactions are called a <italic>cut set</italic>. A cut set is called ‘minimal’ if no proper subset of it can disable the target reaction. The concept of minimal cut sets (MCS) was introduced by <xref rid="btz393-B19" ref-type="bibr">Klamt and Gilles (2004)</xref> and its applications are examined in detail in <xref rid="btz393-B17" ref-type="bibr">Klamt (2006)</xref>.</p>
    <p>At the moment, the main approach used for enumerating the MCSs for a target reaction is to compute the elementary flux modes (EFMs) containing the target and then use a dualization procedure to produce the MCSs (<xref rid="btz393-B10" ref-type="bibr">Gainer-Dewar and Vera-Licona, 2017</xref>). Here, <italic>flux modes</italic> are possible distributions of fluxes through the reactions, and those can be modeled as hyperedges on the vertex set of possible reactions. <italic>EFMs</italic> are flux modes which are support-minimal, and it is known that any flux mode can be written as a non-negative linear combination of EFMs. Given the full set of EFMs, MCS can be obtained through the dualization of the hypergraph they define (<xref rid="btz393-B13" ref-type="bibr">Haus <italic>et al.</italic>, 2008</xref>; <xref rid="btz393-B19" ref-type="bibr">Klamt and Gilles, 2004</xref>). Two approaches to do this are Berge’s algorithm (<xref rid="btz393-B3" ref-type="bibr">Berge, 1984</xref>) and Fredman and Khachiyan’s dualization procedure (<xref rid="btz393-B8" ref-type="bibr">Fredman and Khachiyan, 1996</xref>). However, both suffer from poor worst-case complexity and produce mixed results in practice. A comparatively new approach (<xref rid="btz393-B2" ref-type="bibr">Ballerstein <italic>et al.</italic>, 2012</xref>) produces the MCSs without first computing the EFMs. It works by generating a dual network, which is larger than the original network and depends on the target reaction, and then computing a subset of the EFMs of that network with a specific property, which guarantees that they are precisely the MCSs in the original network. We call this the <italic>target-specific dual network method</italic>. In this article, we develop a new method, minimal coordinated support (MCS<sup>2</sup>), which also generates a dual network (either explicitly or implicitly), but in a way that is independent of the target reaction from the original network, then computes the MCSs from those EFMs of the dual network that satisfy a certain property, which also guarantees that they are precisely the MCSs for the target reaction in the original network. MCS<sup>2</sup> is based on a generalization of some theoretical results by the last author (<xref rid="btz393-B5" ref-type="bibr">Chindelevitch, 2014</xref>).</p>
    <p>We implement MCS<sup>2</sup> and find it to be effective on most instances we test it on. We compare it to three alternate methods for enumerating all the MCSs for a target set. The first two methods are to compute the EFMs, and then dualize them with either Berge’s algorithm, or an optimized implementation of Fredman–Khachiyan dualization, respectively. For Berge’s algorithm, we used the implementation in CellNetAnalayzer (<xref rid="btz393-B18" ref-type="bibr">Klamt <italic>et al.</italic>, 2007</xref>), containing the enhancements described in <xref rid="btz393-B6" ref-type="bibr">Eiter <italic>et al.</italic> (2008</xref>) and <xref rid="btz393-B13" ref-type="bibr">Haus <italic>et al.</italic> (2008</xref>). For Fredman–Khachiyan dualization, we used the recent implementation of <xref rid="btz393-B32" ref-type="bibr">Sedaghat <italic>et al.</italic> (2018)</xref>.</p>
    <p>The <italic>target-specific dual network method</italic> (<xref rid="btz393-B2" ref-type="bibr">Ballerstein <italic>et al.</italic>, 2012</xref>) first creates a dual network based on the given stoichiometric matrix and the given target reaction. It then proceeds to compute the EFMs of that dual network. Following some post-processing, the supports of these EFMs are reduced to give the required MCSs; because the MCSs correspond to only a subset of the vectors produced, this post-processing includes removing any supersets. Like MCS<sup>2</sup>, the target-specific dual network method reports all the MCSs without first computing the EFMs or requiring them as an input. The authors of <xref rid="btz393-B2" ref-type="bibr">Ballerstein <italic>et al.</italic> (2012)</xref> did not provide a publicly available implementation of their method, so we did so ourselves, including all the enhancements mentioned in their <xref ref-type="supplementary-material" rid="sup1">Supplementary Materials</xref>. Most of these enhancements have improved the performance of the target-specific dual network method, for instance by reducing the size of the intermediate results.</p>
    <p>For the majority of the models we investigated, we find that MCS<sup>2</sup> is more efficient than these other methods, in terms of both running time and memory use. On the negative side, we show that our approach does not allow the enumeration of all MCSs through a given target reaction in incremental polynomial time, something that therefore remains a major open problem in the field.</p>
    <p>Given the challenges in enumerating all MCSs (in part due to their large number, which can be exponential in the size of the network), some recent work (<xref rid="btz393-B39" ref-type="bibr">von Kamp and Klamt, 2014</xref>; <xref rid="btz393-B38" ref-type="bibr">Vieira <italic>et al.</italic>, 2016</xref>) uses mixed-integer linear programming (MILP) formulations to enumerate a subset of the MCSs, in increasing order of size. In some practical applications, quickly obtaining a few MCSs of minimum size may be more desirable than enumerating the complete set. We therefore adapt the MCS<sup>2</sup> approach to use MILP formulations to address this task. We also implement this method, which we call MCS<sup>2</sup>-MILP, and compare it to MCSEnumerator, the target-specific dual network approach adapted to MILP (<xref rid="btz393-B39" ref-type="bibr">von Kamp and Klamt, 2014</xref>). The comparison shows that MCS<sup>2</sup>-MILP performs at least as well as MCSEnumerator using a state-of-the-art MILP solver (IBM).</p>
    <p>We conclude that MCS<sup>2</sup> is a promising approach for the computation of MCSs in metabolic networks, and expect it to be a beneficial addition to the analysis tools available for metabolic network models.</p>
    <p>We now introduce the terminology we will be using throughout this article. When we speak of a metabolic network, it is understood that we are talking about a model in the constraint-based modeling formalism.</p>
    <p>
      <statement id="mthst1">
        <label>Definition 1</label>
        <p>(Stoichiometric matrix). The <italic>stoichiometric matrix S</italic> is an <italic>m </italic>×<italic> n</italic> matrix with each row representing a metabolite (indexed from 1 to <italic>m</italic>) and each column, a reaction (indexed from 1 to <italic>n</italic>). The entry <italic>S<sub>ij</sub></italic> indicates how many units of metabolite <italic>i</italic> are produced (if <italic>S<sub>ij</sub></italic> &gt; 0) or consumed (if <italic>S<sub>ij</sub></italic> &lt; 0) by reaction <italic>j</italic>. A vector <italic>v</italic> is <italic>feasible</italic> with respect to <italic>S</italic> if it is in the <italic>null space</italic> of <italic>S</italic>, i.e. if it satisfies <italic>Sv</italic> = 0.</p>
      </statement>
    </p>
    <p>
      <statement id="mthst2">
        <label>Definition 2</label>
        <p>(Reaction irreversibility). The set <inline-formula id="IE1"><mml:math id="IM1"><mml:mi mathvariant="script">I</mml:mi></mml:math></inline-formula> of <italic>irreversible</italic> reactions is a subset of the set of reactions constrained to have only non-negative fluxes. Its complement <inline-formula id="IE2"><mml:math id="IM2"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, the set of <italic>reversible</italic> reactions, is allowed to have fluxes of any sign. A vector <italic>v</italic> respects the reaction irreversibility constraints if <inline-formula id="IE3"><mml:math id="IM3"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">I</mml:mi></mml:mrow></mml:math></inline-formula>, also written as <inline-formula id="IE4"><mml:math id="IM4"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
      </statement>
    </p>
    <p>
      <statement id="mthst3">
        <label>Definition 3</label>
        <p>(Metabolic network). A metabolic network <inline-formula id="IE5"><mml:math id="IM5"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula> is a pair <inline-formula id="IE6"><mml:math id="IM6"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">I</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE7"><mml:math id="IM7"><mml:mrow><mml:mi>S</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">Q</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>×</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is a stoichiometric matrix and <inline-formula id="IE8"><mml:math id="IM8"><mml:mrow><mml:mi mathvariant="script">I</mml:mi><mml:mo>⊆</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is the set of irreversible reactions. A vector <italic>v</italic> is a <italic>flux mode</italic> if it is feasible with respect to <italic>S</italic> and respects the irreversibility constraints, i.e. <italic>Sv</italic> = 0 and <inline-formula id="IE9"><mml:math id="IM9"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. The set of all such vectors is called the network’s <italic>flux cone</italic>.</p>
      </statement>
    </p>
    <p>
      <statement id="mthst4">
        <label>Definition 4</label>
        <p>(Reconfigured network). Let <inline-formula id="IE10"><mml:math id="IM10"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">I</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be a metabolic network. We can <italic>reconfigure</italic> this network by replacing <italic>S</italic> with <inline-formula id="IE11"><mml:math id="IM11"><mml:mrow><mml:mi>S</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>S</mml:mi><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:msup></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> which <inline-formula id="IE12"><mml:math id="IM12"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:msup></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> contains the columns of <italic>S</italic> that are not in <inline-formula id="IE13"><mml:math id="IM13"><mml:mi mathvariant="script">I</mml:mi></mml:math></inline-formula>, and then consider all reactions as irreversible. This is equivalent to splitting each reversible reaction in the network into its forward reaction and reverse reaction.</p>
      </statement>
    </p>
    <p>
      <statement id="mthst5">
        <label>Definition 5</label>
        <p>(Null space matrix and network). Let <italic>S</italic> be a matrix. A <italic>null space matrix</italic> of <italic>S</italic> is a matrix whose rows form a basis of the null space of <italic>S</italic>. The <italic>null space network</italic> of a metabolic network with stoichiometric matrix <italic>S</italic> is the fully reversible metabolic network (i.e. with <inline-formula id="IE14"><mml:math id="IM14"><mml:mrow><mml:mi mathvariant="script">I</mml:mi><mml:mo>=</mml:mo><mml:mo>φ</mml:mo></mml:mrow></mml:math></inline-formula>) whose stoichiometric matrix is a null space matrix of <italic>S</italic>.</p>
      </statement>
    </p>
    <p>
      <statement id="mthst6">
        <label>Definition 6</label>
        <p>(Positive and negative support). Let <italic>v</italic> be a vector. The <italic>positive support</italic> of <italic>v</italic>, <inline-formula id="IE15"><mml:math id="IM15"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, is the set of positions <italic>i</italic> where <italic>v<sub>i</sub></italic> is positive: <inline-formula id="IE16"><mml:math id="IM16"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>i</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. The <italic>negative support</italic> of <italic>v</italic>, <inline-formula id="IE17"><mml:math id="IM17"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>−</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, is the set of positions <italic>i</italic> where <italic>v<sub>i</sub></italic> is negative: <inline-formula id="IE18"><mml:math id="IM18"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>−</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>i</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>&lt;</mml:mo><mml:mn>0</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Their union <inline-formula id="IE19"><mml:math id="IM19"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the <italic>support</italic> of <italic>v</italic>: <inline-formula id="IE20"><mml:math id="IM20"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>−</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      </statement>
    </p>
    <p>
      <statement id="mthst7">
        <label>Definition 7</label>
        <p>(Coordinated support). Let <italic>v</italic> be a vector of size <italic>n</italic> and let <inline-formula id="IE21"><mml:math id="IM21"><mml:mrow><mml:mi>A</mml:mi><mml:mo>⊆</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be a set of positions. The <italic>A-coordinated support</italic> of <italic>v</italic>, <inline-formula id="IE22"><mml:math id="IM22"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi>A</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, is the union of its negative support on the positions in <italic>A</italic> and its support everywhere else: <inline-formula id="IE23"><mml:math id="IM23"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi>A</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>−</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>A<sup>C</sup></italic> is the complement of the set <italic>A</italic> with respect to <inline-formula id="IE24"><mml:math id="IM24"><mml:mrow><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      </statement>
    </p>
    <p>
      <statement id="mthst8">
        <label>Definition 8</label>
        <p>(EFM). Let <inline-formula id="IE25"><mml:math id="IM25"><mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">I</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be a metabolic network, and let <italic>v</italic> be a flux mode of <inline-formula id="IE26"><mml:math id="IM26"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula>. It is an <italic>EFM</italic> if its support is minimal among all the flux modes of <inline-formula id="IE27"><mml:math id="IM27"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula>, i.e. for any flux mode <italic>w</italic> which <inline-formula id="IE28"><mml:math id="IM28"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊊</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⇒</mml:mo><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> (<xref rid="btz393-B9" ref-type="bibr">Gagneur and Klamt, 2004</xref>; <xref rid="btz393-B31" ref-type="bibr">Schuster <italic>et al.</italic>, 2000</xref>).</p>
      </statement>
    </p>
    <p>
      <statement id="mthst9">
        <label>Definition 9</label>
        <p>(MCS). Let <inline-formula id="IE29"><mml:math id="IM29"><mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">I</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be a metabolic network, and let <italic>t</italic> be a reaction. <italic>C</italic> is a <italic>cut set</italic> for <italic>t</italic> if <inline-formula id="IE30"><mml:math id="IM30"><mml:mrow><mml:mi mathvariant="italic">Sv</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>⇒</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. <italic>C</italic> is a <italic>MCS</italic> if it is inclusion-minimal: for any set <inline-formula id="IE31"><mml:math id="IM31"><mml:mrow><mml:mi>D</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo>⊊</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula> implies that <inline-formula id="IE32"><mml:math id="IM32"><mml:mrow><mml:mo>∃</mml:mo><mml:mi>v</mml:mi><mml:mo> </mml:mo><mml:mi mathvariant="normal">s</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="normal">t</mml:mi><mml:mo>.</mml:mo><mml:mo> </mml:mo><mml:mtext>Sv</mml:mtext><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">v</mml:mi></mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">v</mml:mi></mml:mrow><mml:mi mathvariant="normal">D</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">v</mml:mi></mml:mrow><mml:mi mathvariant="normal">t</mml:mi></mml:msub><mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> (<xref rid="btz393-B19" ref-type="bibr">Klamt and Gilles, 2004</xref>).</p>
      </statement>
    </p>
    <p>
      <statement id="mthst10">
        <label>Definition 10</label>
        <p>(Canonical form of a network). Let <inline-formula id="IE33"><mml:math id="IM33"><mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">I</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be a metabolic network. We say that <inline-formula id="IE34"><mml:math id="IM34"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula> is in <italic>canonical form</italic> if it satisfies:
<list list-type="order"><list-item><p>No blocked reactions: for every reaction <italic>i</italic>, there exists a flux vector <italic>v</italic> with <italic>v<sub>i</sub></italic> = 1</p></list-item><list-item><p>Proper directedness: for every reaction <inline-formula id="IE35"><mml:math id="IM35"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, there exists a flux vector <italic>w</italic> with <inline-formula id="IE36"><mml:math id="IM36"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p>No enzyme subsets: no reaction pair <inline-formula id="IE37"><mml:math id="IM37"><mml:mrow><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula> satisfies <inline-formula id="IE38"><mml:math id="IM38"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>κ</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> with <inline-formula id="IE39"><mml:math id="IM39"><mml:mrow><mml:mo>κ</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Q</mml:mi></mml:mrow></mml:math></inline-formula> for all flux vectors <italic>v</italic></p></list-item><list-item><p>No redundant constraints: <italic>S</italic> has full row rank</p></list-item></list></p>
        <p>A metabolic network can be reduced to an equivalent one in canonical form (a.k.a. compressed form) in time polynomial in <italic>m</italic> and <italic>n</italic> (<xref rid="btz393-B5" ref-type="bibr">Chindelevitch, 2014</xref>).</p>
      </statement>
    </p>
  </sec>
  <sec>
    <title>2 The MCS<sup>2</sup> method</title>
    <p>Let <italic>S<sub>i</sub></italic> be the <italic>i</italic>th row of the stoichiometric matrix <italic>S</italic>. Then <italic>S<sub>ir</sub></italic> represents the amount of metabolite <italic>i</italic> consumed or produced by reaction <italic>r</italic> (in these cases, <italic>S<sub>ir</sub></italic> &lt; 0 and <italic>S<sub>ir</sub></italic> &gt; 0, respectively). Assume that reaction <italic>r</italic> produces metabolite <italic>i</italic> if it has a positive flux. Then, in a steady state where no reaction consuming metabolite <italic>i</italic> is active, reaction <italic>r</italic> must be inactive in the forward direction. If reaction <italic>r</italic> happens to be reversible, it must be consuming metabolite <italic>i</italic>, and its flux must be negative. This shows that reaction <italic>r</italic> is blocked in the forward direction if we disable every reaction that can consume metabolite <italic>i</italic>, i.e. every irreversible reaction with a negative value in row <italic>i</italic> and every reversible reaction with a non-zero value in row <italic>i</italic>. Disabling a reaction can be done by removing the corresponding column from the stoichiometric matrix or adding the constraint that this reaction’s flux is zero to the problem. The set of such reactions is then a cut set for the forward direction of reaction <italic>r</italic>. Every row gives us some, not necessarily minimal, cut set in this manner.</p>
    <p>We can apply the same reasoning to linear combinations of the metabolites. Consider a new <italic>virtual</italic> metabolite <italic>x</italic>, which represents a linear combination of rows <italic>S<sub>i</sub></italic> and <italic>S<sub>j</sub></italic> corresponding to metabolites <italic>i</italic> and <italic>j</italic> respectively, say for example <inline-formula id="IE40"><mml:math id="IM40"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
    <p>Since the fluxes producing and consuming each metabolite are balanced in any admissible vector, so are the fluxes of their linear combinations, so the virtual metabolite <italic>x</italic> must also be balanced. If we pick a reaction with a positive value in <italic>u<sub>x</sub></italic>, it produces a virtual metabolite <italic>x</italic> when it has a positive flux. It will therefore be blocked if we cut all irreversible reactions with negative values in <italic>u<sub>x</sub></italic> and all reversible reactions with non-zero values in <italic>u<sub>x</sub></italic>. Thus, we can obtain cut sets from the vector <italic>u<sub>x</sub></italic>, which is a member of the row space of <italic>S</italic>, as we did with <italic>S<sub>i</sub></italic> and <italic>S<sub>j</sub></italic>. A proposal for finding cut sets by analyzing the row space of the stoichiometric matrix was introduced in the Ph.D. thesis of Chindelevitch (<xref rid="btz393-B5" ref-type="bibr">Chindelevitch, 2014</xref>). The intuition we described shows how vectors in the row space can generate cut sets. However, the lemmas proven in <xref rid="btz393-B5" ref-type="bibr">Chindelevitch (2014)</xref> work only for the fully reversible networks (i.e. with <inline-formula id="IE41"><mml:math id="IM41"><mml:mrow><mml:mi mathvariant="script">I</mml:mi><mml:mo>=</mml:mo><mml:mo>φ</mml:mo></mml:mrow></mml:math></inline-formula>) or fully reversible networks (i.e. with <inline-formula id="IE42"><mml:math id="IM42"><mml:mrow><mml:mi mathvariant="script">I</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>). We generalize them here to networks with both irreversible reactions and reversible reactions.</p>
    <sec>
      <title>2.1 Enumerating the full set of MCSs</title>
      <p>In the MCS<sup>2</sup> method, the dual network is the null space network of the original network, i.e. a fully reversible network whose stoichiometric matrix is the null space matrix of the original stoichiometric matrix. The EFMs in this dual network map to MCS of the original network, though, as we will see, the mapping can be many to one. The dual network has the same number of reactions, <italic>n</italic>, as the original one, but it typically has fewer metabolites; if the original network has <italic>m</italic> metabolites and the stoichiometric matrix is full rank, the dual has <italic>n</italic> – <italic>m</italic> metabolites.</p>
      <p>
        <statement id="mthst11">
          <label>Lemma 1</label>
          <p>(MCSs for an irreversible reaction). Let <inline-formula id="IE43"><mml:math id="IM43"><mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">I</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be a metabolic network. Let <inline-formula id="IE44"><mml:math id="IM44"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">I</mml:mi></mml:mrow></mml:math></inline-formula> be an irreversible target reaction. Then <italic>C</italic> is a cut set for <italic>t</italic> if and only if there exists a vector <italic>u</italic> in the row space of <italic>S</italic>, <inline-formula id="IE45"><mml:math id="IM45"><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="italic">Row</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, such that <italic>u<sub>t</sub></italic> = 1 and <inline-formula id="IE46"><mml:math id="IM46"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
        </statement>
      </p>
      <p>
        <statement id="mthst12">
          <label>Proof.</label>
          <p> This lemma is an extension of Lemma 3 of <xref rid="btz393-B5" ref-type="bibr">Chindelevitch (2014)</xref>. We observe that <italic>C</italic> being a cut set for irreversible reaction <italic>t</italic> is equivalent to:
<disp-formula id="E1"><label>(1)</label><mml:math id="M1"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:msub><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">I</mml:mi><mml:mo>−</mml:mo><mml:mi>C</mml:mi><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo>⇒</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></disp-formula></p>
          <p>Based on Farkas’ Lemma and the irreversibility of <italic>t</italic>, we only need to find a constraint that implies <inline-formula id="IE47"><mml:math id="IM47"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. Thus, there exists a <italic>y</italic> such that:
<disp-formula id="E2"><label>(2)</label><mml:math id="M2"><mml:mrow><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">I</mml:mi><mml:mo>−</mml:mo><mml:mo>{</mml:mo><mml:mi>C</mml:mi><mml:mo>∪</mml:mo><mml:mi>t</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi mathvariant="normal">s</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="normal">t</mml:mi><mml:mo>.</mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi mathvariant="normal">i</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">I</mml:mi><mml:mo>-</mml:mo><mml:mo>{</mml:mo><mml:mi mathvariant="normal">C</mml:mi><mml:mo>∪</mml:mo><mml:mi mathvariant="normal">t</mml:mi><mml:mo>}</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mi mathvariant="normal">i</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></disp-formula></p>
          <p>Here, <italic>e<sub>i</sub></italic> is a vector with a 1 in the <italic>i</italic>th position and 0 elsewhere. Thus:
<disp-formula id="E3"><label>(3)</label><mml:math id="M3"><mml:mrow><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">I</mml:mi><mml:mo>−</mml:mo><mml:mi>C</mml:mi><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo> </mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:msup><mml:mo>−</mml:mo><mml:mi>C</mml:mi><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></disp-formula></p>
          <p>Therefore <inline-formula id="IE48"><mml:math id="IM48"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>−</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi mathvariant="script">I</mml:mi><mml:mo>⊆</mml:mo><mml:mi>C</mml:mi><mml:mo>∩</mml:mo><mml:mi mathvariant="script">I</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE49"><mml:math id="IM49"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:msup><mml:mo>⊆</mml:mo><mml:mi>C</mml:mi><mml:mo>∩</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, and so <inline-formula id="IE50"><mml:math id="IM50"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
          <p>For the other direction, suppose that <italic>u</italic> satisfies <xref ref-type="disp-formula" rid="E3">Equation (3)</xref> for some <italic>C</italic>. Then the union of the indices <italic>i</italic> in <inline-formula id="IE51"><mml:math id="IM51"><mml:mi mathvariant="script">I</mml:mi></mml:math></inline-formula> for which <inline-formula id="IE52"><mml:math id="IM52"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>&lt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and the indices <italic>i</italic> in <inline-formula id="IE53"><mml:math id="IM53"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> for which <inline-formula id="IE54"><mml:math id="IM54"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> is a subset of <italic>C</italic>, i.e. <inline-formula id="IE55"><mml:math id="IM55"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula>. Then equality (2) holds and, by Farkas’ lemma, so does condition (1). □</p>
        </statement>
      </p>
      <p>
        <statement id="mthst13">
          <label>Lemma 2</label>
          <p>(MCSs for one direction of a reversible reaction). Let <inline-formula id="IE56"><mml:math id="IM56"><mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">I</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be a metabolic network. Let <italic>t</italic> be a reversible target reaction. Then <italic>C</italic> is a cut set for the forward (reverse) direction of <italic>t</italic> if and only if there exists a vector <inline-formula id="IE57"><mml:math id="IM57"><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="italic">Row</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE58"><mml:math id="IM58"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula> and <italic>u<sub>t</sub></italic> = 1 (<inline-formula id="IE59"><mml:math id="IM59"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>), respectively.</p>
        </statement>
      </p>
      <p>
        <statement id="mthst14">
          <label>Proof. </label>
          <p>If we assume that <italic>t</italic> is irreversible for a moment, the first part already follows from the previous lemma. For the second part, replace <italic>t</italic> with –<italic>t</italic> in <italic>S</italic> to create <inline-formula id="IE60"><mml:math id="IM60"><mml:mrow><mml:mi>S</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. Reaction <italic>t</italic> is blocked in the forward direction in <inline-formula id="IE61"><mml:math id="IM61"><mml:mrow><mml:mi>S</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> if and only if reaction <italic>t</italic> is blocked in the reverse direction in <italic>S</italic>, and there is a bijection between the vectors in <italic>Row</italic>(<italic>S</italic>) and those in <inline-formula id="IE62"><mml:math id="IM62"><mml:mrow><mml:mi mathvariant="italic">Row</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> via the mapping that multiplies the <italic>t</italic>th coordinate by –1. □</p>
          <p>With these lemmas, Algorithm 1 can be used to find the MCS for a set of target reactions <inline-formula id="IE63"><mml:math id="IM63"><mml:mrow><mml:mi>T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> in an arbitrary metabolic network <inline-formula id="IE64"><mml:math id="IM64"><mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">I</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>T</italic> has separate elements for the opposite directions of a reversible reaction. We call this method MCS<sup>2</sup> because it computes MCSs as the MCS<sup>2</sup> of the EFMs in the dual network.</p>
          <p>
            <boxed-text id="btz393-BOX1" position="float" orientation="portrait">
              <sec>
                <title>Algorithm 1. MCS enumeration via the MCS<sup>2</sup> method</title>
                <p><bold>Input</bold>: A metabolic network <inline-formula id="IE65"><mml:math id="IM65"><mml:mrow><mml:mi mathvariant="script">M</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">I</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and a target set <inline-formula id="IE66"><mml:math id="IM66"><mml:mrow><mml:mi>T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula></p>
                <p><bold>Output</bold>: MCS of target reactions <italic>T</italic>.</p>
                <p>1: <bold>function</bold><italic>MCS</italic>_Enumeration(<inline-formula id="IE67"><mml:math id="IM67"><mml:mrow><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">I</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula>)</p>
                <p>2:  Reduce <italic>S</italic> to its canonical form.</p>
                <p>3:  Compute the null space matrix <italic>N</italic> of <italic>S</italic>.</p>
                <p>4:  Compute all EFMs <inline-formula id="IE68"><mml:math id="IM68"><mml:mi mathvariant="script">F</mml:mi></mml:math></inline-formula> of <italic>N</italic>.</p>
                <p>5:  <bold>for all</bold><inline-formula id="IE69"><mml:math id="IM69"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula><bold>do</bold> Compute <inline-formula id="IE70"><mml:math id="IM70"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, the set of all elements of <inline-formula id="IE71"><mml:math id="IM71"><mml:mi mathvariant="script">F</mml:mi></mml:math></inline-formula> involving target <italic>t<sub>i</sub></italic>.</p>
                <p>6:  <bold>for all</bold><inline-formula id="IE72"><mml:math id="IM72"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula><bold>do</bold> Let <inline-formula id="IE73"><mml:math id="IM73"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">C</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the set of minimal <inline-formula id="IE74"><mml:math id="IM74"><mml:mi mathvariant="script">I</mml:mi></mml:math></inline-formula>-coordinated supports of the elements of <inline-formula id="IE75"><mml:math id="IM75"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
                <p>7:  Let <inline-formula id="IE76"><mml:math id="IM76"><mml:mrow><mml:mi mathvariant="script">C</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>∪</mml:mo><mml:mo>…</mml:mo><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">C</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
                <p>8:  Let <inline-formula id="IE77"><mml:math id="IM77"><mml:mrow><mml:mi mathvariant="script">C</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> be the result of pruning <inline-formula id="IE78"><mml:math id="IM78"><mml:mi mathvariant="script">C</mml:mi></mml:math></inline-formula> to remove any supersets.</p>
                <p>9:  Return <inline-formula id="IE79"><mml:math id="IM79"><mml:mrow><mml:mi mathvariant="script">C</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
              </sec>
            </boxed-text>
          </p>
        </statement>
      </p>
      <p>The MCS<sup>2</sup> method computes the null space network of the original network. Then, by applying coordinated support to the EFMs in which each target reaction is active in turn, it generates the cut sets related for this target. All the MCSs are among these cut sets, and are obtained by pruning. The null space network is fully reversible, and since the null space of the null space is the original space, the dual network of the dual network is equivalent to the original network all of whose reactions have become reversible. An example is shown in <xref ref-type="fig" rid="btz393-F1">Figure 1</xref>, where the dual network appears alongside the original one. As shown in the example, flux modes with an active target reaction in the dual network map to cut sets for the target reaction in the original network.
</p>
      <fig id="btz393-F1" orientation="portrait" position="float">
        <label>Fig. 1.</label>
        <caption>
          <p>Example of a metabolic network with its associated dual network created by the nullspace matrix. Some of its FMs involving target reaction <inline-formula id="IE80"><mml:math id="IM80"><mml:mn>1</mml:mn></mml:math></inline-formula> are shown; their <inline-formula id="IE81"><mml:math id="IM81"><mml:mrow><mml:mi mathvariant="script">I</mml:mi><mml:mo>-</mml:mo></mml:mrow></mml:math></inline-formula>coordinated supports result in cut sets for it in the original network</p>
        </caption>
        <graphic xlink:href="btz393f1"/>
      </fig>
      <p>Flux modes finders such as FluxModeCalculator (<xref rid="btz393-B37" ref-type="bibr">van Klinken and Willems van Dijk, 2016</xref>) reconfigure the network before applying the double description method. The double description method is an algorithmic approach for finding the extreme rays of a pointed cone described by linear constraints. The reconfigured network is <inline-formula id="IE82"><mml:math id="IM82"><mml:mrow><mml:mi>N</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>N</mml:mi><mml:mo> </mml:mo><mml:mo>;</mml:mo><mml:mo>−</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>N</italic> is the null space network of <italic>S</italic>. <xref ref-type="fig" rid="btz393-F2">Figure 2</xref> shows the null space matrix of <inline-formula id="IE83"><mml:math id="IM83"><mml:mrow><mml:mi>N</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>, which is the starting point of double description method. The double description method begins by using elementary row operations to put the matrix in the form suggested in <xref rid="btz393-B41" ref-type="bibr">Wagner (2004)</xref> which contains an identity matrix of size <italic>m </italic>+<italic> n</italic>. When the double description method finishes, it outputs the extreme rays describing a cone in 2<italic>n</italic>-dimensional space (<xref rid="btz393-B35" ref-type="bibr">Terzer and Stelling, 2008</xref>). These extreme rays are the non-zero vectors in the flux cone with minimal support. On the other hand, <inline-formula id="IE84"><mml:math id="IM84"><mml:mi mathvariant="script">I</mml:mi></mml:math></inline-formula>-coordinated support does not count non-zero values in some dimensions, namely, those that correspond to positive values in irreversible reactions. If we ignore these dimensions, we project the cone into a lower-dimensional subspace. While the image of a pointed cone remains a pointed cone, the extreme rays of the new cone are those in the original flux cone with minimal support in the remaining dimensions. <xref ref-type="fig" rid="btz393-F3">Figure 3</xref> shows why all the MCS<sup>2</sup> are among the minimal supports, while arguing that there may be some redundant results among them as well. The next theorem formalizes this:
</p>
      <fig id="btz393-F2" orientation="portrait" position="float">
        <label>Fig. 2.</label>
        <caption>
          <p>This <inline-formula id="IE85"><mml:math id="IM85"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> matrix is the nullspace of the reconfigured nullspace of stoichiometry matrix <inline-formula id="IE86"><mml:math id="IM86"><mml:mi>S</mml:mi></mml:math></inline-formula>. The double description method begins on this space and finds extreme rays with length <inline-formula id="IE87"><mml:math id="IM87"><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula></p>
        </caption>
        <graphic xlink:href="btz393f2"/>
      </fig>
      <fig id="btz393-F3" orientation="portrait" position="float">
        <label>Fig. 3.</label>
        <caption>
          <p>Each extreme ray of the projected cone is an image of an extreme ray in the original cone, while some extreme rays of the original cone do not project to extreme rays. It is also possible that two or more extreme rays in the original cone project onto the same one. Our desired projections lie in the plane where the value in the target position is <inline-formula id="IE88"><mml:math id="IM88"><mml:mn>1</mml:mn></mml:math></inline-formula></p>
        </caption>
        <graphic xlink:href="btz393f3"/>
      </fig>
      <p>
        <statement id="mthst15">
          <label>Theorem 1</label>
          <p>(Correctness of the method). Algorithm 1 returns precisely the set of MCS of the network <inline-formula id="IE89"><mml:math id="IM89"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula> for a single target reaction.</p>
        </statement>
      </p>
      <p>
        <statement id="mthst16">
          <label>Proof. </label>
          <p>Let <italic>t</italic> be the target reaction. We prove the inclusion in both directions. First, let <inline-formula id="IE90"><mml:math id="IM90"><mml:mrow><mml:mi>C</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> be one of the sets returned by the method above. Then <italic>C</italic> is a cut set for <italic>t</italic> in the reconfigured network, by Lemma 1 and by construction. Indeed, <inline-formula id="IE91"><mml:math id="IM91"><mml:mi mathvariant="script">F</mml:mi></mml:math></inline-formula> contains flux modes of <italic>N</italic> involving <italic>t</italic>, which are precisely the vectors in the row space of <italic>S</italic> involving <italic>t</italic>, and <inline-formula id="IE92"><mml:math id="IM92"><mml:mi mathvariant="script">C</mml:mi></mml:math></inline-formula> (as well as <inline-formula id="IE93"><mml:math id="IM93"><mml:mrow><mml:mi mathvariant="script">C</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>) contains the <inline-formula id="IE94"><mml:math id="IM94"><mml:mi mathvariant="script">I</mml:mi></mml:math></inline-formula>-coordinated supports of these vectors.</p>
          <p>Now, let <italic>C</italic> be a MCS for <italic>t</italic> in <inline-formula id="IE95"><mml:math id="IM95"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula>. We will show that <inline-formula id="IE96"><mml:math id="IM96"><mml:mrow><mml:mi>C</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. By Lemma 1, there exists a vector <inline-formula id="IE97"><mml:math id="IM97"><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="italic">Row</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> such that <italic>u<sub>t</sub></italic> = 1 and <inline-formula id="IE98"><mml:math id="IM98"><mml:mrow><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Since <inline-formula id="IE99"><mml:math id="IM99"><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="italic">Row</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⇔</mml:mo><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="italic">Null</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <italic>u</italic> is a conical combination of the EFMs of <italic>N</italic>. Note that the results of <xref rid="btz393-B26" ref-type="bibr">Müller and Regensburger (2016)</xref> imply that since the space to which <italic>u</italic> belongs is linear (i.e. it does not need to satisfy any non-negativity constraints), this conical combination can be chosen to be <bold>conformal</bold>, meaning that there are no cancellations involved in any component. Let such a conformal conical combination be given by
<disp-formula id="E4"><label>(4)</label><mml:math id="M4"><mml:mrow><mml:mo>∀</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo> </mml:mo><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo>⋯</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo> </mml:mo><mml:mtext>where</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></disp-formula></p>
          <p>Since all the coefficients are strictly positive in (4), we deduce that
<disp-formula id="E5"><mml:math id="M5"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mo>…</mml:mo><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
          <p>Indeed, each <inline-formula id="IE100"><mml:math id="IM100"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi mathvariant="script">I</mml:mi></mml:mrow></mml:math></inline-formula> must have a negative component in at least one of the <italic>f<sub>i</sub></italic>, as otherwise the <italic>j</italic>th component of the right-hand side of (4) will be non-negative, which gives the <inline-formula id="IE101"><mml:math id="IM101"><mml:mo>⊆</mml:mo></mml:math></inline-formula> direction, and the fact that the combination is conformal gives the <inline-formula id="IE102"><mml:math id="IM102"><mml:mo>⊇</mml:mo></mml:math></inline-formula> direction, as otherwise there would be a cancellation.</p>
          <p>In particular, we deduce that <inline-formula id="IE103"><mml:math id="IM103"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for each <inline-formula id="IE104"><mml:math id="IM104"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. In this case, the minimality of <italic>C</italic> implies that either <inline-formula id="IE105"><mml:math id="IM105"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> or <italic>f<sub>i</sub></italic> has a 0 in position <italic>t</italic>, for each <inline-formula id="IE106"><mml:math id="IM106"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. But since <italic>u</italic> has a 1 in position <italic>t</italic>, there must be at least one <italic>f<sub>i</sub></italic> in the first category, so that <inline-formula id="IE107"><mml:math id="IM107"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula> and therefore, <inline-formula id="IE108"><mml:math id="IM108"><mml:mrow><mml:mi>C</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">C</mml:mi></mml:mrow></mml:math></inline-formula>. Once again, by the minimality of <italic>C</italic> we conclude that <inline-formula id="IE109"><mml:math id="IM109"><mml:mrow><mml:mi>C</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> since it cannot be a superset of the <inline-formula id="IE110"><mml:math id="IM110"><mml:mi mathvariant="script">I</mml:mi></mml:math></inline-formula>-coordinated support of another vector in <inline-formula id="IE111"><mml:math id="IM111"><mml:mi mathvariant="script">C</mml:mi></mml:math></inline-formula>, concluding the proof. □</p>
        </statement>
      </p>
      <sec>
        <title>2.1.1 Limitations</title>
        <p>Our method is limited to blocking one direction of a given reaction. In practice, blocking one direction of a given reaction is the typical objective (<xref rid="btz393-B20" ref-type="bibr">Burgard <italic>et al.</italic>, 2001</xref>). To block multiple reactions, it is possible to compute the MCSs of every target reaction, take unions of all possible combinations, then remove the supersets. However, this may not always be efficient.</p>
        <p>A more critical issue is the possibility of generating a large number of non-MCS before the post-processing. The following Lemma shows that this type of blow-up can occur in theory:</p>
        <p>
          <statement id="mthst17">
            <label>Lemma 3</label>
            <p>(Large number of supersets in the final step). For every integer <inline-formula id="IE112"><mml:math id="IM112"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≥</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> there exists a network containing <italic>k </italic>+<italic> </italic>2 metabolites, <inline-formula id="IE113"><mml:math id="IM113"><mml:mrow><mml:mn>3</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> reactions and <inline-formula id="IE114"><mml:math id="IM114"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> elementary vectors for the target reaction <italic>t </italic>=<italic> </italic>1 that map to the exact same MCS. This network is in canonical form, and is elementally balanced as per <xref rid="btz393-B42" ref-type="bibr">Zabeti <italic>et al.</italic> (2018)</xref>.</p>
          </statement>
        </p>
        <p>
          <statement id="mthst18">
            <label>Proof. </label>
            <p>We construct the network as follows. There are two special metabolites, denoted <italic>M<sub>I</sub></italic> (initial) and <italic>M<sub>F</sub></italic> (final), and <italic>k</italic> intermediate metabolites, denoted <italic>M<sub>i</sub></italic> for <inline-formula id="IE115"><mml:math id="IM115"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. For each metabolite, we have an export reaction and an import reaction, with the export reactions for each intermediate metabolite coupled with an import of the final metabolite. Lastly, each intermediate metabolite except the first one can be transformed into the first one, <italic>M</italic><sub>1</sub>, which itself can also be transformed into the initial metabolite <italic>M<sub>I</sub></italic>. All reactions in the network are irreversible and all the stoichiometric coefficients are ±1.</p>
            <p>We order these reactions as follows (for simplicity of argument):
<disp-formula id="E6"><mml:math id="M6"><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mtext>              </mml:mtext><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>:</mml:mo><mml:mo>φ</mml:mo><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>I</mml:mi></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow/></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mtext>              </mml:mtext><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>I</mml:mi></mml:msub><mml:mo>→</mml:mo><mml:mo>φ</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow/></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mtext>              </mml:mtext><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>I</mml:mi></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow/></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mtext>        </mml:mtext><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mtext>  </mml:mtext><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:mo>φ</mml:mo><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>         </mml:mtext><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>F</mml:mi></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>         </mml:mtext><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mtext>      </mml:mtext><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>F</mml:mi></mml:msub><mml:mo>→</mml:mo><mml:mo>φ</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow/></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p>
            <p>The stoichiometric matrix then looks as follows (shown for <italic>k </italic>=<italic> </italic>2):
<disp-formula id="E7"><mml:math id="M7"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mo>+</mml:mo></mml:mtd><mml:mtd><mml:mo>−</mml:mo></mml:mtd><mml:mtd><mml:mo>+</mml:mo></mml:mtd><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/></mml:mtr><mml:mtr><mml:mtd/><mml:mtd/><mml:mtd><mml:mo>−</mml:mo></mml:mtd><mml:mtd><mml:mo>+</mml:mo></mml:mtd><mml:mtd><mml:mo>+</mml:mo></mml:mtd><mml:mtd/><mml:mtd><mml:mo>−</mml:mo></mml:mtd><mml:mtd/><mml:mtd/><mml:mtd/></mml:mtr><mml:mtr><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd><mml:mo>−</mml:mo></mml:mtd><mml:mtd/><mml:mtd><mml:mo>+</mml:mo></mml:mtd><mml:mtd/><mml:mtd><mml:mo>−</mml:mo></mml:mtd><mml:mtd/><mml:mtd/></mml:mtr><mml:mtr><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd><mml:mo>+</mml:mo></mml:mtd><mml:mtd><mml:mo>+</mml:mo></mml:mtd><mml:mtd><mml:mo>−</mml:mo></mml:mtd><mml:mtd/></mml:mtr></mml:mtable></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p>
            <p>Here, a + represents a 1 and a – represents a –1. We now proceed to show each part of the desired statement:
<list list-type="bullet"><list-item><p>The network is elementally balanced because every reaction that is not pure import or pure export is an exchange of one metabolite for another in a 1-1 ratio, so we can consider each metabolite as containing exactly 1 atom.</p></list-item><list-item><p>The network is in canonical form because every reaction can be active and no pair of reactions is constrained to have proportional fluxes; this is evidenced by the following flux modes: 
<disp-formula id="E71"><mml:math id="M8"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>This set of fluxes includes every reaction at least twice, and in at least two of these the sets of other active reactions are disjoint. The only exceptions are <italic>R</italic><sub>1</sub> and <italic>R</italic><sub>3</sub>, which need <italic>R</italic><sub>2</sub> to be active in order to occur, but the first and third flux modes (respectively second and third flux modes) show that their fluxes are not proportional to that of <italic>R</italic><sub>2</sub> or to each other; and the reactions <inline-formula id="IE116"><mml:math id="IM116"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE117"><mml:math id="IM117"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE118"><mml:math id="IM118"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, both of which need <inline-formula id="IE119"><mml:math id="IM119"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to be active in order to occur, but not in a fixed ratio, as evidenced by taking linear combinations of the last two sets of flux vectors.</p></list-item><list-item><p>The stoichiometric matrix has full row rank, i.e. no metabolite generates a redundant constraint, because every metabolite except <italic>M<sub>F</sub></italic> has a pure import reaction, while <italic>M<sub>F</sub></italic> has a pure export reaction.</p></list-item><list-item><p>There is a unique MCS for target reaction <italic>R</italic><sub>1</sub>, namely, <italic>R</italic><sub>2</sub>. This is because <italic>R</italic><sub>2</sub> is the only reaction consuming <italic>M<sub>I</sub></italic> (recall that all reactions are irreversible). The first row of <italic>S</italic>, <inline-formula id="IE120"><mml:math id="IM120"><mml:mrow><mml:mi>u</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> produces this MCS via its negative support.</p></list-item><list-item><p>Lastly, there are <inline-formula id="IE121"><mml:math id="IM121"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> additional vectors in the row space of <italic>S</italic> that produce supersets of this MCS via their negative support. The first one is obtained by adding the second row of <italic>S</italic> to <italic>u</italic>, replacing it by
<disp-formula id="E72"><mml:math id="M9"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mo>φ</mml:mo></mml:msub><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>5</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo>⋯</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
and then picking any subset <italic>P</italic> of the set of <inline-formula id="IE122"><mml:math id="IM122"><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> entries <inline-formula id="IE123"><mml:math id="IM123"><mml:mrow><mml:mi>E</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> to form a new vector <italic>v<sub>P</sub></italic>, as follows.</p><p>Let <inline-formula id="IE124"><mml:math id="IM124"><mml:mrow><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula> be an element of the chosen subset, where <inline-formula id="IE125"><mml:math id="IM125"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. We will replace <inline-formula id="IE126"><mml:math id="IM126"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> with <inline-formula id="IE127"><mml:math id="IM127"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> via the addition of the <inline-formula id="IE128"><mml:math id="IM128"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-nd row of <italic>S</italic> (corresponding to the intermediate metabolite <inline-formula id="IE129"><mml:math id="IM129"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) to the starting vector. Indeed, this row contains three non-zero entries: a –1 from reaction <inline-formula id="IE130"><mml:math id="IM130"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> (which cancels out the 1 in position <inline-formula id="IE131"><mml:math id="IM131"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>), as well as another 1 from reaction <inline-formula id="IE132"><mml:math id="IM132"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and another –1 from reaction <inline-formula id="IE133"><mml:math id="IM133"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. We do this addition independently for each element of <italic>P</italic> to get <italic>v<sub>P</sub></italic> (if <inline-formula id="IE134"><mml:math id="IM134"><mml:mrow><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mo>φ</mml:mo></mml:mrow></mml:math></inline-formula> we get <inline-formula id="IE135"><mml:math id="IM135"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mo>φ</mml:mo></mml:msub></mml:mrow></mml:math></inline-formula>). It is easy to check that <italic>v<sub>P</sub></italic> has support:
<disp-formula id="E73"><mml:math id="M10"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>}</mml:mo><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mo>∉</mml:mo><mml:mi>P</mml:mi><mml:mo>}</mml:mo><mml:mo>∪</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>{</mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi>P</mml:mi><mml:mo>}</mml:mo><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi>P</mml:mi><mml:mo>}</mml:mo><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p><p>No proper subset of this support can produce a non-trivial vector in the row space of <italic>S</italic>, as it is impossible by construction to add a linear combination (possibly with negative coefficients) of the rows of <italic>S</italic> to <italic>v<sub>P</sub></italic> without adding any new elements to its support, so each <italic>v<sub>P</sub></italic> is elementary. Furthermore, the negative support of <italic>v<sub>P</sub></italic> is:
<disp-formula id="E74"><mml:math id="M11"><mml:mrow><mml:mo>{</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>}</mml:mo><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi>P</mml:mi><mml:mo>}</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula></p><p>which is a strict superset of the negative support {2} of <italic>u</italic>.</p></list-item></list></p>
            <p>□</p>
          </statement>
        </p>
      </sec>
      <sec>
        <title>2.1.2 Advantages</title>
        <p>An advantage of the MCS<sup>2</sup> approach is that we find the MCSs directly, without first computing the EFMs of the original network. Also, we do not need to reconfigure or alter the stochiometric matrix; every step is performed directly on the original stoichiometric matrix or its null space matrix. Network compression or reduction may be done as a preprocessing step before going through the main procedure, but these are only used to reduce the running time and space and are optional. These advantages are shared with the target-specific dual network approach.</p>
        <p>However, there are additional advantages that MCS<sup>2</sup> has over this method. First, the null space matrix is typically smaller than the original matrix, especially if the original matrix is nearly full rank, while the target-specific dual network has a matrix that is always larger. This difference in input size can lead to substantial resource savings during EFM computation. Second, and perhaps most importantly, the dual network is independent of the target reaction in our method, while it is not with the target-specific approach. This means that we can calculate these EFMs once and use them for any given target reaction to be blocked.</p>
      </sec>
    </sec>
    <sec>
      <title>2.2 Generating a partial set of MCSs via MILP</title>
      <p>An alternative strategy for computing EFMs is via MILP, particularly when only a few small MCSs are required instead of a full enumeration (<xref rid="btz393-B29" ref-type="bibr">Rezola <italic>et al.</italic>, 2013</xref>, <xref rid="btz393-B30" ref-type="bibr">2015</xref>). Recall that EFMs are minimal-support vectors in the null space. Our method for finding small MCSs, which we call MCS<sup>2</sup>-MILP, similarly looks for vectors with MCS<sup>2</sup> in the row space, which is to say, EFMs with minimal coordinated support in the dual network.</p>
      <p>
        <statement id="mthst19">
          <label>Lemma 4</label>
          <p>(MCSs of a target set of reactions in a fully irreversible metabolic network). Let <italic>S</italic> be the stoichiometric matrix of a fully irreversible metabolic network <inline-formula id="IE136"><mml:math id="IM136"><mml:mi mathvariant="script">M</mml:mi></mml:math></inline-formula>. Let <italic>T</italic> be a set of target reactions. Then <italic>C</italic> is a cut set for all the reactions in <italic>T</italic> if and only if there exist a vector <inline-formula id="IE137"><mml:math id="IM137"><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="italic">Row</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE138"><mml:math id="IM138"><mml:mrow><mml:mi>T</mml:mi><mml:mo>⊆</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE139"><mml:math id="IM139"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>−</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
        </statement>
      </p>
      <p>
        <statement id="mthst20">
          <label>Proof.</label>
          <p> We need to show that every cut set for the target reactions arises from a vector in the row space with the described constraints, and every vector in the row space satisfying those constraints maps to a cut set.</p>
          <p>Let <italic>C</italic> be a cut set for all reactions in <italic>T</italic>. Therefore, <italic>C</italic> is a cut set for each reaction in <inline-formula id="IE140"><mml:math id="IM140"><mml:mrow><mml:mi>T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> individually. Based on Lemma 1, there exist vectors <inline-formula id="IE141"><mml:math id="IM141"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="italic">Row</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE142"><mml:math id="IM142"><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE143"><mml:math id="IM143"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>−</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE144"><mml:math id="IM144"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. In other words, for all vectors <inline-formula id="IE145"><mml:math id="IM145"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> the only negative elements are the ones with indices belonging to <italic>C</italic>, and all other elements are non-negative, with a strictly positive value in the one with index <italic>t<sub>i</sub></italic> in the vector <italic>u<sub>i</sub></italic>, for <inline-formula id="IE146"><mml:math id="IM146"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. If we define the vector <inline-formula id="IE147"><mml:math id="IM147"><mml:mrow><mml:mi>u</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo>⋯</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, then <inline-formula id="IE148"><mml:math id="IM148"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>−</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE149"><mml:math id="IM149"><mml:mrow><mml:mi>T</mml:mi><mml:mo>⊆</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and <italic>u</italic> is clearly in <italic>Row</italic>(<italic>S</italic>).</p>
          <p>Now, let <italic>u</italic> be a vector in <italic>Row</italic>(<italic>S</italic>) such that <inline-formula id="IE150"><mml:math id="IM150"><mml:mrow><mml:mi>T</mml:mi><mml:mo>⊆</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE151"><mml:math id="IM151"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>−</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula>. Then <inline-formula id="IE152"><mml:math id="IM152"><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for all <inline-formula id="IE153"><mml:math id="IM153"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. Based on Lemma 1, <inline-formula id="IE154"><mml:math id="IM154"><mml:mrow><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>−</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a cut set for the reaction <italic>t<sub>i</sub></italic>, for each <inline-formula id="IE155"><mml:math id="IM155"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. Therefore, <italic>C</italic> is a cut set for all the reactions in <italic>T</italic>, completing the proof. □</p>
          <p>Based on this Lemma we are able to find MCS for every set of target reactions without the restriction of only blocking one direction of a reaction. Since reversible reactions can be split into two reactions after reconfiguration, we can block a reversible reaction in one direction or in both directions.</p>
          <p>Let <inline-formula id="IE156"><mml:math id="IM156"><mml:mrow><mml:mi>S</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> be the <inline-formula id="IE157"><mml:math id="IM157"><mml:mrow><mml:mi>m</mml:mi><mml:mo>×</mml:mo><mml:mi>n</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> reconfigured matrix of the <italic>m </italic>×<italic> n</italic> stoichiometric matrix <italic>S</italic> with irreversible reactions <inline-formula id="IE158"><mml:math id="IM158"><mml:mi mathvariant="script">I</mml:mi></mml:math></inline-formula>. Since all the values in the stoichiometric matrix are proportions of consumed and produced metabolites, we can scale each row of <italic>S</italic> to have only integer entries without changing its structural properties.</p>
          <p>We now describe how to encode the problem of finding the smallest MCS for a target set <italic>T</italic> as a MILP. Let <inline-formula id="IE159"><mml:math id="IM159"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">Z</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> be a vector in the row space of the reconfigured matrix <inline-formula id="IE160"><mml:math id="IM160"><mml:mrow><mml:mi>S</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> corresponding to the smallest MCS for target reaction set <inline-formula id="IE161"><mml:math id="IM161"><mml:mrow><mml:mi>T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Then there exists a vector <inline-formula id="IE162"><mml:math id="IM162"><mml:mrow><mml:mi>y</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">Z</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> s.t <inline-formula id="IE163"><mml:math id="IM163"><mml:mrow><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:math></inline-formula>. If we define <inline-formula id="IE164"><mml:math id="IM164"><mml:mrow><mml:msup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo>−</mml:mo></mml:msup><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> as the indicator vectors of the positive and negative supports of <italic>v</italic>, respectively, we may force <italic>v<sub>i</sub></italic> to be non-positive if <inline-formula id="IE165"><mml:math id="IM165"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> is 0, and force it to be non-negative if <inline-formula id="IE166"><mml:math id="IM166"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> is 0, by adding the following constraints using <inline-formula id="IE167"><mml:math id="IM167"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE168"><mml:math id="IM168"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> as indicator variables:
<disp-formula id="E8"><label>(5)</label><mml:math id="M12"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>⇒</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mn>0</mml:mn><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>⇒</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></disp-formula></p>
          <p>There must also be positive values in the target positions:
<disp-formula id="E9"><label>(6)</label><mml:math id="M13"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>∀</mml:mo><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></disp-formula></p>
          <p>These constraints also ensure that <italic>v </italic>=<italic> </italic>0 is not in our feasible space. To make <italic>v</italic> a vector in the row space of <inline-formula id="IE169"><mml:math id="IM169"><mml:mrow><mml:mi>S</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> we need to add the <italic>y<sub>j</sub></italic> variables, namely, the entries of a vector <italic>y</italic> with size <italic>m</italic>. The constraint <inline-formula id="IE170"><mml:math id="IM170"><mml:mrow><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mi>S</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:math></inline-formula> then ensures that <italic>v</italic> is an element of the row space of <inline-formula id="IE171"><mml:math id="IM171"><mml:mrow><mml:mi>S</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
          <p>The objective function for finding the smallest MCS is:
<disp-formula id="E10"><label>(7)</label><mml:math id="M14"><mml:mrow><mml:mtext>minimize</mml:mtext><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:munderover><mml:mrow><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo></mml:msubsup></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
since the cut set is precisely the negative support of <italic>v</italic>, i.e. <italic>r</italic><sup>–</sup>.</p>
          <p>Suppose that we have found the smallest MCS <inline-formula id="IE172"><mml:math id="IM172"><mml:mrow><mml:mi mathvariant="script">C</mml:mi><mml:mo>⊊</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>′</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. To find the next smallest MCS, we need to exclude <inline-formula id="IE173"><mml:math id="IM173"><mml:mi mathvariant="script">C</mml:mi></mml:math></inline-formula> and all its supersets from our feasible space. This is achieved by the following constraint:
<disp-formula id="E11"><label>(8)</label><mml:math id="M15"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">C</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo></mml:msubsup></mml:mrow><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></disp-formula></p>
          <p>We can keep excluding newly found MCSs and thus enumerate them in order of increasing size. As we stated above, in most scenarios we only wish to block an irreversible reaction or one direction of a reversible reaction. In those cases, we can avoid re-configuring the network to have a smaller stoichiometric matrix. Let <italic>t</italic> be the only target reaction. Instead of the constraints (6), we only need one constraint <inline-formula id="IE174"><mml:math id="IM174"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> if we want to block it in forward direction, and we need the constraint <inline-formula id="IE175"><mml:math id="IM175"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> if we need to block it in the reverse direction. The objective function (7) and constraints (8) can be updated as follows to reflect the coordinated support instead of the negative support:
<disp-formula id="E12"><mml:math id="M16"><mml:mrow><mml:mtext>minimize</mml:mtext><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo></mml:msubsup></mml:mrow><mml:mo>+</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">I</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:munder><mml:mrow><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">C</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo></mml:msubsup></mml:mrow><mml:mo>+</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mo>∩</mml:mo><mml:mi mathvariant="script">I</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo></mml:msubsup></mml:mrow><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></disp-formula></p>
          <p>Unlike <xref rid="btz393-B39" ref-type="bibr">von Kamp and Klamt (2014)</xref>, our problem formulation does not require any additional constraints, because they only reduce a part of the feasible space of our problem without affecting the optimum objective value. This concerns constraints such as <inline-formula id="IE176"><mml:math id="IM176"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo></mml:msubsup><mml:mo>≤</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE177"><mml:math id="IM177"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo></mml:msubsup><mml:mo>⇒</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>&gt;</mml:mo><mml:mo>ϵ</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        </statement>
      </p>
    </sec>
  </sec>
  <sec>
    <title>3 Implementation details</title>
    <p>Except where noted, the implementations we discuss are in MATLAB. Each method that we consider requires an extreme ray computation, with the underlying cone varying. We used FluxModeCalculator’s EFM generator (<xref rid="btz393-B37" ref-type="bibr">van Klinken and Willems van Dijk, 2016</xref>) for this purpose. Note that the optimized Berge algorithm implemented by CellNetAnalyzer (<xref rid="btz393-B18" ref-type="bibr">Klamt <italic>et al.</italic>, 2007</xref>) uses the older EFM finder of CellNetAnalyzer by default. However, we observed that it is a slower implementation of an identical calculation, so we rewrote this part to use FluxModeCalculator in order to make a fair comparison. The MCS<sup>2</sup> method and the target-specific dual network method both need to remove redundant supersets from the obtained extreme rays, since the desired minimality is not with respect to the full support of the vector, but only a specific part of it (the <inline-formula id="IE178"><mml:math id="IM178"><mml:mi mathvariant="script">I</mml:mi></mml:math></inline-formula>-coordinated support for the former, and support in the <italic>v</italic>-coordinates for the latter). We use an implementation in Java whose time complexity is <inline-formula id="IE179"><mml:math id="IM179"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for a collection of <italic>N</italic> sets. All stoichiometric matrices are compressed by the Mongoose (<xref rid="btz393-B21" ref-type="bibr">Leonid <italic>et al.</italic>, 2014</xref>) before processing, which converts them to a canonical form.</p>
    <p>Since the null space is needed for the row space method, we calculate the null space basis matrix using Mongoose (<xref rid="btz393-B21" ref-type="bibr">Leonid <italic>et al.</italic>, 2014</xref>). Since finding the MCSs in every method takes several seconds to several minutes, and the computation time of the null space basis matrix is less than a second in every case, we ignore this component of it. The reduced matrix given by Mongoose (for Berge and MFK), the target-specific dual matrix (for the target-specific dual method) and the null space basis matrix (for MCS<sup>2</sup>) get further compressed by FluxModeCalculator before processing. For the Berge algorithm, we used CellNetAnalyzer (<xref rid="btz393-B18" ref-type="bibr">Klamt <italic>et al.</italic>, 2007</xref>). We also used an existing implementation of the improved modified Fredman–Khachiyan (MFK) algorithm (<xref rid="btz393-B32" ref-type="bibr">Sedaghat <italic>et al.</italic>, 2018</xref>). However, we implemented the target-specific dual method from scratch using MATLAB and the source code of FluxModeCalculator. All the enhancements mentioned in the <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref> of the original paper (<xref rid="btz393-B2" ref-type="bibr">Ballerstein <italic>et al.</italic>, 2012</xref>) were implemented as well.</p>
    <p>We used CPLEX (IBM) to solve the MILPs. The implementation was done via the Java API and has been implemented for single target reactions without network reconfiguration, and for multiple target reactions with network reconfiguration. Since the stoichiometric matrices needed to contain only integers, we used the integralize function of MONGOOSE (<xref rid="btz393-B21" ref-type="bibr">Leonid <italic>et al.</italic>, 2014</xref>) to multiply each row by the smallest possible integer that makes all the values integer (which is the least common multiple of the denominators of its entries). We also tested the results of our MILP in small networks against other implementations to make sure that the results are consistent. The implementation of all the methods and the MILP version of our method are publicly available at <ext-link ext-link-type="uri" xlink:href="https://github.com/RezaMash/MCS">https://github.com/RezaMash/MCS</ext-link> under the GNU 3.0 license. Some of them require the use of non-public modules available for academic use, such as CellNetAnalyzer (<xref rid="btz393-B18" ref-type="bibr">Klamt <italic>et al.</italic>, 2007</xref>) and CPLEX (IBM).</p>
  </sec>
  <sec>
    <title>4 Results</title>
    <p>In this section, we summarize the performance of MCS<sup>2</sup> and MCS<sup>2</sup>-MILP in comparison to the other methods.</p>
    <p>We ran the implementations on the first 5 models in our database in the GitHub repository. We compared the set of MCSs in these five small examples to confirm that all the implementations produced same results. For the other results presented in <xref rid="btz393-T1" ref-type="table">Tables 1–3</xref>, we again checked the number of MCSs reported by implementations if they finished, and the numbers matched in all cases. We then ran the methods on several models from the BioModels database (<xref rid="btz393-B23" ref-type="bibr">Li <italic>et al.</italic>, 2010</xref>). There were a few models on which our method either was not able to finish in the given time (5 h) or took much longer to report the MCSs, while the optimized Berge was able to finish in time and beat our method (see <xref rid="btz393-T3" ref-type="table">Table 3</xref> for an example). This is due to the large number of supersets generated in that example by MCS<sup>2</sup>. However, MCS<sup>2</sup> always performed better than the target-specific dual network approach, despite all its suggested enhancements being implemented. In addition, as can be seen for the <italic>hepatic polyamine and sulfur amino acid combined</italic> model (<xref rid="btz393-B28" ref-type="bibr">Reyes-Palomares <italic>et al.</italic>, 2012</xref>), the Berge and MFK methods could not finish in 5 h, but MCS<sup>2</sup> generated results in 4 min, and the dual method in 30 min.</p>
    <table-wrap id="btz393-T1" orientation="portrait" position="float">
      <label>Table 1.</label>
      <caption>
        <p>Result of running the methods on the <italic>hepatic polyamine and sulfur amino acid network</italic> (<xref rid="btz393-B28" ref-type="bibr">Reyes-Palomares <italic>et al.</italic>, 2012</xref>)</p>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="1" colspan="1">All times are in seconds</th>
            <th rowspan="1" colspan="1">Optimized Berge</th>
            <th rowspan="1" colspan="1">Improved MFK</th>
            <th rowspan="1" colspan="1">Target-specific dual network</th>
            <th rowspan="1" colspan="1">MCS<sup>2</sup> dual network</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">Extreme ray computation</td>
            <td rowspan="1" colspan="1">270.2</td>
            <td rowspan="1" colspan="1">270.2</td>
            <td rowspan="1" colspan="1">1191.9</td>
            <td rowspan="1" colspan="1">79.8</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Secondary process time</td>
            <td rowspan="1" colspan="1">&gt;18 000</td>
            <td rowspan="1" colspan="1">&gt;18 000</td>
            <td rowspan="1" colspan="1">591.3</td>
            <td rowspan="1" colspan="1">157.4</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Total time</td>
            <td rowspan="1" colspan="1">&gt;18 000</td>
            <td rowspan="1" colspan="1">&gt;18 000</td>
            <td rowspan="1" colspan="1">1783.2</td>
            <td rowspan="1" colspan="1">237.2</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <fn id="tblfn1">
          <p>Note: <inline-formula id="IE180"><mml:math id="IM180"><mml:mrow><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>53</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>73</mml:mn></mml:mrow></mml:math></inline-formula>; target reaction 1.</p>
        </fn>
      </table-wrap-foot>
    </table-wrap>
    <table-wrap id="btz393-T2" orientation="portrait" position="float">
      <label>Table 2.</label>
      <caption>
        <p>Result of running the methods on the <italic>kinetic model of yeast</italic> network (<xref rid="btz393-B34" ref-type="bibr">Stanford <italic>et al.</italic>, 2013</xref>) with <inline-formula id="IE181"><mml:math id="IM181"><mml:mrow><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>295</mml:mn><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>285</mml:mn></mml:mrow></mml:math></inline-formula>; all the reactions were used as targets</p>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="1" colspan="1">All times are in seconds</th>
            <th rowspan="1" colspan="1">Optimized Berge</th>
            <th rowspan="1" colspan="1">Improved MFK</th>
            <th rowspan="1" colspan="1">Target-specific Dual network</th>
            <th rowspan="1" colspan="1">MCS<sup>2</sup> Dual network</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">Extreme ray computation</td>
            <td align="center" rowspan="1" colspan="1">86.0</td>
            <td align="center" rowspan="1" colspan="1">86.0</td>
            <td rowspan="1" colspan="1">&gt;18 000</td>
            <td rowspan="1" colspan="1">53.0</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Secondary process time</td>
            <td rowspan="1" colspan="1">&gt;18 000<xref ref-type="table-fn" rid="tblfn2"><sup>a</sup></xref></td>
            <td rowspan="1" colspan="1">&gt;18 000</td>
            <td rowspan="1" colspan="1">—</td>
            <td rowspan="1" colspan="1">13.6</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Total time</td>
            <td rowspan="1" colspan="1">&gt;18 000<xref ref-type="table-fn" rid="tblfn2"><sup>a</sup></xref></td>
            <td rowspan="1" colspan="1">&gt;18 000</td>
            <td rowspan="1" colspan="1">&gt;18 000</td>
            <td rowspan="1" colspan="1">66.6</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <fn id="tblfn2">
          <label>a</label>
          <p>Berge computed the MCSs for the first 5 reactions before running out of time. The MFK and target-specific dual methods were not able to finish the computation of the MCSs even for the first reaction.</p>
        </fn>
      </table-wrap-foot>
    </table-wrap>
    <table-wrap id="btz393-T3" orientation="portrait" position="float">
      <label>Table 3.</label>
      <caption>
        <p>Result of running the methods on <italic>Fernandez2006 ModelB</italic> (<xref rid="btz393-B7" ref-type="bibr">Fernandez <italic>et al.</italic>, 2006</xref>) with <inline-formula id="IE182"><mml:math id="IM182"><mml:mrow><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>75</mml:mn><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>152</mml:mn></mml:mrow></mml:math></inline-formula>; target reaction 1</p>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="center" span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="1" colspan="1">All times are in seconds</th>
            <th rowspan="1" colspan="1">Optimized Berge</th>
            <th rowspan="1" colspan="1">Improved MFK</th>
            <th rowspan="1" colspan="1">Target-specificdual network</th>
            <th rowspan="1" colspan="1">MCS<sup>2</sup> dual network</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">Extreme ray computation</td>
            <td rowspan="1" colspan="1">99.5</td>
            <td rowspan="1" colspan="1">99.5</td>
            <td rowspan="1" colspan="1">&gt;18 000</td>
            <td rowspan="1" colspan="1">&gt;18 000</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Secondary process</td>
            <td rowspan="1" colspan="1">2.1</td>
            <td rowspan="1" colspan="1">1445.1</td>
            <td rowspan="1" colspan="1">—</td>
            <td rowspan="1" colspan="1">—</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Total time</td>
            <td rowspan="1" colspan="1">101.6</td>
            <td rowspan="1" colspan="1">1544.6</td>
            <td rowspan="1" colspan="1">&gt;18 000</td>
            <td rowspan="1" colspan="1">&gt;18 000</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <fn id="tblfn3">
          <p><italic>Note:</italic> This is an example where MCS<sup>2</sup> and the target-specific dual methods could not finish in time, while the Berge and MFK methods reported all 194 689 MCSs for the compressed network’s reaction 1 fairly quickly.</p>
        </fn>
      </table-wrap-foot>
    </table-wrap>
    <p>The first task of every method is an extreme ray computation, which for Berge and MFK is the well-known EFM computation. Berge and MFK then proceed to generate the MCSs through dualization, while the secondary process of the target-specific dual network and MCS<sup>2</sup> approaches is removing the redundant cut sets. In the first two provided examples, the target is the forward direction of the first reaction. <xref rid="btz393-T2" ref-type="table">Table 2</xref> shows the computation time for calculating the MCSs for all possible target reactions. In the <italic>kinetic model of yeast metabolic network</italic>, described in <xref rid="btz393-B34" ref-type="bibr">Stanford <italic>et al.</italic> (2013)</xref>, our method’s advantage is clear—it was able to finish computing the MCSs for all the reactions in under 14 s. Note that the dimensions stated in the tables are the ones before compression is applied. The conclusion is there are models for which it was not feasible to enumerate the full set of MCSs for a given target reaction before our work, but it is feasible now with MCS<sup>2</sup>.</p>
    <p>We ran the MILP versions on larger networks alongside the MILP version of the target-specific dual approach, as described in <xref rid="btz393-B39" ref-type="bibr">von Kamp and Klamt (2014)</xref>. This version is also a part of CellNetAnalyzer and is believed to be the state of the art for extracting some of the smallest MCSs in increasing order of size. We were able to compute 100 MCSs for reaction 10 (the first reaction with at least 100 MCSs) in <xref rid="btz393-B24" ref-type="bibr">Li <italic>et al.</italic> (2012</xref>) model, which has 578 reactions after compression. The time required by both approaches on the first 40 MCSs is shown in <xref ref-type="fig" rid="btz393-F4">Figure 4</xref>.
</p>
    <fig id="btz393-F4" orientation="portrait" position="float">
      <label>Fig. 4.</label>
      <caption>
        <p>Time (in seconds) for computing each of the 40 smallest MCSs for reaction 10 (the first reaction which has at least 100 MCSs) of the Li2012 calcium-mediated synaptic plasticity model (<xref rid="btz393-B24" ref-type="bibr">Li <italic>et al.</italic>, 2012</xref>)</p>
      </caption>
      <graphic xlink:href="btz393f4"/>
    </fig>
    <p>MILP was used to find a subset of the MCSs (<xref rid="btz393-B33" ref-type="bibr">Song <italic>et al.</italic>, 2017</xref>). The target-specific dual method has previously been used for this task, in a method called MCSEnumerator (<xref rid="btz393-B39" ref-type="bibr">von Kamp and Klamt, 2014</xref>; <xref rid="btz393-B38" ref-type="bibr">Vieira <italic>et al.</italic>, 2016</xref>). As its authors state, not all the EFMs in the dual space result in valid MCSs, but by adding the appropriate constraints, one can remove the redundant results from the ILP’s feasible space. To get a sense of how our approach, MCS<sup>2</sup>-MILP, performs compared to MCSEnumerator, we implemented the MILP described in <xref rid="btz393-B39" ref-type="bibr">von Kamp and Klamt (2014</xref>), currently part of CellNetAnalyzer. We ran our implementation of MCSEnumerator (<xref rid="btz393-B39" ref-type="bibr">von Kamp and Klamt, 2014</xref>) and MCS<sup>2</sup>-MILP on <italic>E.coli iAF1260</italic> for the sake of comparison, which showed a similar performance, as shown in <xref rid="btz393-T4" ref-type="table">Table 4</xref>. This table contains the result of running MILPs for each reaction as a target reaction once per iteration. In each iteration, we restricted the MILPs to not spend more than 1 min on finding MCSs. <xref rid="btz393-T5" ref-type="table">Table 5</xref> shows the result of the same experiment repeated with models chosen from the BiGG database (<xref rid="btz393-B16" ref-type="bibr">King <italic>et al.</italic>, 2016</xref>).</p>
    <table-wrap id="btz393-T4" orientation="portrait" position="float">
      <label>Table 4.</label>
      <caption>
        <p>Result of running MCS<sup>2</sup>-MILP and MCSEnumerator on the <italic>E.coli iAF1260</italic> network with 2382 reactions (981 reactions after compression)</p>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="1" colspan="1">Method used</th>
            <th rowspan="1" colspan="1">Average number of MCSs</th>
            <th rowspan="1" colspan="1">Average time for shortest MCS</th>
            <th rowspan="1" colspan="1">Number of targets MILP failed on</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">MCS<sup>2</sup>-MILP</td>
            <td rowspan="1" colspan="1">12.74 MCSs</td>
            <td rowspan="1" colspan="1">4.45 s</td>
            <td rowspan="1" colspan="1">17</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">MCSEnumerator</td>
            <td rowspan="1" colspan="1">12.07 MCSs</td>
            <td rowspan="1" colspan="1">5.22 s</td>
            <td rowspan="1" colspan="1">13</td>
          </tr>
        </tbody>
      </table>
    </table-wrap>
    <table-wrap id="btz393-T5" orientation="portrait" position="float">
      <label>Table 5.</label>
      <caption>
        <p>Result of running MCS<sup>2</sup>-MILP and MCSEnumerator on the models from the BiGG database which initially have 2000–2600 reactions</p>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="" span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="2" colspan="1">Model ID</th>
            <th rowspan="2" colspan="1">Average time for shortest MCS for MCSE numerator (s)</th>
            <th rowspan="2" colspan="1">Average time for shortest MCS for MCS<sup>2</sup>-MILP (s)</th>
            <th rowspan="1" colspan="1">Reactions before (after)</th>
          </tr>
          <tr>
            <th rowspan="1" colspan="1">compression</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">iJO1366</td>
            <td rowspan="1" colspan="1">4.66</td>
            <td rowspan="1" colspan="1">3.98</td>
            <td rowspan="1" colspan="1">2583 (1106)</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">iRC1080</td>
            <td rowspan="1" colspan="1">7.12</td>
            <td rowspan="1" colspan="1">7.19</td>
            <td rowspan="1" colspan="1">2191 (1080)</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">STM_v1_0</td>
            <td rowspan="1" colspan="1">1.82</td>
            <td rowspan="1" colspan="1">1.83</td>
            <td rowspan="1" colspan="1">2545 (1031)</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">iSbBS512_1146</td>
            <td rowspan="1" colspan="1">14.10</td>
            <td rowspan="1" colspan="1">19.03</td>
            <td rowspan="1" colspan="1">2591 (1018)</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">iAF1260</td>
            <td rowspan="1" colspan="1">5.22</td>
            <td rowspan="1" colspan="1">4.45</td>
            <td rowspan="1" colspan="1">2382 (981)</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">iSDY_1059</td>
            <td rowspan="1" colspan="1">8.00</td>
            <td rowspan="1" colspan="1">9.63</td>
            <td rowspan="1" colspan="1">2539 (942)</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">iYL1228</td>
            <td rowspan="1" colspan="1">1.88</td>
            <td rowspan="1" colspan="1">2.11</td>
            <td rowspan="1" colspan="1">2262 (805)</td>
          </tr>
        </tbody>
      </table>
    </table-wrap>
    <p>The results in <xref ref-type="fig" rid="btz393-F4">Figure 4</xref> and <xref rid="btz393-T5" ref-type="table">Table 5</xref> suggest that while MCS<sup>2</sup>-MILP does not perform faster than the MCSEnumerator, it is not slower either. On the other hand, MCS<sup>2</sup>-MILP is in the first version of itself. It has very simple structure compare to the MCSEnumerator and there is a possibility that it would improve. Even if not, MCS<sup>2</sup>-MILP is an alternative method which is easier to implement and understand and can help to have a better insight about what is exactly happening during the procedure of these methods.</p>
  </sec>
  <sec>
    <title>5 Conclusions and future work</title>
    <p>One key advantage of our method is that it does not depend on the target reaction to construct the dual network. The computations for one target reaction can therefore be reused for a different target reaction. Furthermore, it tends to operate on a smaller network than the original.</p>
    <p>One limitation to our method is that it is primarily designed for single target reactions (rather than a target containing a set of reactions), while both are just as easily handled by the competitor methods. Although MCS<sup>2</sup> does not find the MCSs for a set of reactions directly, it can easily find the MCSs for each reaction individually, then prune any supersets from the union of these MCSs.</p>
    <p>An alternate strategy for computing MCSs is via MILP, particularly when only a few short sets are required, rather than a complete enumeration (<xref rid="btz393-B29" ref-type="bibr">Rezola <italic>et al.</italic>, 2013</xref>, <xref rid="btz393-B30" ref-type="bibr">2015</xref>). We showed that MCS<sup>2</sup> can be easily adapted to this task via the MCS<sup>2</sup>-MILP method, which has shown performance not inferior to that of the state of the art. Another topic for further investigation can be the problem of finding a partial set of irreversible minimal cut sets (iMCSs) (<xref rid="btz393-B1" ref-type="bibr">Annika <italic>et al.</italic>, 2018</xref>) with MILP. With proper additional constraints, we can find a partial set of iMCSs. There has been some work in enumerating iMCSs; the MILP version of this method is a suitable contender.</p>
    <p>Another strategy is to alter the double description method to directly find rays with MCS<sup>2</sup> instead of minimal support, e.g. by ignoring some of dimensions of the reconfigured network. Here it is important to be careful about zero-cycle flux modes, which are flux modes that have fluxes in both direction of a split reversible reaction. These are not valid flux modes, but they do appear in the output of the double description method (<xref rid="btz393-B9" ref-type="bibr">Gagneur and Klamt, 2004</xref>) and they may cause the omission of some rays which contain them in their support.</p>
    <p>As we mentioned, there are many models for which our method outperforms all other existing methods, while for some models, the best performance is obtained by the Berge algorithm. The challenge is to find out what features of these models are different, and then to decide ahead of time what method to choose for a given model.</p>
    <p>Our method is based on novel insights, and may be refined further. Possible additional sources of improvement include identifying and removing unwanted supersets during the execution of the double description method and optimizing the process of superset removal during post-processing. We believe that our method opens the door to further ideas exploring this different kind of duality between EFMs and MCSs, and deeper insights into the structure of metabolic network models.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>TS would like to acknowledge financial support from an NSERC Discovery Grant. LC would like to acknowledge financial support from a Sloan Foundation Fellowship and an NSERC Discovery Grant.</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="sup1">
      <label>btz393_Supplementary_Data</label>
      <media xlink:href="btz393_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btz393-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Annika</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Computing irreversible minimal cut sets in genome-scale metabolic networks via flux cone projection</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>3011</fpage>–<lpage>3017</lpage>.</mixed-citation>
    </ref>
    <ref id="btz393-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Ballerstein</surname><given-names>K.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>Minimal cut sets in a metabolic network are elementary modes in a dual network</article-title>. <source>Bioinformatics</source>, <volume>28</volume>, <fpage>381</fpage>–<lpage>387</lpage>.<pub-id pub-id-type="pmid">22190691</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B3">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Berge</surname><given-names>C.</given-names></name></person-group> (<year>1984</year>) <source>Hypergraphs: Combinatorics of Finite Sets, Volume 45 of North-Holland Mathematical Library</source>. 
<publisher-name>Elsevier</publisher-name>, 
<publisher-loc>Toronto, Canada</publisher-loc>. </mixed-citation>
    </ref>
    <ref id="btz393-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bordbar</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Constraint-based models predict metabolic and associated cellular functions</article-title>. <source>Nat. Rev. Genet</source>., <volume>15</volume>, <fpage>107</fpage>.<pub-id pub-id-type="pmid">24430943</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Burgard</surname><given-names>A.P.</given-names></name></person-group><etal>et al</etal> (<year>2001</year>) <chapter-title>Minimal reaction sets for Escherichia coli metabolism under different growth requirements and uptake environments</chapter-title>
<source>Biotechnol. Prog.</source>, <volume>17</volume>, <fpage>791</fpage>–<lpage>797</lpage>.<pub-id pub-id-type="pmid">11587566</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chindelevitch</surname><given-names>L.</given-names></name></person-group> (<year>2014</year>) 
<article-title>An exact arithmetic toolbox for a consistent and reproducible structural analysis of metabolic network models</article-title>. <source>Nat Commun.</source>, <volume>5</volume>, <fpage>4893</fpage>.<pub-id pub-id-type="pmid">25291352</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Eiter</surname><given-names>T.</given-names></name></person-group><etal>et al</etal> (<year>2008</year>) 
<article-title>Computational aspects of monotone dualization: a brief survey</article-title>. <source>Discrete Appl. Math</source>., <volume>156</volume>, <fpage>2035</fpage>–<lpage>2049</lpage>.</mixed-citation>
    </ref>
    <ref id="btz393-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Fernandez</surname><given-names>É.</given-names></name></person-group><etal>et al</etal> (<year>2006</year>) 
<article-title>DARPP-32 is a robust integrator of dopamine and glutamate signals</article-title>. <source>PLoS Computat. Biol</source>., <volume>2</volume>, <fpage>e176</fpage>.</mixed-citation>
    </ref>
    <ref id="btz393-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Fredman</surname><given-names>M.</given-names></name>, <name name-style="western"><surname>Khachiyan</surname><given-names>L.</given-names></name></person-group> (<year>1996</year>) 
<article-title>On the complexity of dualization of monotone disjunctive normal forms</article-title>. <source>J. Algorith</source>., <volume>21</volume>, <fpage>618</fpage>–<lpage>628</lpage>.</mixed-citation>
    </ref>
    <ref id="btz393-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Gagneur</surname><given-names>J.</given-names></name>, <name name-style="western"><surname>Klamt</surname><given-names>S.</given-names></name></person-group> (<year>2004</year>) 
<article-title>Computation of elementary modes: a unifying framework and the new binary approach</article-title>. <source>BMC Bioinformatics</source>, <volume>5</volume>, <fpage>175.</fpage><pub-id pub-id-type="pmid">15527509</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Gainer-Dewar</surname><given-names>A.</given-names></name>, <name name-style="western"><surname>Vera-Licona</surname><given-names>P.</given-names></name></person-group> (<year>2017</year>) 
<article-title>The minimal hitting set generation problem: algorithms and computation</article-title>. <source>SIAM J. Discrete Math</source>., <volume>31</volume>, <fpage>63</fpage>–<lpage>100</lpage>.</mixed-citation>
    </ref>
    <ref id="btz393-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Harder</surname><given-names>B.-J.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Model-based metabolic engineering enables high yield itaconic acid production by <italic>Escherichia coli</italic></article-title>. <source>Metab. Eng</source>., <volume>38</volume>, <fpage>29</fpage>–<lpage>37</lpage>.<pub-id pub-id-type="pmid">27269589</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Hartman</surname><given-names>H.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Identification of potential drug targets in <italic>Salmonella enterica sv</italic>. Typhimurium using metabolic modelling and experimental validation</article-title>. <source>Microbiology</source>, <volume>160</volume>, <fpage>1252</fpage>–<lpage>1266</lpage>.<pub-id pub-id-type="pmid">24777662</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Haus</surname><given-names>U.-U.</given-names></name></person-group><etal>et al</etal> (<year>2008</year>) 
<article-title>Computing knock-out strategies in metabolic networks</article-title>. <source>J. Comput. Biol</source>., <volume>15</volume>, <fpage>259</fpage>–<lpage>268</lpage>.<pub-id pub-id-type="pmid">18331197</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B14">
      <mixed-citation publication-type="other">IBM. CPLEX optimizer. <ext-link ext-link-type="uri" xlink:href="http://www-01.ibm.com/software/integration/optimization/cplex-optimizer">www-01.ibm.com/software/integration/optimization/cplex-optimizer</ext-link>.</mixed-citation>
    </ref>
    <ref id="btz393-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Imielinski</surname><given-names>M.</given-names></name>, <name name-style="western"><surname>Belta</surname><given-names>C.</given-names></name></person-group> (<year>2008</year>) 
<article-title>Exploiting the pathway structure of metabolism to reveal high-order epistasis</article-title>. <source>BMC Syst. Biol</source>., <volume>2</volume>, <fpage>40</fpage>.<pub-id pub-id-type="pmid">18447928</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>King</surname><given-names>Z.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>BiGG Models: a platform for integrating, standardizing and sharing genome-scale models</article-title>. <source>Nucleic Acids Res</source>., <volume>44</volume>, <fpage>D515</fpage>–<lpage>D522</lpage>.<pub-id pub-id-type="pmid">26476456</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Klamt</surname><given-names>S.</given-names></name></person-group> (<year>2006</year>) 
<article-title>Generalized concept of minimal cut sets in biochemical networks</article-title>. <source>Biosystems</source>, <volume>83</volume>, <fpage>233</fpage>–<lpage>247</lpage>.<pub-id pub-id-type="pmid">16303240</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Klamt</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2007</year>) 
<article-title>Structural and functional analysis of cellular networks with CellNetAnalyzer</article-title>. <source>BMC Syst. Biol</source>., <volume>1</volume>, <fpage>2</fpage>.<pub-id pub-id-type="pmid">17408509</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Klamt</surname><given-names>S.</given-names></name>, <name name-style="western"><surname>Gilles</surname><given-names>E.</given-names></name></person-group> (<year>2004</year>) 
<article-title>Minimal cut sets in biochemical reaction networks</article-title>. <source>Bioinformatics</source>, <volume>20</volume>, <fpage>226</fpage>–<lpage>234</lpage>.<pub-id pub-id-type="pmid">14734314</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Leonid</surname><given-names>C.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>An exact arithmetic toolbox for a consistent and reproducible structural analysis of metabolic network models</article-title>. <source>Nat. Commun</source>., <volume>5</volume>, <fpage>4893</fpage>.<pub-id pub-id-type="pmid">25291352</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lewis</surname><given-names>N.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>Constraining the metabolic genotype–phenotype relationship using a phylogeny of in silico methods</article-title>. <source>Nat. Rev. Microbiol</source>., <volume>10</volume>, <fpage>291</fpage>.<pub-id pub-id-type="pmid">22367118</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>C.</given-names></name></person-group><etal>et al</etal> (<year>2010</year>) 
<article-title>BioModels database: an enhanced, curated and annotated resource for published quantitative kinetic models</article-title>. <source>BMC Syst. Biol</source>., <volume>4</volume>, <fpage>92</fpage>.<pub-id pub-id-type="pmid">20587024</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>L.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>Calcium input frequency, duration and amplitude differentially modulate the relative activation of calcineurin and CaMKII</article-title>. <source>PLoS One</source>, <volume>7</volume>, <fpage>e43810</fpage>.<pub-id pub-id-type="pmid">22962589</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Mahadevan</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Genome-scale strain designs based on regulatory minimal cut sets</article-title>. <source>Bioinformatics</source>, <volume>31</volume>, <fpage>2844</fpage>–<lpage>2851</lpage>.<pub-id pub-id-type="pmid">25913205</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Müller</surname><given-names>S.</given-names></name>, <name name-style="western"><surname>Regensburger</surname><given-names>G.</given-names></name></person-group> (<year>2016</year>) 
<article-title>Elementary vectors and conformal sums in polyhedral geometry and their relevance for metabolic pathway analysis</article-title>. <source>Front. Genet</source>., <volume>7</volume>, <fpage>90.</fpage><pub-id pub-id-type="pmid">27252734</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Price</surname><given-names>N.</given-names></name></person-group><etal>et al</etal> (<year>2004</year>) 
<article-title>Genome-scale models of microbial cells: evaluating the consequences of constraints</article-title>. <source>Nat. Rev. Microbiol</source>., <volume>2</volume>, <fpage>886</fpage>.<pub-id pub-id-type="pmid">15494745</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Reyes-Palomares</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>A combined model of hepatic polyamine and sulfur amino acid metabolism to analyze S-adenosyl methionine availability</article-title>. <source>Amino Acids</source>, <volume>42</volume>, <fpage>597</fpage>–<lpage>610</lpage>.<pub-id pub-id-type="pmid">21814788</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Rezola</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>Selection of human tissue-specific elementary flux modes using gene expression data</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>2009</fpage>–<lpage>2016</lpage>.<pub-id pub-id-type="pmid">23742984</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Rezola</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Advances in network-based metabolic pathway analysis and gene expression data integration</article-title>. <source>Brief. Bioinformatics</source>, <volume>16</volume>, <fpage>265</fpage>–<lpage>279</lpage>.<pub-id pub-id-type="pmid">24626528</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Schuster</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2000</year>) 
<article-title>A general definition of metabolic pathways useful for systematic organization and analysis of complex metabolic networks</article-title>. <source>Nat. Biotechnol</source>., <volume>18</volume>, <fpage>326</fpage>.<pub-id pub-id-type="pmid">10700151</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B32">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Sedaghat</surname><given-names>N.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) Speeding up dualization in the Fredman–Khachiyan algorithm B. In <italic>Leibniz International Proceedings in Informatics, Caen, France</italic>, Vol. 103. Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik.</mixed-citation>
    </ref>
    <ref id="btz393-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Song</surname><given-names>H.-S.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>Sequential computation of elementary modes and minimal cut sets in genome-scale metabolic networks using alternate integer linear programming</article-title>. <source>Bioinformatics</source>, <volume>33</volume>, <fpage>2345</fpage>–<lpage>2353</lpage>.<pub-id pub-id-type="pmid">28369193</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Stanford</surname><given-names>N.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>Systematic construction of kinetic models from genome-scale metabolic networks</article-title>. <source>PLoS One</source>, <volume>8</volume>, <fpage>e79195</fpage>.<pub-id pub-id-type="pmid">24324546</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Terzer</surname><given-names>M.</given-names></name>, <name name-style="western"><surname>Stelling</surname><given-names>J.</given-names></name></person-group> (<year>2008</year>) 
<article-title>Large-scale computation of elementary flux modes with bit pattern trees</article-title>. <source>Bioinformatics</source>, <volume>24</volume>, <fpage>2229</fpage>–<lpage>2235</lpage>.<pub-id pub-id-type="pmid">18676417</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Trinh</surname><given-names>C.T.</given-names></name></person-group><etal>et al</etal> (<year>2006</year>) 
<article-title>Design, construction and performance of the most efficient biomass producing <italic>E. coli</italic> bacterium</article-title>. <source>Metab. Eng</source>., <volume>8</volume>, <fpage>628</fpage>–<lpage>638</lpage>.<pub-id pub-id-type="pmid">16997589</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B37">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>van Klinken</surname><given-names>J.B.</given-names></name>, <name name-style="western"><surname>Willems van Dijk</surname><given-names>K.</given-names></name></person-group> (<year>2016</year>) 
<article-title>FluxModeCalculator: an efficient tool for large-scale flux mode computation</article-title>. <source>Bioinformatics</source>, <volume>32</volume>, <fpage>1265</fpage>–<lpage>1266</lpage>.<pub-id pub-id-type="pmid">26685305</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B38">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Vieira</surname><given-names>V.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) <chapter-title>Development of an integrated framework for minimal cut set enumeration in constraint-based models</chapter-title> In: <source>10th International Conference on Practical Applications of Computational Biology &amp; Bioinformatics, Ávila, Spain</source>, pp. <fpage>193</fpage>–<lpage>201</lpage>. 
<publisher-name>Springer</publisher-name>.</mixed-citation>
    </ref>
    <ref id="btz393-B39">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>von Kamp</surname><given-names>A.</given-names></name>, <name name-style="western"><surname>Klamt</surname><given-names>S.</given-names></name></person-group> (<year>2014</year>) 
<article-title>Enumeration of smallest intervention strategies in genome-scale metabolic networks</article-title>. <source>PLoS Comput. Biol</source>., <volume>10</volume>, <fpage>e1003378.</fpage><pub-id pub-id-type="pmid">24391481</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B40">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>von Kamp</surname><given-names>A.</given-names></name>, <name name-style="western"><surname>Klamt</surname><given-names>S.</given-names></name></person-group> (<year>2017</year>) 
<article-title>Growth-coupled overproduction is feasible for almost all metabolites in five major production organisms</article-title>. <source>Nat. Commun</source>., <volume>8</volume>, <fpage>15956.</fpage><pub-id pub-id-type="pmid">28639622</pub-id></mixed-citation>
    </ref>
    <ref id="btz393-B41">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Wagner</surname><given-names>C.</given-names></name></person-group> (<year>2004</year>) 
<article-title>Nullspace approach to determine the elementary modes of chemical reaction systems</article-title>. <source>The Journal of Physical Chemistry B</source>, <volume>108</volume>, <fpage>2425</fpage>–<lpage>2431</lpage>.</mixed-citation>
    </ref>
    <ref id="btz393-B42">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Zabeti</surname><given-names>H.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) <chapter-title>A duality-based method for identifying elemental balance violations in metabolic network models</chapter-title> In: <source>Leibniz International Proceedings in Informatics, Caen, France</source>, Vol. <volume>113</volume>
<publisher-name>Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik</publisher-name>.</mixed-citation>
    </ref>
  </ref-list>
</back>
