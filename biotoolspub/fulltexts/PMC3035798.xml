<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3035798</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btq677</article-id>
    <article-id pub-id-type="publisher-id">btq677</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group>
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>SlideSort: all pairs similarity search for short reads</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Shimizu</surname>
          <given-names>Kana</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="COR1">
          <sup>*</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Tsuda</surname>
          <given-names>Koji</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="AFF1">
          <sup>2</sup>
        </xref>
      </contrib>
    </contrib-group>
    <aff id="AFF1"><sup>1</sup>Computational Biology Research Center, National Institute of Advanced Industrial Science and Technology (AIST) and <sup>2</sup>ERATO Minato Project, Japan Science and Technology Agency, Japan</aff>
    <author-notes>
      <corresp id="COR1"><sup>*</sup> To whom correspondence should be addressed.</corresp>
      <fn>
        <p>Associate Editor: Alex Bateman</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>2</month>
      <year>2011</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>9</day>
      <month>12</month>
      <year>2010</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>9</day>
      <month>12</month>
      <year>2010</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>27</volume>
    <issue>4</issue>
    <fpage>464</fpage>
    <lpage>470</lpage>
    <history>
      <date date-type="received">
        <day>19</day>
        <month>8</month>
        <year>2010</year>
      </date>
      <date date-type="rev-recd">
        <day>27</day>
        <month>10</month>
        <year>2010</year>
      </date>
      <date date-type="accepted">
        <day>3</day>
        <month>12</month>
        <year>2010</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2010. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2010</copyright-year>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by-nc/2.5">
        <license-p><!--CREATIVE COMMONS-->This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/2.5">http://creativecommons.org/licenses/by-nc/2.5</ext-link>), which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> Recent progress in DNA sequencing technologies calls for fast and accurate algorithms that can evaluate sequence similarity for a huge amount of short reads. Searching similar pairs from a string pool is a fundamental process of <italic>de novo</italic> genome assembly, genome-wide alignment and other important analyses.</p>
      <p><bold>Results:</bold> In this study, we designed and implemented an exact algorithm <italic>SlideSort</italic> that finds all similar pairs from a string pool in terms of edit distance. Using an efficient pattern growth algorithm, <italic>SlideSort</italic> discovers chains of common <italic>k</italic>-mers to narrow down the search. Compared to existing methods based on single <italic>k</italic>-mers, our method is more effective in reducing the number of edit distance calculations. In comparison to backtracking methods such as BWA, our method is much faster in finding remote matches, scaling easily to tens of millions of sequences. Our software has an additional function of single link clustering, which is useful in summarizing short reads for further processing.</p>
      <p><bold>Availability:</bold> Executable binary files and C++ libraries are available at <ext-link ext-link-type="uri" xlink:href="http://www.cbrc.jp/~shimizu/slidesort/">http://www.cbrc.jp/~shimizu/slidesort/</ext-link> for Linux and Windows.</p>
      <p><bold>Contact:</bold><email>slidesort@m.aist.go.jp</email>; <email>shimizu-kana@aist.go.jp</email></p>
      <p><bold>Supplementary information:</bold><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/btq677/DC1">Supplementary data</ext-link> are available at <italic>Bioinformatics</italic> online.</p>
    </abstract>
  </article-meta>
</front>
<body>
  <sec sec-type="intro" id="SEC1">
    <title>1 INTRODUCTION</title>
    <p>Due to the dramatic improvement of DNA sequencing, it is required to evaluate sequence similarities among a huge amount of fragment sequences such as short reads. We address the problem of enumerating all neighbor pairs in a large string pool in terms of edit distance, where the cost of insertion, deletion and substitution is one. Namely, given a set of <italic>n</italic> sequences of equal length ℓ, <italic>s</italic><sub>1</sub>,…, <italic>s</italic><sub><italic>n</italic></sub>, the task is to find all pairs whose edit distance is at most <italic>d</italic>,
<disp-formula id="M1"><label>(1)</label><graphic xlink:href="btq677m1"/></disp-formula>
It is conventionally called <italic>all pairs similarity search</italic>.</p>
    <p>All pairs search appears in important biological tasks. For example, it is required in finding seed matches in all pairs alignment necessary in sequence clustering (<xref ref-type="bibr" rid="B1">Abouelhoda <italic>et al.</italic>, 2004</xref>). Such alignments can then be used to detect and correct errors in short reads (<xref ref-type="bibr" rid="B13">Qu <italic>et al.</italic>, 2009</xref>). In the first step of <italic>de novo</italic> genome assembly (<xref ref-type="bibr" rid="B16">Simpson <italic>et al.</italic>, 2009</xref>; <xref ref-type="bibr" rid="B22">Zerbino and Birney, 2008</xref>), short reads are decomposed to <italic>k</italic>-mers, and suffix–prefix matches of length <italic>k</italic> − 1 are detected. In most cases, exact matches are employed due to time constraint. Using approximate matches, the length of contigs can be extended, which leads to final assembly of better quality. This problem reduces to all pairs similarity search by collecting all <italic>k</italic> − 1 prefixes and suffixes into a sequence pool. From the output, only prefix–suffix pairs are reported.</p>
    <p>Basically, most popular methods solve the search problem by either of the following two approaches or a combination of them. (i) Finding a common <italic>k</italic>-mer and verify the match (<xref ref-type="bibr" rid="B10">Lipman and Pearson, 1985</xref>; <xref ref-type="bibr" rid="B16">Simpson <italic>et al.</italic>, 2009</xref>; <xref ref-type="bibr" rid="B20">Warren <italic>et al.</italic>, 2007</xref>; <xref ref-type="bibr" rid="B21">Weese <italic>et al.</italic>, 2009</xref>; <xref ref-type="bibr" rid="B22">Zerbino and Birney, 2008</xref>). (ii) Backtracking in an index structure (i.e. suffix array and FM-index) (<xref ref-type="bibr" rid="B7">Langmead <italic>et al.</italic>, 2009</xref>; <xref ref-type="bibr" rid="B8">Li and Durbin, 2009</xref>; <xref ref-type="bibr" rid="B9">Li <italic>et al.</italic>, 2009</xref>; <xref ref-type="bibr" rid="B14">Rajasekaran <italic>et al.</italic>, 2005</xref>; <xref ref-type="bibr" rid="B15">Sagot, 1998</xref>; <xref ref-type="bibr" rid="B18">Trapnell <italic>et al.</italic>, 2009</xref>). The first type finds common <italic>k</italic>-mers in strings (i.e. seed match) and verify if two strings sharing the <italic>k</italic>-mer are neighbors indeed by extending the match with dynamic programming. It works perfectly well when the string is long enough. However, when strings are short and the threshold <italic>d</italic> is large, the length of shared <italic>k</italic>-mers falls so short that too many candidate pairs have to be verified. The second type stores the strings into an index structure, most commonly a suffix array. Then, similar strings are found by traversing nodes of the corresponding suffix tree. This approach works fine if <italic>d</italic> is small, e.g. <italic>d</italic> ≤ 2, and employed in state-of-the-art short read mapping tools such as BWA (<xref ref-type="bibr" rid="B8">Li and Durbin, 2009</xref>), bowtie (<xref ref-type="bibr" rid="B7">Langmead <italic>et al.</italic>, 2009</xref>) and SOAP2 (<xref ref-type="bibr" rid="B9">Li <italic>et al.</italic>, 2009</xref>). However, it becomes rapidly infeasible as <italic>d</italic> grows larger, mainly because the complexity is exponential to <italic>d</italic> and no effective pruning is known. ELAND and SeqMap (<xref ref-type="bibr" rid="B5">Jiang and Wong, 2008</xref>) decompose sequences into blocks and use multiple indices to store all <italic>k</italic>-concatenations of blocks. Obviously, it requires much more memory compared with BWA, which would be problematic in many scenarios. Multisorting (<xref ref-type="bibr" rid="B19">Uno, 2008</xref>) uses multiple substring matches to narrow down the search effectively, but it can find neighbors in terms of Hamming distance only.</p>
    <p>Our method termed <italic>SlideSort</italic> finds a chain of common substrings by an efficient pattern growth algorithm, which has been successfully applied in data mining tasks such as itemset mining (<xref ref-type="bibr" rid="B4">Han <italic>et al.</italic>, 2004</xref>). A pattern corresponds to a sequence of substrings. The space of all patterns is organized as a tree and systematically traversed. Our method does not rely on any index structure to avoid storage overhead. Instead, radix sort is employed to find equivalent strings during pattern growth. To demonstrate the correctness of our algorithm, the existence of a common substring chain in any neighbor pair is proved first. In addition, we deliberately avoid reporting the same pair multiple times by duplication checking. As a result, our method scales easily to 10 million sequences and is much faster than seed matching methods and suffix arrays for short sequences and large radius.</p>
    <p>The rest of this article is organized as follows. <xref ref-type="sec" rid="SEC2">Section 2</xref> introduces our algorithm. In <xref ref-type="sec" rid="SEC3">Section 3</xref>, results of computational experiments are presented. <xref ref-type="sec" rid="SEC4">Section 4</xref> concludes the article.</p>
  </sec>
  <sec sec-type="methods" id="SEC2">
    <title>2 METHOD</title>
    <p>Two similar strings share common substrings <italic>in series</italic>. Therefore, we can detect similar strings by detecting chains of common strings systematically. Before proceeding to the algorithm, let us describe fundamental properties first. Divide the interval 1,…, ℓ into <italic>b</italic> blocks of arbitrary length <italic>w</italic><sub>1</sub>,…, <italic>w</italic><sub><italic>b</italic></sub>, ∑<sub><italic>i</italic>=1</sub><sup><italic>b</italic></sup> <italic>w</italic><sub><italic>i</italic></sub> = ℓ. The starting position of each block is defined as <italic>q</italic><sub><italic>i</italic></sub> = 1 + ∑<sub><italic>j</italic>=1</sub><sup><italic>i</italic>−1</sup> <italic>w</italic><sub><italic>j</italic></sub>. The alphabet is denoted as Σ. We assume that each string in the database {<italic>s</italic><sub><italic>i</italic></sub>}<sub><italic>i</italic>=1</sub><sup><italic>n</italic></sup> consists of ℓ letters, <italic>s</italic><sub><italic>i</italic></sub> ∈ |Σ|<sup>ℓ</sup>. Given two strings <italic>s</italic>, <italic>t</italic>, <italic>s</italic> = <italic>t</italic> holds if all letters are identical. The substring from positions <italic>i</italic> to <italic>j</italic> is described as <italic>s</italic>[<italic>i</italic>, <italic>j</italic>].</p>
    <p>A <italic>pattern</italic> of length <italic>k</italic> is defined as a sequence of strings and block indices,
<disp-formula><graphic xlink:href="btq677um1"/></disp-formula>
where <bold><italic>x</italic></bold><sub><italic>i</italic></sub> ∈ |Σ|<sup><italic>w</italic><sub><italic>y</italic><sub><italic>i</italic></sub></sub></sup>, 1 ≤ <italic>y</italic><sub>1</sub> &lt; <italic>y</italic><sub>2</sub>,…, &lt; <italic>y</italic><sub><italic>k</italic></sub> ≤ <italic>b</italic>. Pattern <italic>X</italic> matches to string <italic>s</italic><sub><italic>i</italic></sub> with offset {<bold><italic>p</italic></bold> = (<italic>p</italic><sub>1</sub>,…, <italic>p</italic><sub><italic>k</italic></sub>), if
<disp-formula><graphic xlink:href="btq677um2"/></disp-formula>
All occurrences of <italic>X</italic> in the database are denoted as
<disp-formula><graphic xlink:href="btq677um3"/></disp-formula>
For convenience, an index set <italic>I</italic>(<italic>X</italic>) is defined as the set of sequences appearing in <italic>C</italic>(<italic>X</italic>). The number of sequences in <italic>I</italic>(<italic>X</italic>) is defined as |<italic>I</italic>(<italic>X</italic>)|.</p>
    <p>The relationship between neighbor pairs and patterns are characterized by the following theorem.</p>
    <statement>
      <title>T<sc>heorem</sc> 1.</title>
      <p><italic>If s</italic><sub><italic>i</italic></sub><italic>and s</italic><sub><italic>j</italic></sub><italic>of equal length</italic> ℓ <italic>are neighbors</italic>, <italic>i.e. EditDist</italic>(<italic>s</italic><sub><italic>i</italic></sub>, <italic>s</italic><sub><italic>j</italic></sub>) ≤ <italic>d</italic>, <italic>i</italic> &lt; <italic>j</italic>, <italic>there exists a pattern X of length b</italic> − <italic>d such that X matches s</italic><sub><italic>i</italic></sub> <italic>with zero offset</italic> (<italic>p</italic><sub>1</sub> = <italic>p</italic><sub>2</sub> = … = <italic>p</italic><sub><italic>b</italic>−<italic>d</italic></sub> = 0) <italic>and matches s</italic><sub><italic>j</italic></sub> <italic>with bounded offset</italic> −⌊<italic>d</italic>/2⌋ ≤ <italic>p</italic><sub><italic>k</italic></sub> ≤ ⌊<italic>d</italic>/2⌋, <italic>k</italic> = 1,…, <italic>b</italic> − <italic>d</italic>.</p>
    </statement>
    <statement>
      <title>P<sc>roof</sc>.</title>
      <p>There are multiple possible alignments of <italic>s</italic><sub><italic>i</italic></sub> and <italic>s</italic><sub><italic>j</italic></sub>. An alignment is characterized by the number of matches <italic>m</italic>, that of mismatches <italic>f</italic>, that of gaps <italic>g</italic><sub><italic>i</italic></sub> in <italic>s</italic><sub><italic>i</italic></sub> and that of gaps <italic>g</italic><sub><italic>j</italic></sub> in <italic>s</italic><sub><italic>j</italic></sub>.The length of <italic>s</italic><sub><italic>i</italic></sub> is equal to <italic>m</italic> + <italic>f</italic> + <italic>g</italic><sub><italic>j</italic></sub> and that of <italic>s</italic><sub><italic>j</italic></sub> is <italic>m</italic> + <italic>f</italic> + <italic>g</italic><sub><italic>i</italic></sub>, because any letter in <italic>s</italic><sub><italic>i</italic></sub> is aligned to either a letter in <italic>s</italic><sub><italic>j</italic></sub> or gap symbol in <italic>s</italic><sub><italic>j</italic></sub> and vice versa. Thus, we obtain <italic>g</italic><sub><italic>i</italic></sub> = <italic>g</italic><sub><italic>j</italic></sub> ≤ ⌊<italic>d</italic>/2⌋ by taking into account that the maximum number of gaps does not exceed <italic>d</italic>. Therefore, an aligned position of any letters is within a bound of ⌊<italic>d</italic>/2⌋ letters from its original position.</p>
      <p>Let us divide <italic>s</italic><sub><italic>i</italic></sub> into <italic>b</italic> blocks of length <italic>w</italic><sub>1</sub>,…, <italic>w</italic><sub><italic>b</italic></sub>. Since the number of mismatches are at most <italic>d</italic>, at least <italic>b</italic> − <italic>d</italic> blocks match exactly with their counterparts in <italic>s</italic><sub><italic>j</italic></sub> in any alignment. Also, since aligned positions are bound within ⌊<italic>d</italic>/2⌋ from their original positions, the matching counterpart of any block of <italic>s</italic><sub><italic>i</italic></sub> can be found in <italic>s</italic><sub><italic>j</italic></sub> within offset between −⌊<italic>d</italic>/2⌋ and ⌊<italic>d</italic>/2⌋. ▪</p>
    </statement>
    <p><xref ref-type="fig" rid="F1">Figure 1</xref> illustrates an example of patterns with <italic>b</italic> = 5, <italic>d</italic> = 3. This theorem implies that any neighbor pair has a chain of <italic>b</italic> − <italic>d</italic> common blocks and the corresponding blocks lie close to each other. It serves as a foundation of our algorithm presented later on.
<fig id="F1" position="float"><label>Fig. 1.</label><caption><p>An example pattern for block size 5 and edit-distance threshold 3. <italic>s</italic><sub><italic>i</italic></sub> matches to <italic>X</italic> with no offset in the first block and the third block. <italic>s</italic><sub><italic>j</italic></sub> matches to <italic>X</italic> with no offset in the first block but with −1 offset in the third block.</p></caption><graphic xlink:href="btq677f1"/></fig></p>
    <sec id="SEC2.1">
      <title>2.1 Pattern growth</title>
      <p>In our algorithm, all patterns X of |<italic>I</italic>(<italic>X</italic>)| ≥ 2 are enumerated by a recursive pattern growth algorithm. In a pattern growth algorithm, a pattern tree is constructed, where each node corresponds to a pattern (<xref ref-type="fig" rid="F2">Fig. 2</xref>). Nodes at depth <italic>k</italic> contain patterns of length <italic>k</italic>.
<fig id="F2" position="float"><label>Fig. 2.</label><caption><p>Pattern growth and pruning process of the proposed method. Patterns are enumerated by traversing the tree in depth-first manner. In each node, new elements are generated by sorting substrings in sequence pool (‘ATA’, ‘TAT’, ‘TTA’ for <italic>y</italic><sub>1</sub> = 1). Useless patterns (‘TTA’ in this case) are removed. Remaining elements are added to yield new patterns. This process is executed by recursive call until the pattern size reaches <italic>b</italic> − <italic>d</italic>.</p></caption><graphic xlink:href="btq677f2"/></fig></p>
      <p>At first, patterns of length 1 are generated as follows. For each block <italic>y</italic><sub>1</sub> = 1,…, <italic>d</italic> + 1, a string pool is made by collecting substring of {<italic>s</italic><sub><italic>i</italic></sub>}<sub><italic>i</italic>=1</sub><sup><italic>n</italic></sup> starting at <italic>q</italic><sub><italic>y</italic><sub>1</sub></sub> − ⌊<italic>d</italic>/2⌋,…, <italic>q</italic><sub><italic>y</italic><sub>1</sub></sub>+⌊<italic>d</italic>/2⌋. Applying radix sort to the string pool and scanning through the sorted result, repetition of equivalent strings can be detected (<xref ref-type="fig" rid="F3">Fig. 3</xref>). Each pattern of length 1, denoted as <italic>X</italic><sub>1</sub>, is constructed as a combination of the repeated string <bold><italic>x</italic></bold><sub>1</sub> and <italic>y</italic><sub>1</sub>,
<disp-formula><graphic xlink:href="btq677um4"/></disp-formula>
At the same time, all occurrences <italic>C</italic>(<italic>X</italic><sub>1</sub>) are recorded. If <italic>s</italic><sub><italic>i</italic></sub> matches the same pattern <italic>X</italic><sub>1</sub> by several different offsets, only the smallest offset is recorded. They form the nodes corresponding to depth 1 of the pattern tree.
<fig id="F3" position="float"><label>Fig. 3.</label><caption><p>Discovery of equivalent strings by radix sort.</p></caption><graphic xlink:href="btq677f3"/></fig></p>
      <p>Given a pattern <italic>X</italic><sub><italic>t</italic></sub> of length <italic>t</italic>, its children in the pattern tree are generated similarly as follows. For each <italic>y</italic><sub><italic>t</italic>+1</sub> = <italic>y</italic><sub><italic>t</italic></sub> + 1,…, <italic>d</italic> + <italic>t</italic> + 1, a string pool is made by collecting substrings of <italic>I</italic>(<italic>X</italic><sub><italic>t</italic></sub>) starting at <italic>q</italic><sub><italic>y</italic><sub><italic>t</italic>+1</sub></sub> − ⌊<italic>d</italic>/2⌋,…, <italic>q</italic><sub><italic>y</italic><sub><italic>t</italic>+1</sub></sub> + ⌊<italic>d</italic>/2⌋. Because the string pool is made from the occurrence set only, the size of the pool decreases sharply as a pattern grows. By sorting and scanning, a next string <italic>x</italic><sub><italic>t</italic>+1</sub> is identified and the pattern is extended as
<disp-formula><graphic xlink:href="btq677um5"/></disp-formula>
and the occurrences <italic>C</italic>(<italic>X</italic><sub><italic>t</italic></sub>) are updated to <italic>C</italic>(<italic>X</italic><sub><italic>t</italic>+1</sub>) as well.</p>
      <p>To avoid generation of useless patterns, the pattern tree is pruned as soon as the support falls below 2. Also, the tree is pruned if there is no string in <italic>I</italic>(<italic>X</italic>) that matches <italic>X</italic> with zero offset. As pattern growth proceeds in a depth-first manner, memory is reserved as a pattern is extended, and then immediately released as the pattern is contracted to visit another branch. This dynamic memory management keeps peak memory usage rather small.</p>
    </sec>
    <sec id="SEC2.2">
      <title>2.2 From patterns to pairs</title>
      <p>As implied in Theorem 1, every neighbor pair (<xref ref-type="fig" rid="F1">Fig. 1</xref>) appears in index set <italic>I</italic>(<italic>X</italic>) of at least one pattern. Since one of the pair must have zero offset, the set of eligible pairs is described as
<disp-formula><graphic xlink:href="btq677um6"/></disp-formula>
Since not all members of <italic>P</italic><sub><italic>X</italic></sub> correspond to neighbors, we have to verify if they are neighbors by actual edit-distance calculation.</p>
      <p>A problem here is that the same pair (<italic>i</italic>, <italic>j</italic>) possibly appears in the index set of many different patterns. It is also possible that pair (<italic>i</italic>, <italic>j</italic>) in the same index set is derived from different offsets. In most applications, it is desirable to ensure that no pair is reported twice. The straightforward solution of the problem is to check if a new pair is previously reported by storing all pairs, which requires huge amount of memory. We propose an alternative solution that rejects <italic>non-canonical</italic> pairs without using any extra memory as follows.</p>
      <p>A match of <italic>s</italic><sub><italic>i</italic></sub> and <italic>s</italic><sub><italic>j</italic></sub> can occur in various ways, each of which can be described as the tuple (<bold><italic>y</italic></bold>, <bold><italic>p</italic></bold>), where <bold><italic>y</italic></bold> = <italic>y</italic><sub>1</sub>,…, <italic>y</italic><sub><italic>b</italic>−<italic>d</italic></sub> describe the blocks in the pattern and <bold><italic>p</italic></bold> is the offset with which the pattern matches <italic>s</italic><sub><italic>j</italic></sub>. We define the canonical match as the one with lexicographically smallest <bold><italic>y</italic></bold> and <bold><italic>p</italic></bold>, where priority is given to <bold><italic>y</italic></bold>. For example, consider the case <italic>s</italic><sub><italic>i</italic></sub> = <italic>AATT</italic>, <italic>s</italic><sub><italic>j</italic></sub> = <italic>ATAT</italic>, <italic>d</italic> = 2 and all block widths set to 1. There are 10 different (<bold><italic>y</italic></bold>, <bold><italic>p</italic></bold>) pairs as shown in <xref ref-type="fig" rid="F4">Figure 4</xref>, where matching residues are shown in red squares. In this case, (1) is canonical. Among them, the matches with overlapping squares do not have correct alignment. We do not exclude such pairs to avoid an extra run of dynamic programming.
<fig id="F4" position="float"><label>Fig. 4.</label><caption><p>All (<bold><italic>y</italic></bold>, <bold><italic>p</italic></bold>) of <italic>s</italic><sub><italic>i</italic></sub> = <italic>AATT</italic>, <italic>s</italic><sub><italic>j</italic></sub> = <italic>ATAT</italic>. Matching residues are shown in red squares. Since the red squares overlap in (6) and (10), they do not correspond to correct alignment.</p></caption><graphic xlink:href="btq677f4"/></fig></p>
      <p>To judge if a given match (<bold><italic>y</italic></bold>, <bold><italic>p</italic></bold>) is canonical or not, it is sufficient to check if there exists another match that is lexicographically smaller. More precisely, the match represented by <bold><italic>y</italic></bold>, <bold><italic>p</italic></bold> is not canonical, iff there exists a block 1 ≤ <italic>z</italic> ≤ max(<bold><italic>y</italic></bold>), <italic>z</italic> ∉ <bold><italic>y</italic></bold> and an offset −⌊<italic>d</italic>/2⌋ ≤ <italic>r</italic> ≤ ⌊<italic>d</italic>/2⌋ such that
<disp-formula id="M2"><label>(2)</label><graphic xlink:href="btq677m2"/></disp-formula>
This canonicity check can be done in <italic>O</italic>(<italic>d</italic>ℓ) time.</p>
      <p>Pseudocode of the overall algorithm is shown in Algorithm 1. In line 18, it suffices to compute diagonal stripe of width 2<italic>d</italic> + 1 of DP matrix. Thus, the distance calculation is performed in <italic>O</italic>(<italic>d</italic>ℓ) time.</p>
    </sec>
    <sec id="SEC2.3">
      <title>2.3 Remarks</title>
      <p>With small modification, SlideSort can deal with gap opening and gap extension penalties. Define the gap open and extension cost as γ<sub><italic>o</italic></sub> and γ<sub><italic>e</italic></sub>, respectively. Denote the number of mismatches, gap opens and gap extensions as <italic>f</italic>, <italic>g</italic><sub><italic>o</italic></sub> and <italic>g</italic><sub><italic>e</italic></sub>, respectively. Then our all pairs similarity search problem is reformulated as finding pairs such that <italic>f</italic> + <italic>g</italic><sub><italic>o</italic></sub>γ<sub><italic>o</italic></sub> + <italic>g</italic><sub><italic>e</italic></sub>γ<sub><italic>e</italic></sub> ≤ <italic>d</italic>. Denote the number of gaps in each sequence as <italic>g</italic><sub><italic>i</italic></sub> and <italic>g</italic><sub><italic>j</italic></sub>. Then, <italic>g</italic><sub><italic>e</italic></sub> = <italic>g</italic><sub><italic>i</italic></sub> + <italic>g</italic><sub><italic>j</italic></sub> and <italic>g</italic><sub><italic>o</italic></sub> ≥ 2 (if <italic>g</italic><sub><italic>e</italic></sub> ≠ 0), <italic>g</italic><sub><italic>o</italic></sub> = 0 (if <italic>g</italic><sub><italic>e</italic></sub> = 0) by definition. When <italic>g</italic><sub><italic>e</italic></sub> ≠ 0, we have (<italic>g</italic><sub><italic>i</italic></sub> + <italic>g</italic><sub><italic>j</italic></sub>) γ<sub><italic>e</italic></sub> ≤ <italic>d</italic> − 2 γ<sub><italic>o</italic></sub>. Since the lengths of two sequences are equal, the number of gaps is also equal, <italic>g</italic><sub><italic>i</italic></sub> = <italic>g</italic><sub><italic>j</italic></sub>, leading to the following inequality,
<disp-formula><graphic xlink:href="btq677um7"/></disp-formula>
Therefore, the offsets <italic>p</italic><sub><italic>k</italic></sub>, for <italic>k</italic> = 1,…, <italic>b</italic> − <italic>d</italic>, are bounded by
<disp-formula id="M3"><label>(3)</label><graphic xlink:href="btq677m3"/></disp-formula>
When <italic>g</italic><sub><italic>e</italic></sub> = 0, we can find all pairs by zero offsets, hence the offset range (<xref ref-type="disp-formula" rid="M3">3</xref>) covers this case as well. Notice that the block size <italic>b</italic> must be larger than max(<italic>d</italic>, ⌊<italic>d</italic>/(γ<sub><italic>o</italic></sub> + γ<sub><italic>e</italic></sub>)⌋). This modification is effective to reduce both computation time and memory space when γ<sub><italic>o</italic></sub> and γ<sub><italic>e</italic></sub> are larger than substitution cost.</p>
      <p>It is worthwhile to notice that SlideSort can handle sequences of slightly different lengths without any essential modification. See a Supplementary Method in Supplementary file 1 for details.</p>
    </sec>
    <sec id="SEC2.4">
      <title>2.4 Complexity</title>
      <p>Denote by σ = |Σ| the alphabet size. Space complexity of SlideSort is <italic>O</italic>((<italic>b</italic> − <italic>d</italic>)<italic>dn</italic> log <italic>n</italic> + <italic>n</italic>ℓlogσ), because it requires an pointer array to describe the pattern tree, and the original strings must be retained. Denote by <italic>m</italic> the number of all pairs included in the index set <italic>I</italic>(<italic>X</italic>). Time complexity of SlideSort is <italic>O</italic>(<italic>b</italic><sup><italic>d</italic>−1</sup> <italic>d</italic><sup><italic>b</italic>−<italic>d</italic></sup> ℓ<italic>n</italic> + <italic>md</italic>ℓ), in which the first part is for sorting and the latter part is for edit-distance calculations. The time complexity depends on the effectiveness of pruning through <italic>m</italic>. The worst case of the latter part becomes <italic>O</italic>(<italic>n</italic><sup>2</sup> <italic>d</italic>ℓ) when all the input short reads are identical. In most cases, however, short reads are quite diverse and <italic>m</italic> is expected to scale much better than <italic>O</italic>(<italic>n</italic><sup>2</sup>).</p>
      <p>The all pairs similarity search problem can be solved by finding approximate non-tandem repeats in the concatenated text of length <italic>n</italic>ℓ. An enhanced suffix array can solve it with <italic>O</italic>(ℓ<sup><italic>d</italic>+1</sup> σ<sup><italic>d</italic></sup><italic>n</italic>) time and <italic>O</italic>(<italic>n</italic> log<italic>n</italic> + <italic>n</italic>ℓlogσ) space (<xref ref-type="bibr" rid="B1">Abouelhoda <italic>et al.</italic>, 2004</xref>). This time complexity is essentially achieved by producing all variants within distance <italic>d</italic> of all sequences and finding identical pairs. The difference is that the time complexity of the suffix array depends on the alphabet size and that not of SlideSort. Thus, SlideSort can be applied to large alphabets (i.e. proteins) as well.</p>
    </sec>
  </sec>
  <sec id="SEC3">
    <title>3 EXPERIMENTS</title>
    <p>From NCBI Sequence Read Archive (<ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/sra/">http://www.ncbi.nlm.nih.gov/sra/</ext-link>), we obtained two datasets: paired-end sequencing of Human HapMap (ERR001081) and whole genome shotgun bisulfite sequencing of the IMR90 cell line (SRR020262). They will be referred to as dataset 1 and 2, respectively. Sequence length of dataset 1 is 51 and that of dataset 2 is 87. Both datasets were generated by Illumina Genome Analyzer II. Reads that do not include ‘N’ were selected from the top of the original fastq files. Our algorithm was implemented by C++ and compiled by g++. All the experiments were done on a Linux PC with Intel Xeon X5570 (2.93 GHz) and 32 GB RAM. Only a single core is used in all experiments.</p>
    <p>
      <inline-graphic xlink:href="btq677i1.jpg"/>
    </p>
    <p>As competitors, BWA (<xref ref-type="bibr" rid="B8">Li and Durbin, 2009</xref>) and SeqMap (<xref ref-type="bibr" rid="B5">Jiang and Wong, 2008</xref>) are selected among many alternatives, because the two methods represent two totally different methodologies, <italic>backtracking</italic> and <italic>block combination</italic>. BWA is among the best methods using index backtracking, while SeqMap takes an ELAND-like methodology of using multiple indexes for all block combinations. SlideSort is also compared to the naive approach that calculates edit distances of all pairs. BWA and SeqMap are applied to all pairs similarity search by creating an index from all short reads and querying it with the same set of reads.</p>
    <p>Notice that both BWA and SeqMap are not originally designed for all pairs similarity search but for read mapping, which requires a larger search space. Although fair comparison is difficult between tools of different purposes, we used mapping tools as competitors, because no tool is widely available for all pairs similarity search, to our knowledge.</p>
    <p>For our method, the number <italic>b</italic> of blocks has to be determined. In the following experiments, we set <italic>b</italic> relative to the distance threshold <italic>d</italic> as <italic>b</italic> = <italic>d</italic> + <italic>k</italic>. Here, <italic>k</italic> corresponds to the pattern size. In the following experiments, we tried <italic>k</italic> = 1,…, 5 and reported the best result.</p>
    <p>The number of neighbor pairs for both datasets are shown in Supplementary Figure S1. We confirmed that both SlideSort and the naive approach reported exactly the same number of neighbor pairs, which ensures correctness of our implementation of SlideSort.</p>
    <sec id="SEC3.1">
      <title>3.1 Computation time and memory usage</title>
      <p><xref ref-type="fig" rid="F5">Figure 5</xref> plots computation time against the distance threshold <italic>d</italic>. SlideSort is consistently faster in all configurations. As the number of sequences grows and the distance threshold is increased, the difference from BWA and SeqMap becomes increasingly evident. Not all results are obtained, because of the 30 GB memory limit and 300 000 s time limit. <xref ref-type="fig" rid="F6">Figure 6</xref> compares peak memory usage of SlideSort, SeqMap and BWA. We separately measured the memory usage of the indexing step and searching step for BWA, because BWA is designed to execute those steps separately. The peak memory of BWA for the search step is the smallest in most of the configurations, while that of SlideSort is comparable or slightly better than BWA's peak indexing memory. Detailed results for 100 000 short reads are shown in <xref ref-type="table" rid="T1">Table 1</xref>.
<fig id="F5" position="float"><label>Fig. 5.</label><caption><p>Computation time on the two short read datasets. Among the four methods, ‘naive’ represents the exhaustive distance calculation.</p></caption><graphic xlink:href="btq677f5"/></fig>
<fig id="F6" position="float"><label>Fig. 6.</label><caption><p>Memory usage on the two short read datasets. BWA's memory usage is separately evaluated for the indexing step (index) and the search step (search).</p></caption><graphic xlink:href="btq677f6"/></fig>
<table-wrap id="T1" position="float"><label>Table 1.</label><caption><p>Computation time on 100 000 short reads</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1"/><th align="left" colspan="5" rowspan="1">Dataset 1<hr/></th><th align="left" colspan="5" rowspan="1">Dataset 2<hr/></th></tr><tr><th rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1">SlideSort</th><th align="left" colspan="2" rowspan="1">BWA<hr/></th><th align="left" rowspan="1" colspan="1">SeqMap</th><th align="left" rowspan="1" colspan="1">Naive</th><th align="left" rowspan="1" colspan="1">SlideSort</th><th align="left" colspan="2" rowspan="1">BWA<hr/></th><th align="left" rowspan="1" colspan="1">SeqMap</th><th align="left" rowspan="1" colspan="1">Naive</th></tr><tr><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1">Index</th><th align="left" rowspan="1" colspan="1">Search</th><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1">Index</th><th align="left" rowspan="1" colspan="1">Search</th><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/></tr></thead><tbody align="left"><tr><td align="left" rowspan="1" colspan="1">d = 1</td><td align="left" rowspan="1" colspan="1">0.2</td><td align="left" rowspan="1" colspan="1">2.34</td><td align="left" rowspan="1" colspan="1">3.25</td><td align="left" rowspan="1" colspan="1">7.68</td><td align="left" rowspan="1" colspan="1">8743.46</td><td align="left" rowspan="1" colspan="1">0.33</td><td align="left" rowspan="1" colspan="1">5.07</td><td align="left" rowspan="1" colspan="1">6.91</td><td align="left" rowspan="1" colspan="1">39.59</td><td align="left" rowspan="1" colspan="1">15 678</td></tr><tr><td align="left" rowspan="1" colspan="1">d = 3</td><td align="left" rowspan="1" colspan="1">0.85</td><td align="left" rowspan="1" colspan="1">2.37</td><td align="left" rowspan="1" colspan="1">562.63</td><td align="left" rowspan="1" colspan="1">205.26</td><td align="left" rowspan="1" colspan="1">23 796.1</td><td align="left" rowspan="1" colspan="1">1.84</td><td align="left" rowspan="1" colspan="1">5.09</td><td align="left" rowspan="1" colspan="1">1647.16</td><td align="left" rowspan="1" colspan="1">10 698.6</td><td align="left" rowspan="1" colspan="1">39 046.3</td></tr><tr><td align="left" rowspan="1" colspan="1">d = 5</td><td align="left" rowspan="1" colspan="1">6.56</td><td align="left" rowspan="1" colspan="1">2.19</td><td align="left" rowspan="1" colspan="1">19 697.67</td><td align="left" rowspan="1" colspan="1">93 115.2</td><td align="left" rowspan="1" colspan="1">38 179.5</td><td align="left" rowspan="1" colspan="1">5.56</td><td align="left" rowspan="1" colspan="1">5.08</td><td align="left" rowspan="1" colspan="1">12 876.88</td><td align="left" rowspan="1" colspan="1">&gt; 300 000</td><td align="left" rowspan="1" colspan="1">65 244.6</td></tr></tbody></table></table-wrap>
</p>
      <p>BWA is most efficient in space complexity, because its index size does not depend on the distance threshold. Instead, BWA's time complexity rapidly deteriorates as the edit-distance threshold grows due to explosion of the number of traversed nodes in backtracking. In contrast, SeqMap indexes and hashes all the combination of key blocks, which leads to huge memory usage. SlideSort is similar to SeqMap in that it considers all block combinations, but is much more memory efficient. The difference is that SlideSort is an indexing free method, which dynamically generates the pattern tree by depth-first traversal. It allows us to maintain only necessary parts of tree in memory.</p>
    </sec>
    <sec id="SEC3.2">
      <title>3.2 Effect of pattern size</title>
      <p><xref ref-type="fig" rid="F7">Figure 7</xref> investigates the influence of pattern size <italic>k</italic> on the efficiency. Except for <italic>d</italic> = 1, the best setting was around <italic>k</italic> = 2–4. Our method <italic>k</italic> = 1 roughly corresponds to the single seed approach, so this result suggests the effectiveness of using chains. Overall, the computation time was not too sensitive to the choice of <italic>k</italic>.
<fig id="F7" position="float"><label>Fig. 7.</label><caption><p>Comparison of performance of the proposed method with different <italic>k</italic> evaluated on 1 000 000 short reads.</p></caption><graphic xlink:href="btq677f7"/></fig></p>
    </sec>
    <sec id="SEC3.3">
      <title>3.3 Comparison to single seed</title>
      <p>Our algorithm employs a chain of common substrings to narrow down the search. Compared with the single seed approach that uses a <italic>k</italic>-mer to derive candidate pairs, the total length of substrings can be much larger than the <italic>k</italic>-mer without losing any neighbors. It yields higher specificity leading to a smaller number of candidate pairs. Instead of a chain, one can detect multiple <italic>k</italic>-mers and verify those pairs containing multiple matches (<xref ref-type="bibr" rid="B2">Burkhardt and Kärkkäinen, 2002</xref>). However, this approach has lower specificity in comparison to the chain of the same total length, because the matching positions of each elements of the chain are strictly localized due to Theorem 1.</p>
      <p><xref ref-type="fig" rid="F8">Figure 8</xref> compares the number of candidate pairs generated by our method and single seed (<italic>k</italic>-mer in plot). It corresponds to the number of edit-distance calculations. We have two variations of the single seed method: ‘<italic>k</italic>-mer/nonredundant’ stores previously reported pairs in memory, and does not include previously reported pairs in candidates. ‘<italic>k</italic>-mer/redundant’ does not use additional memory but counts the same pair multiple times. Here we set the length of the <italic>k</italic>-mer to ℓ/<italic>d</italic> so that no neighbors are lost. In the plot, one can see a significant reduction in the number of candidate pairs in our algorithm. Notice that the number of candidate pairs is shown in log scale. In our method, the number of candidates is minimum at the largest pattern size, because the total length of substrings is maximized and specificity becomes optimal. However, since the search space of patterns is expanded, the total computation time is not optimal in this case.
<fig id="F8" position="float"><label>Fig. 8.</label><caption><p>Comparison of number of candidate pairs. The evaluations were done on 100 000 short reads. The proposed method was examined with <italic>k</italic> = 1,…, 5. ‘Neighbor pairs’ represent the actual number of neighbor pairs in data. ‘<italic>k</italic>-mer/nonredundant’ and ‘<italic>k</italic>-mer/redundant’ represent two variants of the single seed method (see text).</p></caption><graphic xlink:href="btq677f8"/></fig></p>
    </sec>
    <sec id="SEC3.4">
      <title>3.4 Clustering analysis of short reads</title>
      <p>A main application of SlideSort is hierarchical sequence clustering, which would be used in correcting errors in short reads and preprocessing for metagenome mapping, for example. SlideSort provides an undirected graph <italic>G</italic>, where vertices represent short reads and weighted edges represent edit distances of neighbor pairs. Among hierarchical clustering algorithms, single link is most scalable (<xref ref-type="bibr" rid="B11">Manning <italic>et al.</italic>, 2008</xref>). Since the dendrogram of single link clustering is isomorphic to the minimum spanning tree (<xref ref-type="bibr" rid="B3">Gower and Ross, 1969</xref>), one can perform single link clustering via minimum spanning trees (MSTs) construction by the Kruskal or Prim algorithm (<xref ref-type="bibr" rid="B6">Kruskal, 1956</xref>; <xref ref-type="bibr" rid="B12">Prim, 1957</xref>).</p>
      <p>Since storing all edges can require a prohibitive amount of memory, we used a well-known online algorithm for building MSTs (<xref ref-type="bibr" rid="B17">Tarjan, 1983</xref>). It creates MSTs from a stream of edges, discarding unnecessary edges along the way. It essentially maintains all cycle-free connected components and, if a cycle is made by a new edge, it removes the heaviest edge from the cycle. In our experiment, the additional computation time for finding MSTs was trivially small compared with that of SlideSort finding similar pairs (<xref ref-type="table" rid="T2">Table 2</xref>). <xref ref-type="fig" rid="F9">Figure 9</xref> visualizes largest MSTs found in 10 000 000 short reads of dataset 2 with edit-distance threshold 3 by the 3D visualization tool Walrus (<ext-link ext-link-type="uri" xlink:href="http://www.caida.org/tools/visualization/walrus/">http://www.caida.org/tools/visualization/walrus/</ext-link>).
<fig id="F9" position="float"><label>Fig. 9.</label><caption><p>Visualization of large MSTs from a neighbour graph of 10 000 000 short reads with edit-distance threshold 3. The left graph shows 360 MSTs of 112 995 nodes, each of which consists of more than 100 nodes. The right graph focuses on the largest MST that consists of 6990 nodes. It is straightforward to obtain the dendrograms of single link clustering from these MSTs.</p></caption><graphic xlink:href="btq677f9"/></fig>
<table-wrap id="T2" position="float"><label>Table 2.</label><caption><p>Comparison of computation time of searching pairs and finding MSTs for two types of short read datasets with edit-distance threshold 3</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th align="left" rowspan="1" colspan="1">Number of reads</th><th align="left" colspan="2" rowspan="1">Dataset 1<hr/></th><th align="left" colspan="2" rowspan="1">Dataset 2<hr/></th></tr><tr><th rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1">Searching pairs only (s)</th><th align="left" rowspan="1" colspan="1">Finding MSTs (s)</th><th align="left" rowspan="1" colspan="1">Searching pairs only (s)</th><th align="left" rowspan="1" colspan="1">Finding MSTs (s)</th></tr></thead><tbody align="left"><tr><td align="left" rowspan="1" colspan="1">10 000</td><td align="left" rowspan="1" colspan="1">0.08</td><td align="left" rowspan="1" colspan="1">0.00</td><td align="left" rowspan="1" colspan="1">0.06</td><td align="left" rowspan="1" colspan="1">0.00</td></tr><tr><td align="left" rowspan="1" colspan="1">100 000</td><td align="left" rowspan="1" colspan="1">0.85</td><td align="left" rowspan="1" colspan="1">0.08</td><td align="left" rowspan="1" colspan="1">1.84</td><td align="left" rowspan="1" colspan="1">0.01</td></tr><tr><td align="left" rowspan="1" colspan="1">1 000 000</td><td align="left" rowspan="1" colspan="1">23.08</td><td align="left" rowspan="1" colspan="1">1.08</td><td align="left" rowspan="1" colspan="1">31.34</td><td align="left" rowspan="1" colspan="1">2.06</td></tr><tr><td align="left" rowspan="1" colspan="1">10 000 000</td><td align="left" rowspan="1" colspan="1">495.15</td><td align="left" rowspan="1" colspan="1">17.69</td><td align="left" rowspan="1" colspan="1">554.09</td><td align="left" rowspan="1" colspan="1">5.61</td></tr></tbody></table></table-wrap>
</p>
    </sec>
  </sec>
  <sec sec-type="conclusions" id="SEC4">
    <title>4 CONCLUSION</title>
    <p>In this study, we developed a novel method that enumerates all similar pairs from a string pool in terms of edit distance. The proposed method is based on a pattern growth algorithm that can effectively narrow down the search by finding chains of common <italic>k</italic>-mers. Using deliberate duplication checks, the number of edit distance calculations is reduced as much as possible. SlideSort was evaluated on large datasets of short reads. As a result, it was about 10–3000 times faster than other index-based methods. All these results demonstrate practical merits of SlideSort.</p>
    <p>One naturally arising question is if SlideSort can be used for mapping. In fact, it is possible by storing the pattern tree (<xref ref-type="fig" rid="F2">Fig. 2</xref>) in memory, and using it as an index structure. However, the index would cost too much memory for genome-scale data. What we learned from this study is that all pairs similarity search is essentially different from mapping in that one can employ pruning and dynamic memory management. Thus, all pairs similarity search is not a subproblem of mapping and deserves separate treatment.</p>
    <p>In future work, we would like to implement SlideSort with parallel computation techniques. Recent progress in hardware technology enables end-users to use many types of parallel computing scheme such as SSE and GPGPU. SlideSort would be further improved by using these technologies.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="PMC_1" content-type="local-data">
      <caption>
        <title>Supplementary Data</title>
      </caption>
      <media mimetype="text" mime-subtype="html" xlink:href="supp_27_4_464__index.html"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="pdf" xlink:href="supp_btq677_supplementary_method.pdf"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="pdf" xlink:href="supp_btq677_s_figure.pdf"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>ACKNOWLEDGEMENT</title>
    <p>The authors thank Kiyoshi Asai, Hisanori Kiryu, Takeaki Uno, Tetsuo Shibuya, Yasuo Tabei and Martin Frith for their fruitful discussions.</p>
    <p><italic>Funding</italic>: Grant-in-Aid for Young Scientists (22700319, 21680025) by JSPS; FIRST program of the Japan Society for the Promotion of Science in part.</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="B1">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Abouelhoda</surname>
            <given-names>M.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Replacing suffix trees with enhanced suffix arrays</article-title>
        <source>J. Discrete Algorithms</source>
        <year>2004</year>
        <volume>2</volume>
        <fpage>53</fpage>
        <lpage>86</lpage>
      </element-citation>
    </ref>
    <ref id="B2">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Burkhardt</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Kärkkäinen</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>One-gapped q-gram filters for levenshtein distance</article-title>
        <source>Proceedings of the 13th Symposium on Combinatorial Pattern Matching (CPM'f02)</source>
        <year>2002</year>
        <volume>2373</volume>
        <publisher-loc>Berlin, Germany</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>225</fpage>
        <lpage>234</lpage>
        <comment>of <italic>Lecture Notes in Computer Science</italic></comment>
      </element-citation>
    </ref>
    <ref id="B3">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gower</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Ross</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <article-title>Minimum spanning trees and single-linkage cluster analysis</article-title>
        <source>Appl. Stat.</source>
        <year>1969</year>
        <volume>18</volume>
        <fpage>54</fpage>
        <lpage>64</lpage>
      </element-citation>
    </ref>
    <ref id="B4">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Han</surname>
            <given-names>J.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Mining frequent patterns without candidate generation</article-title>
        <source>Data Min. Knowl. Discov.</source>
        <year>2004</year>
        <volume>8</volume>
        <fpage>53</fpage>
        <lpage>87</lpage>
      </element-citation>
    </ref>
    <ref id="B5">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Jiang</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Wong</surname>
            <given-names>W.H.</given-names>
          </name>
        </person-group>
        <article-title>Seqmap: mapping massive amount of oligonucleotides to the genome</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <fpage>2395</fpage>
        <lpage>2396</lpage>
        <pub-id pub-id-type="pmid">18697769</pub-id>
      </element-citation>
    </ref>
    <ref id="B6">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kruskal</surname>
            <given-names>J.B.</given-names>
          </name>
        </person-group>
        <article-title>On the shortest spanning subtree of a graph and the traveling salesman problem</article-title>
        <source>Proc. Am. Math. Soc.</source>
        <year>1956</year>
        <volume>7</volume>
        <fpage>48</fpage>
        <lpage>50</lpage>
      </element-citation>
    </ref>
    <ref id="B7">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Langmead</surname>
            <given-names>B.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Ultrafast and memory-efficient alignment of short dna sequences to the human genome</article-title>
        <source>Genome Biol.</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>R25</fpage>
        <pub-id pub-id-type="pmid">19261174</pub-id>
      </element-citation>
    </ref>
    <ref id="B8">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <article-title>Fast and accurate short read alignment with burrows-wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>1754</fpage>
        <lpage>1760</lpage>
        <pub-id pub-id-type="pmid">19451168</pub-id>
      </element-citation>
    </ref>
    <ref id="B9">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>R.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Soap2: an improved ultrafast tool for short read alignment</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>1966</fpage>
        <lpage>1967</lpage>
        <pub-id pub-id-type="pmid">19497933</pub-id>
      </element-citation>
    </ref>
    <ref id="B10">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lipman</surname>
            <given-names>D.J.</given-names>
          </name>
          <name>
            <surname>Pearson</surname>
            <given-names>W.R.</given-names>
          </name>
        </person-group>
        <article-title>Rapid and sensitive protein similarity searches</article-title>
        <source>Science</source>
        <year>1985</year>
        <volume>227</volume>
        <fpage>1435</fpage>
        <lpage>1441</lpage>
        <pub-id pub-id-type="pmid">2983426</pub-id>
      </element-citation>
    </ref>
    <ref id="B11">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Manning</surname>
            <given-names>C.</given-names>
          </name>
          <etal/>
        </person-group>
        <source>Introduction to Information Retrieval.</source>
        <year>2008</year>
        <publisher-loc>Cambridge, UK</publisher-loc>
        <publisher-name>Cambridge University Press</publisher-name>
      </element-citation>
    </ref>
    <ref id="B12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Prim</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <article-title>Shortest connection networks and some generalizations</article-title>
        <source>Bell Syst. Tech. J.</source>
        <year>1957</year>
        <volume>26</volume>
        <fpage>1389</fpage>
        <lpage>1401</lpage>
      </element-citation>
    </ref>
    <ref id="B13">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Qu</surname>
            <given-names>W.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Efficient frequency-based de novo short-read clustering for error trimming in next-generation sequencing</article-title>
        <source>Genome Res.</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>1309</fpage>
        <lpage>1315</lpage>
        <pub-id pub-id-type="pmid">19439514</pub-id>
      </element-citation>
    </ref>
    <ref id="B14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rajasekaran</surname>
            <given-names>S.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>High-performance exact algorithms for motif search</article-title>
        <source>J. Clin. Monit. Comput.</source>
        <year>2005</year>
        <volume>19</volume>
        <fpage>319</fpage>
        <lpage>328</lpage>
        <pub-id pub-id-type="pmid">16328946</pub-id>
      </element-citation>
    </ref>
    <ref id="B15">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Sagot</surname>
            <given-names>M.-F.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Lucchesi</surname>
            <given-names>C.L.</given-names>
          </name>
          <name>
            <surname>Moura</surname>
            <given-names>A.V.</given-names>
          </name>
        </person-group>
        <article-title>Spelling approximate repeated or common motifs using a suffix tree</article-title>
        <source>LATIN '98: Theoretical Informatics, Third Latin American Symposium</source>
        <year>1998</year>
        <volume>1380</volume>
        <publisher-loc>Berlin, Germany</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>374</fpage>
        <lpage>390</lpage>
        <comment>of <italic>Lecture Notes in Computer Science</italic></comment>
      </element-citation>
    </ref>
    <ref id="B16">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Simpson</surname>
            <given-names>J.T.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Abyss: a parallel assembler for short read sequence data</article-title>
        <source>Genome Res.</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>1117</fpage>
        <lpage>1123</lpage>
        <pub-id pub-id-type="pmid">19251739</pub-id>
      </element-citation>
    </ref>
    <ref id="B17">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Tarjan</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <article-title>Data Structures and Network Algorithms</article-title>
        <source>Society for Industrial and Applied Mathematics (SIAM)</source>
        <year>1983</year>
        <publisher-loc>Philadelphia, USA</publisher-loc>
      </element-citation>
    </ref>
    <ref id="B18">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Trapnell</surname>
            <given-names>C.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Tophat: discovering splice junctions with rna-seq</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>1105</fpage>
        <lpage>1111</lpage>
        <pub-id pub-id-type="pmid">19289445</pub-id>
      </element-citation>
    </ref>
    <ref id="B19">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Uno</surname>
            <given-names>T.</given-names>
          </name>
        </person-group>
        <article-title>An efficient algorithm for finding similar short substrings from large scale string data</article-title>
        <source>Proceedings of the 12th Pacific-Asia Conference on Advances in Knowledge Discovery and Data Mining (PAKDD'08)</source>
        <year>2008</year>
        <volume>5012</volume>
        <publisher-loc>Berlin, Germany</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>345</fpage>
        <lpage>356</lpage>
        <comment>of <italic>Lecture Notes in Computer Science</italic></comment>
      </element-citation>
    </ref>
    <ref id="B20">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Warren</surname>
            <given-names>R.L.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Assembling millions of short dna sequences using ssake</article-title>
        <source>Bioinformatics</source>
        <year>2007</year>
        <volume>23</volume>
        <fpage>500</fpage>
        <lpage>501</lpage>
        <pub-id pub-id-type="pmid">17158514</pub-id>
      </element-citation>
    </ref>
    <ref id="B21">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Weese</surname>
            <given-names>D.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Razers-fast read mapping with sensitivity control</article-title>
        <source>Genome Res.</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>1646</fpage>
        <lpage>1654</lpage>
        <pub-id pub-id-type="pmid">19592482</pub-id>
      </element-citation>
    </ref>
    <ref id="B22">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zerbino</surname>
            <given-names>D.R.</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E.</given-names>
          </name>
        </person-group>
        <article-title>Velvet: algorithms for de novo short read assembly using de bruijn graphs</article-title>
        <source>Genome Res.</source>
        <year>2008</year>
        <volume>18</volume>
        <fpage>821</fpage>
        <lpage>829</lpage>
        <pub-id pub-id-type="pmid">18349386</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
