<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Mol Biol Evol</journal-id>
    <journal-id journal-id-type="iso-abbrev">Mol. Biol. Evol</journal-id>
    <journal-id journal-id-type="hwp">molbiolevol</journal-id>
    <journal-id journal-id-type="publisher-id">molbev</journal-id>
    <journal-title-group>
      <journal-title>Molecular Biology and Evolution</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">0737-4038</issn>
    <issn pub-type="epub">1537-1719</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">2693737</article-id>
    <article-id pub-id-type="pmid">19377059</article-id>
    <article-id pub-id-type="doi">10.1093/molbev/msp077</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Articles</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>FastTree: Computing Large Minimum Evolution Trees with Profiles instead of a Distance Matrix</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Price</surname>
          <given-names>Morgan N.</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">*</xref>
        <xref ref-type="aff" rid="aff2">†</xref>
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Dehal</surname>
          <given-names>Paramvir S.</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">*</xref>
        <xref ref-type="aff" rid="aff2">†</xref>
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Arkin</surname>
          <given-names>Adam P.</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">*</xref>
        <xref ref-type="aff" rid="aff2">†</xref>
        <xref ref-type="aff" rid="aff3">‡</xref>
      </contrib>
    </contrib-group>
    <aff id="aff1"><label>*</label>Physical Biosciences Division, Lawrence Berkeley National Laboratory</aff>
    <aff id="aff2"><label>†</label>Virtual Institute of Microbial Stress and Survival, Lawrence Berkeley National Laboratory</aff>
    <aff id="aff3"><label>‡</label>Department of Bioengineering, University of California, Berkeley</aff>
    <author-notes>
      <corresp>E-mail: <email>morgannprice@yahoo.com</email>.</corresp>
      <fn>
        <p>While this paper was under review, we implemented tree-comparison in O(N) space and approximately O(N) time(<ext-link ext-link-type="uri" xlink:href="http://www.microbesonline.org/fasttree/">http://www.microbesonline.org/fasttree/</ext-link> treecmp.html). This makes it possible to use the traditional bootstrap with tens of thousands of sequences.</p>
      </fn>
      <fn>
        <p>Koichiro Tamura, Associate Editor</p>
      </fn>
    </author-notes>
    <!--Fake ppub date generated  by PMC from publisher pub-date/@pub-type='epub-ppub' -->
    <pub-date pub-type="ppub">
      <month>7</month>
      <year>2009</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>17</day>
      <month>4</month>
      <year>2009</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>17</day>
      <month>4</month>
      <year>2009</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>26</volume>
    <issue>7</issue>
    <fpage>1641</fpage>
    <lpage>1650</lpage>
    <history>
      <date date-type="accepted">
        <day>11</day>
        <month>4</month>
        <year>2009</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2009 The Authors</copyright-statement>
      <copyright-year>2009</copyright-year>
      <license license-type="open-access">
        <license-p><!--CREATIVE COMMONS-->This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/2.0/uk/">http://creativecommons.org/licenses/by-nc/2.0/uk/</ext-link>) which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p>Gene families are growing rapidly, but standard methods for inferring phylogenies do not scale to alignments with over 10,000 sequences. We present FastTree, a method for constructing large phylogenies and for estimating their reliability. Instead of storing a distance matrix, FastTree stores sequence profiles of internal nodes in the tree. FastTree uses these profiles to implement Neighbor-Joining and uses heuristics to quickly identify candidate joins. FastTree then uses nearest neighbor interchanges to reduce the length of the tree. For an alignment with <italic>N</italic> sequences, <italic>L</italic> sites, and <italic>a</italic> different characters, a distance matrix requires O(<italic>N</italic><sup>2</sup>) space and O(<italic>N</italic><sup>2</sup><italic>L</italic>) time, but FastTree requires just O(<italic>NLa</italic> + <italic>N</italic><inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx9_ht.jpg"/></inline-formula>) memory and O(<italic>N</italic><inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx9_ht.jpg"/></inline-formula>log (<italic>N</italic>)<italic>La</italic>) time. To estimate the tree's reliability, FastTree uses local bootstrapping, which gives another 100-fold speedup over a distance matrix. For example, FastTree computed a tree and support values for 158,022 distinct 16S ribosomal RNAs in 17 h and 2.4 GB of memory. Just computing pairwise Jukes–Cantor distances and storing them, without inferring a tree or bootstrapping, would require 17 h and 50 GB of memory. In simulations, FastTree was slightly more accurate than Neighbor-Joining, BIONJ, or FastME; on genuine alignments, FastTree's topologies had higher likelihoods. FastTree is available at <ext-link ext-link-type="uri" xlink:href="http://microbesonline.org/fasttree">http://microbesonline.org/fasttree</ext-link>.</p>
    </abstract>
    <kwd-group>
      <kwd>minimum evolution</kwd>
      <kwd>Neighbor-Joining</kwd>
      <kwd>large phylogenies</kwd>
    </kwd-group>
  </article-meta>
</front>
<body>
  <sec>
    <title>Introduction</title>
    <p>Inferring phylogenies from biological sequences is the fundamental method in molecular evolution and has many applications in taxonomy and for predicting structure and biological function. In general, sequences are identified as homologous and aligned, and then a phylogeny is inferred. Large alignments can be constructed efficiently, in time linear in the number of sequences, by aligning the sequences to a profile instead of to each other, as with position-specific Blast or hmmalign (<xref ref-type="bibr" rid="bib25">Schaffer et al. 2001</xref>; <ext-link ext-link-type="uri" xlink:href="http://hmmer.janelia.org/">http://hmmer.janelia.org/</ext-link>).</p>
    <p>Given an alignment, Neighbor-Joining and related minimum evolution methods are the fastest and most scalable approaches for inferring phylogenies (<xref ref-type="bibr" rid="bib24">Saitou and Nei, 1987</xref>), (<xref ref-type="bibr" rid="bib30">Studier and Keppler, 1988</xref>), (<xref ref-type="bibr" rid="bib5">Desper and Gascuel, 2002</xref>). All these methods rely on a distance matrix that stores an estimate of the evolutionary distance between each pair of sequences. Computing an entry in the distance matrix requires comparing the characters at each position in the alignment and hence requires O(<italic>L</italic>) time, where <italic>L</italic> is the number of positions. Thus, the distance matrix takes O(<italic>N</italic><sup>2</sup><italic>L</italic>) time to compute, where <italic>N</italic> is the number of sequences, and O(<italic>N</italic><sup>2</sup>) space to store.</p>
    <p>Given a distance matrix, Neighbor-Joining performs a greedy search for a tree of minimal length, according to a local estimate of the length of each branch (<xref ref-type="bibr" rid="bib14">Gascuel and Steel 2006</xref>). More specifically, Neighbor-Joining begins with the tree as a star topology, and it iteratively refines the tree by joining the best pair of nodes together, until the tree is fully resolved. Each step considers O(<italic>N</italic><sup>2</sup>) possible joins, so the standard Neighbor-Joining algorithm requires O(<italic>N</italic><sup>3</sup>) time to infer a tree from a distance matrix. This can be reduced to O(<italic>N</italic><sup>2</sup>) or O(<italic>N</italic><sup>2</sup>log<italic>N</italic>) time, either by using heuristics to consider fewer joins (<xref ref-type="bibr" rid="bib8">Elias and Lagergren 2005</xref>, <xref ref-type="bibr" rid="bib10">Evans et al. 2006</xref>) or by using additional O(<italic>N</italic><sup>2</sup>) memory (<xref ref-type="bibr" rid="bib26">Simonsen et al. 2008</xref>, <xref ref-type="bibr" rid="bib33">Zaslavsky and Tatusova 2008</xref>). FastME is another minimum evolution method that takes only O(<italic>N</italic><sup>2</sup>) time (<xref ref-type="bibr" rid="bib5">Desper and Gascuel 2002</xref>). With any of these optimized methods, the O(<italic>N</italic><sup>2</sup><italic>L</italic>) time to compute the distance matrix dominates the time.</p>
    <p>As DNA sequencing accelerates, the memory and CPU requirements of the distance matrix approach are becoming prohibitive. For example, an alignment of full- length 16S ribosomal RNAs (rRNAs) contains over 160,000 distinct sequences (<xref ref-type="bibr" rid="bib4">DeSantis et al. 2006</xref>; <ext-link ext-link-type="uri" xlink:href="http://greengenes.lbl.gov">http://greengenes.lbl.gov</ext-link>). Similarly, the MicrobesOnline database, which provides phylogenies for all protein families from prokaryotic genomes, contains protein families with over 100,000 distinct sequences (<xref ref-type="bibr" rid="bib1">Alm et al. 2005</xref>; <ext-link ext-link-type="uri" xlink:href="http://www.microbesonline.org/">http://www.microbesonline.org/</ext-link>). The distance matrix for families with 100,000–200,000 members requires 20–80 GB of memory to store (a 4-byte floating-point value for each of <italic>N</italic>(<italic>N</italic> −1)/2 pairs). Although computers with this much memory are available, the typical node in a compute cluster has an order of magnitude less memory. Furthermore, DNA sequencing technology is improving rapidly, and the distance matrix's size scales as the square of the family's size, so we expect these problems to become much more severe. Finally, most of the methods that construct a tree from a distance matrix in O(<italic>N</italic><sup>2</sup>) time, such as FastME and the exact O(<italic>N</italic><sup>2</sup>) implementations of Neighbor-Joining, require additional O(<italic>N</italic><sup>2</sup>) memory.</p>
    <p>Whatever the method used, inferred phylogenies often contain errors, and so it is important to estimate the reliability of the result (<xref ref-type="bibr" rid="bib23">Nei et al. 1998</xref>). The standard method to estimate reliability is to use the bootstrap: to resample the columns of the alignment, to rerun the method 100–1,000 times, to compare the resulting trees to each other or to the tree inferred from the full alignment, and to count the number of times that each split occurs in the resulting trees (<xref ref-type="bibr" rid="bib11">Felsenstein 1985</xref>). (A split is the two sets of leaves on either side of an internal edge.) Unfortunately, bootstrapping is a minimum of 100 times slower than the underlying phylogenetic inference, and comparing the trees to each other is also a nontrivial computation. In principle, the resampled trees could be compared with the original tree in O(<italic>N</italic><sup>2</sup>) time and O(<italic>N</italic>) space by hashing the splits in the tree. However, the tree comparison tools that we are aware of require O(<italic>N</italic><sup>3</sup>) time and O(<italic>N</italic><sup>2</sup>) space.</p>
    <p>Although building phylogenetic trees for large gene families is challenging, it is important to do so and not just to build trees for small sets of selected homologs. Analyzing all the sequences is important for taxonomy, for predicting gene function, for classifying environmental DNA sequences, and for identifying functional residues (<xref ref-type="bibr" rid="bib7">Eisen 1998</xref>, <xref ref-type="bibr" rid="bib21">Lichtarge et al. 2003</xref>, <xref ref-type="bibr" rid="bib9">Engelhardt et al. 2005</xref>, <xref ref-type="bibr" rid="bib32">von Mering et al. 2007</xref>). Furthermore, omitting sequences might change the biological interpretation of the result, especially in prokaryotes: because of horizontal gene transfer, it is difficult to know which homologs are relevant without building a tree. Finally, for Web sites that support interactive use of phylogenetic trees, it is desirable to compute trees for all the genes beforehand (<xref ref-type="bibr" rid="bib20">Li et al. 2006</xref>; <ext-link ext-link-type="uri" xlink:href="http://www.treefam.org/">http://www.treefam.org/</ext-link>; <ext-link ext-link-type="uri" xlink:href="http://www.microbesonline.org/">http://www.microbesonline.org/</ext-link>).</p>
    <sec>
      <title>Our Approach</title>
      <p>We present FastTree that uses four ideas to reduce the space and time complexity of inferring a phylogeny from an alignment (fig. 1). First, FastTree implements Neighbor-Joining by storing profiles for the internal nodes in the tree instead of storing a distance matrix. Each profile includes a frequency vector for each position, and the profile of an internal node is the weighted average of its children's profiles. For example, if we join two leaves <italic>i</italic> and <italic>j</italic>, and <italic>i</italic> has an A at a position and <italic>j</italic> has a G, then the profile of <italic>ij</italic> at that position will be 50% A and 50% G (and 0% for other characters). The intuition behind using profiles is that the average of the distances between the sequences in two subtrees <italic>A</italic> and <italic>B</italic> equals the distance between profile(<italic>A</italic>) and profile(<italic>B</italic>) because profile(<italic>A</italic>) is the average of the sequences in <italic>A</italic>. FastTree uses these profiles to compute the distances between internal nodes in the tree and also the total distance from a node to all other nodes, which is also required for Neighbor-Joining. The profiles require a total of O(<italic>NLa</italic>) space, where <italic>a</italic> is the size of the alphabet (20 for protein sequences and 4 for nucleotide sequences), instead of O(<italic>N</italic><sup>2</sup>) space for the distance matrix. However, the time required for Neighbor-Joining with exhaustive search rises from O(<italic>N</italic><sup>3</sup>) to O(<italic>N</italic><sup>3</sup><italic>La</italic>) because every distance has to be recomputed on demand in O(<italic>La</italic>) time.</p>
      <p>Second, FastTree uses a combination of previously published heuristics (<xref ref-type="bibr" rid="bib8">Elias and Lagergren 2005</xref>, <xref ref-type="bibr" rid="bib10">Evans et al. 2006</xref>) and a new “top-hits” heuristic to reduce the number of joins considered. Whereas traditional Neighbor-Joining considers O(<italic>N</italic><sup>3</sup>) possible joins and optimized variants have considered O(<italic>N</italic><sup>2</sup>) possible joins (the size of the distance matrix), FastTree considers O(<italic>N</italic><inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx9_ht.jpg"/></inline-formula>log<italic>N</italic>) possible joins. Thus, in theory, FastTree takes O(<italic>N</italic><inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx9_ht.jpg"/></inline-formula>log(<italic>N</italic>)<italic>La</italic>) time. In practice, FastTree is faster than computing the distance matrix. These heuristics require additional O(<italic>N</italic><inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx9_ht.jpg"/></inline-formula>) memory, raising the total storage requirement for FastTree to O(<italic>N</italic><italic>La</italic> +<italic>N</italic><inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx9_ht.jpg"/></inline-formula>), which is still much less than O(<italic>N</italic><sup>2</sup>).</p>
      <p>Third, FastTree refines the initial topology with nearest neighbor interchanges (NNIs). Given an unrooted tree ((<italic>A</italic>, <italic>B</italic>), (<italic>C</italic>, <italic>D</italic>)), where <italic>A</italic>, <italic>B</italic>, <italic>C</italic>, and <italic>D</italic> may be sub-trees rather than individual sequences, FastTree compares the profiles of <italic>A</italic>, <italic>B</italic>, <italic>C</italic>, and <italic>D</italic> and determines whether alternate topologies ((<italic>A</italic>, <italic>C</italic>), (<italic>B</italic>, <italic>D</italic>)) or ((<italic>A</italic>, <italic>D</italic>), (<italic>B</italic>, <italic>C</italic>)) would reduce the length of the tree. These NNIs are similar to those of FastME, although FastME uses a distance matrix (<xref ref-type="bibr" rid="bib5">Desper and Gascuel 2002</xref>). FastTree's NNIs take O(<italic>N</italic> log(<italic>N</italic>)<italic>La</italic>) additional time and O(<italic>NLa</italic>) additional space. In practice, the NNIs take much less time than computing the initial topology, and they improve the quality of the tree.</p>
      <p>Fourth, FastTree computes a local bootstrap value for each internal split ((<italic>A</italic>, <italic>B</italic>), (<italic>C</italic>, <italic>D</italic>)) by resampling the columns of the profiles and counting the fraction of resamples that support ((<italic>A</italic>, <italic>B</italic>), (<italic>C</italic>, <italic>D</italic>)) over the alternate topologies ((<italic>A</italic>, <italic>C</italic>), (<italic>B</italic>, <italic>D</italic>)) or ((<italic>A</italic>, <italic>D</italic>), (<italic>B</italic>, <italic>C</italic>)). The local bootstrap has been used for maximum likelihood trees (Kishino et al. 1990) but cannot be used with distance matrices. Computing the local bootstrap takes O(<italic>bNLa</italic>) time, where <italic>b</italic> is the number of bootstrap samples. Even with 1,000 resamples, this takes less than a minute for an alignment of over 8,000 protein sequences and 394 columns. Thus, local bootstrap gives FastTree an additional 100-fold speedup over distance matrix methods, in which the entire computation must be repeated for each sample. However, the local bootstrap should be interpreted more conservatively than the traditional bootstrap. Whereas traditional bootstrap estimates the probability that the split is correct (<xref ref-type="bibr" rid="bib6">Efron et al. 1996</xref>), local bootstrap estimates the probability that the split is correct if we assume that <italic>A</italic>, <italic>B</italic>, <italic>C</italic>, and <italic>D</italic> are subtrees of the true tree.</p>
      <p>Below, we describe FastTree in more detail. Then, we show that in realistic simulations, FastTree is slightly more accurate than other minimum evolution methods such as Neighbor-Joining, BIONJ, or FastME. On genuine alignments, FastTree topologies tend to have higher likelihoods than topologies from other minimum evolution methods, which also suggests that FastTree gives higher quality results. For both simulated and genuine alignments, FastTree's heuristics do not lead to any measurable reduction in quality. For large families, FastTree requires less CPU time and far less memory than computing and storing a distance matrix. Finally, we show that the local bootstrap is a good indicator of whether each split in the inferred topology is correct, and it is orders of magnitude faster than the traditional bootstrap. We believe that FastTree is the first practical method for computing accurate phylogenies, including support values, for alignments with tens or hundreds of thousands of sequences.</p>
    </sec>
  </sec>
  <sec sec-type="materials|methods">
    <title>Materials and Methods</title>
    <sec>
      <title>FastTree</title>
      <p>A rough outline of FastTree is shown at the bottom of <xref ref-type="fig" rid="fig1">figure 1</xref>. Before we explain how FastTree implements Neighbor-Joining, we explain how it computes distances between sequences and how it computes distances between profiles. We then explain how it computes distances between internal nodes and how it calculates the Neighbor-Joining criterion, which is used to select the best join. We also describe the heuristics that it uses to reduce the number of joins that it considers. Finally, we explain the steps after Neighbor-Joining: NNIs, the local bootstrap, and estimating the branch lengths for the final topology. For formulas, derivations, and technical details, see supplementary note 1 (<ext-link ext-link-type="uri" xlink:href="http://mbe.oxfordjournals.org/cgi/content/full/msp077/DC1">Supplementary Material</ext-link> online).</p>
      <fig id="fig1" position="float">
        <label>F<sc>IG</sc>. 1.—</label>
        <caption>
          <p>Overview of FastTree.</p>
        </caption>
        <graphic xlink:href="molbiolevolmsp077f01_ht"/>
      </fig>
      <sec>
        <title>Distances between Sequences</title>
        <p>FastTree uses both corrected and uncorrected distances. FastTree corrects the distances for multiple substitutions during NNIs, computing final branch lengths, and local bootstrap, but not during Neighbor-Joining. For nucleotide sequences, FastTree's uncorrected distance <italic>d</italic><sub>u</sub> is the fraction of positions that differ, and the corrected distance is the Jukes–Cantor distance <inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx11_ht.jpg"/></inline-formula><inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx12_ht.jpg"/></inline-formula>. For protein sequences, FastTree estimates distances by using the BLOSUM45 amino acid similarity matrix (Henikoff S and Henikoff JG 1992) and a log correction inspired by that of scoredist (<xref ref-type="bibr" rid="bib27">Sonnhammer and Hollich 2005</xref>). We scaled the BLOSUM45 similarity matrix into a dissimilarity matrix such that the average dissimilarity between each amino acid and a random amino acid is 1 if we use the nonuniform amino acid frequencies of biological sequences. The uncorrected distance <italic>d</italic><sub>u</sub> between two sequences is the average dissimilarity among nongap positions, and the corrected distance is <italic>d</italic> = −1.3 × log(1 − <italic>d</italic><sub>u</sub>). The intuitive justification is that the term within the logarithm ranges from 1 for identical sequences to an expected value of 0 for unrelated sequences, as with Jukes–Cantor distances for nucleotide sequences. For both nucleotide and protein sequences, FastTree truncates the corrected distances to a maximum of 3.0 substitutions per site, and for sequences that do not overlap because of gaps, FastTree uses this maximum distance.</p>
      </sec>
      <sec>
        <title>Distances between Profiles</title>
        <p>FastTree uses profiles to estimate the average distance between the children of two nodes. The profile distance at each position is the average dissimilarity of the characters. The uncorrected distance between two profiles is then the average of these position-wise distances, weighted by the product of the proportion of nongaps in each of the two profiles. FastTree computes the distance between two profiles in O(<italic>La</italic>) time by using the eigendecomposition of the dissimilarity matrix.</p>
        <p>The profile distance is identical to the average distance if the distances are not corrected for multiple substitutions and if the sequences do not contain gaps. For example, if we join two sequences <italic>A</italic> and <italic>B</italic> together, then the profile distance<disp-formula><inline-graphic xlink:href="molbiolevolmsp077fx1_ht.jpg"/></disp-formula>Of course, we do wish to correct for multiple substitutions, and in practice, large alignments always contain gaps. In these cases, the profile-based average becomes an approximation of the average distances used in traditional minimum evolution methods.</p>
        <p>First, consider the issue of correcting distances for multiple substitutions with a formula of the form <italic>d</italic> ∝ −log(1− <italic>d</italic><sub>u</sub>). The average corrected distance between <italic>A</italic> and <italic>BC</italic> is (<italic>d</italic>(<italic>A</italic>,<italic>B</italic>) + <italic>d</italic>(<italic>A</italic>,<italic>C</italic>))/2 or the average of two logarithms. However, FastTree cannot compute this average of logarithms from the profiles. Instead, FastTree uses the logarithm of averages. This is a close approximation if the distances are short or if the distances are similar. If the distances are large, then distances between profiles may be more accurate than averages of distances (<xref ref-type="bibr" rid="bib22">Müller et al. 2004</xref>).</p>
        <p>Second, consider what happens if the sequences contain gaps. FastTree records the fraction of gaps at each profile position, and when computing distances, FastTree weights positions by their proportion of nongaps. Traditional Neighbor-Joining implicitly weights the ungapped columns more highly. For example, consider an alignment with <italic>A</italic> = C-, <italic>B</italic> = GG, and <italic>C</italic> = CC: Δ(<italic>AB</italic>,<italic>C</italic>) = 2/3, but (<italic>d</italic><sub>u</sub>(<italic>A</italic>,<italic>B</italic>) + <italic>d</italic><sub>u</sub>(<italic>A</italic>, <italic>C</italic>))/2 = 1/2. Both approaches treat gaps as missing data, and it is not obvious which is preferable.</p>
      </sec>
      <sec>
        <title>Distances between Internal Nodes</title>
        <p>Neighbor-Joining operates on distances between internal nodes rather than on average distances between the members of subtrees. For example, after joining nodes <italic>A</italic> and <italic>B</italic>, Neighbor-Joining sets<disp-formula><inline-graphic xlink:href="molbiolevolmsp077fx2_ht.jpg"/></disp-formula>FastTree instead sets the profile of <italic>AB</italic> to <inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx13_ht.jpg"/></inline-formula>(<italic>AB</italic>) =(<inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx13_ht.jpg"/></inline-formula>(<italic>A</italic>) + <inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx13_ht.jpg"/></inline-formula>(<italic>B</italic>))/2 and computes the distance between nodes with<disp-formula><inline-graphic xlink:href="molbiolevolmsp077fx3_ht.jpg"/></disp-formula>where Δ(<italic>i</italic>,<italic>j</italic>) is the profile distance and <italic>u</italic>(<italic>i</italic>) is the “up-distance,” or the average distance of the node from its children. <italic>u</italic>(<italic>i</italic>) = 0 for leaves, and for balanced joins, <italic>u</italic>(<italic>ij</italic>) = Δ(<italic>i</italic>,<italic>j</italic>)/2. This profile-based computation gives the exact same value of <italic>d</italic><sub>u</sub>(<italic>i</italic>,<italic>j</italic>) as Neighbor-Joining after any number of joins, as long as distances are not corrected for multiple substitutions and the sequences contain no gaps.</p>
        <p>FastTree actually uses weighted joins, as in BIONJ (<xref ref-type="bibr" rid="bib13">Gascuel 1997</xref>), rather than the balanced joins. In BIONJ, the weight of each join depends on the variance of the distance between two joined nodes, which can also be computed from the profiles. Also, with weighted joins, the formula for the up-distances becomes more complicated.</p>
      </sec>
      <sec>
        <title>Calculating the Neighbor-Joining Criterion</title>
        <p>Given the distances between nodes, Neighbor-Joining selects the join that minimizes the criterion <italic>d</italic><sub>u</sub>(<italic>i</italic>,<italic>j</italic>) −<italic>r</italic>(<italic>i</italic>) −<italic>r</italic>(<italic>j</italic>), where <italic>i</italic>, <italic>j</italic>, and <italic>k</italic> are indices of active nodes that have not yet been joined, <italic>d</italic><sub>u</sub>(<italic>i</italic>,<italic>j</italic>) is the distance between nodes <italic>i</italic> and <italic>j</italic>, <italic>n</italic> is the number of active nodes, and<disp-formula><inline-graphic xlink:href="molbiolevolmsp077fx4_ht.jpg"/></disp-formula><italic>r</italic>(<italic>i</italic>) can be thought of as the average “out-distance” of <italic>i</italic> to other active nodes (although the denominator is <italic>n</italic>−2, not <italic>n</italic> − 1). Traditional Neighbor-Joining computes all <italic>N</italic> out-distances before doing any joins, which takes O(<italic>N</italic><sub>2</sub>) time, and updates each out-distance after each join, which also takes O(<italic>N</italic><sup>2</sup>) time overall. To avoid this work, FastTree computes each out-distance as needed in O(<italic>La</italic>) time by using a “total profile” <italic>T</italic> which is the average of all active nodes’ profiles, as implied by<disp-formula><inline-graphic xlink:href="molbiolevolmsp077fx5_ht.jpg"/></disp-formula>(Δ(<italic>i</italic>,<italic>i</italic>) is the average distance between children of <italic>i</italic>, including self-comparisons.) If there are gaps, then this is an approximation. FastTree computes the total profile at the beginning of Neighbor-Joining in O(<italic>NLa</italic>) time, updates it incrementally in O(<italic>La</italic>) time, and recomputes it every 200 joins to avoid round-off error.</p>
        <p>Notice that FastTree does not log correct the distances during Neighbor-Joining. We considered doing so, but it reduced FastTree's accuracy. Perhaps the profile-based out-distances become inaccurate: the out-distance is an average of both far and small values, and so the log correction of the average distance is a poor estimate of the average of the log-corrected distances.</p>
      </sec>
      <sec>
        <title>Selecting the Best Join</title>
        <p>FastTree uses heuristics to reduce the number of joins considered at each step to less than O(<italic>n</italic>). We first explain the “top-hits” heuristic. For each node, FastTree records a top-hits list: the nodes that are the closest <italic>m</italic> neighbors of that node, according to the Neighbor-Joining criterion. By default, <italic>m</italic> =<inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx9_ht.jpg"/></inline-formula>. Before doing any joins, FastTree estimates these lists for all <italic>N</italic> sequences by assuming that if <italic>A</italic> and <italic>B</italic> have similar sequences, then the top-hits lists of <italic>A</italic> and <italic>B</italic> will largely overlap. More precisely, FastTree computes the 2<italic>m</italic> top hits of <italic>A</italic>, where the factor of two is a safety factor. Then, for each node <italic>B</italic> within the top <italic>m</italic> hits of <italic>A</italic> that does not already have a top-hits list, FastTree estimates the top hits of <italic>B</italic> by comparing <italic>B</italic> to the top 2<italic>m</italic> hits of <italic>A</italic>. In theory, this takes a total of O(<italic>N</italic><sup>2</sup><italic>L</italic>/<italic>m</italic> + <italic>NmL</italic>) = O(<italic>N</italic><inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx9_ht.jpg"/></inline-formula><italic>L</italic>) time to compute and O(<italic>Nm</italic>) = O(<italic>N</italic><inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx9_ht.jpg"/></inline-formula>) space to store.</p>
        <p>FastTree restricts the top-hits heuristic to ensure that a sequence's top hits are only inferred from the top hits of a “close enough” neighbor. Because of these restrictions, it is not clear how many sequences will have O(<italic>m</italic>) close neighbors and it is not clear if the initial computation of top-hits lists will truly take O(<italic>N</italic><inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx9_ht.jpg"/></inline-formula><italic>L</italic>) time. However, for large alignments, it takes less time than computing the distance matrix, so in practice it takes less than O(<italic>N</italic><sup>2</sup><italic>L</italic>) time.</p>
        <p>FastTree maintains these top-hits lists during Neighbor-Joining. First, after a join, FastTree computes the top-hits list for the new node in O(<italic>mLa</italic>) time by comparing the node to all entries in the top-hits lists of its children. Second, after a join, some of the other nodes’ top hits may point to an inactive (joined) node. When FastTree encounters these entries, it replaces them with the active ancestor. Finally, as the algorithm progresses, the top-hits lists will gradually become shorter as joined nodes become absent from lists. Thus, FastTree periodically “refreshes” the top-hits list by comparing the new node to all other nodes and also by comparing each of the new node's top hits to each other. Each refresh takes O(<italic>nLa</italic> + <italic>m</italic><sup>2</sup><italic>La</italic>) time and ensures that the top-hits lists of O(<italic>m</italic>) other nodes are of full length and up-to-date, so FastTree performs O(<inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx9_ht.jpg"/></inline-formula>) refreshes, and they take a total of O(<italic>N</italic><inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx9_ht.jpg"/></inline-formula><italic>La</italic>) time.</p>
        <p>Besides storing the list of top hits for each node, FastTree also remembers the best-known join for each node, as in FastNJ (<xref ref-type="bibr" rid="bib8">Elias and Lagergren 2005</xref>). FastTree updates the best-known join whenever it considers a join that involves that node. For example, while computing the top hits of <italic>A</italic>, it may discover that <italic>A</italic>,<italic>B</italic> is a better join than <italic>B</italic>,best(<italic>B</italic>).</p>
        <p>Based on the best joins and the top-hits lists, FastTree can quickly select a join. First, FastTree finds the best <italic>m</italic> joins among the best-known joins of the <italic>n</italic> active nodes, without recomputing the Neighbor-Joining criterion to reflect the current out-distances. In principle, this can be implemented in O(<italic>m</italic>log <italic>N</italic>) time per join by using a priority queue. (FastTree simply sorts the entries, which adds O(<italic>N</italic>log <italic>N</italic>) time per join or O(<italic>N</italic><sup>2</sup> log <italic>N</italic>) time overall.) For those <italic>m</italic> candidates, FastTree recomputes the Neighbor-Joining criterion, which takes O(<italic>mLa</italic>) time, and selects the best. Furthermore, FastTree does a local hill-climbing search to find a better join, as in relaxed Neighbor-Joining (<xref ref-type="bibr" rid="bib10">Evans et al. 2006</xref>): given a join <italic>AB</italic>, it considers all joins <italic>AC</italic> or <italic>BD</italic>, where <italic>C</italic> is in top-hits(<italic>A</italic>) or <italic>D</italic> is in top-hits(<italic>B</italic>). This can be beneficial because the out-distances change after every join, so the best join for a node can change as well. In theory, this takes O(log<italic>n</italic>) iterations (<xref ref-type="bibr" rid="bib10">Evans et al. 2006</xref>), O(<italic>m</italic>log(<italic>n</italic>)<italic>La</italic>) time per join, or O(<italic>N</italic><inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx9_ht.jpg"/></inline-formula>log(<italic>N</italic>)<italic>La</italic>) time overall. Thus, it takes FastTree a total of O(<italic>N</italic><inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx9_ht.jpg"/></inline-formula>log(<italic>N</italic>)<italic>La</italic>) time to maintain the top-hits lists and to select all the joins.</p>
      </sec>
      <sec>
        <title>Nearest Neighbor Interchanges</title>
        <p>After FastTree constructs an initial tree with Neighbor-Joining, it uses NNIs to improve the tree topology. During each round, FastTree tests and possibly rearranges each split in the tree, and it recomputes the profile of each internal node. The profiles can change even if the topology does not change because FastTree recomputes the weighting of the joins.</p>
        <p>By default, FastTree does log<sub>2</sub>(<italic>N</italic>) + 1 rounds of NNIs. We chose a fixed number of rounds, instead of iterating until no more NNIs occur, to ensure fast completion. We chose roughly log<sub>2</sub>(<italic>N</italic>) rounds so that, on a balanced topology, a misplaced node could migrate all the way across the tree.</p>
        <p>The minimum evolution criterion prefers ((<italic>A</italic>, <italic>B</italic>), (<italic>C</italic>, <italic>D</italic>)) over alternate topologies ((<italic>A</italic>, <italic>C</italic>), (<italic>B</italic>, <italic>D</italic>)) or ((<italic>A</italic>, <italic>D</italic>), (<italic>B</italic>, <italic>C</italic>)) if <italic>d</italic>(<italic>A</italic>,<italic>B</italic>) + <italic>d</italic>(<italic>C</italic>,<italic>D</italic>) &lt; <italic>d</italic>(<italic>A</italic>,<italic>C</italic>) + <italic>d</italic>(<italic>B</italic>,<italic>D</italic>) and <italic>d</italic>(<italic>A</italic>,<italic>B</italic>) + <italic>d</italic>(<italic>C</italic>,<italic>D</italic>) &lt; <italic>d</italic>(<italic>A</italic>,<italic>D</italic>) + <italic>d</italic>(<italic>B</italic>,<italic>C</italic>). Here, FastTree uses log-corrected profile distances, rather than distances between nodes. The profile distances do not account for the distances within the nodes, but this does not affect the minimum evolution criterion as it increases all distances <italic>d</italic>(<italic>A</italic>, ·) by the same amount.</p>
        <p>For larger topologies, FastTree must compute profiles for additional subtrees before doing this computation. For example, consider the topology ((<italic>A</italic>, (<italic>B</italic>, <italic>C</italic>)), <italic>D</italic>, <italic>E</italic>). After Neighbor-Joining, FastTree has profiles for the internal nodes <italic>BC</italic> and <italic>ABC</italic> as well as for the leaves, but to test the split <italic>BC</italic> versus <italic>ADE</italic> requires the profile for <italic>DE</italic>. FastTree computes the profile for <italic>DE</italic> by doing a weighted join of <italic>D</italic> and <italic>E</italic>, using the weighting of BIONJ for a 4-leaf tree (<xref ref-type="bibr" rid="bib13">Gascuel 1997</xref>). FastTree stores these additional profiles along the path to the root and reuses them when possible. (FastTree computes an unrooted tree but stores it as a rooted tree.) To ensure that a round of NNIs takes O(<italic>NLa</italic>) time and at most O(<italic>NLa</italic>) additional space, FastTree visits nodes in postorder (it visits children before their parents).</p>
      </sec>
      <sec>
        <title>Local Bootstrap</title>
        <p>To estimate the support for each split, FastTree resamples the alignment's columns with Knuth's 2002 random number generator (<ext-link ext-link-type="uri" xlink:href="http://www-cs-faculty.stanford.edu/knuth/programs/rng.c">http://www-cs-faculty.stanford.edu/knuth/programs/rng.c</ext-link>). FastTree counts the fraction of resamples that support a split over the two potential NNIs around that node, much as it does while using NNIs to improve the topology. If a resample's minimum evolution criterion gives a tie, then that resample is counted as not supporting the split.</p>
      </sec>
      <sec>
        <title>Branch Lengths</title>
        <p>Once the topology is complete, FastTree computes branch lengths, with<disp-formula><inline-graphic xlink:href="molbiolevolmsp077fx6_ht.jpg"/></disp-formula>for internal branches and<disp-formula><inline-graphic xlink:href="molbiolevolmsp077fx7_ht.jpg"/></disp-formula>for the branch leading to leaf <italic>A</italic>, where <italic>d</italic> are log-corrected profile distances.</p>
      </sec>
      <sec>
        <title>Unique Sequences</title>
        <p>Large alignments often contain many sequences that are exactly identical to each other (<xref ref-type="bibr" rid="bib18">Howe et al. 2002</xref>). Before inferring a tree, FastTree uses hashing to quickly identify redundant sequences. It constructs a tree for the unique subset of sequences and then creates multifurcating nodes, without support values, as parents of the redundant sequences.</p>
      </sec>
    </sec>
    <sec>
      <title>Testing FastTree</title>
      <sec>
        <title>Sources of Alignments</title>
        <p>We obtained sequences of members of Clusters of Orthologous Groups (COG) gene families (Tatusov et al. 2001) and members of Pfam PF00005 (<xref ref-type="bibr" rid="bib12">Finn et al. 2006</xref>) from the fall 2007 release of the MicrobesOnline database (<ext-link ext-link-type="uri" xlink:href="http://www.microbesonline.org/">http://www.microbesonline.org/</ext-link>). We aligned the sequences to the family's profile, using reverse position-specific Blast for the COG alignment (<xref ref-type="bibr" rid="bib25">Schaffer et al. 2001</xref>) and hmmalign for the PF00005 alignment (<ext-link ext-link-type="uri" xlink:href="http://hmmer.janelia.org/">http://hmmer.janelia.org/</ext-link>). As the profiles only include positions that are present in many members of the family, these alignments do not contain all positions from the original sequences. The 16S rRNA alignment is from greengenes and is trimmed with the greengenes mask (<xref ref-type="bibr" rid="bib4">DeSantis et al. 2006</xref>; <ext-link ext-link-type="uri" xlink:href="http://greengenes.lbl.gov">http://greengenes.lbl.gov</ext-link>).</p>
        <p>To simulate alignments with realistic phylogenies and realistic gaps, we used the COG alignments. In each simulation, we selected the desired number of sequences from a COG alignment, we removed positions that were over 25% gaps, we estimated a topology and branch lengths with PhyML (<xref ref-type="bibr" rid="bib15">Guindon and Gascuel 2003</xref>), we estimated evolutionary rates across sites with PHYLIP's proml (<ext-link ext-link-type="uri" xlink:href="http://evolution.genetics.washington.edu/phylip.htm">http://evolution.genetics.washington.edu/phylip.htm</ext-link>), we simulated sequences with Rose (<xref ref-type="bibr" rid="bib29">Stoye et al. 1998</xref>), and we reintroduced the gaps from the original alignment. For simulations of 5,000 sequences, we used FastTree instead of PhyML and we assigned evolutionary rates at random. For <italic>N</italic> = 10, we simulated 3,100 alignments (10 independent runs per family); for <italic>N</italic> = 50, we simulated 3,099 alignments; for <italic>N</italic> = 250, we simulated 308 alignments; for <italic>N</italic> = 1,250, we simulated only 92 alignments because some PhyML jobs did not complete, and for <italic>N</italic> = 5,000, we simulated 7 alignments, as only seven families contained enough nonredundant sequences. See supplementary note 2 (<ext-link ext-link-type="uri" xlink:href="http://mbe.oxfordjournals.org/cgi/content/full/msp077/DC1">Supplementary Material</ext-link> online) for technical details.</p>
      </sec>
      <sec>
        <title>CPU Timings</title>
        <p>All programs used a single thread of execution. We used a computer with two dual-core 2.6-GHz AMD Opteron processors and 32 GB of RAM. However, for the two long-running maximum likelihood jobs in <xref ref-type="table" rid="tbl6">table 6</xref>, we used a computer with a 2.4-GHz Intel Q6600 quad-core processor and 8 GB of RAM. The two machines have similar performance (about 20% different for FastTree).</p>
        <p>To estimate performance on large alignments, we extrapolated from the largest feasible alignment for that method and its theoretical complexity. Inferring a tree from a distance matrix requires O(<italic>N</italic><sup>2</sup>) space and either O(<italic>N</italic><sup>2</sup>) time (FastME and RapidNJ; <xref ref-type="bibr" rid="bib26">Simonsen et al. 2008</xref>), O(<italic>N</italic><sup>2</sup>log<italic>N</italic>) time (Clearcut), or O(<italic>N</italic><sup>3</sup>) time (QuickTree and BIONJ). Computing bootstrap values from resampled trees with PHYLIP's consense or with QuickTree's built-in bootstrap requires O(<italic>N</italic><sup>2</sup>) space and O(<italic>N</italic><sup>3</sup>) time. For QuickTree, which identifies and removes duplicate sequences, we used the number of unique sequences rather than the total number.</p>
      </sec>
    </sec>
  </sec>
  <sec sec-type="results">
    <title>Results</title>
    <sec>
      <title>Topological Accuracy in Simulations</title>
      <p>We tested FastTree and other methods for inferring phylogenies on simulated protein alignments with realistic topologies, realistic gaps, varying evolutionary rates across sites, and between 10 and 5,000 sequences. The simulated alignments ranged from 64 to 1,009 positions (median 304), with 9% gaps, and on average, pairs of sequences within these alignments were 33% identical. For each alignment and for each method, we counted the proportion of splits that were correctly inferred.</p>
      <p>As shown in <xref ref-type="table" rid="tbl1">table 1</xref>, FastTree was significantly more accurate than other minimum evolution methods but was 1–2% less accurate than PhyML, a maximum likelihood method (<xref ref-type="bibr" rid="bib15">Guindon and Gascuel 2003</xref>). We will show that FastTree scales to far larger alignments than current maximum likelihood methods can handle. Furthermore, most of the splits that disagree between minimum evolution and maximum likelihood trees are poorly supported (<xref ref-type="bibr" rid="bib23">Nei et al. 1998</xref>). This is true in our simulations as well, even for the splits that PhyML inferred correctly but FastTree missed (data not shown). Thus, the practical effect of these differences may be much less than 1–2%.</p>
      <table-wrap id="tbl1" position="float">
        <label>Table 1</label>
        <caption>
          <p>Topological Accuracy of Tree-Building Methods on Simulated Protein Alignments with Gaps</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="center" colspan="6" rowspan="1">Topological Accuracy<hr/></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Method</td>
              <td align="center" rowspan="1" colspan="1">Distances</td>
              <td align="center" rowspan="1" colspan="1"><italic>n</italic> = 10</td>
              <td align="center" rowspan="1" colspan="1"><italic>n</italic> = 50</td>
              <td align="center" rowspan="1" colspan="1"><italic>n</italic> = 250</td>
              <td align="center" rowspan="1" colspan="1"><italic>n</italic> = 1,250</td>
              <td align="center" rowspan="1" colspan="1"><italic>n</italic> = 5,000</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">PhyML</td>
              <td rowspan="1" colspan="1">JTT</td>
              <td align="char" char="." rowspan="1" colspan="1">0.744<xref ref-type="table-fn" rid="tblfn1">a</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.771<xref ref-type="table-fn" rid="tblfn1">a</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.817<xref ref-type="table-fn" rid="tblfn1">a</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.801<xref ref-type="table-fn" rid="tblfn1">a</xref></td>
              <td align="center" rowspan="1" colspan="1">—</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">FastTree</td>
              <td rowspan="1" colspan="1">Log-corrected</td>
              <td align="char" char="." rowspan="1" colspan="1">0.724<xref ref-type="table-fn" rid="tblfn2">b</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.763<xref ref-type="table-fn" rid="tblfn2">b</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.797<xref ref-type="table-fn" rid="tblfn2">b</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.778<xref ref-type="table-fn" rid="tblfn2">b</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.763<xref ref-type="table-fn" rid="tblfn2">b</xref></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">FastME</td>
              <td rowspan="1" colspan="1">Log-corrected</td>
              <td align="char" char="." rowspan="1" colspan="1">0.716<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.754<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.796<xref ref-type="table-fn" rid="tblfn2">b</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.777<xref ref-type="table-fn" rid="tblfn2">b</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.753<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BIONJ</td>
              <td rowspan="1" colspan="1">Log-corrected</td>
              <td align="char" char="." rowspan="1" colspan="1">0.725<xref ref-type="table-fn" rid="tblfn2">b</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.754<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.766<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.730<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.723<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BIONJ</td>
              <td rowspan="1" colspan="1">JTT</td>
              <td align="char" char="." rowspan="1" colspan="1">0.701<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.758<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.777<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.737<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.731<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BIONJ</td>
              <td rowspan="1" colspan="1">JTT + Γ</td>
              <td align="char" char="." rowspan="1" colspan="1">0.567<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.625<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.737<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.697<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="center" rowspan="1" colspan="1">—</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">QuickTree</td>
              <td rowspan="1" colspan="1">Log-corrected</td>
              <td align="char" char="." rowspan="1" colspan="1">0.716<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.746<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.760<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.726<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.716<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">QuickTree</td>
              <td rowspan="1" colspan="1">%Different</td>
              <td align="char" char="." rowspan="1" colspan="1">0.673<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.678<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.699<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.672<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.655<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Clearcut</td>
              <td rowspan="1" colspan="1">Log-corrected</td>
              <td align="char" char="." rowspan="1" colspan="1">0.682<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.733<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.755<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.723<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">0.715<xref ref-type="table-fn" rid="tblfn3">c</xref></td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <label>a</label>
            <p>Significantly more accurate than FastTree (<italic>P</italic> &lt; 0.01, paired <italic>t</italic>-test)</p>
          </fn>
          <fn id="tblfn2">
            <label>b</label>
            <p>Not significantly different from FastTree (<italic>P</italic> &gt; 0.01, paired <italic>t</italic>-test)</p>
          </fn>
          <fn id="tblfn3">
            <label>c</label>
            <p>Significantly less accurate than FastTree (<italic>P</italic> &lt; 0.01, paired <italic>t</italic>-test)</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>After FastTree, the next best method was FastME, which like FastTree uses NNIs according to the minimum evolution criterion (<xref ref-type="bibr" rid="bib5">Desper and Gascuel 2002</xref>). Depending on the number of sequences, FastTree was slightly but significantly more accurate than FastME, or the two methods were tied. FastTree was up to 4% more accurate than BIONJ, a weighted variant of Neighbor-Joining (<xref ref-type="bibr" rid="bib13">Gascuel 1997</xref>), when run with FastTree's log-corrected distances. BIONJ with log-corrected distances was about as accurate as BIONJ with maximum likelihood distances from PHYLIP's protdist, so FastTree's distance measure is adequate. Maximum likelihood distances that were estimated using a model with gamma-distributed rates gave poor results. FastTree was 1–5% more accurate than QuickTree, an implementation of traditional Neighbor-Joining (<xref ref-type="bibr" rid="bib18">Howe et al. 2002</xref>), and 4–6% more accurate than Clearcut, an implementation of relaxed Neighbor-Joining (<xref ref-type="bibr" rid="bib10">Evans et al. 2006</xref>). Clearcut is more scalable than the other distance matrix methods but not as scalable as FastTree (see below).</p>
      <p>We obtained similar results with a standard set of simulations of ungapped nucleotide alignments (<xref ref-type="bibr" rid="bib5">Desper and Gascuel 2002</xref>) or with ungapped protein simulations (<ext-link ext-link-type="uri" xlink:href="http://mbe.oxfordjournals.org/cgi/content/full/msp077/DC1">supplementary tables 1</ext-link> and <ext-link ext-link-type="uri" xlink:href="http://mbe.oxfordjournals.org/cgi/content/full/msp077/DC1">2</ext-link>; <ext-link ext-link-type="uri" xlink:href="http://mbe.oxfordjournals.org/cgi/content/full/msp077/DC1">Supplementary Material</ext-link> online). Furthermore, FastTree was more accurate than BIONJ regardless of how strongly the tree deviated from the molecular clock or how divergent the sequences were (<ext-link ext-link-type="uri" xlink:href="http://mbe.oxfordjournals.org/cgi/content/full/msp077/DC1">Supplementary fig. 1</ext-link>; <ext-link ext-link-type="uri" xlink:href="http://mbe.oxfordjournals.org/cgi/content/full/msp077/DC1">Supplementary Material</ext-link> online).</p>
      <table-wrap id="tbl2" position="float">
        <label>Table 2</label>
        <caption>
          <p>The Topological Accuracy of Variants of FastTree on Simulated Protein Alignments with Gaps</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="center" colspan="3" rowspan="1">Topological Accuracy<hr/></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Method</td>
              <td align="center" rowspan="1" colspan="1"><italic>N</italic> = 250</td>
              <td align="center" rowspan="1" colspan="1"><italic>N</italic> = 1, 250</td>
              <td align="center" rowspan="1" colspan="1"><italic>N</italic> = 5, 000</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">FastTree, default settings</td>
              <td align="char" char="." rowspan="1" colspan="1">0.797</td>
              <td align="char" char="." rowspan="1" colspan="1">0.778</td>
              <td align="char" char="." rowspan="1" colspan="1">0.763</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">FastTree + extra NNI (20 rounds)</td>
              <td align="char" char="." rowspan="1" colspan="1">0.797</td>
              <td align="char" char="." rowspan="1" colspan="1">0.778</td>
              <td align="char" char="." rowspan="1" colspan="1">0.763</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">FastTree's Neighbor-Joining (no NNI)</td>
              <td align="char" char="." rowspan="1" colspan="1">0.734</td>
              <td align="char" char="." rowspan="1" colspan="1">0.702</td>
              <td align="char" char="." rowspan="1" colspan="1">0.698</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">FastTree, exhaustive search, no NNI</td>
              <td align="char" char="." rowspan="1" colspan="1">0.733</td>
              <td align="char" char="." rowspan="1" colspan="1">0.701</td>
              <td align="center" rowspan="1" colspan="1">—</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BIONJ, uncorrected distances</td>
              <td align="char" char="." rowspan="1" colspan="1">0.731</td>
              <td align="char" char="." rowspan="1" colspan="1">0.699</td>
              <td align="char" char="." rowspan="1" colspan="1">0.694</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BIONJ, log-corrected distances</td>
              <td align="char" char="." rowspan="1" colspan="1">0.766</td>
              <td align="char" char="." rowspan="1" colspan="1">0.730</td>
              <td align="char" char="." rowspan="1" colspan="1">0.723</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>These simulations also confirm that topologies can be inferred even when there are many more sequences than sites (<xref ref-type="bibr" rid="bib2">Bininda-Emonds et al. 2001</xref>). The alignments with 5,000 sequences contained just 197–384 sites, yet FastTree identified 76.3% of the splits correctly.</p>
    </sec>
    <sec>
      <title>Effectiveness of FastTree's Approximations and Heuristics</title>
      <p>The simulations also let us test the internals of FastTree. First, FastTree's Neighbor-Joining phase should give roughly the same results as BIONJ with uncorrected distances. In practice, the two methods had very similar accuracies, as did FastTree's Neighbor-Joining with exhaustive search (<xref ref-type="table" rid="tbl2">table 2</xref>). Thus, FastTree's accuracy was not affected by its approximations to handle gaps or by its heuristics to reduce the number of joins considered. Heuristic search was also over 100 times faster: for an alignment of 1,250 proteins with 338 positions, the Neighbor-Joining phase of FastTree took 1,551 s with exhaustive search but only 8 s with heuristic search.</p>
      <p>Second, using uncorrected distances only reduced the accuracy of BIONJ by around 3% (<xref ref-type="table" rid="tbl2">table 2</xref>). This is consistent with a previous simulation study of realistic topologies and protein alignments (<xref ref-type="bibr" rid="bib17">Hollich et al. 2005</xref>). Because using uncorrected distances leads to relatively few errors, FastTree can correct these errors by doing a few rounds of NNIs. Adding more rounds of NNIs did not increase accuracy (<xref ref-type="table" rid="tbl2">table 2</xref>).</p>
    </sec>
    <sec>
      <title>Quality of Trees for Genuine Alignments</title>
      <p>To test the quality of FastTree's results on genuine protein families, we inferred topologies for alignments of 500 randomly selected sequences from large COGs. These alignments ranged from 65 to 1,009 positions, and within each alignment, the average pair of sequences was 27% identical. To quantify the quality of each topology, we used PhyML to optimize the branch lengths and compute the log likelihood. We ran PhyML with the Jones, Taylor, and Thorton (JTT) model of amino acid substitution and four categories of gamma-distributed rates.</p>
      <p>In <xref ref-type="table" rid="tbl3">table 3</xref>, we report the average difference in log likelihood between that method's trees and FastTree's trees. The methods are sorted by the average difference. All the distance matrix methods gave significantly worse average likelihoods than FastTree (paired <italic>t</italic>-test, all <italic>P</italic> &lt; 1<sup>0</sup> −20). Furthermore, as in the simulations, FastTree's approximations and heuristics did not reduce the quality of the trees (<ext-link ext-link-type="uri" xlink:href="http://mbe.oxfordjournals.org/cgi/content/full/msp077/DC1">supplementary table 3</ext-link>; <ext-link ext-link-type="uri" xlink:href="http://mbe.oxfordjournals.org/cgi/content/full/msp077/DC1">Supplementary Material</ext-link> online). Overall, we found that for these genuine alignments, FastTree's topologies were of high quality.</p>
      <table-wrap id="tbl3" position="float">
        <label>Table 3</label>
        <caption>
          <p>The Relative Log Likelihoods of Topologies Inferred for 310 Genuine Protein Alignments of 500 Sequences Each</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td rowspan="1" colspan="1">Method</td>
              <td align="center" rowspan="1" colspan="1">Distances/model</td>
              <td align="center" rowspan="1" colspan="1">Average log likelihood</td>
              <td align="center" rowspan="1" colspan="1">Lower likelihood than FastTree(%)</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">PhyML/FastTree<xref ref-type="table-fn" rid="tblfn4">a</xref></td>
              <td rowspan="1" colspan="1">JTT + Γ<sub>4</sub><xref ref-type="table-fn" rid="tblfn5">b</xref></td>
              <td align="char" char="." rowspan="1" colspan="1">440.7</td>
              <td align="char" char="." rowspan="1" colspan="1">0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">FastTree</td>
              <td rowspan="1" colspan="1">Log-corrected</td>
              <td align="char" char="." rowspan="1" colspan="1">0.0</td>
              <td align="center" rowspan="1" colspan="1">—</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">FastME</td>
              <td rowspan="1" colspan="1">Log-corrected</td>
              <td align="char" char="." rowspan="1" colspan="1">– 165.2</td>
              <td align="char" char="." rowspan="1" colspan="1">86</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BIONJ</td>
              <td rowspan="1" colspan="1">JTT</td>
              <td align="char" char="." rowspan="1" colspan="1">– 404.3</td>
              <td align="char" char="." rowspan="1" colspan="1">95</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BIONJ</td>
              <td rowspan="1" colspan="1">Log-corrected</td>
              <td align="char" char="." rowspan="1" colspan="1">– 426.1</td>
              <td align="char" char="." rowspan="1" colspan="1">&gt; 99</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">QuickTree</td>
              <td rowspan="1" colspan="1">Log-corrected</td>
              <td align="char" char="." rowspan="1" colspan="1">– 495.3</td>
              <td align="char" char="." rowspan="1" colspan="1">&gt; 99</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Clearcut</td>
              <td rowspan="1" colspan="1">Log-corrected</td>
              <td align="char" char="." rowspan="1" colspan="1">– 532.2</td>
              <td align="char" char="." rowspan="1" colspan="1">99</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">QuickTree</td>
              <td rowspan="1" colspan="1">%Different</td>
              <td align="char" char="." rowspan="1" colspan="1">– 667.0</td>
              <td align="char" char="." rowspan="1" colspan="1">100</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BIONJ</td>
              <td rowspan="1" colspan="1">JTT + Γ</td>
              <td align="char" char="." rowspan="1" colspan="1">– 1,576.1</td>
              <td align="char" char="." rowspan="1" colspan="1">99</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn4">
            <label>a</label>
            <p>PhyML 3 with FastTree as the starting tree.</p>
          </fn>
          <fn id="tblfn5">
            <label>b</label>
            <p>Γ<sub>4</sub> means four categories of sites with gamma-distributed rates.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>We also tested the quality of FastTree trees for sets of 500 nonredundant sequences from a large 16S rRNA alignment (<xref ref-type="bibr" rid="bib4">DeSantis et al. 2006</xref>; <ext-link ext-link-type="uri" xlink:href="http://greengenes.lbl.gov">http://greengenes.lbl.gov</ext-link>). To quantify the quality of each topology, we used PhyML with the Hasegawa–Kishino–Yano 85 model, which accounts for the higher rate of transitions over transversions, and four categories of gamma-distributed rates. FastTree found topologies with higher likelihoods than most of the distance matrix methods (<xref ref-type="table" rid="tbl4">table 4</xref>). FastME did outperform FastTree slightly if given maximum likelihood distances that account for the higher rate of transitions than transversions. Distinguishing transitions from transversions might further improve FastTree's topologies.</p>
      <table-wrap id="tbl4" position="float">
        <label>Table 4</label>
        <caption>
          <p>The Relative Log Likelihoods of Topologies Inferred for 100 Genuine 16S rRNA Alignments of 500 Sequences Each</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td rowspan="1" colspan="1">Method</td>
              <td align="center" rowspan="1" colspan="1">Distances/model</td>
              <td align="center" rowspan="1" colspan="1">Average log likelihood</td>
              <td align="center" rowspan="1" colspan="1">Lower likelihood than FastTree(%)</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">PhyML</td>
              <td rowspan="1" colspan="1">HKY85 + Γ<sub>4</sub></td>
              <td align="char" char="." rowspan="1" colspan="1">510.4</td>
              <td align="char" char="." rowspan="1" colspan="1">0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">PhyML</td>
              <td rowspan="1" colspan="1">HKY85</td>
              <td align="char" char="." rowspan="1" colspan="1">358.4</td>
              <td align="char" char="." rowspan="1" colspan="1">5</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">FastME</td>
              <td rowspan="1" colspan="1">F84 + Γ</td>
              <td align="char" char="." rowspan="1" colspan="1">59.9</td>
              <td align="char" char="." rowspan="1" colspan="1">34</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">FastTree</td>
              <td rowspan="1" colspan="1">Jukes–Cantor</td>
              <td align="char" char="." rowspan="1" colspan="1">0.0</td>
              <td align="center" rowspan="1" colspan="1">—</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">FastME</td>
              <td rowspan="1" colspan="1">Kimura</td>
              <td align="char" char="." rowspan="1" colspan="1">– 7.4</td>
              <td align="char" char="." rowspan="1" colspan="1">53</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">FastME</td>
              <td rowspan="1" colspan="1">Jukes–Cantor</td>
              <td align="char" char="." rowspan="1" colspan="1">– 71.7</td>
              <td align="char" char="." rowspan="1" colspan="1">70</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BIONJ</td>
              <td rowspan="1" colspan="1">F84 + Γ</td>
              <td align="char" char="." rowspan="1" colspan="1">– 749.1</td>
              <td align="char" char="." rowspan="1" colspan="1">100</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BIONJ</td>
              <td rowspan="1" colspan="1">Kimura</td>
              <td align="char" char="." rowspan="1" colspan="1">– 781.0</td>
              <td align="char" char="." rowspan="1" colspan="1">100</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BIONJ</td>
              <td rowspan="1" colspan="1">Jukes–Cantor</td>
              <td align="char" char="." rowspan="1" colspan="1">– 843.9</td>
              <td align="char" char="." rowspan="1" colspan="1">100</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">QuickTree</td>
              <td rowspan="1" colspan="1">F84 + Γ</td>
              <td align="char" char="." rowspan="1" colspan="1">– 878.8</td>
              <td align="char" char="." rowspan="1" colspan="1">100</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Clearcut</td>
              <td rowspan="1" colspan="1">F84 + Γ</td>
              <td align="char" char="." rowspan="1" colspan="1">– 905.1</td>
              <td align="char" char="." rowspan="1" colspan="1">100</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">QuickTree</td>
              <td rowspan="1" colspan="1">Jukes–Cantor</td>
              <td align="char" char="." rowspan="1" colspan="1">– 941.1</td>
              <td align="char" char="." rowspan="1" colspan="1">100</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Clearcut</td>
              <td rowspan="1" colspan="1">Jukes–Cantor</td>
              <td align="char" char="." rowspan="1" colspan="1">– 982.3</td>
              <td align="char" char="." rowspan="1" colspan="1">100</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn>
            <p>N<sc>OTE</sc>.—HKY, Hasegawa–Kishino–Yano.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>CPU Time and Memory Required to Infer Trees</title>
      <p>We tested FastTree and other methods on a protein alignment from the COG database (COG2814), a domain alignment from PFam (PF00005), and a trimmed alignment of full-length 16S rRNAs (<xref ref-type="bibr" rid="bib31">Tatusov et al. 2001</xref>; <xref ref-type="bibr" rid="bib12">Finn et al. 2006</xref>; <ext-link ext-link-type="uri" xlink:href="http://greengenes.lbl.gov">http://greengenes.lbl.gov</ext-link>). These alignments contain roughly 8,000–150,000 distinct sequences (<xref ref-type="table" rid="tbl5">table 5</xref>). Running the distance matrix methods on the larger alignments was not feasible, so we extrapolated from smaller alignments (see Materials and Methods). The actual or estimated CPU time and memory usage are shown in table 6.</p>
      <table-wrap id="tbl5" position="float">
        <label>Table 5</label>
        <caption>
          <p>Genuine Alignments for Performance Testing</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td rowspan="1" colspan="1">Alignment</td>
              <td align="center" rowspan="1" colspan="1">COG2814</td>
              <td align="center" rowspan="1" colspan="1">PF00005</td>
              <td align="center" rowspan="1" colspan="1">16S rRNA</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Type</td>
              <td rowspan="1" colspan="1">Protein</td>
              <td rowspan="1" colspan="1">Protein</td>
              <td rowspan="1" colspan="1">Nucleotide</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">#Sequences</td>
              <td rowspan="1" colspan="1">10,610</td>
              <td rowspan="1" colspan="1">52,927</td>
              <td rowspan="1" colspan="1">167,547</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">#Distinct</td>
              <td rowspan="1" colspan="1">8,362</td>
              <td rowspan="1" colspan="1">39,092</td>
              <td rowspan="1" colspan="1">158,022</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">#Columns</td>
              <td rowspan="1" colspan="1">394</td>
              <td rowspan="1" colspan="1">214</td>
              <td rowspan="1" colspan="1">1,287</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">%Gaps</td>
              <td rowspan="1" colspan="1">10.8</td>
              <td rowspan="1" colspan="1">15.2</td>
              <td rowspan="1" colspan="1">4.3</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <table-wrap id="tbl6" position="float">
        <label>Table 6</label>
        <caption>
          <p>CPU Time and Memory Usage for Computing Distances, Trees, and Support Values</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td rowspan="2" colspan="1">Program</td>
              <td align="center" rowspan="2" colspan="1">Support</td>
              <td align="center" colspan="2" rowspan="1">COG2814<hr/></td>
              <td align="center" colspan="2" rowspan="1">PF00005<hr/></td>
              <td align="center" colspan="2" rowspan="1">16S rRNA<hr/></td>
            </tr>
            <tr>
              <td align="center" rowspan="1" colspan="1">h</td>
              <td align="center" rowspan="1" colspan="1">GB</td>
              <td align="center" rowspan="1" colspan="1">h</td>
              <td align="center" rowspan="1" colspan="1">GB</td>
              <td align="center" rowspan="1" colspan="1">h</td>
              <td align="center" rowspan="1" colspan="1">GB</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">FastTree 1.0</td>
              <td rowspan="1" colspan="1">None</td>
              <td align="char" char="." rowspan="1" colspan="1">0.06</td>
              <td align="char" char="." rowspan="1" colspan="1">0.16</td>
              <td align="char" char="." rowspan="1" colspan="1">0.52</td>
              <td align="char" char="." rowspan="1" colspan="1">0.3</td>
              <td align="char" char="." rowspan="1" colspan="1">16.3</td>
              <td align="char" char="." rowspan="1" colspan="1">2.4</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">FastTree 1.0</td>
              <td rowspan="1" colspan="1">Local 1,000</td>
              <td align="char" char="." rowspan="1" colspan="1">0.08</td>
              <td align="char" char="." rowspan="1" colspan="1">0.16</td>
              <td align="char" char="." rowspan="1" colspan="1">0.56</td>
              <td align="char" char="." rowspan="1" colspan="1">0.3</td>
              <td align="char" char="." rowspan="1" colspan="1">17.3</td>
              <td align="char" char="." rowspan="1" colspan="1">2.4</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Log-corrected distances<xref ref-type="table-fn" rid="tblfn6">a</xref></td>
              <td rowspan="1" colspan="1"/>
              <td align="char" char="." rowspan="1" colspan="1">0.05</td>
              <td align="char" char="." rowspan="1" colspan="1">0.13</td>
              <td align="char" char="." rowspan="1" colspan="1">0.71</td>
              <td align="char" char="." rowspan="1" colspan="1">2.8</td>
              <td align="char" char="." rowspan="1" colspan="1">33.1</td>
              <td align="char" char="." rowspan="1" colspan="1">49.9</td>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Maximum likelihood distances<xref ref-type="table-fn" rid="tblfn7">b</xref></td>
              <td rowspan="1" colspan="1"/>
              <td align="char" char="." rowspan="1" colspan="1">138</td>
              <td align="char" char="." rowspan="1" colspan="1">0.72</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 3, 000</td>
              <td align="center" rowspan="1" colspan="1">—</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 5, 000</td>
              <td align="center" rowspan="1" colspan="1">—</td>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Clearcut 1.0.8<xref ref-type="table-fn" rid="tblfn8">c</xref></td>
              <td rowspan="1" colspan="1">None</td>
              <td align="char" char="." rowspan="1" colspan="1">0.06</td>
              <td align="char" char="." rowspan="1" colspan="1">0.22</td>
              <td align="char" char="." rowspan="1" colspan="1">1.44</td>
              <td align="char" char="." rowspan="1" colspan="1">5.2</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 28.6</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 52</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">RapidNJ 1.0.0<xref ref-type="table-fn" rid="tblfn8">c</xref></td>
              <td rowspan="1" colspan="1">None</td>
              <td align="char" char="." rowspan="1" colspan="1">0.05</td>
              <td align="char" char="." rowspan="1" colspan="1">2.2</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 0.9</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 55</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 22.1</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 549</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">FastME 1.1<xref ref-type="table-fn" rid="tblfn8">c</xref></td>
              <td rowspan="1" colspan="1">None</td>
              <td align="char" char="." rowspan="1" colspan="1">0.51</td>
              <td align="char" char="." rowspan="1" colspan="1">4.2</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 12.5</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 105</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 138</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 1, 000</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">QuickTree 1.1<xref ref-type="table-fn" rid="tblfn8">c</xref></td>
              <td rowspan="1" colspan="1">None</td>
              <td align="char" char="." rowspan="1" colspan="1">0.24</td>
              <td align="char" char="." rowspan="1" colspan="1">0.16</td>
              <td align="char" char="." rowspan="1" colspan="1">22.7</td>
              <td align="char" char="." rowspan="1" colspan="1">2.9</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 1, 500</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 47</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">QuickTree 1.1<xref ref-type="table-fn" rid="tblfn9">d</xref></td>
              <td rowspan="1" colspan="1">Boot 100</td>
              <td align="char" char="." rowspan="1" colspan="1">63.5</td>
              <td align="char" char="." rowspan="1" colspan="1">0.71</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 10<sup>4</sup></td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 15.5</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 10<sup>5</sup></td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 254</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BIONJ<xref ref-type="table-fn" rid="tblfn8">c</xref></td>
              <td rowspan="1" colspan="1">None</td>
              <td align="char" char="." rowspan="1" colspan="1">32.9</td>
              <td align="char" char="." rowspan="1" colspan="1">0.44</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 820</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 10.9</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 10<sup>5</sup></td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 110</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">PhyML 3<xref ref-type="table-fn" rid="tblfn10">e</xref></td>
              <td rowspan="1" colspan="1">Approximate</td>
              <td align="char" char="." rowspan="1" colspan="1">&gt; 1,000</td>
              <td align="char" char="." rowspan="1" colspan="1">9.5</td>
              <td align="center" rowspan="1" colspan="1">—</td>
              <td align="center" rowspan="1" colspan="1">—</td>
              <td align="center" rowspan="1" colspan="1">—</td>
              <td align="center" rowspan="1" colspan="1">—</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">    likelihood ratio test</td>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">RAxML VI 1.0<xref ref-type="table-fn" rid="tblfn11">f</xref></td>
              <td rowspan="1" colspan="1">None</td>
              <td align="char" char="." rowspan="1" colspan="1">&gt; 1,000</td>
              <td align="char" char="." rowspan="1" colspan="1">0.70</td>
              <td align="center" rowspan="1" colspan="1">—</td>
              <td align="center" rowspan="1" colspan="1">—</td>
              <td align="center" rowspan="1" colspan="1">—</td>
              <td align="center" rowspan="1" colspan="1">—</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Consense<xref ref-type="table-fn" rid="tblfn12">g</xref></td>
              <td rowspan="1" colspan="1">Boot 100</td>
              <td align="char" char="." rowspan="1" colspan="1">1.09</td>
              <td align="char" char="." rowspan="1" colspan="1">0.36</td>
              <td align="char" char="." rowspan="1" colspan="1">118</td>
              <td align="char" char="." rowspan="1" colspan="1">9.4</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 3, 700</td>
              <td align="char" char="." rowspan="1" colspan="1">≈ 94</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn>
            <p>N<sc>OTE</sc>.—aLRT, approximate likelihood ratio test.</p>
          </fn>
          <fn id="tblfn6">
            <label>a</label>
            <p>The time to compute the distances between all <italic>N</italic><sup>2</sup> pairs of sequences in the alignment, as implemented by the authors, and the space required to store the <italic>N</italic>(<italic>N</italic> – 1)/2 distinct entries of the distance matrix. For nucleotide sequences, these are the same as Jukes–Cantor distances.</p>
          </fn>
          <fn id="tblfn7">
            <label>b</label>
            <p>For protein sequences, we used PHYLIP's protdist and default options (JTT model, no variation of rates across sites). For nucleotide sequences, we used PHYLIP's dnadist with the F84 model and gamma-distributed rates.</p>
          </fn>
          <fn id="tblfn8">
            <label>c</label>
            <p>These timings include half of the time to compute <italic>N</italic><sup>2</sup> log-corrected distances because the method requires a distance matrix but each pair of sequences only needs to be considered once.</p>
          </fn>
          <fn id="tblfn9">
            <label>d</label>
            <p>Using QuickTree's built-in implementation of %different distances and of global bootstrap.</p>
          </fn>
          <fn id="tblfn10">
            <label>e</label>
            <p>For best performance, we used no variation of rates across sites.</p>
          </fn>
          <fn id="tblfn11">
            <label>f</label>
            <p>For best performance, we used no variation of rates across sites and the fast hill-climbing option (-f d.). For an initial topology, we used the BIONJ tree.</p>
          </fn>
          <fn id="tblfn12">
            <label>g</label>
            <p>This does not include the time to compute the resampled trees.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>The maximum likelihood methods we tested, PhyML 3 (<xref ref-type="bibr" rid="bib15">Guindon and Gascuel 2003</xref>) and RAxML VI (<xref ref-type="bibr" rid="bib28">Stamatakis 2006</xref>), did not complete in 50 days on the smallest of these problems, which took FastTree about 3 min. (Despite the high usage of virtual memory by PhyML, both PhyML and RAxML ran at over 99% CPU utilization.) Even for COG alignments of just 1,250 proteins, PhyML 3 typically took over a week. Thus, current maximum likelihood methods do not scale.</p>
      <p>Most of the methods require a distance matrix as input, so in practice, the running time is the time to compute a distance matrix plus the time to infer a tree. As shown in <xref ref-type="table" rid="tbl6">table 6</xref>, FastTree is over 1,000 times faster than computing maximum likelihood protein distances. For the 16S rRNA alignment, FastTree is as fast as computing Jukes–Cantor distances and over 100 times faster than computing maximum likelihood distances with gamma-distributed rates.</p>
      <p>For the 16S alignment, the only method other than FastTree that seems practical is Clearcut: all the other methods would require over 1,000 h or over 500 GB of memory. Clearcut itself is very fast—we estimate that it might take only 12 h to infer a tree from the 16S distance matrix. However, Clearcut requires a distance matrix, and FastTree is faster than Clearcut once the cost of computing the distance matrix is included. Clearcut would also require over 50 GB of memory—20 times as much as FastTree—which makes it impractical for us to run. Furthermore, Clearcut seems to be less accurate than FastTree (<xref ref-type="table" rid="tbl1 tbl3 tbl4">tables 1, 3, and 4</xref>).</p>
    </sec>
    <sec>
      <title>Effectiveness and Speed of the Local Bootstrap</title>
      <p>To test whether FastTree's local bootstrap can identify which splits are reliable, we used the protein simulations with 250 sequences. We also computed the traditional bootstrap: we used PHYLIP's seqboot to generate resampled alignments, we ran FastTree on each resample, and we counted how often each split in the original tree was present in the resampled trees. For both methods, we used 1,000 resamples. As shown in <xref ref-type="fig" rid="fig2">figure 2</xref>, both methods were effective in identifying correct splits. If we define “strongly supported” as a local bootstrap of ≥95%, then 65% of the correct splits were strongly supported. Conversely, 97% of the strongly supported splits were correct.</p>
      <fig id="fig2" position="float">
        <label>F<sc>IG</sc>. 2.—</label>
        <caption>
          <p>Distribution of support values for simulated alignments of 250 protein sequences with gaps. We compare the distribution of FastTree's local bootstrap and the traditional (global) bootstrap for correctly and incorrectly inferred splits. The right-most bin contains the strongly supported splits (0.95–1.0)</p>
        </caption>
        <graphic xlink:href="molbiolevolmsp077f02_ht"/>
      </fig>
      <p>To quantify how effective the measures were in distinguishing correct splits, we used the area under the receiver operating characteristic curve (AOC; <xref ref-type="bibr" rid="bib3">DeLong and Clarke-Pearson 1998</xref>). The AOC is the probability that a true split will have a higher support value than an incorrect split, so a perfect predictor has AOC = 1 and a random predictor has AOC = 1/2. The traditional bootstrap had an AOC of 0.933 versus 0.875 for the local bootstrap. Overall, the local bootstrap is not quite as sensitive as the traditional bootstrap, but it is a strong indicator of which splits are correct.</p>
      <p>The local bootstrap was far faster than the traditional bootstrap and required far less memory. The traditional bootstrap takes 100 times longer than tree inference plus the time to compare the trees to each other. For the 16S rRNA alignment, performing the tree comparisons with PHYLIP's consense would take months and would require over 90 GB of memory (<xref ref-type="table" rid="tbl6">table 6</xref>). In contrast, FastTree computed the local bootstrap in an hour and 2.4 GB.</p>
    </sec>
  </sec>
  <sec sec-type="discussion">
    <title>Discussion</title>
    <sec>
      <title>Large Alignments</title>
      <p>We have relied on profile-based multiple sequence alignment as the most practical method for large families. However, profile-based alignment is believed to be less accurate than progressive alignment. Thus, whenever possible, biological inferences from these large trees should be confirmed with smaller, higher quality alignments. This also allows the use of slower but more accurate tree-building methods and tests. For example, MicrobesOnline.org includes interactive tools for browsing large trees, for selecting relevant sequences, and for building progressive alignments and maximum likelihood trees with those sequences.</p>
    </sec>
    <sec>
      <title>Scaling to a Million Sequences</title>
      <p>FastTree computes trees for the largest existing alignments, with on the order of 100,000 sequences, in under a day. However, given the rapid rate of DNA sequencing, we expect that alignments with 1,000,000 sequences will soon exist. For such large alignments, the major memory requirement will be the top-hits lists, which take O(<italic>N</italic><inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx9_ht.jpg"/></inline-formula>) space. For 1 million sequences, this will be about 20 GB. In contrast, the distance matrix for a million sequences would take 2 TB of memory. FastTree's running time should scale by between O(<italic>N</italic>log<italic>N</italic><inline-formula><inline-graphic xlink:href="molbiolevolmsp077fx9_ht.jpg"/></inline-formula>) and O(<italic>N</italic><sup>2</sup>), so inferring a tree for a million rRNA sequences should take 2–4 weeks. Tuning the top-hits heuristic might reduce this time.</p>
    </sec>
  </sec>
  <sec sec-type="conclusions">
    <title>Conclusions</title>
    <p>FastTree makes it practical to infer accurate phylogenies, including support values, for families with tens or hundreds of thousands of sequences. These phylogenies should be useful for reconstructing the tree of life and for predicting functions for the millions of uncharacterized proteins that are being identified by large-scale DNA sequencing. FastTree executables and source code are available at <ext-link ext-link-type="uri" xlink:href="http://www.microbesonline.org/fasttree">http://www.microbesonline.org/fasttree</ext-link>; FastTree trees for every prokaryotic gene family are available in the MicrobesOnline tree-browser (<ext-link ext-link-type="uri" xlink:href="http://www.microbesonline.org/">http://www.microbesonline.org/</ext-link>); and a FastTree tree for all sequenced full-length 16S rRNAs is available from the FastTree Web site and will be included in the next release of greengenes (<ext-link ext-link-type="uri" xlink:href="http://greengenes.lbl.gov">http://greengenes.lbl.gov</ext-link>).</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <p>Supplementary notes 1 and 2, <ext-link ext-link-type="uri" xlink:href="http://mbe.oxfordjournals.org/cgi/content/full/msp077/DC1">Tables 1</ext-link>–<ext-link ext-link-type="uri" xlink:href="http://mbe.oxfordjournals.org/cgi/content/full/msp077/DC1">3</ext-link> and <ext-link ext-link-type="uri" xlink:href="http://mbe.oxfordjournals.org/cgi/content/full/msp077/DC1">figure 1</ext-link> are available at <italic>Molecular Biology and Evolution</italic> online (<ext-link ext-link-type="uri" xlink:href="http://www.mbe.oxfordjournals.org/">http://www.mbe.oxfordjournals.org/</ext-link>).</p>
    <supplementary-material id="PMC_1" content-type="local-data">
      <caption>
        <title>[Supplementary Data]</title>
      </caption>
      <media mimetype="text" mime-subtype="html" xlink:href="msp077_index.html"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="pdf" xlink:href="msp077_1.pdf"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="pdf" xlink:href="msp077_2.pdf"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <p>This work was supported by a grant from the US Department of Energy Genomics: GTL program (DE-AC02-05CH11231).</p>
  </ack>
  <ref-list>
    <ref id="bib1">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Alm</surname>
            <given-names>EJ</given-names>
          </name>
          <name>
            <surname>Huang</surname>
            <given-names>KH</given-names>
          </name>
          <name>
            <surname>Price</surname>
            <given-names>MN</given-names>
          </name>
          <name>
            <surname>Koche</surname>
            <given-names>RP</given-names>
          </name>
          <name>
            <surname>Keller</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Dubchak</surname>
            <given-names>IL</given-names>
          </name>
          <name>
            <surname>Arkin</surname>
            <given-names>AP</given-names>
          </name>
        </person-group>
        <article-title>The MicrobesOnline Web site for comparative genomics</article-title>
        <source>Genome Res.</source>
        <year>2005</year>
        <volume>15</volume>
        <fpage>1015</fpage>
        <lpage>1022</lpage>
        <pub-id pub-id-type="pmid">15998914</pub-id>
      </element-citation>
    </ref>
    <ref id="bib2">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bininda-Emonds</surname>
            <given-names>OR</given-names>
          </name>
          <name>
            <surname>Brady</surname>
            <given-names>SG</given-names>
          </name>
          <name>
            <surname>Kim</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Sanderson</surname>
            <given-names>MJ</given-names>
          </name>
        </person-group>
        <article-title>Scaling of accuracy in extremely large phylogenetic trees</article-title>
        <source>Pac Symp Biocomput</source>
        <year>2001</year>
        <volume>2001</volume>
        <fpage>547</fpage>
        <lpage>558</lpage>
        <pub-id pub-id-type="pmid">11262972</pub-id>
      </element-citation>
    </ref>
    <ref id="bib3">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>DeLong</surname>
            <given-names>ER</given-names>
          </name>
          <name>
            <surname>Clarke-Pearson</surname>
            <given-names>DL</given-names>
          </name>
        </person-group>
        <article-title>Comparing the areas under two or more correlated receiver operating characteristic curves: a nonparametric approach</article-title>
        <source>Biometrics</source>
        <year>1998</year>
        <volume>44</volume>
        <fpage>837</fpage>
        <lpage>845</lpage>
        <pub-id pub-id-type="pmid">3203132</pub-id>
      </element-citation>
    </ref>
    <ref id="bib4">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>DeSantis</surname>
            <given-names>TZ</given-names>
          </name>
          <name>
            <surname>Hugenholtz</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Larsen</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Rojas</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Brodie</surname>
            <given-names>EL</given-names>
          </name>
          <name>
            <surname>Keller</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Huber</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Dalevi</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Hu</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Andersen</surname>
            <given-names>GL</given-names>
          </name>
        </person-group>
        <article-title>Greengenes, a chimera-checked 16S rRNA gene database and workbench compatible with ARB</article-title>
        <source>Appl Environ Microbiol.</source>
        <year>2006</year>
        <volume>72</volume>
        <fpage>5069</fpage>
        <lpage>5072</lpage>
        <pub-id pub-id-type="pmid">16820507</pub-id>
      </element-citation>
    </ref>
    <ref id="bib5">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Desper</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Gascuel</surname>
            <given-names>O</given-names>
          </name>
        </person-group>
        <article-title>Fast and accurate phylogeny reconstruction algorithms based on the minimum-evolution principle</article-title>
        <source>J Comput Biol.</source>
        <year>2002</year>
        <volume>9</volume>
        <fpage>687</fpage>
        <lpage>705</lpage>
        <pub-id pub-id-type="pmid">12487758</pub-id>
      </element-citation>
    </ref>
    <ref id="bib6">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Efron</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Halloran</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Holmes</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Bootstrap confidence levels for phylogenetic trees</article-title>
        <source>Proc Natl Acad Sci USA</source>
        <year>1996</year>
        <volume>93</volume>
        <fpage>13429</fpage>
        <lpage>13434</lpage>
        <pub-id pub-id-type="pmid">8917608</pub-id>
      </element-citation>
    </ref>
    <ref id="bib7">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Eisen</surname>
            <given-names>JA</given-names>
          </name>
        </person-group>
        <article-title>Phylogenomics: improving functional predictions for uncharacterized genes by evolutionary analysis</article-title>
        <source>Genome Res.</source>
        <year>1998</year>
        <volume>8</volume>
        <fpage>163</fpage>
        <lpage>167</lpage>
        <pub-id pub-id-type="pmid">9521918</pub-id>
      </element-citation>
    </ref>
    <ref id="bib8">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Elias</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Lagergren</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Fast neighbor joining. In: Proceedings of the 32nd International Colloquium on Automata</article-title>
        <source>Languages and Programming (ICALP'05) Lecture Notes in Computer Science</source>
        <year>2005</year>
        <volume>3580</volume>
        <publisher-loc>Berlin/Heidelberg</publisher-loc>
        <publisher-name>Springer-Verlag</publisher-name>
        <fpage>1263</fpage>
        <lpage>1274</lpage>
      </element-citation>
    </ref>
    <ref id="bib9">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Engelhardt</surname>
            <given-names>BE</given-names>
          </name>
          <name>
            <surname>Jordan</surname>
            <given-names>MI</given-names>
          </name>
          <name>
            <surname>Muratore</surname>
            <given-names>KE</given-names>
          </name>
          <name>
            <surname>Brenner</surname>
            <given-names>SE</given-names>
          </name>
        </person-group>
        <source>Protein molecular function prediction by Bayesian phylogenomics. PLoS Comput Biol. 1:e45</source>
        <year>2005</year>
      </element-citation>
    </ref>
    <ref id="bib10">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Evans</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Sheneman</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Foster</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Relaxed neighbor joining: a fast distance-based phylogenetic tree construction method</article-title>
        <source>J Mol Evol.</source>
        <year>2006</year>
        <volume>62</volume>
        <fpage>785</fpage>
        <lpage>792</lpage>
        <pub-id pub-id-type="pmid">16752216</pub-id>
      </element-citation>
    </ref>
    <ref id="bib11">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Felsenstein</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Confidence limits on phylogenies: an approach using the bootstrap</article-title>
        <source>Evolution</source>
        <year>1985</year>
        <volume>39</volume>
        <fpage>783</fpage>
        <lpage>791</lpage>
      </element-citation>
    </ref>
    <ref id="bib12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Finn</surname>
            <given-names>RD</given-names>
          </name>
          <name>
            <surname>Mistry</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Schuster-Böckler</surname>
            <given-names>B</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>13 co-authors</article-title>
        <article-title>Pfam: clans, web tools and services</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2006</year>
        <volume>34</volume>
        <fpage>D247</fpage>
        <lpage>D251</lpage>
      </element-citation>
    </ref>
    <ref id="bib13">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gascuel</surname>
            <given-names>O</given-names>
          </name>
        </person-group>
        <article-title>BIONJ: an improved version of the NJ algorithm based on a simple model of sequence data</article-title>
        <source>Mol Biol Evol.</source>
        <year>1997</year>
        <volume>14</volume>
        <fpage>685</fpage>
        <lpage>695</lpage>
        <pub-id pub-id-type="pmid">9254330</pub-id>
      </element-citation>
    </ref>
    <ref id="bib14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gascuel</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Steel</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Neighbor-joining revealed</article-title>
        <source>Mol Biol Evol.</source>
        <year>2006</year>
        <volume>23</volume>
        <fpage>1997</fpage>
        <lpage>2000</lpage>
        <pub-id pub-id-type="pmid">16877499</pub-id>
      </element-citation>
    </ref>
    <ref id="bib15">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Guindon</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Gascuel</surname>
            <given-names>O</given-names>
          </name>
        </person-group>
        <article-title>A simple, fast, and accurate algorithm to estimate large phylogenies by maximum likelihood</article-title>
        <source>Syst Biol.</source>
        <year>2003</year>
        <volume>52</volume>
        <fpage>696</fpage>
        <lpage>704</lpage>
        <pub-id pub-id-type="pmid">14530136</pub-id>
      </element-citation>
    </ref>
    <ref id="bib16">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Henikoff</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Henikoff</surname>
            <given-names>JG</given-names>
          </name>
        </person-group>
        <article-title>Amino acid substitution matrices from protein blocks</article-title>
        <source>Proc Natl Acad Sci USA</source>
        <year>1992</year>
        <volume>89</volume>
        <fpage>10915</fpage>
        <lpage> 10919</lpage>
        <pub-id pub-id-type="pmid">1438297</pub-id>
      </element-citation>
    </ref>
    <ref id="bib17">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hollich</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Milchert</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Arvestad</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Sonnhammer</surname>
            <given-names>EL</given-names>
          </name>
        </person-group>
        <article-title>Assessment of protein distance measures and tree-building methods for phylogenetic tree reconstruction</article-title>
        <source>Mol Biol Evol.</source>
        <year>2005</year>
        <volume>22</volume>
        <fpage>2257</fpage>
        <lpage>2264</lpage>
        <pub-id pub-id-type="pmid">16049194</pub-id>
      </element-citation>
    </ref>
    <ref id="bib18">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Howe</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Bateman</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>QuickTree: building huge neighbour-joining trees of protein sequences</article-title>
        <source>Bioinformatics</source>
        <year>2002</year>
        <volume>18</volume>
        <fpage>1546</fpage>
        <lpage>1547</lpage>
        <pub-id pub-id-type="pmid">12424131</pub-id>
      </element-citation>
    </ref>
    <ref id="bib19">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kishino</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Miyata</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Hasegawa</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Maximum likelihood inference of protein phylogeny and the origin of chloroplasts</article-title>
        <source>J Mol Evol.</source>
        <year>1990</year>
        <volume>31</volume>
        <fpage>151</fpage>
        <lpage>160</lpage>
      </element-citation>
    </ref>
    <ref id="bib20">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Coghlan</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Ruan</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>15 co-authors</article-title>
        <article-title>TreeFam: a curated database of phylogenetic trees of animal gene families</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2006</year>
        <volume>34</volume>
        <fpage>D572</fpage>
        <lpage>D580</lpage>
      </element-citation>
    </ref>
    <ref id="bib21">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lichtarge</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Yao</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Kristensen</surname>
            <given-names>DM</given-names>
          </name>
          <name>
            <surname>Madabushi</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Mihalek</surname>
            <given-names>I</given-names>
          </name>
        </person-group>
        <article-title>Accurate and scalable identification of functional sites by evolutionary tracing</article-title>
        <source>J Struct Funct Genomics</source>
        <year>2003</year>
        <volume>4</volume>
        <fpage>159</fpage>
        <lpage>166</lpage>
        <pub-id pub-id-type="pmid">14649300</pub-id>
      </element-citation>
    </ref>
    <ref id="bib22">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Müller</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Rahmann</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Dandekar</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Wolf</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Accurate and robust phylogeny estimation based on profile distances: a study of the Chlorophyceae (Chlorophyta)</article-title>
        <source>BMC Evol Biol.</source>
        <year>2004</year>
        <volume>4</volume>
        <fpage>20</fpage>
        <comment>doi:10.1186/1471-2148-4-20</comment>
        <pub-id pub-id-type="pmid">15222898</pub-id>
      </element-citation>
    </ref>
    <ref id="bib23">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Nei</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Kumar</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Takahashi</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>The optimization principle in phylogenetic analysis tends to give incorrect topologies when the number of nucleotides or amino acids used is small</article-title>
        <source>Proc Natl Acad Sci USA</source>
        <year>1998</year>
        <volume>95</volume>
        <fpage>12390</fpage>
        <lpage>12397</lpage>
        <pub-id pub-id-type="pmid">9770497</pub-id>
      </element-citation>
    </ref>
    <ref id="bib24">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Saitou</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Nei</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>The neighbor-joining method: a new method for reconstructing phylogenetic trees</article-title>
        <source>Mol Biol Evol.</source>
        <year>1987</year>
        <volume>4</volume>
        <fpage>406</fpage>
        <lpage>425</lpage>
        <pub-id pub-id-type="pmid">3447015</pub-id>
      </element-citation>
    </ref>
    <ref id="bib25">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schaffer</surname>
            <given-names>AA</given-names>
          </name>
          <name>
            <surname>Aravind</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Madden</surname>
            <given-names>TL</given-names>
          </name>
          <name>
            <surname>Shavirin</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Spouge</surname>
            <given-names>JL</given-names>
          </name>
          <name>
            <surname>Wolf</surname>
            <given-names>YI</given-names>
          </name>
          <name>
            <surname>Koonin</surname>
            <given-names>EV</given-names>
          </name>
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
        </person-group>
        <article-title>Improving the accuracy of PSI-BLAST protein database searches with composition-based statistics and other refinements</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2001</year>
        <volume>29</volume>
        <fpage>2994</fpage>
        <lpage>3005</lpage>
        <pub-id pub-id-type="pmid">11452024</pub-id>
      </element-citation>
    </ref>
    <ref id="bib26">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Simonsen</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Mailund</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Pedersen</surname>
            <given-names>CNS</given-names>
          </name>
        </person-group>
        <article-title>Rapid neighbor-joining</article-title>
        <source>Lect Notes Comput Sci.</source>
        <year>2008</year>
        <volume>5251</volume>
        <fpage>113</fpage>
        <lpage>122</lpage>
      </element-citation>
    </ref>
    <ref id="bib27">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sonnhammer</surname>
            <given-names>ELL</given-names>
          </name>
          <name>
            <surname>Hollich</surname>
            <given-names>V</given-names>
          </name>
        </person-group>
        <article-title>Scoredist: a simple and robust protein sequence distance estimator</article-title>
        <source>BMC Bioinformatics</source>
        <year>2005</year>
        <volume>6</volume>
        <fpage>108</fpage>
        <pub-id pub-id-type="pmid">15857510</pub-id>
      </element-citation>
    </ref>
    <ref id="bib28">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Stamatakis</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>RAxML-VI-HPC: maximum likelihood-based phylogenetic analyses with thousands of taxa and mixed models</article-title>
        <source>Bioinformatics</source>
        <year>2006</year>
        <volume>22</volume>
        <fpage>2688</fpage>
        <lpage>2690</lpage>
        <pub-id pub-id-type="pmid">16928733</pub-id>
      </element-citation>
    </ref>
    <ref id="bib29">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Stoye</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Evers</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Meyer</surname>
            <given-names>F</given-names>
          </name>
        </person-group>
        <article-title>Rose: generating sequence families</article-title>
        <source>Bioinformatics</source>
        <year>1998</year>
        <volume>14</volume>
        <fpage>157</fpage>
        <lpage>163</lpage>
        <pub-id pub-id-type="pmid">9545448</pub-id>
      </element-citation>
    </ref>
    <ref id="bib30">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Studier</surname>
            <given-names>JA</given-names>
          </name>
          <name>
            <surname>Keppler</surname>
            <given-names>KJ</given-names>
          </name>
        </person-group>
        <article-title>A note on the neighbor-joining algorithm of Saitou and Nei</article-title>
        <source>Mol Biol Evol.</source>
        <year>1988</year>
        <volume>5</volume>
        <fpage>729</fpage>
        <lpage>731</lpage>
        <pub-id pub-id-type="pmid">3221794</pub-id>
      </element-citation>
    </ref>
    <ref id="bib31">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Tatusov</surname>
            <given-names>RL</given-names>
          </name>
          <name>
            <surname>Natale</surname>
            <given-names>DA</given-names>
          </name>
          <name>
            <surname>Garkavtsev</surname>
            <given-names>IV</given-names>
          </name>
          <name>
            <surname>Tatusova</surname>
            <given-names>TA</given-names>
          </name>
          <name>
            <surname>Shankavaram</surname>
            <given-names>UT</given-names>
          </name>
          <name>
            <surname>Rao</surname>
            <given-names>BS</given-names>
          </name>
          <name>
            <surname>Kiryutin</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Galperin</surname>
            <given-names>MY</given-names>
          </name>
          <name>
            <surname>Fedorova</surname>
            <given-names>ND</given-names>
          </name>
          <name>
            <surname>Koonin</surname>
            <given-names>EV</given-names>
          </name>
        </person-group>
        <article-title>The COG database: new developments in phylogenetic classification of proteins from complete genomes</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2001</year>
        <volume>29</volume>
        <fpage>22</fpage>
        <lpage>28</lpage>
        <pub-id pub-id-type="pmid">11125040</pub-id>
      </element-citation>
    </ref>
    <ref id="bib32">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>von Mering</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Hugenholtz</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Raes</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Tringe</surname>
            <given-names>SG</given-names>
          </name>
          <name>
            <surname>Doerks</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Jensen</surname>
            <given-names>LJ</given-names>
          </name>
          <name>
            <surname>Ward</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Bork</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Quantitative phylogenetic assessment of microbial communities in diverse environments</article-title>
        <source>Science</source>
        <year>2007</year>
        <volume>315</volume>
        <fpage>1126</fpage>
        <lpage>1130</lpage>
        <pub-id pub-id-type="pmid">17272687</pub-id>
      </element-citation>
    </ref>
    <ref id="bib33">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zaslavsky</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Tatusova</surname>
            <given-names>TA</given-names>
          </name>
        </person-group>
        <article-title>Accelerating the neighbor-joining algorithm using the adaptive bucket data structure</article-title>
        <source>Lect Notes Comput Sci.</source>
        <year>2008</year>
        <volume>4983</volume>
        <fpage>122</fpage>
        <lpage>133</lpage>
        <pub-id pub-id-type="pmid">18478099</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
