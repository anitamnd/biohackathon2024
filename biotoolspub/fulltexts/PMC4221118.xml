<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4221118</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btu507</article-id>
    <article-id pub-id-type="publisher-id">btu507</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>BitPAl: a bit-parallel, general integer-scoring sequence alignment algorithm</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Loving</surname>
          <given-names>Joshua</given-names>
        </name>
        <xref ref-type="aff" rid="btu507-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="btu507-AFF1">
          <sup>2</sup>
        </xref>
        <xref ref-type="corresp" rid="btu507-COR1">*</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Hernandez</surname>
          <given-names>Yozen</given-names>
        </name>
        <xref ref-type="aff" rid="btu507-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="btu507-AFF1">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Benson</surname>
          <given-names>Gary</given-names>
        </name>
        <xref ref-type="aff" rid="btu507-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="btu507-AFF1">
          <sup>2</sup>
        </xref>
        <xref ref-type="aff" rid="btu507-AFF1">
          <sup>3</sup>
        </xref>
        <xref ref-type="corresp" rid="btu507-COR1">*</xref>
      </contrib>
      <aff id="btu507-AFF1"><sup>1</sup>Laboratory for Biocomputing and Informatics, <sup>2</sup>Graduate Program in Bioinformatics, and <sup>3</sup>Department of Computer Science, Boston University, Boston, MA 02215, USA</aff>
    </contrib-group>
    <author-notes>
      <corresp id="btu507-COR1">*To whom correspondence should be addressed.</corresp>
      <fn id="FN1">
        <p>Associate Editor: John Hancock</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>11</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>29</day>
      <month>7</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>29</day>
      <month>7</month>
      <year>2014</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>30</volume>
    <issue>22</issue>
    <fpage>3166</fpage>
    <lpage>3173</lpage>
    <history>
      <date date-type="received">
        <day>27</day>
        <month>2</month>
        <year>2014</year>
      </date>
      <date date-type="rev-recd">
        <day>18</day>
        <month>7</month>
        <year>2014</year>
      </date>
      <date date-type="accepted">
        <day>21</day>
        <month>7</month>
        <year>2014</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author 2014. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2014</copyright-year>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/" license-type="creative-commons">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> Mapping of high-throughput sequencing data and other bulk sequence comparison applications have motivated a search for high-efficiency sequence alignment algorithms. The bit-parallel approach represents individual cells in an alignment scoring matrix as bits in computer words and emulates the calculation of scores by a series of logic operations composed of AND, OR, XOR, complement, shift and addition. Bit-parallelism has been successfully applied to the longest common subsequence (LCS) and edit-distance problems, producing fast algorithms in practice.</p>
      <p><bold>Results:</bold> We have developed BitPAl, a bit-parallel algorithm for general, integer-scoring global alignment. Integer-scoring schemes assign integer weights for match, mismatch and insertion/deletion. The BitPAl method uses structural properties in the relationship between adjacent scores in the scoring matrix to construct classes of efficient algorithms, each designed for a particular set of weights. In timed tests, we show that BitPAl runs 7–25 times faster than a standard iterative algorithm.</p>
      <p><bold>Availability and implementation:</bold> Source code is freely available for download at <ext-link ext-link-type="uri" xlink:href="http://lobstah.bu.edu/BitPAl/BitPAl.html">http://lobstah.bu.edu/BitPAl/BitPAl.html</ext-link>. BitPAl is implemented in C and runs on all major operating systems.</p>
      <p><bold>Contact</bold>: <email>jloving@bu.edu</email> or <email>yhernand@bu.edu</email> or <email>gbenson@bu.edu</email></p>
      <p><bold>Supplementary information</bold>: <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu507/-/DC1">Supplementary data</ext-link> are available at <italic>Bioinformatics</italic> online.</p>
    </abstract>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 INTRODUCTION</title>
    <p>Sequence alignment algorithms are critical tools in the analysis of biological sequence data including DNA, RNA and protein sequences. The demands placed on computational resources by high-throughput experiments require new, more efficient methodologies. While the standard algorithms of <xref rid="btu507-B15" ref-type="bibr">Smith and Waterman (1981)</xref> and <xref rid="btu507-B14" ref-type="bibr">Needleman and Wunch (1970)</xref> calculate the score in each cell of the alignment scoring matrix sequentially, a newer technique called bit-parallelism partially overcomes score dependencies so that scores can be calculated in parallel to achieve much higher efficiencies.</p>
    <p>Bit-parallel algorithms have been developed for exact and approximate string matching problems. Early examples include the algorithms of <xref rid="btu507-B2" ref-type="bibr">Baeza-Yates and Gonnet (1992)</xref>, which finds exact matches to a simple string pattern, and <xref rid="btu507-B16" ref-type="bibr">Wu and Manber (1992)</xref>, which finds approximate matches to a string pattern or a regular expression, where the number of differences between the pattern and the text is at most <italic>k</italic> (counting single character substitutions and single character insertions and deletions or indels). The latter is implemented as the Unix command <italic>agrep</italic>. Additional <italic>k</italic>-differences examples include (<xref rid="btu507-B17" ref-type="bibr">Wu <italic>et al.</italic>, 1996</xref>), which finds matches to ‘limited expressions’, i.e. regular expressions without Kleene closure, (<xref rid="btu507-B12" ref-type="bibr">Myers, 1999</xref>), which finds matches to simple string patterns and emulates the dynamic programming solution used in alignment, and (<xref rid="btu507-B13" ref-type="bibr">Navarro, 2004</xref>), which allows arbitrary integer weights for substitution of each pair of characters, insertion of each character and deletion of each character, and finds occurrences of regular expressions where the <italic>sum</italic> of the edit weights is at most <italic>k</italic>. In most <italic>k</italic>-differences algorithms, the complexity (and computing time) increases with increasing <italic>k</italic>.</p>
    <p>Bit-parallel methods have been successfully applied to the longest common subsequence (LCS) problem (<xref rid="btu507-B1" ref-type="bibr">Allison and Dix, 1986</xref>; <xref rid="btu507-B5" ref-type="bibr">Crochemore <italic>et al.</italic>, 2001</xref>; <xref rid="btu507-B7" ref-type="bibr">Hyyrö, 2004</xref>), and to unit-cost edit-distance (<xref rid="btu507-B8" ref-type="bibr">Hyyrö and Navarro, 2005</xref>; <xref rid="btu507-B10" ref-type="bibr">Hyyrö <italic>et al.</italic>, 2005</xref>) by modifications of <xref rid="btu507-B12" ref-type="bibr">Myers’s method (1999)</xref>. These algorithms compute the alignment score, de-linking that computation from the traceback, which produces the final alignment. In the LCS scoring matrix, scores are monotonically non-decreasing in the rows and columns, and bit-parallel implementations use bits to represent the cells where an increase occurs. In edit-distance scoring, adjacent scores can differ by at most one, and the binary representation stores the locations of (two of the three) possible differences, +1, −1 and zero. These algorithms are <italic>ad hoc</italic> in their approach, relying on specific properties of the underlying problems, making it difficult to directly adapt them to other alignment scoring schemes.</p>
    <p>Below, we present a bit-parallel method for similarity and distance based global alignment using general integer-scoring (<xref rid="btu507-B3" ref-type="bibr">Benson <italic>et al.</italic>, 2013</xref>), allowing arbitrary integer weights for match, mismatch and indel. Other approaches have been suggested by <xref rid="btu507-B16" ref-type="bibr">Wu and Manber (1992)</xref> and <xref rid="btu507-B4" ref-type="bibr">Bergeron and Hamel (2002)</xref>. The method of <xref rid="btu507-B13" ref-type="bibr">Navarro (2004)</xref> is more flexible in scoring and applies to both simple patterns and regular expressions, but is much slower than our method in practice. Our contribution is based on an observation of the regularity in the relationship between adjacent scores in the scoring matrix (Section 2.1) and the design of an efficient series of bit operations to exploit that regularity (Section 3). Because every distinct choice of weights requires a different program, we show how to construct a class of efficient algorithms, each designed for a particular set of weights, and provide an online C code generator for users. The complexity of our algorithms depends on the weights, not the ultimate score of the alignment. Our method works for general alphabets, but our interest derives from frequent use of DNA alignment when analyzing high-throughput sequencing data to detect genetic variation.</p>
  </sec>
  <sec>
    <title>2 METHODS</title>
    <p>The problem to be solved is stated in terms of similarity scoring, but the technique applies to distance scoring as well.
<statement><title>P<sc>roblem</sc></title><p>Given two sequences X and Y, of length n and m respectively, and a similarity scoring function S defined by three integer weights M (match), I (mismatch) and G (indel or gap), calculate the global alignment similarity score for X and Y using logic and addition operations on computer words of length w.</p></statement>
</p>
    <p>We are interested in two measures of efficiency for the algorithms. The first is standard time complexity and the second is a ratio of the word size, <italic>w</italic>, and the count, <italic>p</italic>, of logic and addition operations required to process <italic>w</italic> consecutive cells in the alignment scoring matrix. The efficiency, <inline-formula><mml:math id="I1"><mml:mrow><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mi>w</mml:mi><mml:mo>/</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>, is the average number of cells computed per operation. For example, when using 64 bit words, LCS has <inline-formula><mml:math id="I2"><mml:mrow><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mn>64</mml:mn><mml:mo>/</mml:mo><mml:mn>4</mml:mn><mml:mo>=</mml:mo><mml:mn>16</mml:mn></mml:mrow></mml:math></inline-formula> [<italic>P</italic> = 4 operations per word (<xref rid="btu507-B7" ref-type="bibr">Hyyrö, 2004</xref>)], and edit distance has <inline-formula><mml:math id="I3"><mml:mrow><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mn>64</mml:mn><mml:mo>/</mml:mo><mml:mn>15</mml:mn><mml:mo>≈</mml:mo><mml:mn>4.2</mml:mn></mml:mrow></mml:math></inline-formula> [an improvement from 64/16 in the method of <xref rid="btu507-B10" ref-type="bibr">Hyyrö <italic>et al.</italic> (2005)</xref> and <xref rid="btu507-B12" ref-type="bibr">Myers (1999)</xref>; see <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu507/-/DC1">Supplementary Information</ext-link> for details]. As <italic>P</italic> is independent of <italic>w</italic>, if the word size doubles, <italic>e</italic> doubles too. Note that we are counting only logic and addition operations, not storage of values in program variables. Adding store operations would be more accurate but the number of these operations is compiler and optimization level specific.</p>
    <p>We require that the alignment method be global or semi-global. That is, we do not restrict the initializations in the first row or column of the alignment scoring matrix or where in the last row or column the alignment score is obtained. Typical initializations require (i) a gap weight to be added successively to every cell (global alignment from the beginning of a sequence), and (ii) a zero in every cell (semi-global alignment where an initial gap has no penalty). We assume that match scores are positive or zero, <inline-formula><mml:math id="I4"><mml:mrow><mml:mi>M</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>, mismatch and gap scores are negative, <inline-formula><mml:math id="I5"><mml:mrow><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and that the use of mismatch is possible, meaning that its penalty is no worse than the penalty for two adjacent gaps, one in each sequence, <inline-formula><mml:math id="I6"><mml:mrow><mml:mi>I</mml:mi><mml:mo>≥</mml:mo><mml:mn>2</mml:mn><mml:mi>G</mml:mi></mml:mrow></mml:math></inline-formula>. While other weightings are possible, they either reduce to simpler problems from a bit-parallel perspective (e.g. LCS has <inline-formula><mml:math id="I7"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mi>I</mml:mi><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mi>∞</mml:mi><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>) or require more complicated structures than detailed here (e.g. protein alignment using PAM or BLOSUM style amino acid substitution tables).</p>
    <sec id="SEC2.1">
      <title>2.1 Function tables</title>
      <p>Let <italic>S</italic> be a recursively-defined, global similarity scoring function for two sequences <italic>X</italic> and <italic>Y</italic> computed in an alignment scoring matrix:
<disp-formula><mml:math id="UM1"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext> if </mml:mtext><mml:mspace width=".3em"/><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="-.6em"/><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext> if </mml:mtext><mml:mspace width=".3em"/><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="-2em"/><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>G</mml:mi></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext> </mml:mtext><mml:mspace width="-.3em"/><mml:mtext>delete </mml:mtext><mml:mspace width=".3em"/><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="-2em"/><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>G</mml:mi></mml:mrow></mml:mtd><mml:mtd><mml:mspace width="-.3em"/><mml:mrow><mml:mtext> delete </mml:mtext><mml:mspace width=".3em"/><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
Instead of actual values of <italic>S</italic>, we store only the differences, Δ<italic>V</italic>, between a cell and the cell above, and Δ<italic>H</italic>, between a cell and the cell to its left:
<disp-formula><mml:math id="UM2"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>−</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula>
<disp-formula><mml:math id="UM3"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>H</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>−</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
</p>
      <p>It is an easy exercise to prove that the minimum and maximum values for Δ<italic>V</italic> and Δ<italic>H</italic> are <italic>G</italic> and <italic>M</italic> − <italic>G</italic><italic>,</italic> respectively. Lemma 2.1 gives the recursive definitions for Δ<italic>V</italic> and Δ<italic>H</italic> in terms of <italic>M</italic>, <italic>I</italic> and <italic>G</italic>.
<statement><title>L<sc>emma</sc> 2.1</title><p><italic>The values for ΔV are as shown below and the values for ΔH are computed similarly. That is, </italic><inline-formula><mml:math id="I8"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>H</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula><italic>in matrix S is equal to </italic><inline-formula><mml:math id="I9"><mml:mrow><mml:mi>V</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula><italic>in the transpose of matrix S.</italic></p></statement>
<disp-formula><mml:math id="UM4"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:munder><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munder><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mi>Δ</mml:mi><mml:mi>H</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi>M</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>c</mml:mi><mml:mi>h,</mml:mi><mml:mspace width=".3em"/><mml:mtext>
</mml:mtext><mml:mi>i</mml:mi><mml:mo>.</mml:mo><mml:mi>e</mml:mi><mml:mo>.</mml:mo><mml:mspace width="-.3em"/><mml:mo>:</mml:mo><mml:mtext>
</mml:mtext><mml:mi>i</mml:mi><mml:mi>f</mml:mi><mml:mspace width=".3em"/><mml:mtext>
</mml:mtext><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>I</mml:mi><mml:mo>−</mml:mo><mml:mi>Δ</mml:mi><mml:mi>H</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi>M</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>c</mml:mi><mml:mi>h</mml:mi><mml:mtext>, </mml:mtext><mml:mspace width=".3em"/><mml:mi>i</mml:mi><mml:mo>.</mml:mo><mml:mi>e</mml:mi><mml:mo>.</mml:mo><mml:mspace width="-.3em"/><mml:mo>:</mml:mo><mml:mtext>
</mml:mtext><mml:mi>i</mml:mi><mml:mi>f</mml:mi><mml:mtext>
</mml:mtext></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow><mml:mi>I</mml:mi><mml:mo>−</mml:mo><mml:mi>G</mml:mi><mml:mo>≥</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>H</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>G</mml:mi></mml:mtd><mml:mtd><mml:mrow><mml:mi>I</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mspace width=".3em"/><mml:mtext>
</mml:mtext><mml:mi>f</mml:mi><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>m</mml:mi><mml:mspace width=".3em"/><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>o</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mtext>, </mml:mtext><mml:mspace width=".3em"/><mml:mi>i</mml:mi><mml:mo>.</mml:mo><mml:mi>e</mml:mi><mml:mo>.</mml:mo><mml:mspace width="-.3em"/><mml:mo>:</mml:mo><mml:mtext>
</mml:mtext><mml:mi>i</mml:mi><mml:mi>f</mml:mi><mml:mtext>
</mml:mtext></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>H</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>I</mml:mi><mml:mo>−</mml:mo><mml:mi>G</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow/></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>G</mml:mi><mml:mo>−</mml:mo><mml:mi>Δ</mml:mi><mml:mi>H</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mspace width="-2.5em"/><mml:mi>I</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mspace width=".3em"/><mml:mtext>
</mml:mtext><mml:mi>f</mml:mi><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>m</mml:mi><mml:mspace width=".3em"/><mml:mi>l</mml:mi><mml:mi>e</mml:mi><mml:mi>f</mml:mi><mml:mi>t</mml:mi><mml:mtext>, </mml:mtext><mml:mspace width=".3em"/><mml:mi>i</mml:mi><mml:mo>.</mml:mo><mml:mi>e</mml:mi><mml:mo>.</mml:mo><mml:mspace width="-.3em"/><mml:mo>:</mml:mo><mml:mtext>
</mml:mtext><mml:mi>i</mml:mi><mml:mi>f</mml:mi><mml:mtext>
</mml:mtext></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>I</mml:mi><mml:mo>−</mml:mo><mml:mi>G</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>H</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:munder><mml:mrow><mml:mi>V</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mo>∀</mml:mo><mml:mi>j</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munder><mml:mo>=</mml:mo><mml:mi>G</mml:mi><mml:mtext>
</mml:mtext><mml:mspace width=".3em"/><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mtext>
</mml:mtext><mml:munder><mml:mrow><mml:mi>V</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mo>∀</mml:mo><mml:mi>j</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munder><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
<statement><title>P<sc>roof</sc></title><p>By substitution in the recursive formula for <italic>S</italic>. <inline-formula><mml:math id="I10"><mml:mspace width="5em"/><mml:mo>□</mml:mo></mml:math></inline-formula></p></statement>
</p>
      <p>The recursion for Δ<italic>V</italic> is summarized in the Function Table in <xref ref-type="fig" rid="btu507-F1">Figure 1</xref>. Note the value <italic>I</italic> − <italic>G</italic>, which frequently occurs in the recursion, and the relation <inline-formula><mml:math id="I11"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>H</mml:mi><mml:mo>=</mml:mo><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>. They set the boundaries for the marked zones in the table. These zones comprise (<inline-formula><mml:math id="I12"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:mi>H</mml:mi></mml:mrow></mml:math></inline-formula>) pairs, which determine how the best score of a cell in <italic>S</italic> is obtained in the absence of a match, either as an indel from the left (Zones A and B), a mismatch (Zone C) or an indel from above (Zone D). Borders between zones, indicated by dotted lines, yield ties for the best score. <xref ref-type="fig" rid="btu507-F2">Figure 2</xref> shows how the relative size of the Zones changes with changes in <italic>I</italic> and <italic>G</italic>.
<fig id="btu507-F1" position="float"><label>Fig. 1.</label><caption><p>Zones in the Function Table for Δ<italic>V</italic>. Zone A: all values are in <inline-formula><mml:math id="I13"><mml:mrow><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi>I</mml:mi><mml:mo>−</mml:mo><mml:mi>G</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mi>G</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>; Zone B: all values are in <inline-formula><mml:math id="I14"><mml:mrow><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mtext>low</mml:mtext></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>−</mml:mo><mml:mi>G</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>; Zone C: all values are in <inline-formula><mml:math id="I15"><mml:mrow><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mtext>low</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and values depend only on Δ<italic>H</italic>; Zone D: all values are G; Last row: values also apply when there is a match;. First column: identity column for values in <inline-formula><mml:math id="I16"><mml:mrow><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></p></caption><graphic xlink:href="btu507f1p"/></fig>
<fig id="btu507-F2" position="float"><label>Fig. 2.</label><caption><p>Relative size of Zones as <italic>I</italic> (mismatch penalty) decreases from 2<italic>G</italic> (twice gap penalty) where there is no preference for mismatches, to zero, where mismatches are free and gaps are introduced only to obtain matches</p></caption><graphic xlink:href="btu507f2p"/></fig></p>
    </sec>
  </sec>
  <sec id="SEC3">
    <title>3 ALGORITHM</title>
    <statement>
      <title>D<sc>efinitions</sc></title>
      <p><inline-formula><mml:math id="I17"><mml:mrow><mml:mi>min</mml:mi><mml:mo>=</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mi>max</mml:mi><mml:mo>=</mml:mo><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mtext> mid</mml:mtext><mml:mo>=</mml:mo><mml:mi>I</mml:mi><mml:mo>−</mml:mo><mml:mi>G</mml:mi></mml:mrow></mml:math></inline-formula>, low <inline-formula><mml:math id="I18"><mml:mrow><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi>min</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula><inline-formula><mml:math id="I19"><mml:mrow><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mtext>mid</mml:mtext><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and high <inline-formula><mml:math id="I20"><mml:mrow><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mtext>mid </mml:mtext><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>max</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    </statement>
    <p>For the illustrations in this article, we use the scoring weights:
<disp-formula><mml:math id="UM5"><mml:mrow><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mi>I</mml:mi><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
which yield
<disp-formula><mml:math id="UM6"><mml:mrow><mml:mi>min</mml:mi><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mi>max</mml:mi><mml:mo>=</mml:mo><mml:mn>7</mml:mn><mml:mo>,</mml:mo><mml:mtext> mid</mml:mtext><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
<disp-formula><mml:math id="UM7"><mml:mrow><mml:mtext>low</mml:mtext><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mo>−</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mtext>high</mml:mtext><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>7</mml:mn><mml:mo>}</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
The Δ<italic>V</italic> Function Table for these weights is shown in <xref ref-type="fig" rid="btu507-F3">Figure 3</xref>.
<fig id="btu507-F3" position="float"><label>Fig. 3.</label><caption><p>The Δ<italic>V</italic> Function Table for the weights <inline-formula><mml:math id="I21"><mml:mrow><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mi>I</mml:mi><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mn>5.</mml:mn></mml:mrow></mml:math></inline-formula> Note that <inline-formula><mml:math id="I22"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>7</mml:mn></mml:mrow><mml:mo stretchy="true">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>; <inline-formula><mml:math id="I23"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mtext>low</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mtext>low</mml:mtext></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mo stretchy="true">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>; <inline-formula><mml:math id="I24"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula>; <inline-formula><mml:math id="I25"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>7</mml:mn></mml:mrow></mml:math></inline-formula>. The Δ<italic>H</italic> Function Table is the transpose of this table, i.e. the labels Δ<italic>H</italic> and Δ<italic>V</italic> are swapped</p></caption><graphic xlink:href="btu507f3p"/></fig></p>
    <p>The algorithm proceeds row-by-row through the alignment matrix. For each row, the input is:
<list list-type="bullet"><list-item><p>the Δ<italic>H</italic> values from the preceding row,</p></list-item><list-item><p>the leftmost Δ<italic>V</italic> value in the current row and</p></list-item><list-item><p>the match positions in the current row.</p></list-item></list>
The computation first determines all the remaining Δ<italic>V</italic> values for the current row and then, using those, determines the Δ<italic>H</italic> values for the current row. A central concept is a <italic>run of</italic>
<inline-formula><mml:math id="I26"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><italic>.</italic> This is a set of consecutive positions in the preceding row for which the values of Δ<italic>H</italic> all equal <inline-formula><mml:math id="I27"><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:math></inline-formula> (in <xref ref-type="fig" rid="btu507-F4">Fig. 4</xref>, positions for which <inline-formula><mml:math id="I28"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>H</mml:mi><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula>).
<fig id="btu507-F4" position="float"><label>Fig. 4.</label><caption><p>An example of the calculation of <inline-formula><mml:math id="I29"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>r</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="I30"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>r</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> values. <inline-formula><mml:math id="I31"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> values come from the previous row. The match locations and the leftmost <inline-formula><mml:math id="I32"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>r</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> value are known. The <inline-formula><mml:math id="I33"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>r</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> value for a particular column is found using the table in <xref ref-type="fig" rid="btu507-F3">Figure 3</xref>. The input is the <inline-formula><mml:math id="I34"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> value in the same column and the <inline-formula><mml:math id="I35"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>r</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> value in the column to the left, <italic>except</italic>, when there is a match, the value in the column to the left is treated as a <inline-formula><mml:math id="I36"><mml:mrow><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo></mml:mrow></mml:math></inline-formula> and, starting with Step 3, if the value in the column to the left is not assigned, it is treated as mid. <inline-formula><mml:math id="I37"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><sup>†</sup>is a modification of <inline-formula><mml:math id="I38"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> in which all Match positions have been changed to <inline-formula><mml:math id="I39"><mml:mrow><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo></mml:mrow></mml:math></inline-formula> and all values less than mid have been changed to mid. The <inline-formula><mml:math id="I40"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>r</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> value for a particular column is found using the transpose of the table in <xref ref-type="fig" rid="btu507-F3">Figure 3</xref>. The input is the <inline-formula><mml:math id="I41"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><sup>†</sup>in the same column and the <inline-formula><mml:math id="I42"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>r</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> value in the column to the left</p></caption><graphic xlink:href="btu507f4p"/></fig></p>
    <p>The algorithm has the following steps (see <xref ref-type="fig" rid="btu507-F4">Fig. 4</xref>), which follow from Lemma 2.1.
<list list-type="simple"><list-item><p>1. Find the locations where <inline-formula><mml:math id="I43"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mi>max</mml:mi></mml:mrow></mml:math></inline-formula> (highest value in Zone A):</p></list-item><list-item><p><bold>Step 1A:</bold> because of a match between the characters in Sequence X and Sequence Y. These occur at match locations where <inline-formula><mml:math id="I44"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>H</mml:mi><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mi>.</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><bold>Step 1B:</bold> in any run of <inline-formula><mml:math id="I45"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to the right of a match location in the run.</p></list-item><list-item><p>2. Find the locations where <inline-formula><mml:math id="I46"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>,for<inline-formula><mml:math id="I47"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mtext>mid</mml:mtext><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="I48"><mml:mrow><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>max</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> (the remaining values in Zone A). These are computed in decreasing order of <italic>i</italic>. For each <italic>i</italic>, there are two categories, those locations:</p></list-item><list-item><p><bold>Step 2A:</bold> because of a match or a larger preceding Δ<italic>V</italic> value. These also depend on the Δ<italic>H</italic> value.</p></list-item><list-item><p><bold>Step 2B:</bold> because of the value <italic>i</italic> being carried through a run of <inline-formula><mml:math id="I49"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>min</mml:mi><mml:mi>.</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p>3. Find the locations where <inline-formula><mml:math id="I50"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>, for <inline-formula><mml:math id="I51"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi>min</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mtext>mid</mml:mtext><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> (the values in Zones B and C). These are computed separately for each value <italic>i</italic> and depend on:</p></list-item><list-item><p><bold>Step 3A:</bold> a match or the preceding Δ<italic>V</italic> value and the Δ<italic>H</italic> value (Zone B).</p></list-item><list-item><p><bold>Step 3B:</bold> the Δ<italic>H</italic> value alone (Zone C).</p></list-item><list-item><p>4. Find the locations where <inline-formula><mml:math id="I52"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mi>min</mml:mi></mml:mrow></mml:math></inline-formula> (the values in Zone D). These are:</p></list-item><list-item><p><bold>Step 4:</bold> all the remaining locations with undetermined Δ<italic>V</italic> values.</p></list-item><list-item><p>5. Find the current row locations where the new <inline-formula><mml:math id="I53"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>H</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> for:</p></list-item><list-item><p><bold>Step 5A:</bold><inline-formula><mml:math id="I54"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&gt;</mml:mo><mml:mi>min</mml:mi></mml:mrow></mml:math></inline-formula>.</p></list-item><list-item><p><bold>Step 5B:</bold><inline-formula><mml:math id="I55"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>min</mml:mi></mml:mrow></mml:math></inline-formula>.</p></list-item></list>
</p>
    <p>We describe the simplest case where the length of the first sequence is less than the computer word size <italic>w</italic>. Longer sequences can be handled in ‘chunks’, where each chunk has size <italic>w</italic>. Match positions for every row are computed before the calculation of the row values as is also done for the LCS and edit-distance problems. Details are given at the end.</p>
    <p>We present two algorithms, <bold>BitPAl</bold> and <bold>BitPAl Packed</bold>. They differ in the data structures used to hold and process the Δ<italic>H</italic> and Δ<italic>V</italic> values and their computation of Steps 3, 4 and 5. Correctness theorems for the various steps are presented in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu507/-/DC1">Supplementary Information</ext-link>.</p>
    <sec id="SEC3.1">
      <title>3.1 BitPAl</title>
      <sec>
        <title>Data Structure for BitPAl</title>
        <p>One computer word (sometimes called a vector) represents each possible value of Δ<italic>H</italic> and Δ<italic>V</italic>. Bit <italic>i</italic> in a word refers to column <italic>i</italic> in the alignment scoring matrix. With the weights used for illustration, there are 13 values <inline-formula><mml:math id="I56"><mml:mrow><mml:mo>{</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mi>G</mml:mi><mml:mo>}</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo>−</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>6</mml:mn><mml:mo>,</mml:mo><mml:mn>7</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, and therefore 13 words each, for Δ<italic>H</italic> and Δ<italic>V</italic>.</p>
      </sec>
    </sec>
    <sec>
      <title>Computing the Δ values</title>
      <p>To compute its output values, each cell needs to know its Δ<italic>H</italic> and Δ<italic>V</italic> input values. As in standard left to right processing, the output Δ<italic>V</italic> value from one cell becomes the input value for the cell to its right. All the input Δ<italic>H</italic> values are in the preceding row.</p>
      <sec>
        <title>Zone A</title>
        <p>Inspection of the Function Table (<xref ref-type="fig" rid="btu507-F3">Fig. 3</xref>) reveals that the output values in Zone A are interdependent and require computing in order from high to low. For example, output <inline-formula><mml:math id="I57"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula> can be obtained in two ways from higher Δ<italic>V</italic> input values, <inline-formula><mml:math id="I58"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mn>7</mml:mn><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:mi>H</mml:mi><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="I59"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mn>6</mml:mn><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:mi>H</mml:mi><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. <inline-formula><mml:math id="I60"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula> cannot be obtained from lower Δ<italic>V</italic> input values.</p>
        <p>The leftmost column in the table, <inline-formula><mml:math id="I61"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> (−5 in the example), is an identity column. This means that for runs of <inline-formula><mml:math id="I62"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, an input Δ<italic>V</italic> value yields the identical Δ<italic>V</italic> ouput for every location in the run to the right of the input. For example, if the input <inline-formula><mml:math id="I63"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula> for the leftmost position in a run, then the output Δ<italic>V</italic> for every position in the run is also 5 (see <xref ref-type="fig" rid="btu507-F4">Fig. 4</xref> steps 1B, 2B for 4). Carrying an input value through a run of <inline-formula><mml:math id="I64"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> can be accomplished with an addition (<monospace>+</monospace>) as seen below. Addition is similarly used to solve left-to-right dependency problems in LCS and edit-distance bit-parallel algorithms.</p>
        <p>Note in the bottom row of the Function Table that a match acts as an input <inline-formula><mml:math id="I65"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> (7 in the example), so we will treat the match positions as having input <inline-formula><mml:math id="I66"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
        <p><bold>Steps 1A and 1B:</bold> The locations where <inline-formula><mml:math id="I67"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mi>max</mml:mi></mml:mrow></mml:math></inline-formula>, stored in the <inline-formula><mml:math id="I68"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> vector, are calculated with four operations (<xref ref-type="fig" rid="btu507-F5">Fig. 5</xref>). The locations are shifted one position to the right for input to subsequent calculations. The operations are—(i) an <monospace>AND</monospace> to find <inline-formula><mml:math id="I69"><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:math></inline-formula> because of matches; (ii) an <monospace>ADDITION</monospace> (<monospace>+</monospace>) to carry <inline-formula><mml:math id="I70"><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:math></inline-formula> through runs of <inline-formula><mml:math id="I71"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and into the position following a run (because the result will be shifted). This causes erroneous internal bit flips if there are multiple matches in the same run; (iii) an <monospace>XOR</monospace> with <inline-formula><mml:math id="I72"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to complement the bits within the <inline-formula><mml:math id="I73"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> runs and (iv) an <monospace>XOR</monospace> with the initial <inline-formula><mml:math id="I74"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to correct any erroneous bits and finish the shift by removing the locations set with matches.
<fig id="btu507-F5" position="float"><label>Fig. 5.</label><caption><p>Finding <inline-formula><mml:math id="I75"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. Each line represents a computer word with low order bit, corresponding to the first position in a sequence, on the left. 1s are shown explicitly, 0s are shown only to fill runs of <inline-formula><mml:math id="I76"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and the first position to the right of each run. Symbol <inline-formula><mml:math id="I77"><mml:mrow><mml:mo>&gt;</mml:mo><mml:mo>&gt;</mml:mo></mml:mrow></mml:math></inline-formula> indicates that the final <inline-formula><mml:math id="I78"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> values are shifted to the right one position. Bits erroneously set by the ADDITION (+) are shown in bold. Sample code is from the complete listing in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu507/-/DC1">Supplementary Information</ext-link></p></caption><graphic xlink:href="btu507f5p"/></fig></p>
        <p><bold>Steps 2A and 2B:</bold> Remaining <inline-formula><mml:math id="I79"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> vectors are calculated, in descending order from <inline-formula><mml:math id="I80"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="I81"><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mtext>mid</mml:mtext><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> because of the dependencies as discussed above. The operations are: (i) finding the locations because of a preceding higher Δ<italic>V</italic> value using <monospace>AND</monospace> of appropriate <inline-formula><mml:math id="I82"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:mi>H</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> pairs (which intersect along a common diagonal in the Function Table) and collecting them together with <monospace>OR</monospace>s; (ii) shifting the initial vectors right one position for subsequent calculations; (iii) carrying through runs of <inline-formula><mml:math id="I83"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> computed in two operations, an <monospace>ADDITION</monospace> (<monospace>+</monospace>) as before and an <monospace>XOR</monospace> with <inline-formula><mml:math id="I84"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to complement the bits within the <inline-formula><mml:math id="I85"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> runs (<xref ref-type="fig" rid="btu507-F6">Fig. 6</xref>). Before the addition, those <inline-formula><mml:math id="I86"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> positions that have already output a <inline-formula><mml:math id="I87"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> value must be removed.
<fig id="btu507-F6" position="float"><label>Fig. 6.</label><caption><p>Carry through runs of <inline-formula><mml:math id="I88"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for remaining values in <inline-formula><mml:math id="I89"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula> Symbol <monospace>X</monospace> marks a single position between runs which cannot be 1 in the initial shifted values</p></caption><graphic xlink:href="btu507f6p"/></fig></p>
        <p><bold>Steps 3A and 3B.</bold> (<xref ref-type="fig" rid="btu507-F7">Fig. 7</xref>). At this point, all the <inline-formula><mml:math id="I90"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> input values for Zone B have been computed (they are the outputs from Zone A), remaining output values are all <inline-formula><mml:math id="I91"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mtext>low</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. The operations are: (i) the <monospace>AND</monospace> of appropriate <inline-formula><mml:math id="I92"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:mi>H</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> pairs, which intersect along a common diagonal (Zone B); (ii) the <monospace>AND</monospace> of the appropriate Δ<italic>H</italic> vector and all positions without a <inline-formula><mml:math id="I93"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> output (Zone C); (iii) an <monospace>OR</monospace> combination of the preceding two results and (iv) a shift of the locations one position to the right for subsequent calculations.
<fig id="btu507-F7" position="float"><label>Fig. 7.</label><caption><p>Code for Zones B, C and D</p></caption><graphic xlink:href="btu507f7p"/></fig></p>
        <p><bold>Step 4:</bold> Zone D has only one output value, <inline-formula><mml:math id="I94"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. It is assigned to all remaining locations as well as the zero location if gap penalty in the first column is being used.</p>
        <p><bold>Step 5:</bold> After the Δ<italic>V</italic> values are computed, all inputs are available and the new Δ<italic>H</italic> vectors for the current row can be computed immediately. The Function Table for the new Δ<italic>H</italic> is the transpose of the table for Δ<italic>V</italic>, i.e. the input labels are swapped. Each new Δ<italic>H</italic> vector is obtained by the <monospace>AND</monospace> of appropriate <inline-formula><mml:math id="I95"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Δ</mml:mi><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:mi>H</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> input pairs, which intersect along a common diagonal, collected together with <monospace>OR</monospace>s. Before this can proceed, though, the Match positions must be added to the previous row’s <inline-formula><mml:math id="I96"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> vector (with <monospace>OR</monospace>) and removed from all other previous row Δ<italic>H</italic> vectors. Also, all previous row <inline-formula><mml:math id="I97"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mtext>low</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> locations must be converted to <inline-formula><mml:math id="I98"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mtext>mid</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
    </sec>
    <sec id="SEC3.2">
      <title>3.2 BitPAl Packed</title>
      <sec>
        <title>Data structure for BitPAl packed</title>
        <p>The number of logic operations in BitPAl scales linearly with the size of the function table. Many of these are the AND and OR operations to compute identical values along Zone B diagonals. These calculations can be performed more efficiently with a new representation. The idea is to store the input Δ<italic>H</italic> and Δ<italic>V</italic> values in such a way that they can all be added simultaneously to give the appropriate output values.</p>
        <p>Rather than using bit-vectors to represent single Δ<italic>H</italic> or Δ<italic>V</italic> values, we use them to represent binary digits (<xref ref-type="fig" rid="btu507-F8">Fig. 8</xref>). We map the Δ<italic>V</italic> values <inline-formula><mml:math id="I99"><mml:mrow><mml:mo>{</mml:mo><mml:mi>min</mml:mi><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>max</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> one-to-one onto the positive values <inline-formula><mml:math id="I100"><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>max</mml:mi><mml:mo>−</mml:mo><mml:mi>min</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and store them in the vectors <inline-formula><mml:math id="I101"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> etc. where <italic>p<sub>i</sub></italic> is the place holder for the <italic>i</italic>th power of 2. The mapping for Δ<italic>H</italic> is onto negative numbers, i.e. <inline-formula><mml:math id="I102"><mml:mrow><mml:mo>{</mml:mo><mml:mi>min</mml:mi><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>max</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> are mapped to <inline-formula><mml:math id="I103"><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>max</mml:mi><mml:mo>−</mml:mo><mml:mi>min</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and stored in vectors <inline-formula><mml:math id="I104"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> etc. After addition, the sums will fall in <inline-formula><mml:math id="I105"><mml:mrow><mml:mo>{</mml:mo><mml:mo>−</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>max</mml:mi><mml:mo>−</mml:mo><mml:mi>min</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>max</mml:mi><mml:mo>−</mml:mo><mml:mi>min</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, so we use <inline-formula><mml:math id="I106"><mml:mrow><mml:mrow><mml:mo stretchy="true">⌈</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>log</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">(</mml:mo><mml:mi>max</mml:mi><mml:mo>−</mml:mo><mml:mi>min</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="true">⌉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> bit-vectors for Δ<italic>H</italic> and Δ<italic>V</italic>. For our example, the Δ<italic>V</italic> values are mapped to <inline-formula><mml:math id="I107"><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>12</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, the Δ<italic>H</italic> values are mapped to <inline-formula><mml:math id="I108"><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mn>12</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and the sums fall within <inline-formula><mml:math id="I109"><mml:mrow><mml:mo>{</mml:mo><mml:mo>−</mml:mo><mml:mn>12</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>12</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, so we use five vectors each for Δ<italic>H</italic> and Δ<italic>V</italic>.
<fig id="btu507-F8" position="float"><label>Fig. 8.</label><caption><p>Top: The BitPAl Packed mapping of Δ<italic>H</italic> and Δ<italic>V</italic> values for the parameter set <inline-formula><mml:math id="I110"><mml:mrow><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula>. Middle: conversion from the 13 <inline-formula><mml:math id="I111"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> vectors at left to the five ‘packed’ vectors at right. Bottom: example code for adding the packed representation</p></caption><graphic xlink:href="btu507f8p"/></fig></p>
        <p>BitPAl Packed does not change the computation of the Δ<italic>V</italic> values in Zone A. The Δ<italic>H</italic> values are always maintained in the packed representation, but some are unpacked into the original representation for the Zone A computations. Once Steps 1 and 2 are completed, all locations without a Δ<italic>V</italic> value are set to mid, all match locations are set to <inline-formula><mml:math id="I112"><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:math></inline-formula>, and the Δ<italic>V</italic> values are converted into the packed representation.</p>
        <p>Steps 3 and 4 are computed by ‘adding’ together the two sets of packed vectors using a series of <monospace>AND</monospace>, <monospace>OR</monospace> and <monospace>XOR</monospace> operations (<xref ref-type="fig" rid="btu507-F8">Fig. 8</xref>) to produce the final encoded values for Δ<italic>V</italic>. Any negative values (sign bit set) are converted to <inline-formula><mml:math id="I113"><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:math></inline-formula> (Zone D). For Step 5, the new Δ<italic>H</italic> values are determined with a second addition. Because all input Δ<italic>H</italic> in the range <inline-formula><mml:math id="I114"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>min</mml:mi><mml:mo>,</mml:mo><mml:mtext>mid</mml:mtext><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> give the same result, we first re-encode that range to mid.</p>
      </sec>
      <sec>
        <title>Packing and unpacking</title>
        <p>Packing Δ<italic>V</italic> vectors involves identifying the locations where the binary representation of the encoded values all have a specific bit set. For example, the binary representations for 1, 3, 5, 7, 9 and 11 all have the bit representing 2<sup>0</sup> set, and the binary representations for 2, 3, 6, 7, 10 and 11 all have the bit representing 2<sup>1</sup> set. Effectively then,
<disp-formula><mml:math id="UM8"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mtext> OR </mml:mtext><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mtext> OR </mml:mtext><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mn>5</mml:mn></mml:msub><mml:mtext> OR </mml:mtext><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mn>7</mml:mn></mml:msub><mml:mtext> OR </mml:mtext><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mn>9</mml:mn></mml:msub><mml:mtext> OR </mml:mtext><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></disp-formula>
<disp-formula><mml:math id="UM9"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mtext> OR </mml:mtext><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mtext> OR </mml:mtext><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mn>6</mml:mn></mml:msub><mml:mtext> OR </mml:mtext><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mn>7</mml:mn></mml:msub><mml:mtext> OR </mml:mtext><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:msub><mml:mtext> OR </mml:mtext><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></disp-formula>
<disp-formula><mml:math id="UM10"><mml:mrow><mml:mtext>etc</mml:mtext><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
where <inline-formula><mml:math id="I115"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the vector of locations with encoded value <italic>i</italic>. However, as can be seen for these two examples, there are common terms (<inline-formula><mml:math id="I116"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mn>7</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>), so combining the terms as above leads to inefficiencies.</p>
        <p>Unpacking the Δ<italic>H</italic> vectors involves identifying locations of specific encoded values from the binary representation vectors. For example, the <inline-formula><mml:math id="I117"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> locations are those (using two’s complement, −1 = 11 111) that have all bits set and <inline-formula><mml:math id="I118"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> locations are those (using two’s complement, −2 = 11 110) that have all but the lowest bit set. Again, effectively
<disp-formula><mml:math id="UM11"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mtext> &amp; </mml:mtext><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mtext> &amp; </mml:mtext><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mtext> &amp; </mml:mtext><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mtext> &amp; </mml:mtext><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>4</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></disp-formula>
<disp-formula><mml:math id="UM12"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mtext>
</mml:mtext><mml:mo>∼</mml:mo><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mtext> &amp; </mml:mtext><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mtext> &amp; </mml:mtext><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mtext> &amp; </mml:mtext><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mtext> &amp; </mml:mtext><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mn>4</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></disp-formula>
<disp-formula><mml:math id="UM13"><mml:mrow><mml:mtext>etc</mml:mtext><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
Again, there are common terms that can be combined to avoid inefficiencies. For both packing and unpacking, we use a binary tree structure in the code generator to guide creation of temporary intermediate vectors so that operations are not duplicated.</p>
      </sec>
    </sec>
    <sec id="SEC3.3">
      <title>3.3 Other tasks</title>
      <sec>
        <title>Determining matches</title>
        <p>As a preprocessing step, the position of the matches are determined for each character <italic>σ</italic> in the sequence alphabet. A bit vector <inline-formula><mml:math id="I119"><mml:mrow><mml:mi>M</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>c</mml:mi><mml:msub><mml:mi>h</mml:mi><mml:mi>σ</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> records those positions in sequence <italic>X</italic> where <italic>σ</italic> occurs. Filling all the <inline-formula><mml:math id="I120"><mml:mrow><mml:mi>M</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>c</mml:mi><mml:msub><mml:mi>h</mml:mi><mml:mi>σ</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> simultaneously can be accomplished efficiently in a single pass through <italic>X</italic>.</p>
      </sec>
      <sec>
        <title>Decoding the alignment score</title>
        <p>The score in the last column of the last row of the alignment scoring matrix can be obtained by calculating the score in the zero column (<inline-formula><mml:math id="I121"><mml:mrow><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mo>*</mml:mo><mml:mi>G</mml:mi></mml:mrow></mml:math></inline-formula>) and then adding the number of 1 bits in each of the Δ<italic>H</italic> vectors multiplied by the value of the vector. Using the method described in (<xref rid="btu507-B11" ref-type="bibr">Kernighan and Ritchie, 1988</xref>), this takes <inline-formula><mml:math id="I122"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> operations with a small constant:
<disp-formula><mml:math id="UM14"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mo>*</mml:mo><mml:mi>G</mml:mi><mml:mo>+</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mi>G</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mtext>bits</mml:mtext></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>*</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></disp-formula>
where <inline-formula><mml:math id="I123"><mml:mrow><mml:msub><mml:mrow><mml:mtext>bits</mml:mtext></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the number of 1 bits set in <inline-formula><mml:math id="I124"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
        <p>For BitPAl Packed, the alignment score can similarly be computed in <inline-formula><mml:math id="I125"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>·</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> operations
<disp-formula><mml:math id="UM15"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mo>*</mml:mo><mml:mi>G</mml:mi><mml:mo>+</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mtext>pbits</mml:mtext></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>*</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
where pbits<sub><italic>i</italic></sub> is the number of 1 bits set in <inline-formula><mml:math id="I126"><mml:mrow><mml:mi>Δ</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, and <italic>k</italic> is the number of bit vectors in the packed representation.</p>
        <p>Several straightforward methods can be used to efficiently find all scores in the last row or last column.</p>
      </sec>
    </sec>
    <sec id="SEC3.4">
      <title>3.4 Complexity and number of operations</title>
      <p>The time complexity of our algorithms is <inline-formula><mml:math id="I127"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mi>n</mml:mi><mml:mi>m</mml:mi><mml:mo>/</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> where <italic>z</italic> depends on the version. For BitPAl standard, <italic>z</italic> represents the combined size of Zones A, B and C (the latter reduced to a single row as in <xref ref-type="fig" rid="btu507-F3">Fig. 3</xref>) in the Function Table. This in turn depends on the alignment weights <italic>M</italic>, <italic>I</italic> and <italic>G</italic>:
<disp-formula><mml:math id="UM16"><mml:mrow><mml:mi>z</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>G</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>I</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:math></disp-formula>
and the constant hidden in the big O notation is ∼4 (dominated by two operations per cell of Zones A, B and C for Δ<italic>V</italic> and separately for Δ<italic>H</italic>). For the example weights used in this article, the number of logic and addition operations, <italic>p</italic>, per word is 265, yielding an efficiency of <inline-formula><mml:math id="I128"><mml:mrow><mml:mn>64</mml:mn><mml:mo>/</mml:mo><mml:mn>265</mml:mn><mml:mo>≈</mml:mo><mml:mn>0.24</mml:mn></mml:mrow></mml:math></inline-formula> cells per operation with 64 bit words.</p>
      <p>For the packed version, <italic>z</italic> represents the size of Zone A, the number of distinct Δ<italic>H</italic> and Δ<italic>V</italic> values for the packing and unpacking steps, and the binary log of the number of distinct values for the addition steps:
<disp-formula><mml:math id="UM17"><mml:mrow><mml:mi>z</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>G</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>log</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>G</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
</p>
      <p>Unlike the standard version, the term constants are not uniform (∼2, 2 and 12, respectively). For the example weights used in this article, the number of logic and addition operations, <italic>p</italic>, per word is 166, yielding an efficiency of <inline-formula><mml:math id="I129"><mml:mrow><mml:mn>64</mml:mn><mml:mo>/</mml:mo><mml:mn>166</mml:mn><mml:mo>≈</mml:mo><mml:mn>0.38</mml:mn></mml:mrow></mml:math></inline-formula> cells per operation for 64 bit words. See <xref ref-type="fig" rid="btu507-F9">Figure 9</xref> for a comparison of the number of operations required by the two algorithms for different alignment weights.
<fig id="btu507-F9" position="float"><label>Fig. 9.</label><caption><p>Comparison of the number of operations for BitPAl and BitPAl packed for different alignment weights (M, I, G)</p></caption><graphic xlink:href="btu507f9p"/></fig></p>
    </sec>
    <sec>
      <title>Implementation</title>
      <p>Each unique set of weights <italic>M</italic>, <italic>I</italic> and <italic>G</italic> requires a uniquely tailored program. To simplify usage, we have constructed a Web site <ext-link ext-link-type="uri" xlink:href="http://lobstah.bu.edu/BitPAl/BitPAl.html">http://lobstah.bu.edu/BitPAl/BitPAl.html</ext-link> that generates C source code for download. The Web site takes as input the user’s alignment weights, the algorithm version (standard or packed), whether it will be used for short sequences (single word) or long sequences (multiple word) and where the final score should be found.</p>
    </sec>
  </sec>
  <sec>
    <title>4 EXPERIMENTAL RESULTS</title>
    <p>We compared running times for several bit-parallel algorithms using different alignment weights: (i) BitPal, (ii) BitPAl Packed, (iii) NW—the classical <xref rid="btu507-B14" ref-type="bibr">Needleman and Wunch (1970)</xref> dynamic programming alignment algorithm, (iv) LCS—the bit-parallel LCS algorithm of <xref rid="btu507-B7" ref-type="bibr">Hyyrö (2004)</xref>, (v) ED—our improved bit-parallel, unit-cost edit-distance algorithm from the method of <xref rid="btu507-B10" ref-type="bibr">Hyyrö <italic>et al.</italic> (2005)</xref> and <xref rid="btu507-B12" ref-type="bibr">Myers (1999)</xref>, (vi) WM—the unit-cost (<xref rid="btu507-B16" ref-type="bibr">Wu and Manber, 1992</xref>) approximate pattern matching algorithm and (vii) N—the (<xref rid="btu507-B13" ref-type="bibr">Navarro, 2004</xref>) general integer scoring, approximate regular expression matching algorithm. We implemented BitPAl, BitPAl Packed, NW, LCS, ED and WM. N was graciously provided by Gonzalo Navarro.</p>
    <p>For all experiments, we used human DNA and ran 100 pattern sequences against 250 000 text sequences for a total of 25 million alignments. (Pattern and text distinctions are irrelevant for BitPAl, BitPAl Packed, NW, LCS and ED.) All sequences were 63 characters long. For WM, we varied <italic>k</italic>, the maximum number of allowed errors, from 1 to 15. For N, we varied <italic>k</italic> from 1 to 12. All programs were compiled with GCC using optimization level O3 and were run on an Intel Core 2 Duo E8400 3.0 GHz CPU running Ubuntu Linux 12.10. Results are shown in <xref ref-type="fig" rid="btu507-F10">Figure 10</xref> and <xref ref-type="table" rid="btu507-T1">Table 1</xref>.
<fig id="btu507-F10" position="float"><label>Fig. 10.</label><caption><p><bold>Running times.</bold> Each experiment involved 25 million alignments. For BitPAl and BitPAl Packed, alignment weights (M, I, G) are shown in parenthesis. All times are averages of three runs. <bold>Left:</bold> unit-cost BitPAl, unit-cost WM, LCS and ED. <italic>k</italic> is the maximum number of errors allowed for WM. <italic>k</italic> is not a parameter for the other algorithms and their times are shown as horizontal lines. LCS uses 4 bit operations per <italic>w</italic> cells, ED uses 15 bit operations, BitPAl (0, −1, −1) uses 23 bit operations. For <italic>k</italic> = 7, the times for BitPal and WM are nearly the same. By <italic>k</italic> = 15, BitPAl runs approximately twice as fast. Results for N are not shown on the graph. It was 118–304 times slower than BitPAl (0, −1, −1) even when optimal parameters were chosen. <bold>Right:</bold> variants of BitPAl and NW (shown as a horizontal line). For BitPAl, time is approximately linearly proportional to one dimension of the function table. For BitPAl packed, time is approximately linearly proportional to the area of the function tables. BitPAl packed (2, −3, −5) is ∼7.1 times faster than NW and BitPAl (0, −1, −1) is ∼24.9 times faster</p></caption><graphic xlink:href="btu507f10p"/></fig>
<table-wrap id="btu507-T1" position="float"><label>Table 1.</label><caption><p>Table of run times in minutes</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="2" colspan="1">Algorithm</th><th align="center" colspan="5" rowspan="1">Parameters (M, I, G)<hr/></th></tr><tr><th rowspan="1" colspan="1">0, −1, −1</th><th rowspan="1" colspan="1">2, −3, 5</th><th rowspan="1" colspan="1">3, −4, −6</th><th rowspan="1" colspan="1">4, −5, −9</th><th rowspan="1" colspan="1">4, −7, −11</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">BitPAl</td><td rowspan="1" colspan="1">0.284000</td><td rowspan="1" colspan="1">1.903778</td><td rowspan="1" colspan="1">2.702000</td><td rowspan="1" colspan="1">5.408722</td><td rowspan="1" colspan="1">8.517500</td></tr><tr><td rowspan="1" colspan="1">BitPAl Packed</td><td rowspan="1" colspan="1">0.390500</td><td rowspan="1" colspan="1">0.999945</td><td rowspan="1" colspan="1">1.126500</td><td rowspan="1" colspan="1">1.475222</td><td rowspan="1" colspan="1">1.755500</td></tr></tbody></table><table-wrap-foot><fn id="btu507-TF1"><p><italic>Note</italic>. Shown are averages over three trials for 25 million alignments. Needleman–Wunsch has the same runtime for all parameters, 7.056056 min.</p></fn></table-wrap-foot></table-wrap></p>
  </sec>
  <sec>
    <title>5 DISCUSSION</title>
    <p>The BitPAl and BitPAl packed algorithms outlined above can be extended in several ways. Computers now in common usage have special 128 bit SIMD registers (Single Instruction, Multiple Data). Using these, with the addition of several bookkeeping operations, would essentially double the efficiency and the speed of computation. Another extension derives from the unexploited parallelism of the operations. There are no dependencies on prior computations after the Δ<italic>V</italic> vectors in Zone A are computed. This means that all the computations in Zones B, C and D for Δ<italic>V</italic> and all the subsequent computations for Δ<italic>H</italic> can be done simultaneously, an ideal situation for the use of general purpose graphical processing units (GPGPU).</p>
    <p>Another possible extension expands the types of scoring schemes allowed. BLOSUM type scoring, which is useful for protein alignments, eliminates match and mismatch scoring and instead assigns different substitution weights to each pair of characters. Affine-gap scoring replaces single character indel scoring with gap initiation and gap extension weights.</p>
    <p>Extension to local alignment is also possible. This is a different class of problem in that the best final alignment score can occur in any cell of the alignment matrix. If all the cells have to be examined, then the time complexity shifts back to <italic>O</italic>(<italic>nm</italic>). <xref rid="btu507-B9" ref-type="bibr">Hyyrö and Navarro (2006)</xref> had some success with this problem using unit cost weights and identifying <italic>columns</italic> in which the score of at least one cell exceeds a predefined threshold <italic>k</italic>.</p>
    <p>The BitPAl methods have already been used to accelerate software for detecting tandem repeat variants in high-throughput sequencing data (<xref rid="btu507-B6" ref-type="bibr">Gelfand <italic>et al.</italic>, 2014</xref>) and are well-suited to other DNA sequence comparison tasks that involve computing many alignments.</p>
    <p><italic>Funding</italic>: This work was supported by the <funding-source>National Science Foundation</funding-source> (<award-id>IIS-1017621</award-id> to G.B., <award-id>DGE-0654108</award-id> to J.L. and Y.H.).</p>
    <p><italic>Conflict of interest</italic>: none declared.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="PMC_1" content-type="local-data">
      <caption>
        <title>Supplementary Data</title>
      </caption>
      <media mimetype="text" mime-subtype="html" xlink:href="supp_30_22_3166__index.html"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="pdf" xlink:href="supp_btu507_appendix.pdf"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="btu507-B1">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Allison</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Dix</surname>
            <given-names>TI</given-names>
          </name>
        </person-group>
        <article-title>A bit-string longest-common-subsequence algorithm</article-title>
        <source>Inf. Process. Lett.</source>
        <year>1986</year>
        <volume>23</volume>
        <fpage>305</fpage>
        <lpage>310</lpage>
      </element-citation>
    </ref>
    <ref id="btu507-B2">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Baeza-Yates</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Gonnet</surname>
            <given-names>GH</given-names>
          </name>
        </person-group>
        <article-title>A new approach to text searching</article-title>
        <source>Commun. ACM</source>
        <year>1992</year>
        <volume>35</volume>
        <fpage>74</fpage>
        <lpage>82</lpage>
      </element-citation>
    </ref>
    <ref id="btu507-B3">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Benson</surname>
            <given-names>G</given-names>
          </name>
          <etal/>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Fischer</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Sanders</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>A bit-parallel, general integer-scoring sequence alignment algorithm</article-title>
        <source>Combinatorial Pattern Matching, Vol. 7922 of Lecture Notes in Computer Science</source>
        <year>2013</year>
        <publisher-loc>Berlin, Heidelberg</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>50</fpage>
        <lpage>61</lpage>
      </element-citation>
    </ref>
    <ref id="btu507-B4">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bergeron</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Hamel</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Vector algorithms for approximate string matching</article-title>
        <source>Int. J. Found. Comput. Sci.</source>
        <year>2002</year>
        <volume>13</volume>
        <fpage>53</fpage>
        <lpage>65</lpage>
      </element-citation>
    </ref>
    <ref id="btu507-B5">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Crochemore</surname>
            <given-names>M</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A fast and practical bit-vector algorithm for the longest common subsequence problem</article-title>
        <source>Inform. Process. Lett.</source>
        <year>2001</year>
        <volume>80</volume>
        <fpage>279</fpage>
        <lpage>285</lpage>
      </element-citation>
    </ref>
    <ref id="btu507-B6">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gelfand</surname>
            <given-names>Y</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>VNTRseek-a computational tool to detect tandem repeat variants in high-throughput sequencing data</article-title>
        <source>Nucleic Acids Res</source>
        <year>2014</year>
        <comment>doi: 10.1093/nar/gku642</comment>
      </element-citation>
    </ref>
    <ref id="btu507-B7">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Hyyrö</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Bit-parallel LCS-length computation revisited</article-title>
        <source>Proceedings of the 15th Australasian Workshop on Combinatorial Algorithms (AWOCA 2004)</source>
        <year>2004</year>
        <publisher-loc>Australia</publisher-loc>
        <publisher-name>University of Sydney</publisher-name>
      </element-citation>
    </ref>
    <ref id="btu507-B8">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hyyrö</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Navarro</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Bit-parallel witnesses and their applications to approximate string matching</article-title>
        <source>Algorithmica</source>
        <year>2005</year>
        <volume>41</volume>
        <fpage>203</fpage>
        <lpage>231</lpage>
      </element-citation>
    </ref>
    <ref id="btu507-B9">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hyyrö</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Navarro</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Bit-parallel computation of local similarity score matrices with unitary weights</article-title>
        <source>Int. J. Found. Comput. Sci.</source>
        <year>2006</year>
        <volume>17</volume>
        <fpage>1325</fpage>
        <lpage>1344</lpage>
      </element-citation>
    </ref>
    <ref id="btu507-B10">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hyyrö</surname>
            <given-names>H</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Increased bit-parallelism for approximate and multiple string matching</article-title>
        <source>J. Exp. Algorithmics</source>
        <year>2005</year>
        <volume>10</volume>
        <fpage>2</fpage>
        <lpage>6</lpage>
      </element-citation>
    </ref>
    <ref id="btu507-B11">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Kernighan</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Ritchie</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <source>The C Programming Language</source>
        <year>1988</year>
        <edition>2nd edn</edition>
        <publisher-loc>Upper Saddle River, NJ, USA</publisher-loc>
        <publisher-name>Prentice Hall</publisher-name>
      </element-citation>
    </ref>
    <ref id="btu507-B12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Myers</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>A fast bit-vector algorithm for approximate string matching based on dynamic programming</article-title>
        <source>J. ACM</source>
        <year>1999</year>
        <volume>46</volume>
        <fpage>395</fpage>
        <lpage>415</lpage>
      </element-citation>
    </ref>
    <ref id="btu507-B13">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Navarro</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Approximate regular expression searching with arbitrary integer weights</article-title>
        <source>Nordic J. Comput.</source>
        <year>2004</year>
        <volume>11</volume>
        <fpage>356</fpage>
        <lpage>373</lpage>
      </element-citation>
    </ref>
    <ref id="btu507-B14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Needleman</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Wunch</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>A general method applicable to the search for similarities in the amino acid sequence of two proteins</article-title>
        <source>J. Mol. Biol.</source>
        <year>1970</year>
        <volume>48</volume>
        <fpage>443</fpage>
        <lpage>453</lpage>
        <pub-id pub-id-type="pmid">5420325</pub-id>
      </element-citation>
    </ref>
    <ref id="btu507-B15">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smith</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Identification of common molecular subsequences</article-title>
        <source>J. Mol. Biol.</source>
        <year>1981</year>
        <volume>147</volume>
        <fpage>195</fpage>
        <lpage>197</lpage>
        <pub-id pub-id-type="pmid">7265238</pub-id>
      </element-citation>
    </ref>
    <ref id="btu507-B16">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wu</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Manber</surname>
            <given-names>U</given-names>
          </name>
        </person-group>
        <article-title>Fast text searching: allowing errors</article-title>
        <source>Commun. ACM</source>
        <year>1992</year>
        <volume>35</volume>
        <fpage>83</fpage>
        <lpage>91</lpage>
      </element-citation>
    </ref>
    <ref id="btu507-B17">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wu</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A subquadratic algorithm for approximate limited expression matching</article-title>
        <source>Algorithmica</source>
        <year>1996</year>
        <volume>15</volume>
        <fpage>50</fpage>
        <lpage>67</lpage>
      </element-citation>
    </ref>
  </ref-list>
</back>
