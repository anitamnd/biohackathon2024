<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10311335</article-id>
    <article-id pub-id-type="pmid">37387132</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad218</article-id>
    <article-id pub-id-type="publisher-id">btad218</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Genome Sequence Analysis</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Seeding with minimized subsequence</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Li</surname>
          <given-names>Xiang</given-names>
        </name>
        <aff><institution>Department of Computer Science and Engineering, The Pennsylvania State University, University Park</institution>, PA 16802, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Shi</surname>
          <given-names>Qian</given-names>
        </name>
        <aff><institution>Department of Computer Science and Engineering, The Pennsylvania State University, University Park</institution>, PA 16802, <country country="US">USA</country></aff>
        <xref rid="btad218-FM1" ref-type="author-notes"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Chen</surname>
          <given-names>Ke</given-names>
        </name>
        <aff><institution>Department of Computer Science and Engineering, The Pennsylvania State University, University Park</institution>, PA 16802, <country country="US">USA</country></aff>
        <xref rid="btad218-FM1" ref-type="author-notes"/>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Shao</surname>
          <given-names>Mingfu</given-names>
        </name>
        <aff><institution>Department of Computer Science and Engineering, The Pennsylvania State University, University Park</institution>, PA 16802, <country country="US">USA</country></aff>
        <aff><institution>Huck Institutes of the Life Sciences, The Pennsylvania State University, University Park</institution>, PA 16802, <country country="US">USA</country></aff>
        <xref rid="btad218-cor1" ref-type="corresp"/>
        <!--mxs2589@psu.edu-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad218-cor1">Corresponding author. Department of Computer Science and Engineering, The Pennsylvania State University, W205A Westgate Building, University Park, PA 16802, USA. E-mail: <email>mxs2589@psu.edu</email> (M.S.)</corresp>
      <fn id="btad218-FM1">
        <p>Qian Shi and Ke Chen Equal contribution.</p>
      </fn>
    </author-notes>
    <pub-date pub-type="collection">
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-06-30">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB/ECCB 2023 Proceedings</issue-title>
    <fpage>i232</fpage>
    <lpage>i241</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad218.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Modern methods for computation-intensive tasks in sequence analysis (e.g. read mapping, sequence alignment, genome assembly, etc.) often first transform each sequence into a list of short, regular-length seeds so that compact data structures and efficient algorithms can be employed to handle the ever-growing large-scale data. Seeding methods using <italic toggle="yes">k</italic>mers (substrings of length <italic toggle="yes">k</italic>) have gained tremendous success in processing sequencing data with low mutation/error rates. However, they are much less effective for sequencing data with high error rates as <italic toggle="yes">k</italic>mers cannot tolerate errors.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We propose SubseqHash, a strategy that uses subsequences, rather than substrings, as seeds. Formally, SubseqHash maps a string of length <italic toggle="yes">n</italic> to its smallest subsequence of length <italic toggle="yes">k</italic>, <italic toggle="yes">k </italic>&lt;<italic toggle="yes"> n</italic>, according to a given order overall length-<italic toggle="yes">k</italic> strings. Finding the smallest subsequence of a string by enumeration is impractical as the number of subsequences grows exponentially. To overcome this barrier, we propose a novel algorithmic framework that consists of a specifically designed order (termed ABC order) and an algorithm that computes the minimized subsequence under an ABC order in polynomial time. We first show that the ABC order exhibits the desired property and the probability of hash collision using the ABC order is close to the Jaccard index. We then show that SubseqHash overwhelmingly outperforms the substring-based seeding methods in producing high-quality seed-matches for three critical applications: read mapping, sequence alignment, and overlap detection. SubseqHash presents a major algorithmic breakthrough for tackling the high error rates and we expect it to be widely adapted for long-reads analysis.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>SubseqHash is freely available at <ext-link xlink:href="https://github.com/Shao-Group/subseqhash" ext-link-type="uri">https://github.com/Shao-Group/subseqhash</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Science Foundation</institution>
            <institution-id institution-id-type="DOI">10.13039/100000001</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>2019797</award-id>
        <award-id>2145171</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Institutes of Health</institution>
            <institution-id institution-id-type="DOI">10.13039/100000002</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>R01HG011065</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="10"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Transforming a sequence into a list of seeds (also known as markers) that are then processed in place of the original sequence is a common approach in sequence analysis as a remedy for the dreadfully expensive full-length comparisons. The resulting seeds of such a transformation are often regular in length and much shorter than the original sequences, making it possible to apply efficient data structures and fast algorithms. For example, in read mapping, the popular seed-and-extend strategy (<xref rid="btad218-B2" ref-type="bibr">Altschul et al. 1990</xref>, <xref rid="btad218-B3" ref-type="bibr">1997</xref>) first identifies seed-matches (i.e. pairs of identical seeds; also known as anchors) between a read and a reference, then performs local alignment around these seeds to look for statistically significant matches. In sequence alignment, seed-matches across sequences are first identified, followed by efficient chaining algorithms to find a co-linear chain of matching seeds that maximizes a scoring function (<xref rid="btad218-B29" ref-type="bibr">Myers and Miller 1995</xref>; <xref rid="btad218-B1" ref-type="bibr">Abouelhoda and Ohlebusch 2005</xref>; <xref rid="btad218-B17" ref-type="bibr">Jain et al. 2022</xref>). In genome assembly, a (sparse) de Bruijn graph can be constructed in which seeds are used as vertices and two seeds are linked by an edge if they are adjacent in some reads (<xref rid="btad218-B23" ref-type="bibr">Lin et al. 2016</xref>; <xref rid="btad218-B36" ref-type="bibr">Ruan and Li 2020</xref>; <xref rid="btad218-B14" ref-type="bibr">Ekim et al. 2021</xref>; <xref rid="btad218-B32" ref-type="bibr">Rautiainen and Marschall 2021</xref>; <xref rid="btad218-B4" ref-type="bibr">Bankevich et al. 2022</xref>). To mitigate all-versus-all pairwise comparisons in applications, such as aligning multiple sequences and constructing overlap/string graphs (<xref rid="btad218-B19" ref-type="bibr">Koren et al. 2017</xref>; <xref rid="btad218-B30" ref-type="bibr">Nurk et al. 2020</xref>; <xref rid="btad218-B9" ref-type="bibr">Cheng et al. 2021</xref>), seeds can be used to bucket sequences (i.e. assigning a sequence into buckets labeled by its own seeds), followed by pairwise comparisons in individual buckets (<xref rid="btad218-B5" ref-type="bibr">Berlin et al. 2015</xref>; <xref rid="btad218-B40" ref-type="bibr">Song et al. 2020</xref>). The efficiency and accuracy of these methods heavily rely on the quality of the generated seeds. Desired properties include high sensitivity (i.e. biologically related sequences producing many seed-matches) and a low false positive rate (i.e. unrelated sequences producing few seed-matches).</p>
    <p>Arguably the most widely used seeds are simply <italic toggle="yes">k</italic>mers (i.e. substrings of fixed length <italic toggle="yes">k</italic>). Sketching approaches, such as Minimizers (<xref rid="btad218-B39" ref-type="bibr">Schleimer et al. 2003</xref>; <xref rid="btad218-B34" ref-type="bibr">Roberts et al. 2004a</xref>,<xref rid="btad218-B35" ref-type="bibr">b</xref>; <xref rid="btad218-B27" ref-type="bibr">Marçais et al. 2018</xref>) or syncmers (<xref rid="btad218-B13" ref-type="bibr">Edgar 2021</xref>), are often combined to select a subset of <italic toggle="yes">k</italic>mers aiming for scaling. Seeding methods using <italic toggle="yes">k</italic>mers have gained success in almost all aspects of sequence analysis especially on data with low error rates. However, requiring exact matches of <italic toggle="yes">k</italic> consecutive characters becomes less effective in comparing biologically related sequences with high mutation rates or error rates. Such scenarios include comparing homologous genes or whole genomes from distant species and processing long-read sequencing data generated by PacBio (<xref rid="btad218-B33" ref-type="bibr">Rhoads and Au 2015</xref>) and Oxford Nanopore (<xref rid="btad218-B18" ref-type="bibr">Jain et al. 2018</xref>) technologies. Observe that a single mutation/error can change <italic toggle="yes">k</italic> consecutive <italic toggle="yes">k</italic>mers in the sequence and the probability of a <italic toggle="yes">k</italic>mer remaining intact under a uniform mutation model decreases exponentially as <italic toggle="yes">k</italic> grows (<xref rid="btad218-B6" ref-type="bibr">Blanca et al. 2022</xref>). This greatly challenges the <italic toggle="yes">k</italic>mer-based seeding methods and puts them in a dilemma: choosing a large <italic toggle="yes">k</italic> results in few seed-matches even in biologically related sequences (i.e. low sensitivity), while making <italic toggle="yes">k</italic> too small suffers from a high false positive rate as unrelated sequences can, by chance, share many short common substrings. Existing tools, such as KmerGenie (<xref rid="btad218-B10" ref-type="bibr">Chikhi and Medvedev 2014</xref>), help select a size of <italic toggle="yes">k</italic>mers that balances its sensitivity and false positive rate based on the data. But due to the intrinsic weakness of <italic toggle="yes">k</italic>mers against mutations, even an optimal choice of <italic toggle="yes">k</italic> can still produce unsatisfactory results.</p>
    <p>Alternative approaches have been proposed to collect non-consecutive characters as seeds. Spaced seeds (<xref rid="btad218-B8" ref-type="bibr">Califano and Rigoutsos 1993</xref>; <xref rid="btad218-B24" ref-type="bibr">Ma et al. 2002</xref>) are extracted by applying a predefined pattern, such as 1110111 on a string where a 1 means the character at that position is taken and a 0 means it is ignored/masked. The masked positions allow seed-matches to occur over substitutions, but because of the fixed pattern, spaced seeds can only handle substitutions at predefined locations and are still vulnerable to insertions and deletions (indels). Indel seeds (<xref rid="btad218-B26" ref-type="bibr">Mak et al. 2006</xref>) use patterns with wild-cards to accommodate certain numbers of indels. But again only indels at the predefined regions can be managed. Using multiple patterns (<xref rid="btad218-B22" ref-type="bibr">Li et al. 2004</xref>; <xref rid="btad218-B20" ref-type="bibr">Kucherov et al. 2005</xref>; <xref rid="btad218-B41" ref-type="bibr">Sun and Buhler 2005</xref>; <xref rid="btad218-B15" ref-type="bibr">Farach-Colton et al. 2007</xref>) alleviates the restrictions of a single pattern at the cost of more computations but still cannot handle mutations/errors at arbitrary locations.</p>
    <p>It is also worth mentioning that there have been successful seeding methods that combine two or more pre-extracted (shorter) seeds. For example, grouped methods (<xref rid="btad218-B12" ref-type="bibr">Du et al. 2019</xref>) use two or more independently produced <italic toggle="yes">k</italic>mers as seeds. The Order Min Hash approach (<xref rid="btad218-B28" ref-type="bibr">Marçais et al. 2019</xref>) selects multiple <italic toggle="yes">k</italic>mers from a sequence with relative positions preserved. The recently proposed <italic toggle="yes">k</italic>mer-alternative method strobemer and its variants (<xref rid="btad218-B37" ref-type="bibr">Sahlin 2021</xref>; <xref rid="btad218-B25" ref-type="bibr">Maier and Sahlin 2022</xref>; <xref rid="btad218-B38" ref-type="bibr">Sahlin 2022</xref>) pick and concatenate <italic toggle="yes">k</italic>mers from multiple consecutive predetermined windows. This provides more flexibility on the spacing between extracted <italic toggle="yes">k</italic>mers and therefore is less susceptible to different mutation rates. Nonetheless, since these methods all use <italic toggle="yes">k</italic>mers as building blocks, they cannot fully resolve the drawback of <italic toggle="yes">k</italic>mer-based methods. In addition, we consider these approaches orthogonal to the “basic” seeding methods (such as <italic toggle="yes">k</italic>mers and our method described below) in the sense that they can be applied on top of any kind of basic seeds.</p>
    <p>In this article, we explore the use of subsequences, rather than substrings, as seeds. The key observation is that two similar strings may share few or even zero substrings (of length <italic toggle="yes">k</italic>) but can contain many common subsequences (of length <italic toggle="yes">k</italic> or longer). Consider an example with two similar strings of length 7: <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">s</mml:mi><mml:mo>=</mml:mo><mml:mtext>ACGCCTA</mml:mtext></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">t</mml:mi><mml:mo>=</mml:mo><mml:mtext>ACGGCTA</mml:mtext></mml:mrow></mml:math></inline-formula> that differ by one substitution in the middle (i.e. their edit distance is 1). Clearly, <bold><italic toggle="yes">s</italic></bold> and <bold><italic toggle="yes">t</italic></bold> do not share any <italic toggle="yes">k</italic>mer for <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≥</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>, leading to zero seed-matches for any <italic toggle="yes">k</italic>mer-based seeding methods (when <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≥</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> is used). On the other hand, two-thirds of the total 21 unique length-4 subsequences of <bold><italic toggle="yes">s</italic></bold> are also subsequences of <bold><italic toggle="yes">t</italic></bold>. In fact, the Jaccard index between the two sets of length-4 subsequences of <bold><italic toggle="yes">s</italic></bold> and <bold><italic toggle="yes">t</italic></bold> is <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mn>14</mml:mn><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>21</mml:mn><mml:mo>+</mml:mo><mml:mn>24</mml:mn><mml:mo>−</mml:mo><mml:mn>14</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>≈</mml:mo><mml:mn>0.45</mml:mn></mml:mrow></mml:math></inline-formula>. According to the property of MinHash (<xref rid="btad218-B7" ref-type="bibr">Broder 1997</xref>), if the “smallest” subsequences of length 4 (with respect to a fully random order, i.e. an order picked uniformly at random from all possible orders over strings of length 4) from <bold><italic toggle="yes">s</italic></bold> and <bold><italic toggle="yes">t</italic></bold> are picked as their respective seeds, then the probability of hash collision (i.e. producing a seed-match) is also about 0.45. Although rather simple, this example demonstrates the potential advantage of using subsequences as seeds: as it is more tolerant to edits happening at any position, it is more likely to produce seed-matches for similar sequences, and therefore provides enhanced sensitivity, particularly for data with a high mutation/error rate.</p>
    <p>To this end, we present a subsequence-based seeding method named SubseqHash. It maps a string of length <italic toggle="yes">n</italic> to its smallest subsequence of length <italic toggle="yes">k</italic> (i.e. the seed), <italic toggle="yes">k </italic>&lt;<italic toggle="yes"> n</italic>, according to a given order overall length-<italic toggle="yes">k</italic> strings. There is one caveat: the number of subsequences grows exponentially in a string, which makes the computation of the smallest subsequence intractable when a fully random order is used. To overcome this difficulty, we propose a new algorithmic framework, consisting of a specifically designed order, named ABC order, and an algorithm that finds the smallest subsequence under an ABC order in polynomial time (Section 2). We show experimentally that an ABC order exhibits similar properties as a fully random order and that the probability of hash collision is close to that when a fully random order is used (Sections 3.1 and 3.2). We finally demonstrate the superiority of SubseqHash over the <italic toggle="yes">k</italic>mer-based seeding method Minimizer in several applications, including sequence alignment, read mapping, and overlap detection (Sections 3.4–3.6).</p>
  </sec>
  <sec>
    <title>2 SubseqHash</title>
    <sec>
      <title>2.1 Definitions of SubseqHash</title>
      <p>Let <bold><italic toggle="yes">x</italic></bold> be a string of length <italic toggle="yes">n</italic> over an alphabet Σ. Given an integer <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, denote by <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> the set of all subsequences of <bold><italic toggle="yes">x</italic></bold> of length <italic toggle="yes">k</italic>. Let <italic toggle="yes">π</italic> be a permutation of <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, i.e. <italic toggle="yes">π</italic> defines an order over all possible strings of length <italic toggle="yes">k</italic>. Define <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as the smallest string in <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> according to <italic toggle="yes">π</italic>. In other words, the function <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub></mml:mrow></mml:math></inline-formula> maps a string of length <italic toggle="yes">n</italic> to its smallest (defined by <italic toggle="yes">π</italic>) subsequence of length <italic toggle="yes">k</italic>; formally, <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>arg</mml:mi><mml:msub><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the rank of <bold><italic toggle="yes">z</italic></bold> in the order defined by <italic toggle="yes">π</italic>. We use SubseqHash to term such a hashing function <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>2.2 Probability of hash collision</title>
      <p>The intuition behind SubseqHash is that a few edits between two sequences may destroy most of their common substrings but many common subsequences can survive. We use the Jaccard index to measure the similarity of two sets. Given two strings <bold><italic toggle="yes">x</italic></bold> and <bold><italic toggle="yes">y</italic></bold>, the Jaccard index for their subsequences of length <italic toggle="yes">k</italic> is defined as <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>/</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. The Jaccard index for their substrings can be defined similarly. In <xref rid="sup1" ref-type="supplementary-material">Supplementary Notes S1</xref> and <xref rid="sup1" ref-type="supplementary-material">S2</xref>, we estimate and compare the Jaccard index for subsequences and substrings; in general, the Jaccard index for subsequences is larger than that for substrings, verifying the intuition.</p>
      <p>We say an order <italic toggle="yes">π</italic> over <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> is “fully random” if <italic toggle="yes">π</italic> is drawn uniformly at random from all orders. For a fully random order <italic toggle="yes">π</italic>, the probability of hash collision of <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub></mml:mrow></mml:math></inline-formula> is exactly the Jaccard index for subsequences according to the property of MinHash (<xref rid="btad218-B7" ref-type="bibr">Broder 1997</xref>), i.e. <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mi>Pr</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for any two strings <bold><italic toggle="yes">x</italic></bold> and <bold><italic toggle="yes">y</italic></bold>. If <italic toggle="yes">π</italic> is not fully random then this may not hold. For example, when the lexicographic order is used, the empirical probability of hash collision reduces considerably (Section 3.2).</p>
    </sec>
    <sec>
      <title>2.3 Algorithmic framework for constructing SubseqHash</title>
      <p>The complexity of calculating <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for a given string <bold><italic toggle="yes">x</italic></bold> also depends on the choice of <italic toggle="yes">π</italic>. For a fully random order <italic toggle="yes">π</italic>, one can compute <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by enumerating all subsequences of <bold><italic toggle="yes">x</italic></bold> and picking the smallest one. Another approach is to traverse all strings of length <italic toggle="yes">k</italic> down the order <italic toggle="yes">π</italic> and return the first one that is a subsequence of <bold><italic toggle="yes">x</italic></bold>. (Determining if a string <bold><italic toggle="yes">z</italic></bold> is a subsequence of another string <bold><italic toggle="yes">x</italic></bold> can be done in <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time, where <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mo>·</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> denotes the length of a string.) Both approaches run in exponential time. On the other hand, when the lexicographic order <italic toggle="yes">π</italic> is used, <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> can be computed in linear time; the downside is that the probability of hash collision gets reduced significantly as stated above.</p>
      <p>We propose a novel approach to balance performance and efficiency. The idea is to use a special order <italic toggle="yes">π</italic> that allows for computing <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in polynomial time. Such a special order is not fully random, but is designed to be “quite” random, and therefore achieves a probability of hash collision comparable with a fully random order. The special order <italic toggle="yes">π</italic> and the polynomial time algorithm are described in the next two sections.</p>
    </sec>
    <sec>
      <title>2.4 The ABC order</title>
      <p>We start with designing an order <italic toggle="yes">π</italic> over <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, named ABC order. Let <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mi>d</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> be an integer parameter. Essentially, <italic toggle="yes">π</italic> is given as a scoring function that maps a string <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> to a pair <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow></mml:math></inline-formula>. Then all strings in <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> are ordered as follows: for <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, define <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> if and only if <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, or <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mo>|</mml:mo><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. The construction of <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (see below) makes it extremely unlikely to have <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo>≠</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:math></inline-formula>. When such a rare case happens, we define <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> if and only if <bold><italic toggle="yes">z</italic></bold> is lexicographically smaller than <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
      <p>We specify such a function <italic toggle="yes">π</italic> for DNA strings by assuming <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mo>Σ</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi mathvariant="normal">A</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi mathvariant="normal">C</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi mathvariant="normal">G</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi mathvariant="normal">T</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. The function <italic toggle="yes">π</italic> is governed by three (random) tables <italic toggle="yes">A</italic>, <italic toggle="yes">B</italic>, and <italic toggle="yes">C</italic>; hence the name. Table <italic toggle="yes">A</italic> is a 3D real matrix of dimension <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>×</mml:mo><mml:mi>d</mml:mi><mml:mo>×</mml:mo><mml:mo>|</mml:mo><mml:mo>Σ</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, i.e. <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>×</mml:mo><mml:mi>d</mml:mi><mml:mo>×</mml:mo><mml:mo>|</mml:mo><mml:mo>Σ</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>. Table <italic toggle="yes">B</italic> is also of dimension <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>×</mml:mo><mml:mi>d</mml:mi><mml:mo>×</mml:mo><mml:mo>|</mml:mo><mml:mo>Σ</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mo>σ</mml:mo><mml:mo>∈</mml:mo><mml:mo>Σ</mml:mo></mml:mrow></mml:math></inline-formula>. Table <italic toggle="yes">C</italic> has dimension <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>×</mml:mo><mml:mo>|</mml:mo><mml:mo>Σ</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mo>σ</mml:mo><mml:mo>∈</mml:mo><mml:mo>Σ</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>These three tables are randomly generated in the following way. Each element <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is drawn independently and uniformly at random from a predetermined subset of <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mi mathvariant="double-struck">R</mml:mi></mml:math></inline-formula>; our implementation uses <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>31</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. For any fixed <italic toggle="yes">i</italic> and <italic toggle="yes">j</italic>, <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is picked from the four pairs <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> uniformly at random without replacement, i.e. <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> if <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. Last, for any fixed <italic toggle="yes">i</italic>, <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, each element <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is drawn independently and uniformly at random from <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. If the parameter <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mi>d</mml:mi><mml:mo>≥</mml:mo><mml:mo>|</mml:mo><mml:mo>Σ</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>, then we do this without replacement, i.e. <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> if <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. Please see <xref rid="sup1" ref-type="supplementary-material">Supplementary Note S3</xref> for an example.</p>
      <p>Once the tables <italic toggle="yes">A</italic>, <italic toggle="yes">B</italic>, and <italic toggle="yes">C</italic> are generated, the scoring function <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is determined for any string <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>. Write <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mo>Σ</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. For the sake of simplicity, denote <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by <italic toggle="yes">ψ<sub>i</sub></italic> and <italic toggle="yes">ω<sub>i</sub></italic>, respectively; also denote the first and the second element in the pair <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> by <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, respectively.</p>
      <p>The initial values are set to <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>ψ</mml:mo></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>ω</mml:mo></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. For <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, we use recurrences
and
</p>
      <disp-formula id="E1">
        <mml:math id="M1" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ψ</mml:mo>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ψ</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mo>−</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
            </mml:msub>
            <mml:mo>+</mml:mo>
            <mml:mi>C</mml:mi>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>z</mml:mi>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo> </mml:mo>
            <mml:mi>mod</mml:mi>
            <mml:mo> </mml:mo>
            <mml:mi>d</mml:mi>
            <mml:mo>,</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <disp-formula id="E2">
        <mml:math id="M2" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ω</mml:mo>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ω</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mo>−</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
            </mml:msub>
            <mml:mo>·</mml:mo>
            <mml:mi>B</mml:mi>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ψ</mml:mo>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mrow>
                  <mml:mo stretchy="false">[</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>z</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="false">]</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:mn>1</mml:mn>
            </mml:msub>
            <mml:mo>+</mml:mo>
            <mml:mi>A</mml:mi>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ψ</mml:mo>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>z</mml:mi>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo>·</mml:mo>
            <mml:mi>B</mml:mi>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ψ</mml:mo>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mrow>
                  <mml:mo stretchy="false">[</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>z</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="false">]</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:mn>2</mml:mn>
            </mml:msub>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Observe that if <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:mi>d</mml:mi><mml:mo>≥</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, then one edit in the string is guaranteed to alter the value of <italic toggle="yes">ψ</italic>, while two edits have a small chance (approximately <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>) to result in the same <italic toggle="yes">ψ</italic>. In addition, due to the use of –1 in table <italic toggle="yes">B</italic>, the value of <italic toggle="yes">ω</italic> can be substantially changed with even a single mutation. Combined, a few edits can cause a drastic change in both <italic toggle="yes">ψ</italic> and <italic toggle="yes">ω</italic>, and therefore the rank of strings in the order, which is a desired property; see Section 3.1 for more discussions.</p>
    </sec>
    <sec>
      <title>2.5 Algorithm for computing the smallest subsequence with an ABC order</title>
      <p>Let <italic toggle="yes">π</italic> be an ABC order. We design an efficient algorithm to find <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>arg</mml:mi><mml:msub><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for any given <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>. Since the scoring function <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is defined by recurrences, it is natural to solve <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> using a dynamic programming algorithm. Consider a subproblem parameterized by <italic toggle="yes">l</italic>, <italic toggle="yes">i</italic>, and <italic toggle="yes">j</italic>, where <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>l</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>, which is defined to seek a subsequence <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is minimized or maximized. We calculate both the maximized and minimized values because they would be switched when encountering a pair from table <italic toggle="yes">B</italic> with –1 being its first element. Furthermore, both values are needed at the end since the definition of an ABC order requires finding the subsequence that maximizes the absolute value of <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>Formally, for each <italic toggle="yes">l</italic>, <italic toggle="yes">i</italic>, and <italic toggle="yes">j</italic>, we define subproblems:
and
</p>
      <disp-formula id="E3">
        <mml:math id="M3" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi mathvariant="italic">min</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>l</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>j</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo>:</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:munder>
              <mml:mrow>
                <mml:mi>min</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>z</mml:mi>
                <mml:mo>∈</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>S</mml:mi>
                  </mml:mrow>
                  <mml:mi>i</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mn>1</mml:mn>
                </mml:msub>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mn>2</mml:mn>
                </mml:msub>
                <mml:mo>⋯</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mi>l</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo> </mml:mo>
                <mml:mo> </mml:mo>
                <mml:mtext>and</mml:mtext>
                <mml:mo> </mml:mo>
                <mml:mo> </mml:mo>
                <mml:mo>ψ</mml:mo>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>z</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mi>j</mml:mi>
              </mml:mrow>
            </mml:munder>
            <mml:mo>ω</mml:mo>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi>z</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <disp-formula id="E4">
        <mml:math id="M4" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi mathvariant="italic">max</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>l</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>j</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo>:</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:munder>
              <mml:mrow>
                <mml:mi>max</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>z</mml:mi>
                <mml:mo>∈</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>S</mml:mi>
                  </mml:mrow>
                  <mml:mi>i</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mn>1</mml:mn>
                </mml:msub>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mn>2</mml:mn>
                </mml:msub>
                <mml:mo>⋯</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mi>l</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo> </mml:mo>
                <mml:mo> </mml:mo>
                <mml:mtext>and</mml:mtext>
                <mml:mo> </mml:mo>
                <mml:mo> </mml:mo>
                <mml:mo>ψ</mml:mo>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>z</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mi>j</mml:mi>
              </mml:mrow>
            </mml:munder>
            <mml:mo>ω</mml:mo>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi>z</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>They can be calculated with the recurrences below, in which <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mi>mod</mml:mi><mml:mo> </mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>.
</p>
      <disp-formula id="E5">
        <mml:math id="M5" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mtable>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>T</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi mathvariant="italic">min</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo stretchy="true">[</mml:mo>
                    <mml:mi>l</mml:mi>
                    <mml:mo stretchy="true">]</mml:mo>
                    <mml:mo stretchy="true">[</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="true">]</mml:mo>
                    <mml:mo stretchy="true">[</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo stretchy="true">]</mml:mo>
                    <mml:mo>=</mml:mo>
                    <mml:mi>min</mml:mi>
                    <mml:mrow>
                      <mml:mo stretchy="true">{</mml:mo>
                      <mml:mrow>
                        <mml:mtable>
                          <mml:mtr columnalign="left">
                            <mml:mtd columnalign="left">
                              <mml:mrow>
                                <mml:msub>
                                  <mml:mrow>
                                    <mml:mi>T</mml:mi>
                                  </mml:mrow>
                                  <mml:mrow>
                                    <mml:mi mathvariant="italic">min</mml:mi>
                                  </mml:mrow>
                                </mml:msub>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>l</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mn>1</mml:mn>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                              </mml:mrow>
                            </mml:mtd>
                          </mml:mtr>
                          <mml:mtr columnalign="left">
                            <mml:mtd columnalign="left">
                              <mml:mrow>
                                <mml:mi>A</mml:mi>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:msub>
                                  <mml:mrow>
                                    <mml:mi>x</mml:mi>
                                  </mml:mrow>
                                  <mml:mi>l</mml:mi>
                                </mml:msub>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo>·</mml:mo>
                                <mml:mi>B</mml:mi>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:msub>
                                  <mml:mrow>
                                    <mml:mrow>
                                      <mml:mo stretchy="true">[</mml:mo>
                                      <mml:msub>
                                        <mml:mrow>
                                          <mml:mi>x</mml:mi>
                                        </mml:mrow>
                                        <mml:mi>l</mml:mi>
                                      </mml:msub>
                                      <mml:mo stretchy="true">]</mml:mo>
                                    </mml:mrow>
                                  </mml:mrow>
                                  <mml:mn>2</mml:mn>
                                </mml:msub>
                                <mml:mo>+</mml:mo>
                                <mml:mrow>
                                  <mml:mo stretchy="true">{</mml:mo>
                                  <mml:mrow>
                                    <mml:mtable>
                                      <mml:mtr columnalign="left">
                                        <mml:mtd columnalign="left">
                                          <mml:mrow>
                                            <mml:mo>+</mml:mo>
                                            <mml:msub>
                                              <mml:mrow>
                                                <mml:mi>T</mml:mi>
                                              </mml:mrow>
                                              <mml:mrow>
                                                <mml:mi mathvariant="italic">min</mml:mi>
                                              </mml:mrow>
                                            </mml:msub>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>l</mml:mi>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>i</mml:mi>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>j</mml:mi>
                                            <mml:mo>′</mml:mo>
                                            <mml:mo stretchy="true">]</mml:mo>
                                          </mml:mrow>
                                        </mml:mtd>
                                      </mml:mtr>
                                      <mml:mtr columnalign="left">
                                        <mml:mtd columnalign="left">
                                          <mml:mrow>
                                            <mml:mo stretchy="true">(</mml:mo>
                                            <mml:mtext>if</mml:mtext>
                                            <mml:mo> </mml:mo>
                                            <mml:mo> </mml:mo>
                                            <mml:mi>B</mml:mi>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>i</mml:mi>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>j</mml:mi>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:msub>
                                              <mml:mrow>
                                                <mml:mrow>
                                                  <mml:mo stretchy="true">[</mml:mo>
                                                  <mml:msub>
                                                    <mml:mrow>
                                                      <mml:mi>x</mml:mi>
                                                    </mml:mrow>
                                                    <mml:mi>l</mml:mi>
                                                  </mml:msub>
                                                  <mml:mo stretchy="true">]</mml:mo>
                                                </mml:mrow>
                                              </mml:mrow>
                                              <mml:mn>1</mml:mn>
                                            </mml:msub>
                                            <mml:mo>=</mml:mo>
                                            <mml:mo>+</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">)</mml:mo>
                                          </mml:mrow>
                                        </mml:mtd>
                                      </mml:mtr>
                                      <mml:mtr columnalign="left">
                                        <mml:mtd columnalign="left">
                                          <mml:mrow>
                                            <mml:mo>−</mml:mo>
                                            <mml:msub>
                                              <mml:mrow>
                                                <mml:mi>T</mml:mi>
                                              </mml:mrow>
                                              <mml:mrow>
                                                <mml:mi mathvariant="italic">max</mml:mi>
                                              </mml:mrow>
                                            </mml:msub>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>l</mml:mi>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>i</mml:mi>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>j</mml:mi>
                                            <mml:mo>′</mml:mo>
                                            <mml:mo stretchy="true">]</mml:mo>
                                          </mml:mrow>
                                        </mml:mtd>
                                      </mml:mtr>
                                      <mml:mtr columnalign="left">
                                        <mml:mtd columnalign="left">
                                          <mml:mrow>
                                            <mml:mo stretchy="true">(</mml:mo>
                                            <mml:mtext>if</mml:mtext>
                                            <mml:mo> </mml:mo>
                                            <mml:mo> </mml:mo>
                                            <mml:mi>B</mml:mi>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>i</mml:mi>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>j</mml:mi>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:msub>
                                              <mml:mrow>
                                                <mml:mrow>
                                                  <mml:mo stretchy="true">[</mml:mo>
                                                  <mml:msub>
                                                    <mml:mrow>
                                                      <mml:mi>x</mml:mi>
                                                    </mml:mrow>
                                                    <mml:mi>l</mml:mi>
                                                  </mml:msub>
                                                  <mml:mo stretchy="true">]</mml:mo>
                                                </mml:mrow>
                                              </mml:mrow>
                                              <mml:mn>1</mml:mn>
                                            </mml:msub>
                                            <mml:mo>=</mml:mo>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">)</mml:mo>
                                          </mml:mrow>
                                        </mml:mtd>
                                      </mml:mtr>
                                    </mml:mtable>
                                  </mml:mrow>
                                </mml:mrow>
                              </mml:mrow>
                            </mml:mtd>
                          </mml:mtr>
                        </mml:mtable>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <disp-formula id="E05">
        <mml:math id="M05" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mtable>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>T</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi mathvariant="italic">max</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo stretchy="true">[</mml:mo>
                    <mml:mi>l</mml:mi>
                    <mml:mo stretchy="true">]</mml:mo>
                    <mml:mo stretchy="true">[</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="true">]</mml:mo>
                    <mml:mo stretchy="true">[</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo stretchy="true">]</mml:mo>
                    <mml:mo>=</mml:mo>
                    <mml:mi>max</mml:mi>
                    <mml:mrow>
                      <mml:mo stretchy="true">{</mml:mo>
                      <mml:mrow>
                        <mml:mtable>
                          <mml:mtr columnalign="left">
                            <mml:mtd columnalign="left">
                              <mml:mrow>
                                <mml:msub>
                                  <mml:mrow>
                                    <mml:mi>T</mml:mi>
                                  </mml:mrow>
                                  <mml:mrow>
                                    <mml:mi mathvariant="italic">max</mml:mi>
                                  </mml:mrow>
                                </mml:msub>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>l</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mn>1</mml:mn>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                              </mml:mrow>
                            </mml:mtd>
                          </mml:mtr>
                          <mml:mtr columnalign="left">
                            <mml:mtd columnalign="left">
                              <mml:mrow>
                                <mml:mi>A</mml:mi>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:msub>
                                  <mml:mrow>
                                    <mml:mi>x</mml:mi>
                                  </mml:mrow>
                                  <mml:mi>l</mml:mi>
                                </mml:msub>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo>·</mml:mo>
                                <mml:mi>B</mml:mi>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:msub>
                                  <mml:mrow>
                                    <mml:mrow>
                                      <mml:mo stretchy="true">[</mml:mo>
                                      <mml:msub>
                                        <mml:mrow>
                                          <mml:mi>x</mml:mi>
                                        </mml:mrow>
                                        <mml:mi>l</mml:mi>
                                      </mml:msub>
                                      <mml:mo stretchy="true">]</mml:mo>
                                    </mml:mrow>
                                  </mml:mrow>
                                  <mml:mn>2</mml:mn>
                                </mml:msub>
                                <mml:mo>+</mml:mo>
                                <mml:mrow>
                                  <mml:mo stretchy="true">{</mml:mo>
                                  <mml:mrow>
                                    <mml:mtable>
                                      <mml:mtr columnalign="left">
                                        <mml:mtd columnalign="left">
                                          <mml:mrow>
                                            <mml:mo>+</mml:mo>
                                            <mml:msub>
                                              <mml:mrow>
                                                <mml:mi>T</mml:mi>
                                              </mml:mrow>
                                              <mml:mrow>
                                                <mml:mi mathvariant="italic">max</mml:mi>
                                              </mml:mrow>
                                            </mml:msub>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>l</mml:mi>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>i</mml:mi>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>j</mml:mi>
                                            <mml:mo>′</mml:mo>
                                            <mml:mo stretchy="true">]</mml:mo>
                                          </mml:mrow>
                                        </mml:mtd>
                                      </mml:mtr>
                                      <mml:mtr columnalign="left">
                                        <mml:mtd columnalign="left">
                                          <mml:mrow>
                                            <mml:mo stretchy="true">(</mml:mo>
                                            <mml:mtext>if</mml:mtext>
                                            <mml:mo> </mml:mo>
                                            <mml:mo> </mml:mo>
                                            <mml:mi>B</mml:mi>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>i</mml:mi>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>j</mml:mi>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:msub>
                                              <mml:mrow>
                                                <mml:mrow>
                                                  <mml:mo stretchy="true">[</mml:mo>
                                                  <mml:msub>
                                                    <mml:mrow>
                                                      <mml:mi>x</mml:mi>
                                                    </mml:mrow>
                                                    <mml:mi>l</mml:mi>
                                                  </mml:msub>
                                                  <mml:mo stretchy="true">]</mml:mo>
                                                </mml:mrow>
                                              </mml:mrow>
                                              <mml:mn>1</mml:mn>
                                            </mml:msub>
                                            <mml:mo>=</mml:mo>
                                            <mml:mo>+</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">)</mml:mo>
                                          </mml:mrow>
                                        </mml:mtd>
                                      </mml:mtr>
                                      <mml:mtr columnalign="left">
                                        <mml:mtd columnalign="left">
                                          <mml:mrow>
                                            <mml:mo>−</mml:mo>
                                            <mml:msub>
                                              <mml:mrow>
                                                <mml:mi>T</mml:mi>
                                              </mml:mrow>
                                              <mml:mrow>
                                                <mml:mi mathvariant="italic">min</mml:mi>
                                              </mml:mrow>
                                            </mml:msub>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>l</mml:mi>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>i</mml:mi>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>j</mml:mi>
                                            <mml:mo>′</mml:mo>
                                            <mml:mo stretchy="true">]</mml:mo>
                                          </mml:mrow>
                                        </mml:mtd>
                                      </mml:mtr>
                                      <mml:mtr columnalign="left">
                                        <mml:mtd columnalign="left">
                                          <mml:mrow>
                                            <mml:mo stretchy="true">(</mml:mo>
                                            <mml:mtext>if</mml:mtext>
                                            <mml:mo> </mml:mo>
                                            <mml:mo> </mml:mo>
                                            <mml:mi>B</mml:mi>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>i</mml:mi>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>j</mml:mi>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:msub>
                                              <mml:mrow>
                                                <mml:mrow>
                                                  <mml:mo stretchy="true">[</mml:mo>
                                                  <mml:msub>
                                                    <mml:mrow>
                                                      <mml:mi>x</mml:mi>
                                                    </mml:mrow>
                                                    <mml:mi>l</mml:mi>
                                                  </mml:msub>
                                                  <mml:mo stretchy="true">]</mml:mo>
                                                </mml:mrow>
                                              </mml:mrow>
                                              <mml:mn>1</mml:mn>
                                            </mml:msub>
                                            <mml:mo>=</mml:mo>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">)</mml:mo>
                                          </mml:mrow>
                                        </mml:mtd>
                                      </mml:mtr>
                                    </mml:mtable>
                                  </mml:mrow>
                                </mml:mrow>
                              </mml:mrow>
                            </mml:mtd>
                          </mml:mtr>
                        </mml:mtable>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow/>
                </mml:mtd>
                <mml:mtd columnalign="left">
                  <mml:mrow/>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Initially, for any <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>l</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">min</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">max</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">min</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">max</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mtext>NaN</mml:mtext></mml:mrow></mml:math></inline-formula> if <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. Tables <italic toggle="yes">T</italic><sub>min</sub> and <italic toggle="yes">T</italic><sub>max</sub> can then be filled using the above recurrences. Subsequently, for <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>, we record the values
</p>
      <disp-formula id="E6">
        <mml:math id="M6" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>T</mml:mi>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>n</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>k</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>j</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo>:</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mi>max</mml:mi>
            <mml:mo>{</mml:mo>
            <mml:mrow>
              <mml:mo>|</mml:mo>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>T</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi mathvariant="italic">min</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mi>n</mml:mi>
                <mml:mo stretchy="false">]</mml:mo>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mi>k</mml:mi>
                <mml:mo stretchy="false">]</mml:mo>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mi>j</mml:mi>
                <mml:mo stretchy="false">]</mml:mo>
              </mml:mrow>
              <mml:mo>|</mml:mo>
            </mml:mrow>
            <mml:mo>,</mml:mo>
            <mml:mrow>
              <mml:mo>|</mml:mo>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>T</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi mathvariant="italic">max</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mi>n</mml:mi>
                <mml:mo stretchy="false">]</mml:mo>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mi>k</mml:mi>
                <mml:mo stretchy="false">]</mml:mo>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mi>j</mml:mi>
                <mml:mo stretchy="false">]</mml:mo>
              </mml:mrow>
              <mml:mo>|</mml:mo>
            </mml:mrow>
            <mml:mo>}</mml:mo>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>In these processes, if any of the three arithmetic operations <inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mo>+</mml:mo><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mo>,</mml:mo><mml:mo>|</mml:mo><mml:mo>·</mml:mo><mml:mo>|</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> involves NaN as an operand, then the result is also an NaN. The <inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:math></inline-formula> operations ignore NaN and only work on numerical operands, unless there is none, in which case an NaN is returned. At the end, we calculate
</p>
      <disp-formula id="E7">
        <mml:math id="M7" display="block" overflow="scroll">
          <mml:msub>
            <mml:mo>ψ</mml:mo>
            <mml:mrow>
              <mml:mi>o</mml:mi>
              <mml:mi>p</mml:mi>
              <mml:mi>t</mml:mi>
            </mml:mrow>
          </mml:msub>
          <mml:mo>=</mml:mo>
          <mml:mi>min</mml:mi>
          <mml:mo>{</mml:mo>
          <mml:mi>j</mml:mi>
          <mml:mo>|</mml:mo>
          <mml:mi>T</mml:mi>
          <mml:mo>[</mml:mo>
          <mml:mi>n</mml:mi>
          <mml:mo>]</mml:mo>
          <mml:mo>[</mml:mo>
          <mml:mi>k</mml:mi>
          <mml:mo>]</mml:mo>
          <mml:mo>[</mml:mo>
          <mml:mi>j</mml:mi>
          <mml:mo>]</mml:mo>
          <mml:mo>≠</mml:mo>
          <mml:mtext>NaN</mml:mtext>
          <mml:mo>}</mml:mo>
          <mml:mo> </mml:mo>
          <mml:mo> </mml:mo>
          <mml:mtext>and</mml:mtext>
          <mml:mo> </mml:mo>
          <mml:mo> </mml:mo>
          <mml:msub>
            <mml:mo>ω</mml:mo>
            <mml:mrow>
              <mml:mi>o</mml:mi>
              <mml:mi>p</mml:mi>
              <mml:mi>t</mml:mi>
            </mml:mrow>
          </mml:msub>
          <mml:mo>=</mml:mo>
          <mml:mi>T</mml:mi>
          <mml:mo>[</mml:mo>
          <mml:mi>n</mml:mi>
          <mml:mo>]</mml:mo>
          <mml:mo>[</mml:mo>
          <mml:mi>k</mml:mi>
          <mml:mo>]</mml:mo>
          <mml:mo>[</mml:mo>
          <mml:msub>
            <mml:mo>ψ</mml:mo>
            <mml:mrow>
              <mml:mi>o</mml:mi>
              <mml:mi>p</mml:mi>
              <mml:mi>t</mml:mi>
            </mml:mrow>
          </mml:msub>
          <mml:mo>]</mml:mo>
          <mml:mo>.</mml:mo>
        </mml:math>
      </disp-formula>
      <p>The optimal subsequence <inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, i.e., the subsequence <italic toggle="yes">z</italic> of <italic toggle="yes">x</italic> with <inline-formula id="IE9002"><mml:math id="IM9002" display="inline" overflow="scroll"><mml:mi>π</mml:mi><mml:mo>(</mml:mo><mml:mi>z</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:msub><mml:mo>ψ</mml:mo><mml:mrow><mml:mi>o</mml:mi><mml:mi>p</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mi>ω</mml:mi><mml:mrow><mml:mi>o</mml:mi><mml:mi>p</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo></mml:math></inline-formula>can be obtained by traceback. The entire algorithm runs in <italic toggle="yes">O</italic>(<italic toggle="yes">nkd</italic>) time.</p>
    </sec>
    <sec>
      <title>2.6 Using SubseqHash in practice</title>
      <p>It is desirable for a seeding/hashing function to be “locality-sensitive,” i.e. the probability of hash collision for a pair of strings <bold><italic toggle="yes">x</italic></bold> and <bold><italic toggle="yes">y</italic></bold> is high if they are similar (say, measured with the edit distance), and at the same time such probability becomes low if <bold><italic toggle="yes">x</italic></bold> and <bold><italic toggle="yes">y</italic></bold> are not similar. These desired properties can also be interpreted as having high sensitivity (more true seed-matches) and a low false positive rate (fewer false seed-matches). For SubseqHash coupled with an ABC order, the choice of <italic toggle="yes">n</italic> and <italic toggle="yes">k</italic> balances these two measures. Generally speaking, a larger <italic toggle="yes">n</italic> lowers the false positive rate while a smaller <italic toggle="yes">n</italic> provides higher sensitivity; for a fixed <italic toggle="yes">n</italic>, increasing the difference between <italic toggle="yes">n</italic> and <italic toggle="yes">k</italic> improves sensitivity while decreasing the difference reduces the number of false seed-matches.</p>
      <p>Again, two similar strings <bold><italic toggle="yes">x</italic></bold> and <bold><italic toggle="yes">y</italic></bold> are likely to share some (long) subsequences. In fact, assume the edit distance between two length-<italic toggle="yes">n</italic> strings <bold><italic toggle="yes">x</italic></bold> and <bold><italic toggle="yes">y</italic></bold> is <italic toggle="yes">e</italic><sub>1</sub>, then a shared subsequence of length <italic toggle="yes">k</italic> is guaranteed if <inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. In this case, the probability of hash collision under SubseqHash between <bold><italic toggle="yes">x</italic></bold> and <bold><italic toggle="yes">y</italic></bold> is strictly positive. However, the probability might be small so that one round of SubseqHash may not actually pick a common subsequence of the two strings (see Section 3.2 for some experimental results). To boost the chance of getting a seed-match, one can “repeat” SubseqHash several times independently, each of which uses a different set of random <inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>B</mml:mi><mml:mo>/</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula> tables. Assume that <italic toggle="yes">p</italic> is the probability of hash collision of calling SubseqHash once, then with <italic toggle="yes">t</italic> repeats, the probability of having at least one seed-match is <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>. Repeats may also increase the false positive seed-matches, but it can be well controlled by picking a large <italic toggle="yes">n</italic> and a <italic toggle="yes">k</italic> that is close to <italic toggle="yes">n</italic>. Specifically, two dissimilar strings (i.e. their edit distance <italic toggle="yes">e</italic><sub>2</sub> is large) of length <italic toggle="yes">n</italic> will not share any subsequence of length <italic toggle="yes">k</italic> if <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>&gt;</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>. In Sections 3.4–3.6, we show that repeats can boost sensitivity while maintaining a low false positive rate (i.e. high precision).</p>
      <p>On the other hand, repeats are not as practical for substring-based seeding methods. This is because it is easy for two similar strings not to share any substring of a reasonable length. In fact, a shared substring of length <italic toggle="yes">k</italic> is guaranteed only if <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, as one edit can break up to <italic toggle="yes">k</italic> substrings of length <italic toggle="yes">k</italic>. When two (similar) strings do not share any length-<italic toggle="yes">k</italic> substring, a seed-match will not be produced regardless of the number of repeats. In the experiments, we include the comparison with “all-kmers” (i.e. every sliding window of length <italic toggle="yes">k</italic> in a sequence is collected as a seed), which is the limit of repeating Minimizers.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <sec>
      <title>3.1 Comparison of orders</title>
      <p>We propose a measure to characterize the similarity of neighboring strings in an order. Observe that, the neighboring strings in the lexicographic order are similar, while they are independent and therefore distant from each other in a fully random order. Let <italic toggle="yes">O</italic> be an order over <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> and let <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> be its <italic toggle="yes">i</italic>-th string. We define the 2<italic toggle="yes">w</italic> strings in a window centered at <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> as the neighboring strings of <inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic toggle="yes">w</italic> is a parameter. We use <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mi>w</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>O</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>w</mml:mi><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>e</mml:mi><mml:mi mathvariant="italic">dit</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to quantify how similar <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is with its neighboring strings, where <inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">edit</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo>,</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> denotes the edit distance. We finally calculate the “averaged minimum neighboring edit distance” (AMNED) over the <italic toggle="yes">m</italic> smallest (top-ranked) strings in the order, i.e. <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mi>w</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>O</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>. We consider top-ranked strings in an order as they are more likely to be hashed to in SubseqHash.</p>
      <p>We compare the AMNEDs of ABC orderings, fully random orders, and the lexicographic order for strings of length <italic toggle="yes">k </italic>=<italic toggle="yes"> </italic>15. To generate the top <italic toggle="yes">m</italic> strings in an ABC order, we randomly generate tables <italic toggle="yes">A</italic>, <italic toggle="yes">B</italic>, and <italic toggle="yes">C</italic> (with three choices of <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>1, 11, 31), calculate the score <inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of all strings in <inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, sort them, and pick the top <italic toggle="yes">m</italic> strings. The top <italic toggle="yes">m</italic> strings of a fully random order are generated by independently simulating random strings of length <italic toggle="yes">k</italic> until <italic toggle="yes">m</italic> distinct ones are available. Note that the AMNED is 1 for the lexicographic order regardless the choice of <italic toggle="yes">w</italic> and <italic toggle="yes">m</italic>.</p>
      <p><xref rid="btad218-F1" ref-type="fig">Figure 1</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S3</xref> report the averaged AMNEDs and the standard deviation for the above three orders (10 repetitions for the ABC order and the fully random order) using different choices of <italic toggle="yes">w</italic> and <italic toggle="yes">m</italic>. The average AMNED for the ABC order is reasonably large, suggesting that the ABC order is “quite” random, in the sense that nearby strings are dissimilar. There is still a gap between an ABC order and a fully random order, but the gap is gradually decreased as <italic toggle="yes">m</italic> grows. Changing <italic toggle="yes">d</italic> from 1 to 11 for an ABC order significantly increases the AMNED, suggesting the effectiveness of using table <italic toggle="yes">C</italic>. There is a small growth when <italic toggle="yes">d</italic> is further increased to 31; we therefore pick <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>11 in the experimental studies.</p>
      <fig position="float" id="btad218-F1">
        <label>Figure 1.</label>
        <caption>
          <p>The AMNED of different orders over strings of length <italic toggle="yes">k </italic>=<italic toggle="yes"> </italic>15 evaluated with varying <italic toggle="yes">w</italic> (<italic toggle="yes">x</italic>-axis) and <italic toggle="yes">m </italic>=<italic toggle="yes"> </italic>10 000. The point and error bar show the mean and standard deviation over 10 individual runs. Results for different values of <italic toggle="yes">m</italic> are available in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S3</xref>.</p>
        </caption>
        <graphic xlink:href="btad218f1" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>3.2 Comparison of probability of hash collision</title>
      <p>We compare the probability of hash collision achieved by Minimizer and SubseqHash. Each seeding method takes a pair of strings <inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as input, and extracts a single seed from each string. For Minimizer, the seed of <bold><italic toggle="yes">x</italic></bold> is the smallest <italic toggle="yes">k</italic>mer among the <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">k</italic>mers in <bold><italic toggle="yes">x</italic></bold> according to a fully random order. For SubseqHash, the seed of <bold><italic toggle="yes">x</italic></bold> is the smallest subsequence of length <italic toggle="yes">k</italic> in <bold><italic toggle="yes">x</italic></bold>, according to the chosen order. For the lexicographic order, linear algorithm exists to find the optimal seed; for the ABC order, algorithm in Section 2.5 is used; for a fully random order, we use a brute-force approach to find the smallest seed (and hence we are not able to report the results for large <italic toggle="yes">k</italic> in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S5</xref>). A seed of <bold><italic toggle="yes">y</italic></bold> will be extracted independently but with the shared order used for <bold><italic toggle="yes">x</italic></bold>. We then check if the two seeds are identical (i.e. a hash collision).</p>
      <p>We use simulations to estimate the probability of hash collisions. To simulate pairs of strings, we start with <bold><italic toggle="yes">x</italic></bold> being a random string of length <italic toggle="yes">n</italic>, <italic toggle="yes">n </italic>=<italic toggle="yes"> </italic>20 or <italic toggle="yes">n </italic>=<italic toggle="yes"> </italic>30. We then apply <italic toggle="yes">n</italic> random evolutionary events sequentially on <bold><italic toggle="yes">x</italic></bold>, with each event with probability of 1/3 being a substitution, a deletion, or an insertion. We make sure that each position can be only mutated once. We collect both the intermediate <italic toggle="yes">n−</italic>1 strings and the final string, resulting in <italic toggle="yes">n</italic> pairs of strings <inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mi mathvariant="bold-italic">i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>. All pairs are categorized according to the edit distance, i.e. pair <inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mi mathvariant="bold-italic">i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is put into the <italic toggle="yes">j</italic>-th category if <inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">edit</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mi mathvariant="bold-italic">i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>. Note that there are <italic toggle="yes">i</italic> mutations simulated from <bold><italic toggle="yes">x</italic></bold> to <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mi mathvariant="bold-italic">i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, but it is not necessarily true that <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">edit</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mi mathvariant="bold-italic">i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>. Notice also that it is possible that <inline-formula id="IE124"><mml:math id="IM124" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mi mathvariant="bold-italic">i</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>≠</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, but a seed of the same length (a <italic toggle="yes">k</italic>mer for Minimizer and a subsequence of length <italic toggle="yes">k</italic> for SubseqHash) will be extracted from them.</p>
      <p>We simulate 10 000 pairs of strings following above procedure, and in each of the 10 categories where edit distance is from 1 to 10, we calculate the frequency of hash collisions and use it as an estimation of the probability of hash collision. The results are shown in <xref rid="btad218-F2" ref-type="fig">Fig. 2</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Figs S4</xref> and <xref rid="sup1" ref-type="supplementary-material">S5</xref>. Minimizer and SubseqHash are compared when extracting seeds of the same length (the same <italic toggle="yes">k</italic>). Observe that in all settings SubseqHash coupled with ABC order achieves much higher probability than Minimizer when the edit distance is in a range of 1–5, indicating the superiority of SubseqHash over Minimizer in hashing similar strings but with high error rates. The probability of hash collision of SubseqHash coupled with the lexicographic order is very similar to that of the Minimizer, suggesting the necessity of a more random order (than lexicographic order) to make SubseqHash more sensitive. The probability of hash collision of SubseqHash gets much improved when <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>11 is used in ABC order than <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>1, again indicating the effectiveness of table <italic toggle="yes">C</italic>. The performance of SubseqHash with fully random orders gives the highest probability (i.e. the Jaccard index) among possible orders, but the curves from ABC orders when <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>11 and <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>31 are very close to them, indicating that the ABC order (with large <italic toggle="yes">d</italic>) is nearly optimal.</p>
      <fig position="float" id="btad218-F2">
        <label>Figure 2.</label>
        <caption>
          <p>The probability of hash collision estimated, using simulations, for different seeding methods with <italic toggle="yes">n </italic>=<italic toggle="yes"> </italic>20 and <italic toggle="yes">k </italic>=<italic toggle="yes"> </italic>16. More results with different <italic toggle="yes">n</italic> and <italic toggle="yes">k</italic> are available in <xref rid="sup1" ref-type="supplementary-material">Supplementary Figs S4</xref> and <xref rid="sup1" ref-type="supplementary-material">S5</xref>.</p>
        </caption>
        <graphic xlink:href="btad218f2" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>3.3 Evaluating seeding methods</title>
      <p>We discuss appropriate measures to evaluate seeding methods for tasks involving sequence comparison, such as sequence alignment, read mapping, and overlapping read detection. Despite variations in methods for these tasks, they all follow a two-step procedure, consisting of a “seeding step” and a “post-seeding step.” The seeding step treats the sequences/reads independently and typically applies a seeding method to sliding windows of a sequence/read, resulting in a list of seeds. Measures for this step include the running time of the seeding method, as well as the density of the seeds, defined as the number of seeds produced from a sequence divided by the length of the sequence.</p>
      <p>The post-seeding step uses the generated seeds to compare sequences. We emphasize that in this step only the matched seeds between compared sequences are used, while unmatched seeds are discarded. For example, in the co-linear chaining approach for sequence alignment, the set of seed-matches serves as the input of the chaining algorithm. In the seed-and-extend scheme for mapping reads, each individual seed-match will be examined in the extension. When detecting overlapping reads, a pair of reads will be determined as “candidate” (which will be then subject to more fine-grained procedure such as chaining to decide overlapping) if there exists one (or more) seed-matches. Therefore, it is the quantity and quality of seed-matches, rather than that of seeds, that determine the running time of the post-seeding step and the accuracy of the outcomes.</p>
      <p>In Sections 3.4 and 3.5, we report the density and running time of different seeding methods, as well as the quantity and quality of the resulting seed-matches to evaluate their impacts on the post-seeding step. In summary, SubseqHash runs much slower than substring-based methods, such as Minimizers. When repetitions are applied to SubseqHash (see Section 2.6), it generates a much larger number of seeds than Minimizers, requiring more memory to store the seeds. However, SubseqHash outperforms other methods in generating high-quality seed-matches, thereby improving the accuracy of the final outcomes. See below for detailed analysis.</p>
    </sec>
    <sec>
      <title>3.4 Application: pairwise sequence alignment</title>
      <p>We use simulations to test the performance of different methods with varying error rates. We simulate 10 pairs of sequences and report the average measures (described below). The first sequence in a pair is a random sequence of length <italic toggle="yes">L </italic>=<italic toggle="yes"> </italic>100 000; the second sequence is obtained by applying an edit, with probability of <italic toggle="yes">r</italic> equally distributed to insertion, deletion, and substitution, independently on every position of the first sequence, where <italic toggle="yes">r</italic> is a parameter specifying the error rate. The ground-truth alignment is saved for evaluation (see below).</p>
      <p>In <xref rid="btad218-F3" ref-type="fig">Fig. 3</xref>, we present the density of SubseqHash and Minimizers using the simulated data described above. As expected, for any fixed window size <italic toggle="yes">n</italic>, the density of both methods decreases as the seed length <italic toggle="yes">k</italic> decreases, but the density of Minimizers decreases much more rapidly than that of SubseqHash. It should be noted that when repetitions are applied to SubseqHash, the density and total number of seeds should be multiplied by the number of repetitions. Furthermore, we provide a comparison of the running time of different seeding methods in <xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S6–S9</xref>. Consistent with the theoretical analysis, SubseqHash typically runs 24–270 times slower than Minimizers.</p>
      <fig position="float" id="btad218-F3">
        <label>Figure 3.</label>
        <caption>
          <p>The density of different seeding methods on simulated sequences. In the legend, “all-kmers” means every single <italic toggle="yes">k</italic>mer is collected as seed, <inline-formula id="IE125"><mml:math id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>9</mml:mn><mml:mo>,</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>25</mml:mn></mml:mrow></mml:math></inline-formula>. “Minimizer <italic toggle="yes">n</italic>” means a window size of <italic toggle="yes">n</italic>; with increasing density, the list of <italic toggle="yes">k</italic> used for each line is <inline-formula id="IE126"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>8</mml:mn><mml:mo>,</mml:mo><mml:mn>9</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. “SubseqHash <italic toggle="yes">n t</italic>” means a window size of <italic toggle="yes">n</italic> and repeating <italic toggle="yes">t</italic> times. For <italic toggle="yes">n </italic>=<italic toggle="yes"> </italic>20, <italic toggle="yes">k</italic> is from 14 to 19; for <italic toggle="yes">n </italic>=<italic toggle="yes"> </italic>25, <italic toggle="yes">k</italic> is from 16 to 24; for <italic toggle="yes">n </italic>=<italic toggle="yes"> </italic>30, <italic toggle="yes">k</italic> is from 18 to 29; for <italic toggle="yes">n </italic>=<italic toggle="yes"> </italic>35, <italic toggle="yes">k</italic> is from 20 to 34. For all methods, points with varying <italic toggle="yes">k</italic> but the same <italic toggle="yes">n</italic> are connected by lines. These parameters are also used in all experimental studies of Sections 3.4 and 3.5.</p>
        </caption>
        <graphic xlink:href="btad218f3" position="float"/>
      </fig>
      <p>We now assess the quality of resulting seed-matches. In either Minimizer or SubseqHash, a seed-match specifies an alignment among <italic toggle="yes">k</italic> identical characters. We define a seed-match to be “true” if at least 50% of the <italic toggle="yes">k</italic> aligned characters appear in the ground-truth; otherwise it is considered to be a “false” seed-match. See <xref rid="btad218-F4" ref-type="fig">Fig. 4</xref> for an example. We do not require all <italic toggle="yes">k</italic> aligned characters to agree with the ground-truth to be considered as a true seed-match as the ground-truth alignment may not reflect the most parsimonious alignment especially when the mutation rate is high. Nevertheless, 50% matched characters certainly indicate that the locations of two seeds are anchored correctly, which is adequate for downstream use.</p>
      <fig position="float" id="btad218-F4">
        <label>Figure 4.</label>
        <caption>
          <p>(a) The ground-truth alignment between two sequences; note that this alignment is not the most parsimonous (i.e. minimizing edit distance) alignment. (b) A seed-match where the identical seed is <italic toggle="yes">ACCCACGTC</italic>. Among the nine matched characters, five of them (55.6%) exist in the ground-truth alignment. Hence this seed-match is a true one.</p>
        </caption>
        <graphic xlink:href="btad218f4" position="float"/>
      </fig>
      <p>In <xref rid="btad218-F5" ref-type="fig">Fig. 5</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S7</xref>, we present the relationship between the number of seed-matches and the ratio of true seed-match ratio (defined as the number of true seed-matches divided by the number of seed-matches). As explained in Section 3.3, the number of seed-matches has a strong correlation with the execution time of the post-seeding step, while the true seed-match ratio reflects the accuracy of seed-matches. By comparing the <italic toggle="yes">y</italic>-coordinates of different methods at a fixed <italic toggle="yes">x</italic>-coordinate, one can assess their accuracy at the same level of running time. SubseqHash without repetitions demonstrates a similar performance to Minimizers in the range of small numbers of seed-matches. SubseqHash with repetitions achieves a much higher true ratio than all-<italic toggle="yes">k</italic>mers when the number of seed-matches falls between approximately 10 000 and 30 000. Beyond this range, SubseqHash and other methods are not comparable.</p>
      <fig position="float" id="btad218-F5">
        <label>Figure 5.</label>
        <caption>
          <p>The number of seed-matches and the true seed-matches ratios on simulated sequences with error rate = 15%. Figure is cropped to only show the portion with high ratio (<inline-formula id="IE127"><mml:math id="IM127" display="inline" overflow="scroll"><mml:mrow><mml:mo>≥</mml:mo><mml:mn>70</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>); complete results are shown in <xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S2–S5</xref>. Results for error rates 5%, 10%, and 20% are available in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S7</xref>.</p>
        </caption>
        <graphic xlink:href="btad218f5" position="float"/>
      </fig>
      <p>It is more desirable for a seeding method to generate true seed-matches that span a larger range of the sequence, rather than ones clustered together (<xref rid="btad218-B37" ref-type="bibr">Sahlin 2021</xref>). We say a character in a sequence is “covered” by a seed-match if it is one of its <italic toggle="yes">k</italic> aligned characters. The “coverage of true seed-matches” (true coverage for short) is the percentage of characters in both sequences that are covered by at least one true seed-match; the “coverage of false seed-matches” (false coverage for short) is defined in the same way but counting false seed-matches. Higher true coverage reflects higher sensitivity, and can facilitate downstream chaining procedure to produce more accurate and faster sequence alignment. Lower false coverage reduces the likelihood of producing incorrect alignments. We report the average true/false coverages of different methods in <xref rid="btad218-F6" ref-type="fig">Fig. 6</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S8</xref>. A single run of SubseqHash outperforms (i.e. higher true coverage at the same false coverage) Minimizer and all-<italic toggle="yes">k</italic>mers when error rate is 5% or 10%, and achieves similar performance at 15% and 20% error rates. SubseqHash with 10 repetitions outperforms others by a large margin at all error rates: specifically, the highest true coverage achieved by Minimizer/all-<italic toggle="yes">k</italic>mers at a false coverage lower than 5% are 85.1%, 61.4%, 38.9%, and 23.1%, respectively, for the 4 error rates, while the numbers for SubseqHash are 98.0%, 90.8%, 75.3%, and 55.0%, respectively.</p>
      <fig position="float" id="btad218-F6">
        <label>Figure 6.</label>
        <caption>
          <p>The coverages of true and false seed-matches for different seeding methods on simulated sequences with error rates =15%. Results for different error rates are available in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S8</xref>.</p>
        </caption>
        <graphic xlink:href="btad218f6" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>3.5 Application: read mapping</title>
      <p>We then compare SubseqHash with other seeding methods on mapping reads to the reference genome. We utilize three real PacBio datasets from <xref rid="btad218-B5" ref-type="bibr">Berlin et al. (2015)</xref> on <italic toggle="yes">Escherichia coli</italic> (SRX533603), <italic toggle="yes">Saccharomyces cerevisiae</italic> (SRX533604), and <italic toggle="yes">Drosophila melanogaster</italic> (SRX499318). To construct a ground-truth for evaluation, we align the reads to the corresponding reference genomes using minimap2 (<xref rid="btad218-B21" ref-type="bibr">Li 2018</xref>) with the default parameters (-cx map-pb). For reads that have a mapped region of at least 2000 bp and a mapping quality of at least 10, we trim the read to only keep the mapped portion. Reads with multiple qualified mappings are discarded. This produces the input reads and their ground-truth alignments. To eliminate the potential biases in the ground-truth created by minimap2, which internally uses Minimizers for seeding, we include a simulated dataset obtained with PBSIM2 (<xref rid="btad218-B31" ref-type="bibr">Ono et al. 2021)</xref> using the same statistics as the PacBio <italic toggle="yes">D.melanogaster</italic> dataset. A total of 287 648 reads are simulated from the X chromosome, with ground-truth alignment saved from simulation. We randomly sample 1000 reads from each of the four datasets for this experiment. The same set of seeding methods (Minimizer, all-<italic toggle="yes">k</italic>mers, and SubseqHash) is applied to generate seeds for both reads and the reference genomes. The density of different methods is illustrated in <xref rid="sup1" ref-type="supplementary-material">Supplementary Figs S9</xref> and <xref rid="sup1" ref-type="supplementary-material">S10</xref>, which show very similar results with <xref rid="btad218-F3" ref-type="fig">Fig. 3</xref>.</p>
      <p>To assess the quality of seed-matches, the same definitions of true and false seed-match used for pairwise sequence alignment (Section 3.4) is also used in this experiment. When calculating the true/false coverages, only the covered characters on reads are considered (instead of on both the reads and the reference genomes). <xref rid="btad218-F7" ref-type="fig">Figure 7</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S11</xref> show the number of seed-matches and the ratio of true seed-matches for different methods averaged over the 1000 reads. At the same level of seed-matches, SubseqHash with 10 repetitions can achieve much higher ratio of true seed-matches than all-<italic toggle="yes">k</italic>mers and Minimizers, verifying the effectiveness of repetitions for sequence mapping. <xref rid="btad218-F8" ref-type="fig">Figure 8</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S12</xref> compare the true/false coverages of different methods. SubseqHash (without repeating) can obtain higher true coverage on the same foot of false coverage than all-<italic toggle="yes">k</italic>mers and Minimizers. Again SubseqHash with repeating 10 times outperforms all others substantially. To give some concrete numbers, the highest true coverage achieved by Minimizer/all-<italic toggle="yes">k</italic>mers at a false coverage lower than 10% are 38.2%, 39.0%, 31.4%, and 34.2%, respectively, for the four datasets, while the numbers for SubseqHash are 74.5%, 67.3%, 52.5%, and 57.5%, respectively.</p>
      <fig position="float" id="btad218-F7">
        <label>Figure 7.</label>
        <caption>
          <p>The number of seed-matches and the ratio of true seed-matches for different seeding methods evaluated on <italic toggle="yes">D.melanogaster</italic> SRX499318 dataset. Figure is cropped to show high ratios (<inline-formula id="IE128"><mml:math id="IM128" display="inline" overflow="scroll"><mml:mrow><mml:mo>≥</mml:mo><mml:mn>15</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>); complete results are given in <xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S10–S13</xref>. Results for other datasets are shown in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S11</xref>.</p>
        </caption>
        <graphic xlink:href="btad218f7" position="float"/>
      </fig>
      <fig position="float" id="btad218-F8">
        <label>Figure 8.</label>
        <caption>
          <p>The coverages of true and false seed-matches for different seeding methods on <italic toggle="yes">D.melanogaster</italic> SRX499318 dataset. Results for other datasets are available in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S12</xref>.</p>
        </caption>
        <graphic xlink:href="btad218f8" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>3.6 Application: overlap detection</title>
      <p>State-of-the-art methods for genome assembly using long-reads sequencing data often rely on an accurate overlap graph, in which vertices are reads and overlapping reads are connected with edges. A straightforward approach for constructing the overlap graph given a set of sequences (i.e. long reads) is performing all-versus-all comparisons, but it certainly does not scale. Seeding methods can be used to detect overlapping pairs while being able to scale. More specifically, a seeding method first transforms each sequence into seeds, then reports pairs of sequences that have at least one seed-match as candidate overlapping pairs. This is certainly a coarse model as for a real overlap detection tool, one would usually perform multiple steps of seed-preprocessing, such as subsampling and filtering; then in the detection phase (post-seeding step), different thresholds for the number of seed-matches and location information of the seeds can be used; lastly, the candidate overlapping pairs are often verified with a fine-grained comparison (e.g. a local alignment) before the final output. All these steps make the overlap results more accurate, but because they can be applied regardless of the seeding methods used, we opt to omit them in this experiment so we can focus on a direct comparison of different seeding methods.</p>
      <p>We use the same four datasets in Section 3.5 in this experiment. We sample 10 000 reads from each dataset; a pair of reads are considered truly overlapping (i.e. ground-truth) if their mapped regions on the reference genome overlap by at least 15 bp. To measure the candidate overlapping pairs reported by a seeding method, we define sensitivity as the fraction of ground-truth pairs that are identified by a seeding method; define precision as the fraction of all reported pairs that are correct according to the ground-truth.</p>
      <p>The precision-sensitivity curves for different methods are shown in <xref rid="btad218-F9" ref-type="fig">Fig. 9</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S13</xref>. Comparing with seeding for sequence alignment and read mapping, here we use a larger window size mainly to reduce false pairs. For each window size <italic toggle="yes">n</italic> used in Minimizers, six seed lengths <italic toggle="yes">k</italic> evenly spaced between 10 and <italic toggle="yes">n</italic> are included (when <italic toggle="yes">k </italic>=<italic toggle="yes"> n</italic>, all-<italic toggle="yes">k</italic>mers are picked as seeds). For each <italic toggle="yes">n</italic> used in SubseqHash, the seed lengths <inline-formula id="IE129"><mml:math id="IM129" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mn>0.65</mml:mn><mml:mi>n</mml:mi></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mn>0.7</mml:mn><mml:mi>n</mml:mi></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mn>0.75</mml:mn><mml:mi>n</mml:mi></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mn>0.8</mml:mn><mml:mi>n</mml:mi></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mn>0.85</mml:mn><mml:mi>n</mml:mi></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> are tested. We include the results of SubseqHash without repetition and of 10 repeats for each of the parameters above. When repetitions apply, the overlapping pairs are simply the union of all 10 runs. Observe that on all four datasets, SubseqHash without repetition already shows better accuracy (i.e. higher precision at the same sensitivity level) than Minimizers and all-<italic toggle="yes">k</italic>mers with a few exceptions at sensitivity near 1.0. In this region, both methods suffer from extremely low precision, which indicates that refining steps are necessary and raw seeds comparison at sensitivity close to 1.0 may not be truly informative. With 10 repetitions, the sensitivity of SubseqHash is significantly boosted while outperforming Minimizers and all-<italic toggle="yes">k</italic>mers substantially. For example, when the sensitivity is set to be at least 80%, the highest precisions achieved by Minimizer/all-<italic toggle="yes">k</italic>mers for the four datasets are 62.9%, 38.9%, 8.7%, and 11.7%, while the numbers for SubseqHash are 85.9%, 78.0%, 23.9%, and 41.7%, respectively.</p>
      <fig position="float" id="btad218-F9">
        <label>Figure 9.</label>
        <caption>
          <p>Overlap detection results on reads sampled from <italic toggle="yes">D.melanogaster</italic> SRX499318 dataset. Results for other datasets are available in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S13</xref>.</p>
        </caption>
        <graphic xlink:href="btad218f9" position="float"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>We investigated SubseqHash, a new approach that uses the minimized subsequence as seed. We figured that the probability of hash collision is determined by the shared order. We therefore studied this core algorithmic formulation: seek an order <italic toggle="yes">π</italic> over all strings of length <italic toggle="yes">k</italic> such that <italic toggle="yes">π</italic> is “as random as possible” and that an efficient algorithm that finds the smallest subsequence (according to <italic toggle="yes">π</italic>) in a string (of length <italic toggle="yes">n</italic>) can be designed. We gave a practical solution for this formulation, consisting of the so-called ABC order together with a dynamic programming algorithm runs in <italic toggle="yes">O</italic>(<italic toggle="yes">nkd</italic>) time to find the minimized subsequence under an ABC order (where <inline-formula id="IE130"><mml:math id="IM130" display="inline" overflow="scroll"><mml:mrow><mml:mi>d</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> can be picked by users). We demonstrated that nearby strings in an ABC order are distant from each other, a property exhibited in a fully random order, and that the probability of hash collision with an ABC order is close to the Jaccard index, achievable when a fully random order is used.</p>
    <p>The superiority of SubseqHash over substring-based methods is in 3-folds. First, SubseqHash tolerates errors while substring-based methods require exact matches. Second, the probability of hash collision of SubseqHash is higher than that of Minimizer (when extracting seeds of the same length). Third, the performance of SubseqHash can be substantially boosted through repetition while for Minimizer this is not as practical. These merits make SubseqHash a more suitable choice for seeding sequencing data with high error/mutation rates.</p>
    <p>We showed that SubseqHash coupled with the ABC order substantially outperformed Minimizer in generating high-quality seed-matches for three applications, sequence alignment, read mapping, and overlap detection. We emphasize that these experiments were designed for a direct comparison between different seeding methods, and therefore the evaluations were conducted at the level of seeds, rather than evaluating the eventual outcomes (e.g. alignments or the overlap graph). As seeding is a key step involved in these applications, we expect SubseqHash will be widely adapted and incorporated to improve their accuracies on the analysis of third-generation sequencing data.</p>
    <p>Our algorithm to find a single seed takes <italic toggle="yes">O</italic>(<italic toggle="yes">nkd</italic>) time, which is much slower than Minimizer that takes amortized <italic toggle="yes">O</italic>(1) time to find a seed in a window. We note that the seeding step usually takes less time than the post-seeding step especially in applications that require all-pairs comparisons, as seeding scales linearly with respect to the number of sequences. Users may choose a smaller <italic toggle="yes">d</italic>, say <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>4 or even <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>1, to gain a speedup at the cost of slightly decrease of sensitivity. Interesting future directions include accelerating the current algorithm using techniques, such as <inline-formula id="IE131"><mml:math id="IM131" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo>∗</mml:mo></mml:mrow></mml:math></inline-formula> heuristic searching (<xref rid="btad218-B16" ref-type="bibr">Ivanov et al. 2022</xref>) and parallel algorithms that have been successfully used to speed up dynamic programming algorithms. We also believe the core algorithmic formulation (stated in the first paragraph of this section), which we find fascinating, can be further improved in achieving faster algorithm and/or higher probability of hash collision.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad218_Supplementary_Data</label>
      <media xlink:href="btad218_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>We thank Paul Medvedev for helpful discussions.</p>
  </ack>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>The authors declare that there is no conflict of interest.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by the US National Science Foundation [2019797, 2145171 to M.S.] and the US National Institutes of Health [R01HG011065 to M.S.].</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad218-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Abouelhoda</surname><given-names>MI</given-names></string-name>, <string-name><surname>Ohlebusch</surname><given-names>E.</given-names></string-name></person-group><article-title>Chaining algorithms for multiple genome comparison</article-title>. <source>J Discrete Algorithms</source><year>2005</year>;<volume>3</volume>:<fpage>321</fpage>–<lpage>41</lpage>.</mixed-citation>
    </ref>
    <ref id="btad218-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Altschul</surname><given-names>SF</given-names></string-name>, <string-name><surname>Gish</surname><given-names>W</given-names></string-name>, <string-name><surname>Miller</surname><given-names>W</given-names></string-name></person-group><etal>et al</etal><article-title>Basic local alignment search tool</article-title>. <source>J Mol Biol</source><year>1990</year>;<volume>215</volume>:<fpage>403</fpage>–<lpage>10</lpage>.<pub-id pub-id-type="pmid">2231712</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Altschul</surname><given-names>SF</given-names></string-name>, <string-name><surname>Madden</surname><given-names>TL</given-names></string-name>, <string-name><surname>Schäffer</surname><given-names>AA</given-names></string-name></person-group><etal>et al</etal><article-title>Gapped BLAST and PSI-BLAST: a new generation of protein database search programs</article-title>. <source>Nucleic Acids Res</source><year>1997</year>;<volume>25</volume>:<fpage>3389</fpage>–<lpage>402</lpage>.<pub-id pub-id-type="pmid">9254694</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bankevich</surname><given-names>A</given-names></string-name>, <string-name><surname>Bzikadze</surname><given-names>AV</given-names></string-name>, <string-name><surname>Kolmogorov</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Multiplex de Bruijn graphs enable genome assembly from long, high-fidelity reads</article-title>. <source>Nat Biotechnol</source><year>2022</year>;<volume>40</volume>:<fpage>1075</fpage>–<lpage>81</lpage>.<pub-id pub-id-type="pmid">35228706</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Berlin</surname><given-names>K</given-names></string-name>, <string-name><surname>Koren</surname><given-names>S</given-names></string-name>, <string-name><surname>Chin</surname><given-names>C-S</given-names></string-name></person-group><etal>et al</etal><article-title>Assembling large genomes with single-molecule sequencing and locality-sensitive hashing</article-title>. <source>Nat Biotechnol</source><year>2015</year>;<volume>33</volume>:<fpage>623</fpage>–<lpage>30</lpage>.<pub-id pub-id-type="pmid">26006009</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Blanca</surname><given-names>A</given-names></string-name>, <string-name><surname>Harris</surname><given-names>RS</given-names></string-name>, <string-name><surname>Koslicki</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>The statistics of <italic toggle="yes">k</italic>-mers from a sequence undergoing a simple mutation process without spurious matches</article-title>. <source>J Comput Biol</source><year>2022</year>;<volume>29</volume>:<fpage>155</fpage>–<lpage>68</lpage>.<pub-id pub-id-type="pmid">35108101</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B7">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Broder</surname><given-names>AZ.</given-names></string-name></person-group> On the resemblance and containment of documents. In: <italic toggle="yes">Proceedings Compression and Complexity of SEQUENCES 1997 (Cat. No.97TB100171)</italic>. <fpage>21</fpage>–<lpage>9</lpage>. <year>1997</year>. <pub-id pub-id-type="doi">10.1109/SEQUEN.1997.666900</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad218-B8">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Califano</surname><given-names>A</given-names></string-name>, <string-name><surname>Rigoutsos</surname><given-names>I.</given-names></string-name></person-group> FLASH: a fast look-up algorithm for string homology. In: <italic toggle="yes">Proceedings of IEEE Conference on Computer Vision and Pattern Recognition (CVPR’93)</italic>. <fpage>353</fpage>–<lpage>9</lpage>. IEEE, <year>1993</year>.</mixed-citation>
    </ref>
    <ref id="btad218-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cheng</surname><given-names>H</given-names></string-name>, <string-name><surname>Concepcion</surname><given-names>GT</given-names></string-name>, <string-name><surname>Feng</surname><given-names>X</given-names></string-name></person-group><etal>et al</etal><article-title>Haplotype-resolved de novo assembly using phased assembly graphs with hifiasm</article-title>. <source>Nat Methods</source><year>2021</year>;<volume>18</volume>:<fpage>170</fpage>–<lpage>5</lpage>.<pub-id pub-id-type="pmid">33526886</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chikhi</surname><given-names>R</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P.</given-names></string-name></person-group><article-title>Informed and automated <italic toggle="yes">k</italic>-mer size selection for genome assembly</article-title>. <source>Bioinformatics</source><year>2014</year>;<volume>30</volume>:<fpage>31</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">23732276</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Du</surname><given-names>N</given-names></string-name>, <string-name><surname>Chen</surname><given-names>J</given-names></string-name>, <string-name><surname>Sun</surname><given-names>Y.</given-names></string-name></person-group><article-title>Improving the sensitivity of long read overlap detection using grouped short <italic toggle="yes">k</italic>-mer matches</article-title>. <source>BMC Genomics</source><year>2019</year>;<volume>20</volume>:<fpage>49</fpage>–<lpage>62</lpage>.<pub-id pub-id-type="pmid">30651061</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Edgar</surname><given-names>R.</given-names></string-name></person-group><article-title>Syncmers are more sensitive than minimizers for selecting conserved k-mers in biological sequences</article-title>. <source>PeerJ</source><year>2021</year>;<volume>9</volume>:<fpage>e10805</fpage>.<pub-id pub-id-type="pmid">33604186</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ekim</surname><given-names>B</given-names></string-name>, <string-name><surname>Berger</surname><given-names>B</given-names></string-name>, <string-name><surname>Chikhi</surname><given-names>R.</given-names></string-name></person-group><article-title>Minimizer-space de Bruijn graphs: whole-genome assembly of long reads in minutes on a personal computer</article-title>. <source>Cell Syst</source><year>2021</year>;<volume>12</volume>:<fpage>958</fpage>–<lpage>68.e6</lpage>.<pub-id pub-id-type="pmid">34525345</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Farach-Colton</surname><given-names>M</given-names></string-name>, <string-name><surname>Landau</surname><given-names>GM</given-names></string-name>, <string-name><surname>Sahinalp</surname><given-names>CS</given-names></string-name></person-group><etal>et al</etal><article-title>Optimal spaced seeds for faster approximate string matching</article-title>. <source>J Comput Syst Sci</source><year>2007</year>;<volume>73</volume>:<fpage>1035</fpage>–<lpage>44</lpage>.</mixed-citation>
    </ref>
    <ref id="btad218-B16">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Ivanov</surname><given-names>P</given-names></string-name>, <string-name><surname>Bichsel</surname><given-names>B</given-names></string-name>, <string-name><surname>Vechev</surname><given-names>M.</given-names></string-name></person-group> Fast and optimal sequence-to-graph alignment guided by seeds. In: <italic toggle="yes">Proceedings of the 26th International Conference on Research in Computational Molecular Biology (RECOMB’22)</italic>. <fpage>306</fpage>–<lpage>25</lpage>. Springer, <year>2022</year>.</mixed-citation>
    </ref>
    <ref id="btad218-B17">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Jain</surname><given-names>C</given-names></string-name>, <string-name><surname>Gibney</surname><given-names>D</given-names></string-name>, <string-name><surname>Thankachan</surname><given-names>SV.</given-names></string-name></person-group> Co-linear chaining with overlaps and gap costs. In: <italic toggle="yes">Proceedings of the 26th International Conference on Research in Computational Molecular Biology (RECOMB’22)</italic>. <fpage>246</fpage>–<lpage>62</lpage>. Springer, <year>2022</year>.</mixed-citation>
    </ref>
    <ref id="btad218-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Jain</surname><given-names>M</given-names></string-name>, <string-name><surname>Koren</surname><given-names>S</given-names></string-name>, <string-name><surname>Miga</surname><given-names>KH</given-names></string-name></person-group><etal>et al</etal><article-title>Nanopore sequencing and assembly of a human genome with ultra-long reads</article-title>. <source>Nat Biotechnol</source><year>2018</year>;<volume>36</volume>:<fpage>338</fpage>–<lpage>45</lpage>.<pub-id pub-id-type="pmid">29431738</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Koren</surname><given-names>S</given-names></string-name>, <string-name><surname>Walenz</surname><given-names>BP</given-names></string-name>, <string-name><surname>Berlin</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>Canu: scalable and accurate long-read assembly via adaptive k-mer weighting and repeat separation</article-title>. <source>Genome Res</source><year>2017</year>;<volume>27</volume>:<fpage>722</fpage>–<lpage>36</lpage>.<pub-id pub-id-type="pmid">28298431</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kucherov</surname><given-names>G</given-names></string-name>, <string-name><surname>Noé</surname><given-names>L</given-names></string-name>, <string-name><surname>Roytberg</surname><given-names>M.</given-names></string-name></person-group><article-title>Multiseed lossless filtration</article-title>. <source>IEEE/ACM Trans Comput Biol Bioinform</source><year>2005</year>;<volume>2</volume>:<fpage>51</fpage>–<lpage>61</lpage>.<pub-id pub-id-type="pmid">17044164</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group><article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title>. <source>Bioinformatics</source><year>2018</year>;<volume>34</volume>:<fpage>3094</fpage>–<lpage>100</lpage>.<pub-id pub-id-type="pmid">29750242</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>M</given-names></string-name>, <string-name><surname>Ma</surname><given-names>B</given-names></string-name>, <string-name><surname>Kisman</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>PatternHunter II: highly sensitive and fast homology search</article-title>. <source>J Bioinform Comput Biol</source><year>2004</year>;<volume>2</volume>:<fpage>417</fpage>–<lpage>39</lpage>.<pub-id pub-id-type="pmid">15359419</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lin</surname><given-names>Y</given-names></string-name>, <string-name><surname>Yuan</surname><given-names>J</given-names></string-name>, <string-name><surname>Kolmogorov</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Assembly of long error-prone reads using de Bruijn graphs</article-title>. <source>Proc Natl Acad Sci USA</source><year>2016</year>;<volume>113</volume>:<fpage>E8396</fpage>–<lpage>405</lpage>.<pub-id pub-id-type="pmid">27956617</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ma</surname><given-names>B</given-names></string-name>, <string-name><surname>Tromp</surname><given-names>J</given-names></string-name>, <string-name><surname>Li</surname><given-names>M.</given-names></string-name></person-group><article-title>PatternHunter: faster and more sensitive homology search</article-title>. <source>Bioinformatics</source><year>2002</year>;<volume>18</volume>:<fpage>440</fpage>–<lpage>5</lpage>.<pub-id pub-id-type="pmid">11934743</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Maier</surname><given-names>BD</given-names></string-name>, <string-name><surname>Sahlin</surname><given-names>K.</given-names></string-name></person-group><article-title>Entropy predicts fuzzy-seed sensitivity</article-title>. In: <italic toggle="yes">Proceedings of the 27th International Conference on Research in Computational Molecular Biology (RECOMB’23)</italic>. 203–204. Springer, 2023.</mixed-citation>
    </ref>
    <ref id="btad218-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mak</surname><given-names>D</given-names></string-name>, <string-name><surname>Gelfand</surname><given-names>Y</given-names></string-name>, <string-name><surname>Benson</surname><given-names>G.</given-names></string-name></person-group><article-title>Indel seeds for homology search</article-title>. <source>Bioinformatics</source><year>2006</year>;<volume>22</volume>:<fpage>e341</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">16873491</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marçais</surname><given-names>G</given-names></string-name>, <string-name><surname>DeBlasio</surname><given-names>D</given-names></string-name>, <string-name><surname>Kingsford</surname><given-names>C.</given-names></string-name></person-group><article-title>Asymptotically optimal minimizers schemes</article-title>. <source>Bioinformatics</source><year>2018</year>;<volume>34</volume>:<fpage>i13</fpage>–<lpage>22</lpage>.<pub-id pub-id-type="pmid">29949995</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marçais</surname><given-names>G</given-names></string-name>, <string-name><surname>DeBlasio</surname><given-names>D</given-names></string-name>, <string-name><surname>Pandey</surname><given-names>P</given-names></string-name></person-group><etal>et al</etal><article-title>Locality-sensitive hashing for the edit distance</article-title>. <source>Bioinformatics</source><year>2019</year>;<volume>35</volume>:<fpage>i127</fpage>–<lpage>35</lpage>.<pub-id pub-id-type="pmid">31510667</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B29">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Myers</surname><given-names>G</given-names></string-name>, <string-name><surname>Miller</surname><given-names>W.</given-names></string-name></person-group> Chaining multiple-alignment fragments in sub-quadratic time. In: <italic toggle="yes">Proceedings of the 6th ACM-SIAM Symposium on Discrete Algorithms (SODA’95)</italic>, Vol. 95. <fpage>38</fpage>–<lpage>47</lpage>. <year>1995</year>.</mixed-citation>
    </ref>
    <ref id="btad218-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Nurk</surname><given-names>S</given-names></string-name>, <string-name><surname>Walenz</surname><given-names>BP</given-names></string-name>, <string-name><surname>Rhie</surname><given-names>A</given-names></string-name></person-group><etal>et al</etal><article-title>HiCanu: accurate assembly of segmental duplications, satellites, and allelic variants from high-fidelity long reads</article-title>. <source>Genome Res</source><year>2020</year>;<volume>30</volume>:<fpage>1291</fpage>–<lpage>305</lpage>.<pub-id pub-id-type="pmid">32801147</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ono</surname><given-names>Y</given-names></string-name>, <string-name><surname>Asai</surname><given-names>K</given-names></string-name>, <string-name><surname>Hamada</surname><given-names>M.</given-names></string-name></person-group><article-title>PBSIM2: a simulator for long-read sequencers with a novel generative model of quality scores</article-title>. <source>Bioinformatics</source><year>2021</year>;<volume>37</volume>:<fpage>589</fpage>–<lpage>95</lpage>.<pub-id pub-id-type="pmid">32976553</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rautiainen</surname><given-names>M</given-names></string-name>, <string-name><surname>Marschall</surname><given-names>T.</given-names></string-name></person-group><article-title>MBG: minimizer-based sparse de Bruijn graph construction</article-title>. <source>Bioinformatics</source><year>2021</year>;<volume>37</volume>:<fpage>2476</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">33475133</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rhoads</surname><given-names>A</given-names></string-name>, <string-name><surname>Au</surname><given-names>KF.</given-names></string-name></person-group><article-title>PacBio sequencing and its applications</article-title>. <source>Genomics Proteomics Bioinformatics</source><year>2015</year>;<volume>13</volume>:<fpage>278</fpage>–<lpage>89</lpage>.<pub-id pub-id-type="pmid">26542840</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Roberts</surname><given-names>M</given-names></string-name>, <string-name><surname>Hayes</surname><given-names>W</given-names></string-name>, <string-name><surname>Hunt</surname><given-names>BR</given-names></string-name></person-group><etal>et al</etal><article-title>Reducing storage requirements for biological sequence comparison</article-title>. <source>Bioinformatics</source><year>2004a</year>;<volume>20</volume>:<fpage>3363</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">15256412</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Roberts</surname><given-names>M</given-names></string-name>, <string-name><surname>Hunt</surname><given-names>BR</given-names></string-name>, <string-name><surname>Yorke</surname><given-names>JA</given-names></string-name></person-group><etal>et al</etal><article-title>A preprocessor for shotgun assembly of large genomes</article-title>. <source>J Comput Biol</source><year>2004b</year>;<volume>11</volume>:<fpage>734</fpage>–<lpage>52</lpage>.<pub-id pub-id-type="pmid">15579242</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ruan</surname><given-names>J</given-names></string-name>, <string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group><article-title>Fast and accurate long-read assembly with wtdbg2</article-title>. <source>Nat Methods</source><year>2020</year>;<volume>17</volume>:<fpage>155</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">31819265</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B37">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sahlin</surname><given-names>K.</given-names></string-name></person-group><article-title>Effective sequence similarity detection with strobemers</article-title>. <source>Genome Res</source><year>2021</year>;<volume>31</volume>:<fpage>2080</fpage>–<lpage>94</lpage>.<pub-id pub-id-type="pmid">34667119</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B38">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sahlin</surname><given-names>K.</given-names></string-name></person-group><article-title>Strobealign: flexible seed size enables ultra-fast and accurate read alignment</article-title>. <source>Genome Biol</source><year>2022</year>;<volume>23</volume>:<fpage>1</fpage>–<lpage>27</lpage>.<pub-id pub-id-type="pmid">34980209</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B39">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Schleimer</surname><given-names>S</given-names></string-name>, <string-name><surname>Wilkerson</surname><given-names>DS</given-names></string-name>, <string-name><surname>Aiken</surname><given-names>A.</given-names></string-name></person-group> Winnowing: local algorithms for document fingerprinting. In: <italic toggle="yes">Proceedings of the 2003 ACM SIGMOD International Conference on Management of Data (SIGMOD/PODS’03)</italic>. <fpage>76</fpage>–<lpage>85</lpage>. <year>2003</year>.</mixed-citation>
    </ref>
    <ref id="btad218-B40">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Song</surname><given-names>Y</given-names></string-name>, <string-name><surname>Tang</surname><given-names>H</given-names></string-name>, <string-name><surname>Zhang</surname><given-names>H</given-names></string-name></person-group><etal>et al</etal><article-title>Overlap detection on long, error-prone sequencing reads via smooth q-gram</article-title>. <source>Bioinformatics</source><year>2020</year>;<volume>36</volume>:<fpage>4838</fpage>–<lpage>45</lpage>.<pub-id pub-id-type="pmid">32311007</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B41">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sun</surname><given-names>Y</given-names></string-name>, <string-name><surname>Buhler</surname><given-names>J.</given-names></string-name></person-group><article-title>Designing multiple simultaneous seeds for DNA similarity search</article-title>. <source>J Comput Biol</source><year>2005</year>;<volume>12</volume>:<fpage>847</fpage>–<lpage>61</lpage>.<pub-id pub-id-type="pmid">16108721</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10311335</article-id>
    <article-id pub-id-type="pmid">37387132</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad218</article-id>
    <article-id pub-id-type="publisher-id">btad218</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Genome Sequence Analysis</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Seeding with minimized subsequence</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Li</surname>
          <given-names>Xiang</given-names>
        </name>
        <aff><institution>Department of Computer Science and Engineering, The Pennsylvania State University, University Park</institution>, PA 16802, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Shi</surname>
          <given-names>Qian</given-names>
        </name>
        <aff><institution>Department of Computer Science and Engineering, The Pennsylvania State University, University Park</institution>, PA 16802, <country country="US">USA</country></aff>
        <xref rid="btad218-FM1" ref-type="author-notes"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Chen</surname>
          <given-names>Ke</given-names>
        </name>
        <aff><institution>Department of Computer Science and Engineering, The Pennsylvania State University, University Park</institution>, PA 16802, <country country="US">USA</country></aff>
        <xref rid="btad218-FM1" ref-type="author-notes"/>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Shao</surname>
          <given-names>Mingfu</given-names>
        </name>
        <aff><institution>Department of Computer Science and Engineering, The Pennsylvania State University, University Park</institution>, PA 16802, <country country="US">USA</country></aff>
        <aff><institution>Huck Institutes of the Life Sciences, The Pennsylvania State University, University Park</institution>, PA 16802, <country country="US">USA</country></aff>
        <xref rid="btad218-cor1" ref-type="corresp"/>
        <!--mxs2589@psu.edu-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad218-cor1">Corresponding author. Department of Computer Science and Engineering, The Pennsylvania State University, W205A Westgate Building, University Park, PA 16802, USA. E-mail: <email>mxs2589@psu.edu</email> (M.S.)</corresp>
      <fn id="btad218-FM1">
        <p>Qian Shi and Ke Chen Equal contribution.</p>
      </fn>
    </author-notes>
    <pub-date pub-type="collection">
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-06-30">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB/ECCB 2023 Proceedings</issue-title>
    <fpage>i232</fpage>
    <lpage>i241</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad218.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Modern methods for computation-intensive tasks in sequence analysis (e.g. read mapping, sequence alignment, genome assembly, etc.) often first transform each sequence into a list of short, regular-length seeds so that compact data structures and efficient algorithms can be employed to handle the ever-growing large-scale data. Seeding methods using <italic toggle="yes">k</italic>mers (substrings of length <italic toggle="yes">k</italic>) have gained tremendous success in processing sequencing data with low mutation/error rates. However, they are much less effective for sequencing data with high error rates as <italic toggle="yes">k</italic>mers cannot tolerate errors.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We propose SubseqHash, a strategy that uses subsequences, rather than substrings, as seeds. Formally, SubseqHash maps a string of length <italic toggle="yes">n</italic> to its smallest subsequence of length <italic toggle="yes">k</italic>, <italic toggle="yes">k </italic>&lt;<italic toggle="yes"> n</italic>, according to a given order overall length-<italic toggle="yes">k</italic> strings. Finding the smallest subsequence of a string by enumeration is impractical as the number of subsequences grows exponentially. To overcome this barrier, we propose a novel algorithmic framework that consists of a specifically designed order (termed ABC order) and an algorithm that computes the minimized subsequence under an ABC order in polynomial time. We first show that the ABC order exhibits the desired property and the probability of hash collision using the ABC order is close to the Jaccard index. We then show that SubseqHash overwhelmingly outperforms the substring-based seeding methods in producing high-quality seed-matches for three critical applications: read mapping, sequence alignment, and overlap detection. SubseqHash presents a major algorithmic breakthrough for tackling the high error rates and we expect it to be widely adapted for long-reads analysis.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>SubseqHash is freely available at <ext-link xlink:href="https://github.com/Shao-Group/subseqhash" ext-link-type="uri">https://github.com/Shao-Group/subseqhash</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Science Foundation</institution>
            <institution-id institution-id-type="DOI">10.13039/100000001</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>2019797</award-id>
        <award-id>2145171</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Institutes of Health</institution>
            <institution-id institution-id-type="DOI">10.13039/100000002</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>R01HG011065</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="10"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Transforming a sequence into a list of seeds (also known as markers) that are then processed in place of the original sequence is a common approach in sequence analysis as a remedy for the dreadfully expensive full-length comparisons. The resulting seeds of such a transformation are often regular in length and much shorter than the original sequences, making it possible to apply efficient data structures and fast algorithms. For example, in read mapping, the popular seed-and-extend strategy (<xref rid="btad218-B2" ref-type="bibr">Altschul et al. 1990</xref>, <xref rid="btad218-B3" ref-type="bibr">1997</xref>) first identifies seed-matches (i.e. pairs of identical seeds; also known as anchors) between a read and a reference, then performs local alignment around these seeds to look for statistically significant matches. In sequence alignment, seed-matches across sequences are first identified, followed by efficient chaining algorithms to find a co-linear chain of matching seeds that maximizes a scoring function (<xref rid="btad218-B29" ref-type="bibr">Myers and Miller 1995</xref>; <xref rid="btad218-B1" ref-type="bibr">Abouelhoda and Ohlebusch 2005</xref>; <xref rid="btad218-B17" ref-type="bibr">Jain et al. 2022</xref>). In genome assembly, a (sparse) de Bruijn graph can be constructed in which seeds are used as vertices and two seeds are linked by an edge if they are adjacent in some reads (<xref rid="btad218-B23" ref-type="bibr">Lin et al. 2016</xref>; <xref rid="btad218-B36" ref-type="bibr">Ruan and Li 2020</xref>; <xref rid="btad218-B14" ref-type="bibr">Ekim et al. 2021</xref>; <xref rid="btad218-B32" ref-type="bibr">Rautiainen and Marschall 2021</xref>; <xref rid="btad218-B4" ref-type="bibr">Bankevich et al. 2022</xref>). To mitigate all-versus-all pairwise comparisons in applications, such as aligning multiple sequences and constructing overlap/string graphs (<xref rid="btad218-B19" ref-type="bibr">Koren et al. 2017</xref>; <xref rid="btad218-B30" ref-type="bibr">Nurk et al. 2020</xref>; <xref rid="btad218-B9" ref-type="bibr">Cheng et al. 2021</xref>), seeds can be used to bucket sequences (i.e. assigning a sequence into buckets labeled by its own seeds), followed by pairwise comparisons in individual buckets (<xref rid="btad218-B5" ref-type="bibr">Berlin et al. 2015</xref>; <xref rid="btad218-B40" ref-type="bibr">Song et al. 2020</xref>). The efficiency and accuracy of these methods heavily rely on the quality of the generated seeds. Desired properties include high sensitivity (i.e. biologically related sequences producing many seed-matches) and a low false positive rate (i.e. unrelated sequences producing few seed-matches).</p>
    <p>Arguably the most widely used seeds are simply <italic toggle="yes">k</italic>mers (i.e. substrings of fixed length <italic toggle="yes">k</italic>). Sketching approaches, such as Minimizers (<xref rid="btad218-B39" ref-type="bibr">Schleimer et al. 2003</xref>; <xref rid="btad218-B34" ref-type="bibr">Roberts et al. 2004a</xref>,<xref rid="btad218-B35" ref-type="bibr">b</xref>; <xref rid="btad218-B27" ref-type="bibr">Marçais et al. 2018</xref>) or syncmers (<xref rid="btad218-B13" ref-type="bibr">Edgar 2021</xref>), are often combined to select a subset of <italic toggle="yes">k</italic>mers aiming for scaling. Seeding methods using <italic toggle="yes">k</italic>mers have gained success in almost all aspects of sequence analysis especially on data with low error rates. However, requiring exact matches of <italic toggle="yes">k</italic> consecutive characters becomes less effective in comparing biologically related sequences with high mutation rates or error rates. Such scenarios include comparing homologous genes or whole genomes from distant species and processing long-read sequencing data generated by PacBio (<xref rid="btad218-B33" ref-type="bibr">Rhoads and Au 2015</xref>) and Oxford Nanopore (<xref rid="btad218-B18" ref-type="bibr">Jain et al. 2018</xref>) technologies. Observe that a single mutation/error can change <italic toggle="yes">k</italic> consecutive <italic toggle="yes">k</italic>mers in the sequence and the probability of a <italic toggle="yes">k</italic>mer remaining intact under a uniform mutation model decreases exponentially as <italic toggle="yes">k</italic> grows (<xref rid="btad218-B6" ref-type="bibr">Blanca et al. 2022</xref>). This greatly challenges the <italic toggle="yes">k</italic>mer-based seeding methods and puts them in a dilemma: choosing a large <italic toggle="yes">k</italic> results in few seed-matches even in biologically related sequences (i.e. low sensitivity), while making <italic toggle="yes">k</italic> too small suffers from a high false positive rate as unrelated sequences can, by chance, share many short common substrings. Existing tools, such as KmerGenie (<xref rid="btad218-B10" ref-type="bibr">Chikhi and Medvedev 2014</xref>), help select a size of <italic toggle="yes">k</italic>mers that balances its sensitivity and false positive rate based on the data. But due to the intrinsic weakness of <italic toggle="yes">k</italic>mers against mutations, even an optimal choice of <italic toggle="yes">k</italic> can still produce unsatisfactory results.</p>
    <p>Alternative approaches have been proposed to collect non-consecutive characters as seeds. Spaced seeds (<xref rid="btad218-B8" ref-type="bibr">Califano and Rigoutsos 1993</xref>; <xref rid="btad218-B24" ref-type="bibr">Ma et al. 2002</xref>) are extracted by applying a predefined pattern, such as 1110111 on a string where a 1 means the character at that position is taken and a 0 means it is ignored/masked. The masked positions allow seed-matches to occur over substitutions, but because of the fixed pattern, spaced seeds can only handle substitutions at predefined locations and are still vulnerable to insertions and deletions (indels). Indel seeds (<xref rid="btad218-B26" ref-type="bibr">Mak et al. 2006</xref>) use patterns with wild-cards to accommodate certain numbers of indels. But again only indels at the predefined regions can be managed. Using multiple patterns (<xref rid="btad218-B22" ref-type="bibr">Li et al. 2004</xref>; <xref rid="btad218-B20" ref-type="bibr">Kucherov et al. 2005</xref>; <xref rid="btad218-B41" ref-type="bibr">Sun and Buhler 2005</xref>; <xref rid="btad218-B15" ref-type="bibr">Farach-Colton et al. 2007</xref>) alleviates the restrictions of a single pattern at the cost of more computations but still cannot handle mutations/errors at arbitrary locations.</p>
    <p>It is also worth mentioning that there have been successful seeding methods that combine two or more pre-extracted (shorter) seeds. For example, grouped methods (<xref rid="btad218-B12" ref-type="bibr">Du et al. 2019</xref>) use two or more independently produced <italic toggle="yes">k</italic>mers as seeds. The Order Min Hash approach (<xref rid="btad218-B28" ref-type="bibr">Marçais et al. 2019</xref>) selects multiple <italic toggle="yes">k</italic>mers from a sequence with relative positions preserved. The recently proposed <italic toggle="yes">k</italic>mer-alternative method strobemer and its variants (<xref rid="btad218-B37" ref-type="bibr">Sahlin 2021</xref>; <xref rid="btad218-B25" ref-type="bibr">Maier and Sahlin 2022</xref>; <xref rid="btad218-B38" ref-type="bibr">Sahlin 2022</xref>) pick and concatenate <italic toggle="yes">k</italic>mers from multiple consecutive predetermined windows. This provides more flexibility on the spacing between extracted <italic toggle="yes">k</italic>mers and therefore is less susceptible to different mutation rates. Nonetheless, since these methods all use <italic toggle="yes">k</italic>mers as building blocks, they cannot fully resolve the drawback of <italic toggle="yes">k</italic>mer-based methods. In addition, we consider these approaches orthogonal to the “basic” seeding methods (such as <italic toggle="yes">k</italic>mers and our method described below) in the sense that they can be applied on top of any kind of basic seeds.</p>
    <p>In this article, we explore the use of subsequences, rather than substrings, as seeds. The key observation is that two similar strings may share few or even zero substrings (of length <italic toggle="yes">k</italic>) but can contain many common subsequences (of length <italic toggle="yes">k</italic> or longer). Consider an example with two similar strings of length 7: <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">s</mml:mi><mml:mo>=</mml:mo><mml:mtext>ACGCCTA</mml:mtext></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">t</mml:mi><mml:mo>=</mml:mo><mml:mtext>ACGGCTA</mml:mtext></mml:mrow></mml:math></inline-formula> that differ by one substitution in the middle (i.e. their edit distance is 1). Clearly, <bold><italic toggle="yes">s</italic></bold> and <bold><italic toggle="yes">t</italic></bold> do not share any <italic toggle="yes">k</italic>mer for <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≥</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>, leading to zero seed-matches for any <italic toggle="yes">k</italic>mer-based seeding methods (when <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≥</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> is used). On the other hand, two-thirds of the total 21 unique length-4 subsequences of <bold><italic toggle="yes">s</italic></bold> are also subsequences of <bold><italic toggle="yes">t</italic></bold>. In fact, the Jaccard index between the two sets of length-4 subsequences of <bold><italic toggle="yes">s</italic></bold> and <bold><italic toggle="yes">t</italic></bold> is <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mn>14</mml:mn><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>21</mml:mn><mml:mo>+</mml:mo><mml:mn>24</mml:mn><mml:mo>−</mml:mo><mml:mn>14</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>≈</mml:mo><mml:mn>0.45</mml:mn></mml:mrow></mml:math></inline-formula>. According to the property of MinHash (<xref rid="btad218-B7" ref-type="bibr">Broder 1997</xref>), if the “smallest” subsequences of length 4 (with respect to a fully random order, i.e. an order picked uniformly at random from all possible orders over strings of length 4) from <bold><italic toggle="yes">s</italic></bold> and <bold><italic toggle="yes">t</italic></bold> are picked as their respective seeds, then the probability of hash collision (i.e. producing a seed-match) is also about 0.45. Although rather simple, this example demonstrates the potential advantage of using subsequences as seeds: as it is more tolerant to edits happening at any position, it is more likely to produce seed-matches for similar sequences, and therefore provides enhanced sensitivity, particularly for data with a high mutation/error rate.</p>
    <p>To this end, we present a subsequence-based seeding method named SubseqHash. It maps a string of length <italic toggle="yes">n</italic> to its smallest subsequence of length <italic toggle="yes">k</italic> (i.e. the seed), <italic toggle="yes">k </italic>&lt;<italic toggle="yes"> n</italic>, according to a given order overall length-<italic toggle="yes">k</italic> strings. There is one caveat: the number of subsequences grows exponentially in a string, which makes the computation of the smallest subsequence intractable when a fully random order is used. To overcome this difficulty, we propose a new algorithmic framework, consisting of a specifically designed order, named ABC order, and an algorithm that finds the smallest subsequence under an ABC order in polynomial time (Section 2). We show experimentally that an ABC order exhibits similar properties as a fully random order and that the probability of hash collision is close to that when a fully random order is used (Sections 3.1 and 3.2). We finally demonstrate the superiority of SubseqHash over the <italic toggle="yes">k</italic>mer-based seeding method Minimizer in several applications, including sequence alignment, read mapping, and overlap detection (Sections 3.4–3.6).</p>
  </sec>
  <sec>
    <title>2 SubseqHash</title>
    <sec>
      <title>2.1 Definitions of SubseqHash</title>
      <p>Let <bold><italic toggle="yes">x</italic></bold> be a string of length <italic toggle="yes">n</italic> over an alphabet Σ. Given an integer <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, denote by <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> the set of all subsequences of <bold><italic toggle="yes">x</italic></bold> of length <italic toggle="yes">k</italic>. Let <italic toggle="yes">π</italic> be a permutation of <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, i.e. <italic toggle="yes">π</italic> defines an order over all possible strings of length <italic toggle="yes">k</italic>. Define <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as the smallest string in <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> according to <italic toggle="yes">π</italic>. In other words, the function <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub></mml:mrow></mml:math></inline-formula> maps a string of length <italic toggle="yes">n</italic> to its smallest (defined by <italic toggle="yes">π</italic>) subsequence of length <italic toggle="yes">k</italic>; formally, <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>arg</mml:mi><mml:msub><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the rank of <bold><italic toggle="yes">z</italic></bold> in the order defined by <italic toggle="yes">π</italic>. We use SubseqHash to term such a hashing function <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>2.2 Probability of hash collision</title>
      <p>The intuition behind SubseqHash is that a few edits between two sequences may destroy most of their common substrings but many common subsequences can survive. We use the Jaccard index to measure the similarity of two sets. Given two strings <bold><italic toggle="yes">x</italic></bold> and <bold><italic toggle="yes">y</italic></bold>, the Jaccard index for their subsequences of length <italic toggle="yes">k</italic> is defined as <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>/</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. The Jaccard index for their substrings can be defined similarly. In <xref rid="sup1" ref-type="supplementary-material">Supplementary Notes S1</xref> and <xref rid="sup1" ref-type="supplementary-material">S2</xref>, we estimate and compare the Jaccard index for subsequences and substrings; in general, the Jaccard index for subsequences is larger than that for substrings, verifying the intuition.</p>
      <p>We say an order <italic toggle="yes">π</italic> over <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> is “fully random” if <italic toggle="yes">π</italic> is drawn uniformly at random from all orders. For a fully random order <italic toggle="yes">π</italic>, the probability of hash collision of <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub></mml:mrow></mml:math></inline-formula> is exactly the Jaccard index for subsequences according to the property of MinHash (<xref rid="btad218-B7" ref-type="bibr">Broder 1997</xref>), i.e. <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mi>Pr</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for any two strings <bold><italic toggle="yes">x</italic></bold> and <bold><italic toggle="yes">y</italic></bold>. If <italic toggle="yes">π</italic> is not fully random then this may not hold. For example, when the lexicographic order is used, the empirical probability of hash collision reduces considerably (Section 3.2).</p>
    </sec>
    <sec>
      <title>2.3 Algorithmic framework for constructing SubseqHash</title>
      <p>The complexity of calculating <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for a given string <bold><italic toggle="yes">x</italic></bold> also depends on the choice of <italic toggle="yes">π</italic>. For a fully random order <italic toggle="yes">π</italic>, one can compute <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by enumerating all subsequences of <bold><italic toggle="yes">x</italic></bold> and picking the smallest one. Another approach is to traverse all strings of length <italic toggle="yes">k</italic> down the order <italic toggle="yes">π</italic> and return the first one that is a subsequence of <bold><italic toggle="yes">x</italic></bold>. (Determining if a string <bold><italic toggle="yes">z</italic></bold> is a subsequence of another string <bold><italic toggle="yes">x</italic></bold> can be done in <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time, where <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mo>·</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> denotes the length of a string.) Both approaches run in exponential time. On the other hand, when the lexicographic order <italic toggle="yes">π</italic> is used, <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> can be computed in linear time; the downside is that the probability of hash collision gets reduced significantly as stated above.</p>
      <p>We propose a novel approach to balance performance and efficiency. The idea is to use a special order <italic toggle="yes">π</italic> that allows for computing <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in polynomial time. Such a special order is not fully random, but is designed to be “quite” random, and therefore achieves a probability of hash collision comparable with a fully random order. The special order <italic toggle="yes">π</italic> and the polynomial time algorithm are described in the next two sections.</p>
    </sec>
    <sec>
      <title>2.4 The ABC order</title>
      <p>We start with designing an order <italic toggle="yes">π</italic> over <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, named ABC order. Let <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mi>d</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> be an integer parameter. Essentially, <italic toggle="yes">π</italic> is given as a scoring function that maps a string <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> to a pair <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow></mml:math></inline-formula>. Then all strings in <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> are ordered as follows: for <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, define <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> if and only if <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, or <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mo>|</mml:mo><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. The construction of <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (see below) makes it extremely unlikely to have <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo>≠</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:math></inline-formula>. When such a rare case happens, we define <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> if and only if <bold><italic toggle="yes">z</italic></bold> is lexicographically smaller than <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
      <p>We specify such a function <italic toggle="yes">π</italic> for DNA strings by assuming <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mo>Σ</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi mathvariant="normal">A</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi mathvariant="normal">C</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi mathvariant="normal">G</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi mathvariant="normal">T</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. The function <italic toggle="yes">π</italic> is governed by three (random) tables <italic toggle="yes">A</italic>, <italic toggle="yes">B</italic>, and <italic toggle="yes">C</italic>; hence the name. Table <italic toggle="yes">A</italic> is a 3D real matrix of dimension <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>×</mml:mo><mml:mi>d</mml:mi><mml:mo>×</mml:mo><mml:mo>|</mml:mo><mml:mo>Σ</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, i.e. <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>×</mml:mo><mml:mi>d</mml:mi><mml:mo>×</mml:mo><mml:mo>|</mml:mo><mml:mo>Σ</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>. Table <italic toggle="yes">B</italic> is also of dimension <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>×</mml:mo><mml:mi>d</mml:mi><mml:mo>×</mml:mo><mml:mo>|</mml:mo><mml:mo>Σ</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mo>σ</mml:mo><mml:mo>∈</mml:mo><mml:mo>Σ</mml:mo></mml:mrow></mml:math></inline-formula>. Table <italic toggle="yes">C</italic> has dimension <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>×</mml:mo><mml:mo>|</mml:mo><mml:mo>Σ</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mo>σ</mml:mo><mml:mo>∈</mml:mo><mml:mo>Σ</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>These three tables are randomly generated in the following way. Each element <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is drawn independently and uniformly at random from a predetermined subset of <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mi mathvariant="double-struck">R</mml:mi></mml:math></inline-formula>; our implementation uses <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>31</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. For any fixed <italic toggle="yes">i</italic> and <italic toggle="yes">j</italic>, <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is picked from the four pairs <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> uniformly at random without replacement, i.e. <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> if <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. Last, for any fixed <italic toggle="yes">i</italic>, <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, each element <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is drawn independently and uniformly at random from <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. If the parameter <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mi>d</mml:mi><mml:mo>≥</mml:mo><mml:mo>|</mml:mo><mml:mo>Σ</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>, then we do this without replacement, i.e. <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> if <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. Please see <xref rid="sup1" ref-type="supplementary-material">Supplementary Note S3</xref> for an example.</p>
      <p>Once the tables <italic toggle="yes">A</italic>, <italic toggle="yes">B</italic>, and <italic toggle="yes">C</italic> are generated, the scoring function <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is determined for any string <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>. Write <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mo>Σ</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. For the sake of simplicity, denote <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by <italic toggle="yes">ψ<sub>i</sub></italic> and <italic toggle="yes">ω<sub>i</sub></italic>, respectively; also denote the first and the second element in the pair <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> by <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, respectively.</p>
      <p>The initial values are set to <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>ψ</mml:mo></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>ω</mml:mo></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. For <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, we use recurrences
and
</p>
      <disp-formula id="E1">
        <mml:math id="M1" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ψ</mml:mo>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ψ</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mo>−</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
            </mml:msub>
            <mml:mo>+</mml:mo>
            <mml:mi>C</mml:mi>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>z</mml:mi>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo> </mml:mo>
            <mml:mi>mod</mml:mi>
            <mml:mo> </mml:mo>
            <mml:mi>d</mml:mi>
            <mml:mo>,</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <disp-formula id="E2">
        <mml:math id="M2" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ω</mml:mo>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ω</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mo>−</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
            </mml:msub>
            <mml:mo>·</mml:mo>
            <mml:mi>B</mml:mi>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ψ</mml:mo>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mrow>
                  <mml:mo stretchy="false">[</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>z</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="false">]</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:mn>1</mml:mn>
            </mml:msub>
            <mml:mo>+</mml:mo>
            <mml:mi>A</mml:mi>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ψ</mml:mo>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>z</mml:mi>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo>·</mml:mo>
            <mml:mi>B</mml:mi>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ψ</mml:mo>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mrow>
                  <mml:mo stretchy="false">[</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>z</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="false">]</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:mn>2</mml:mn>
            </mml:msub>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Observe that if <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:mi>d</mml:mi><mml:mo>≥</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, then one edit in the string is guaranteed to alter the value of <italic toggle="yes">ψ</italic>, while two edits have a small chance (approximately <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>) to result in the same <italic toggle="yes">ψ</italic>. In addition, due to the use of –1 in table <italic toggle="yes">B</italic>, the value of <italic toggle="yes">ω</italic> can be substantially changed with even a single mutation. Combined, a few edits can cause a drastic change in both <italic toggle="yes">ψ</italic> and <italic toggle="yes">ω</italic>, and therefore the rank of strings in the order, which is a desired property; see Section 3.1 for more discussions.</p>
    </sec>
    <sec>
      <title>2.5 Algorithm for computing the smallest subsequence with an ABC order</title>
      <p>Let <italic toggle="yes">π</italic> be an ABC order. We design an efficient algorithm to find <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>arg</mml:mi><mml:msub><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for any given <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>. Since the scoring function <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:mo>π</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is defined by recurrences, it is natural to solve <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> using a dynamic programming algorithm. Consider a subproblem parameterized by <italic toggle="yes">l</italic>, <italic toggle="yes">i</italic>, and <italic toggle="yes">j</italic>, where <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>l</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>, which is defined to seek a subsequence <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is minimized or maximized. We calculate both the maximized and minimized values because they would be switched when encountering a pair from table <italic toggle="yes">B</italic> with –1 being its first element. Furthermore, both values are needed at the end since the definition of an ABC order requires finding the subsequence that maximizes the absolute value of <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>Formally, for each <italic toggle="yes">l</italic>, <italic toggle="yes">i</italic>, and <italic toggle="yes">j</italic>, we define subproblems:
and
</p>
      <disp-formula id="E3">
        <mml:math id="M3" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi mathvariant="italic">min</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>l</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>j</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo>:</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:munder>
              <mml:mrow>
                <mml:mi>min</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>z</mml:mi>
                <mml:mo>∈</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>S</mml:mi>
                  </mml:mrow>
                  <mml:mi>i</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mn>1</mml:mn>
                </mml:msub>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mn>2</mml:mn>
                </mml:msub>
                <mml:mo>⋯</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mi>l</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo> </mml:mo>
                <mml:mo> </mml:mo>
                <mml:mtext>and</mml:mtext>
                <mml:mo> </mml:mo>
                <mml:mo> </mml:mo>
                <mml:mo>ψ</mml:mo>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>z</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mi>j</mml:mi>
              </mml:mrow>
            </mml:munder>
            <mml:mo>ω</mml:mo>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi>z</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <disp-formula id="E4">
        <mml:math id="M4" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi mathvariant="italic">max</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>l</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>j</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo>:</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:munder>
              <mml:mrow>
                <mml:mi>max</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>z</mml:mi>
                <mml:mo>∈</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>S</mml:mi>
                  </mml:mrow>
                  <mml:mi>i</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mn>1</mml:mn>
                </mml:msub>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mn>2</mml:mn>
                </mml:msub>
                <mml:mo>⋯</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mi>l</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo> </mml:mo>
                <mml:mo> </mml:mo>
                <mml:mtext>and</mml:mtext>
                <mml:mo> </mml:mo>
                <mml:mo> </mml:mo>
                <mml:mo>ψ</mml:mo>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>z</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mi>j</mml:mi>
              </mml:mrow>
            </mml:munder>
            <mml:mo>ω</mml:mo>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi>z</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>They can be calculated with the recurrences below, in which <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mi>mod</mml:mi><mml:mo> </mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>.
</p>
      <disp-formula id="E5">
        <mml:math id="M5" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mtable>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>T</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi mathvariant="italic">min</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo stretchy="true">[</mml:mo>
                    <mml:mi>l</mml:mi>
                    <mml:mo stretchy="true">]</mml:mo>
                    <mml:mo stretchy="true">[</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="true">]</mml:mo>
                    <mml:mo stretchy="true">[</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo stretchy="true">]</mml:mo>
                    <mml:mo>=</mml:mo>
                    <mml:mi>min</mml:mi>
                    <mml:mrow>
                      <mml:mo stretchy="true">{</mml:mo>
                      <mml:mrow>
                        <mml:mtable>
                          <mml:mtr columnalign="left">
                            <mml:mtd columnalign="left">
                              <mml:mrow>
                                <mml:msub>
                                  <mml:mrow>
                                    <mml:mi>T</mml:mi>
                                  </mml:mrow>
                                  <mml:mrow>
                                    <mml:mi mathvariant="italic">min</mml:mi>
                                  </mml:mrow>
                                </mml:msub>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>l</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mn>1</mml:mn>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                              </mml:mrow>
                            </mml:mtd>
                          </mml:mtr>
                          <mml:mtr columnalign="left">
                            <mml:mtd columnalign="left">
                              <mml:mrow>
                                <mml:mi>A</mml:mi>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:msub>
                                  <mml:mrow>
                                    <mml:mi>x</mml:mi>
                                  </mml:mrow>
                                  <mml:mi>l</mml:mi>
                                </mml:msub>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo>·</mml:mo>
                                <mml:mi>B</mml:mi>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:msub>
                                  <mml:mrow>
                                    <mml:mrow>
                                      <mml:mo stretchy="true">[</mml:mo>
                                      <mml:msub>
                                        <mml:mrow>
                                          <mml:mi>x</mml:mi>
                                        </mml:mrow>
                                        <mml:mi>l</mml:mi>
                                      </mml:msub>
                                      <mml:mo stretchy="true">]</mml:mo>
                                    </mml:mrow>
                                  </mml:mrow>
                                  <mml:mn>2</mml:mn>
                                </mml:msub>
                                <mml:mo>+</mml:mo>
                                <mml:mrow>
                                  <mml:mo stretchy="true">{</mml:mo>
                                  <mml:mrow>
                                    <mml:mtable>
                                      <mml:mtr columnalign="left">
                                        <mml:mtd columnalign="left">
                                          <mml:mrow>
                                            <mml:mo>+</mml:mo>
                                            <mml:msub>
                                              <mml:mrow>
                                                <mml:mi>T</mml:mi>
                                              </mml:mrow>
                                              <mml:mrow>
                                                <mml:mi mathvariant="italic">min</mml:mi>
                                              </mml:mrow>
                                            </mml:msub>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>l</mml:mi>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>i</mml:mi>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>j</mml:mi>
                                            <mml:mo>′</mml:mo>
                                            <mml:mo stretchy="true">]</mml:mo>
                                          </mml:mrow>
                                        </mml:mtd>
                                      </mml:mtr>
                                      <mml:mtr columnalign="left">
                                        <mml:mtd columnalign="left">
                                          <mml:mrow>
                                            <mml:mo stretchy="true">(</mml:mo>
                                            <mml:mtext>if</mml:mtext>
                                            <mml:mo> </mml:mo>
                                            <mml:mo> </mml:mo>
                                            <mml:mi>B</mml:mi>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>i</mml:mi>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>j</mml:mi>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:msub>
                                              <mml:mrow>
                                                <mml:mrow>
                                                  <mml:mo stretchy="true">[</mml:mo>
                                                  <mml:msub>
                                                    <mml:mrow>
                                                      <mml:mi>x</mml:mi>
                                                    </mml:mrow>
                                                    <mml:mi>l</mml:mi>
                                                  </mml:msub>
                                                  <mml:mo stretchy="true">]</mml:mo>
                                                </mml:mrow>
                                              </mml:mrow>
                                              <mml:mn>1</mml:mn>
                                            </mml:msub>
                                            <mml:mo>=</mml:mo>
                                            <mml:mo>+</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">)</mml:mo>
                                          </mml:mrow>
                                        </mml:mtd>
                                      </mml:mtr>
                                      <mml:mtr columnalign="left">
                                        <mml:mtd columnalign="left">
                                          <mml:mrow>
                                            <mml:mo>−</mml:mo>
                                            <mml:msub>
                                              <mml:mrow>
                                                <mml:mi>T</mml:mi>
                                              </mml:mrow>
                                              <mml:mrow>
                                                <mml:mi mathvariant="italic">max</mml:mi>
                                              </mml:mrow>
                                            </mml:msub>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>l</mml:mi>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>i</mml:mi>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>j</mml:mi>
                                            <mml:mo>′</mml:mo>
                                            <mml:mo stretchy="true">]</mml:mo>
                                          </mml:mrow>
                                        </mml:mtd>
                                      </mml:mtr>
                                      <mml:mtr columnalign="left">
                                        <mml:mtd columnalign="left">
                                          <mml:mrow>
                                            <mml:mo stretchy="true">(</mml:mo>
                                            <mml:mtext>if</mml:mtext>
                                            <mml:mo> </mml:mo>
                                            <mml:mo> </mml:mo>
                                            <mml:mi>B</mml:mi>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>i</mml:mi>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>j</mml:mi>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:msub>
                                              <mml:mrow>
                                                <mml:mrow>
                                                  <mml:mo stretchy="true">[</mml:mo>
                                                  <mml:msub>
                                                    <mml:mrow>
                                                      <mml:mi>x</mml:mi>
                                                    </mml:mrow>
                                                    <mml:mi>l</mml:mi>
                                                  </mml:msub>
                                                  <mml:mo stretchy="true">]</mml:mo>
                                                </mml:mrow>
                                              </mml:mrow>
                                              <mml:mn>1</mml:mn>
                                            </mml:msub>
                                            <mml:mo>=</mml:mo>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">)</mml:mo>
                                          </mml:mrow>
                                        </mml:mtd>
                                      </mml:mtr>
                                    </mml:mtable>
                                  </mml:mrow>
                                </mml:mrow>
                              </mml:mrow>
                            </mml:mtd>
                          </mml:mtr>
                        </mml:mtable>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <disp-formula id="E05">
        <mml:math id="M05" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mtable>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>T</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi mathvariant="italic">max</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo stretchy="true">[</mml:mo>
                    <mml:mi>l</mml:mi>
                    <mml:mo stretchy="true">]</mml:mo>
                    <mml:mo stretchy="true">[</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="true">]</mml:mo>
                    <mml:mo stretchy="true">[</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo stretchy="true">]</mml:mo>
                    <mml:mo>=</mml:mo>
                    <mml:mi>max</mml:mi>
                    <mml:mrow>
                      <mml:mo stretchy="true">{</mml:mo>
                      <mml:mrow>
                        <mml:mtable>
                          <mml:mtr columnalign="left">
                            <mml:mtd columnalign="left">
                              <mml:mrow>
                                <mml:msub>
                                  <mml:mrow>
                                    <mml:mi>T</mml:mi>
                                  </mml:mrow>
                                  <mml:mrow>
                                    <mml:mi mathvariant="italic">max</mml:mi>
                                  </mml:mrow>
                                </mml:msub>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>l</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mn>1</mml:mn>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                              </mml:mrow>
                            </mml:mtd>
                          </mml:mtr>
                          <mml:mtr columnalign="left">
                            <mml:mtd columnalign="left">
                              <mml:mrow>
                                <mml:mi>A</mml:mi>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:msub>
                                  <mml:mrow>
                                    <mml:mi>x</mml:mi>
                                  </mml:mrow>
                                  <mml:mi>l</mml:mi>
                                </mml:msub>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo>·</mml:mo>
                                <mml:mi>B</mml:mi>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:mo stretchy="true">[</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo stretchy="true">]</mml:mo>
                                <mml:msub>
                                  <mml:mrow>
                                    <mml:mrow>
                                      <mml:mo stretchy="true">[</mml:mo>
                                      <mml:msub>
                                        <mml:mrow>
                                          <mml:mi>x</mml:mi>
                                        </mml:mrow>
                                        <mml:mi>l</mml:mi>
                                      </mml:msub>
                                      <mml:mo stretchy="true">]</mml:mo>
                                    </mml:mrow>
                                  </mml:mrow>
                                  <mml:mn>2</mml:mn>
                                </mml:msub>
                                <mml:mo>+</mml:mo>
                                <mml:mrow>
                                  <mml:mo stretchy="true">{</mml:mo>
                                  <mml:mrow>
                                    <mml:mtable>
                                      <mml:mtr columnalign="left">
                                        <mml:mtd columnalign="left">
                                          <mml:mrow>
                                            <mml:mo>+</mml:mo>
                                            <mml:msub>
                                              <mml:mrow>
                                                <mml:mi>T</mml:mi>
                                              </mml:mrow>
                                              <mml:mrow>
                                                <mml:mi mathvariant="italic">max</mml:mi>
                                              </mml:mrow>
                                            </mml:msub>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>l</mml:mi>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>i</mml:mi>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>j</mml:mi>
                                            <mml:mo>′</mml:mo>
                                            <mml:mo stretchy="true">]</mml:mo>
                                          </mml:mrow>
                                        </mml:mtd>
                                      </mml:mtr>
                                      <mml:mtr columnalign="left">
                                        <mml:mtd columnalign="left">
                                          <mml:mrow>
                                            <mml:mo stretchy="true">(</mml:mo>
                                            <mml:mtext>if</mml:mtext>
                                            <mml:mo> </mml:mo>
                                            <mml:mo> </mml:mo>
                                            <mml:mi>B</mml:mi>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>i</mml:mi>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>j</mml:mi>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:msub>
                                              <mml:mrow>
                                                <mml:mrow>
                                                  <mml:mo stretchy="true">[</mml:mo>
                                                  <mml:msub>
                                                    <mml:mrow>
                                                      <mml:mi>x</mml:mi>
                                                    </mml:mrow>
                                                    <mml:mi>l</mml:mi>
                                                  </mml:msub>
                                                  <mml:mo stretchy="true">]</mml:mo>
                                                </mml:mrow>
                                              </mml:mrow>
                                              <mml:mn>1</mml:mn>
                                            </mml:msub>
                                            <mml:mo>=</mml:mo>
                                            <mml:mo>+</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">)</mml:mo>
                                          </mml:mrow>
                                        </mml:mtd>
                                      </mml:mtr>
                                      <mml:mtr columnalign="left">
                                        <mml:mtd columnalign="left">
                                          <mml:mrow>
                                            <mml:mo>−</mml:mo>
                                            <mml:msub>
                                              <mml:mrow>
                                                <mml:mi>T</mml:mi>
                                              </mml:mrow>
                                              <mml:mrow>
                                                <mml:mi mathvariant="italic">min</mml:mi>
                                              </mml:mrow>
                                            </mml:msub>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>l</mml:mi>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>i</mml:mi>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>j</mml:mi>
                                            <mml:mo>′</mml:mo>
                                            <mml:mo stretchy="true">]</mml:mo>
                                          </mml:mrow>
                                        </mml:mtd>
                                      </mml:mtr>
                                      <mml:mtr columnalign="left">
                                        <mml:mtd columnalign="left">
                                          <mml:mrow>
                                            <mml:mo stretchy="true">(</mml:mo>
                                            <mml:mtext>if</mml:mtext>
                                            <mml:mo> </mml:mo>
                                            <mml:mo> </mml:mo>
                                            <mml:mi>B</mml:mi>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>i</mml:mi>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:mo stretchy="true">[</mml:mo>
                                            <mml:mi>j</mml:mi>
                                            <mml:mo stretchy="true">]</mml:mo>
                                            <mml:msub>
                                              <mml:mrow>
                                                <mml:mrow>
                                                  <mml:mo stretchy="true">[</mml:mo>
                                                  <mml:msub>
                                                    <mml:mrow>
                                                      <mml:mi>x</mml:mi>
                                                    </mml:mrow>
                                                    <mml:mi>l</mml:mi>
                                                  </mml:msub>
                                                  <mml:mo stretchy="true">]</mml:mo>
                                                </mml:mrow>
                                              </mml:mrow>
                                              <mml:mn>1</mml:mn>
                                            </mml:msub>
                                            <mml:mo>=</mml:mo>
                                            <mml:mo>−</mml:mo>
                                            <mml:mn>1</mml:mn>
                                            <mml:mo stretchy="true">)</mml:mo>
                                          </mml:mrow>
                                        </mml:mtd>
                                      </mml:mtr>
                                    </mml:mtable>
                                  </mml:mrow>
                                </mml:mrow>
                              </mml:mrow>
                            </mml:mtd>
                          </mml:mtr>
                        </mml:mtable>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow/>
                </mml:mtd>
                <mml:mtd columnalign="left">
                  <mml:mrow/>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Initially, for any <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>l</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">min</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">max</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">min</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">max</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mtext>NaN</mml:mtext></mml:mrow></mml:math></inline-formula> if <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. Tables <italic toggle="yes">T</italic><sub>min</sub> and <italic toggle="yes">T</italic><sub>max</sub> can then be filled using the above recurrences. Subsequently, for <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>, we record the values
</p>
      <disp-formula id="E6">
        <mml:math id="M6" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>T</mml:mi>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>n</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>k</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>j</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo>:</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mi>max</mml:mi>
            <mml:mo>{</mml:mo>
            <mml:mrow>
              <mml:mo>|</mml:mo>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>T</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi mathvariant="italic">min</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mi>n</mml:mi>
                <mml:mo stretchy="false">]</mml:mo>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mi>k</mml:mi>
                <mml:mo stretchy="false">]</mml:mo>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mi>j</mml:mi>
                <mml:mo stretchy="false">]</mml:mo>
              </mml:mrow>
              <mml:mo>|</mml:mo>
            </mml:mrow>
            <mml:mo>,</mml:mo>
            <mml:mrow>
              <mml:mo>|</mml:mo>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>T</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi mathvariant="italic">max</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mi>n</mml:mi>
                <mml:mo stretchy="false">]</mml:mo>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mi>k</mml:mi>
                <mml:mo stretchy="false">]</mml:mo>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mi>j</mml:mi>
                <mml:mo stretchy="false">]</mml:mo>
              </mml:mrow>
              <mml:mo>|</mml:mo>
            </mml:mrow>
            <mml:mo>}</mml:mo>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>In these processes, if any of the three arithmetic operations <inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mo>+</mml:mo><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mo>,</mml:mo><mml:mo>|</mml:mo><mml:mo>·</mml:mo><mml:mo>|</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> involves NaN as an operand, then the result is also an NaN. The <inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:math></inline-formula> operations ignore NaN and only work on numerical operands, unless there is none, in which case an NaN is returned. At the end, we calculate
</p>
      <disp-formula id="E7">
        <mml:math id="M7" display="block" overflow="scroll">
          <mml:msub>
            <mml:mo>ψ</mml:mo>
            <mml:mrow>
              <mml:mi>o</mml:mi>
              <mml:mi>p</mml:mi>
              <mml:mi>t</mml:mi>
            </mml:mrow>
          </mml:msub>
          <mml:mo>=</mml:mo>
          <mml:mi>min</mml:mi>
          <mml:mo>{</mml:mo>
          <mml:mi>j</mml:mi>
          <mml:mo>|</mml:mo>
          <mml:mi>T</mml:mi>
          <mml:mo>[</mml:mo>
          <mml:mi>n</mml:mi>
          <mml:mo>]</mml:mo>
          <mml:mo>[</mml:mo>
          <mml:mi>k</mml:mi>
          <mml:mo>]</mml:mo>
          <mml:mo>[</mml:mo>
          <mml:mi>j</mml:mi>
          <mml:mo>]</mml:mo>
          <mml:mo>≠</mml:mo>
          <mml:mtext>NaN</mml:mtext>
          <mml:mo>}</mml:mo>
          <mml:mo> </mml:mo>
          <mml:mo> </mml:mo>
          <mml:mtext>and</mml:mtext>
          <mml:mo> </mml:mo>
          <mml:mo> </mml:mo>
          <mml:msub>
            <mml:mo>ω</mml:mo>
            <mml:mrow>
              <mml:mi>o</mml:mi>
              <mml:mi>p</mml:mi>
              <mml:mi>t</mml:mi>
            </mml:mrow>
          </mml:msub>
          <mml:mo>=</mml:mo>
          <mml:mi>T</mml:mi>
          <mml:mo>[</mml:mo>
          <mml:mi>n</mml:mi>
          <mml:mo>]</mml:mo>
          <mml:mo>[</mml:mo>
          <mml:mi>k</mml:mi>
          <mml:mo>]</mml:mo>
          <mml:mo>[</mml:mo>
          <mml:msub>
            <mml:mo>ψ</mml:mo>
            <mml:mrow>
              <mml:mi>o</mml:mi>
              <mml:mi>p</mml:mi>
              <mml:mi>t</mml:mi>
            </mml:mrow>
          </mml:msub>
          <mml:mo>]</mml:mo>
          <mml:mo>.</mml:mo>
        </mml:math>
      </disp-formula>
      <p>The optimal subsequence <inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>π</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, i.e., the subsequence <italic toggle="yes">z</italic> of <italic toggle="yes">x</italic> with <inline-formula id="IE9002"><mml:math id="IM9002" display="inline" overflow="scroll"><mml:mi>π</mml:mi><mml:mo>(</mml:mo><mml:mi>z</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:msub><mml:mo>ψ</mml:mo><mml:mrow><mml:mi>o</mml:mi><mml:mi>p</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mi>ω</mml:mi><mml:mrow><mml:mi>o</mml:mi><mml:mi>p</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo></mml:math></inline-formula>can be obtained by traceback. The entire algorithm runs in <italic toggle="yes">O</italic>(<italic toggle="yes">nkd</italic>) time.</p>
    </sec>
    <sec>
      <title>2.6 Using SubseqHash in practice</title>
      <p>It is desirable for a seeding/hashing function to be “locality-sensitive,” i.e. the probability of hash collision for a pair of strings <bold><italic toggle="yes">x</italic></bold> and <bold><italic toggle="yes">y</italic></bold> is high if they are similar (say, measured with the edit distance), and at the same time such probability becomes low if <bold><italic toggle="yes">x</italic></bold> and <bold><italic toggle="yes">y</italic></bold> are not similar. These desired properties can also be interpreted as having high sensitivity (more true seed-matches) and a low false positive rate (fewer false seed-matches). For SubseqHash coupled with an ABC order, the choice of <italic toggle="yes">n</italic> and <italic toggle="yes">k</italic> balances these two measures. Generally speaking, a larger <italic toggle="yes">n</italic> lowers the false positive rate while a smaller <italic toggle="yes">n</italic> provides higher sensitivity; for a fixed <italic toggle="yes">n</italic>, increasing the difference between <italic toggle="yes">n</italic> and <italic toggle="yes">k</italic> improves sensitivity while decreasing the difference reduces the number of false seed-matches.</p>
      <p>Again, two similar strings <bold><italic toggle="yes">x</italic></bold> and <bold><italic toggle="yes">y</italic></bold> are likely to share some (long) subsequences. In fact, assume the edit distance between two length-<italic toggle="yes">n</italic> strings <bold><italic toggle="yes">x</italic></bold> and <bold><italic toggle="yes">y</italic></bold> is <italic toggle="yes">e</italic><sub>1</sub>, then a shared subsequence of length <italic toggle="yes">k</italic> is guaranteed if <inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. In this case, the probability of hash collision under SubseqHash between <bold><italic toggle="yes">x</italic></bold> and <bold><italic toggle="yes">y</italic></bold> is strictly positive. However, the probability might be small so that one round of SubseqHash may not actually pick a common subsequence of the two strings (see Section 3.2 for some experimental results). To boost the chance of getting a seed-match, one can “repeat” SubseqHash several times independently, each of which uses a different set of random <inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>B</mml:mi><mml:mo>/</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula> tables. Assume that <italic toggle="yes">p</italic> is the probability of hash collision of calling SubseqHash once, then with <italic toggle="yes">t</italic> repeats, the probability of having at least one seed-match is <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>. Repeats may also increase the false positive seed-matches, but it can be well controlled by picking a large <italic toggle="yes">n</italic> and a <italic toggle="yes">k</italic> that is close to <italic toggle="yes">n</italic>. Specifically, two dissimilar strings (i.e. their edit distance <italic toggle="yes">e</italic><sub>2</sub> is large) of length <italic toggle="yes">n</italic> will not share any subsequence of length <italic toggle="yes">k</italic> if <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>&gt;</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>. In Sections 3.4–3.6, we show that repeats can boost sensitivity while maintaining a low false positive rate (i.e. high precision).</p>
      <p>On the other hand, repeats are not as practical for substring-based seeding methods. This is because it is easy for two similar strings not to share any substring of a reasonable length. In fact, a shared substring of length <italic toggle="yes">k</italic> is guaranteed only if <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, as one edit can break up to <italic toggle="yes">k</italic> substrings of length <italic toggle="yes">k</italic>. When two (similar) strings do not share any length-<italic toggle="yes">k</italic> substring, a seed-match will not be produced regardless of the number of repeats. In the experiments, we include the comparison with “all-kmers” (i.e. every sliding window of length <italic toggle="yes">k</italic> in a sequence is collected as a seed), which is the limit of repeating Minimizers.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <sec>
      <title>3.1 Comparison of orders</title>
      <p>We propose a measure to characterize the similarity of neighboring strings in an order. Observe that, the neighboring strings in the lexicographic order are similar, while they are independent and therefore distant from each other in a fully random order. Let <italic toggle="yes">O</italic> be an order over <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> and let <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> be its <italic toggle="yes">i</italic>-th string. We define the 2<italic toggle="yes">w</italic> strings in a window centered at <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> as the neighboring strings of <inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic toggle="yes">w</italic> is a parameter. We use <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mi>w</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>O</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>w</mml:mi><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>e</mml:mi><mml:mi mathvariant="italic">dit</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to quantify how similar <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is with its neighboring strings, where <inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">edit</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo>,</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> denotes the edit distance. We finally calculate the “averaged minimum neighboring edit distance” (AMNED) over the <italic toggle="yes">m</italic> smallest (top-ranked) strings in the order, i.e. <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mi>w</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>O</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>. We consider top-ranked strings in an order as they are more likely to be hashed to in SubseqHash.</p>
      <p>We compare the AMNEDs of ABC orderings, fully random orders, and the lexicographic order for strings of length <italic toggle="yes">k </italic>=<italic toggle="yes"> </italic>15. To generate the top <italic toggle="yes">m</italic> strings in an ABC order, we randomly generate tables <italic toggle="yes">A</italic>, <italic toggle="yes">B</italic>, and <italic toggle="yes">C</italic> (with three choices of <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>1, 11, 31), calculate the score <inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>ψ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of all strings in <inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, sort them, and pick the top <italic toggle="yes">m</italic> strings. The top <italic toggle="yes">m</italic> strings of a fully random order are generated by independently simulating random strings of length <italic toggle="yes">k</italic> until <italic toggle="yes">m</italic> distinct ones are available. Note that the AMNED is 1 for the lexicographic order regardless the choice of <italic toggle="yes">w</italic> and <italic toggle="yes">m</italic>.</p>
      <p><xref rid="btad218-F1" ref-type="fig">Figure 1</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S3</xref> report the averaged AMNEDs and the standard deviation for the above three orders (10 repetitions for the ABC order and the fully random order) using different choices of <italic toggle="yes">w</italic> and <italic toggle="yes">m</italic>. The average AMNED for the ABC order is reasonably large, suggesting that the ABC order is “quite” random, in the sense that nearby strings are dissimilar. There is still a gap between an ABC order and a fully random order, but the gap is gradually decreased as <italic toggle="yes">m</italic> grows. Changing <italic toggle="yes">d</italic> from 1 to 11 for an ABC order significantly increases the AMNED, suggesting the effectiveness of using table <italic toggle="yes">C</italic>. There is a small growth when <italic toggle="yes">d</italic> is further increased to 31; we therefore pick <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>11 in the experimental studies.</p>
      <fig position="float" id="btad218-F1">
        <label>Figure 1.</label>
        <caption>
          <p>The AMNED of different orders over strings of length <italic toggle="yes">k </italic>=<italic toggle="yes"> </italic>15 evaluated with varying <italic toggle="yes">w</italic> (<italic toggle="yes">x</italic>-axis) and <italic toggle="yes">m </italic>=<italic toggle="yes"> </italic>10 000. The point and error bar show the mean and standard deviation over 10 individual runs. Results for different values of <italic toggle="yes">m</italic> are available in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S3</xref>.</p>
        </caption>
        <graphic xlink:href="btad218f1" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>3.2 Comparison of probability of hash collision</title>
      <p>We compare the probability of hash collision achieved by Minimizer and SubseqHash. Each seeding method takes a pair of strings <inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as input, and extracts a single seed from each string. For Minimizer, the seed of <bold><italic toggle="yes">x</italic></bold> is the smallest <italic toggle="yes">k</italic>mer among the <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">k</italic>mers in <bold><italic toggle="yes">x</italic></bold> according to a fully random order. For SubseqHash, the seed of <bold><italic toggle="yes">x</italic></bold> is the smallest subsequence of length <italic toggle="yes">k</italic> in <bold><italic toggle="yes">x</italic></bold>, according to the chosen order. For the lexicographic order, linear algorithm exists to find the optimal seed; for the ABC order, algorithm in Section 2.5 is used; for a fully random order, we use a brute-force approach to find the smallest seed (and hence we are not able to report the results for large <italic toggle="yes">k</italic> in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S5</xref>). A seed of <bold><italic toggle="yes">y</italic></bold> will be extracted independently but with the shared order used for <bold><italic toggle="yes">x</italic></bold>. We then check if the two seeds are identical (i.e. a hash collision).</p>
      <p>We use simulations to estimate the probability of hash collisions. To simulate pairs of strings, we start with <bold><italic toggle="yes">x</italic></bold> being a random string of length <italic toggle="yes">n</italic>, <italic toggle="yes">n </italic>=<italic toggle="yes"> </italic>20 or <italic toggle="yes">n </italic>=<italic toggle="yes"> </italic>30. We then apply <italic toggle="yes">n</italic> random evolutionary events sequentially on <bold><italic toggle="yes">x</italic></bold>, with each event with probability of 1/3 being a substitution, a deletion, or an insertion. We make sure that each position can be only mutated once. We collect both the intermediate <italic toggle="yes">n−</italic>1 strings and the final string, resulting in <italic toggle="yes">n</italic> pairs of strings <inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mi mathvariant="bold-italic">i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>. All pairs are categorized according to the edit distance, i.e. pair <inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mi mathvariant="bold-italic">i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is put into the <italic toggle="yes">j</italic>-th category if <inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">edit</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mi mathvariant="bold-italic">i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>. Note that there are <italic toggle="yes">i</italic> mutations simulated from <bold><italic toggle="yes">x</italic></bold> to <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mi mathvariant="bold-italic">i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, but it is not necessarily true that <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">edit</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mi mathvariant="bold-italic">i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>. Notice also that it is possible that <inline-formula id="IE124"><mml:math id="IM124" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mi mathvariant="bold-italic">i</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>≠</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, but a seed of the same length (a <italic toggle="yes">k</italic>mer for Minimizer and a subsequence of length <italic toggle="yes">k</italic> for SubseqHash) will be extracted from them.</p>
      <p>We simulate 10 000 pairs of strings following above procedure, and in each of the 10 categories where edit distance is from 1 to 10, we calculate the frequency of hash collisions and use it as an estimation of the probability of hash collision. The results are shown in <xref rid="btad218-F2" ref-type="fig">Fig. 2</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Figs S4</xref> and <xref rid="sup1" ref-type="supplementary-material">S5</xref>. Minimizer and SubseqHash are compared when extracting seeds of the same length (the same <italic toggle="yes">k</italic>). Observe that in all settings SubseqHash coupled with ABC order achieves much higher probability than Minimizer when the edit distance is in a range of 1–5, indicating the superiority of SubseqHash over Minimizer in hashing similar strings but with high error rates. The probability of hash collision of SubseqHash coupled with the lexicographic order is very similar to that of the Minimizer, suggesting the necessity of a more random order (than lexicographic order) to make SubseqHash more sensitive. The probability of hash collision of SubseqHash gets much improved when <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>11 is used in ABC order than <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>1, again indicating the effectiveness of table <italic toggle="yes">C</italic>. The performance of SubseqHash with fully random orders gives the highest probability (i.e. the Jaccard index) among possible orders, but the curves from ABC orders when <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>11 and <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>31 are very close to them, indicating that the ABC order (with large <italic toggle="yes">d</italic>) is nearly optimal.</p>
      <fig position="float" id="btad218-F2">
        <label>Figure 2.</label>
        <caption>
          <p>The probability of hash collision estimated, using simulations, for different seeding methods with <italic toggle="yes">n </italic>=<italic toggle="yes"> </italic>20 and <italic toggle="yes">k </italic>=<italic toggle="yes"> </italic>16. More results with different <italic toggle="yes">n</italic> and <italic toggle="yes">k</italic> are available in <xref rid="sup1" ref-type="supplementary-material">Supplementary Figs S4</xref> and <xref rid="sup1" ref-type="supplementary-material">S5</xref>.</p>
        </caption>
        <graphic xlink:href="btad218f2" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>3.3 Evaluating seeding methods</title>
      <p>We discuss appropriate measures to evaluate seeding methods for tasks involving sequence comparison, such as sequence alignment, read mapping, and overlapping read detection. Despite variations in methods for these tasks, they all follow a two-step procedure, consisting of a “seeding step” and a “post-seeding step.” The seeding step treats the sequences/reads independently and typically applies a seeding method to sliding windows of a sequence/read, resulting in a list of seeds. Measures for this step include the running time of the seeding method, as well as the density of the seeds, defined as the number of seeds produced from a sequence divided by the length of the sequence.</p>
      <p>The post-seeding step uses the generated seeds to compare sequences. We emphasize that in this step only the matched seeds between compared sequences are used, while unmatched seeds are discarded. For example, in the co-linear chaining approach for sequence alignment, the set of seed-matches serves as the input of the chaining algorithm. In the seed-and-extend scheme for mapping reads, each individual seed-match will be examined in the extension. When detecting overlapping reads, a pair of reads will be determined as “candidate” (which will be then subject to more fine-grained procedure such as chaining to decide overlapping) if there exists one (or more) seed-matches. Therefore, it is the quantity and quality of seed-matches, rather than that of seeds, that determine the running time of the post-seeding step and the accuracy of the outcomes.</p>
      <p>In Sections 3.4 and 3.5, we report the density and running time of different seeding methods, as well as the quantity and quality of the resulting seed-matches to evaluate their impacts on the post-seeding step. In summary, SubseqHash runs much slower than substring-based methods, such as Minimizers. When repetitions are applied to SubseqHash (see Section 2.6), it generates a much larger number of seeds than Minimizers, requiring more memory to store the seeds. However, SubseqHash outperforms other methods in generating high-quality seed-matches, thereby improving the accuracy of the final outcomes. See below for detailed analysis.</p>
    </sec>
    <sec>
      <title>3.4 Application: pairwise sequence alignment</title>
      <p>We use simulations to test the performance of different methods with varying error rates. We simulate 10 pairs of sequences and report the average measures (described below). The first sequence in a pair is a random sequence of length <italic toggle="yes">L </italic>=<italic toggle="yes"> </italic>100 000; the second sequence is obtained by applying an edit, with probability of <italic toggle="yes">r</italic> equally distributed to insertion, deletion, and substitution, independently on every position of the first sequence, where <italic toggle="yes">r</italic> is a parameter specifying the error rate. The ground-truth alignment is saved for evaluation (see below).</p>
      <p>In <xref rid="btad218-F3" ref-type="fig">Fig. 3</xref>, we present the density of SubseqHash and Minimizers using the simulated data described above. As expected, for any fixed window size <italic toggle="yes">n</italic>, the density of both methods decreases as the seed length <italic toggle="yes">k</italic> decreases, but the density of Minimizers decreases much more rapidly than that of SubseqHash. It should be noted that when repetitions are applied to SubseqHash, the density and total number of seeds should be multiplied by the number of repetitions. Furthermore, we provide a comparison of the running time of different seeding methods in <xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S6–S9</xref>. Consistent with the theoretical analysis, SubseqHash typically runs 24–270 times slower than Minimizers.</p>
      <fig position="float" id="btad218-F3">
        <label>Figure 3.</label>
        <caption>
          <p>The density of different seeding methods on simulated sequences. In the legend, “all-kmers” means every single <italic toggle="yes">k</italic>mer is collected as seed, <inline-formula id="IE125"><mml:math id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>9</mml:mn><mml:mo>,</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>25</mml:mn></mml:mrow></mml:math></inline-formula>. “Minimizer <italic toggle="yes">n</italic>” means a window size of <italic toggle="yes">n</italic>; with increasing density, the list of <italic toggle="yes">k</italic> used for each line is <inline-formula id="IE126"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>8</mml:mn><mml:mo>,</mml:mo><mml:mn>9</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. “SubseqHash <italic toggle="yes">n t</italic>” means a window size of <italic toggle="yes">n</italic> and repeating <italic toggle="yes">t</italic> times. For <italic toggle="yes">n </italic>=<italic toggle="yes"> </italic>20, <italic toggle="yes">k</italic> is from 14 to 19; for <italic toggle="yes">n </italic>=<italic toggle="yes"> </italic>25, <italic toggle="yes">k</italic> is from 16 to 24; for <italic toggle="yes">n </italic>=<italic toggle="yes"> </italic>30, <italic toggle="yes">k</italic> is from 18 to 29; for <italic toggle="yes">n </italic>=<italic toggle="yes"> </italic>35, <italic toggle="yes">k</italic> is from 20 to 34. For all methods, points with varying <italic toggle="yes">k</italic> but the same <italic toggle="yes">n</italic> are connected by lines. These parameters are also used in all experimental studies of Sections 3.4 and 3.5.</p>
        </caption>
        <graphic xlink:href="btad218f3" position="float"/>
      </fig>
      <p>We now assess the quality of resulting seed-matches. In either Minimizer or SubseqHash, a seed-match specifies an alignment among <italic toggle="yes">k</italic> identical characters. We define a seed-match to be “true” if at least 50% of the <italic toggle="yes">k</italic> aligned characters appear in the ground-truth; otherwise it is considered to be a “false” seed-match. See <xref rid="btad218-F4" ref-type="fig">Fig. 4</xref> for an example. We do not require all <italic toggle="yes">k</italic> aligned characters to agree with the ground-truth to be considered as a true seed-match as the ground-truth alignment may not reflect the most parsimonious alignment especially when the mutation rate is high. Nevertheless, 50% matched characters certainly indicate that the locations of two seeds are anchored correctly, which is adequate for downstream use.</p>
      <fig position="float" id="btad218-F4">
        <label>Figure 4.</label>
        <caption>
          <p>(a) The ground-truth alignment between two sequences; note that this alignment is not the most parsimonous (i.e. minimizing edit distance) alignment. (b) A seed-match where the identical seed is <italic toggle="yes">ACCCACGTC</italic>. Among the nine matched characters, five of them (55.6%) exist in the ground-truth alignment. Hence this seed-match is a true one.</p>
        </caption>
        <graphic xlink:href="btad218f4" position="float"/>
      </fig>
      <p>In <xref rid="btad218-F5" ref-type="fig">Fig. 5</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S7</xref>, we present the relationship between the number of seed-matches and the ratio of true seed-match ratio (defined as the number of true seed-matches divided by the number of seed-matches). As explained in Section 3.3, the number of seed-matches has a strong correlation with the execution time of the post-seeding step, while the true seed-match ratio reflects the accuracy of seed-matches. By comparing the <italic toggle="yes">y</italic>-coordinates of different methods at a fixed <italic toggle="yes">x</italic>-coordinate, one can assess their accuracy at the same level of running time. SubseqHash without repetitions demonstrates a similar performance to Minimizers in the range of small numbers of seed-matches. SubseqHash with repetitions achieves a much higher true ratio than all-<italic toggle="yes">k</italic>mers when the number of seed-matches falls between approximately 10 000 and 30 000. Beyond this range, SubseqHash and other methods are not comparable.</p>
      <fig position="float" id="btad218-F5">
        <label>Figure 5.</label>
        <caption>
          <p>The number of seed-matches and the true seed-matches ratios on simulated sequences with error rate = 15%. Figure is cropped to only show the portion with high ratio (<inline-formula id="IE127"><mml:math id="IM127" display="inline" overflow="scroll"><mml:mrow><mml:mo>≥</mml:mo><mml:mn>70</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>); complete results are shown in <xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S2–S5</xref>. Results for error rates 5%, 10%, and 20% are available in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S7</xref>.</p>
        </caption>
        <graphic xlink:href="btad218f5" position="float"/>
      </fig>
      <p>It is more desirable for a seeding method to generate true seed-matches that span a larger range of the sequence, rather than ones clustered together (<xref rid="btad218-B37" ref-type="bibr">Sahlin 2021</xref>). We say a character in a sequence is “covered” by a seed-match if it is one of its <italic toggle="yes">k</italic> aligned characters. The “coverage of true seed-matches” (true coverage for short) is the percentage of characters in both sequences that are covered by at least one true seed-match; the “coverage of false seed-matches” (false coverage for short) is defined in the same way but counting false seed-matches. Higher true coverage reflects higher sensitivity, and can facilitate downstream chaining procedure to produce more accurate and faster sequence alignment. Lower false coverage reduces the likelihood of producing incorrect alignments. We report the average true/false coverages of different methods in <xref rid="btad218-F6" ref-type="fig">Fig. 6</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S8</xref>. A single run of SubseqHash outperforms (i.e. higher true coverage at the same false coverage) Minimizer and all-<italic toggle="yes">k</italic>mers when error rate is 5% or 10%, and achieves similar performance at 15% and 20% error rates. SubseqHash with 10 repetitions outperforms others by a large margin at all error rates: specifically, the highest true coverage achieved by Minimizer/all-<italic toggle="yes">k</italic>mers at a false coverage lower than 5% are 85.1%, 61.4%, 38.9%, and 23.1%, respectively, for the 4 error rates, while the numbers for SubseqHash are 98.0%, 90.8%, 75.3%, and 55.0%, respectively.</p>
      <fig position="float" id="btad218-F6">
        <label>Figure 6.</label>
        <caption>
          <p>The coverages of true and false seed-matches for different seeding methods on simulated sequences with error rates =15%. Results for different error rates are available in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S8</xref>.</p>
        </caption>
        <graphic xlink:href="btad218f6" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>3.5 Application: read mapping</title>
      <p>We then compare SubseqHash with other seeding methods on mapping reads to the reference genome. We utilize three real PacBio datasets from <xref rid="btad218-B5" ref-type="bibr">Berlin et al. (2015)</xref> on <italic toggle="yes">Escherichia coli</italic> (SRX533603), <italic toggle="yes">Saccharomyces cerevisiae</italic> (SRX533604), and <italic toggle="yes">Drosophila melanogaster</italic> (SRX499318). To construct a ground-truth for evaluation, we align the reads to the corresponding reference genomes using minimap2 (<xref rid="btad218-B21" ref-type="bibr">Li 2018</xref>) with the default parameters (-cx map-pb). For reads that have a mapped region of at least 2000 bp and a mapping quality of at least 10, we trim the read to only keep the mapped portion. Reads with multiple qualified mappings are discarded. This produces the input reads and their ground-truth alignments. To eliminate the potential biases in the ground-truth created by minimap2, which internally uses Minimizers for seeding, we include a simulated dataset obtained with PBSIM2 (<xref rid="btad218-B31" ref-type="bibr">Ono et al. 2021)</xref> using the same statistics as the PacBio <italic toggle="yes">D.melanogaster</italic> dataset. A total of 287 648 reads are simulated from the X chromosome, with ground-truth alignment saved from simulation. We randomly sample 1000 reads from each of the four datasets for this experiment. The same set of seeding methods (Minimizer, all-<italic toggle="yes">k</italic>mers, and SubseqHash) is applied to generate seeds for both reads and the reference genomes. The density of different methods is illustrated in <xref rid="sup1" ref-type="supplementary-material">Supplementary Figs S9</xref> and <xref rid="sup1" ref-type="supplementary-material">S10</xref>, which show very similar results with <xref rid="btad218-F3" ref-type="fig">Fig. 3</xref>.</p>
      <p>To assess the quality of seed-matches, the same definitions of true and false seed-match used for pairwise sequence alignment (Section 3.4) is also used in this experiment. When calculating the true/false coverages, only the covered characters on reads are considered (instead of on both the reads and the reference genomes). <xref rid="btad218-F7" ref-type="fig">Figure 7</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S11</xref> show the number of seed-matches and the ratio of true seed-matches for different methods averaged over the 1000 reads. At the same level of seed-matches, SubseqHash with 10 repetitions can achieve much higher ratio of true seed-matches than all-<italic toggle="yes">k</italic>mers and Minimizers, verifying the effectiveness of repetitions for sequence mapping. <xref rid="btad218-F8" ref-type="fig">Figure 8</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S12</xref> compare the true/false coverages of different methods. SubseqHash (without repeating) can obtain higher true coverage on the same foot of false coverage than all-<italic toggle="yes">k</italic>mers and Minimizers. Again SubseqHash with repeating 10 times outperforms all others substantially. To give some concrete numbers, the highest true coverage achieved by Minimizer/all-<italic toggle="yes">k</italic>mers at a false coverage lower than 10% are 38.2%, 39.0%, 31.4%, and 34.2%, respectively, for the four datasets, while the numbers for SubseqHash are 74.5%, 67.3%, 52.5%, and 57.5%, respectively.</p>
      <fig position="float" id="btad218-F7">
        <label>Figure 7.</label>
        <caption>
          <p>The number of seed-matches and the ratio of true seed-matches for different seeding methods evaluated on <italic toggle="yes">D.melanogaster</italic> SRX499318 dataset. Figure is cropped to show high ratios (<inline-formula id="IE128"><mml:math id="IM128" display="inline" overflow="scroll"><mml:mrow><mml:mo>≥</mml:mo><mml:mn>15</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>); complete results are given in <xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S10–S13</xref>. Results for other datasets are shown in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S11</xref>.</p>
        </caption>
        <graphic xlink:href="btad218f7" position="float"/>
      </fig>
      <fig position="float" id="btad218-F8">
        <label>Figure 8.</label>
        <caption>
          <p>The coverages of true and false seed-matches for different seeding methods on <italic toggle="yes">D.melanogaster</italic> SRX499318 dataset. Results for other datasets are available in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S12</xref>.</p>
        </caption>
        <graphic xlink:href="btad218f8" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>3.6 Application: overlap detection</title>
      <p>State-of-the-art methods for genome assembly using long-reads sequencing data often rely on an accurate overlap graph, in which vertices are reads and overlapping reads are connected with edges. A straightforward approach for constructing the overlap graph given a set of sequences (i.e. long reads) is performing all-versus-all comparisons, but it certainly does not scale. Seeding methods can be used to detect overlapping pairs while being able to scale. More specifically, a seeding method first transforms each sequence into seeds, then reports pairs of sequences that have at least one seed-match as candidate overlapping pairs. This is certainly a coarse model as for a real overlap detection tool, one would usually perform multiple steps of seed-preprocessing, such as subsampling and filtering; then in the detection phase (post-seeding step), different thresholds for the number of seed-matches and location information of the seeds can be used; lastly, the candidate overlapping pairs are often verified with a fine-grained comparison (e.g. a local alignment) before the final output. All these steps make the overlap results more accurate, but because they can be applied regardless of the seeding methods used, we opt to omit them in this experiment so we can focus on a direct comparison of different seeding methods.</p>
      <p>We use the same four datasets in Section 3.5 in this experiment. We sample 10 000 reads from each dataset; a pair of reads are considered truly overlapping (i.e. ground-truth) if their mapped regions on the reference genome overlap by at least 15 bp. To measure the candidate overlapping pairs reported by a seeding method, we define sensitivity as the fraction of ground-truth pairs that are identified by a seeding method; define precision as the fraction of all reported pairs that are correct according to the ground-truth.</p>
      <p>The precision-sensitivity curves for different methods are shown in <xref rid="btad218-F9" ref-type="fig">Fig. 9</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S13</xref>. Comparing with seeding for sequence alignment and read mapping, here we use a larger window size mainly to reduce false pairs. For each window size <italic toggle="yes">n</italic> used in Minimizers, six seed lengths <italic toggle="yes">k</italic> evenly spaced between 10 and <italic toggle="yes">n</italic> are included (when <italic toggle="yes">k </italic>=<italic toggle="yes"> n</italic>, all-<italic toggle="yes">k</italic>mers are picked as seeds). For each <italic toggle="yes">n</italic> used in SubseqHash, the seed lengths <inline-formula id="IE129"><mml:math id="IM129" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mn>0.65</mml:mn><mml:mi>n</mml:mi></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mn>0.7</mml:mn><mml:mi>n</mml:mi></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mn>0.75</mml:mn><mml:mi>n</mml:mi></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mn>0.8</mml:mn><mml:mi>n</mml:mi></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mn>0.85</mml:mn><mml:mi>n</mml:mi></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> are tested. We include the results of SubseqHash without repetition and of 10 repeats for each of the parameters above. When repetitions apply, the overlapping pairs are simply the union of all 10 runs. Observe that on all four datasets, SubseqHash without repetition already shows better accuracy (i.e. higher precision at the same sensitivity level) than Minimizers and all-<italic toggle="yes">k</italic>mers with a few exceptions at sensitivity near 1.0. In this region, both methods suffer from extremely low precision, which indicates that refining steps are necessary and raw seeds comparison at sensitivity close to 1.0 may not be truly informative. With 10 repetitions, the sensitivity of SubseqHash is significantly boosted while outperforming Minimizers and all-<italic toggle="yes">k</italic>mers substantially. For example, when the sensitivity is set to be at least 80%, the highest precisions achieved by Minimizer/all-<italic toggle="yes">k</italic>mers for the four datasets are 62.9%, 38.9%, 8.7%, and 11.7%, while the numbers for SubseqHash are 85.9%, 78.0%, 23.9%, and 41.7%, respectively.</p>
      <fig position="float" id="btad218-F9">
        <label>Figure 9.</label>
        <caption>
          <p>Overlap detection results on reads sampled from <italic toggle="yes">D.melanogaster</italic> SRX499318 dataset. Results for other datasets are available in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S13</xref>.</p>
        </caption>
        <graphic xlink:href="btad218f9" position="float"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>We investigated SubseqHash, a new approach that uses the minimized subsequence as seed. We figured that the probability of hash collision is determined by the shared order. We therefore studied this core algorithmic formulation: seek an order <italic toggle="yes">π</italic> over all strings of length <italic toggle="yes">k</italic> such that <italic toggle="yes">π</italic> is “as random as possible” and that an efficient algorithm that finds the smallest subsequence (according to <italic toggle="yes">π</italic>) in a string (of length <italic toggle="yes">n</italic>) can be designed. We gave a practical solution for this formulation, consisting of the so-called ABC order together with a dynamic programming algorithm runs in <italic toggle="yes">O</italic>(<italic toggle="yes">nkd</italic>) time to find the minimized subsequence under an ABC order (where <inline-formula id="IE130"><mml:math id="IM130" display="inline" overflow="scroll"><mml:mrow><mml:mi>d</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> can be picked by users). We demonstrated that nearby strings in an ABC order are distant from each other, a property exhibited in a fully random order, and that the probability of hash collision with an ABC order is close to the Jaccard index, achievable when a fully random order is used.</p>
    <p>The superiority of SubseqHash over substring-based methods is in 3-folds. First, SubseqHash tolerates errors while substring-based methods require exact matches. Second, the probability of hash collision of SubseqHash is higher than that of Minimizer (when extracting seeds of the same length). Third, the performance of SubseqHash can be substantially boosted through repetition while for Minimizer this is not as practical. These merits make SubseqHash a more suitable choice for seeding sequencing data with high error/mutation rates.</p>
    <p>We showed that SubseqHash coupled with the ABC order substantially outperformed Minimizer in generating high-quality seed-matches for three applications, sequence alignment, read mapping, and overlap detection. We emphasize that these experiments were designed for a direct comparison between different seeding methods, and therefore the evaluations were conducted at the level of seeds, rather than evaluating the eventual outcomes (e.g. alignments or the overlap graph). As seeding is a key step involved in these applications, we expect SubseqHash will be widely adapted and incorporated to improve their accuracies on the analysis of third-generation sequencing data.</p>
    <p>Our algorithm to find a single seed takes <italic toggle="yes">O</italic>(<italic toggle="yes">nkd</italic>) time, which is much slower than Minimizer that takes amortized <italic toggle="yes">O</italic>(1) time to find a seed in a window. We note that the seeding step usually takes less time than the post-seeding step especially in applications that require all-pairs comparisons, as seeding scales linearly with respect to the number of sequences. Users may choose a smaller <italic toggle="yes">d</italic>, say <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>4 or even <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>1, to gain a speedup at the cost of slightly decrease of sensitivity. Interesting future directions include accelerating the current algorithm using techniques, such as <inline-formula id="IE131"><mml:math id="IM131" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo>∗</mml:mo></mml:mrow></mml:math></inline-formula> heuristic searching (<xref rid="btad218-B16" ref-type="bibr">Ivanov et al. 2022</xref>) and parallel algorithms that have been successfully used to speed up dynamic programming algorithms. We also believe the core algorithmic formulation (stated in the first paragraph of this section), which we find fascinating, can be further improved in achieving faster algorithm and/or higher probability of hash collision.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad218_Supplementary_Data</label>
      <media xlink:href="btad218_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>We thank Paul Medvedev for helpful discussions.</p>
  </ack>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>The authors declare that there is no conflict of interest.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by the US National Science Foundation [2019797, 2145171 to M.S.] and the US National Institutes of Health [R01HG011065 to M.S.].</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad218-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Abouelhoda</surname><given-names>MI</given-names></string-name>, <string-name><surname>Ohlebusch</surname><given-names>E.</given-names></string-name></person-group><article-title>Chaining algorithms for multiple genome comparison</article-title>. <source>J Discrete Algorithms</source><year>2005</year>;<volume>3</volume>:<fpage>321</fpage>–<lpage>41</lpage>.</mixed-citation>
    </ref>
    <ref id="btad218-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Altschul</surname><given-names>SF</given-names></string-name>, <string-name><surname>Gish</surname><given-names>W</given-names></string-name>, <string-name><surname>Miller</surname><given-names>W</given-names></string-name></person-group><etal>et al</etal><article-title>Basic local alignment search tool</article-title>. <source>J Mol Biol</source><year>1990</year>;<volume>215</volume>:<fpage>403</fpage>–<lpage>10</lpage>.<pub-id pub-id-type="pmid">2231712</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Altschul</surname><given-names>SF</given-names></string-name>, <string-name><surname>Madden</surname><given-names>TL</given-names></string-name>, <string-name><surname>Schäffer</surname><given-names>AA</given-names></string-name></person-group><etal>et al</etal><article-title>Gapped BLAST and PSI-BLAST: a new generation of protein database search programs</article-title>. <source>Nucleic Acids Res</source><year>1997</year>;<volume>25</volume>:<fpage>3389</fpage>–<lpage>402</lpage>.<pub-id pub-id-type="pmid">9254694</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bankevich</surname><given-names>A</given-names></string-name>, <string-name><surname>Bzikadze</surname><given-names>AV</given-names></string-name>, <string-name><surname>Kolmogorov</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Multiplex de Bruijn graphs enable genome assembly from long, high-fidelity reads</article-title>. <source>Nat Biotechnol</source><year>2022</year>;<volume>40</volume>:<fpage>1075</fpage>–<lpage>81</lpage>.<pub-id pub-id-type="pmid">35228706</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Berlin</surname><given-names>K</given-names></string-name>, <string-name><surname>Koren</surname><given-names>S</given-names></string-name>, <string-name><surname>Chin</surname><given-names>C-S</given-names></string-name></person-group><etal>et al</etal><article-title>Assembling large genomes with single-molecule sequencing and locality-sensitive hashing</article-title>. <source>Nat Biotechnol</source><year>2015</year>;<volume>33</volume>:<fpage>623</fpage>–<lpage>30</lpage>.<pub-id pub-id-type="pmid">26006009</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Blanca</surname><given-names>A</given-names></string-name>, <string-name><surname>Harris</surname><given-names>RS</given-names></string-name>, <string-name><surname>Koslicki</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>The statistics of <italic toggle="yes">k</italic>-mers from a sequence undergoing a simple mutation process without spurious matches</article-title>. <source>J Comput Biol</source><year>2022</year>;<volume>29</volume>:<fpage>155</fpage>–<lpage>68</lpage>.<pub-id pub-id-type="pmid">35108101</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B7">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Broder</surname><given-names>AZ.</given-names></string-name></person-group> On the resemblance and containment of documents. In: <italic toggle="yes">Proceedings Compression and Complexity of SEQUENCES 1997 (Cat. No.97TB100171)</italic>. <fpage>21</fpage>–<lpage>9</lpage>. <year>1997</year>. <pub-id pub-id-type="doi">10.1109/SEQUEN.1997.666900</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad218-B8">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Califano</surname><given-names>A</given-names></string-name>, <string-name><surname>Rigoutsos</surname><given-names>I.</given-names></string-name></person-group> FLASH: a fast look-up algorithm for string homology. In: <italic toggle="yes">Proceedings of IEEE Conference on Computer Vision and Pattern Recognition (CVPR’93)</italic>. <fpage>353</fpage>–<lpage>9</lpage>. IEEE, <year>1993</year>.</mixed-citation>
    </ref>
    <ref id="btad218-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cheng</surname><given-names>H</given-names></string-name>, <string-name><surname>Concepcion</surname><given-names>GT</given-names></string-name>, <string-name><surname>Feng</surname><given-names>X</given-names></string-name></person-group><etal>et al</etal><article-title>Haplotype-resolved de novo assembly using phased assembly graphs with hifiasm</article-title>. <source>Nat Methods</source><year>2021</year>;<volume>18</volume>:<fpage>170</fpage>–<lpage>5</lpage>.<pub-id pub-id-type="pmid">33526886</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chikhi</surname><given-names>R</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P.</given-names></string-name></person-group><article-title>Informed and automated <italic toggle="yes">k</italic>-mer size selection for genome assembly</article-title>. <source>Bioinformatics</source><year>2014</year>;<volume>30</volume>:<fpage>31</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">23732276</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Du</surname><given-names>N</given-names></string-name>, <string-name><surname>Chen</surname><given-names>J</given-names></string-name>, <string-name><surname>Sun</surname><given-names>Y.</given-names></string-name></person-group><article-title>Improving the sensitivity of long read overlap detection using grouped short <italic toggle="yes">k</italic>-mer matches</article-title>. <source>BMC Genomics</source><year>2019</year>;<volume>20</volume>:<fpage>49</fpage>–<lpage>62</lpage>.<pub-id pub-id-type="pmid">30651061</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Edgar</surname><given-names>R.</given-names></string-name></person-group><article-title>Syncmers are more sensitive than minimizers for selecting conserved k-mers in biological sequences</article-title>. <source>PeerJ</source><year>2021</year>;<volume>9</volume>:<fpage>e10805</fpage>.<pub-id pub-id-type="pmid">33604186</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ekim</surname><given-names>B</given-names></string-name>, <string-name><surname>Berger</surname><given-names>B</given-names></string-name>, <string-name><surname>Chikhi</surname><given-names>R.</given-names></string-name></person-group><article-title>Minimizer-space de Bruijn graphs: whole-genome assembly of long reads in minutes on a personal computer</article-title>. <source>Cell Syst</source><year>2021</year>;<volume>12</volume>:<fpage>958</fpage>–<lpage>68.e6</lpage>.<pub-id pub-id-type="pmid">34525345</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Farach-Colton</surname><given-names>M</given-names></string-name>, <string-name><surname>Landau</surname><given-names>GM</given-names></string-name>, <string-name><surname>Sahinalp</surname><given-names>CS</given-names></string-name></person-group><etal>et al</etal><article-title>Optimal spaced seeds for faster approximate string matching</article-title>. <source>J Comput Syst Sci</source><year>2007</year>;<volume>73</volume>:<fpage>1035</fpage>–<lpage>44</lpage>.</mixed-citation>
    </ref>
    <ref id="btad218-B16">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Ivanov</surname><given-names>P</given-names></string-name>, <string-name><surname>Bichsel</surname><given-names>B</given-names></string-name>, <string-name><surname>Vechev</surname><given-names>M.</given-names></string-name></person-group> Fast and optimal sequence-to-graph alignment guided by seeds. In: <italic toggle="yes">Proceedings of the 26th International Conference on Research in Computational Molecular Biology (RECOMB’22)</italic>. <fpage>306</fpage>–<lpage>25</lpage>. Springer, <year>2022</year>.</mixed-citation>
    </ref>
    <ref id="btad218-B17">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Jain</surname><given-names>C</given-names></string-name>, <string-name><surname>Gibney</surname><given-names>D</given-names></string-name>, <string-name><surname>Thankachan</surname><given-names>SV.</given-names></string-name></person-group> Co-linear chaining with overlaps and gap costs. In: <italic toggle="yes">Proceedings of the 26th International Conference on Research in Computational Molecular Biology (RECOMB’22)</italic>. <fpage>246</fpage>–<lpage>62</lpage>. Springer, <year>2022</year>.</mixed-citation>
    </ref>
    <ref id="btad218-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Jain</surname><given-names>M</given-names></string-name>, <string-name><surname>Koren</surname><given-names>S</given-names></string-name>, <string-name><surname>Miga</surname><given-names>KH</given-names></string-name></person-group><etal>et al</etal><article-title>Nanopore sequencing and assembly of a human genome with ultra-long reads</article-title>. <source>Nat Biotechnol</source><year>2018</year>;<volume>36</volume>:<fpage>338</fpage>–<lpage>45</lpage>.<pub-id pub-id-type="pmid">29431738</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Koren</surname><given-names>S</given-names></string-name>, <string-name><surname>Walenz</surname><given-names>BP</given-names></string-name>, <string-name><surname>Berlin</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>Canu: scalable and accurate long-read assembly via adaptive k-mer weighting and repeat separation</article-title>. <source>Genome Res</source><year>2017</year>;<volume>27</volume>:<fpage>722</fpage>–<lpage>36</lpage>.<pub-id pub-id-type="pmid">28298431</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kucherov</surname><given-names>G</given-names></string-name>, <string-name><surname>Noé</surname><given-names>L</given-names></string-name>, <string-name><surname>Roytberg</surname><given-names>M.</given-names></string-name></person-group><article-title>Multiseed lossless filtration</article-title>. <source>IEEE/ACM Trans Comput Biol Bioinform</source><year>2005</year>;<volume>2</volume>:<fpage>51</fpage>–<lpage>61</lpage>.<pub-id pub-id-type="pmid">17044164</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group><article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title>. <source>Bioinformatics</source><year>2018</year>;<volume>34</volume>:<fpage>3094</fpage>–<lpage>100</lpage>.<pub-id pub-id-type="pmid">29750242</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>M</given-names></string-name>, <string-name><surname>Ma</surname><given-names>B</given-names></string-name>, <string-name><surname>Kisman</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>PatternHunter II: highly sensitive and fast homology search</article-title>. <source>J Bioinform Comput Biol</source><year>2004</year>;<volume>2</volume>:<fpage>417</fpage>–<lpage>39</lpage>.<pub-id pub-id-type="pmid">15359419</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lin</surname><given-names>Y</given-names></string-name>, <string-name><surname>Yuan</surname><given-names>J</given-names></string-name>, <string-name><surname>Kolmogorov</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Assembly of long error-prone reads using de Bruijn graphs</article-title>. <source>Proc Natl Acad Sci USA</source><year>2016</year>;<volume>113</volume>:<fpage>E8396</fpage>–<lpage>405</lpage>.<pub-id pub-id-type="pmid">27956617</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ma</surname><given-names>B</given-names></string-name>, <string-name><surname>Tromp</surname><given-names>J</given-names></string-name>, <string-name><surname>Li</surname><given-names>M.</given-names></string-name></person-group><article-title>PatternHunter: faster and more sensitive homology search</article-title>. <source>Bioinformatics</source><year>2002</year>;<volume>18</volume>:<fpage>440</fpage>–<lpage>5</lpage>.<pub-id pub-id-type="pmid">11934743</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Maier</surname><given-names>BD</given-names></string-name>, <string-name><surname>Sahlin</surname><given-names>K.</given-names></string-name></person-group><article-title>Entropy predicts fuzzy-seed sensitivity</article-title>. In: <italic toggle="yes">Proceedings of the 27th International Conference on Research in Computational Molecular Biology (RECOMB’23)</italic>. 203–204. Springer, 2023.</mixed-citation>
    </ref>
    <ref id="btad218-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mak</surname><given-names>D</given-names></string-name>, <string-name><surname>Gelfand</surname><given-names>Y</given-names></string-name>, <string-name><surname>Benson</surname><given-names>G.</given-names></string-name></person-group><article-title>Indel seeds for homology search</article-title>. <source>Bioinformatics</source><year>2006</year>;<volume>22</volume>:<fpage>e341</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">16873491</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marçais</surname><given-names>G</given-names></string-name>, <string-name><surname>DeBlasio</surname><given-names>D</given-names></string-name>, <string-name><surname>Kingsford</surname><given-names>C.</given-names></string-name></person-group><article-title>Asymptotically optimal minimizers schemes</article-title>. <source>Bioinformatics</source><year>2018</year>;<volume>34</volume>:<fpage>i13</fpage>–<lpage>22</lpage>.<pub-id pub-id-type="pmid">29949995</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marçais</surname><given-names>G</given-names></string-name>, <string-name><surname>DeBlasio</surname><given-names>D</given-names></string-name>, <string-name><surname>Pandey</surname><given-names>P</given-names></string-name></person-group><etal>et al</etal><article-title>Locality-sensitive hashing for the edit distance</article-title>. <source>Bioinformatics</source><year>2019</year>;<volume>35</volume>:<fpage>i127</fpage>–<lpage>35</lpage>.<pub-id pub-id-type="pmid">31510667</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B29">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Myers</surname><given-names>G</given-names></string-name>, <string-name><surname>Miller</surname><given-names>W.</given-names></string-name></person-group> Chaining multiple-alignment fragments in sub-quadratic time. In: <italic toggle="yes">Proceedings of the 6th ACM-SIAM Symposium on Discrete Algorithms (SODA’95)</italic>, Vol. 95. <fpage>38</fpage>–<lpage>47</lpage>. <year>1995</year>.</mixed-citation>
    </ref>
    <ref id="btad218-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Nurk</surname><given-names>S</given-names></string-name>, <string-name><surname>Walenz</surname><given-names>BP</given-names></string-name>, <string-name><surname>Rhie</surname><given-names>A</given-names></string-name></person-group><etal>et al</etal><article-title>HiCanu: accurate assembly of segmental duplications, satellites, and allelic variants from high-fidelity long reads</article-title>. <source>Genome Res</source><year>2020</year>;<volume>30</volume>:<fpage>1291</fpage>–<lpage>305</lpage>.<pub-id pub-id-type="pmid">32801147</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ono</surname><given-names>Y</given-names></string-name>, <string-name><surname>Asai</surname><given-names>K</given-names></string-name>, <string-name><surname>Hamada</surname><given-names>M.</given-names></string-name></person-group><article-title>PBSIM2: a simulator for long-read sequencers with a novel generative model of quality scores</article-title>. <source>Bioinformatics</source><year>2021</year>;<volume>37</volume>:<fpage>589</fpage>–<lpage>95</lpage>.<pub-id pub-id-type="pmid">32976553</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rautiainen</surname><given-names>M</given-names></string-name>, <string-name><surname>Marschall</surname><given-names>T.</given-names></string-name></person-group><article-title>MBG: minimizer-based sparse de Bruijn graph construction</article-title>. <source>Bioinformatics</source><year>2021</year>;<volume>37</volume>:<fpage>2476</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">33475133</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rhoads</surname><given-names>A</given-names></string-name>, <string-name><surname>Au</surname><given-names>KF.</given-names></string-name></person-group><article-title>PacBio sequencing and its applications</article-title>. <source>Genomics Proteomics Bioinformatics</source><year>2015</year>;<volume>13</volume>:<fpage>278</fpage>–<lpage>89</lpage>.<pub-id pub-id-type="pmid">26542840</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Roberts</surname><given-names>M</given-names></string-name>, <string-name><surname>Hayes</surname><given-names>W</given-names></string-name>, <string-name><surname>Hunt</surname><given-names>BR</given-names></string-name></person-group><etal>et al</etal><article-title>Reducing storage requirements for biological sequence comparison</article-title>. <source>Bioinformatics</source><year>2004a</year>;<volume>20</volume>:<fpage>3363</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">15256412</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Roberts</surname><given-names>M</given-names></string-name>, <string-name><surname>Hunt</surname><given-names>BR</given-names></string-name>, <string-name><surname>Yorke</surname><given-names>JA</given-names></string-name></person-group><etal>et al</etal><article-title>A preprocessor for shotgun assembly of large genomes</article-title>. <source>J Comput Biol</source><year>2004b</year>;<volume>11</volume>:<fpage>734</fpage>–<lpage>52</lpage>.<pub-id pub-id-type="pmid">15579242</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ruan</surname><given-names>J</given-names></string-name>, <string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group><article-title>Fast and accurate long-read assembly with wtdbg2</article-title>. <source>Nat Methods</source><year>2020</year>;<volume>17</volume>:<fpage>155</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">31819265</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B37">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sahlin</surname><given-names>K.</given-names></string-name></person-group><article-title>Effective sequence similarity detection with strobemers</article-title>. <source>Genome Res</source><year>2021</year>;<volume>31</volume>:<fpage>2080</fpage>–<lpage>94</lpage>.<pub-id pub-id-type="pmid">34667119</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B38">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sahlin</surname><given-names>K.</given-names></string-name></person-group><article-title>Strobealign: flexible seed size enables ultra-fast and accurate read alignment</article-title>. <source>Genome Biol</source><year>2022</year>;<volume>23</volume>:<fpage>1</fpage>–<lpage>27</lpage>.<pub-id pub-id-type="pmid">34980209</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B39">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Schleimer</surname><given-names>S</given-names></string-name>, <string-name><surname>Wilkerson</surname><given-names>DS</given-names></string-name>, <string-name><surname>Aiken</surname><given-names>A.</given-names></string-name></person-group> Winnowing: local algorithms for document fingerprinting. In: <italic toggle="yes">Proceedings of the 2003 ACM SIGMOD International Conference on Management of Data (SIGMOD/PODS’03)</italic>. <fpage>76</fpage>–<lpage>85</lpage>. <year>2003</year>.</mixed-citation>
    </ref>
    <ref id="btad218-B40">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Song</surname><given-names>Y</given-names></string-name>, <string-name><surname>Tang</surname><given-names>H</given-names></string-name>, <string-name><surname>Zhang</surname><given-names>H</given-names></string-name></person-group><etal>et al</etal><article-title>Overlap detection on long, error-prone sequencing reads via smooth q-gram</article-title>. <source>Bioinformatics</source><year>2020</year>;<volume>36</volume>:<fpage>4838</fpage>–<lpage>45</lpage>.<pub-id pub-id-type="pmid">32311007</pub-id></mixed-citation>
    </ref>
    <ref id="btad218-B41">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sun</surname><given-names>Y</given-names></string-name>, <string-name><surname>Buhler</surname><given-names>J.</given-names></string-name></person-group><article-title>Designing multiple simultaneous seeds for DNA similarity search</article-title>. <source>J Comput Biol</source><year>2005</year>;<volume>12</volume>:<fpage>847</fpage>–<lpage>61</lpage>.<pub-id pub-id-type="pmid">16108721</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
