<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Algorithms Mol Biol</journal-id>
    <journal-id journal-id-type="iso-abbrev">Algorithms Mol Biol</journal-id>
    <journal-title-group>
      <journal-title>Algorithms for Molecular Biology : AMB</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1748-7188</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3974045</article-id>
    <article-id pub-id-type="publisher-id">1748-7188-9-2</article-id>
    <article-id pub-id-type="pmid">24565280</article-id>
    <article-id pub-id-type="doi">10.1186/1748-7188-9-2</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Using cascading Bloom filters to improve the memory usage for de Brujin graphs</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" id="A1">
        <name>
          <surname>Salikhov</surname>
          <given-names>Kamil</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>salikhov.kamil@gmail.com</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Sacomoto</surname>
          <given-names>Gustavo</given-names>
        </name>
        <xref ref-type="aff" rid="I2">2</xref>
        <xref ref-type="aff" rid="I3">3</xref>
        <email>gustavo.sacomoto@inria.fr</email>
      </contrib>
      <contrib contrib-type="author" corresp="yes" id="A3">
        <name>
          <surname>Kucherov</surname>
          <given-names>Gregory</given-names>
        </name>
        <xref ref-type="aff" rid="I4">4</xref>
        <xref ref-type="aff" rid="I5">5</xref>
        <email>Gregory.Kucherov@univ-mlv.fr</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Lomonosov Moscow State University, Moscow, Russia</aff>
    <aff id="I2"><label>2</label>INRIA Grenoble Rhône-Alpes, Grenoble, France</aff>
    <aff id="I3"><label>3</label>Laboratoire Biométrie et Biologie Evolutive, Université Lyon 1, Lyon, France</aff>
    <aff id="I4"><label>4</label>Department of Computer Science, Ben-Gurion University of the Negev, Be’er Sheva, Israel</aff>
    <aff id="I5"><label>5</label>Laboratoire d’Informatique Gaspard Monge, Université Paris-Est &amp; CNRS, Marne-la-Vallée, Paris, France</aff>
    <pub-date pub-type="collection">
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>24</day>
      <month>2</month>
      <year>2014</year>
    </pub-date>
    <volume>9</volume>
    <fpage>2</fpage>
    <lpage>2</lpage>
    <history>
      <date date-type="received">
        <day>8</day>
        <month>12</month>
        <year>2013</year>
      </date>
      <date date-type="accepted">
        <day>17</day>
        <month>2</month>
        <year>2014</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2014 Salikhov et al.; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2014</copyright-year>
      <copyright-holder>Salikhov et al.; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly credited. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.almob.org/content/9/1/2"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>De Brujin graphs are widely used in bioinformatics for processing next-generation sequencing data. Due to a very large size of NGS datasets, it is essential to represent de Bruijn graphs compactly, and several approaches to this problem have been proposed recently.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>In this work, we show how to reduce the memory required by the data structure of Chikhi and Rizk (WABI’12) that represents de Brujin graphs using Bloom filters. Our method requires 30% to 40% less memory with respect to their method, with insignificant impact on construction time. At the same time, our experiments showed a better query time compared to the method of Chikhi and Rizk.</p>
      </sec>
      <sec>
        <title>Conclusion</title>
        <p>The proposed data structure constitutes, to our knowledge, currently the most efficient practical representation of de Bruijn graphs.</p>
      </sec>
    </abstract>
    <kwd-group>
      <kwd>Next-generation sequencing</kwd>
      <kwd>Genome assembly</kwd>
      <kwd>de Brujin graph</kwd>
      <kwd>Bloom filter</kwd>
    </kwd-group>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>Modern next-generation sequencing (NGS) technologies generate huge volumes of short nucleotide sequences (<italic>reads</italic>) drawn from a DNA sample under study. The length of a read varies from 35 to about 400 base pairs (letters) and the number of reads may be hundreds of millions, thus the total volume of data may reach tens or even hundreds of Gb.</p>
    <p>Many computational tools dealing with NGS data, especially those devoted to <italic>genome assembly</italic>, are based on the concept of a <italic>de Bruijn graph</italic>, see e.g. [<xref ref-type="bibr" rid="B1">1</xref>]. Nodes of a de Bruijn graph<sup>a</sup> correspond to all distinct <italic>k-mers</italic> occurring in the given set of reads, and two <italic>k-mers</italic> are linked by an arc if they have a suffix-prefix overlap of size <italic>k</italic>−1. The value of <italic>k</italic> is an open parameter that in practice is chosen between 20 and 64. The idea of using de Bruijn graphs for genome assembly goes back to the “pre-NGS era” [<xref ref-type="bibr" rid="B2">2</xref>]. Note, however, that <italic>de novo</italic> genome assembly is not the only application of those graphs when dealing with NGS data. There are several others, including: <italic>de novo</italic> transcriptome assembly [<xref ref-type="bibr" rid="B3">3</xref>] and <italic>de novo</italic> alternative splicing calling [<xref ref-type="bibr" rid="B4">4</xref>] from transcriptomic NGS data (RNA-seq); metagenome assembly [<xref ref-type="bibr" rid="B5">5</xref>] from metagenomic NGS data; and genomic variant detection [<xref ref-type="bibr" rid="B6">6</xref>] from genomic NGS data using a reference genome.</p>
    <p>Due to a very large size of NGS datasets, it is essential to represent de Bruijn graphs as compactly as possible. This has been a very active line of research. Recently, several papers have been published that propose different approaches to compressing de Bruijn graphs [<xref ref-type="bibr" rid="B7">7</xref>-<xref ref-type="bibr" rid="B11">11</xref>].</p>
    <p>Conway and Bromage [<xref ref-type="bibr" rid="B7">7</xref>] proposed a method based on classical succinct data structures, i.e. bitmaps with efficient rank/select operations. On the same direction, Bowe et al. [<xref ref-type="bibr" rid="B10">10</xref>] proposed an interesting succinct representation that, assuming only one string (read) is present, uses only 4<italic>E</italic> bits, where <italic>E</italic> is the number of arcs in the graph. The more realistic case where there are <italic>R</italic> reads can be easily reduced to the one string case by concatenating all <italic>R</italic> reads using a special separator character. In this case, however, the size of the structure is 4<italic>E</italic>+<italic>O</italic>(<italic>R</italic> log<italic>E</italic>) bits ([<xref ref-type="bibr" rid="B10">10</xref>], Theorem 1). Since the multiplicative constant of the second term is difficult to evaluate, it is hard to know precisely what would be the size of this structure in practice.</p>
    <p>Ye et al. [<xref ref-type="bibr" rid="B8">8</xref>] proposed a different method based on a sparse representation of de Bruijn graphs, where only a subset of <italic>k</italic>-mers present in the dataset are stored. Using the <italic>Bloom filter</italic> data structure, Pell et al. [<xref ref-type="bibr" rid="B11">11</xref>] proposed <italic>probabilistic de Bruijn graphs</italic> as a compact approximate representation of full de Bruijn graphs. Finally, Chikhi and Rizk [<xref ref-type="bibr" rid="B9">9</xref>] improved Pell’s scheme in order to obtain an exact representation of the de Bruijn graph.</p>
    <p>A direct application of Bloom filters to de Bruijn graphs, studied in [<xref ref-type="bibr" rid="B11">11</xref>], results in a space-efficient representation at the price of allowing <italic>one-sided errors</italic>, namely <italic>false positive</italic> nodes (<italic>k</italic>-mers). The method of [<xref ref-type="bibr" rid="B9">9</xref>] removes these errors and proposes a space-efficient data structure for the <italic>exact</italic> representation of de Bruijn graphs. The method is based on the following idea. In the genome assembly application, de Bruijn graphs are only used for traversal, and random accesses to graph nodes are never performed. If all queried nodes (<italic>k</italic>-mers) are only those which are reachable from some node known to belong to the graph, then only a fraction of all false positives can actually occur. Storing these false positives explicitly leads to an exact (false positive free) and space-efficient representation of the de Bruijn graph. This is the best practical <italic>exact</italic> representation of de Bruijn graphs for the purpose of genome assembly, now implemented in <sc>MINIA</sc> software [<xref ref-type="bibr" rid="B15">15</xref>].</p>
    <p>Our main contribution is an improvement of the method of [<xref ref-type="bibr" rid="B9">9</xref>] by changing the representation of the set of false positives. We achieve this by iteratively applying a Bloom filter to represent the set of false positives, then the set of “false false positives” etc. We show analytically that this cascade of Bloom filters allows for a considerable further economy of memory, improving the method of [<xref ref-type="bibr" rid="B9">9</xref>]. Depending on the value of <italic>k</italic>, our method requires 30% to 40% less memory with respect to the method of [<xref ref-type="bibr" rid="B9">9</xref>]. Moreover, with our method, the memory grows very little as <italic>k</italic> grows. Finally, we implemented our method and tested it against [<xref ref-type="bibr" rid="B9">9</xref>] on real datasets. The tests confirm the theoretical predictions for the size of structure and show a 20% to 30% <italic>improvement</italic> in query times.</p>
  </sec>
  <sec>
    <title>Preliminaries</title>
    <p>A <italic>Bloom filter</italic> is a space-efficient data structure for representing a given subset of elements <italic>T</italic>⊆<italic>U</italic>, with support for efficient membership queries with one-sided error. That is, if a query for an element <italic>x</italic>∈<italic>U</italic> returns <italic>no</italic> then <italic>x</italic>∉<italic>T</italic>, but if it returns <italic>yes</italic> then either <italic>x</italic>∈<italic>T</italic>, or, with small probability, <italic>x</italic>∉<italic>T</italic> (false positive). A Bloom filter consists of a bitmap (array of bits) <italic>B</italic> of size <italic>m</italic> and a set of <italic>p</italic> distinct hash functions {<italic>h</italic><sub>1</sub>,…,<italic>h</italic><sub><italic>p</italic></sub>}, where <italic>h</italic><sub><italic>i</italic></sub>:<italic>U</italic>↦{0,…,<italic>m</italic>−1}. Initially, all bits of <italic>B</italic> are set to 0. An insertion of an element <italic>x</italic>∈<italic>T</italic> is done by setting the bits of <italic>B</italic> with indices <italic>h</italic><sub>1</sub>(<italic>x</italic>),…,<italic>h</italic><sub><italic>p</italic></sub>(<italic>x</italic>) to 1, i.e. <italic>B</italic>[ <italic>h</italic><sub><italic>i</italic></sub>(<italic>x</italic>)]=1 for all <italic>i</italic>∈ [ 1,<italic>p</italic>]. Membership queries are done symmetrically, returning <italic>yes</italic> if all <italic>B</italic>[ <italic>h</italic><sub><italic>i</italic></sub>(<italic>x</italic>)] are equal 1 and <italic>no</italic> otherwise. As shown in [<xref ref-type="bibr" rid="B12">12</xref>], when considering hash functions that yield equally likely positions in the bitmap, and for large enough bitmap size <italic>m</italic> and number of inserted elements <italic>n</italic>, the false positive rate <inline-formula><inline-graphic xlink:href="1748-7188-9-2-i1.gif"/></inline-formula> is</p>
    <p>
      <disp-formula id="bmcM1">
        <label>(1)</label>
        <mml:math id="M1" name="1748-7188-9-2-i2" overflow="scroll">
          <mml:mi mathvariant="script">F</mml:mi>
          <mml:mo>≈</mml:mo>
          <mml:msup>
            <mml:mrow>
              <mml:mo>(</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo>−</mml:mo>
              <mml:msup>
                <mml:mrow>
                  <mml:mi>e</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo>−</mml:mo>
                  <mml:mtext mathvariant="italic">pn</mml:mtext>
                  <mml:mo>/</mml:mo>
                  <mml:mi>m</mml:mi>
                </mml:mrow>
              </mml:msup>
              <mml:mo>)</mml:mo>
            </mml:mrow>
            <mml:mrow>
              <mml:mi>p</mml:mi>
            </mml:mrow>
          </mml:msup>
          <mml:mo>=</mml:mo>
          <mml:msup>
            <mml:mrow>
              <mml:mo>(</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo>−</mml:mo>
              <mml:msup>
                <mml:mrow>
                  <mml:mi>e</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo>−</mml:mo>
                  <mml:mi>p</mml:mi>
                  <mml:mo>/</mml:mo>
                  <mml:mi>r</mml:mi>
                </mml:mrow>
              </mml:msup>
              <mml:mo>)</mml:mo>
            </mml:mrow>
            <mml:mrow>
              <mml:mi>p</mml:mi>
            </mml:mrow>
          </mml:msup>
        </mml:math>
      </disp-formula>
    </p>
    <p>where <italic>r</italic>=<italic>m</italic>/<italic>n</italic> is the number of bits (of the bitmap <italic>B</italic>) per element (of <italic>T</italic> represented). It is not hard to see that this expression is minimized when <italic>p</italic>=<italic>r</italic> ln2, giving the false positive rate</p>
    <p>
      <disp-formula id="bmcM2">
        <label>(2)</label>
        <mml:math id="M2" name="1748-7188-9-2-i3" overflow="scroll">
          <mml:mi mathvariant="script">F</mml:mi>
          <mml:mo>≈</mml:mo>
          <mml:msup>
            <mml:mrow>
              <mml:mo>(</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo>−</mml:mo>
              <mml:msup>
                <mml:mrow>
                  <mml:mi>e</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo>−</mml:mo>
                  <mml:mo>ln</mml:mo>
                  <mml:mn>2</mml:mn>
                </mml:mrow>
              </mml:msup>
              <mml:mo>)</mml:mo>
            </mml:mrow>
            <mml:mrow>
              <mml:mi>r</mml:mi>
              <mml:mo>ln</mml:mo>
              <mml:mn>2</mml:mn>
            </mml:mrow>
          </mml:msup>
          <mml:mo>=</mml:mo>
          <mml:msup>
            <mml:mrow>
              <mml:mo>(</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo>/</mml:mo>
              <mml:mn>2</mml:mn>
              <mml:mo>)</mml:mo>
            </mml:mrow>
            <mml:mrow>
              <mml:mi>r</mml:mi>
              <mml:mo>ln</mml:mo>
              <mml:mn>2</mml:mn>
            </mml:mrow>
          </mml:msup>
          <mml:mo>≈</mml:mo>
          <mml:mn>0.618</mml:mn>
          <mml:msup>
            <mml:mrow>
              <mml:mn>5</mml:mn>
            </mml:mrow>
            <mml:mrow>
              <mml:mi>r</mml:mi>
            </mml:mrow>
          </mml:msup>
          <mml:mi>.</mml:mi>
        </mml:math>
      </disp-formula>
    </p>
    <p>A <italic>de Bruijn graph</italic>, for a given parameter <italic>k</italic>, of a set of reads (strings) <inline-formula><mml:math id="M3" name="1748-7188-9-2-i4" overflow="scroll"><mml:mi mathvariant="script">R</mml:mi><mml:mo>⊆</mml:mo><mml:msup><mml:mrow><mml:mi>Σ</mml:mi></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> is entirely defined by the set <italic>T</italic>⊆<italic>U</italic>=<italic>Σ</italic><sup><italic>k</italic></sup> of <italic>k</italic>-mers present in <inline-formula><inline-graphic xlink:href="1748-7188-9-2-i5.gif"/></inline-formula>. The nodes of the graph are precisely the <italic>k</italic>-mers of <italic>T</italic> and for any two vertices <italic>u</italic>,<italic>v</italic>∈<italic>T</italic>, there is an arc from <italic>u</italic> to <italic>v</italic> if the suffix of <italic>u</italic> of size (<italic>k</italic>−1) is equal to the prefix of <italic>v</italic> of the same size. Thus, given a set <italic>T</italic>⊆<italic>U</italic> of <italic>k</italic>-mers, we can represent its de Bruijn graph using a Bloom filter <italic>B</italic>. This approach has the disadvantage of having false positive nodes, as a direct consequence of false positives in the Bloom filter, which can create false connections in the graph (see [<xref ref-type="bibr" rid="B11">11</xref>] for the influence of false positive nodes on the topology of the graph). The naive way to remove those false positives nodes by explicitly storing (e.g. using a hash table) the set of all false positives of <italic>B</italic> is clearly inefficient, as the expected number of elements to be explicitly stored is <inline-formula><mml:math id="M4" name="1748-7188-9-2-i6" overflow="scroll"><mml:mo>|</mml:mo><mml:mi>U</mml:mi><mml:mo>|</mml:mo><mml:mi mathvariant="script">F</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mi mathvariant="script">F</mml:mi></mml:math></inline-formula>.</p>
    <p>The key idea of [<xref ref-type="bibr" rid="B9">9</xref>] is to explicitly store only a small subset of all false positives of <italic>B</italic>, the so-called <italic>critical false positives</italic>. Consider a <italic>k</italic>-mer <italic>u</italic> that belongs to <italic>T</italic>, <italic>u</italic> has at most 2|<italic>Σ</italic>|=8<italic>potential neighbors</italic>, i.e. <italic>k</italic>-mers overlapping <italic>u</italic> by (<italic>k</italic>−1) letters. The set of <italic>critical false positives</italic> consists of the potential neighbors of <italic>k</italic>-mers of <italic>T</italic> that are false positives of <italic>B</italic>. This set is, in general, much smaller than the set of all false positives of <italic>B</italic>, its expected size can be upper-bounded by <inline-formula><mml:math id="M5" name="1748-7188-9-2-i7" overflow="scroll"><mml:mn>8</mml:mn><mml:mo>|</mml:mo><mml:mi>T</mml:mi><mml:mo>|</mml:mo><mml:mi mathvariant="script">F</mml:mi></mml:math></inline-formula>. On the other hand, storing the set of critical false positives is clearly sufficient to represent the de Bruijn graph if one only wants to support graph traversal, i.e. navigation from a node of the graph to its neighbors. In this case, only potential neighbors of nodes in <italic>T</italic> are queried.</p>
  </sec>
  <sec>
    <title>Cascading Bloom filter</title>
    <p>Let <inline-formula><inline-graphic xlink:href="1748-7188-9-2-i8.gif"/></inline-formula> be a set of reads and <italic>T</italic><sub>0</sub> be the set of occurring <italic>k</italic>-mers (nodes of the de Brujin graph) that we want to store. As stated in Section “Preliminaries”, the method of [<xref ref-type="bibr" rid="B9">9</xref>] stores <italic>T</italic><sub>0</sub> via a bitmap <italic>B</italic><sub>1</sub> using a Bloom filter, together with the set <italic>T</italic><sub>1</sub> of critical false positives. <italic>T</italic><sub>1</sub> consists of potential neighbors of <italic>T</italic><sub>0</sub> which are stored in <italic>B</italic><sub>1</sub> “by mistake”, i.e. belong<sup>b</sup> to <italic>B</italic><sub>1</sub> but not to <italic>T</italic><sub>0</sub>. <italic>B</italic><sub>1</sub> and <italic>T</italic><sub>1</sub> are sufficient to represent the graph provided that the only queried <italic>k</italic>-mers are those which are potential neighbors of <italic>k</italic>-mers of <italic>T</italic><sub>0</sub>.</p>
    <p>The idea we introduce in this work is to use this structure recursively and represent the set <italic>T</italic><sub>1</sub> by a new bitmap <italic>B</italic><sub>2</sub> and a new set <italic>T</italic><sub>2</sub>, then represent <italic>T</italic><sub>2</sub> by <italic>B</italic><sub>3</sub> and <italic>T</italic><sub>3</sub>, and so on. More formally, starting from <italic>B</italic><sub>1</sub> and <italic>T</italic><sub>1</sub> defined as above, we define a series of bitmaps <italic>B</italic><sub>1</sub>,<italic>B</italic><sub>2</sub>,… and a series of sets <italic>T</italic><sub>1</sub>,<italic>T</italic><sub>2</sub>,… as follows. <italic>B</italic><sub>2</sub> stores the set of false positives <italic>T</italic><sub>1</sub> using another Bloom filter, and <italic>T</italic><sub>2</sub> contains the critical false positives of <italic>B</italic><sub>2</sub>, i.e. true positives from <italic>T</italic><sub>0</sub> that are stored in <italic>B</italic><sub>2</sub> “by mistake” (we call them <italic>false false positives</italic>). <italic>B</italic><sub>3</sub> and <italic>T</italic><sub>3</sub>, and, generally, <italic>B</italic><sub><italic>i</italic></sub> and <italic>T</italic><sub><italic>i</italic></sub> are defined similarly: <italic>B</italic><sub><italic>i</italic></sub> stores <italic>k</italic>-mers of <italic>T</italic><sub><italic>i</italic>−1</sub> using a Bloom filter, and <italic>T</italic><sub><italic>i</italic></sub> contains <italic>k</italic>-mers stored in <italic>B</italic><sub><italic>i</italic></sub> “by mistake”, i.e. those <italic>k</italic>-mers in <italic>B</italic><sub><italic>i</italic></sub> that do not belong to <italic>T</italic><sub><italic>i</italic>−1</sub> but belong to <italic>T</italic><sub><italic>i</italic>−2</sub>. Observe that <italic>T</italic><sub>0</sub>∩<italic>T</italic><sub>1</sub>=<italic>∅</italic>, <italic>T</italic><sub>0</sub>⊇<italic>T</italic><sub>2</sub>⊇<italic>T</italic><sub>4</sub>… and <italic>T</italic><sub>1</sub>⊇<italic>T</italic><sub>3</sub>⊇<italic>T</italic><sub>5</sub>….</p>
    <p>The following lemma shows that the construction is correct, that is it allows one to verify whether or not a given <italic>k</italic>-mer belongs to the set <italic>T</italic><sub>0</sub>.</p>
    <sec>
      <title><bold>Lemma </bold><bold>1</bold>.</title>
      <p>Given a <italic>k</italic>-mer (node) <italic>u</italic>, consider the smallest <italic>i</italic> such that <italic>u</italic>∉<italic>B</italic><sub><italic>i</italic>+1</sub> (if <italic>u</italic>∉<italic>B</italic><sub>1</sub>, we define <italic>i</italic>=0). Then, if <italic>i</italic> is odd, then <italic>u</italic>∈<italic>T</italic><sub>0</sub>, and if <italic>i</italic> is even (including 0), then <italic>u</italic>∉<italic>T</italic><sub>0</sub>.</p>
    </sec>
    <sec>
      <title><italic>Proof</italic>.</title>
      <p>Observe that <italic>u</italic>∉<italic>B</italic><sub><italic>i</italic>+1</sub> implies <italic>u</italic>∉<italic>T</italic><sub><italic>i</italic></sub> by the basic property of Bloom filters that membership queries have one-sided error, i.e. there are no false negatives. We first check the Lemma for <italic>i</italic>=0,1.</p>
      <p>For <italic>i</italic>=0, we have <italic>u</italic>∉<italic>B</italic><sub>1</sub>, and then <italic>u</italic>∉<italic>T</italic><sub>0</sub>.</p>
      <p>For <italic>i</italic>=1, we have <italic>u</italic>∈<italic>B</italic><sub>1</sub> but <italic>u</italic>∉<italic>B</italic><sub>2</sub>. The latter implies that <italic>u</italic>∉<italic>T</italic><sub>1</sub>, and then <italic>u</italic> must be a false false positive, that is <italic>u</italic>∈<italic>T</italic><sub>0</sub>. Note that here we use the fact that the only queried <italic>k</italic>-mers <italic>u</italic> are either nodes of <italic>T</italic><sub>0</sub> or their potential neighbors in the graph (see [<xref ref-type="bibr" rid="B9">9</xref>]), and therefore if <italic>u</italic>∈<italic>B</italic><sub>1</sub> and <italic>u</italic>∉<italic>T</italic><sub>0</sub> then <italic>u</italic>∈<italic>T</italic><sub>1</sub>.</p>
      <p>For the general case <italic>i</italic>≥2, we show by induction that <italic>u</italic>∈<italic>T</italic><sub><italic>i</italic>−1</sub>. Indeed, <italic>u</italic>∈<italic>B</italic><sub>1</sub>∩…∩<italic>B</italic><sub><italic>i</italic></sub> implies <italic>u</italic>∈<italic>T</italic><sub><italic>i</italic>−1</sub>∪<italic>T</italic><sub><italic>i</italic></sub> (which, again, is easily seen by induction), and <italic>u</italic>∉<italic>B</italic><sub><italic>i</italic>+1</sub> implies <italic>u</italic>∉<italic>T</italic><sub><italic>i</italic></sub>.</p>
      <p>Since <italic>T</italic><sub><italic>i</italic>−1</sub>⊆<italic>T</italic><sub>0</sub> for odd <italic>i</italic>, and <italic>T</italic><sub><italic>i</italic>−1</sub>⊆<italic>T</italic><sub>1</sub> for even <italic>i</italic> (for <italic>T</italic><sub>0</sub>∩<italic>T</italic><sub>1</sub>=<italic>∅</italic>), the lemma follows.</p>
      <p>Naturally, Lemma 1 provides an algorithm to check if a given <italic>k</italic>-mer <italic>u</italic> belongs to the graph: it suffices to check successively if it belongs to <italic>B</italic><sub>1</sub>,<italic>B</italic><sub>2</sub>,… until we encounter the first <italic>B</italic><sub><italic>i</italic>+1</sub> which does not contain <italic>u</italic>. Then, the answer will simply depend on whether <italic>i</italic> is even or odd: <italic>u</italic> belongs to the graph if and only if <italic>i</italic> is odd</p>
      <p>In our reasoning so far, we assumed an infinite number of bitmaps <italic>B</italic><sub><italic>i</italic></sub>. Of course, in practice we cannot store infinitely many (and even simply many) bitmaps. Therefore, we truncate the construction at some step <italic>t</italic> and store a finite set of bitmaps <italic>B</italic><sub>1</sub>,<italic>B</italic><sub>2</sub>,…,<italic>B</italic><sub><italic>t</italic></sub> together with an explicit representation of <italic>T</italic><sub><italic>t</italic></sub>. The procedure of Lemma 1 is extended in the obvious way: if for all 1≤<italic>i</italic>≤<italic>t</italic>, <italic>u</italic>∈<italic>B</italic><sub><italic>i</italic></sub>, then the answer is determined by directly checking <italic>u</italic>∈<italic>T</italic><sub><italic>t</italic></sub>.</p>
    </sec>
  </sec>
  <sec>
    <title>Analysis of the data structure</title>
    <sec>
      <title>Memory and time usage</title>
      <p>First, we estimate the memory needed by our data structure, under the assumption of an infinite number of bitmaps. Let <italic>N</italic> be the number of true positives, i.e. |<italic>T</italic><sub>0</sub>|=<italic>N</italic>. As stated in Section “Preliminaries”, if <italic>T</italic><sub>0</sub> has to be stored via a bitmap <italic>B</italic><sub>1</sub> of size <italic>rN</italic>, the false positive rate can be estimated as <italic>c</italic><sup><italic>r</italic></sup>, where <italic>c</italic>=0.6185. And, the expected number of critical false positive nodes (set <italic>T</italic><sub>1</sub>) has been estimated in [<xref ref-type="bibr" rid="B9">9</xref>] to be 8<italic>N</italic><italic>c</italic><sup><italic>r</italic></sup>, as every node has eight extensions, i.e. potential neighbors in the graph. We slightly refine this estimation to 6<italic>N</italic><italic>c</italic><sup><italic>r</italic></sup> by noticing that for most of the graph nodes, two out of these eight extensions belong to <italic>T</italic><sub>0</sub> (are real nodes) and thus only six are potential false positives. Furthermore, to store these 6<italic>N</italic><italic>c</italic><sup><italic>r</italic></sup> critical false positive nodes, we use a bitmap <italic>B</italic><sub>2</sub> of size 6<italic>r</italic><italic>N</italic><italic>c</italic><sup><italic>r</italic></sup>. Bitmap <italic>B</italic><sub>3</sub> is used for storing nodes of <italic>T</italic><sub>0</sub> which are stored in <italic>B</italic><sub>2</sub> “by mistake” (set <italic>T</italic><sub>2</sub>). We estimate the number of these nodes as the fraction <italic>c</italic><sup><italic>r</italic></sup> (false positive rate of filter <italic>B</italic><sub>2</sub>) of <italic>N</italic> (size of <italic>T</italic><sub>0</sub>), that is <italic>N</italic><italic>c</italic><sup><italic>r</italic></sup>. Similarly, the number of nodes we need to put to <italic>B</italic><sub>4</sub> is 6<italic>N</italic><italic>c</italic><sup><italic>r</italic></sup> multiplied by <italic>c</italic><sup><italic>r</italic></sup>, i.e. 6<italic>N</italic><italic>c</italic><sup>2<italic>r</italic></sup>. Keeping counting in this way, the memory needed for the whole structure is <italic>r</italic><italic>N</italic>+6<italic>r</italic><italic>N</italic><italic>c</italic><sup><italic>r</italic></sup>+<italic>r</italic><italic>N</italic><italic>c</italic><sup><italic>r</italic></sup>+6<italic>r</italic><italic>N</italic><italic>c</italic><sup>2<italic>r</italic></sup>+<italic>r</italic><italic>N</italic><italic>c</italic><sup>2<italic>r</italic></sup>+… bits. The number of bits per <italic>k</italic>-mer is then</p>
      <p>
        <disp-formula id="bmcM3">
          <label>(3)</label>
          <mml:math id="M6" name="1748-7188-9-2-i9" overflow="scroll">
            <mml:mtable>
              <mml:mtr>
                <mml:mtd>
                  <mml:mi>r</mml:mi>
                  <mml:mspace width="0.3em"/>
                  <mml:mo>+</mml:mo>
                  <mml:mspace width="0.3em"/>
                  <mml:mn>6</mml:mn>
                  <mml:mi>r</mml:mi>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>c</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>r</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                  <mml:mspace width="0.3em"/>
                  <mml:mo>+</mml:mo>
                  <mml:mspace width="0.3em"/>
                  <mml:mi>r</mml:mi>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>c</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>r</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                  <mml:mspace width="0.3em"/>
                  <mml:mo>+</mml:mo>
                  <mml:mspace width="0.3em"/>
                  <mml:mn>6</mml:mn>
                  <mml:mi>r</mml:mi>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>c</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>2</mml:mn>
                      <mml:mi>r</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                  <mml:mo>+</mml:mo>
                  <mml:mo>…</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mo>(</mml:mo>
                  <mml:mi>r</mml:mi>
                  <mml:mo>+</mml:mo>
                  <mml:mn>6</mml:mn>
                  <mml:mi>r</mml:mi>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>c</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>r</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                  <mml:mo>)</mml:mo>
                  <mml:mo>(</mml:mo>
                  <mml:mn>1</mml:mn>
                  <mml:mspace width="0.3em"/>
                  <mml:mo>+</mml:mo>
                  <mml:mspace width="0.3em"/>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>c</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>r</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                  <mml:mo>+</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>c</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>2</mml:mn>
                      <mml:mi>r</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                  <mml:mo>+</mml:mo>
                  <mml:mo>…</mml:mo>
                  <mml:mo>)</mml:mo>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr>
                <mml:mtd>
                  <mml:mspace width="11em"/>
                  <mml:mo>=</mml:mo>
                  <mml:mo>(</mml:mo>
                  <mml:mn>1</mml:mn>
                  <mml:mo>+</mml:mo>
                  <mml:mn>6</mml:mn>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>c</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>r</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                  <mml:mo>)</mml:mo>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:mi>r</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>1</mml:mn>
                      <mml:mo>−</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi>c</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>r</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                  </mml:mfrac>
                  <mml:mi>.</mml:mi>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
      </p>
      <p>A simple calculation shows that the minimum of this expression is achieved when <italic>r</italic>=5.464, and then the minimum memory used per <italic>k</italic>-mer is 8.45 bits.</p>
      <p>As mentioned earlier, in practice we store only a finite number of bitmaps <italic>B</italic><sub>1</sub>,…,<italic>B</italic><sub><italic>t</italic></sub> together with an explicit representation (such as array or hash table) of <italic>T</italic><sub><italic>t</italic></sub>. In this case, the memory taken by the bitmaps is a truncated sum <italic>r</italic><italic>N</italic>+6<italic>r</italic><italic>N</italic><italic>c</italic><sup><italic>r</italic></sup>+<italic>r</italic><italic>N</italic><italic>c</italic><sup><italic>r</italic></sup>+.., and a data structure storing <italic>T</italic><sub><italic>t</italic></sub> takes either <inline-formula><mml:math id="M7" name="1748-7188-9-2-i10" overflow="scroll"><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>·</mml:mo><mml:mi>N</mml:mi><mml:msup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo>⌈</mml:mo><mml:mfrac><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>⌉</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> or <inline-formula><mml:math id="M8" name="1748-7188-9-2-i11" overflow="scroll"><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>·</mml:mo><mml:mn>6</mml:mn><mml:mi>N</mml:mi><mml:msup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo>⌈</mml:mo><mml:mfrac><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>⌉</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> bits, depending on whether <italic>t</italic> is even or odd. The latter follows from the observations that we need to store <inline-formula><mml:math id="M9" name="1748-7188-9-2-i12" overflow="scroll"><mml:mi>N</mml:mi><mml:msup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo>⌈</mml:mo><mml:mfrac><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>⌉</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> (or <inline-formula><mml:math id="M10" name="1748-7188-9-2-i13" overflow="scroll"><mml:mn>6</mml:mn><mml:mi>N</mml:mi><mml:msup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo>⌈</mml:mo><mml:mfrac><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>⌉</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>) <italic>k</italic>-mers, each taking 2<italic>k</italic> bits of memory. Consequently, we have to adjust the optimal value of <italic>r</italic> minimizing the total space, and re-estimate the resulting space spent on one <italic>k</italic>-mer.</p>
      <p>Table <xref ref-type="table" rid="T1">1</xref> shows estimations for optimal values of <italic>r</italic> and the corresponding space per <italic>k</italic>-mer for <italic>t</italic>=4 and <italic>t</italic>=6, and several values of <italic>k</italic>. The data demonstrates that even such small values of <italic>t</italic> lead to considerable memory savings. It appears that the space per <italic>k</italic>-mer is very close to the optimal space (8.45 bits) obtained for the infinite number of filters. Table <xref ref-type="table" rid="T1">1</xref> reveals another advantage of our improvement: the number of bits per stored <italic>k</italic>-mer remains almost constant for different values of <italic>k</italic>.</p>
      <table-wrap position="float" id="T1">
        <label>Table 1</label>
        <caption>
          <p><bold>1st column: </bold><bold><italic>k </italic></bold><bold>-mer size; 2nd and 4th columns: optimal value of </bold><bold><italic>r </italic></bold><bold> for Bloom filters (bitmap size per number of stored elements) for </bold><bold><italic>t </italic></bold><bold>=4 and </bold><bold><italic>t </italic></bold><bold>=6 respectively; 3rd and 5th columns: the resulting space per </bold><bold><italic>k </italic></bold><bold>-mer (for </bold><bold><italic>t </italic></bold><bold>=4 and </bold><bold><italic>t </italic></bold><bold>=6); 6th column: space per </bold><bold><italic>k </italic></bold><bold>-mer for the method of [</bold>[<xref ref-type="bibr" rid="B9">9</xref>]<bold>] ( </bold><bold><italic>t </italic></bold><bold>=1)</bold></p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col align="left"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th align="center" valign="bottom">
                <bold>
                  <italic>k</italic>
                </bold>
                <hr/>
              </th>
              <th align="center" valign="bottom">
                <bold>Optimal</bold>
                <bold>
                  <italic>r</italic>
                </bold>
                <hr/>
              </th>
              <th align="center" valign="bottom">
                <bold>Bits per </bold>
                <bold>
                  <italic>k </italic>
                </bold>
                <bold>-mer</bold>
                <hr/>
              </th>
              <th align="center" valign="bottom">
                <bold>Optimal</bold>
                <bold>
                  <italic>r</italic>
                </bold>
                <hr/>
              </th>
              <th align="center" valign="bottom">
                <bold>Bits per </bold>
                <bold>
                  <italic>k </italic>
                </bold>
                <bold>-mer</bold>
                <hr/>
              </th>
              <th align="center" valign="bottom">
                <bold>Bits per </bold>
                <bold>
                  <italic>k </italic>
                </bold>
                <bold>-mer</bold>
                <hr/>
              </th>
            </tr>
            <tr>
              <th align="left"> </th>
              <th align="center">
                <bold>for </bold>
                <bold>
                  <italic>t </italic>
                </bold>
                <bold>=4</bold>
              </th>
              <th align="center">
                <bold>for </bold>
                <bold>
                  <italic>t </italic>
                </bold>
                <bold>=4</bold>
              </th>
              <th align="center">
                <bold>for </bold>
                <bold>
                  <italic>t </italic>
                </bold>
                <bold>=6</bold>
              </th>
              <th align="center">
                <bold>for </bold>
                <bold>
                  <italic>t </italic>
                </bold>
                <bold>=6</bold>
              </th>
              <th align="center"><bold>for </bold><bold><italic>t </italic></bold><bold>=1 (</bold>[<xref ref-type="bibr" rid="B9">9</xref>]<bold>)</bold></th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="center" valign="bottom">16<hr/></td>
              <td align="center" valign="bottom">5.777<hr/></td>
              <td align="center" valign="bottom">8.556<hr/></td>
              <td align="center" valign="bottom">5.506<hr/></td>
              <td align="center" valign="bottom">8.459<hr/></td>
              <td align="center" valign="bottom">12.078<hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">32<hr/></td>
              <td align="center" valign="bottom">6.049<hr/></td>
              <td align="center" valign="bottom">8.664<hr/></td>
              <td align="center" valign="bottom">5.556<hr/></td>
              <td align="center" valign="bottom">8.470<hr/></td>
              <td align="center" valign="bottom">13.518<hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">64<hr/></td>
              <td align="center" valign="bottom">6.399<hr/></td>
              <td align="center" valign="bottom">8.824<hr/></td>
              <td align="center" valign="bottom">5.641<hr/></td>
              <td align="center" valign="bottom">8.490<hr/></td>
              <td align="center" valign="bottom">14.958<hr/></td>
            </tr>
            <tr>
              <td align="center">128</td>
              <td align="center">6.819</td>
              <td align="center">9.045</td>
              <td align="center">5.772</td>
              <td align="center">8.524</td>
              <td align="center">16.398</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>The last column of Table <xref ref-type="table" rid="T1">1</xref> shows the memory usage of the original method of [<xref ref-type="bibr" rid="B9">9</xref>], obtained using the estimation <inline-formula><mml:math id="M11" name="1748-7188-9-2-i14" overflow="scroll"><mml:mfenced open="(" close=")"><mml:mrow><mml:mn>1.44</mml:mn><mml:munder><mml:mrow><mml:mo>log</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:munder><mml:mfenced open="(" close=")"><mml:mrow><mml:mfrac><mml:mrow><mml:mn>16</mml:mn><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mn>2.08</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mn>2.08</mml:mn></mml:mrow></mml:mfenced></mml:math></inline-formula> the authors provided. Note that according to that estimation, doubling the value of <italic>k</italic> results in a memory increment by 1.44 bits, whereas in our method the increment is of 0.11 to 0.22 bits.</p>
      <p>Let us now comment on query and preprocessing times for our scheme. The query time can be split into two parts: the time spent on querying <italic>t</italic> Bloom filters and the time spent on querying <italic>T</italic><sub><italic>t</italic></sub>. As stated in Section “Preliminaries”, each query in a Bloom filter corresponds to <italic>p</italic>=<italic>r</italic> ln2 hash functions evaluations. Clearly, the total query time for <italic>t</italic> Bloom filters is <italic>t</italic><italic>p</italic>=<italic>Θ</italic>(<italic>t</italic><italic>r</italic>). Thus, it is expected that using <italic>t</italic> Bloom filters, even if <italic>r</italic> decreases, the query time increases. For instance, with <italic>t</italic>=4 we have that <italic>r</italic>=6.049 (<italic>k</italic>=32) and the total number of hash function evaluations is proportional to <italic>r</italic><italic>t</italic>≈24, whereas with <italic>t</italic>=1 we have that <italic>r</italic>=11.44 and <italic>r</italic><italic>t</italic>≈12, a factor 2 increase in the number of hash function evaluations. On the other hand, the set <italic>T</italic><sub><italic>t</italic></sub> is generally much smaller than <italic>T</italic><sub>1</sub>, due to the above-mentioned exponential decrease. Depending on the data structure for storing <italic>T</italic><sub><italic>t</italic></sub>, the time saving in querying <italic>T</italic><sub><italic>t</italic></sub> vs. <italic>T</italic><sub>1</sub> may even dominate the time loss in querying multiple Bloom filters. Our experimental results (Section “Construction algorithm” below) confirm that this situation does indeed occur in practice. Note that even in the case when querying <italic>T</italic><sub><italic>t</italic></sub> weakly depends on its size (e.g. when <italic>T</italic><sub><italic>t</italic></sub> is implemented by a hash table), the query time will not increase much, due to our choice of a small value for <italic>t</italic>, as discussed earlier.</p>
      <p>At the preprocessing step, we need to construct Bloom filters <italic>B</italic><sub>1</sub>,…,<italic>B</italic><sub><italic>t</italic></sub> and set <italic>T</italic><sub><italic>t</italic></sub>. At each stage <italic>i</italic>, we need to store <italic>T</italic><sub><italic>i</italic>−1</sub> and <italic>T</italic><sub><italic>i</italic>−2</sub> (possibly on disk, if we want to save on the internal memory used by the algorithm) to construct <italic>B</italic><sub><italic>i</italic></sub> and <italic>T</italic><sub><italic>i</italic></sub>. A key observation is that the sizes of <italic>B</italic><sub><italic>i</italic></sub> and <italic>T</italic><sub><italic>i</italic></sub> decrease exponentially on <italic>i</italic> and therefore the time spent to construct the whole structure is a linear function on the size of <italic>T</italic><sub>0</sub>. In particular, asymptotically it is only a small constant factor larger compared to the original method of [<xref ref-type="bibr" rid="B9">9</xref>]. If the value of <italic>t</italic> is small (such as <italic>t</italic>=4, as in Table <xref ref-type="table" rid="T1">1</xref>), the preprocessing time is obviously even smaller.</p>
    </sec>
    <sec>
      <title>Using different values of <italic>r</italic> for different filters</title>
      <p>In the previous section, we assumed that each of our Bloom filters uses the same value of <italic>r</italic>, the ratio of bitmap size to the number of stored <italic>k</italic>-mers. However, formula (3) for the number of bits per <italic>k</italic>-mer shows a difference for odd and even filter indices. This suggests that using different parameters <italic>r</italic> for different filters, rather than the same for all filters, may reduce the space even further. If <italic>r</italic><sub><italic>i</italic></sub> denotes the corresponding ratio for filter <italic>B</italic><sub><italic>i</italic></sub>, then (3) should be rewritten to</p>
      <p>
        <disp-formula id="bmcM4">
          <label>(4)</label>
          <mml:math id="M12" name="1748-7188-9-2-i15" overflow="scroll">
            <mml:msub>
              <mml:mrow>
                <mml:mi>r</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mn>1</mml:mn>
              </mml:mrow>
            </mml:msub>
            <mml:mo>+</mml:mo>
            <mml:mn>6</mml:mn>
            <mml:msub>
              <mml:mrow>
                <mml:mi>r</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mn>2</mml:mn>
              </mml:mrow>
            </mml:msub>
            <mml:msup>
              <mml:mrow>
                <mml:mi>c</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>r</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
            </mml:msup>
            <mml:mo>+</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>r</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mn>3</mml:mn>
              </mml:mrow>
            </mml:msub>
            <mml:msup>
              <mml:mrow>
                <mml:mi>c</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>r</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>2</mml:mn>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
            </mml:msup>
            <mml:mo>+</mml:mo>
            <mml:mn>6</mml:mn>
            <mml:msub>
              <mml:mrow>
                <mml:mi>r</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mn>4</mml:mn>
              </mml:mrow>
            </mml:msub>
            <mml:msup>
              <mml:mrow>
                <mml:mi>c</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>r</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>+</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>r</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>3</mml:mn>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
            </mml:msup>
            <mml:mo>+</mml:mo>
            <mml:mo>…</mml:mo>
            <mml:mo>,</mml:mo>
          </mml:math>
        </disp-formula>
      </p>
      <p>and the minimum value of this expression becomes 7.93 (this value is achieved with <italic>r</italic><sub>1</sub>=4.41;<italic>r</italic><sub><italic>i</italic></sub>=1.44,<italic>i</italic>&gt;1).</p>
      <p>In the same way, we can use different values of <italic>r</italic><sub><italic>i</italic></sub> in the truncated case. This leads to a small 2% to 4% improvement in comparison with the case of unique value of <italic>r</italic>. Table <xref ref-type="table" rid="T2">2</xref> shows results for the case <italic>t</italic>=4 for different values of <italic>k</italic>.</p>
      <table-wrap position="float" id="T2">
        <label>Table 2</label>
        <caption>
          <p>
            <bold>Estimated memory occupation for the case of different values of </bold>
            <bold>
              <italic>r </italic>
            </bold>
            <bold> vs. single value of </bold>
            <bold>
              <italic>r </italic>
            </bold>
            <bold> (shown in Table 1), for 4 Bloom filters ( </bold>
            <bold>
              <italic>t </italic>
            </bold>
            <bold>=4)</bold>
          </p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col align="left"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th align="center" valign="bottom">
                <bold>
                  <italic>k</italic>
                </bold>
                <hr/>
              </th>
              <th align="center" valign="bottom">
                <bold>Optimal</bold>
                <bold>
                  <italic>r</italic>
                </bold>
                <sub>
                  <bold>1</bold>
                </sub>
                <bold>,</bold>
                <bold>
                  <italic>r</italic>
                </bold>
                <sub>
                  <bold>2</bold>
                </sub>
                <bold>,</bold>
                <bold>
                  <italic>r</italic>
                </bold>
                <sub>
                  <bold>3</bold>
                </sub>
                <bold>,</bold>
                <bold>
                  <italic>r</italic>
                </bold>
                <sub>
                  <bold>4</bold>
                </sub>
                <hr/>
              </th>
              <th align="center" valign="bottom">
                <bold>Bits per </bold>
                <bold>
                  <italic>k </italic>
                </bold>
                <bold>-mer</bold>
                <hr/>
              </th>
              <th align="center" valign="bottom">
                <bold>Bits per </bold>
                <bold>
                  <italic>k </italic>
                </bold>
                <bold>-mer</bold>
                <hr/>
              </th>
            </tr>
            <tr>
              <th align="left"> </th>
              <th align="left"> </th>
              <th align="center">
                <bold>different values of</bold>
                <bold>
                  <italic>r</italic>
                </bold>
              </th>
              <th align="center">
                <bold>single value of</bold>
                <bold>
                  <italic>r</italic>
                </bold>
              </th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="center" valign="bottom">16<hr/></td>
              <td align="center" valign="bottom">5.254, 3.541, 4.981, 8.653<hr/></td>
              <td align="center" valign="bottom">8.336<hr/></td>
              <td align="center" valign="bottom">8.556<hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">32<hr/></td>
              <td align="center" valign="bottom">5.383, 3.899, 5.318, 9.108<hr/></td>
              <td align="center" valign="bottom">8.404<hr/></td>
              <td align="center" valign="bottom">8.664<hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">64<hr/></td>
              <td align="center" valign="bottom">5.572, 4.452, 5.681, 9.108<hr/></td>
              <td align="center" valign="bottom">8.512<hr/></td>
              <td align="center" valign="bottom">8.824<hr/></td>
            </tr>
            <tr>
              <td align="center">128</td>
              <td align="center">5.786, 5.108, 6.109, 9.109</td>
              <td align="center">8.669</td>
              <td align="center">9.045</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
    <sec>
      <title>Query distribution among filters</title>
      <p>The query algorithm of Lemma 1 simply queries Bloom filters <italic>B</italic><sub>1</sub>,…,<italic>B</italic><sub><italic>t</italic></sub> successively as long as the returned answer is positive. The query time then directly depends on the number of filters applied before getting a negative answer. Therefore, it is instructive to analyse how the query frequencies to different filters are distributed when performing a graph traversal. We provide such an analysis in this section.</p>
      <p>We analyse query frequencies during an exhaustive traversal of the de Bruijn graph, when each true node is visited exactly once. We assume that each time a true node is visited, all its eight potential neighbors are queried, as there is no other way to tell which of those neighbors are real. Note however that this assumption does not take into account structural properties of the de Bruijn graph, nor any additional statistical properties of the genome (such as genomic word frequencies).</p>
      <p>For a filter <italic>B</italic><sub><italic>i</italic></sub>, we want to estimate the number of queried <italic>k</italic>-mers resolved by <italic>B</italic><sub><italic>i</italic></sub> during the traversal, that is queries on which <italic>B</italic><sub><italic>i</italic></sub> returns <italic>no</italic>. This number is the difference of the number of queries submitted to <italic>B</italic><sub><italic>i</italic></sub> and the number of queries for which <italic>B</italic><sub><italic>i</italic></sub> returns <italic>yes</italic>. Note that the queries submitted to <italic>B</italic><sub><italic>i</italic></sub> are precisely those on which the previous filter <italic>B</italic><sub><italic>i</italic>−1</sub> returns <italic>yes</italic>.</p>
      <p>If the input set <italic>T</italic><sub>0</sub> contains <italic>N</italic><italic>k</italic>-mers, then the number of queries in a graph traversal is 8<italic>N</italic>, since for each true node each of its 8 potential neighbors are queried. Moreover, about 2<italic>N</italic> queries correspond to true <italic>k</italic>-mers, as we assume that most of the graph nodes have two true neighbors. Filter <italic>B</italic><sub>1</sub> will return <italic>yes</italic> on 2<italic>N</italic>+6<italic>c</italic><sup><italic>r</italic></sup><italic>N</italic> queries, corresponding to the number of true and false positives respectively. For an arbitrary <italic>i</italic>, filter <italic>B</italic><sub><italic>i</italic></sub> returns <italic>yes</italic> precisely on the <italic>k</italic>-mers inserted to <italic>B</italic><sub><italic>i</italic></sub> (i.e. <italic>k</italic>-mers <italic>B</italic><sub><italic>i</italic></sub> is built on), and the <italic>k</italic>-mers which are inserted to <italic>B</italic><sub><italic>i</italic>+1</sub> (which are the critical false positives for <italic>B</italic><sub><italic>i</italic></sub>). The counts then easily follow from the analysis of Section “Memory and time usage”.</p>
      <p>Table <xref ref-type="table" rid="T3">3</xref> provides counts for the first four filters, together with the estimated fraction of <italic>k</italic>-mers resolved by each filter (last row), for the case of infinite number of filters. The data shows that 99.48<italic>%</italic> of all <italic>k</italic>-mers are resolved by four filters, which suggests that a very small number of filters is sufficient to cover a vast majority of <italic>k</italic>-mers. Furthermore, Table <xref ref-type="table" rid="T4">4</xref> shows data for 1-, 2- and 4-filter setups, this time with the optimal value of <italic>r</italic> for each case. Even two filters are already sufficient to reduce the accesses to <italic>T</italic><sub>2</sub> to 2.08<italic>%</italic>. In case of four filters, 99.7<italic>%</italic> of <italic>k</italic>-mers are resolved before accessing <italic>T</italic><sub>4</sub>.</p>
      <table-wrap position="float" id="T3">
        <label>Table 3</label>
        <caption>
          <p>
            <bold>Estimations of the number of queries made to filters</bold>
            <bold>
              <italic>B</italic>
            </bold>
            <sub>
              <bold>1</bold>
            </sub>
            <bold>,</bold>
            <bold>
              <italic>B</italic>
            </bold>
            <sub>
              <bold>2</bold>
            </sub>
            <bold>,</bold>
            <bold>
              <italic>B</italic>
            </bold>
            <sub>
              <bold>3</bold>
            </sub>
            <bold>,</bold>
            <bold>
              <italic>B</italic>
            </bold>
            <sub>
              <bold>4</bold>
            </sub>
            <bold> and of the fraction of queries resolved by each filter (for the optimal value </bold>
            <bold>
              <italic>r </italic>
            </bold>
            <bold>=5 </bold>
            <bold>
              <italic>. </italic>
            </bold>
            <bold>464), in the case of infinite number of filters</bold>
          </p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col align="left"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th align="left"> </th>
              <th align="center">
                <bold>
                  <italic>B</italic>
                </bold>
                <sub>
                  <bold>1</bold>
                </sub>
              </th>
              <th align="center">
                <bold>
                  <italic>B</italic>
                </bold>
                <sub>
                  <bold>2</bold>
                </sub>
              </th>
              <th align="center">
                <bold>
                  <italic>B</italic>
                </bold>
                <sub>
                  <bold>3</bold>
                </sub>
              </th>
              <th align="center">
                <bold>
                  <italic>B</italic>
                </bold>
                <sub>
                  <bold>4</bold>
                </sub>
              </th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="center" valign="bottom">nb of queries<hr/></td>
              <td align="center" valign="bottom">8<italic>N</italic><hr/></td>
              <td align="center" valign="bottom">(2+6<italic>c</italic><sup><italic>r</italic></sup>)<italic>N</italic><hr/></td>
              <td align="center" valign="bottom">(6<italic>c</italic><sup><italic>r</italic></sup>+2<italic>c</italic><sup><italic>r</italic></sup>)<italic>N</italic><hr/></td>
              <td align="center" valign="bottom">(2<italic>c</italic><sup><italic>r</italic></sup>+6<italic>c</italic><sup>2<italic>r</italic></sup>)<italic>N</italic><hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">Queries returning <italic>yes</italic><hr/></td>
              <td align="center" valign="bottom">(2+6<italic>c</italic><sup><italic>r</italic></sup>)<italic>N</italic><hr/></td>
              <td align="center" valign="bottom">(6<italic>c</italic><sup><italic>r</italic></sup>+2<italic>c</italic><sup><italic>r</italic></sup>)<italic>N</italic><hr/></td>
              <td align="center" valign="bottom">(2<italic>c</italic><sup><italic>r</italic></sup>+6<italic>c</italic><sup>2<italic>r</italic></sup>)<italic>N</italic><hr/></td>
              <td align="center" valign="bottom">(6<italic>c</italic><sup>2<italic>r</italic></sup>+2<italic>c</italic><sup>2<italic>r</italic></sup>)<italic>N</italic><hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">Queries returning <italic>no</italic><hr/></td>
              <td align="center" valign="bottom">(6−6<italic>c</italic><sup><italic>r</italic></sup>)<italic>N</italic><hr/></td>
              <td align="center" valign="bottom">(2−2<italic>c</italic><sup><italic>r</italic></sup>)<italic>N</italic><hr/></td>
              <td align="center" valign="bottom">(6<italic>c</italic><sup><italic>r</italic></sup>−6<italic>c</italic><sup>2<italic>r</italic></sup>)<italic>N</italic><hr/></td>
              <td align="center" valign="bottom">(2<italic>c</italic><sup><italic>r</italic></sup>−2<italic>c</italic><sup>2<italic>r</italic></sup>)<italic>N</italic><hr/></td>
            </tr>
            <tr>
              <td align="center">Fraction of resolved queries</td>
              <td align="center">69.57<italic>%</italic></td>
              <td align="center">23.19<italic>%</italic></td>
              <td align="center">5.04<italic>%</italic></td>
              <td align="center">1.68<italic>%</italic></td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <table-wrap position="float" id="T4">
        <label>Table 4</label>
        <caption>
          <p>
            <bold>Estimated fractions of queries resolved by each filter and by the explicitely stored set</bold>
            <bold>
              <italic>T</italic>
            </bold>
            <sub>
              <bold>
                <italic>t</italic>
              </bold>
            </sub>
            <bold> for </bold>
            <bold>
              <italic>t </italic>
            </bold>
            <bold>=1,2,4, computed for </bold>
            <bold>
              <italic>k </italic>
            </bold>
            <bold>=32 and optimal value of </bold>
            <bold>
              <italic>r </italic>
            </bold>
            <bold> shown in the second column</bold>
          </p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col align="left"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th align="center">
                <bold>Value of</bold>
                <bold>
                  <italic>t</italic>
                </bold>
              </th>
              <th align="center">
                <bold>
                  <italic>r</italic>
                </bold>
              </th>
              <th align="center">
                <bold>
                  <italic>B</italic>
                </bold>
                <sub>
                  <bold>1</bold>
                </sub>
              </th>
              <th align="center">
                <bold>
                  <italic>B</italic>
                </bold>
                <sub>
                  <bold>2</bold>
                </sub>
              </th>
              <th align="center">
                <bold>
                  <italic>B</italic>
                </bold>
                <sub>
                  <bold>3</bold>
                </sub>
              </th>
              <th align="center">
                <bold>
                  <italic>B</italic>
                </bold>
                <sub>
                  <bold>4</bold>
                </sub>
              </th>
              <th align="center">
                <bold>
                  <italic>T</italic>
                </bold>
                <sub>
                  <bold>
                    <italic>t</italic>
                  </bold>
                </sub>
              </th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="center" valign="bottom">1<hr/></td>
              <td align="center" valign="bottom">11.44<hr/></td>
              <td align="center" valign="bottom">74.70<italic>%</italic><hr/></td>
              <td align="center" valign="bottom">0<hr/></td>
              <td align="center" valign="bottom">0<hr/></td>
              <td align="center" valign="bottom">0<hr/></td>
              <td align="center" valign="bottom">25.3<italic>%</italic><hr/></td>
            </tr>
            <tr>
              <td align="center" valign="bottom">2<hr/></td>
              <td align="center" valign="bottom">8.060<hr/></td>
              <td align="center" valign="bottom">73.44<italic>%</italic><hr/></td>
              <td align="center" valign="bottom">24.48<italic>%</italic><hr/></td>
              <td align="center" valign="bottom">0<hr/></td>
              <td align="center" valign="bottom">0<hr/></td>
              <td align="center" valign="bottom">2.08<italic>%</italic><hr/></td>
            </tr>
            <tr>
              <td align="center">4</td>
              <td align="center">6.049</td>
              <td align="center">70.90<italic>%</italic></td>
              <td align="center">23.63<italic>%</italic></td>
              <td align="center">3.88<italic>%</italic></td>
              <td align="center">1.29<italic>%</italic></td>
              <td align="center">0.3<italic>%</italic></td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
  </sec>
  <sec>
    <title>Experimental results</title>
    <sec>
      <title>Construction algorithm</title>
      <p>In practice, constructing a cascading Bloom filter for a real-life read set is a computationally intensive step. To perform it on a commonly-used computer, the implementation makes an essential use of external memory. Here we give a short description of the construction algorithm for up to four Bloom filters. Extension for larger number of filters is straightforward.</p>
      <p>We start from the input set <italic>T</italic><sub>0</sub> of <italic>k</italic>-mers written on disk. In this set, for each pair of <italic>k</italic>-mer and its reverse complement we keep only one of them, the lexicographically smaller, and identify the other to it. We build the Bloom filter <italic>B</italic><sub>1</sub> of appropriate size by inserting elements of <italic>T</italic><sub>0</sub> successively. Next, all possible extensions of each <italic>k</italic>-mer in <italic>T</italic><sub>0</sub> are queried against <italic>B</italic><sub>1</sub>, and those which return true are written to the disk. Then, in this set only the <italic>k</italic>-mers absent from <italic>T</italic><sub>0</sub> are kept, i.e. we perform a set difference from <italic>T</italic><sub>0</sub>. We cannot afford to load <italic>T</italic><sub>0</sub> entirely in memory, so we partition <italic>T</italic><sub>0</sub> and perform the set difference in several iterations, loading only one partition of <italic>T</italic><sub>0</sub> each time. This results in the set <italic>T</italic><sub>1</sub> of critical false positives, which is also kept on disk. Up to this point, the procedure is identical to that of [<xref ref-type="bibr" rid="B9">9</xref>].</p>
      <p>Next, we insert all <italic>k</italic>-mers from <italic>T</italic><sub>1</sub> into <italic>B</italic><sub>2</sub> and to obtain <italic>T</italic><sub>2</sub>, we check for each <italic>k</italic>-mer in <italic>T</italic><sub>0</sub> if a query to <italic>B</italic><sub>2</sub> returns true. This results in the set <italic>T</italic><sub>2</sub>, which is directly stored on disk. Thus, at this point we have <italic>B</italic><sub>1</sub>, <italic>B</italic><sub>2</sub> and, by loading <italic>T</italic><sub>2</sub> from the disk, a complete representation for <italic>t</italic>=2. In order to build the data structure for <italic>t</italic>=4, we continue this process, by inserting <italic>T</italic><sub>2</sub> in <italic>B</italic><sub>3</sub> and retrieving (and writing directly on disk) <italic>T</italic><sub>3</sub> from <italic>T</italic><sub>1</sub> (stored on disk). It should be noted that to obtain <italic>T</italic><sub><italic>i</italic></sub> we need <italic>T</italic><sub><italic>i</italic>−2</sub>, and by always directly storing it on disk we guarantee not to use more memory than the size of the final structure. The set <italic>T</italic><sub><italic>t</italic></sub> (that is, <italic>T</italic><sub>1</sub>, <italic>T</italic><sub>2</sub> or <italic>T</italic><sub>4</sub> in our experiments) is represented as a sorted array and is searched by a binary search. We found this implementation more efficient than a hash table.</p>
    </sec>
    <sec>
      <title>Implementation and experimental setup</title>
      <p>We implemented our method using <sc>MINIA</sc> software [<xref ref-type="bibr" rid="B9">9</xref>] and ran comparative tests for 2 and 4 Bloom filters (<italic>t</italic>=2,4). Note that since the only modified part of <sc>MINIA</sc> was the construction step and the <italic>k</italic>-mer membership queries, this allows us to precisely evaluate our method against the one of [<xref ref-type="bibr" rid="B9">9</xref>].</p>
      <p>The first step of the implementation is to retrieve the list of <italic>k</italic>-mers that appear more than <italic>d</italic> times using DSK [<xref ref-type="bibr" rid="B13">13</xref>] – a constant memory streaming algorithm to count <italic>k</italic>-mers. Note, as a side remark, that performing counting allows us to perform off-line deletions of <italic>k</italic>-mers. That is, if at some point of the scan of the input set of <italic>k</italic>-mers (or reads) some of them should be deleted, it is done by a simple decrement of the counter.</p>
      <p>Assessing the query time is done through the procedure of graph traversal, as it is implemented in [<xref ref-type="bibr" rid="B9">9</xref>]. Since the procedure is identical and independent on the data structure, the time spent on graph traversal is a faithful estimator of the query time.</p>
      <p>We compare three versions: <italic>t</italic>=1 (i.e. the version of [<xref ref-type="bibr" rid="B9">9</xref>]), <italic>t</italic>=2 and <italic>t</italic>=4. For convenience, we define 1 Bloom, 2 Bloom and 4 Bloom as the versions with <italic>t</italic>=1,2 and 4, respectively.</p>
    </sec>
    <sec>
      <title><italic>E.coli</italic> dataset, varying <italic>k</italic></title>
      <p>In this set of tests, our main goal was to evaluate the influence of the <italic>k</italic>-mer size on principal parameters: size of the whole data structure, size of the set <italic>T</italic><sub><italic>t</italic></sub>, graph traversal time, and time of construction of the data structure. We retrieved 10M <italic>E. coli</italic> reads of 100bp from the <italic>Short Read Archive</italic> (ERX008638) without read pairing information and extracted all <italic>k</italic>-mers occurring at least two times. The total number of <italic>k</italic>-mers considered varied, depending on the value of <italic>k</italic>, from 6,967,781 (<italic>k</italic>=15) to 5,923,501 (<italic>k</italic>=63). We ran each version, 1 Bloom [<xref ref-type="bibr" rid="B9">9</xref>], 2 Bloom and 4 Bloom, for values of <italic>k</italic> ranging from 16 to 64. The results are shown in Figure <xref ref-type="fig" rid="F1">1</xref>.</p>
      <fig id="F1" position="float">
        <label>Figure 1</label>
        <caption>
          <p><bold>Results for 10M E.coli reads of 100bp using several values of</bold><bold><italic>k</italic></bold><bold>.</bold> The <italic>1 Bloom</italic> version corresponds to the one presented in [<xref ref-type="bibr" rid="B9">9</xref>]. <bold>(a)</bold> Size of the structure in bits used per <italic>k</italic>-mer stored. <bold>(b)</bold> Number of false positives stored in <italic>T</italic><sub>1</sub>, <italic>T</italic><sub>2</sub> or <italic>T</italic><sub>4</sub> for 1, 2 or 4 Bloom filters, respectively. <bold>(c)</bold> De Bruijn graph traversal time, including branching <italic>k</italic>-mer indexing. <bold>(d)</bold> De Bruijn graph construction time, excluding <italic>k</italic>-mer counting step.</p>
        </caption>
        <graphic xlink:href="1748-7188-9-2-1"/>
      </fig>
      <p>The total size of the structures in bits per stored <italic>k</italic>-mer, i.e. the size of <italic>B</italic><sub>1</sub> and <italic>T</italic><sub>1</sub> (respectively, <italic>B</italic><sub>1</sub>,<italic>B</italic><sub>2</sub>, <italic>T</italic><sub>2</sub> or <italic>B</italic><sub>1</sub>,<italic>B</italic><sub>2</sub>,<italic>B</italic><sub>3</sub>,<italic>B</italic><sub>4</sub>, <italic>T</italic><sub>4</sub>) is shown in Figure <xref ref-type="fig" rid="F1">1</xref>(a). As expected, the space for 4 Bloom filters is the smallest for all values of <italic>k</italic> considered, showing a considerable improvement, ranging from 32% to 39%, over the version of [<xref ref-type="bibr" rid="B9">9</xref>]. Even the version with just 2 Bloom filters shows an improvement of at least 20% over [<xref ref-type="bibr" rid="B9">9</xref>], for all values of <italic>k</italic>. Regarding the influence of the <italic>k</italic>-mer size on the structure size, we observe that for 4 Bloom filters the structure size is almost constant, the minimum value is 8.60 and the largest is 8.89, an increase of only 3%. For 1 and 2 Bloom the same pattern is seen: a plateau from <italic>k</italic>=16 to 32, a jump for <italic>k</italic>=33 and another plateau from <italic>k</italic>=33 to 64. The jump at <italic>k</italic>=32 is due to switching from 64-bit to 128-bit representation of <italic>k</italic>-mers in the table <italic>T</italic><sub><italic>t</italic></sub>.</p>
      <p>Figure <xref ref-type="fig" rid="F1">1</xref>(b) shows the size of table <italic>T</italic><sub><italic>t</italic></sub> (number of <italic>k</italic>-mers) for <italic>t</italic>=1,2,4, depending on <italic>k</italic>. It clearly demonstrates the sharp decrease of the size of <italic>T</italic><sub><italic>t</italic></sub> with growing <italic>t</italic>, in accordance with the exponential decrease estimated analytically in Section “Memory and time usage”. We also observe a decrease in the size of <italic>T</italic><sub><italic>t</italic></sub> with growing <italic>k</italic> for <italic>t</italic>=1 and, to a smaller extent, for <italic>t</italic>=2, while for <italic>t</italic>=4 the decrease is not noticeable. This is explained by the increase rate of optimal <italic>r</italic> (Table <xref ref-type="table" rid="T1">1</xref>) which is high for <italic>t</italic>=1, smaller for <italic>t</italic>=2 and yet smaller for <italic>t</italic>=4. Since the size of <italic>T</italic><sub><italic>t</italic></sub> is <italic>O</italic>(<italic>N</italic><italic>c</italic><sup><italic>t</italic><italic>r</italic>/2</sup>) (Section “Memory and time usage”) for <italic>c</italic>&lt;1 and almost invariable <italic>N</italic>, the decrease rate is exponential w.r.t. the increase rate of <italic>r</italic>.</p>
      <p>Traversal times for each version are shown in Figure <xref ref-type="fig" rid="F1">1</xref>(c). The fastest version is 4 Bloom, showing an improvement over [<xref ref-type="bibr" rid="B9">9</xref>] of 18% to 30%, followed by 2 Bloom. This result is surprising and may seem counter-intuitive, as we have four filters to apply to the queried <italic>k</italic>-mer rather than a single filter as in [<xref ref-type="bibr" rid="B9">9</xref>]. However, the size of <italic>T</italic><sub>4</sub> (or even <italic>T</italic><sub>2</sub>) is much smaller than <italic>T</italic><sub>1</sub>, as the size of <italic>T</italic><sub><italic>i</italic></sub>’s decreases exponentially. As <italic>T</italic><sub><italic>t</italic></sub> is stored in an array, the time economy in searching <italic>T</italic><sub>4</sub> (or <italic>T</italic><sub>2</sub>) compared to <italic>T</italic><sub>1</sub> dominates the time lost on querying additional Bloom filters, which explains the overall gain in query time.</p>
      <p>As far as the construction time is concerned (Figure <xref ref-type="fig" rid="F1">1</xref>(d)), our versions yielded also a faster construction, with the 4 Bloom version being 5% to 22% faster than that of [<xref ref-type="bibr" rid="B9">9</xref>]. The gain is explained by the time required for sorting the array storing <italic>T</italic><sub><italic>t</italic></sub>, which is much higher for <italic>T</italic><sub>0</sub> than for <italic>T</italic><sub>2</sub> or <italic>T</italic><sub>4</sub>. However, the gain is less significant here, and, on the other hand, was not observed for bigger datasets (see Section “Human dataset”).</p>
    </sec>
    <sec>
      <title><italic>E. coli</italic> dataset, varying coverage</title>
      <p>From the complete <italic>E. coli</italic> dataset (≈44M reads) from the previous section, we selected several samples ranging from 5M to 40M reads in order to assess the impact of the coverage on the size of the data structures. This strain <italic>E. coli</italic> (K-12 MG1655) is estimated to have a genome of 4.6M bp [<xref ref-type="bibr" rid="B14">14</xref>], implying that a sample of 5M reads (of 100bp) corresponds to ≈100X coverage. We set <italic>d</italic>=3 and <italic>k</italic>=27. The results are shown in Figure <xref ref-type="fig" rid="F2">2</xref>. As expected, the memory consumption per <italic>k</italic>-mer remains almost constant for increasing coverage, with a slight decrease for 2 and 4 Bloom. The best results are obtained with the 4 Bloom version, an improvement of 33% over the 1 Bloom version of [<xref ref-type="bibr" rid="B9">9</xref>]. On the other hand, the number of distinct <italic>k</italic>-mers increases markedly (around 10% for each 5M reads) with increasing coverage, see Figure <xref ref-type="fig" rid="F2">2</xref>(b). This is due to sequencing errors: an increase in coverage implies more errors with higher coverage, which are not removed by our cutoff <italic>d</italic>=3. This suggests that the value of <italic>d</italic> should be chosen according to the coverage of the sample. Moreover, in the case where read qualities are available, a quality control pre-processing step may help to reduce the number of sequencing errors.</p>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p><bold>Results for</bold><bold><italic>E.coli</italic></bold><bold> reads of 100bp using</bold><bold><italic>k</italic></bold><bold>=27.</bold> The <italic>1 Bloom</italic> version corresponds to the one presented in [<xref ref-type="bibr" rid="B9">9</xref>]. <bold>(a)</bold> Size of the structure in bits used per <italic>k</italic>-mer stored. <bold>(b)</bold> Number of distinct <italic>k</italic>-mers.</p>
        </caption>
        <graphic xlink:href="1748-7188-9-2-2"/>
      </fig>
    </sec>
    <sec>
      <title><italic>E. coli</italic> dataset, query statistics</title>
      <p>In this set of tests we used the dataset of Section “<italic>E.coli</italic> dataset, varying <italic>k</italic>” to experimentally evaluate how the queries are distributed among the Bloom filters. We ran the graph traversal algorithm for each version, 1 Bloom [<xref ref-type="bibr" rid="B9">9</xref>], 2 Bloom and 4 Bloom, using values of <italic>k</italic> ranging from 16 to 64 and retrieved the number of queries resolved in each Bloom filter and the table <italic>T</italic><sub><italic>t</italic></sub>. The results are shown in Figure <xref ref-type="fig" rid="F3">3</xref>. The plots indicate that, for each version, the query distribution among the Bloom filters is approximately invariant to the value of <italic>k</italic>. Indeed, on average 74%, 73% and 70% of the queries are resolved in <italic>B</italic><sub>1</sub> for the 1, 2 and 4 Bloom version, respectively, and the variance is smaller than 0.01% in each case. For the 4 Bloom version, 70%, 24%, 4%, 1% and 0.2% of the queries are resolved in <italic>B</italic><sub>1</sub>, <italic>B</italic><sub>2</sub>, <italic>B</italic><sub>3</sub>, <italic>B</italic><sub>4</sub> and <italic>T</italic><sub>4</sub>, respectively, showing that the values estimated theoretically in Section “Query distribution among filters” (the last row of Table <xref ref-type="table" rid="T4">4</xref>) are very precise. Furthermore, as a query to a Bloom filter is faster than to <italic>T</italic><sub>1</sub> and the majority of the queries to 4 and 2 Bloom versions, 94% and 95% respectively, are resolved in the first two filters, it is natural that on average queries to 1 Bloom version are slower than to 2 and 4 Bloom versions, corroborating the results of Section “<italic>E.coli</italic> dataset, varying <italic>k</italic>”.</p>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p><bold>Query statistics results for 10M E.coli reads of 100bp using several values of</bold><bold><italic>k</italic></bold><bold>.</bold> The <italic>1 Bloom</italic> version corresponds to the one presented in [<xref ref-type="bibr" rid="B9">9</xref>]. <bold>(a)</bold> Total number of queries performed, for each value of <italic>k</italic>, during a graph traversal. <bold>(b)</bold> Fraction of resolved queries in <italic>B</italic><sub>1</sub> and <italic>T</italic><sub>1</sub> (1 Bloom version) for each value of <italic>k</italic>. <bold>(c)</bold> Fraction of resolved queries in <italic>B</italic><sub>1</sub>, <italic>B</italic><sub>2</sub> and <italic>T</italic><sub>2</sub> (2 Bloom version) for each value of <italic>k</italic>. <bold>(d)</bold> Fraction of resolved queries in <italic>B</italic><sub>1</sub>, <italic>B</italic><sub>2</sub>, <italic>B</italic><sub>3</sub>, <italic>B</italic><sub>4</sub> and <italic>T</italic><sub>4</sub> for each value of <italic>k</italic>.</p>
        </caption>
        <graphic xlink:href="1748-7188-9-2-3"/>
      </fig>
    </sec>
    <sec>
      <title>Human dataset</title>
      <p>We also compared 2 and 4 Bloom versions with the 1 Bloom version of [<xref ref-type="bibr" rid="B9">9</xref>] on a large dataset. For that, we retrieved 564M Human reads of 100bp (SRA: SRX016231) without pairing information and discarded the reads occurring less than 3 times. The dataset corresponds to ≈17X coverage. A total of 2,455,753,508 <italic>k</italic>-mers were indexed. We ran each version, 1 Bloom [<xref ref-type="bibr" rid="B9">9</xref>], 2 Bloom and 4 Bloom with <italic>k</italic> = 23. The results are shown in Table <xref ref-type="table" rid="T5">5</xref>.</p>
      <table-wrap position="float" id="T5">
        <label>Table 5</label>
        <caption>
          <p>
            <bold>Results of 1, 2 and 4 Bloom filters version for 564M Human reads of 100 bp using </bold>
            <bold>
              <italic>k </italic>
            </bold>
            <bold>=23</bold>
          </p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col align="left"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th align="left">
                <bold>Method</bold>
              </th>
              <th align="left"><bold>1 Bloom </bold>[<xref ref-type="bibr" rid="B9">9</xref>]</th>
              <th align="left">
                <bold>2 Bloom</bold>
              </th>
              <th align="left">
                <bold>4 Bloom</bold>
              </th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="left" valign="bottom">Construction time (s)<hr/></td>
              <td align="left" valign="bottom">40160.7<hr/></td>
              <td align="left" valign="bottom">43362.8<hr/></td>
              <td align="left" valign="bottom">44300.7<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">Traversal time (s)<hr/></td>
              <td align="left" valign="bottom">46596.5<hr/></td>
              <td align="left" valign="bottom">35909.3<hr/></td>
              <td align="left" valign="bottom">34177.2<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom"><italic>r</italic> coefficient<hr/></td>
              <td align="left" valign="bottom">11.10<hr/></td>
              <td align="left" valign="bottom">7.80<hr/></td>
              <td align="left" valign="bottom">5.97<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="left" valign="bottom"><italic>B</italic><sub>1</sub>=3250.95<hr/></td>
              <td align="left" valign="bottom"><italic>B</italic><sub>1</sub>=2283.64<hr/></td>
              <td align="left" valign="bottom"><italic>B</italic><sub>1</sub>=1749.04<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="left" valign="bottom"><italic>B</italic><sub>2</sub>=323.08<hr/></td>
              <td align="left" valign="bottom"><italic>B</italic><sub>2</sub>=591.57<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">Bloom filters size (MB)<hr/></td>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="left" valign="bottom"><italic>B</italic><sub>3</sub>=100.56<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="left" valign="bottom"><italic>B</italic><sub>4</sub>=34.01<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">False positive table<hr/></td>
              <td align="left" valign="bottom"><italic>T</italic><sub>1</sub>=545.94<hr/></td>
              <td align="left" valign="bottom"><italic>T</italic><sub>2</sub>=425.74<hr/></td>
              <td align="left" valign="bottom"><italic>T</italic><sub>4</sub>=36.62<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">size (MB)<hr/></td>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="left" valign="bottom"> <hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">Total size (MB)<hr/></td>
              <td align="left" valign="bottom">3796.89<hr/></td>
              <td align="left" valign="bottom">3032.46<hr/></td>
              <td align="left" valign="bottom">2511.8<hr/></td>
            </tr>
            <tr>
              <td align="left">
                <bold>Size (bits/ </bold>
                <bold>
                  <italic>k </italic>
                </bold>
                <bold>-mer)</bold>
              </td>
              <td align="left">
                <bold>12.96</bold>
              </td>
              <td align="left">
                <bold>10.35</bold>
              </td>
              <td align="left">
                <bold>8.58</bold>
              </td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>The results are in general consistent with the previous tests on <italic>E.coli</italic> datasets. There is an improvement of 34% (21%) for the 4 Bloom (2 Bloom) in the size of the structure. The graph traversal is also 26% faster in the 4 Bloom version. However, in contrast to the previous results, the graph construction time increased by 10% and 7% for 4 and 2 Bloom versions respectively, when compared to the 1 Bloom version. This is due to the fact that disk writing/reading operations now dominate the time for the graph construction, and 2 and 4 Bloom versions generate more disk accesses than 1 Bloom. As stated in Section “Construction algorithm”, when constructing the 1 Bloom structure, the only part written on the disk is <italic>T</italic><sub>1</sub> and it is read only once to fill an array in memory. For 4 Bloom, <italic>T</italic><sub>1</sub> and <italic>T</italic><sub>2</sub> are written to the disk, and <italic>T</italic><sub>0</sub> and <italic>T</italic><sub>1</sub> are read at least one time each to build <italic>B</italic><sub>2</sub> and <italic>B</italic><sub>3</sub>. Moreover, since the size coefficient of <italic>B</italic><sub>1</sub> reduces, from <italic>r</italic>=11.10 in 1 Bloom to <italic>r</italic>=5.97 in 4 Bloom, the number of false positives in <italic>T</italic><sub>1</sub> increases.</p>
    </sec>
  </sec>
  <sec>
    <title>Discussion and conclusions</title>
    <p>Using cascading Bloom filters for storing de Bruijn graphs has clear advantages over the single-filter method of [<xref ref-type="bibr" rid="B9">9</xref>]. In terms of memory consumption, which is the main parameter here, we obtained an improvement of around 30%-40% in all our experiments. Our data structure takes 8.5 to 9 bits per stored <italic>k</italic>-mer, compared to 13 to 15 bits by the method of [<xref ref-type="bibr" rid="B9">9</xref>]. This confirms our analytical estimations. The above results were obtained using only four filters and are very close to the estimated optimum (around 8.4 bits/<italic>k</italic>-mer) produced by the infinite number of filters. This is consistent with both our analytical estimations and experimental data showing that over 99% of queries are resolved by the four filters, without resorting to the explicitely stored set <italic>T</italic><sub><italic>t</italic></sub>. Even two filters only resolve about 95% of queries. An interesting characteristic of our method is that the memory grows insignificantly with the growth of <italic>k</italic>, even slower than with the method of [<xref ref-type="bibr" rid="B9">9</xref>]. Somewhat surprisingly, we also obtained a significant decrease, of order 20%-30%, of query time. The construction time of the data structure varied from being 10% slower (for the human dataset) to 22% faster (for the bacterial dataset). Cascading Bloom filters have now been implemented by default in the <sc>MINIA</sc> software [<xref ref-type="bibr" rid="B15">15</xref>].</p>
    <p>As stated previously, another compact encoding of de Bruijn graphs has been proposed in [<xref ref-type="bibr" rid="B10">10</xref>], however no implementation of the method was made available. For this reason, we could not experimentally compare our method with the one of [<xref ref-type="bibr" rid="B10">10</xref>]. We remark, however, that the space bound of [<xref ref-type="bibr" rid="B10">10</xref>] heavily depends on the number of reads (i.e. coverage), while in our case, the data structure size is almost invariant with respect to the coverage (Section “<italic>E. coli</italic> dataset, varying coverage”).</p>
    <p>An interesting open question is whether the Bloom filter construction can be made online, so that new <italic>k</italic>-mers (reads) can be inserted without reconstructing the whole data structure from scratch. Note that the presented construction (Section “Construction algorithm”) is inherently off-line, as all <italic>k</italic>-mers should be known before the data structure is built.</p>
    <p>Another interesting prospect for possible further improvements of our method is offered by work [<xref ref-type="bibr" rid="B16">16</xref>], where an efficient replacement to Bloom filter was introduced. The results of [<xref ref-type="bibr" rid="B16">16</xref>] suggest that we could hope to reduce the memory to about 5 bits per <italic>k</italic>-mer. However, there exist obstacles on this way: an implementation of such a structure would probably result in a significant construction and query time increase.</p>
  </sec>
  <sec>
    <title>Endnotes</title>
    <p><sup>a</sup> Note that this is actually a <italic>subgraph</italic> of the de Bruijn graph under its classical combinatorial definition. However, we still call it de Bruijn graph to follow the terminology common to the bioinformatics literature.</p>
    <p><sup>b</sup> By a slight abuse of notation, we also view <italic>B</italic><sub><italic>j</italic></sub> as the set of all <italic>k</italic>-mers on which the filter <italic>B</italic><sub><italic>j</italic></sub> returns the positive answer.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors’ contributions</title>
    <p>KS and GK designed the data structure. KS performed analytical estimatons. GS implemented the method and performed the computational experiments with biological data. All authors contributed to writing the manuscript. All authors read and approved the final manuscript.</p>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>Part of this work has been done during the visit of KS to LIGM in France, supported by the CNRS French-Russian exchange program in Computer Science. GK has been partly supported by the ABS2NGS grant of the French gouvernement (program <italic>Investissement d’Avenir</italic>) as well as by a Marie-Curie Intra-European Fellowship for Carrier Development. GS was supported by the European Research Council under the European Community’s Seventh Framework Programme (FP7/2007-2013)/ERC grant agreement no. [247073]10.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Miller</surname>
          <given-names>JR</given-names>
        </name>
        <name>
          <surname>Koren</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Sutton</surname>
          <given-names>G</given-names>
        </name>
        <article-title>
          <bold>Assembly algorithms for next-generation sequencing data</bold>
        </article-title>
        <source>Genomics</source>
        <year>2010</year>
        <volume>9</volume>
        <issue>6</issue>
        <fpage>315</fpage>
        <lpage>327</lpage>
        <pub-id pub-id-type="doi">10.1016/j.ygeno.2010.03.001</pub-id>
        <?supplied-pmid 20211242?>
        <pub-id pub-id-type="pmid">20211242</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Pevzner</surname>
          <given-names>PA</given-names>
        </name>
        <name>
          <surname>Tang</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Waterman</surname>
          <given-names>MS</given-names>
        </name>
        <article-title>
          <bold>An Eulerian path approach to DNA fragment assembly</bold>
        </article-title>
        <source>Proc Natl Acad Sci USA</source>
        <year>2001</year>
        <volume>9</volume>
        <issue>17</issue>
        <fpage>9748</fpage>
        <lpage>9753</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.171285098</pub-id>
        <?supplied-pmid 11504945?>
        <pub-id pub-id-type="pmid">11504945</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Grabherr</surname>
          <given-names>MG</given-names>
        </name>
        <name>
          <surname>Haas</surname>
          <given-names>BJ</given-names>
        </name>
        <name>
          <surname>Yassour</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Levin</surname>
          <given-names>JZ</given-names>
        </name>
        <name>
          <surname>Thompson</surname>
          <given-names>DA</given-names>
        </name>
        <name>
          <surname>Amit</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Adiconis</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Fan</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Raychowdhury</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Zeng</surname>
          <given-names>Q</given-names>
        </name>
        <name>
          <surname>Chen</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Mauceli</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Hacohen</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Gnirke</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Rhind</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>di Palma</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Birren</surname>
          <given-names>BW</given-names>
        </name>
        <name>
          <surname>Nusbaum</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Lindblad-Toh</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Friedman</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Regev</surname>
          <given-names>A</given-names>
        </name>
        <article-title>
          <bold>Full-length transcriptome assembly from RNA-Seq data without a reference genome</bold>
        </article-title>
        <source>Nat Biotech</source>
        <year>2011</year>
        <volume>9</volume>
        <issue>7</issue>
        <fpage>644</fpage>
        <lpage>652</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.1883</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Sacomoto</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Kielbassa</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Chikhi</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Uricaru</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Antoniou</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Sagot</surname>
          <given-names>M-F</given-names>
        </name>
        <name>
          <surname>Peterlongo</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Lacroix</surname>
          <given-names>V</given-names>
        </name>
        <article-title>
          <bold>KISSPLICE: de-novo calling alternative splicing events from RNA-seq data</bold>
        </article-title>
        <source>BMC Bioinformatics</source>
        <year>2012</year>
        <volume>9</volume>
        <issue>Suppl 6</issue>
        <fpage>5</fpage>
        <?supplied-pmid 22233380?>
        <pub-id pub-id-type="pmid">22233380</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Peng</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Leung</surname>
          <given-names>HCM</given-names>
        </name>
        <name>
          <surname>Yiu</surname>
          <given-names>SM</given-names>
        </name>
        <name>
          <surname>Chin</surname>
          <given-names>FYL</given-names>
        </name>
        <article-title>
          <bold>Meta-IDBA: a de novo assembler for metagenomic data</bold>
        </article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>9</volume>
        <issue>13</issue>
        <fpage>94</fpage>
        <lpage>101</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btr216</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Iqbal</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Caccamo</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Turner</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Flicek</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>McVean</surname>
          <given-names>G</given-names>
        </name>
        <article-title>
          <bold>De novo assembly and genotyping of variants using colored de Bruijn graphs</bold>
        </article-title>
        <source>Nat Genet</source>
        <year>2012</year>
        <volume>9</volume>
        <issue>2</issue>
        <fpage>226</fpage>
        <lpage>232</lpage>
        <pub-id pub-id-type="doi">10.1038/ng.1028</pub-id>
        <?supplied-pmid 22231483?>
        <pub-id pub-id-type="pmid">22231483</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Conway</surname>
          <given-names>TC</given-names>
        </name>
        <name>
          <surname>Bromage</surname>
          <given-names>AJ</given-names>
        </name>
        <article-title>
          <bold>Succinct data structures for assembling large genomes</bold>
        </article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>9</volume>
        <issue>4</issue>
        <fpage>479</fpage>
        <lpage>486</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq697</pub-id>
        <?supplied-pmid 21245053?>
        <pub-id pub-id-type="pmid">21245053</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Ye</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Ma</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Cannon</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Pop</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Yu</surname>
          <given-names>D</given-names>
        </name>
        <article-title>
          <bold>Exploiting sparseness in de novo genome assembly</bold>
        </article-title>
        <source>BMC Bioinformatics</source>
        <year>2012</year>
        <volume>9</volume>
        <issue>Suppl 6</issue>
        <fpage>1</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-13-S6-S1</pub-id>
        <?supplied-pmid 22214541?>
        <pub-id pub-id-type="pmid">22214541</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Chikhi</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Rizk</surname>
          <given-names>G</given-names>
        </name>
        <article-title>
          <bold>Space-efficient and exact de Bruijn graph representation based on a Bloom filter</bold>
        </article-title>
        <source>Algorithms Mol Biol</source>
        <year>2013</year>
        <volume>9</volume>
        <issue>1</issue>
        <fpage>22</fpage>
        <comment>Preliminary version in WABI’2012</comment>
        <pub-id pub-id-type="doi">10.1186/1748-7188-8-22</pub-id>
        <?supplied-pmid 24040893?>
        <pub-id pub-id-type="pmid">24040893</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="book">
        <name>
          <surname>Bowe</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Onodera</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Sadakane</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Shibuya</surname>
          <given-names>T</given-names>
        </name>
        <person-group person-group-type="editor">Raphael BJ, Tang J</person-group>
        <article-title>
          <bold>Succinct de Bruijn graphs</bold>
        </article-title>
        <source>Algorithms in Bioinformatics - 12th International Workshop, WABI 2012, Ljubljana, Slovenia, September 10-12, 2012. Proceedings. Lecture Notes in Computer Science Volume 7534</source>
        <year>2012</year>
        <publisher-name>Berlin: Springer</publisher-name>
        <fpage>225</fpage>
        <lpage>235</lpage>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Pell</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Hintze</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Canino-Koning</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Howe</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Tiedje</surname>
          <given-names>JM</given-names>
        </name>
        <name>
          <surname>Brown</surname>
          <given-names>CT</given-names>
        </name>
        <article-title>
          <bold>Scaling metagenome sequence assembly with probabilistic de Bruijn graphs</bold>
        </article-title>
        <source>Proc Natl Acad Sci USA</source>
        <year>2012</year>
        <volume>9</volume>
        <issue>33</issue>
        <fpage>13272</fpage>
        <lpage>13277</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.1121464109</pub-id>
        <?supplied-pmid 22847406?>
        <pub-id pub-id-type="pmid">22847406</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kirsch</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Mitzenmacher</surname>
          <given-names>M</given-names>
        </name>
        <article-title>
          <bold>Less hashing, same performance: building a better Bloom filter</bold>
        </article-title>
        <source>Random Struct Algorithms</source>
        <year>2008</year>
        <volume>9</volume>
        <issue>2</issue>
        <fpage>187</fpage>
        <lpage>218</lpage>
        <pub-id pub-id-type="doi">10.1002/rsa.20208</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Rizk</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Lavenier</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Chikhi</surname>
          <given-names>R</given-names>
        </name>
        <article-title>
          <bold>DSK: k-mer counting with very low memory usage</bold>
        </article-title>
        <source>Bioinformatics</source>
        <year>2013</year>
        <volume>9</volume>
        <issue>5</issue>
        <fpage>652</fpage>
        <lpage>3</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btt020</pub-id>
        <?supplied-pmid 23325618?>
        <pub-id pub-id-type="pmid">23325618</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Blattner</surname>
          <given-names>FR</given-names>
        </name>
        <name>
          <surname>Plunkett</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Bloch</surname>
          <given-names>CA</given-names>
        </name>
        <name>
          <surname>Perna</surname>
          <given-names>NT</given-names>
        </name>
        <name>
          <surname>Burland</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Riley</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Collado-Vides</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Glasner</surname>
          <given-names>JD</given-names>
        </name>
        <name>
          <surname>Rode</surname>
          <given-names>CK</given-names>
        </name>
        <name>
          <surname>Mayhew</surname>
          <given-names>GF</given-names>
        </name>
        <name>
          <surname>Gregor</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Davis</surname>
          <given-names>NW</given-names>
        </name>
        <name>
          <surname>Kirkpatrick</surname>
          <given-names>HA</given-names>
        </name>
        <name>
          <surname>Goeden</surname>
          <given-names>MA</given-names>
        </name>
        <name>
          <surname>Rose</surname>
          <given-names>DJ</given-names>
        </name>
        <name>
          <surname>Mau</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Shao</surname>
          <given-names>Y</given-names>
        </name>
        <article-title>
          <bold>The complete genome sequence of Escherichia coli K-12</bold>
        </article-title>
        <source>Science</source>
        <year>1997</year>
        <volume>9</volume>
        <issue>5331</issue>
        <fpage>1453</fpage>
        <lpage>1462</lpage>
        <pub-id pub-id-type="doi">10.1126/science.277.5331.1453</pub-id>
        <?supplied-pmid 9278503?>
        <pub-id pub-id-type="pmid">9278503</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="other">
        <article-title>
          <sc>MINIA</sc>
          <bold>software</bold>
        </article-title>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://minia.genouest.org/">http://minia.genouest.org/</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="book">
        <name>
          <surname>Porat</surname>
          <given-names>E</given-names>
        </name>
        <article-title>
          <bold>An optimal Bloom filter replacement based on matrix solving</bold>
        </article-title>
        <source>Computer Science - Theory and Applications, Fourth International Computer Science Symposium in Russia, CSR 2009, Novosibirsk, Russia, August 18-23, 2009. Proceedings. Lecture Notes in Computer Science, Volume 5675</source>
        <year>2009</year>
        <publisher-name>Berlin: Springer</publisher-name>
        <fpage>263</fpage>
        <lpage>273</lpage>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
