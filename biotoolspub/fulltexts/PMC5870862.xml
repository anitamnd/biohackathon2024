<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">5870862</article-id>
    <article-id pub-id-type="pmid">28449031</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btx263</article-id>
    <article-id pub-id-type="publisher-id">btx263</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Structural Bioinformatics</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>RNAblueprint: flexible multiple target nucleic acid sequence design</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Hammer</surname>
          <given-names>Stefan</given-names>
        </name>
        <xref ref-type="aff" rid="btx263-aff1">1</xref>
        <xref ref-type="aff" rid="btx263-aff2">2</xref>
        <xref ref-type="corresp" rid="btx263-cor1"/>
        <!--<email>s.hammer@univie.ac.at</email>-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Tschiatschek</surname>
          <given-names>Birgit</given-names>
        </name>
        <xref ref-type="aff" rid="btx263-aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Flamm</surname>
          <given-names>Christoph</given-names>
        </name>
        <xref ref-type="aff" rid="btx263-aff1">1</xref>
        <xref ref-type="aff" rid="btx263-aff3">3</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Hofacker</surname>
          <given-names>Ivo L</given-names>
        </name>
        <xref ref-type="aff" rid="btx263-aff1">1</xref>
        <xref ref-type="aff" rid="btx263-aff2">2</xref>
        <xref ref-type="aff" rid="btx263-aff4">4</xref>
        <xref ref-type="corresp" rid="btx263-cor1"/>
        <!--<email>ivo@tbi.univie.ac.at</email>-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Findeiß</surname>
          <given-names>Sven</given-names>
        </name>
        <xref ref-type="aff" rid="btx263-aff1">1</xref>
        <xref ref-type="aff" rid="btx263-aff2">2</xref>
        <xref ref-type="corresp" rid="btx263-cor1"/>
        <!--<email>sven@tbi.univie.ac.at</email>-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Sahinalp</surname>
          <given-names>Cenk</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <aff id="btx263-aff1"><label>1</label>Faculty of Chemistry, Department of Theoretical Chemistry, University of Vienna, Vienna, Austria</aff>
    <aff id="btx263-aff2"><label>2</label>Faculty of Computer Science, Research Group Bioinformatics and Computational Biology, University of Vienna, Vienna, Austria</aff>
    <aff id="btx263-aff3"><label>3</label>Research Network Chemistry Meets Microbiology, University of Vienna, Vienna, Austria</aff>
    <aff id="btx263-aff4"><label>4</label>Center for Non-Coding RNA in Technology and Health, University of Copenhagen, Copenhagen, Denmark</aff>
    <author-notes>
      <corresp id="btx263-cor1">To whom correspondence should be addressed. Email: <email>s.hammer@univie.ac.at</email>, <email>ivo@tbi.univie.ac.at</email> or <email>sven@tbi.univie.ac.at</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>9</month>
      <year>2017</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2017-04-25">
      <day>25</day>
      <month>4</month>
      <year>2017</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>25</day>
      <month>4</month>
      <year>2017</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>33</volume>
    <issue>18</issue>
    <fpage>2850</fpage>
    <lpage>2858</lpage>
    <history>
      <date date-type="received">
        <day>21</day>
        <month>9</month>
        <year>2016</year>
      </date>
      <date date-type="rev-recd">
        <day>24</day>
        <month>2</month>
        <year>2017</year>
      </date>
      <date date-type="accepted">
        <day>21</day>
        <month>4</month>
        <year>2017</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author 2017. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2017</copyright-year>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/" license-type="cc-by">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btx263.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="SA1">
        <title>Motivation</title>
        <p>Realizing the value of synthetic biology in biotechnology and medicine requires the design of molecules with specialized functions. Due to its close structure to function relationship, and the availability of good structure prediction methods and energy models, RNA is perfectly suited to be synthetically engineered with predefined properties. However, currently available RNA design tools cannot be easily adapted to accommodate new design specifications. Furthermore, complicated sampling and optimization methods are often developed to suit a specific RNA design goal, adding to their inflexibility.</p>
      </sec>
      <sec id="SA2">
        <title>Results</title>
        <p>We developed a <monospace>C ++ </monospace> library implementing a graph coloring approach to stochastically sample sequences compatible with structural and sequence constraints from the typically very large solution space. The approach allows to specify and explore the solution space in a well defined way. Our library also guarantees uniform sampling, which makes optimization runs performant by not only avoiding re-evaluation of already found solutions, but also by raising the probability of finding better solutions for long optimization runs. We show that our software can be combined with any other software package to allow diverse RNA design applications. Scripting interfaces allow the easy adaption of existing code to accommodate new scenarios, making the whole design process very flexible. We implemented example design approaches written in <monospace>Python</monospace> to demonstrate these advantages.</p>
      </sec>
      <sec id="SA3">
        <title>Availability and implementation</title>
        <p><monospace>RNAblueprint</monospace>, <monospace>Python</monospace> implementations and benchmark datasets are available at github: <ext-link ext-link-type="uri" xlink:href="https://github.com/ViennaRNA">https://github.com/ViennaRNA</ext-link>.</p>
      </sec>
      <sec id="SA4">
        <title>Supplementary information</title>
        <p><xref ref-type="supplementary-material" rid="sup1">Supplementary data</xref> are available at <italic>Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">FET</named-content>
          <named-content content-type="funder-identifier">10.13039/100010664</named-content>
        </funding-source>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>RNA molecules are omnipresent in all domains of life. They execute diverse functions including small molecule sensing, signal transduction and gene regulation. RNA is a molecule well-suited for designing with predefined functionality. This is mainly due to its close structure to function relationship and the physio-chemically grounded energy models for straightforward <italic>in silico</italic> calculations at the level of secondary structure. In recent years, due to the advent of synthetic biology, more researchers are focusing on the design of synthetic RNAs. There has been increasing success in modifying existing systems and incorporating novel functionality in RNAs within a cellular context (<xref rid="btx263-B3" ref-type="bibr">Chappell <italic>et al.</italic>, 2015</xref>; <xref rid="btx263-B4" ref-type="bibr">Espah-Borujeni <italic>et al.</italic>, 2015</xref>; <xref rid="btx263-B7" ref-type="bibr">Green <italic>et al.</italic>, 2014</xref>; <xref rid="btx263-B21" ref-type="bibr">Rodrigo <italic>et al.</italic>, 2012</xref>)</p>
    <p>To produce an RNA molecule with a prescribed function, the close structure to function relationship must be incorporated into the design process, along with a rationally defined specification of the structure performing that function. In the simplest form one could generate all 4<sup><italic>n</italic></sup> possible nucleic acid sequences of length <italic>n</italic> and test for each sequence if it fulfills the design criteria, e.g. its most stable fold is the structure of interest. Only a small subset of all possible sequences will be actually able to fold at all into the target structure and it is therefore favorable to generate those candidate sequences at least comply with the structural constraints, i.e. are able to fold into the defined structure. Generating only those sequences able and likely to fold into the target structure is known as the ‘inverse folding problem’ (<xref rid="btx263-B8" ref-type="bibr">Hofacker <italic>et al.</italic>, 1994</xref>) where the applied structural constraints reduce the size of the solution space to be investigated. Biologically active RNA molecules such as aptamers or ribozymes frequently require specific nucleotide patterns in binding or catalytic domains. Therefore, the designed RNA must also comply with certain sequence constraints. Several computational tools capable of solving this hard combinatorial optimization problem have been published. These tools differ mainly in how the initial sequence is selected and which search strategy, e.g. stochastic local or global search, is applied (see <xref ref-type="supplementary-material" rid="sup1">Supplementary Table S1</xref>). Both algorithmic characteristics have a big impact on the success of the optimization.</p>
    <p>A variety of RNA molecules, natural as well as artificial, have been described that exploit structural change as their functional mechanism. Usually, the structural switching of these RNAs between an inactive and the active conformation is induced by an external trigger, which can be as diverse as temperature, small organic molecules, or other small RNAs (<xref rid="btx263-B2" ref-type="bibr">Berens and Suess, 2015</xref>). The design of such RNA devices requires finding a sequence compatible with two or more structural constraints. Designing a bi-stable RNA was first solved by <xref rid="btx263-B5" ref-type="bibr">Flamm <italic>et al.</italic> (2001)</xref> using a graph coloring approach. Recent tools can now also design multi-state (three or more) RNA molecules (<xref rid="btx263-B9" ref-type="bibr">Höner zu Siederdissen <italic>et al.</italic>, 2013</xref>; <xref rid="btx263-B14" ref-type="bibr">Lyngso <italic>et al.</italic>, 2012</xref>; <xref rid="btx263-B22" ref-type="bibr">Taneda, 2015</xref>; <xref rid="btx263-B24" ref-type="bibr">Wolfe and Pierce, 2015</xref>; <xref rid="btx263-B25" ref-type="bibr">Zadeh <italic>et al.</italic>, 2011a</xref>). The most recent version of the <monospace>RNAiFold</monospace> server seems to accept more than two target structures, this extension is however not yet described in the latest publication (<xref rid="btx263-B6" ref-type="bibr">Garcia-Martin <italic>et al.</italic>, 2015</xref>). Algorithms able to handle multi-state as well as multi-sequence folding and pseudoknotted structures are required if multiple RNA molecules are used as triggers. The latter are implemented in the <monospace>NUPACK</monospace> design and analysis framework (<xref rid="btx263-B26" ref-type="bibr">Zadeh <italic>et al.</italic>, 2011b</xref>).</p>
    <p>Sampling sequences compatible with multiple structural constraints can be achieved using a complex graph coloring algorithm (<xref rid="btx263-B1" ref-type="bibr">Abfalter <italic>et al.</italic>, 2003</xref>; <xref rid="btx263-B9" ref-type="bibr">Höner zu Siederdissen <italic>et al.</italic>, 2013</xref>). It solves this problem in a defined way where each solution is drawn statistically fairly with equal probability. In contrast, other sampling approaches use ad hoc sampling heuristics that introduce biases and often exhibit undefined runtime complexities (<xref rid="btx263-B14" ref-type="bibr">Lyngso <italic>et al.</italic>, 2012</xref>; <xref rid="btx263-B22" ref-type="bibr">Taneda, 2015</xref>). Thus, good solutions may be missed because the sampled part of the solution space is not clearly specified and therefore cannot be fully explored. Furthermore, frequent re-evaluation of already discovered solutions due to biased sampling leads to inefficient optimization, especially if the calculation of the objective involves demanding computations such as pseudoknot structure prediction.</p>
    <p>A review of the literature revealed that published RNA designs were either achieved by manual ad hoc approaches or very specific software implementations, which can handle only restricted design problems on a case-by-case basis (<xref rid="btx263-B10" ref-type="bibr">Isaacs <italic>et al.</italic>, 2004</xref>; <xref rid="btx263-B17" ref-type="bibr">Neupert <italic>et al.</italic>, 2008</xref>; <xref rid="btx263-B18" ref-type="bibr">Qi <italic>et al.</italic>, 2012</xref>; <xref rid="btx263-B20" ref-type="bibr">Rodrigo and Jaramillo, 2014</xref>; <xref rid="btx263-B23" ref-type="bibr">Wachsmuth <italic>et al.</italic>, 2013</xref>). Very recent publications focus on the flexibility of the design approach and provide methods and interfaces to allow the specification of broader objectives (<xref rid="btx263-B9" ref-type="bibr">Höner zu Siederdissen <italic>et al.</italic>, 2013</xref>; <xref rid="btx263-B22" ref-type="bibr">Taneda, 2015</xref>). However, the diversity of the objectives is still limited and introducing a new feature in the objective function requires changes in the program code (some of which are closed source). Furthermore, the mechanisms of optimization in existing tools are always predefined and very rigid.</p>
    <p>To address these limitations, we developed <monospace>RNAblueprint</monospace> which solves the problem of sampling RNA sequences compatible with multiple structural and sequence constraints in a well defined way. The library is able to specify the runtime complexity and memory requirements of the problem for any given constraints, calculate the number of possible solutions, and to stochastically sample uniformly from all solutions. Furthermore, our technique can be easily integrated into existing tools, henceforth making it possible to focus on the formulation of the objective function as the most crucial part of the design process. Until now this aspect was largely neglected, even though the objective describes best how the design should function. The actual optimization process is performed using the scripting interface, where we offer predefined solutions but also give the user the opportunity to easily implement new ideas without having to change the source code of the core library. Next to the well defined way of describing and exploring the solution space, this flexibility is a major advantage of our approach.</p>
    <p>With our framework, in addition to predicting RNA structure and RNA–RNA interactions, and allowing for pseudoknot incorporation (<xref rid="btx263-B11" ref-type="bibr">Janssen and Giegerich, 2015</xref>; <xref rid="btx263-B12" ref-type="bibr">Lorenz <italic>et al.</italic>, 2011</xref>; <xref rid="btx263-B25" ref-type="bibr">Zadeh <italic>et al.</italic>, 2011a</xref>,<xref rid="btx263-B26" ref-type="bibr">b</xref>) recent methods for the calculation of RNA-ligand interactions can also be incorporated (<xref rid="btx263-B13" ref-type="bibr">Lorenz <italic>et al.</italic>, 2016</xref>). Using <monospace>RNAblueprint</monospace> and its scripting interface we here implemented a multi-state design, which we used to analyze and benchmark our software. The developed software allows us to effectively solve problems including the design of translational and transcriptional on/off switches, triggered by diverse inputs such as small RNAs, ligands, temperature, salt concentration or proteins. <monospace>RNAblueprint</monospace> can also be used to specify the design of RNA or DNA scaffolds in synthetic biology, and to construct RNA/DNA origami.</p>
  </sec>
  <sec>
    <title>2 Approach</title>
    <p>An RNA sequence <inline-formula id="IE1"><mml:math id="IM1"><mml:mrow><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> is constructed from a set of monomers <inline-formula id="IE2"><mml:math id="IM2"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> that can interact by forming base pairs (<italic>i</italic>, <italic>j</italic>), <inline-formula id="IE3"><mml:math id="IM3"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> where <italic>i</italic> and <italic>j</italic> are positions separated by at least three bases and <inline-formula id="IE4"><mml:math id="IM4"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script">B</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>A</mml:mi><mml:mi>U</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mi>U</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi><mml:mi>G</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> the set of allowed base pairs with <inline-formula id="IE5"><mml:math id="IM5"><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mo>⊂</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:mo>×</mml:mo><mml:mi mathvariant="script">A</mml:mi></mml:mrow></mml:math></inline-formula>. A set of base pairs of a sequence <italic>x</italic> is called secondary structure Θ.</p>
    <p><monospace>RNAblueprint</monospace> implements a method to sample RNA sequences compatible with all structures of a given set <inline-formula id="IE6"><mml:math id="IM6"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mo>Θ</mml:mo><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mo>Θ</mml:mo><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mo>Θ</mml:mo><mml:mi>M</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and sequence constraints <inline-formula id="IE7"><mml:math id="IM7"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mo>Υ</mml:mo><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mo>Υ</mml:mo><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mo>Υ</mml:mo><mml:mn>3</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mo>Υ</mml:mo><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE8"><mml:math id="IM8"><mml:mrow><mml:msub><mml:mo>Υ</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo>⊆</mml:mo><mml:mi mathvariant="script">A</mml:mi></mml:mrow></mml:math></inline-formula> is the set of allowed nucleotides at position <italic>i</italic>. To be able to uniformly sample from the entire solution space <inline-formula id="IE9"><mml:math id="IM9"><mml:mi mathvariant="script">C</mml:mi></mml:math></inline-formula> (which is the set of all <italic>x</italic> compatible with all <inline-formula id="IE10"><mml:math id="IM10"><mml:mrow><mml:msub><mml:mo>Θ</mml:mo><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>t</mml:mi><mml:mo>≤</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:math></inline-formula>, given all sequence constraints <inline-formula id="IE11"><mml:math id="IM11"><mml:mrow><mml:msub><mml:mo>Υ</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>), we implemented the graph-theoretical coloring approach developed by <xref rid="btx263-B1" ref-type="bibr">Abfalter <italic>et al.</italic> (2003)</xref>, which is depicted in <xref ref-type="fig" rid="btx263-F1">Figure 1</xref> and described in the following. The goal is to generate sequences that are compatible with a sequence constraint and a set of target structures. Such a design problem is represented as a <italic>dependency graph</italic><inline-formula id="IE12"><mml:math id="IM12"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> constructed as the union of the circle plot representations of the structural constraints (<xref ref-type="supplementary-material" rid="sup1">Supplementary Fig. S1</xref>). Each vertex <inline-formula id="IE13"><mml:math id="IM13"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula> of the graph corresponds to a position <inline-formula id="IE14"><mml:math id="IM14"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> in the sequence to be designed, and the edges <italic>E</italic> represent base pairs (<italic>i</italic>, <italic>j</italic>) that are formed between two vertices. Each base pair occurs at least in one of the input structures. According to the generalized intersection theorem, there exists a solution given the structural constraints, <italic>iff</italic> the resulting graph is bipartite (<xref rid="btx263-B5" ref-type="bibr">Flamm <italic>et al.</italic>, 2001</xref>). Finally, a coloring or base assignment on a vertex <italic>v<sub>i</sub></italic> is a single nucleotide <inline-formula id="IE15"><mml:math id="IM15"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mo>Υ</mml:mo><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> assigned to the position <italic>i</italic>. Note, that poorly chosen sequence constraints might lead to an unsolvable design problem if they contradict the base pairing pattern enforced by the structural constraints. However, this can already be detected during the graph construction process.
</p>
    <fig id="btx263-F1" orientation="portrait" position="float">
      <label>Fig. 1.</label>
      <caption>
        <p>A dependency graph is hierarchically decomposed starting from the top and moving down through four levels to generate a decomposition tree. The dot-bracket strings (top left) denote three structural input constraints which are converted into a dependency graph (top right) by intersecting their circle representations, see <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S1</xref>. For an easy visual mapping sequence positions are indicated above the dot-bracket string by an increment of five. Gray boxed subgraphs are not decomposed further as their number of possible colorings can be obtained with the path coloring approach. <inline-graphic xlink:href="btx263ilf1.jpg"/> nodes represent articulation points</p>
      </caption>
      <graphic xlink:href="btx263f1"/>
    </fig>
    <p>For the design problem with two structural states, <xref rid="btx263-B5" ref-type="bibr">Flamm <italic>et al.</italic> (2001)</xref> showed that connected components and the underlying sequence positions of the corresponding dependency graph belong to one of the following classes: (i) isolated positions that are unpaired in both structures, (ii) positions that are paired with the same pairing partner in both structures and therefore form paths of length one and (iii) positions that are paired differently in both structures and therefore form paths or cycles. Connected components in (i) and (ii) can be assigned with any element of <inline-formula id="IE16"><mml:math id="IM16"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> and <inline-formula id="IE17"><mml:math id="IM17"><mml:mi mathvariant="script">B</mml:mi></mml:math></inline-formula>, respectively. Paths and cycles belonging to (iii) can be stochastically colored by a simple recursion. Furthermore, it was demonstrated how Fibonacci numbers can be used to determine the number of possible solutions for the latter.</p>
    <p>Following these results, it is desirable to decompose a more complex dependency graph generated by more than two structural constraints into the aforementioned classes. This decomposition happens at vertices with degree greater than two, denoted as a set of <italic>articulation points</italic><inline-formula id="IE18"><mml:math id="IM18"><mml:mi mathvariant="script">S</mml:mi></mml:math></inline-formula>. Depending on the decomposition algorithm, these nodes are also called cut points or attachment points. As the subsequently explained coloring approach can be very memory and CPU demanding, it is important to follow a specific order on how to decompose the dependency graph into paths. Connected components containing articulation points are decomposed into biconnected components and if they still contain articulation points, they are further decomposed using the ear decomposition algorithm, see <xref ref-type="fig" rid="btx263-F1">Figure 1</xref>. An ear decomposition of a graph starting with a path <italic>P</italic><sub>0</sub> is a decomposition of its edge set <inline-formula id="IE19"><mml:math id="IM19"><mml:mrow><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>∪</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>∪</mml:mo><mml:mo>…</mml:mo><mml:mo>∪</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE20"><mml:math id="IM20"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is a simple path or ear whose endpoints belong to <inline-formula id="IE21"><mml:math id="IM21"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>∪</mml:mo><mml:mo>…</mml:mo><mml:mo>∪</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, but its internal vertices do not (<xref rid="btx263-B15" ref-type="bibr">Maon <italic>et al.</italic>, 1986</xref>). Our step-wise decomposition approach ensures that the dependency graph falls apart into paths and cycles in a fixed order. As soon as the maximal degree of a subgraph <italic>H</italic> is two, either a path or a circle is reached and further decomposition is terminated. Using this decomposition approach, a binary tree of subgraphs is generated where the complete dependency graph sits at the root and each step of decomposition leads to a fixed order of subgraphs.</p>
    <p>After the graph decomposition, the coloring problem therefore reduces to the determination of possible colorings of articulation points (<inline-graphic xlink:href="btx263ilf1.jpg"/> and <inline-graphic xlink:href="btx263ilf3.jpg"/> vertices in <xref ref-type="fig" rid="btx263-F2">Fig. 2</xref>) in the generated subgraphs <italic>H</italic>. This information can be efficiently calculated by a dynamic programming procedure (<xref rid="btx263-B1" ref-type="bibr">Abfalter <italic>et al.</italic>, 2003</xref>). Uniform sampling from <inline-formula id="IE22"><mml:math id="IM22"><mml:mi mathvariant="script">C</mml:mi></mml:math></inline-formula> can then be achieved by stochastic backtracking. First articulation points are assigned, followed by the sampling of colors for adjacent paths. For ear decompositions this has been described in (<xref rid="btx263-B9" ref-type="bibr">Höner zu Siederdissen <italic>et al.</italic>, 2013</xref>). In this contribution we describe a generalized approach that covers the dynamic programming for all decomposed components of the dependency graph.</p>
    <fig id="btx263-F2" orientation="portrait" position="float">
      <label>Fig. 2.</label>
      <caption>
        <p>Algorithmic implementation of the decomposition (black arrows) and the reassembly (gray arrows) of a biconnected component. <inline-graphic xlink:href="btx263ilf2.jpg"/> nodes are ordinary nodes and <inline-graphic xlink:href="btx263ilf1.jpg"/> nodes indicate articulation points. <inline-graphic xlink:href="btx263ilf3.jpg"/> nodes are internalized articulation points which can be converted to ordinary nodes with the <monospace>reduce</monospace> function. During the dynamic programming forward recursion, the matrix concatenation operator calculates the number of possible colorings of the combined subgraphs given any assignments on <inline-formula id="IE23"><mml:math id="IM23"><mml:mi mathvariant="script">S</mml:mi></mml:math></inline-formula></p>
      </caption>
      <graphic xlink:href="btx263f2"/>
    </fig>
    <p>The dynamic programming forward recursion we implemented traverses the binary decomposition tree from the bottom up, ending at the complete assembled dependency graph <italic>G</italic>. For every subgraph <italic>H</italic> the possible colorings for the set of articulation points <inline-formula id="IE24"><mml:math id="IM24"><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mi>H</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and the according number of available solutions for <italic>H</italic> given these colors are stored in a memorization table during the dynamic programming procedure. The dimension of such a table is determined by <inline-formula id="IE25"><mml:math id="IM25"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mi>H</mml:mi></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. Since this number differs during the recursive traversal of the graphs in the decomposition tree (smaller graphs are connected at articulation points to larger units) the dimension of the memorization tables also varies. A table dimension itself is indexed by the elements of <inline-formula id="IE26"><mml:math id="IM26"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula>. For unbranched paths of length <italic>l</italic> the number of colorings can easily be looked up in the <italic>l</italic>-th power of the pairing matrix <inline-formula id="IE27"><mml:math id="IM27"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula>. The memorization table of any other subgraph <italic>H</italic> (parent node in the decomposition tree) is always calculated from the memorization tables of its two smaller constituting graphs (child nodes in the decomposition tree) in a type of concatenation procedure (<xref ref-type="fig" rid="btx263-F2">Fig. 2</xref>). The corresponding entries of the articulation points (table dimensions) are first multiplied component-wise and then inserted into the new table. In our implementation the memorization tables are sparse objects and the above construction procedure only increases dimensionality of the tables. The result would be a sparse memorization table with <inline-formula id="IE28"><mml:math id="IM28"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> dimensions at the root node of the decomposition tree. To avoid wasting of memory resources, we introduced a dimension reduction step during the successive construction of the memorization tables. This reduction step rests on the observation that whenever the vertex degree of an articulation point in a partially assembled graph is equal to the vertex degree of the corresponding node in the union graph (root node of the decomposition tree) no further subgraph will be ‘attached’ to this particular vertex in subsequent memorization table concatenation operations (see <xref ref-type="fig" rid="btx263-F2">Fig. 2</xref>). Hence, the corresponding dimension of the memorization table is collapsed via summing up the values over that internalized articulation point, which shrinks the memorization table and removes the articulation point from the table. This implies that memorization tables for connected components have dimension zero since all articulation points have been internalized and removed via summation. In other words a memorization table with zero dimensions stores the total number of possible colorings for the respective subgraph. The memorization table for the root graph (i.e. the original union graph) therefore stores the size of the solution space, <inline-formula id="IE29"><mml:math id="IM29"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, which is equal to the total number of sequences compatible with the design constraints. With the help of the total number of sequences, the coloring count entries of the memorization tables can be re-interpreted as probabilities, paving the way for uniform sampling approaches.</p>
    <p>The sampling procedure works exactly in the opposite order of the memorization table calculation. For each subgraph, articulation points are colored by stochastic backtracking from the probability matrix, which corresponds to the re-interpreted memorization table, followed by the sampling of the graph itself, if it is a path. Otherwise the next hierarchical level of subgraphs is processed. If an articulation point has a base assigned already, this information is used during the stochastic backtracking. Finally, when the last child has been processed, all bases are assigned and a solution was fairly drawn from the complete solution space.</p>
    <p>Besides <italic>global sampling</italic>, i.e. generating a completely new sequence all the time, <monospace>RNAblueprint</monospace> offers two more procedures to mutate or resample parts of the sequence. <italic>C-local sampling</italic> resets the base assignments of all vertices of a random connected component and draws new colors, i.e. nucleotide assignments, for these vertices. <italic>P-local sampling</italic> randomly selects one path at the leaves of the decomposition tree and resamples only vertices which are not articulation points. This way we ensure the compatibility within a connected component. For both C-local and P-local sampling it can be useful to restrict the random selection of subgraphs by minimal and maximal size constraints or to directly select the connected component or path. The possibility to resample a specific position in the sequence also exists. This either involves a P-local sampling of the path containing the position or, in cases where the selected position corresponds to an articulation point, a C-local sampling of the corresponding connected component. In this way, the ranges of positions to be sampled can be specified. A history of previous sampled sequences is stored, making it convenient to revert to those previous sequences if necessary.</p>
    <p>The complexity of our program strongly depends on the number of articulation points <inline-formula id="IE30"><mml:math id="IM30"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. The minimum time complexity <inline-formula id="IE31"><mml:math id="IM31"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is specified by running the graph decomposition algorithms or path colorings. For every subgraph <italic>H</italic>, the memory and CPU requirements of the dynamic programming coloring approach can be denoted as <inline-formula id="IE32"><mml:math id="IM32"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:msup><mml:mo>|</mml:mo><mml:mo>α</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mi>H</mml:mi></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE33"><mml:math id="IM33"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">A</mml:mi><mml:msup><mml:mo>|</mml:mo><mml:mo>β</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>β</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:munder><mml:mo>∪</mml:mo><mml:mrow><mml:mi>h</mml:mi><mml:mo>∈</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mi>h</mml:mi></mml:msub></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, respectively. <italic>C</italic>(<italic>H</italic>) represents the set of child subgraphs of <italic>H</italic>. The overall complexity is therefore defined as the sum over all <italic>H</italic>. The latter varies, as the ear decomposition is not done in a deterministic way. It derives from one of many possible spanning trees of the corresponding graph and it follows that <italic>α</italic> and <italic>β</italic> can vary dramatically as investigated in (<xref rid="btx263-B9" ref-type="bibr">Höner zu Siederdissen <italic>et al.</italic>, 2013</xref>). Therefore, we generate a set of random instances of spanning trees and select the one with lowest <italic>α</italic> and <italic>β</italic> values.</p>
    <p>The implementation is written in <monospace>C++</monospace> using the boost graph library and other parts of the boost library available at <ext-link ext-link-type="uri" xlink:href="http://www.boost.org/">http://www.boost.org/</ext-link>. Using the <monospace>SWIG</monospace> framework, we offer an easy to use <monospace>Perl</monospace> and <monospace>Python</monospace> scripting interface to the library. Additionally, we developed a <monospace>Python</monospace> module so that code can be reused for many central components.</p>
  </sec>
  <sec>
    <title>3 Materials and methods</title>
    <sec>
      <title>3.1 Objective function</title>
      <p>The original objective function <italic>f</italic>(<italic>x</italic>) proposed by <xref rid="btx263-B5" ref-type="bibr">Flamm <italic>et al.</italic> (2001)</xref> for two target designs was extended to the multi-target case (<xref rid="btx263-B9" ref-type="bibr">Höner zu Siederdissen <italic>et al.</italic>, 2013</xref>) and is
<disp-formula id="E1"><label>(1)</label><mml:math id="M1"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:munder><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mi>i</mml:mi><mml:mi>M</mml:mi></mml:munderover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo></mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mo>Θ</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">︸</mml:mo></mml:munder><mml:mrow><mml:mtext>dominate</mml:mtext><mml:mo> </mml:mo><mml:mtext>ensemble</mml:mtext></mml:mrow></mml:munder><mml:mo>+</mml:mo><mml:mo>ξ</mml:mo><mml:munder><mml:munder><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:munderover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo></mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mo>Θ</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mo>Θ</mml:mo><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="false">︸</mml:mo></mml:munder><mml:mrow><mml:mtext>minimize</mml:mtext><mml:mo> </mml:mo><mml:mtext>energy</mml:mtext><mml:mo> </mml:mo><mml:mtext>difference</mml:mtext></mml:mrow></mml:munder></mml:mrow></mml:math></disp-formula>
where <italic>G</italic>(<italic>x</italic>) is the ensemble free energy, <inline-formula id="IE34"><mml:math id="IM34"><mml:mrow><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mo>Θ</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the free energy of the sequence <italic>x</italic> folded into structure Θ<sub><italic>i</italic></sub> and <italic>ξ</italic> is a weighting factor typically set to 1. The first term is to maximize the energy contribution of each target structure to the ensemble to achieve dominance whereas the second term is to minimize the energy difference of target structures to get them to the same energy level. In <xref rid="btx263-B22" ref-type="bibr">Taneda (2015)</xref> the latter was changed to <inline-formula id="IE35"><mml:math id="IM35"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msubsup><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mo>Θ</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mo>Θ</mml:mo><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> which brings most of the target structure energies close to the minimum free energy (MFE) and outliers are possible. In contrast, the original version attempts to minimize the number of outliers and therefore the distance to the MFE of all states might be higher. Either way, weighting of the two terms is essential in single objective approaches. Although objective function (1) showed good performance on two-target designs, the straight-forward extension to three or more structures neglects the varying number of target structures. We therefore modified the objective function to
<disp-formula id="E2"><label>(2)</label><mml:math id="M2"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>M</mml:mi></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mi>i</mml:mi><mml:mi>M</mml:mi></mml:munderover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo></mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mo>Θ</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>+</mml:mo><mml:mo>ξ</mml:mo><mml:mfrac><mml:mn>2</mml:mn><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:munderover><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mo>Θ</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mo>Θ</mml:mo><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
as we sum up <italic>M</italic> elements in the first term and build <inline-formula id="IE36"><mml:math id="IM36"><mml:mrow><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>M</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> differences in the latter. With this new objective function, the ratio between the two terms is independent of the number of structures <italic>M</italic>. To preserve the good performance for the two-target structure case and keep the 1:1 ratio between the two terms in the objective we set <italic>ξ</italic> to 0.5.</p>
    </sec>
    <sec>
      <title>3.2 Benchmark datasets</title>
      <p>The number of target structures is only a rough estimate of the complexity of a given design problem. If the given structural constraints have no conflicting base pairs, the complexity of the connected components are just single vertices or paths of length one. If more overlap between the structural constraints exists, paths get longer, and complex subgraphs such as cycles and blocks occur. Based on a published tri-stable switch (<xref rid="btx263-B9" ref-type="bibr">Höner zu Siederdissen <italic>et al.</italic>, 2013</xref>), which contains only two cycles and eight paths of length one, we generated more complex examples by adding a fourth and fifth structural constraint, see <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S2A–C</xref>. These three example inputs of increasing complexity were used to evaluate the implemented sampling procedures of <monospace>RNAblueprint</monospace>. The effect of uniform sampling is tested on an extreme example that contains one large and complex connected component and a base pair as well as an unpaired position. To further reduce the solution space size, two sequence constraints were introduced, see <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S2D</xref>.</p>
      <p>Comparison with existing approaches was performed on the published datasets containing two-, three- and four-target designs as well as pseudoknotted two-target structure examples (<xref rid="btx263-B22" ref-type="bibr">Taneda, 2015</xref>). The applied optimization is described in Section 3.3.</p>
    </sec>
    <sec>
      <title>3.3 Multi-state design</title>
      <p>To be able to benchmark against existing design software, we implemented an optimization approach consisting of <monospace>RNAblueprint</monospace> for uniform sequence sampling, the value of the objective function (2) to determine the cost of a solution, and an adaptive walk. The latter works as follows: Consecutive sequence candidates are generated by randomly applying one of the three sampling methods, i.e. P-local, C-local or global and calculating the cost. The new sequence is only kept if the cost is lower than the current best solution. Depending on the chosen method, one randomly selected subgraph (P-local and C-local sampling) or all subgraphs (global sampling) are redrawn. The stop condition was set to 1000, being the maximum number of optimization trails with no cost improvement. An optimization run would therefore be stopped earliest after 1000 sampling steps, which gave reasonable results for design problems with increasing complexity, see <xref ref-type="fig" rid="btx263-F4">Figure 4</xref>. To compare this approach to existing multi-target design tools we created 100 solutions for each member of the two-, three- and four-target design datasets described in <xref rid="btx263-B22" ref-type="bibr">Taneda (2015)</xref>. Energy calculations for these datasets were made using the scripting bindings of the <monospace>ViennaRNA package</monospace> v2.2.5 (<xref rid="btx263-B12" ref-type="bibr">Lorenz <italic>et al.</italic>, 2011</xref>). As we are not restricted to nested base pairs in the structural input, the pseudoknotted two-target datasets described in <xref rid="btx263-B22" ref-type="bibr">Taneda (2015)</xref> were also used with stop condition 100. This is set to be much smaller because the runtime dramatically increases when using the <monospace>Nupack package</monospace> v3.0.4 (<xref rid="btx263-B26" ref-type="bibr">Zadeh <italic>et al.</italic>, 2011b</xref>) for pseudoknotted structure prediction. Furthermore, only 30 solutions were generated for each of the latter benchmark tasks.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Results and discussion</title>
    <sec>
      <title>4.1 Effect of uniform sampling</title>
      <p>Implementing the complete graph coloring algorithm (<xref rid="btx263-B1" ref-type="bibr">Abfalter <italic>et al.</italic>, 2003</xref>; <xref rid="btx263-B9" ref-type="bibr">Höner zu Siederdissen <italic>et al.</italic>, 2013</xref>) and assigning all possible base pairs, <monospace>RNAblueprint</monospace> guarantees to uniformly sample the complete solution space. We show that this leads to an extreme value distributed frequency of uniquely found solutions (<xref ref-type="fig" rid="btx263-F3">Fig. 3A</xref>). It follows that the solution space, by means of unique solutions generated, can be efficiently explored (<xref ref-type="fig" rid="btx263-F3">Fig. 3B</xref>). The expected number of samplings required to explore <inline-formula id="IE37"><mml:math id="IM37"><mml:mi mathvariant="script">C</mml:mi></mml:math></inline-formula> is <inline-formula id="IE38"><mml:math id="IM38"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> a fact that is known for the related Coupon Collector’s problem (<xref rid="btx263-B16" ref-type="bibr">Michael Mitzenmacher, 2005</xref>). As the redundancy increases with the sample size <italic>d</italic> (known for the Birthday problem) and |<italic>C</italic>| grows not more than exponentially with <italic>n</italic>, the average number of times sequences are generated when uniform sampling is bounded by <inline-formula id="IE39"><mml:math id="IM39"><mml:mrow><mml:mtext>log</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>C</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo>Θ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Thus sequences will typically be sampled at most a linear number of times. The advantage of uniform sampling is most apparent when the amount of generated sequences <italic>d</italic> is large, <inline-formula id="IE40"><mml:math id="IM40"><mml:mrow><mml:mi>d</mml:mi><mml:mi mathvariant="normal">≳</mml:mi><mml:mo>|</mml:mo><mml:mi>C</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. In this case, uniform sampling generates a much larger number of unique solutions. To highlight these properties, we implemented a biased sampling method by using the same algorithm as <monospace>RNAblueprint</monospace>, but making every backtracking decision uniformly. Thus, we sample all articulation point combinations with the same probability independent of the number of possible solutions of the attached subgraphs. We show that the biased sampling approach produces sequences with varying probabilities heavily dependent on the structure of the dependency graph. Therefore, while generating the same amount of sequences, only a fraction of unique sequences were found compared to <monospace>RNAblueprint</monospace> (<xref ref-type="fig" rid="btx263-F3">Fig. 3B</xref>). Note, that for very small <italic>d</italic> the curves are almost identical, as expected. However, utilizing an approach that produces many different solutions, avoids heavy re-evaluation of already found sequences.
</p>
      <fig id="btx263-F3" orientation="portrait" position="float">
        <label>Fig. 3.</label>
        <caption>
          <p>Differences in uniform and biased stochastic sampling shown on a small example with a rather complex dependency graph, see <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S2D</xref>. (<bold>A</bold>) The histogram shows how frequent unique sequences were found when sampling completely new candidates using <monospace>RNAblueprint</monospace> and the biased sampling method. In total 9.6 × 10<sup>9</sup> sequences (sample size <italic>d</italic>) were sampled from 4.1 × 10<sup>7</sup> possible unique sequences (size of solution space |<italic>C</italic>|). While uniform sampling led to an extreme value distribution with the mean (2.57) count being slightly above the relative sample size and the maximum number of times a sequence is rediscovered being 15, biased sampling led to a input specific distorted distribution where a sequence is found 4.78 times on average and 227 times maximal. (<bold>B</bold>) When the sample size was chosen to be much bigger than the solution space (∼ 230%), only about 50% of all possible sequences with biased sampling were obtained for this example, while the uniform sampling method generated about 90%. The performance of <monospace>RNAblueprint</monospace> is independent of the underlying problem whereas the curve of the other approaches heavily depends on the properties of the dependency graph</p>
        </caption>
        <graphic xlink:href="btx263f3"/>
      </fig>
      <p>A simplified version of the graph coloring algorithm was implemented in <monospace>MODENA</monospace> (<xref rid="btx263-B22" ref-type="bibr">Taneda, 2015</xref>). Therein a naïve nucleotide assignment algorithm is used that is able to generate solutions of a design problem but not uniform sampling of the solution space. Furthermore, during the assignment of paired nucleotides without a sequence constraint, the G-U base pair is neglected unless a sequence constraint forces such an assignment. This generates a biased initial population of sequences that are subsequently optimized by applying a genetic algorithm. Unfortunately, <monospace>MODENA</monospace> is available as binary only, of which the maximum population size is restricted to 1000 and at least one iteration of the genetic algorithm optimization is enforced. Therefore, we could not compare the effect of the implemented nucleotide assignment algorithm alone. However, their sequence sampling essentially corresponds to our biased sampling method described in the previous paragraph.</p>
      <p>The Haskell prototype implementation in <xref rid="btx263-B9" ref-type="bibr">Höner zu Siederdissen <italic>et al.</italic> (2013)</xref>, <monospace>RNAdesign</monospace>, used lazy enumeration of all solutions and therefore allows uniform sampling. It opts for <inline-formula id="IE41"><mml:math id="IM41"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> sampling, with low overhead in components. However, this applies only for sufficiently small problems. The way the prototype samples does not scale well for designing sequences with many and complex constraints as each component may get prohibitively large. These limitations get obvious when comparing the memory and CPU requirements of both implementations. While <monospace>RNAblueprint</monospace> needs 7 MB and about 0.35 s to generate one compatible sequence (without any optimization) for the complex design example shown in <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S2D</xref> the prototype implementation needs 15 GB and about 45.8 s on an Intel i7-6700, 3.4 GHz machine. The memory requirement is not independent of the sample size and further increases during the sampling process. We are aiming on a flexible approach where the sequence sampling step should not be the bottleneck as it might be necessary to generate multiple dependency graphs for exploring sequence and solutions spaces and application of computationally demanding objective functions, e.g. including pseudoknot prediction, will anyway slow down the design process.</p>
      <p>In summary, our method is capable of generating sequences with a well defined distribution independent of the input constraints or the sample and solution space size. Note, that <monospace>RNAblueprint</monospace> can be easily incorporated in any multi-state design software such as <monospace>MODENA</monospace> in order to explore the complete solution space of complex multi-state design problems in an unbiased way.</p>
    </sec>
    <sec>
      <title>4.2 Sequence sampling</title>
      <p>In a typical RNA design scenario, sequences compatible with the structural constraints are scored using an objective function, which gets either minimized or maximized. Thereby, the sequence space is transformed into a landscape of complex and typically unknown structure that needs to be explored. Sampling completely new sequences generates solutions distributed over the complete landscape. This way, for an infinite sampling time the global optimum is always found. However, the optimization is rather slow because in each sampling step the reachable neighborhood is the complete solution space. The solution space of small examples is already of size 4.1 × 10<sup>7</sup> to 1.4 × 10<sup>14</sup> (<xref ref-type="supplementary-material" rid="sup1">Supplementary Fig. S2</xref>) and therefore only a small fraction of all solutions is evaluated during a typical optimization run. The other sampling methods, i.e. P-local and C-local, described in Section 2 dramatically reduced the size of the reachable neighborhood. An adaptive walk using these move steps led to the solution ending up in local minima. The quality of these minima and how fast they were reached depends on the number of nucleotides changed in each step, <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S3</xref>.</p>
      <p>In <xref ref-type="fig" rid="btx263-F4">Figure 4</xref>, the published three state design example (<xref rid="btx263-B9" ref-type="bibr">Höner zu Siederdissen <italic>et al.</italic>, 2013</xref>) was extended to four and five input structures. The extension was made in a way that the complexity of the dependency graph from short paths and cycles in the three state example was increased to larger connected components, <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S2</xref>. We compared the performance of different sampling methods that differ in the size of their largest move step, see <xref ref-type="fig" rid="btx263-F4">Figure 4</xref>. One method, called <italic>global</italic>, always generates a completely new sequence. When sample <italic>C-local</italic> is applied, the assignments of a randomly selected connected component are redrawn. The random selection is weighted by the number of possible solutions associated to the connected components. In contrast, <italic>P-local</italic> resamples only vertices which are not articulation points of a randomly selected path.
</p>
      <fig id="btx263-F4" orientation="portrait" position="float">
        <label>Fig. 4.</label>
        <caption>
          <p>Cost change during the optimization procedure using different move steps and dependency graphs. We minimized function (2) with <italic>ξ</italic> = 0.5 to calculate the cost. The x-axis shows the number of sampled sequences while the y-axis resembles the mean cost from 100 optimization runs, normalized to the mean cost of the initial randomly chosen sequences. For each trend curve the confidence interval (± <italic>σ</italic>) is indicated. Three different move steps (P-local, C-local and global) and an additional run, where one of these moves was randomly picked at every step (random), are compared. At the leftmost plot a very simple dependency graph was generated, only consisting of paths and two cycles, in the middle plot the graph already contains a block and on the right hand side many vertices are captured in one big connected component. The slope of the cost change mainly results from two aspects, the rejection rate and the quality of the newly found solutions. Both are heavily dependent on the size of the move step, therefore we see a change from the left to the right plot, as the move steps of C-local, global and random become bigger, <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S3</xref></p>
        </caption>
        <graphic xlink:href="btx263f4"/>
      </fig>
      <p>If the dependency graph contained only short paths and cycles (three state example), the C-local sampling approach was similar to the P-local sampling, i.e. reached a local minimum relatively fast and the cost converged. The relative mean cost difference between P-local and C-local sampling minima results from the fact that articulation points were redrawn by the latter only. This allowed a maximum step size of up to six nucleotides (complete circle) compared to three nucleotides (longest path), <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S3</xref>. The more complex the dependency graph, i.e. the more articulation points and larger connected components exist, the more pronounced this difference between P-local and C-local sampling, <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S3</xref>. If one large connected component contained most of the bases (five state example), performing a C-local sampling where all assignments of the large component are most likely reassigned (<xref ref-type="supplementary-material" rid="sup1">Supplementary Fig. S3</xref>), was similar to a completely new sampled sequence, i.e. the slope of the corresponding curves in <xref ref-type="fig" rid="btx263-F4">Figure 4</xref> are similar. However, the hamming distance to reachable neighbors was different for C-local and global sampling, <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S3</xref>. Reaching a local minimum indicates that most likely no further cost improvement can be made using the same sampling method. For the analyzed examples applying a simulated annealing approach, i.e. using an adaptive walk that allows for the acceptance of worse solutions on the way, did only slightly improve the results, see <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S4</xref>. Changing the method and thereby changing the move step allows other local minima with better solutions to be reached. Interestingly, our analyses showed that randomly changing the sampling method in each step, <italic>random</italic> in <xref ref-type="fig" rid="btx263-F4">Figure 4</xref>, gave significantly better results faster in most cases. We investigated the reachable neighborhood of selected time points during optimization of the four state design example in more detail, <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S5</xref>. After 1000 sampling steps, the mean cost of sequences optimized with the random approach was significantly lower than the cost reached with global sampling (student’s <italic>t</italic>-test <italic>P</italic>-value: 10<sup>–</sup><sup>55</sup>). Furthermore, the number of neighbors with a cost below the current best solution was similar, <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S5</xref>. At the end point of the trend curves (after 500 000 sampling trails), C-local and random sampling reached the same mean costs and within their analyzed neighborhood of size 350 600 no better solution was found, <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S5</xref>. Interestingly, the sequences optimized with global sampling did not reach the same mean cost and the likelihood of generating a better solution was very low, <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S5</xref>. We stress again that these observations are highly dependent on the design problem, e.g. the complexity of the dependency graph and the length of the sequence to be designed. However, we show in the following that applying the random sampling method to a diverse benchmark dataset of nested and pseudoknotted structural input gives reasonably good results.</p>
    </sec>
    <sec>
      <title>4.3 Impact of normalization and weighting</title>
      <p>To analyze the effect of the corrected objective function (2) and the applied optimization procedure we used the recently published benchmark dataset (<xref rid="btx263-B22" ref-type="bibr">Taneda, 2015</xref>), which consists of two-, three- and four-target design problems as well as three pseudoknotted two-target sets. These examples were either taken from naturally occurring RNAs that are able to switch between structural states or were generated in a way that reachable, sub-optimal structures are taken as input constraints for the design process. <monospace>RNAblueprint</monospace> itself does no optimization but rather implements a move set on uniformly sampled sequences. We implemented an adaptive walk that, given a start sequence, randomly selects one of the three sampling methods and applies it to generate the next sequence candidate. The generated sequence is retained if its cost is lower than the best prior solution. On the small examples evaluated in <xref ref-type="fig" rid="btx263-F4">Figure 4</xref>, this approach adapted best to the varying complexity of the underlying dependency graphs. To score sequences, we applied an objective function that ensures on one hand that the target structures of a good solution dominate the ensemble while on the other hand the energy difference between the target structures is minimized. In its original version (1), proposed for the two state design case in (<xref rid="btx263-B5" ref-type="bibr">Flamm <italic>et al.</italic>, 2001</xref>), the corresponding two terms were summed up without any weighting. Designs for two states gave reasonable results compared to other approaches, see <xref rid="btx263-T1" ref-type="table">Table 1</xref>. However, a systematic extension to three or even more states needs individual normalization of the individual terms. Therefore, we proposed a corrected objective function (2), which is adjusted to the good performing original two state objective. Especially for the four structure designs this yielded a significant improvement over the original one, see <xref rid="btx263-T1" ref-type="table">Table 1</xref>. Note, when using a multi-objective approach it is assumed that the weighting is implicitly found during optimization (<xref rid="btx263-B22" ref-type="bibr">Taneda, 2015</xref>).
<table-wrap id="btx263-T1" orientation="portrait" position="float"><label>Table 1.</label><caption><p>Comparison of currently available approaches to solve multi-target designs</p></caption><table frame="hsides" rules="groups"><colgroup span="1"><col valign="top" align="left" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="center" span="1"/></colgroup><thead><tr><th colspan="13" rowspan="1">Nested Structure Input<hr/></th><th colspan="6" rowspan="1">Pseudoknotted Structure Input<hr/></th></tr><tr><th rowspan="1" colspan="1"/><th colspan="6" rowspan="1"><monospace>RNAblueprint</monospace><hr/></th><th colspan="3" rowspan="1"><monospace>MODENA</monospace><xref ref-type="table-fn" rid="tblfn2"><sup>a</sup></xref><hr/></th><th colspan="3" rowspan="1"><monospace>Frnakenstein</monospace><xref ref-type="table-fn" rid="tblfn2"><sup>a</sup></xref><hr/></th><th colspan="3" rowspan="1"><monospace>RNAblueprint</monospace><hr/></th><th colspan="3" rowspan="1"><monospace>MODENA</monospace><xref ref-type="table-fn" rid="tblfn2"><sup>a</sup></xref><hr/></th></tr><tr><th rowspan="1" colspan="1"/><th colspan="3" rowspan="1"><italic>original</italic><hr/></th><th colspan="3" rowspan="1"><italic>corrected</italic><hr/></th><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/></tr><tr><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1">2str</th><th rowspan="1" colspan="1">3str</th><th rowspan="1" colspan="1">4str</th><th rowspan="1" colspan="1">2str</th><th rowspan="1" colspan="1">3str</th><th rowspan="1" colspan="1">4str</th><th rowspan="1" colspan="1">2str</th><th rowspan="1" colspan="1">3str</th><th rowspan="1" colspan="1">4str</th><th rowspan="1" colspan="1">2str</th><th rowspan="1" colspan="1">3str</th><th rowspan="1" colspan="1">4str</th><th rowspan="1" colspan="1">LE80</th><th rowspan="1" colspan="1">PK60</th><th rowspan="1" colspan="1">PK80</th><th rowspan="1" colspan="1">LE80</th><th rowspan="1" colspan="1">PK60</th><th rowspan="1" colspan="1">PK80</th></tr></thead><tbody><tr><td rowspan="1" colspan="1"><italic>μ</italic>(<italic>δe</italic><sub>1</sub>)</td><td rowspan="1" colspan="1"><bold>0.28</bold></td><td rowspan="1" colspan="1">0.22</td><td rowspan="1" colspan="1">1.46</td><td rowspan="1" colspan="1">0.31</td><td rowspan="1" colspan="1"><bold>0.10</bold></td><td rowspan="1" colspan="1"><bold>0.48</bold></td><td rowspan="1" colspan="1">0.38</td><td rowspan="1" colspan="1">0.27</td><td rowspan="1" colspan="1">0.84</td><td rowspan="1" colspan="1">0.35</td><td rowspan="1" colspan="1">0.39</td><td rowspan="1" colspan="1">0.92</td><td rowspan="1" colspan="1"><bold>0.82</bold></td><td rowspan="1" colspan="1"><bold>0.03</bold></td><td rowspan="1" colspan="1"><bold>0.15</bold></td><td rowspan="1" colspan="1">0.89</td><td rowspan="1" colspan="1">0.12</td><td rowspan="1" colspan="1">0.29</td></tr><tr><td rowspan="1" colspan="1"><inline-formula id="IE42"><mml:math id="IM42"><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mo>δ</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td><td rowspan="1" colspan="1"><bold>0.00</bold></td><td rowspan="1" colspan="1"><bold>0.00</bold></td><td rowspan="1" colspan="1">0.70</td><td rowspan="1" colspan="1"><bold>0.00</bold></td><td rowspan="1" colspan="1"><bold>0.00</bold></td><td rowspan="1" colspan="1"><bold>0.05</bold></td><td rowspan="1" colspan="1">0.10</td><td rowspan="1" colspan="1"><bold>0.00</bold></td><td rowspan="1" colspan="1">0.39</td><td rowspan="1" colspan="1">0.10</td><td rowspan="1" colspan="1">0.10</td><td rowspan="1" colspan="1">0.55</td><td rowspan="1" colspan="1">0.30</td><td rowspan="1" colspan="1"><bold>0.00</bold></td><td rowspan="1" colspan="1"><bold>0.00</bold></td><td rowspan="1" colspan="1"><bold>0.20</bold></td><td rowspan="1" colspan="1"><bold>0.00</bold></td><td rowspan="1" colspan="1"><bold>0.00</bold></td></tr><tr><td rowspan="1" colspan="1"><italic>μ</italic>(<italic>δe</italic><sub>2</sub>)</td><td rowspan="1" colspan="1"><bold>0.34</bold></td><td rowspan="1" colspan="1">0.43</td><td rowspan="1" colspan="1">1.96</td><td rowspan="1" colspan="1">0.36</td><td rowspan="1" colspan="1"><bold>0.26</bold></td><td rowspan="1" colspan="1"><bold>1.21</bold></td><td rowspan="1" colspan="1">0.76</td><td rowspan="1" colspan="1">0.54</td><td rowspan="1" colspan="1">1.78</td><td rowspan="1" colspan="1">1.09</td><td rowspan="1" colspan="1">0.96</td><td rowspan="1" colspan="1">1.89</td><td rowspan="1" colspan="1"><bold>1.09</bold></td><td rowspan="1" colspan="1"><bold>0.08</bold></td><td rowspan="1" colspan="1"><bold>0.17</bold></td><td rowspan="1" colspan="1">1.22</td><td rowspan="1" colspan="1">0.32</td><td rowspan="1" colspan="1">0.56</td></tr><tr><td rowspan="1" colspan="1"><inline-formula id="IE43"><mml:math id="IM43"><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mo>δ</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td><td rowspan="1" colspan="1"><bold>0.00</bold></td><td rowspan="1" colspan="1">0.20</td><td rowspan="1" colspan="1">1.30</td><td rowspan="1" colspan="1"><bold>0.00</bold></td><td rowspan="1" colspan="1"><bold>0.10</bold></td><td rowspan="1" colspan="1"><bold>0.80</bold></td><td rowspan="1" colspan="1">0.50</td><td rowspan="1" colspan="1">0.30</td><td rowspan="1" colspan="1">1.40</td><td rowspan="1" colspan="1">0.60</td><td rowspan="1" colspan="1">0.80</td><td rowspan="1" colspan="1">1.60</td><td rowspan="1" colspan="1"><bold>0.55</bold></td><td rowspan="1" colspan="1"><bold>0.00</bold></td><td rowspan="1" colspan="1"><bold>0.00</bold></td><td rowspan="1" colspan="1"><bold>0.55</bold></td><td rowspan="1" colspan="1"><bold>0.00</bold></td><td rowspan="1" colspan="1">0.05</td></tr></tbody></table><table-wrap-foot><fn id="tblfn1"><label>*</label><p>Results of two-, three- and four-target designs are shown. For <monospace>RNAblueprint</monospace> and <monospace>MODENA</monospace> two-target designs of pseudoknotted structures are also presented. For each resulting sequence, we evaluated the difference between the most stable target structure to the ground state (<italic>δe</italic><sub>1</sub>) and the highest energy target structure to the ground state (<italic>δe</italic><sub>2</sub>). The mean (<italic>μ</italic>) and median (<inline-formula id="IE44"><mml:math id="IM44"><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>) energy difference for 100 and 30 generated sequences is presented for the nested and pseudoknotted structure input, respectively. Performance of the individual sequences is listed in <xref ref-type="supplementary-material" rid="sup1">Supplementary Tables S2–S7</xref>. Boldface values highlight the best performing approach on a specific dataset. For <monospace>RNAblueprint</monospace> the values for the <italic>original</italic> (1) and <italic>corrected</italic> (2) objective functions are listed.</p></fn><fn id="tblfn2"><label>a</label><p>Values taken from the original publication (<xref rid="btx263-B22" ref-type="bibr">Taneda, 2015</xref>).</p></fn></table-wrap-foot></table-wrap></p>
      <p>Comparing the results of our naïve optimization procedure with multi-objective approaches that implement complex genetic algorithms to optimize sequences we performed similar or even better on the benchmark dataset as measured by <italic>δe</italic><sub>1</sub>, i.e. the difference of the lowest energy target structure to the ground state and <italic>δe</italic><sub>2</sub>, i.e. the difference between the ground state and the highest energy target structure, on the benchmark dataset. Furthermore, we also compared how often the desired target structures are energetically equal to the predicted MFE structure, see <xref ref-type="supplementary-material" rid="sup1">Supplementary Tables S2–S7</xref>. These values are termed <italic>n<sub>i</sub></italic>, <italic>i</italic> being the number of target structures with equal energy to the MFE. Given this benchmark measure, <monospace>MODENA</monospace> and <monospace>RNAblueprint</monospace> performed similarly. A notable difference between our approach and <monospace>MODENA</monospace> is that the latter uses a genetic algorithm to optimize a population of 500 individuals of which the best 100 are taken, while we performed 100 independent optimizations. We expect to get similar sequences from a population-based approach while the solutions generated with our approach are extremely diverse.</p>
      <p>Although <italic>δe</italic><sub>1</sub>, <italic>δe</italic><sub>2</sub> and <italic>n<sub>i</sub></italic> together are a good measure of the solution quality of this specific design problem, they do not describe the actual functionality of the switch <italic>in vitro</italic> or <italic>in vivo</italic>. An objective function describing every aspect necessary to create a functional switch might contain many more features, some of which cannot easily be calculated. Furthermore, it is questionable whether the creation of 100 solutions is even useful. It might be better to run the optimization longer and retrieve 10-20 heterogeneous solutions, as this is a more realistic number for experimental validation.</p>
    </sec>
    <sec>
      <title>4.4 Flexibility matters</title>
      <p>Three example objective functions were proposed by Flamm and coworkers to design two-state temperature and structural switches (<xref rid="btx263-B5" ref-type="bibr">Flamm <italic>et al.</italic>, 2001</xref>). Those objectives have been adapted to multi-state design and are still used to benchmark new software (<xref rid="btx263-B9" ref-type="bibr">Höner zu Siederdissen <italic>et al.</italic>, 2013</xref>; <xref rid="btx263-B22" ref-type="bibr">Taneda, 2015</xref>). <monospace>MODENA</monospace> enables the user for the first time to choose from a catalog of different structure prediction methods to calculate features of a given sequence and derive new objectives. However, this catalog is fixed and therefore the complete functionality of the applied software might not be available. This is especially true for recent developments, such as the soft constraint framework implemented in the <monospace>ViennaRNA package</monospace> (<xref rid="btx263-B13" ref-type="bibr">Lorenz <italic>et al.</italic>, 2016</xref>) and the test tube ensemble defect available in <monospace>NUPACK</monospace> (<xref rid="btx263-B24" ref-type="bibr">Wolfe and Pierce, 2015</xref>). Furthermore, the methods to optimize sequences, in the case of <monospace>MODENA</monospace> by applying a genetic algorithm, cannot be changed. Therefore, we implemented <monospace>RNAblueprint</monospace> as a library and equipped this sequence generator with a flexible scripting interface where the user can easily implement its own optimization procedures and come up with new objective functions. Thus, features such as molecule concentrations, specific nucleotide compositions, or various probabilities can be captured in the design process.</p>
    </sec>
  </sec>
  <sec>
    <title>5 Conclusion</title>
    <p>We have developed a software solution that makes it possible to uniformly sample RNA sequences compatible with structural and sequence constraints. Sampling in an uniform way from a well defined solution space ensures to efficiently investigate the entire solution space and avoids heavy re-evaluation of repeatedly generated sequences. Therefore, it is possible to review many more solutions, which potentially leads to better results. We are currently investigating how to adapt the graph coloring algorithm to implement other desired sampling distributions, such as Boltzmann sampling according to a state energy model in a manner similar to what is done for single target design in <monospace>IncaRNAtion</monospace> (<xref rid="btx263-B19" ref-type="bibr">Reinharz <italic>et al.</italic>, 2013</xref>). This way promising sequences that are able and likely to fold into the target structures would be already favored during the sampling procedure.</p>
    <p>Scripting interfaces make it easy to freely combine different optimization algorithms and to incorporate evaluations of different software packages into the objective function. We used the <monospace>NUPACK</monospace> and the <monospace>ViennaRNA</monospace> package to design multi-stable RNA structures with and without pseudoknots, respectively. With the scripting interface, any software such as the recently published <monospace>RNA shapes studio</monospace> (<xref rid="btx263-B11" ref-type="bibr">Janssen and Giegerich, 2015</xref>) and the approach by Wolfe and Pierce to reduce the amount of unwanted complexes when designing interacting molecules (<xref rid="btx263-B24" ref-type="bibr">Wolfe and Pierce, 2015</xref>), can be easily integrated. As the correct sequence generation problem for a set of fixed structural constraints is now efficiently solved, further research can focus on the challenging task of finding objective functions that better describe the goals and functions of RNA molecules. Using <monospace>RNAblueprint</monospace> it is now feasible to explore a much broader range of objectives and it is easy to adapt and recombine existing software and optimization techniques to generate an RNA molecule that perfectly suits the specific needs and goals of the task.</p>
    <p>We illustrated the usefulness of our approach with typical but small sample applications. A general solution for solving all the diverse RNA design problems does not exist and there is also no universal way how to benchmark existing tools or novel approaches against each other. Applied measurements heavily depend on the goal and the objective of the design and therefore user knowledge is always necessary to choose an appropriate optimization method, move set and objective function.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="sup1">
      <label>Supplementary Data</label>
      <media xlink:href="btx263_supplement.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgements</title>
    <p>Thanks to Christian Höner zu Siederdissen for assistance with the prototype Haskell implementation, Peter F. Stadler and Daniel Merkle for fruitful discussion and our private <monospace>boost</monospace> help desk Jakob L. Andersen. We thank Life Science Editors for proofreading and editing. Computational results have been achieved in part using the Vienna Scientific Cluster (VSC). We further like to thank the reviewers helping us to improve the manuscript significantly.</p>
    <sec>
      <title>Funding</title>
      <p>The project RiboNets acknowledges the financial support of the Future and Emerging Technologies (FET) programme within the Seventh Framework Programme for Research of the European Commission, under FET-Open grant number: 323987. This work was furthermore supported by the COST-Action CM1304 ‘Systems Chemistry’, the FWF projects SFB F43 ‘RNA regulation of the transcriptome’ and ‘Doktoratskolleg RNA Biology W1207-B09’.</p>
      <p><italic>Conflict of Interest</italic>: none declared.</p>
    </sec>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="btx263-B1">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Abfalter</surname><given-names>I.G.</given-names></name></person-group><etal>et al</etal> (<year>2003</year>) <chapter-title>Design of multi-stable nucleic acid sequences</chapter-title> In: <person-group person-group-type="editor"><name name-style="western"><surname>Mewes</surname><given-names>H.W.</given-names></name></person-group><etal>et al</etal> (eds.) In: <source>Proceedings of the German Conference on Bioinformatics (GCB)</source>. 
<publisher-name>Belleville Verlag, Michael Farin</publisher-name>, 
<publisher-loc>München</publisher-loc>, vol. <volume>1</volume>, pp. <fpage>1</fpage>–<lpage>7</lpage>.</mixed-citation>
    </ref>
    <ref id="btx263-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Berens</surname><given-names>C.</given-names></name>, <name name-style="western"><surname>Suess</surname><given-names>B.</given-names></name></person-group> (<year>2015</year>) 
<article-title>Riboswitch engineering — making the all-important second and third steps</article-title>. <source>Curr. Opin. Biotechnol</source>., <volume>31</volume>, <fpage>10</fpage>–<lpage>15</lpage>.<pub-id pub-id-type="pmid">25137633</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chappell</surname><given-names>J.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Creating small transcription activating RNAs</article-title>. <source>Nat. Chem. Biol</source>., <volume>11</volume>, <fpage>214</fpage>–<lpage>220</lpage>.<pub-id pub-id-type="pmid">25643173</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Espah-Borujeni</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Automated physics-based design of synthetic riboswitches from diverse RNA aptamers</article-title>. <source>Nucleic Acids Res</source>., <fpage>gkv1289.</fpage></mixed-citation>
    </ref>
    <ref id="btx263-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Flamm</surname><given-names>C.</given-names></name></person-group><etal>et al</etal> (<year>2001</year>) 
<article-title>Design of multistable RNA molecules</article-title>. <source>RNA</source>, <volume>7</volume>, <fpage>254</fpage>–<lpage>265</lpage>.<pub-id pub-id-type="pmid">11233982</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Garcia-Martin</surname><given-names>J.A.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>RNAiFold 2.0: a web server and software to design custom and rfam-based RNA molecules</article-title>. <source>Nucleic Acids Res</source>., <volume>43</volume>, <fpage>W513</fpage>–<lpage>W521</lpage>.<pub-id pub-id-type="pmid">26019176</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Green</surname><given-names>A.A.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Toehold switches: de-novo-designed regulators of gene expression</article-title>. <source>Cell</source>, <volume>159</volume>, <fpage>925</fpage>–<lpage>939</lpage>.<pub-id pub-id-type="pmid">25417166</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Hofacker</surname><given-names>I.L.</given-names></name></person-group><etal>et al</etal> (<year>1994</year>) 
<article-title>Fast folding and comparison of RNA secondary structures</article-title>. <source>Monatshefte Für Chemie/Chem. Mon</source>., <volume>125</volume>, <fpage>167</fpage>–<lpage>188</lpage>.</mixed-citation>
    </ref>
    <ref id="btx263-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Höner zu Siederdissen</surname><given-names>C.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>Computational design of RNAs with complex energy landscapes</article-title>. <source>Biopolymers</source>, <volume>99</volume>, <fpage>1124</fpage>–<lpage>1136</lpage>.<pub-id pub-id-type="pmid">23818234</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Isaacs</surname><given-names>F.J.</given-names></name></person-group><etal>et al</etal> (<year>2004</year>) 
<article-title>Engineered riboregulators enable post-transcriptional control of gene expression</article-title>. <source>Nat. Biotechnol</source>., <volume>22</volume>, <fpage>841</fpage>–<lpage>847</lpage>.<pub-id pub-id-type="pmid">15208640</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Janssen</surname><given-names>S.</given-names></name>, <name name-style="western"><surname>Giegerich</surname><given-names>R.</given-names></name></person-group> (<year>2015</year>) 
<article-title>The RNA shapes studio</article-title>. <source>Bioinformatics</source>, <volume>31</volume>, <fpage>423</fpage>–<lpage>425</lpage>.<pub-id pub-id-type="pmid">25273103</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lorenz</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2011</year>) 
<article-title>ViennaRNA Package 2.0</article-title>. <source>Algorithms Mol. Biol</source>., <volume>6</volume>, <fpage>26.</fpage><pub-id pub-id-type="pmid">22115189</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lorenz</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>RNA folding with hard and soft constraints</article-title>. <source>Algorithms Mol. Biol</source>., <volume>11</volume>, <fpage>8.</fpage><pub-id pub-id-type="pmid">27110276</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lyngso</surname><given-names>R.B.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>Frnakenstein: multiple target inverse RNA folding</article-title>. <source>BMC Bioinformatics</source>, <volume>13</volume>, <fpage>260.</fpage><pub-id pub-id-type="pmid">23043260</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Maon</surname><given-names>Y.</given-names></name></person-group><etal>et al</etal> (<year>1986</year>) 
<article-title>Parallel ear decomposition search (EDS) and ST-numbering in graphs</article-title>. <source>Theor. Comp. Sci</source>., <volume>47</volume>, <fpage>277</fpage>–<lpage>298</lpage>.</mixed-citation>
    </ref>
    <ref id="btx263-B16">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Michael Mitzenmacher</surname><given-names>E.U.</given-names></name></person-group> (<year>2005</year>) <source>Probability and Computing: Randomized Algorithms and Probabilistic Analysis</source>. 
<publisher-name>Cambridge University</publisher-name>, 
<publisher-loc>Puerto Rico</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btx263-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Neupert</surname><given-names>J.</given-names></name></person-group><etal>et al</etal> (<year>2008</year>) 
<article-title>Design of simple synthetic RNA thermometers for temperature-controlled gene expression in <italic>Escherichia coli</italic></article-title>. <source>Nucleic Acids Res</source>., <volume>36</volume>, <fpage>e124.</fpage><pub-id pub-id-type="pmid">18753148</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Qi</surname><given-names>L.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>Engineering naturally occurring trans-acting non-coding RNAs to sense molecular signals</article-title>. <source>Nucleic Acids Res</source>, <volume>40</volume>, <fpage>5775</fpage>–<lpage>5786</lpage>.<pub-id pub-id-type="pmid">22383579</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Reinharz</surname><given-names>V.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>A weighted sampling algorithm for the design of RNA sequences with targeted secondary structure and nucleotide distribution</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>i308</fpage>–<lpage>i315</lpage>.<pub-id pub-id-type="pmid">23812999</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Rodrigo</surname><given-names>G.</given-names></name>, <name name-style="western"><surname>Jaramillo</surname><given-names>A.</given-names></name></person-group> (<year>2014</year>) 
<article-title>RiboMaker: computational design of conformation-based riboregulation</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>2508</fpage>–<lpage>2510</lpage>.<pub-id pub-id-type="pmid">24833802</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Rodrigo</surname><given-names>G.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>De novo automated design of small RNA circuits for engineering synthetic riboregulation in living cells</article-title>. <source>Proc. Natl. Acad. Sci. U. S. A</source>., <volume>109</volume>, <fpage>15271</fpage>–<lpage>15276</lpage>.<pub-id pub-id-type="pmid">22949707</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Taneda</surname><given-names>A.</given-names></name></person-group> (<year>2015</year>) 
<article-title>Multi-objective optimization for RNA design with multiple target secondary structures</article-title>. <source>BMC Bioinformatics</source>, <volume>16</volume>, <fpage>280.</fpage><pub-id pub-id-type="pmid">26335276</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Wachsmuth</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>De novo design of a synthetic riboswitch that regulates transcription termination</article-title>. <source>Nucleic Acids Res</source>., <volume>41</volume>, <fpage>2541</fpage>–<lpage>2551</lpage>.<pub-id pub-id-type="pmid">23275562</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Wolfe</surname><given-names>B.R.</given-names></name>, <name name-style="western"><surname>Pierce</surname><given-names>N.A.</given-names></name></person-group> (<year>2015</year>) 
<article-title>Sequence design for a test tube of interacting nucleic acid strands</article-title>. <source>ACS Synth. Biol</source>., <volume>4</volume>, <fpage>1086</fpage>–<lpage>1100</lpage>.<pub-id pub-id-type="pmid">25329866</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Zadeh</surname><given-names>J.N.</given-names></name></person-group><etal>et al</etal> (<year>2011a</year>) 
<article-title>Nucleic acid sequence design via efficient ensemble defect optimization</article-title>. <source>J. Comput. Chem</source>., <volume>32</volume>, <fpage>439</fpage>–<lpage>452</lpage>.<pub-id pub-id-type="pmid">20717905</pub-id></mixed-citation>
    </ref>
    <ref id="btx263-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Zadeh</surname><given-names>J.N.</given-names></name></person-group><etal>et al</etal> (<year>2011b</year>) 
<article-title>NUPACK: analysis and design of nucleic acid systems</article-title>. <source>J. Comput. Chem</source>., <volume>32</volume>, <fpage>170</fpage>–<lpage>173</lpage>.<pub-id pub-id-type="pmid">20645303</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
