<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3637623</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-14-117</article-id>
    <article-id pub-id-type="pmid">23557111</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-14-117</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methodology Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>CUDASW++ 3.0: accelerating Smith-Waterman protein database search by coupling CPU and GPU SIMD instructions</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes" id="A1">
        <name>
          <surname>Liu</surname>
          <given-names>Yongchao</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>liuy@uni-mainz.de</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Wirawan</surname>
          <given-names>Adrianto</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>wirawan@uni-mainz.de</email>
      </contrib>
      <contrib contrib-type="author" corresp="yes" id="A3">
        <name>
          <surname>Schmidt</surname>
          <given-names>Bertil</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>bertil.schmidt@uni-mainz.de</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Institut für Informatik, Johannes Gutenberg Universität Mainz, Mainz, Germany</aff>
    <pub-date pub-type="collection">
      <year>2013</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>4</day>
      <month>4</month>
      <year>2013</year>
    </pub-date>
    <volume>14</volume>
    <fpage>117</fpage>
    <lpage>117</lpage>
    <history>
      <date date-type="received">
        <day>21</day>
        <month>12</month>
        <year>2012</year>
      </date>
      <date date-type="accepted">
        <day>15</day>
        <month>3</month>
        <year>2013</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2013 Liu et al.; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2013</copyright-year>
      <copyright-holder>Liu et al.; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1471-2105/14/117"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>The maximal sensitivity for local alignments makes the Smith-Waterman algorithm a popular choice for protein sequence database search based on pairwise alignment. However, the algorithm is compute-intensive due to a quadratic time complexity. Corresponding runtimes are further compounded by the rapid growth of sequence databases.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We present CUDASW++ 3.0, a fast Smith-Waterman protein database search algorithm, which couples CPU and GPU SIMD instructions and carries out concurrent CPU and GPU computations. For the CPU computation, this algorithm employs SSE-based vector execution units as accelerators. For the GPU computation, we have investigated for the first time a GPU SIMD parallelization, which employs CUDA PTX SIMD video instructions to gain more data parallelism beyond the SIMT execution model. Moreover, sequence alignment workloads are automatically distributed over CPUs and GPUs based on their respective compute capabilities. Evaluation on the Swiss-Prot database shows that CUDASW++ 3.0 gains a performance improvement over CUDASW++ 2.0 up to 2.9 and 3.2, with a maximum performance of 119.0 and 185.6 GCUPS, on a single-GPU GeForce GTX 680 and a dual-GPU GeForce GTX 690 graphics card, respectively. In addition, our algorithm has demonstrated significant speedups over other top-performing tools: SWIPE and BLAST+.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>CUDASW++ 3.0 is written in CUDA C++ and PTX assembly languages, targeting GPUs based on the Kepler architecture. This algorithm obtains significant speedups over its predecessor: CUDASW++ 2.0, by benefiting from the use of CPU and GPU SIMD instructions as well as the concurrent execution on CPUs and GPUs. The source code and the simulated data are available at <ext-link ext-link-type="uri" xlink:href="http://cudasw.sourceforge.net">http://cudasw.sourceforge.net</ext-link>.</p>
      </sec>
    </abstract>
    <kwd-group>
      <kwd>Smith-Waterman</kwd>
      <kwd>CUDA</kwd>
      <kwd>GPU</kwd>
      <kwd>PTX SIMD instructions</kwd>
      <kwd>Concurrent execution</kwd>
    </kwd-group>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>The Smith-Waterman (SW) algorithm [<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B2">2</xref>] is a dynamic-programming-based approach to identify optimal local alignments of biological sequence pairs. Due to its maximal sensitivity for local alignments, this algorithm is a fundamental operation in bioinformatics, including biological sequence database search, multiple sequence alignment [<xref ref-type="bibr" rid="B3">3</xref>,<xref ref-type="bibr" rid="B4">4</xref>] and next-generation sequencing read alignment [<xref ref-type="bibr" rid="B5">5</xref>,<xref ref-type="bibr" rid="B6">6</xref>]. In biological sequence database search, the similarities between sequences can be inferred from optimal local alignment scores calculated by the SW algorithm. To calculate optimal local alignment scores, the SW algorithm has a linear space complexity and a quadratic time complexity. However, this quadratic time complexity makes the SW algorithm computationally demanding for large-scale sequence database search. This is further compounded by the rapid growth of sequence databases.</p>
    <p>Therefore, several heuristics such as FASTA [<xref ref-type="bibr" rid="B7">7</xref>] and BLAST [<xref ref-type="bibr" rid="B8">8</xref>,<xref ref-type="bibr" rid="B9">9</xref>] have been proposed to accelerate the sequence database search, but not guaranteeing to discover optimal local alignments. These heuristics usually produce considerably good results, but might fail to detect some distantly related sequences due to the loss of sensitivity. Hence, it has great significance to accelerate the SW algorithm so as to maintain optimal results. Consequently, a lot of efforts have been made to parallelize this computation on high-performance computing architectures ranging from loosely-coupled to tightly-coupled ones. Architecture examples include clouds [<xref ref-type="bibr" rid="B10">10</xref>], clusters [<xref ref-type="bibr" rid="B10">10</xref>] and accelerators [<xref ref-type="bibr" rid="B11">11</xref>]. Recent acceleration approaches focus on the use of field programmable gate arrays (FPGAs), single instruction multiple data (SIMD) vector execution units on CPUs, multi-core Cell Broadband Engine (Cell/BE), and many-core general-purpose GPUs, especially based on the compute unified device architecture (CUDA)-enabled GPUs.</p>
    <p>For FPGAs, some approaches based on linear systolic arrays and custom instructions have been proposed. Oliver <italic>et al</italic>. [<xref ref-type="bibr" rid="B12">12</xref>,<xref ref-type="bibr" rid="B13">13</xref>] constructed a linear systolic array on a standard Virtex II FPGA board to perform the SW algorithm with affine gap penalties. Li <italic>et al</italic>. [<xref ref-type="bibr" rid="B14">14</xref>] designed custom instructions to support massively parallel computing of the SW algorithm on an Altera Stratix EP1S40 FPGA.</p>
    <p>For SIMD vector execution units on CPUs, most efforts have been concentrated on intra-task parallelization that accelerates the alignment of a single sequence pair. Intra-task parallelization approaches can be generally classified into two computational patterns: (<italic>i</italic>) SIMD vectors parallel to minor diagonals in the alignment matrix [<xref ref-type="bibr" rid="B15">15</xref>], and (<italic>ii</italic>) SIMD vectors parallel to the query sequence by means of either a sequential [<xref ref-type="bibr" rid="B16">16</xref>] or a striped layout [<xref ref-type="bibr" rid="B17">17</xref>]. The former pattern is runtime independent of scoring schemes, but has complicated data management and limited speedups. The latter pattern proves to be faster, but is runtime sensitive to scoring schemes. Besides intra-task parallelization, some approaches based on inter-task parallelization have also been investigated [<xref ref-type="bibr" rid="B18">18</xref>,<xref ref-type="bibr" rid="B19">19</xref>].</p>
    <p>Unlike intra-task parallelization, the inter-task parallelization computes multiple alignments in parallel in a SIMD vector. The major advantages of this parallelization are the independence between alignments in SIMD vectors and the runtime independence of scoring schemes. These two parallelization approaches provide a general framework for other architectures with SIMD vector execution units, such as Cell/BEs and general-purpose GPUs. Cell/BE is a heterogeneous multi-core architecture comprised of one general-purpose power processor element and eight synergistic processing elements that serve as SIMD accelerators. On Cell/BEs, several approaches have been implemented [<xref ref-type="bibr" rid="B20">20</xref>]–[<xref ref-type="bibr" rid="B22">22</xref>], all of which are designed based on the striped approach [<xref ref-type="bibr" rid="B17">17</xref>]. For general-purpose GPUs, Liu <italic>et al</italic>. [<xref ref-type="bibr" rid="B23">23</xref>] developed an initial OpenGL-based implementation. With the emergence of CUDA programming model, several implementations targeting different generations of CUDA-enabled GPU architectures [<xref ref-type="bibr" rid="B24">24</xref>]–[<xref ref-type="bibr" rid="B29">29</xref>] have been developed using CUDA, among which CUDASW++ 2.0 [<xref ref-type="bibr" rid="B26">26</xref>] is one of the fastest.</p>
    <p>In this paper, we present CUDASW++ 3.0, which yields faster SW protein database search by coupling CPU and GPU SIMD instructions and conducting concurrent CPU and GPU computations. Similar approaches of coupling CPU and GPU computation have been investigated in [<xref ref-type="bibr" rid="B30">30</xref>] and [<xref ref-type="bibr" rid="B31">31</xref>] for phylogeny-aware alignment kernel and short-read alignment, respectively. To balance the runtimes of CPU and GPU computations, we have dynamically distributed all sequence alignment workloads over CPUs and GPUs, as per their compute power. For the computation on CPUs, we have employed the streaming SIMD extensions (SSE)-based vector execution units and multi-threading to speed up the SW algorithm. For the computation on GPUs, for the first time, we have investigated a GPU SIMD parallelization approach using PTX SIMD video instructions. Using the PTX SIMD instructions, we can obtain more data parallelism on GPUs beyond the single instruction multiple thread (SIMT) execution model implemented such as in CUDASW++ 2.0.</p>
    <p>We have evaluated the performance of CUDASW++ 3.0 and three other top-performing algorithms: CUDASW++ 2.0, SWIPE [<xref ref-type="bibr" rid="B19">19</xref>] and BLAST+ [<xref ref-type="bibr" rid="B32">32</xref>] using both the Swiss-Prot protein database and a simulated database comprised of equal-length sequences. Two Kepler-based graphics cards, namely GeForce GTX 680 (GTX680) and GeForce GTX 690 (GTX690), have been used for all evaluations of our algorithm. On a GTX680 (GTX690), CUDASW++ 3.0 achieves a maximal performance improvement of 2.9 (3.2) times over CUDASW++ 2.0 using the Swiss-Prot database and of 2.2 (2.3) times using the simulated database. Furthermore, our algorithm gains an average performance of 109.4 (169.7) billion cell updates per second (GCUPS), with a maximum of 119.0 (185.6) GCUPS, on the Swiss-Prot database and an average performance of 118.0 (196.2) GCUPS, with a maximum of 121.6 (204.7) GCUPS, on the simulated database. In addition, CUDASW++ 3.0 demonstrated significant speedups on average over SWIPE and BLAST+.</p>
    <sec>
      <title>The Smith-Waterman algorithm</title>
      <p>Given a sequence <italic>S</italic>, define <italic>S</italic>[<italic>i</italic>] to denote the <italic>i</italic><sup>th</sup> residue of <italic>S</italic>, and <italic>S</italic><sub><italic>i</italic></sub> to denote the prefix of <italic>S</italic> ending at position <italic>i</italic>. Given two sequences <italic>S</italic> and <italic>T</italic>, the recurrence of the SW algorithm with affine gap penalties is defined as</p>
      <p>
        <disp-formula id="bmcM1">
          <label>(1)</label>
          <mml:math id="M1" name="1471-2105-14-117-i1" overflow="scroll">
            <mml:mtable columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:msub>
                    <mml:mi>H</mml:mi>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>j</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>=</mml:mo>
                  <mml:mo>max</mml:mo>
                  <mml:mo stretchy="true">{</mml:mo>
                  <mml:msub>
                    <mml:mi>H</mml:mi>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>−</mml:mo>
                      <mml:mn>1</mml:mn>
                      <mml:mo>,</mml:mo>
                      <mml:mi>j</mml:mi>
                      <mml:mo>−</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>+</mml:mo>
                  <mml:mi>M</mml:mi>
                  <mml:mo stretchy="true">(</mml:mo>
                  <mml:mi>S</mml:mi>
                  <mml:mfenced open="[" close="]">
                    <mml:mi>i</mml:mi>
                  </mml:mfenced>
                  <mml:mo>,</mml:mo>
                  <mml:mi>T</mml:mi>
                  <mml:mo stretchy="true">[</mml:mo>
                  <mml:mi>j</mml:mi>
                  <mml:mo stretchy="true">]</mml:mo>
                  <mml:mo stretchy="true">)</mml:mo>
                  <mml:mo>,</mml:mo>
                  <mml:msub>
                    <mml:mi>E</mml:mi>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>j</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>,</mml:mo>
                  <mml:msub>
                    <mml:mi>F</mml:mi>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>j</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>,</mml:mo>
                  <mml:mn>0</mml:mn>
                  <mml:mo stretchy="true">}</mml:mo>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr>
                <mml:mtd>
                  <mml:msub>
                    <mml:mi>E</mml:mi>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>j</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>=</mml:mo>
                  <mml:mo>max</mml:mo>
                  <mml:mfenced open="{" close="}">
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>E</mml:mi>
                        <mml:mrow>
                          <mml:mi>i</mml:mi>
                          <mml:mo>−</mml:mo>
                          <mml:mn>1</mml:mn>
                          <mml:mo>,</mml:mo>
                          <mml:mi>j</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo>−</mml:mo>
                      <mml:mi>β</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:msub>
                        <mml:mi>H</mml:mi>
                        <mml:mrow>
                          <mml:mi>i</mml:mi>
                          <mml:mo>−</mml:mo>
                          <mml:mn>1</mml:mn>
                          <mml:mo>,</mml:mo>
                          <mml:mi>j</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo>−</mml:mo>
                      <mml:mi>α</mml:mi>
                    </mml:mrow>
                  </mml:mfenced>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr>
                <mml:mtd>
                  <mml:msub>
                    <mml:mi>F</mml:mi>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>j</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>=</mml:mo>
                  <mml:mo>max</mml:mo>
                  <mml:mfenced open="{" close="}">
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>F</mml:mi>
                        <mml:mrow>
                          <mml:mi>i</mml:mi>
                          <mml:mo>,</mml:mo>
                          <mml:mi>j</mml:mi>
                          <mml:mo>−</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo>−</mml:mo>
                      <mml:mi>β</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:msub>
                        <mml:mi>H</mml:mi>
                        <mml:mrow>
                          <mml:mi>i</mml:mi>
                          <mml:mo>,</mml:mo>
                          <mml:mi>j</mml:mi>
                          <mml:mo>−</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo>−</mml:mo>
                      <mml:mi>α</mml:mi>
                    </mml:mrow>
                  </mml:mfenced>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
      </p>
      <p>where <italic>H</italic><sub><italic>i</italic>,<italic>j</italic></sub>, <italic>E</italic><sub><italic>i</italic>,<italic>j</italic></sub> and <italic>F</italic><sub><italic>i</italic>,<italic>j</italic></sub> represent the local alignment score of two prefixes <italic>S</italic><sub><italic>i</italic></sub> and <italic>T</italic><sub><italic>j</italic></sub> with <italic>S</italic>[<italic>i</italic>] aligned to <italic>T</italic>[<italic>j</italic>], <italic>S</italic>[<italic>i</italic>] aligned to a gap and <italic>T</italic>[<italic>j</italic>] aligned to a gap, respectively. <italic>M</italic> is the scoring matrix which defines the substitution scores between residues, α is the sum of the gap open and extension penalties, and β is the gap extension penalty. The recurrence is initialized as <italic>H</italic><sub><italic>i</italic>,0</sub> = <italic>H</italic><sub>0,<italic>j</italic></sub> = <italic>E</italic><sub><italic>0</italic>,<italic>j</italic></sub> = <italic>F</italic><sub><italic>i</italic>,0</sub> = 0 for 0≤<italic>i</italic>≤|<italic>S</italic>| and 0≤<italic>j</italic>≤|<italic>T</italic>|. The optimal local alignment score is the maximal alignment score in the alignment matrix <italic>H</italic> and can be calculated in linear space.</p>
    </sec>
    <sec>
      <title>GPU architecture</title>
      <p>CUDA-enabled GPUs have evolved into highly parallel many-core processors with tremendous compute power and very high memory bandwidth. They are especially well-suited to address computational problems with high data parallelism and arithmetic density. A CUDA-enabled GPU can be conceptualized as a fully configurable array of scalar processors (SPs). These SPs are further organized into a set of streaming multiprocessors (SMs) under three architecture generations: Tesla [<xref ref-type="bibr" rid="B33">33</xref>], Fermi [<xref ref-type="bibr" rid="B34">34</xref>] and Kepler [<xref ref-type="bibr" rid="B35">35</xref>]. Since our algorithm targets the newest Kepler architecture, it is fundamental to understand the features of the underlying hardware and the associated parallel programming model.</p>
      <p>For the Kepler architecture, each SM comprises 192 CUDA SP cores sharing a configurable 64 KB on-chip memory. The on-chip memory can be configured at runtime as 48 KB shared-memory with 16 KB L1 cache, 32 KB shared-memory with 32 KB L1 cache, or 16 KB shared-memory with 48 KB L1 cache, for each CUDA kernel. This architecture has a local memory size of 512 KB per thread and has a L1/L2 cache hierarchy with a size-configurable L1 cache per SM and a dedicated unified L2 cache of size up to 1,536 KB. However, L1 caching in Kepler is reserved only for local memory accesses such as register spills and stack data. Global memory loads can only be cached in L2 cache and the 48 KB read-only data cache [<xref ref-type="bibr" rid="B36">36</xref>]. Same as all previous architectures, threads launched onto a GPU are scheduled in groups of 32 parallel threads, called warps, in SIMT fashion.</p>
      <p>To facilitate general-purpose data-parallel computing, CUDA-enabled GPUs have introduced PTX, a low-level parallel thread execution virtual machine and instruction set architecture (ISA) [<xref ref-type="bibr" rid="B37">37</xref>]. PTX provides a stable programming model and ISA that spans multiple GPU generations. For the Kepler architecture, SIMD video instructions are introduced in PTX, which operate either on pairs of 16-bit values or quads of 8-bit values. These SIMD instructions expose more data parallelism of GPUs and provide an opportunity for us to achieve higher speed for data-parallel compute-intensive problems. In this paper, we have explored PTX SIMD instructions to further accelerate the SW algorithm on Kepler-based GPUs.</p>
    </sec>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <sec>
      <title>Program outline</title>
      <p>CUDASW++ 3.0 gains high speed by benefiting from the use of CPU and GPU SIMD instructions as well as the concurrent CPU and GPU computations. Our algorithm generally works in four stages: (<italic>i</italic>) distribution of workloads over CPUs and GPUs according to their compute power; (<italic>ii</italic>) concurrent CPU and GPU computations; (<italic>iii</italic>) re-computation of all alignments that have exceeded the 8-bit accuracy using CPU 8-lane 16-bit SIMD instructions; and (<italic>iv</italic>) sorting of all alignment scores in descending order and output the results. Figure <xref ref-type="fig" rid="F1">1</xref> illustrates the workflow of our algorithm. In our algorithm, all subject sequences are pre-sorted in ascending order of sequence length.</p>
      <fig id="F1" position="float">
        <label>Figure 1</label>
        <caption>
          <p>Program workflow of CUDASW++ 3.0.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-117-1"/>
      </fig>
    </sec>
    <sec>
      <title>Workload distribution</title>
      <p>Our workload distribution in Stage (<italic>i</italic>) balances the runtimes between the CPU and GPU SIMD computation. Hence, the compute power of CPUs and GPUs should be taken into consideration in order to generalize our approach to different hardware configurations. Our distribution policy calculates a rate <italic>R</italic> of the number of residues from the database assigned to GPUs, which is calculated as</p>
      <p>
        <disp-formula id="bmcM2">
          <label>(2)</label>
          <mml:math id="M2" name="1471-2105-14-117-i2" overflow="scroll">
            <mml:mrow>
              <mml:mi>R</mml:mi>
              <mml:mo>=</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>N</mml:mi>
                    <mml:mi>G</mml:mi>
                  </mml:msub>
                  <mml:msub>
                    <mml:mi>f</mml:mi>
                    <mml:mi>G</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>N</mml:mi>
                    <mml:mi>G</mml:mi>
                  </mml:msub>
                  <mml:msub>
                    <mml:mi>f</mml:mi>
                    <mml:mi>G</mml:mi>
                  </mml:msub>
                  <mml:mo>+</mml:mo>
                  <mml:msub>
                    <mml:mi>N</mml:mi>
                    <mml:mi>C</mml:mi>
                  </mml:msub>
                  <mml:msub>
                    <mml:mi>f</mml:mi>
                    <mml:mi>C</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="true">/</mml:mo>
                  <mml:mi>C</mml:mi>
                </mml:mrow>
              </mml:mfrac>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>where <italic>f</italic><sub><italic>C</italic></sub> and <italic>f</italic><sub><italic>G</italic></sub> are the core frequencies of CPUs and GPUs, <italic>N</italic><sub><italic>C</italic></sub> and <italic>N</italic><sub><italic>G</italic></sub> are the number of CPU cores (i.e. threads) and the number of GPU SMs, and <italic>C</italic> is a constant derived from empirical evaluations, i.e. 3.2 and 5.1 for the query profile and its variant, respectively. When using multiple GPUs, our algorithm assumes that they have the same compute power and will calculate <italic>N</italic><sub><italic>G</italic></sub> by summing up the number of SMs on all GPUs.</p>
      <p>After obtaining <italic>R</italic>, we calculate the number <italic>N</italic><sub><italic>R</italic></sub> of residues assigned to GPUs as <italic>R</italic> times the total number of residues in the database. Subsequently, all subject sequences assigned to GPUs can be determined by summing the sequence lengths in ascending order until it reaches <italic>N</italic><sub><italic>R</italic></sub>. All other subject sequences will be distributed to CPUs.</p>
    </sec>
    <sec>
      <title>CPU SIMD computation</title>
      <p>In Stage (<italic>ii</italic>), the CPU SIMD computation consists of two steps. First, we compute the SW algorithm by splitting an SSE vector to 16 lanes with 8-bit lane width. This allows aligning a query in parallel to 16 subject sequences following the inter-task parallelization model. Secondly, we re-compute all alignments, whose scores have overflow potential, using 8-lane SSE vectors with 16-bit lane width. We determine an alignment to have overflow potential by comparing its score with a score limit calculated by subtracting from 128 the maximum substitution score in the scoring matrix. If the score ≥ the score limit, the alignment is deemed to have an overflow potential and thus requires re-computation. Our approach is based on the open-source SWIPE and more details about the specific implementation of the SSE-based SW algorithm can be obtained from [<xref ref-type="bibr" rid="B19">19</xref>].</p>
      <p>In our algorithm, users are allowed to use multiple threads to conduct the CPU SIMD computation. Since the workload (i.e. subject sequences assigned to CPUs) is known beforehand, we calculate the total number of residues in all assigned subject sequences and (nearly) equally distribute all residues over all threads using a sequence as a unit. This distribution aims to make each thread hold (roughly) the same number of residues, but not necessarily receiving the same number of subject sequences.</p>
    </sec>
    <sec>
      <title>GPU SIMD computation</title>
      <sec>
        <title>Core PTX SIMD assemblies</title>
        <p>We have implemented the recurrence in Equation (1) with PTX SIMD assembly instructions. The code consists of ten assembly instructions for the recurrence and one instruction for obtaining the optimal local alignment score. Figure <xref ref-type="fig" rid="F2">2</xref> shows the PTX SIMD assembly instructions.</p>
        <fig id="F2" position="float">
          <label>Figure 2</label>
          <caption>
            <p>Code in CUDA PTX SIMD assemblies.</p>
          </caption>
          <graphic xlink:href="1471-2105-14-117-2"/>
        </fig>
        <p>The figure shows that every instruction operates on quads of 8-bit signed values, corresponding to four independent alignments. Variables <italic>h</italic>, <italic>n</italic> and <italic>h</italic><sub><italic>e</italic></sub> represent the alignment score vectors corresponding to matrix <italic>H</italic>, where <italic>h</italic> denotes the score vector of the four current cells, <italic>n</italic> the score vector of the four diagonal neighbours and <italic>h</italic><sub><italic>e</italic></sub> the score vector of the four upper neighbours. Variables <italic>e</italic> and <italic>f</italic> represent the score vectors corresponding to the matrices <italic>E</italic> and <italic>F</italic> respectively, and <italic>S</italic> stores the current maximum alignment scores. For additions and subtractions, saturation instructions have been used to clamp the values to their appropriate signed ranges.</p>
      </sec>
      <sec>
        <title>CUDA-enabled parallelization</title>
        <p>For quad-lane SIMD computing on GPUs, four adjacent subject sequences (in the pre-sorted list as mentioned above) are assigned to a single thread, with each vector lane corresponding to each sequence. To facilitate data fetches for SIMD vectors, a two-dimensional sequence profile of size 4×<italic>l</italic> will be created for four sequences, where <italic>l</italic> is the maximum length of the four sequences. In a sequence profile, each row is a quad-lane residue vector represented as an <italic>integer</italic> data type, and is created by packing four residues of the same index in their corresponding sequences with each residue occupying 8 bits. To reduce the number of texture fetches, we have further packed four successive residue vectors using a <italic>uint4</italic> vector data type for each sequence profile. Thus, we can realize four residue vectors for four subject sequences by a single texture fetch. Using a profile as a unit, we store all profiles in the texture memory following the same layout as in CUDASW++ 2.0.</p>
        <p>For the linear-space SW algorithm, we require two intermediate buffers to store one row for matrices <italic>H</italic> and <italic>E</italic> (in our case) respectively. Instead of global memory, we have allocated them in local memory. Since the Kepler architecture has 512 KB per-thread local memory, theoretically we can support subject sequences as long as 65,536 on GPUs. Our algorithm sets the maximum subject sequence length to be 3,072 by default, but allows users to configure it at compile time because the two intermediate buffers have to be statically allocated in local memory.</p>
        <p>The sequence length deviation generally causes runtime imbalance between threads, which in return can waste GPU compute power. In this regard, we have developed two CUDA kernels based on two parallelization approaches: static scheduling and dynamic scheduling. These two kernels are invoked at runtime based on the sequence length deviation of the database. For both approaches, we compute the total number of thread blocks from the total number of sequence profiles, which is constructed from the workload assigned to the GPU. Since each thread has its own intermediate buffers, the static scheduling parallelization launches all thread blocks onto the GPU at the same time, which is common for launching a CUDA kernel. The parallelization will rely on the CUDA runtime system to maximize the utilization of computational resources of GPUs. Besides the CUDA runtime system, the dynamic scheduling approach attempts to intervene with the scheduling of thread blocks on GPUs. This parallelization launches a small set of thread blocks of size <italic>N</italic><sub><italic>T</italic></sub> to carry out the whole computation, regardless of the assigned workload. <italic>N</italic><sub><italic>T</italic></sub> is defined as:</p>
        <p>
          <disp-formula id="bmcM3">
            <label>(3)</label>
            <mml:math id="M3" name="1471-2105-14-117-i3" overflow="scroll">
              <mml:mrow>
                <mml:msub>
                  <mml:mi>N</mml:mi>
                  <mml:mi>T</mml:mi>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:mn>2</mml:mn>
                    <mml:msub>
                      <mml:mi>N</mml:mi>
                      <mml:mi mathvariant="italic">SM</mml:mi>
                    </mml:msub>
                    <mml:mo>×</mml:mo>
                    <mml:msub>
                      <mml:mi>N</mml:mi>
                      <mml:mi mathvariant="italic">MRT</mml:mi>
                    </mml:msub>
                  </mml:mrow>
                  <mml:msub>
                    <mml:mi>N</mml:mi>
                    <mml:mi mathvariant="italic">TPB</mml:mi>
                  </mml:msub>
                </mml:mfrac>
              </mml:mrow>
            </mml:math>
          </disp-formula>
        </p>
        <p>where <italic>N</italic><sub><italic>SM</italic></sub> is the number of SMs, <italic>N</italic><sub><italic>MRT</italic></sub> is the maximum number of resident threads per SM supported by the GPU, and <italic>N</italic><sub><italic>TPB</italic></sub> is the number of threads per thread block configured by the user. The dynamic scheduling parallelization works as follows. All sequence profiles are organized into sequence profile blocks, each of which has as many sequence profiles as the number of threads in a thread block. Subsequently, <italic>N</italic><sub><italic>T</italic></sub> thread blocks are launched to perform the computation, where a thread block processes a sequence profile block at a time. When a thread block finishes its current computation, this thread block will dynamically obtain an unprocessed profile block. This operation is done by the atomic addition function <italic>atomicAdd</italic>() on global memory, which increments the index of global profile blocks. In our algorithm, both static scheduling and dynamic scheduling have used a thread block size of 64.</p>
        <p>Our evaluation has found that dynamic scheduling performs slightly better than static scheduling when using the Swiss-Prot database (with large sequence length deviation), whereas the latter seems slightly better in the ideal case where all sequences are of equal lengths. Based on the above observations, we have decided to employ the static scheduling approach for databases with very small sequence length deviation (by default when the standard deviation does not exceed 1% of the mean) and the dynamic scheduling approach for all others.</p>
      </sec>
      <sec>
        <title>Query profile variant</title>
        <p>Given a query <italic>S</italic> defined over an alphabet Σ, a query profile is defined as a numerical string set <italic>P</italic> = {<italic>P</italic><sub><italic>r</italic></sub> | <italic>r</italic> є Σ}, where <italic>P</italic><sub><italic>r</italic></sub> is a numeric string comprised of substitution scores required for aligning the whole query to any residue in Σ. The space complexity of the query profile can be calculated as <italic>O</italic>(|<italic>S</italic>|×|Σ|). In our algorithm we have employed the sequential-layout query profile [<xref ref-type="bibr" rid="B16">16</xref>], which defines the <italic>i</italic><sup>th</sup> element of <italic>P</italic><sub><italic>r</italic></sub> as <italic>M</italic>(<italic>r</italic>, <italic>S</italic>[<italic>i</italic>]), 1≤<italic>i</italic>≤|<italic>S</italic>|. The query profile is stored in texture memory and has been packed in the same way as in CUDASW++ 2.0 to reduce the number of texture fetches.</p>
        <p>To facilitate GPU SIMD parallelization, we have derived a variant of a query profile. By enumerating all residues in Σ, we define a query profile variant as a numerical set <italic>V</italic> = {<italic>V</italic><sub><italic>r</italic></sub> | 0≤ <italic>r</italic>&lt;|Σ|<sup><italic>K</italic></sup>} of |Σ|<sup><italic>K</italic></sup> entries, where <italic>V</italic><sub><italic>r</italic></sub> is a vector of <italic>K</italic> substitution scores and <italic>r</italic> is an integer corresponding to the permutation of any <italic>K</italic> residues in Σ. <italic>V</italic><sub><italic>r</italic></sub> stores all substitution score vectors for aligning the whole query to the <italic>K</italic> residues corresponding to <italic>r</italic>. The space complexity of a query profile variant can be calculated as <italic>O</italic>(|<italic>S</italic>|×|Σ|<sup><italic>K</italic></sup>). Like the query profile, this variant is also stored in texture memory. When <italic>K</italic> = 4, each element of <italic>V</italic><sub><italic>r</italic></sub> can be directly used in our quad-lane SIMD computation. However, the memory footprint is considerable even for short protein queries (this pressure can be significantly alleviated for DNA sequences due to their small alphabet size), and will cause more texture cache misses as the query length increases. In order to improve speed for long queries, our algorithm therefore uses <italic>K</italic>=2. We represent each element of <italic>V</italic><sub><italic>r</italic></sub> using the <italic>short integer</italic> data type, since the range of the <italic>char</italic> data type is generally large enough to store a substitution score. Figure <xref ref-type="fig" rid="F3">3</xref> shows an example query profile variant using <italic>K</italic>=2. Similar to the query profile, the variant has also been packed by representing four consecutive elements of each <italic>V</italic><sub><italic>r</italic></sub> using the <italic>short4</italic> data type. In this way, the variant can reduce the number of texture fetches by half compared to the query profile. On the other hand, to compute each cell vector (see Figure <xref ref-type="fig" rid="F2">2</xref>), we have to extract and concatenate the substitution scores, from either query profile or the variant, to generate a substitution score vector. This requires some additional bitwise operations in our implementation. In this case, we can save six bitwise operations for each cell vector by using the variant, instead of the query profile. This makes great sense in terms of speed, considering that each cell vector requires only several assembly instructions as shown in Figure <xref ref-type="fig" rid="F2">2</xref>.</p>
        <fig id="F3" position="float">
          <label>Figure 3</label>
          <caption>
            <p><bold>An example query profile variant using </bold><bold><italic>K</italic></bold><bold>=2.</bold> Operation <italic>a</italic>||<italic>b</italic> means concatenating 8-bit substitution scores <italic>a</italic> and <italic>b</italic> to form a short integer data.</p>
          </caption>
          <graphic xlink:href="1471-2105-14-117-3"/>
        </fig>
        <p>Our algorithm employs both the query profile and its variant. In general, for short queries, more performance gains can be realized from the query profile variant because it can reduce the number of texture fetches by half and use fewer bitwise operations per cell as mentioned above. However, for longer queries, a query profile becomes superior due to its much smaller memory footprint and less texture cache miss. Thus, we have calculated a query length threshold <italic>Q</italic> to decide whether to use the query profile or the variant. For the Kepler architecture, texture fetches are cached by the aforementioned read-only cache and L2 cache. Since the L2 cache is usually much larger than the read-only cache, we have estimated <italic>Q</italic> from the L2 cache size as</p>
        <p>
          <disp-formula id="bmcM4">
            <label>(4)</label>
            <mml:math id="M4" name="1471-2105-14-117-i4" overflow="scroll">
              <mml:mrow>
                <mml:mi>Q</mml:mi>
                <mml:mo>=</mml:mo>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:mi>L</mml:mi>
                    <mml:mn>2</mml:mn>
                    <mml:mo>_</mml:mo>
                    <mml:mi mathvariant="italic">cache</mml:mi>
                    <mml:mo>_</mml:mo>
                    <mml:mi mathvariant="italic">size</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>2</mml:mn>
                    <mml:msup>
                      <mml:mfenced open="|" close="|">
                        <mml:mo>∑</mml:mo>
                      </mml:mfenced>
                      <mml:mi>K</mml:mi>
                    </mml:msup>
                  </mml:mrow>
                </mml:mfrac>
              </mml:mrow>
            </mml:math>
          </disp-formula>
        </p>
        <p>The estimation is empirical and works well in practice through our evaluations. <italic>Q</italic> is used in the dynamic scheduling parallelization to cope with more general databases. For static scheduling which is only applied to databases with small sequence length deviations, we have found that a query profile variant usually leads to superior speed.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>Results and discussion</title>
    <sec>
      <title>Experimental design</title>
      <p>We used the GCUPS metric to measure the performance of the following algorithms: CUDASW++ 3.0 (v3.0.14), CUDASW++ 2.0 (v2.0.10), SWIPE (v2.0.5) and BLAST+ (v2.2.27). We used 20 protein queries of lengths ranging from 144 to 5,478 to search against two protein databases: the Swiss-Prot database (release 2012_11) and a simulated database of equal-length sequences. The accession numbers of all queries are: P02232, P05013, P14942, P07327, P01008, P03435, P42357, P21177, Q38941, P27895, P07756, P04775, P19096, P28167, P0C6B8, P20930, P08519, Q7TMA5, P33450, and Q9UKN1, listed in the ascending order of sequence length. The Swiss-Prot database consists of 191,240,745 amino acids in 538,585 sequences and has the largest sequence length 35,213. The simulated database comprises 200,000 sequences with each sequence of length 3,000, containing 600,000,000 amino acids in total.</p>
      <p>All tests were conducted on a personal computer with an Intel <italic>i</italic>7 2700K quad-core 3.5 GHz CPU and 16 GB memory, running the Linux operating system (Ubuntu 12.04). All GPU-based tests are carried out on the aforementioned GTX680 and GTX690 graphics cards. GTX680 has a single GPU that contains 8 SMs (1,536 SPs and a clock rate of 1.06 GHz) and 2 GB memory. GTX690 consists of two GPUs, each of which contains 8 SMs (1,536 SPs and a clock rate of 1.02 GHz) and 2 GB memory. We turned off the error correcting code on both graphics cards and conducted all single-GPU evaluations on GTX680 as well as all dual-GPU evaluations on GTX690. For all tests, the wall clock times were used to compute the GCUPS performance of all evaluated algorithms.</p>
      <p>The CUDASW++ 3.0, CUDASW++ 2.0 and SWIPE algorithms used the default scoring schemes due to their runtime independence of scoring schemes. BLAST+ used the scoring matrices BLOSUM62 (BL62) and BLOSUM50 (BL50), with the default gap open and extension penalties. We used four CPU threads for the CUDASW++ 3.0, SWIPE and BLAST+ algorithms, and used other parameters “-b 0 -v 0” for SWIPE and “-num_alignment 0” for BLAST+, respectively. CUDA toolkit 4.2 was used to compile CUDASW++ 2.0 and CUDASW++ 3.0.</p>
    </sec>
    <sec>
      <title>Evaluation on the Swiss-Prot database</title>
      <p>We first compared the performance of all evaluated algorithms by searching the 20 queries against the Swiss-Prot database. Figure <xref ref-type="fig" rid="F4">4</xref> illustrates the performance of all evaluated algorithms for varying query lengths. For the Swiss-Prot database, CUDASW++ 3.0 employs the dynamic scheduling approach for all queries. On GTX680 (GTX690), CUDASW++ 3.0 yields an average performance of 109.4 (169.7) GCUPS, with a maximum of 119.0 (185.6) GCUPS. Highest performance is realized by short queries of lengths &lt;400 due to the use of the query profile variant. In addition, a sudden performance drop can be observed as the curve moves to query length ≥400. This is because our CUDA kernel switches to the use of the query profile for longer queries, giving up the query profile variant.</p>
      <fig id="F4" position="float">
        <label>Figure 4</label>
        <caption>
          <p>Performance comparisons on the Swiss-Prot database.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-117-4"/>
      </fig>
      <p>Both CUDASW++ 2.0 and SWIPE achieve nearly constant performance for all queries. CUDASW++ 2.0 has an average performance of 44.8 (77.9) GCUPS on GTX680 (GTX690), while SWIPE yields an average performance of 45.0 GCUPS using 4 threads. CUDASW++ 3.0 is superior to both CUDASW++ 2.0 and SWIPE for every query, even if only using a single GPU. CUDADSW++ 3.0 on GTX 680 (GTX690) runs on average 2.4× (2.2×) faster than CUDASW++ 2.0 and 2.4 × (3.8×) faster than SWIPE, while gaining a maximum speedup of 2.9 (3.2) over CUDASW++ 2.0 and 3.2 (5.0) over SWIPE. BLAST+ shows performance fluctuations for different queries, especially in the case of BL62. Furthermore, BLAST+ is runtime sensitive to the scoring scheme used. It runs on average 3.4× faster using BL62 than BL50. On GTX690, CUDASW++ 3.0 is always superior to BLAST+ for each case, where the former achieves an average speedup of 2.4 and 7.8 (and a maximum of 3.8 and 11.1) over the latter using BL62 and BL50, respectively. On GTX680, CUDASW++ 3.0 outperforms BLAST+ using BL50 for all queries, gaining an average speedup of 5.1 and a maximum of 7.2. Compared to BLAST+ using BL62, CUDASW++ 3.0 gains an average speedup of 1.6 and a maximum of 2.4. However, our algorithm has a lower performance for two queries with the following accession numbers: P08519 and Q7TMA5.</p>
    </sec>
    <sec>
      <title>Evaluation on a simulated database</title>
      <p>In addition, we have employed the aforementioned simulated database to compare all algorithms. On this database, we can avoid the computation waste of CPU and GPU SIMD instructions as all alignments in all lanes will be completed at the same time, and can also avoid the computational imbalance between threads within a warp and a thread block. Figure <xref ref-type="fig" rid="F5">5</xref> shows the performance of all evaluated algorithms on this simulated database.</p>
      <fig id="F5" position="float">
        <label>Figure 5</label>
        <caption>
          <p>Performance comparisons on the simulated database.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-117-5"/>
      </fig>
      <p>Compared to the Swiss-Prot database, all evaluated algorithms are able to improve their average performance. On GTX680 (GTX690), CUDASW++ 3.0 achieves an average performance of 118.0 (196.2) GCUPS and CUDASW++ 2.0 of 55.2 (92.9) GCUPS. SWIPE improves its average performance to 48.6 GCUPS and BLAST+ to 126.9 and 27.1 GCUPS using BL62 and BL50 respectively. Similar to the Swiss-Prot database, CUDASW++ 2.0 and SWIPE produce nearly constant performance over all queries, while BLAST+ fluctuates. CUDASW++ 3.0 is still superior to CUDASW++ 2.0, SWIPE and BLAST+ using BL50 in each case. On GTX680 (GTX690), our algorithm gains an average speedup of 2.1 (2.1) over CUDASW++ 2.0, 2.4 (4.0) over SWIPE and 4.6 (7.6) over BLAST+ using BL50. Compared to BLAST+ using BL62, CUDASW++ 3.0 on GTX690 is superior for all queries except for the largest one, for which BLAST+ has a performance burst of up to 254.2 GCUPS. On average, CUDASW++ 3.0 on GTX680 can be considered on par with BLAST+ using BL62, but on GTX690 runs 1.7× faster.</p>
    </sec>
    <sec>
      <title>Other evaluations</title>
      <p>In addition to the performance based on hybrid CPU-GPU parallelism, we have evaluated the performance of GPU-only CUDASW++ 3.0 by disabling CPU threads. By default, the GPU computation only supports subject sequences of lengths ≤3072 (as mentioned above) due to the limited GPU device memory. Longer subject sequences (&gt;3072 residues) are distributed to the CPU. Hence, for this evaluation we created a new sub-database by extracting all sequences of lengths ≤3072 from the Swiss-Prot database. This new sub-database consists of 99.88% sequences and 98.41% amino acids of the original Swiss-Prot database. Using this sub-database, CUDASW++ 2.0 will only conduct the inter-task parallelization stage because all sequence lengths are ≤3072. In addition, we have disabled Stage (<italic>iv</italic>), which re-computes the very few alignments with indicative overflows on CPUs.</p>
      <p>Figure <xref ref-type="fig" rid="F6">6</xref> shows the performance comparison between GPU-only CUDASW++ 3.0 and CUDASW++ 2.0 on the single-GPU GTX680. Due to the large sequence length deviation of the sub-database, the dynamic scheduling approach is automatically selected by CUDASW++ 3.0 for all queries. Similar to the case of using the original Swiss-Prot database, we have also observed a performance drop because of the switch from the query profile variant to the query profile. From the figure, GPU-only CUDASW++ 3.0 is superior to the CUDASW++ 2.0 for all queries, yielding an average speedup of 1.2 and a maximum speedup of 1.6. In addition, CUDASW++ 3.0 realized an average performance of 68.3 GCUPS and a maximum performance of 83.3 GCUPS, for all queries.</p>
      <fig id="F6" position="float">
        <label>Figure 6</label>
        <caption>
          <p>Performance comparison between GPU-only CUDASW++ 3.0 and 2.0.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-117-6"/>
      </fig>
      <p>Finally, we have evaluated the relative performance of CPU computation to GPU computation in Stage (<italic>ii</italic>), by searching all queries against the Swiss-Prot database on the GTX680. We have measured the runtimes of both the CPU and GPU computation and then calculate their performance from their respective workload and runtime. Figure <xref ref-type="fig" rid="F7">7</xref> shows the performance ratio of the CPU to CPU computation in terms of runtime and GCUPS. From the figure, we can see that the runtime ratios of the CPU to GPU computation slightly fluctuate around 1.0 for all queries. This reflects that our workload distribution between the CPU and GPU computation are well balanced. In addition, for longer queries of lengths &gt;400, the performance ratio of the CPU to GPU computation has also reached roughly stable values (about 1:2 on average).</p>
      <fig id="F7" position="float">
        <label>Figure 7</label>
        <caption>
          <p>Relative performance of CPU SIMD computation to GPU SIMD computation.</p>
        </caption>
        <graphic xlink:href="1471-2105-14-117-7"/>
      </fig>
    </sec>
  </sec>
  <sec sec-type="conclusions">
    <title>Conclusions</title>
    <p>In this paper, we have presented CUDASW++ 3.0, a faster SW protein database search algorithm, which gains high speed by coupling CPU and GPU SIMD instructions and carrying out concurrent CPU and GPU computations. For the first time, we have investigated a GPU SIMD parallelization based on CUDA PTX SIMD video instructions. This parallelization enables us to gain more data parallelism beyond the SIMT execution model on CUDA-enabled GPUs. Performance evaluation reveals that our algorithm gains significant speedups over three other top-performing algorithms: CUDASW++ 2.0, SWIPE and BLAST+. On the popular Swiss-Prot database, our algorithm on GTX680 (GTX690) yields a speedup of up to 2.9 (3.2) over CUDASW++ 2.0, up to 3.2 (5.0) over SWIPE using 4 threads, and up to 7.2 (11.1) over BLAST+ with BL50 using 4 threads. With Hyper-Threading enabled, the performance of both SWIPE and BLAST+ against the Swiss-Prot database improves, albeit insignificantly. On average, compared to the aforementioned performance with 4 threads, the Hyper-Threading functionality can improve the performance by 12.8% and 34.0% for SWIPE and BLAST+ respectively, by using 8 threads. Despite designed for the SW protein database search, our algorithm has also presented a general computing framework for heterogeneous computing with CUDA-enabled GPUs and is expected to make contributions to other research problems.</p>
  </sec>
  <sec>
    <title>Abbreviations</title>
    <p>BL50: BLOSUM50; BL62: BLOSUM62; CPU: Central Processing Unit; CUDA: Compute Unified Device Architecture; GPU: Graphics Processing Unit; GTX680: GeForce GTX 680; GTX690: GeForce GTX 690; FPGA: Field Programmable Gate Array; ISA: Instruction Set Architecture; PTX: Parallel Thread Execution; SSE: Streaming SIMD Extensions; SIMD: Single Instruction Multiple Data; SIMT: Single Instruction Multiple Thread.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors’ contributions</title>
    <p>YL contributed the idea of concurrent CPU and GPU execution, programmed the algorithm, performed the tests, analysed the results and drafted the manuscript; AW programmed the algorithm, analysed the results and revised the manuscript; BS contributed the idea of using PTX SIMD video instructions, participated in the algorithm optimization, analysed the results and revised the manuscript. All authors read and approved the final manuscript.</p>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>The authors thank the editor and the anonymous reviewers for their helpful and constructive comments that helped to improve the manuscript. We acknowledge Rognes T. for the use of parts of source code from the open-source SWIPE algorithm.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Smith</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Waterman</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Identification of common molecular subsequences</article-title>
        <source>J Mol Biol</source>
        <year>1981</year>
        <volume>147</volume>
        <fpage>195</fpage>
        <lpage>197</lpage>
        <pub-id pub-id-type="doi">10.1016/0022-2836(81)90087-5</pub-id>
        <?supplied-pmid 7265238?>
        <pub-id pub-id-type="pmid">7265238</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gotoh</surname>
          <given-names>O</given-names>
        </name>
        <article-title>An improved algorithm for matching biological sequences</article-title>
        <source>J Mol Biol</source>
        <year>1982</year>
        <volume>162</volume>
        <fpage>707</fpage>
        <lpage>708</lpage>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Thompson</surname>
          <given-names>JD</given-names>
        </name>
        <name>
          <surname>Higgins</surname>
          <given-names>DG</given-names>
        </name>
        <name>
          <surname>Gibson</surname>
          <given-names>TJ</given-names>
        </name>
        <article-title>CLUSTALW: improving the sensitivity of progressive multiple sequence alignment through sequence weighting, position-specific gap penalties and weight matrix choice</article-title>
        <source>Nucleic Acids Res</source>
        <year>1994</year>
        <volume>22</volume>
        <fpage>4673</fpage>
        <lpage>4680</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/22.22.4673</pub-id>
        <?supplied-pmid 7984417?>
        <pub-id pub-id-type="pmid">7984417</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="book">
        <name>
          <surname>Liu</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Schmidt</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Maskell</surname>
          <given-names>DL</given-names>
        </name>
        <source>MSA-CUDA: Multiple Sequence Alignment on Graphics Processing Units with CUDA</source>
        <year>2009</year>
        <publisher-name>20th IEEE International Conference on Application-specific Systems, Architectures and Processors</publisher-name>
        <fpage>121</fpage>
        <lpage>128</lpage>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Durbin</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Fast and accurate short read alignment with Burrows-Wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>14</issue>
        <fpage>1755</fpage>
        <lpage>1760</lpage>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Liu</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Schmidt</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Maskell</surname>
          <given-names>DL</given-names>
        </name>
        <article-title>CUSHAW: a CUDA compatible short read aligner to large genomes based on the Burrows-Wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <issue>14</issue>
        <fpage>1830</fpage>
        <lpage>1837</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts276</pub-id>
        <?supplied-pmid 22576173?>
        <pub-id pub-id-type="pmid">22576173</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Pearson</surname>
          <given-names>WR</given-names>
        </name>
        <name>
          <surname>Lipman</surname>
          <given-names>DJ</given-names>
        </name>
        <article-title>Improved tools for biological sequence comparison</article-title>
        <source>Proc. Nat. Acad. Sci. USA</source>
        <year>1988</year>
        <volume>85</volume>
        <issue>8</issue>
        <fpage>2444</fpage>
        <lpage>2448</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.85.8.2444</pub-id>
        <?supplied-pmid 3162770?>
        <pub-id pub-id-type="pmid">3162770</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Altschul</surname>
          <given-names>SF</given-names>
        </name>
        <name>
          <surname>Gish</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Miller</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Myers</surname>
          <given-names>EW</given-names>
        </name>
        <name>
          <surname>Lipman</surname>
          <given-names>DJ</given-names>
        </name>
        <article-title>Basical local alignment search tool</article-title>
        <source>J Mol Biol</source>
        <year>1990</year>
        <volume>215</volume>
        <issue>3</issue>
        <fpage>403</fpage>
        <lpage>410</lpage>
        <?supplied-pmid 2231712?>
        <pub-id pub-id-type="pmid">2231712</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Altschul</surname>
          <given-names>SF</given-names>
        </name>
        <name>
          <surname>Madden</surname>
          <given-names>TL</given-names>
        </name>
        <name>
          <surname>Schaffer</surname>
          <given-names>AA</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Miller</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Lipman</surname>
          <given-names>DJ</given-names>
        </name>
        <article-title>Gapped BLAST and PSI-BLAST: a new generation of protein database search programs</article-title>
        <source>Nucleic Acids Res</source>
        <year>1997</year>
        <volume>25</volume>
        <issue>17</issue>
        <fpage>3389</fpage>
        <lpage>3402</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/25.17.3389</pub-id>
        <?supplied-pmid 9254694?>
        <pub-id pub-id-type="pmid">9254694</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Qiu</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Ekanayake</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Gunarathne</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Choi</surname>
          <given-names>JY</given-names>
        </name>
        <name>
          <surname>Bae</surname>
          <given-names>SH</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Wu</surname>
          <given-names>TL</given-names>
        </name>
        <name>
          <surname>Ruan</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Ekanayake</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Hughes</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Fox</surname>
          <given-names>G</given-names>
        </name>
        <article-title>Hybrid cloud and cluster computing paradigms for life science applications</article-title>
        <source>BMC Bioinformatics</source>
        <year>2010</year>
        <volume>11</volume>
        <issue>Suppl12</issue>
        <fpage>S3</fpage>
        <?supplied-pmid 21210982?>
        <pub-id pub-id-type="pmid">21210982</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Liu</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Maskell</surname>
          <given-names>DL</given-names>
        </name>
        <name>
          <surname>Schmidt</surname>
          <given-names>B</given-names>
        </name>
        <article-title>CUDASW++: optimizing Smith-Waterman sequence database searches for CUDA-enabled graphics processing units</article-title>
        <source>BMC Research Notes</source>
        <year>2009</year>
        <volume>2</volume>
        <fpage>73</fpage>
        <pub-id pub-id-type="doi">10.1186/1756-0500-2-73</pub-id>
        <?supplied-pmid 19416548?>
        <pub-id pub-id-type="pmid">19416548</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Oliver</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Schmidt</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Nathan</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Clemens</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Maskell</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Using reconfigurable hardware to accelerate multiple sequence alignment with ClustalW</article-title>
        <source>Bioinformatics</source>
        <year>2005</year>
        <volume>21</volume>
        <issue>16</issue>
        <fpage>3431</fpage>
        <lpage>3432</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bti508</pub-id>
        <?supplied-pmid 15919726?>
        <pub-id pub-id-type="pmid">15919726</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Oliver</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Schmidt</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Maskell</surname>
          <given-names>DL</given-names>
        </name>
        <article-title>Reconfigurable architectures for bio-sequence database scanning on FPGAs</article-title>
        <source>IEEE Trans. Circuit Syst. II</source>
        <year>2005</year>
        <volume>52</volume>
        <fpage>851</fpage>
        <lpage>855</lpage>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>TI</given-names>
        </name>
        <name>
          <surname>Shum</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Truong</surname>
          <given-names>K</given-names>
        </name>
        <article-title>160-fold acceleration of the Smith-Waterman algorithm using a field programmable gate array (FPGA)</article-title>
        <source>BMC Bioinformatics</source>
        <year>2007</year>
        <volume>8</volume>
        <fpage>I85</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-8-85</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Wozniak</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Using video-oriented instructions to speed up sequence comparison</article-title>
        <source>Comput Appl Biosci</source>
        <year>1997</year>
        <volume>13</volume>
        <issue>2</issue>
        <fpage>145</fpage>
        <lpage>150</lpage>
        <?supplied-pmid 9146961?>
        <pub-id pub-id-type="pmid">9146961</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Rognes</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Seeberg</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Six-fold speedup of Smith-Waterman sequence database searches using parallel processing on common microprocessors</article-title>
        <source>Bioinformatics</source>
        <year>2000</year>
        <volume>16</volume>
        <issue>8</issue>
        <fpage>699</fpage>
        <lpage>706</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/16.8.699</pub-id>
        <?supplied-pmid 11099256?>
        <pub-id pub-id-type="pmid">11099256</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Farrar</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Striped Smith-Waterman speeds database searches six times over other SIMD implementations</article-title>
        <source>Bioinformatics</source>
        <year>2007</year>
        <volume>23</volume>
        <issue>2</issue>
        <fpage>156</fpage>
        <lpage>161</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btl582</pub-id>
        <?supplied-pmid 17110365?>
        <pub-id pub-id-type="pmid">17110365</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="book">
        <name>
          <surname>Alpern</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Carter</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Gatlin</surname>
          <given-names>KS</given-names>
        </name>
        <source>Microparallelism and high performance protein matching</source>
        <year>1995</year>
        <publisher-name>USA: Proceedings of the 1995 ACM/IEEE Supercomputing Conference</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Rognes</surname>
          <given-names>T</given-names>
        </name>
        <article-title>Faster Smith-Waterman database searches with inter-sequence SIMD parallelization</article-title>
        <source>BMC Bioinformatics</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>221</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-12-221</pub-id>
        <?supplied-pmid 21631914?>
        <pub-id pub-id-type="pmid">21631914</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Wirawan</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Kwoh</surname>
          <given-names>CK</given-names>
        </name>
        <name>
          <surname>Hieu</surname>
          <given-names>NT</given-names>
        </name>
        <name>
          <surname>Schmidt</surname>
          <given-names>B</given-names>
        </name>
        <article-title>CBESW: Sequence Alignment on Playstation 3</article-title>
        <source>BMC Bioinformatics</source>
        <year>2008</year>
        <volume>9</volume>
        <fpage>377</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-9-377</pub-id>
        <?supplied-pmid 18798993?>
        <pub-id pub-id-type="pmid">18798993</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Szalkowski</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Ledergerber</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Krahenbuhl</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Dessimoz</surname>
          <given-names>C</given-names>
        </name>
        <article-title>SWPS3 – fast multi-threaded vectorized Smith-Waterman for IBM Cell/B.E. and x86/SSE2</article-title>
        <source>BMC Research Notes</source>
        <year>2008</year>
        <volume>1</volume>
        <fpage>107</fpage>
        <pub-id pub-id-type="doi">10.1186/1756-0500-1-107</pub-id>
        <?supplied-pmid 18959793?>
        <pub-id pub-id-type="pmid">18959793</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="other">
        <name>
          <surname>Farrar</surname>
          <given-names>MS</given-names>
        </name>
        <source>Optimizing Smith-Waterman for the Cell broadband engine</source>
        <comment>
          <ext-link ext-link-type="uri" xlink:href="http://cudasw.sourceforge.net/sw-cellbe.pdf">http://cudasw.sourceforge.net/sw-cellbe.pdf</ext-link>
        </comment>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Liu</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Schmidt</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Voss</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Muller-Wittig</surname>
          <given-names>W</given-names>
        </name>
        <article-title>Streaming algorithms for biological sequence alignment on GPUs</article-title>
        <source>IEEE Trans Parallel Distr Syst</source>
        <year>2007</year>
        <volume>18</volume>
        <issue>9</issue>
        <fpage>1270</fpage>
        <lpage>1281</lpage>
      </mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Manavski</surname>
          <given-names>SA</given-names>
        </name>
        <name>
          <surname>Valle</surname>
          <given-names>G</given-names>
        </name>
        <article-title>CUDA compatible GPU cards as efficient hardware accelerators for Smith-Waterman sequence alignment</article-title>
        <source>BMC Bioinformatics</source>
        <year>2008</year>
        <volume>9</volume>
        <issue>Suppl2</issue>
        <fpage>S10</fpage>
        <?supplied-pmid 19091009?>
        <pub-id pub-id-type="pmid">18387198</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Ligowski</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Rudnicki</surname>
          <given-names>W</given-names>
        </name>
        <article-title>An efficient implementation of Smith Waterman algorithm on GPU using CUDA, for massively parallel scanning of sequence databases</article-title>
        <source>IEEE International Symposium on Parallel &amp; Distributed Processing</source>
        <year>2009</year>
        <volume>2009</volume>
        <fpage>1</fpage>
        <lpage>8</lpage>
        <?supplied-pmid 22806676?>
        <pub-id pub-id-type="pmid">22806676</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Liu</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Schmidt</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Maskel</surname>
          <given-names>DL</given-names>
        </name>
        <article-title>CUDASW++2.0: enhanced Smith-Waterman protein database search on CUDA-enabled GPUs based on SIMT and virtualized SIMD abstractions</article-title>
        <source>BMC Research Notes</source>
        <year>2010</year>
        <volume>3</volume>
        <fpage>93</fpage>
        <pub-id pub-id-type="doi">10.1186/1756-0500-3-93</pub-id>
        <?supplied-pmid 20370891?>
        <pub-id pub-id-type="pmid">20370891</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Khajeh-Saeed</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Poole</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Perot</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Acceleration of the Smith–Waterman algorithm using single and multiple graphics processors</article-title>
        <source>J Comput Phys</source>
        <year>2010</year>
        <volume>229</volume>
        <fpage>4247</fpage>
        <lpage>4258</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jcp.2010.02.009</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Blazewicz</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Frohmberg</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Kierzynka</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Pesch</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Wojciechowski</surname>
          <given-names>P</given-names>
        </name>
        <article-title>Protein alignment algorithms with an efficient backtracking routine on multiple GPUs</article-title>
        <source>BMC Bioinformatics</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>181</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-12-181</pub-id>
        <?supplied-pmid 21599912?>
        <pub-id pub-id-type="pmid">21599912</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Hains</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Cashero</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Ottenberg</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Bohm</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Rajopadhye</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Improving CUDASW++, a parallelization of Smith-Waterman for CUDA enabled devices</article-title>
        <source>IEEE International Symposium on Parallel and Distributed Processing Workshops and Phd Forum</source>
        <year>2011</year>
        <volume>2011</volume>
        <fpage>490</fpage>
        <lpage>501</lpage>
      </mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Alachiotis</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Berger</surname>
          <given-names>SA</given-names>
        </name>
        <name>
          <surname>Stamatakis</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Coupling SIMD and SIMT architectures to boost performance of a phylogeny-aware alignment kernel</article-title>
        <source>BMC Bioinformatics</source>
        <year>2012</year>
        <volume>13</volume>
        <fpage>196</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-13-196</pub-id>
        <?supplied-pmid 22876807?>
        <pub-id pub-id-type="pmid">22876807</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Liu</surname>
          <given-names>CM</given-names>
        </name>
        <name>
          <surname>Wong</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Wu</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Luo</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Yiu</surname>
          <given-names>SM</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Yu</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Chu</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Zhao</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Lam</surname>
          <given-names>TW</given-names>
        </name>
        <article-title>SOAP3: ultra-fast GPU-based parallel alignment tool for short reads</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>28</volume>
        <issue>6</issue>
        <fpage>878</fpage>
        <lpage>789</lpage>
        <pub-id pub-id-type="pmid">22285832</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B32">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Camacho</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Coulouris</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Avagyan</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Ma</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Papadopoulos</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Bealer</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Madden</surname>
          <given-names>TL</given-names>
        </name>
        <article-title>BLAST+: architecture and applications</article-title>
        <source>BMC Bioinformatics</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>421</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-10-421</pub-id>
        <?supplied-pmid 20003500?>
        <pub-id pub-id-type="pmid">20003500</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B33">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Lindholm</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Nickolls</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Oberman</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Montrym</surname>
          <given-names>J</given-names>
        </name>
        <article-title>NVIDIA Tesla: a unified graphics and computing architecture</article-title>
        <source>IEEE Micro</source>
        <year>2008</year>
        <volume>28</volume>
        <issue>2</issue>
        <fpage>39</fpage>
        <lpage>55</lpage>
      </mixed-citation>
    </ref>
    <ref id="B34">
      <mixed-citation publication-type="book">
        <collab>NVIDIA</collab>
        <source>NVIDIA’s next generation CUDA compute architecture: Fermi</source>
        <year>2009</year>
        <publisher-name>USA: NVIDIA Corporation Whitepaper</publisher-name>
        <?supplied-pmid 23559506?>
      </mixed-citation>
    </ref>
    <ref id="B35">
      <mixed-citation publication-type="book">
        <collab>NVIDIA</collab>
        <source>NVIDIA’s Next Generation CUDA Compute Architecture: Kepler GK110</source>
        <year>2012</year>
        <publisher-name>USA: NVIDIA Corporation Whitepaper</publisher-name>
        <?supplied-pmid 23559506?>
      </mixed-citation>
    </ref>
    <ref id="B36">
      <mixed-citation publication-type="other">
        <collab>NVIDIA</collab>
        <source>Tuning CUDA Applications for Kepler</source>
        <comment>
          <ext-link ext-link-type="uri" xlink:href="http://docs.nvidia.com/cuda/kepler-tuning-guide/index.html">http://docs.nvidia.com/cuda/kepler-tuning-guide/index.html</ext-link>
        </comment>
      </mixed-citation>
    </ref>
    <ref id="B37">
      <mixed-citation publication-type="book">
        <collab>NVIDIA</collab>
        <source>Parallel thread execution ISA version 3.1</source>
        <year>2012</year>
        <publisher-name>USA: NVIDIA Corporation Whitepaper</publisher-name>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
