<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6129281</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/bty560</article-id>
    <article-id pub-id-type="publisher-id">bty560</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Eccb 2018: European Conference on Computational Biology Proceedings</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Data</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>fastp: an ultra-fast all-in-one FASTQ preprocessor</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Chen</surname>
          <given-names>Shifu</given-names>
        </name>
        <xref ref-type="aff" rid="bty560-aff1">1</xref>
        <xref ref-type="aff" rid="bty560-aff2">2</xref>
        <xref ref-type="corresp" rid="bty560-cor1"/>
        <!--<email>chen@haplox.com</email>-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Zhou</surname>
          <given-names>Yanqing</given-names>
        </name>
        <xref ref-type="aff" rid="bty560-aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Chen</surname>
          <given-names>Yaru</given-names>
        </name>
        <xref ref-type="aff" rid="bty560-aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Gu</surname>
          <given-names>Jia</given-names>
        </name>
        <xref ref-type="aff" rid="bty560-aff2">2</xref>
      </contrib>
    </contrib-group>
    <aff id="bty560-aff1"><label>1</label>Department of Bioinformatics, HaploX Biotechnology, Shenzhen, China</aff>
    <aff id="bty560-aff2"><label>2</label>Shenzhen Institutes of Advanced Technology, Chinese Academy of Sciences, Shenzhen, China</aff>
    <author-notes>
      <corresp id="bty560-cor1">To whom correspondence should be addressed. E-mail: <email>chen@haplox.com</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>01</day>
      <month>9</month>
      <year>2018</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2018-09-08">
      <day>08</day>
      <month>9</month>
      <year>2018</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>08</day>
      <month>9</month>
      <year>2018</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>34</volume>
    <issue>17</issue>
    <fpage>i884</fpage>
    <lpage>i890</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2018. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2018</copyright-year>
      <license license-type="cc-by-nc" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="bty560.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Quality control and preprocessing of FASTQ files are essential to providing clean data for downstream analysis. Traditionally, a different tool is used for each operation, such as quality control, adapter trimming and quality filtering. These tools are often insufficiently fast as most are developed using high-level programming languages (e.g. Python and Java) and provide limited multi-threading support. Reading and loading data multiple times also renders preprocessing slow and I/O inefficient.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We developed fastp as an ultra-fast FASTQ preprocessor with useful quality control and data-filtering features. It can perform quality control, adapter trimming, quality filtering, per-read quality pruning and many other operations with a single scan of the FASTQ data. This tool is developed in C++ and has multi-threading support. Based on our evaluation, fastp is 2–5 times faster than other FASTQ preprocessing tools such as Trimmomatic or Cutadapt despite performing far more operations than similar tools.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>The open-source code and corresponding instructions are available at <ext-link ext-link-type="uri" xlink:href="https://github.com/OpenGene/fastp">https://github.com/OpenGene/fastp</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">Special Funds for Future Industries of Shenzhen</named-content>
        </funding-source>
        <award-id>JSGG20160229123927512</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">National Science Foundation of China</named-content>
          <named-content content-type="funder-identifier">10.13039/501100001809</named-content>
        </funding-source>
        <award-id>61472411</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="7"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Quality control and preprocessing of sequencing data are critical to obtaining high-quality and high-confidence variants in downstream data analysis. Data can suffer from adapter contamination, base content biases and overrepresented sequences. Even worse, library preparation and sequencing steps always involve errors and can cause inaccurate representations of original nucleic acid sequences. Sequencing technologies, especially next-generation sequencing (NGS), have been broadly used in clinical applications in recent years, particularly for noninvasive prenatal testing (<xref rid="bty560-B2" ref-type="bibr">Bianchi <italic>et al.</italic>, 2015</xref>) and cancer diagnosis. For example, liquid biopsy technology (<xref rid="bty560-B8" ref-type="bibr">Esposito <italic>et al.</italic>, 2017</xref>), which seeks out cancer-related biomarkers in the circulatory system, can be used to facilitate cancer diagnosis and personalized treatment regimens. As a major technology in liquid biopsy, cell-free tumor DNA (ctDNA) sequencing is used to detect tumor-derived DNA fragments from plasma, urine and other circulating liquids. ctDNA sequencing data are usually highly noisy, and detected mutations often exhibit ultra-low mutation allele frequencies (MAF); quality control and data preprocessing are especially important for detecting low-MAF mutations to eliminate false positives and false negatives.</p>
    <p>Quality control and preprocessing of FASTQ data could be considered resolved given the availability of several relevant tools. For instance, FASTQC (<xref rid="bty560-B1" ref-type="bibr">Andrews, 2010</xref>) is a Java-based quality control tool providing per-base and per-read quality profiling features. Cutadapt (<xref rid="bty560-B13" ref-type="bibr">Martin, 2011</xref>) is a commonly used adapter trimmer, which also provides some read-filtering features. Trimmomatic (<xref rid="bty560-B3" ref-type="bibr">Bolger <italic>et al.</italic>, 2014</xref>), another popular trimming adapter tool, can perform quality pruning using algorithms such as sliding window cutting. SOAPnuke (<xref rid="bty560-B6" ref-type="bibr">Chen <italic>et al.</italic>, 2018</xref>) is a recently published tool for adapter trimming and read filtering with the implementation of MapReduce on Hadoop systems.</p>
    <p>In the past, multiple tools were employed for FASTQ data quality control and preprocessing. A typical combination was the use of FASTQC for quality control, Cutadapt for adapter trimming and Trimmomatic for read pruning and filtering. The requirement to read and load data multiple times made preprocessing slow and I/O inefficient. Yet the tools must be used in combination because no single tool currently exists that can effectively address all these problems. The authors developed AfterQC (<xref rid="bty560-B5" ref-type="bibr">Chen <italic>et al.</italic>, 2017</xref>) to integrate quality control, adapter trimming, data filtering and other useful functions into one tool. AfterQC is a convenient tool that can perform all necessary operations and output HTML-based reports with a single scan of FASTQ files. It also provides a novel algorithm to correct bases by searching for overlapping paired-end reads. However, because AfterQC was developed in Python, it is relatively slow and overly time-consuming when processing large FASTQ files.</p>
    <p>In this paper, we present <italic>fastp</italic>, an ultra-fast tool to perform quality control, read filtering and base correction for FASTQ data. It includes most features of FASTQC + Cutadapt + Trimmomatic + AfterQC while running 2–5 times faster than any of them alone. In addition to the functions available in these tools, <italic>fastp</italic> offers supplementary features such as unique molecular identifier (UMI) preprocessing, per-read polyG tail trimming and output splitting. <italic>fastp</italic> also provides quality control reports for pre- and post-filtered data within a single HTML page, which allows for direct comparison of quality statistics altered by preprocessing. <italic>fastp</italic> can automatically detect adapter sequences for single-end and paired-end Illumina data. In contrast with the aforementioned tools developed in Java or Python, <italic>fastp</italic> is developed in C/C++ with solid multi-threading implementation, making it much faster than its peers. Furthermore, based on the functions for correcting or eliminating sequencing errors, <italic>fastp</italic> can obtain even better clean data compared to conventional tools.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <p>As an all-in-one FASTQ preprocessor, <italic>fastp</italic> provides functions including quality profiling, adapter trimming, read filtering and base correction. It supports both single-end and paired-end short read data and also provides basic support for long-read data, which are typically generated by PacBio and Nanopore sequencers. In this section, we will first present the overall design of this tool and then explain how the major modules work.</p>
    <sec>
      <title>2.1 Overall design</title>
      <p><italic>fastp</italic> is designed for multi-threading parallel processing. Reads loaded from FASTQ files will be packed with a size of <italic>N</italic> (<italic>N</italic> = 1000). Each pack will be consumed by one thread in the pool, and each read of the pack will be processed. Each thread has an individual context to store statistical values of the reads it processes, such as per-cycle quality profiles, per-cycle base contents, adapter trimming results and k-mer counts. These values will be merged after all reads are processed, and a reporter will generate reports in HTML and JSON formats. <italic>fastp</italic> reports statistical values for pre-filtering and post-filtering data to facilitate comparisons of changes in data quality after filtering is complete.</p>
      <p><italic>fastp</italic> supports single-end (SE) and paired-end (PE) data. While most steps of SE and PE data processing are similar, PE data processing requires some additional steps such as overlapping analysis. For the sake of simplicity, we only demonstrate the main workflow of paired-end data preprocessing, shown in <xref ref-type="fig" rid="bty560-F1">Figure 1</xref>.</p>
      <p>
        <boxed-text id="bty560-BOX1" position="float" orientation="portrait">
          <sec>
            <title>Algorithm 1 adapter sequence detection</title>
            <p>for seed in sorted_adapter_seeds:</p>
            <p> seqs_after_seed = get_seqs_after(seed)</p>
            <p> forward_tree = build_nucleotide_tree(seqs_after_seed)</p>
            <p> found = True</p>
            <p> node = forward_tree.root</p>
            <p> after_seed = “”</p>
            <p> while node.is_not_leaf():</p>
            <p>  if node.has_dominant_child():</p>
            <p>   node = node.dominant_child()</p>
            <p>   after_seed = after_seed + node.base</p>
            <p>  else:</p>
            <p>   found = False</p>
            <p>   break</p>
            <p> if found == False:</p>
            <p>  continue</p>
            <p> else:</p>
            <p>  seqs_before_seed = get_seqs_before(seed)</p>
            <p>  backward_tree = build_nucleotide_tree(seqs_before_seed)</p>
            <p>  node = backward _tree.root</p>
            <p>  before_seed = “”</p>
            <p>  while node.is_not_leaf():</p>
            <p>   if node.has_dominant_child():</p>
            <p>     node = node.dominant_child()</p>
            <p>     before_seed = node.base + before_seed</p>
            <p>   else:</p>
            <p>     break</p>
            <p> adapter = before_seed + seed + after_seed</p>
            <p> break</p>
          </sec>
        </boxed-text>
      </p>
      <fig id="bty560-F1" orientation="portrait" position="float">
        <label>Fig. 1.</label>
        <caption>
          <p>Workflow of <italic>fastp.</italic> (<bold>a</bold>) Main workflow of paired-end data processing, and (<bold>b</bold>) paired-end preprocessor of one read pair. In the main workflow, a pair of FASTQ files is loaded and packed, after which each read pair is processed individually in the paired-end preprocessor, described in (b)</p>
        </caption>
        <graphic xlink:href="bty560f1"/>
      </fig>
    </sec>
    <sec>
      <title>2.2 Adapter trimming</title>
      <p><italic>fastp</italic> supports automatic adapter trimming for both single-end and paired-end Illumina data and uses different algorithms for each of these tasks. For single-end data, adapter sequences are detected by assembling the high-frequency read tails; for paired-end data, adapter sequences are detected by finding the overlap of each pair.</p>
      <p>The adapter-sequence detection algorithm is based on two assumptions: the first is that only one adapter exists in the data; the second is that adapter sequences exist only in the read tails. These two assumptions are valid for major next-generation sequencers like Illumina HiSeq series, NextSeq series and NovaSeq series. We compute the k-mer (<italic>k</italic> = 10) of first <italic>N</italic> reads (<italic>N</italic> = 1 M). From this k-mer, the sequences with high occurrence frequencies (&gt;0.0001) are considered as adapter seeds. Low-complexity sequences are removed because they are usually caused by sequencing artifacts. The adapter seeds are sorted by its occurrence frequencies. A tree-based algorithm is applied to extend the adapter seeds to find the real complete adapter, which is described by the pseudo code in Algorithm 1.</p>
      <p>In Algorithm 1, the function build_nucleotide_tree() is used to convert a set of sequences to a tree, in which each node is a nucleotide and each path of root to leaf is a sequence. A node’s dominant child is defined as its major child with a dominant percentage (&gt;90%). This algorithm tries to extend an adapter seed in the forward direction to check its validity since a valid adapter can always be extended to the read tails. And if this adapter seed is valid, a backward extension is applied to obtain the complete adapter sequence. The process of extending an adapter seed in forward and backward directions is given in <xref ref-type="fig" rid="bty560-F2">Figure 2</xref>.</p>
      <fig id="bty560-F2" orientation="portrait" position="float">
        <label>Fig. 2.</label>
        <caption>
          <p>A demonstration of extending an adapter seed in both forward and backward directions. The found adapter is GCAAATCGATCGACT, with the first two bases (GC) as the upstream sequence, the central ten bases as the adapter seed, and the last three bases (ACT) as the downstream sequence</p>
        </caption>
        <graphic xlink:href="bty560f2"/>
      </fig>
      <p>For paired-end data, <italic>fastp</italic> seeks the overlap of each pair and considers the bases that fall out of the overlapped regions as adapter contents. The overlapping detection algorithm was derived from our previous work, AfterQC. Compared to sequence-matching-based adapter-trimming tools like Cutadapt and Trimmomatic, a clear advantage of the overlap-analysis-based method is that it can trim adapters with few bases in the read tail. For example, most sequence-matching-based tools require a hatchment of at least three bases and cannot trim adapters with only one or two bases. In contrast, <italic>fastp</italic> can trim adapters with even only one base in the tail.</p>
      <p>Although <italic>fastp</italic> can detect adapter sequences automatically, it also provides interfaces to set specific adapter sequences for trimming. For SE data, if an adapter sequence is given, then automatic adapter-sequence detection will be disabled. For PE data, the adapter sequence will be used for sequence-matching-based adapter trimming only when <italic>fastp</italic> fails to detect a good overlap in the pair.</p>
    </sec>
    <sec>
      <title>2.3 Base correction</title>
      <p>For paired-end data, if one pair of reads can be detected with a good overlap, then the bases within the overlapped region can be compared. If the reads are of high quality, they are usually completely reverse-complemented.</p>
      <p>If any mismatches are found within the overlapped region, <italic>fastp</italic> will try to correct them. <italic>fastp</italic> only corrects a mismatched base pair with an imbalanced quality score, such as when one has a high-quality score (&gt;Q30) and the other has a low-quality score (&lt;Q15). To reduce false corrections, <italic>fastp</italic> only performs a correction if the total mismatch is below a given threshold <italic>T</italic> (<italic>T</italic> = 5).</p>
    </sec>
    <sec>
      <title>2.4 Sliding window quality pruning</title>
      <p>To improve the read quality, <italic>fastp</italic> supports a sliding window method to drop the low-quality bases of each read’s head and tail. The window can slide from either 5′ to 3′ or from 3′ to 5′, and the average quality score within the window is evaluated. If the average quality is lower than a given threshold, then the bases in the window will be marked as discarded and the window will be moved forward by one base; otherwise, the algorithm ends.</p>
    </sec>
    <sec>
      <title>2.5 polyG and polyX tail trimming</title>
      <p>PolyG is a common issue observed in Illumina NextSeq and NovaSeq series, which are based on two-color chemistry. Such systems use two different lights (i.e. red and green) to represent four bases: a base with only a detected red-light signal is called C; a base with only a detected green light signal is called T; a base with both red and green light detected is called A; and a base with no light detected is called G. However, as the sequencing by synthesis proceeds to subsequent cycles, the signal strength of each DNA cluster becomes progressively weaker. This issue causes some T and C to be wrongly interpreted as G in the read tails, a problem otherwise known as a polyG tail.</p>
      <p><italic>fastp</italic> can detect and trim the polyG in the read tails. It checks the flow cell identifier to determine whether the data are from Illumina NextSeq or NovaSeq sequencers, and if so, it automatically enables polyG tai trimming. The polyG tail issue can result in a serious base content separation problem, meaning that A and T or C and G have substantially different base content ratios. <xref ref-type="fig" rid="bty560-F3">Figure 3</xref> shows an example of data exhibiting a polyG tail issue and how the problem is ad-dressed with fastp preprocessing.</p>
      <fig id="bty560-F3" orientation="portrait" position="float">
        <label>Fig. 3.</label>
        <caption>
          <p>The base content ratio curves generated by fastp for one Illumina NextSeq FASTQ file. (<bold>a</bold>) Before fastp preprocessing, and (<bold>b</bold>) after fastp preprocessing. As depicted in (a), the G curve is abnormal and the G/C curves are separated. In (b), the G/C separation problem is eliminated</p>
        </caption>
        <graphic xlink:href="bty560f3"/>
      </fig>
      <p><italic>fastp</italic> also implements polyX tail trimming, where X means any base of A/T/C/G. This function can be used to trim the low-complexity consecutive bases in 3′ end. PolyX tail trimming and polyG tail trimming can be enabled together. In this case, polyG tail trimming will be applied first since polyG is usually caused by sequencing artifacts and should be trimmed first.</p>
    </sec>
    <sec>
      <title>2.6 UMI preprocessing</title>
      <p>Recently, UMI technology was proposed to reduce background noise and improve sensitivity when detecting ultra-low frequency mutations in deep-sequencing applications (i.e. ctDNA sequencing). The UMI method can be used to remove duplications and generate high-quality consensus reads. It has been adopted by various sequencing methods such as Duplex-Seq (<xref rid="bty560-B9" ref-type="bibr">Kennedy <italic>et al.</italic>, 2014</xref>) and iDES (<xref rid="bty560-B14" ref-type="bibr">Newman <italic>et al.</italic>, 2016</xref>). For Illumina sequencing platforms, UMI can be integrated into the sample index or inserted DNA. UMI should be shifted to the read identifier to be retained by alignment tools like BWA (<xref rid="bty560-B11" ref-type="bibr">Li and Durbin, 2009</xref>) or Bowtie (<xref rid="bty560-B10" ref-type="bibr">Langmead <italic>et al.</italic>, 2012</xref>).</p>
      <p>Some tools have already been developed for preprocessing UMI-integrated FASTQ data, such as UMI-tools (<xref rid="bty560-B15" ref-type="bibr">Smith <italic>et al.</italic>, 2017</xref>) and umis (<xref rid="bty560-B16" ref-type="bibr">Valentine Svensson, 2018</xref>). However, these tools are not efficient enough and require individual execution that consumes additional I/O and computational resources. <italic>fastp</italic> supports UMI preprocessing with little overhead; that is, it supports UMI in either a sample index or inserted DNA (or both). Compared to UMI-tools or umis, <italic>fastp</italic> runs approximately 3 times faster even when performing other tasks simultaneously (i.e. QC and filtering). Performance evaluation results are discussed in the next section.</p>
    </sec>
    <sec>
      <title>2.7 Output splitting</title>
      <p>Parallel processing of NGS data has become a new trend, especially in a cloud-computing environment. In a typical parallel NGS data processing pipeline, an original FASTQ file will be split into multiple pieces, and each piece will be run with aligners and alignment adjustment tools to obtain the corresponding BAM file. These BAM files can then be merged into different forms for parallel variant calling.</p>
      <p><italic>fastp</italic> supports two splitting modes: splitting by file lines and splitting by file numbers. The latter is more complicated because <italic>fastp</italic> must evaluate the total lines of the input files, which is especially difficult for GZIP-compressed data. <italic>fastp</italic> evaluates total lines by comparing the stream size of the first 1 M reads.</p>
    </sec>
    <sec>
      <title>2.8 Duplication evaluation</title>
      <p>Duplication level evaluation is important to profile the diversity of the sequencing libraries. FASTQC evaluates duplication by first recording the reads appear in the first 100 000 records, and then counting these reads through the whole file. For each read, only the first 50 bp is used for the comparison to reduce computation cost and eliminate sequencing error interference. FASTQC’s method has a major drawback that it doesn’t support paired-end duplication analysis. For paired-end input, it detects duplicated reads for read1 and read2 individually. So it’s result only reflects the duplication level of read1 and read2 respectively, but doesn’t reflect the duplication level of the whole inserted DNA sequence. This may result in overestimation, particularly for high-depth sequencing while it’s quite common that two different DNA fragments share the starting sequences but have different lengths.</p>
      <p><italic>fastp</italic> supports duplication level evaluation for both single-end and paired-end data. Different from FASTQC that uses a hash table to store the duplication keys, <italic>fastp</italic> stores them by a duplication array <italic>D</italic> and a counting array <italic>C</italic> to provide much faster access. <italic>fastp</italic> computes two keys from a paired-end reads, the first 12 bp of read1 as <italic>key1</italic>, and first 32 bp of read2 as <italic>key2. key1</italic> is used to find the offset of array <italic>D</italic>, while <italic>key2</italic> is denoted by a 64-bit long integer for fast comparison. For each read pair, <italic>fastp</italic> looks up the array <italic>C</italic> by <italic>key1</italic>, and checks that whether it’s 0. If the count is 0, then the corresponding element of array <italic>D</italic> will be occupied by <italic>key2</italic>, and the count is reset as 1. If the count is not 0, the corresponding element of array <italic>D</italic> will be compared with <italic>key2</italic>, and the count will be increased by 1 only if they are identical. The arrays <italic>D</italic> and <italic>C</italic> have a size of 2<sup>24</sup>, which is much bigger than 100 000 used in FASTQC.</p>
      <p>Paired-end duplication analysis is very important to estimate more accurate duplication level. We conducted an experiment for a ∼10 000× paired-end cell-free DNA sequencing data to compare FASTQC and <italic>fastp</italic> for duplication evaluation. In the result, FASTQC reported duplication rates of 79.99% and 77.75% for read1 and read2 respectively, but <italic>fastp</italic> only reported a duplication rate of 16.22%. We then run <italic>fastp</italic> in single-end mode for read1 and read2 individually, and it reported duplication rates of 79.23% and 79.06 for read1 and read2 respectively, which are quite close to FASTQC’s result, but are obviously overestimated.</p>
      <p>In addition to evaluating the duplication levels, <italic>fastp</italic> also records the GC percentage for each read. The duplication level histogram and corresponding mean GC percentages are then presented together, as demonstrated in <xref ref-type="fig" rid="bty560-F4">Figure 4</xref>.</p>
      <fig id="bty560-F4" orientation="portrait" position="float">
        <label>Fig. 4.</label>
        <caption>
          <p>Duplication estimation. The read percentages and mean GC ratios of different duplication levels. The mean GC ratio curve is truncated since the reads with higher duplication level are too few to compute a stable mean value</p>
        </caption>
        <graphic xlink:href="bty560f4"/>
      </fig>
    </sec>
    <sec>
      <title>2.9 Overrepresented sequence analysis</title>
      <p>Some sequences, or even entire reads, can be overrepresented in FASTQ data. Analysis of these overrepresented sequences provides an overview of certain sequencing artifacts such as PCR over-duplication, polyG tails and adapter contamination. FASTQC offers an overrepresented sequence analysis module, however, according to the author’s introduction, FASTQC only tracks the first 1 M reads of the input file to conserve memory. We suggest that inferring the overall distribution from the first 1 M reads is not a reliable solution as the initial reads in Illumina FASTQ data usually originate from the edges of flowcell lanes, which may have lower quality and different patterns than the overall distribution.</p>
      <p>Unlike FASTQC, <italic>fastp</italic> samples all reads evenly to evaluate overrepresented sequences and eliminate partial distribution bias. To achieve an efficient implementation of this feature, we designed a two-step method. In the first step, <italic>fastp</italic> completely analyzes the first 1.5 M base pairs of the input FASTQ to obtain a list of sequences with relatively high occurrence frequency in different sizes. In the second step, <italic>fastp</italic> samples the entire file and counts the occurrence of each sequence. Finally, the sequences with high occurrence frequency are reported.</p>
      <p>Besides the occurrence frequency, fastp also records the positions of overrepresented sequences. This information is quite useful for diagnosing sequence quality issues. Some sequences tend to appear in the read head whereas others appear more often in the read tail. The distribution of overrepresented sequences is visualized in the HTML report. <xref ref-type="fig" rid="bty560-F5">Figure 5</xref> shows a demonstration of overrepresented sequence analysis results.</p>
      <fig id="bty560-F5" orientation="portrait" position="float">
        <label>Fig. 5.</label>
        <caption>
          <p>Overrepresented sequence analysis results. The right column shows the histogram of occurrence among all sequencing cycles</p>
        </caption>
        <graphic xlink:href="bty560f5"/>
      </fig>
    </sec>
    <sec>
      <title>2.10 Quality control and reporting</title>
      <p><italic>fastp</italic> supports filtering reads using a low-quality base percentage, <italic>N</italic> base number and read length. These filters are trivial and thus not described here. <italic>fastp</italic> also supports filtering low-complexity reads by evaluating the percentage of consecutive bases. <italic>fastp</italic> records the number of reads that were filtered out according to different filtering criteria.</p>
      <p><italic>fastp</italic> also provides comprehensive information on quality-profiling results. In contrast to FASTQC, <italic>fastp</italic> offers results for both pre-filtering and post-filtering data, which allows for evaluation of the filtering effect by comparing the figures directly. <italic>fastp</italic> also reports results in JSON and HTML format, the former of which contains all data visualized in the HTML report. The format of the JSON report is manually optimized to be easily readable by humans. The HTML report is a single standalone web page, with all figures created dynamically using JavaScript and web canvas. Additionally, <italic>fastp</italic> provides a full k-mer occurrence table for all 6-bp sequences. An online demonstration of the HTML report can be found at <ext-link ext-link-type="uri" xlink:href="http://opengene.org/fastp/fastp.html">http://opengene.org/fastp/fastp.html</ext-link>.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>We conducted several experiments to evaluate the performance of <italic>fastp</italic> in terms of speed and quality. We chose FASTQC, Cutadapt, Trimmomatic, SOAPnuke and AfterQC for performance comparison, and the results revealed that <italic>fastp</italic> is much faster than these tools while providing similar or even better quality.</p>
    <sec>
      <title>3.1 Speed evaluation</title>
      <p>We compared the speed of all six tools by preprocessing the B17NCB1 dataset, obtained from the National Center for Clinical Laboratories in China. This dataset is paired-end, containing 9316 M bases. We evaluated the used time for PE and SE mode, respectively. All tools were run with a single thread to ensure fair comparison. Results are listed in <xref rid="bty560-T1" ref-type="table">Table 1</xref>.
<table-wrap id="bty560-T1" orientation="portrait" position="float"><label>Table 1.</label><caption><p>Speed comparison of <italic>fastp</italic> and other software</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">Tool</th><th rowspan="1" colspan="1">Input</th><th rowspan="1" colspan="1">Time (min)</th><th rowspan="1" colspan="1">Throughput (reads/s)</th></tr></thead><tbody align="left"><tr><td rowspan="2" colspan="1">Fastp</td><td rowspan="1" colspan="1">SE</td><td align="char" char="." rowspan="1" colspan="1">6</td><td align="char" char="." rowspan="1" colspan="1">129397.9</td></tr><tr><td rowspan="1" colspan="1">PE</td><td align="char" char="." rowspan="1" colspan="1">13.3</td><td align="char" char="." rowspan="1" colspan="1">116750.0</td></tr><tr><td rowspan="2" colspan="1">FASTQC</td><td rowspan="1" colspan="1">SE</td><td align="char" char="." rowspan="1" colspan="1">13</td><td align="char" char="." rowspan="1" colspan="1">59722.1</td></tr><tr><td rowspan="1" colspan="1">PE</td><td align="char" char="." rowspan="1" colspan="1">25.8</td><td align="char" char="." rowspan="1" colspan="1">60185.1</td></tr><tr><td rowspan="2" colspan="1">Cutadapt</td><td rowspan="1" colspan="1">SE</td><td align="char" char="." rowspan="1" colspan="1">18</td><td align="char" char="." rowspan="1" colspan="1">43132.6</td></tr><tr><td rowspan="1" colspan="1">PE</td><td align="char" char="." rowspan="1" colspan="1">24.6</td><td align="char" char="." rowspan="1" colspan="1">63120.9</td></tr><tr><td rowspan="2" colspan="1">SOAPnuke</td><td rowspan="1" colspan="1">SE</td><td align="char" char="." rowspan="1" colspan="1">30.7</td><td align="char" char="." rowspan="1" colspan="1">25289.5</td></tr><tr><td rowspan="1" colspan="1">PE</td><td align="char" char="." rowspan="1" colspan="1">32.5</td><td align="char" char="." rowspan="1" colspan="1">47777.7</td></tr><tr><td rowspan="2" colspan="1">AfterQC</td><td rowspan="1" colspan="1">SE</td><td align="char" char="." rowspan="1" colspan="1">25.2</td><td align="char" char="." rowspan="1" colspan="1">30809.0</td></tr><tr><td rowspan="1" colspan="1">PE</td><td align="char" char="." rowspan="1" colspan="1">57.2</td><td align="char" char="." rowspan="1" colspan="1">27146.4</td></tr><tr><td rowspan="2" colspan="1">Trimmomatic</td><td rowspan="1" colspan="1">SE</td><td align="char" char="." rowspan="1" colspan="1">31.9</td><td align="char" char="." rowspan="1" colspan="1">24338.2</td></tr><tr><td rowspan="1" colspan="1">PE</td><td align="char" char="." rowspan="1" colspan="1">60.9</td><td align="char" char="." rowspan="1" colspan="1">25497.1</td></tr></tbody></table><table-wrap-foot><fn id="tblfn1"><p><italic>Note</italic>: Results for both paired-end (PE) and single-end (SE) input were compared.</p></fn></table-wrap-foot></table-wrap></p>
      <p>As indicated, fastp is much faster than other tools. The second-fastest tool is FASTQC, which takes about twice the time of fastp. However, FASTQC only performs quality control, whereas fastp performs quality control (for pre-filtering data and post-filtering data), data filtering and other operations. The other tools take 3–5 times longer than fastp. Because fastp was natively designed for multi-thread processing, it may demonstrate even higher performance when executed in real applications in multi-thread mode. As some of the selected tools do not support multi-threading, a multi-threading performance comparison is not provided.</p>
    </sec>
    <sec>
      <title>3.2 Quality evaluation</title>
      <p>To evaluate the adapter trimming and quality pruning of <italic>fastp</italic> compared to other tools (i.e. AfterQC, SOAPnuke, Trimmomatic and Cutadapt), we used an Illumina NextSeq PE150 dataset (NS_PE150). Among these tools, <italic>fastp</italic> and AfterQC can trim adapters via overlap analysis, whereas the other tools require adapter sequence input. We evaluated the amount of suspected adapters by searching the 33 bp-long adapter sequences from post-filtering data with tolerance of several mismatches; results are shown in <xref ref-type="fig" rid="bty560-F6">Figure 6</xref>.</p>
      <fig id="bty560-F6" orientation="portrait" position="float">
        <label>Fig. 6.</label>
        <caption>
          <p>Result of adapter trimming performance evaluation. The X-axis is the number of allowed mismatches when searching for suspected adapter sequences, and the Y-axis is the count of suspected adapter sequences</p>
        </caption>
        <graphic xlink:href="bty560f6"/>
      </fig>
      <p>From <xref ref-type="fig" rid="bty560-F6">Figure 6</xref>, we can learn that <italic>fastp</italic> and Trimmomatic give the best performance. The <italic>fastp</italic>-filtered data contains no suspected adapters when four or fewer mismatches are allowed. Comparing to <italic>fastp</italic>-filtered data, Trimmomatic-filtered data contains less suspected adapters when five or more mismatches are allowed, but contains more when four mismatches are allowed. The data filtered with Cutadapt, SOAPnuke or AfterQC contain a large number of suspected adapters when the allowed mismatches are four or more. Since AfterQC was not designed as a professional adapter-trimming tool, the data filtered by this tool even contains suspected adapters without any mismatch.</p>
      <p>To further evaluate filtering effectiveness, we mapped the data filtered by different tools to the reference genome hg19 using BWA-MEM and evaluated the mapping results with Samtools (<xref rid="bty560-B12" ref-type="bibr">Li <italic>et al.</italic>, 2009</xref>). Mimatches, clips and improper mappings were recorded for evaluation purposes. From our perspective, uncorrected sequencing errors contribute greatly to mismatches while residual adapters contribute to clips and improper mappings. Comparison results are presented in <xref rid="bty560-T2" ref-type="table">Table 2</xref>.
<table-wrap id="bty560-T2" orientation="portrait" position="float"><label>Table 2.</label><caption><p>Mismatches, clips and single-read maps of the data filtered with different tools</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">NS_PE150</th><th rowspan="1" colspan="1">Total map base (M)</th><th rowspan="1" colspan="1">Mismatched base (M)</th><th rowspan="1" colspan="1">Total map read (M)</th><th rowspan="1" colspan="1">Clip read (M)</th><th rowspan="1" colspan="1">Single- read map</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">Raw data</td><td align="char" char="." rowspan="1" colspan="1">3390</td><td align="char" char="." rowspan="1" colspan="1">19.8</td><td align="char" char="." rowspan="1" colspan="1">22.4</td><td align="char" char="." rowspan="1" colspan="1">6.16</td><td align="char" char="." rowspan="1" colspan="1">46025</td></tr><tr><td rowspan="1" colspan="1">Fastp</td><td align="char" char="." rowspan="1" colspan="1">3102</td><td align="char" char="." rowspan="1" colspan="1">10.6</td><td align="char" char="." rowspan="1" colspan="1">21.2</td><td align="char" char="." rowspan="1" colspan="1">0.30</td><td align="char" char="." rowspan="1" colspan="1">271</td></tr><tr><td rowspan="1" colspan="1">AfterQC</td><td align="char" char="." rowspan="1" colspan="1">3053</td><td align="char" char="." rowspan="1" colspan="1">12.3</td><td align="char" char="." rowspan="1" colspan="1">21.2</td><td align="char" char="." rowspan="1" colspan="1">0.64</td><td align="char" char="." rowspan="1" colspan="1">34099</td></tr><tr><td rowspan="1" colspan="1">SOAPnuke</td><td align="char" char="." rowspan="1" colspan="1">2981</td><td align="char" char="." rowspan="1" colspan="1">18.3</td><td align="char" char="." rowspan="1" colspan="1">19.7</td><td align="char" char="." rowspan="1" colspan="1">3.46</td><td align="char" char="." rowspan="1" colspan="1">36888</td></tr><tr><td rowspan="1" colspan="1">Trimmomatic</td><td align="char" char="." rowspan="1" colspan="1">3111</td><td align="char" char="." rowspan="1" colspan="1">12.8</td><td align="char" char="." rowspan="1" colspan="1">22.1</td><td align="char" char="." rowspan="1" colspan="1">0.75</td><td align="char" char="." rowspan="1" colspan="1">229111</td></tr><tr><td rowspan="1" colspan="1">Cutadapt</td><td align="char" char="." rowspan="1" colspan="1">3287</td><td align="char" char="." rowspan="1" colspan="1">19.8</td><td align="char" char="." rowspan="1" colspan="1">22.4</td><td align="char" char="." rowspan="1" colspan="1">1.05</td><td align="char" char="." rowspan="1" colspan="1">46195</td></tr></tbody></table></table-wrap></p>
      <p><italic>fastp</italic> generated the lowest number of mismatches, clipped reads and single-read mapped reads. Trimmomatic and Cutadapt generated much more clipped or single-read mapped reads. Given that Trimmomatic, Cutadapt and SOAPnuke are all based on adapter-sequence matching, they may fail to detect adapters when the adapter sequence only has a few bases. For example, Cutadapt requires at least 3 bp matching of the adapter sequence and the read for a sequence to be recognized as an adapter. If the adapter sequence has only one or two bases, it will not be detected and is often erroneously reported as either a mismatch or soft clip by the alignment tools.</p>
    </sec>
    <sec>
      <title>3.3 UMI evaluation</title>
      <p>UMI technology is widely used in cancer sequencing, especially ctDNA sequencing. To analyze NGS data with UMI integration, the FASTQ preprocessor should shift the UMI from the reads to the read identifiers. We ran UMI preprocessing on a FASTQ of 4 Gb Illumina PE150 data using <italic>fastp</italic>, umis and UMI-tools, respectively. The execution times were recorded and are reported in <xref rid="bty560-T3" ref-type="table">Table 3</xref>.
<table-wrap id="bty560-T3" orientation="portrait" position="float"><label>Table 3.</label><caption><p>UMI preprocessing time comparison of <italic>fastp</italic>, umis and UMI-tools</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">Tools</th><th rowspan="1" colspan="1">Time (min)</th><th rowspan="1" colspan="1">Throughput (read/s)</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">fastp</td><td align="char" char="." rowspan="1" colspan="1">4.6</td><td align="char" char="." rowspan="1" colspan="1">104302.9</td></tr><tr><td rowspan="1" colspan="1">umis</td><td align="char" char="." rowspan="1" colspan="1">12.43</td><td align="char" char="." rowspan="1" colspan="1">38599.6</td></tr><tr><td rowspan="1" colspan="1">UMI-tools</td><td align="char" char="." rowspan="1" colspan="1">28.38</td><td align="char" char="." rowspan="1" colspan="1">16906.4</td></tr></tbody></table></table-wrap></p>
      <p>Clearly, <italic>fastp</italic> is approximately 2.7 times faster than umis and about 6.1 times faster than UMI-tools. This evaluation was conducted with GZIP input and uncompressed output because umis does not support GZIP output. Considering that <italic>fastp</italic> can achieve high performance for UMI preprocessing, it has recently been adopted by the popular NGS pipeline framework, bcbio-nextgen (<xref rid="bty560-B4" ref-type="bibr">Brad Chapman, 2018</xref>).</p>
    </sec>
    <sec>
      <title>3.4 Downstream analysis evaluation</title>
      <p>We conducted an experiment to evaluate how <italic>fastp</italic> preprocessing improves downstream analysis. The standard dataset NA12878 (SRR952827) was selected for benchmarking <italic>fastp</italic>, Trimmomatic, Cutadapt and SOAPNuke, for their performance on reducing false positive variants. These tools were used to filter the dataset respectively, and SpeedSeq (<xref rid="bty560-B7" ref-type="bibr">Chiang <italic>et al.</italic>, 2015</xref>) was used to call variants from the filtered data. The variants called from these filtered data, but not found in the NA12878 curated variants were counted as false positive variants. Finally, The data filtered by Trimmomatic, SOAPNuke, Cutadapt and <italic>fastp</italic> were detected with 7174, 7040, 6942 and 6708 false positive variants respectively. This result showed that <italic>fastp</italic> preprocessing could improve the specificity of downstream analysis.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>In this paper, we introduced <italic>fastp</italic>, an ultra-fast all-in-one FASTQ preprocessor. <italic>fastp</italic> is a versatile tool that can perform quality profiling, read filtering, read pruning, adapter trimming, polyG/polyX tail trimming, UMI preprocessing and other operations with a single scan of FASTQ files. Additionally, it can split output into multiple files for parallel processing.</p>
    <p>We evaluated the performance of speed and quality of <italic>fastp</italic> against other tools. The results indicate that <italic>fastp</italic> is much faster than its counterparts and provides the highest-quality data filtering of all other tested options. Due to its high speed and rich functions in FASTQ file quality control and filtering, <italic>fastp</italic> has gained many community users.</p>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgements</title>
    <p>The authors would like to thank <italic>fastp</italic> community users for providing feature requests and identifying bugs.</p>
  </ack>
  <sec>
    <title>Funding</title>
    <p>This work was financed by Special Funds for Future Industries of Shenzhen (No. JSGG20160229123927512) and the National Science Foundation of China (No. 61472411).</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </sec>
  <ref-list>
    <title>References</title>
    <ref id="bty560-B1">
      <mixed-citation publication-type="web"><person-group person-group-type="author"><name name-style="western"><surname>Andrews</surname><given-names>S.</given-names></name></person-group> (<year>2010</year>) 
<article-title>A quality control tool for high throughput sequence data</article-title>. <ext-link ext-link-type="uri" xlink:href="http://www.bioinformatics.babraham.ac.uk/projects/fastqc/">http://www.bioinformatics.babraham.ac.uk/projects/fastqc/</ext-link>.</mixed-citation>
    </ref>
    <ref id="bty560-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bianchi</surname><given-names>D.W.</given-names></name><etal>et al</etal></person-group> (<year>2015</year>) 
<article-title>Noninvasive prenatal testing and incidental detection of occult maternal malignancies</article-title>. <source>JAMA</source>, <volume>314</volume>, <fpage>162</fpage>–<lpage>169</lpage>.<pub-id pub-id-type="pmid">26168314</pub-id></mixed-citation>
    </ref>
    <ref id="bty560-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bolger</surname><given-names>A.M.</given-names></name><etal>et al</etal></person-group> (<year>2014</year>) 
<article-title>Trimmomatic: a flexible trimmer for Illumina sequence data</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>2114</fpage>–<lpage>2120</lpage>.<pub-id pub-id-type="pmid">24695404</pub-id></mixed-citation>
    </ref>
    <ref id="bty560-B4">
      <mixed-citation publication-type="web"><person-group person-group-type="author"><name name-style="western"><surname>Brad Chapman</surname><given-names>R.K.</given-names></name><etal>et al</etal></person-group> (<year>2018</year>) <source>Validated, Scalable, Community Developed Variant Calling, RNA-Seq and Small RNA Analysis</source>, <ext-link ext-link-type="uri" xlink:href="https://github.com/chapmanb/bcbio-nextgen">https://github.com/chapmanb/bcbio-nextgen</ext-link>.</mixed-citation>
    </ref>
    <ref id="bty560-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chen</surname><given-names>S.</given-names></name><etal>et al</etal></person-group> (<year>2017</year>) 
<article-title>AfterQC: automatic filtering, trimming, error removing and quality control for fastq data</article-title>. <source>BMC Bioinformatics</source>, <volume>18</volume>, <fpage>80</fpage>–<lpage>91100</lpage>.<pub-id pub-id-type="pmid">28361673</pub-id></mixed-citation>
    </ref>
    <ref id="bty560-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chen</surname><given-names>Y.</given-names></name><etal>et al</etal></person-group> (<year>2018</year>) 
<article-title>SOAPnuke: a MapReduce acceleration-supported software for integrated quality control and preprocessing of high-throughput sequencing data</article-title>. <source>Gigascience</source>, <volume>7</volume>, <fpage>1</fpage>–<lpage>6</lpage>.</mixed-citation>
    </ref>
    <ref id="bty560-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chiang</surname><given-names>C.</given-names></name><etal>et al</etal></person-group> (<year>2015</year>) 
<article-title>SpeedSeq: ultra-fast personal genome analysis and interpretation</article-title>. <source>Nat. Methods</source>, <volume>12</volume>, <fpage>966</fpage>–<lpage>968</lpage>.<pub-id pub-id-type="pmid">26258291</pub-id></mixed-citation>
    </ref>
    <ref id="bty560-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Esposito</surname><given-names>A.</given-names></name><etal>et al</etal></person-group> (<year>2017</year>) 
<article-title>The emerging role of “Liquid Biopsies,” circulating tumor cells, and circulating cell-free tumor dna in lung cancer diagnosis and identification of resistance mutations</article-title>. <source>Curr. Oncol. Rep.</source>, <volume>19</volume>.</mixed-citation>
    </ref>
    <ref id="bty560-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Kennedy</surname><given-names>S.R.</given-names></name><etal>et al</etal></person-group> (<year>2014</year>) 
<article-title>Detecting ultralow-frequency mutations by duplex sequencing</article-title>. <source>Nat. Protoc.</source>, <volume>9</volume>, <fpage>2586</fpage>–<lpage>2606</lpage>.<pub-id pub-id-type="pmid">25299156</pub-id></mixed-citation>
    </ref>
    <ref id="bty560-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Langmead</surname><given-names>B.</given-names></name><etal>et al</etal></person-group> (<year>2012</year>) 
<article-title>Fast gapped-read alignment with Bowtie 2</article-title>. <source>Nat. Methods</source>, <volume>9</volume>, <fpage>357</fpage>–<lpage>359</lpage>.<pub-id pub-id-type="pmid">22388286</pub-id></mixed-citation>
    </ref>
    <ref id="bty560-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>H.</given-names></name>, <name name-style="western"><surname>Durbin</surname><given-names>R.</given-names></name></person-group> (<year>2009</year>) 
<article-title>Fast and accurate short read alignment with Burrows-Wheeler transform</article-title>. <source>Bioinformatics</source>, <volume>25</volume>, <fpage>1754</fpage>–<lpage>1760</lpage>.<pub-id pub-id-type="pmid">19451168</pub-id></mixed-citation>
    </ref>
    <ref id="bty560-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>H.</given-names></name><etal>et al</etal></person-group> (<year>2009</year>) 
<article-title>The Sequence Alignment/Map format and SAMtools</article-title>. <source>Bioinformatics</source>, <volume>25</volume>, <fpage>2078</fpage>–<lpage>2079</lpage>.<pub-id pub-id-type="pmid">19505943</pub-id></mixed-citation>
    </ref>
    <ref id="bty560-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Martin</surname><given-names>M.</given-names></name></person-group> (<year>2011</year>) 
<article-title>Cutadapt removes adapter sequences from high-throughput sequencing reads</article-title>. <source>EMBnet J.</source>, <volume>17</volume>, <fpage>10</fpage>–<lpage>12</lpage>.</mixed-citation>
    </ref>
    <ref id="bty560-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Newman</surname><given-names>A.M.</given-names></name><etal>et al</etal></person-group> (<year>2016</year>) 
<article-title>Integrated digital error suppression for improved detection of circulating tumor DNA</article-title>. <source>Nat. Biotechnol.</source>, <volume>34</volume>, <fpage>547</fpage>–<lpage>555</lpage>.<pub-id pub-id-type="pmid">27018799</pub-id></mixed-citation>
    </ref>
    <ref id="bty560-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Smith</surname><given-names>T.</given-names></name><etal>et al</etal></person-group> (<year>2017</year>) 
<article-title>UMI-tools: modelling sequencing errors in Unique Molecular Identifiers to improve quantification accuracy</article-title>. <source>Genome Res.</source>, <volume>27</volume>, <fpage>491</fpage>–<lpage>499</lpage>.<pub-id pub-id-type="pmid">28100584</pub-id></mixed-citation>
    </ref>
    <ref id="bty560-B16">
      <mixed-citation publication-type="web"><person-group person-group-type="author"><name name-style="western"><surname>Valentine Svensson</surname><given-names>R.K.</given-names></name><etal>et al</etal></person-group> (<year>2018</year>) <source>Tools for Processing UMI RNA-Tag Data</source>, <ext-link ext-link-type="uri" xlink:href="https://github.com/vals/umis">https://github.com/vals/umis</ext-link>.</mixed-citation>
    </ref>
  </ref-list>
</back>
