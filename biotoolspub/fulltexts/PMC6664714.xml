<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6664714</article-id>
    <article-id pub-id-type="publisher-id">3002</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-019-3002-3</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>ROBOT: A Tool for Automating Ontology Workflows</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0003-4871-5569</contrib-id>
        <name>
          <surname>Jackson</surname>
          <given-names>Rebecca C.</given-names>
        </name>
        <address>
          <email>rbca.jackson@gmail.com</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Balhoff</surname>
          <given-names>James P.</given-names>
        </name>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Douglass</surname>
          <given-names>Eric</given-names>
        </name>
        <xref ref-type="aff" rid="Aff3">3</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Harris</surname>
          <given-names>Nomi L.</given-names>
        </name>
        <xref ref-type="aff" rid="Aff3">3</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Mungall</surname>
          <given-names>Christopher J.</given-names>
        </name>
        <xref ref-type="aff" rid="Aff3">3</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Overton</surname>
          <given-names>James A.</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <aff id="Aff1"><label>1</label>Knocean Inc., Toronto, Ontario Canada </aff>
      <aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 1034 1720</institution-id><institution-id institution-id-type="GRID">grid.410711.2</institution-id><institution>Renaissance Computing Institute, </institution><institution>University of North Carolina, </institution></institution-wrap>Chapel Hill, North Carolina USA </aff>
      <aff id="Aff3"><label>3</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 2231 4551</institution-id><institution-id institution-id-type="GRID">grid.184769.5</institution-id><institution>Lawrence Berkeley National Laboratory, </institution></institution-wrap>Berkeley, California USA </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>29</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>29</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2019</year>
    </pub-date>
    <volume>20</volume>
    <elocation-id>407</elocation-id>
    <history>
      <date date-type="received">
        <day>9</day>
        <month>10</month>
        <year>2018</year>
      </date>
      <date date-type="accepted">
        <day>19</day>
        <month>7</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s). 2019</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold>This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p id="Par1">Ontologies are invaluable in the life sciences, but building and maintaining ontologies often requires a challenging number of distinct tasks such as running automated reasoners and quality control checks, extracting dependencies and application-specific subsets, generating standard reports, and generating release files in multiple formats. Similar to more general software development, automation is the key to executing and managing these tasks effectively and to releasing more robust products in standard forms.</p>
        <p id="Par2">For ontologies using the Web Ontology Language (OWL), the OWL API Java library is the foundation for a range of software tools, including the Protégé ontology editor. In the Open Biological and Biomedical Ontologies (OBO) community, we recognized the need to package a wide range of low-level OWL API functionality into a library of common higher-level operations and to make those operations available as a command-line tool.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p id="Par3">ROBOT (a recursive acronym for “ROBOT is an OBO Tool”) is an open source library and command-line tool for automating ontology development tasks. The library can be called from any programming language that runs on the Java Virtual Machine (JVM). Most usage is through the command-line tool, which runs on macOS, Linux, and Windows. ROBOT provides ontology processing commands for a variety of tasks, including commands for converting formats, running a reasoner, creating import modules, running reports, and various other tasks. These commands can be combined into larger workflows using a separate task execution system such as GNU Make, and workflows can be automatically executed within continuous integration systems.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p id="Par4">ROBOT supports automation of a wide range of ontology development tasks, focusing on OBO conventions. It packages common high-level ontology development functionality into a convenient library, and makes it easy to configure, combine, and execute individual tasks in comprehensive, automated workflows. This helps ontology developers to efficiently create, maintain, and release high-quality ontologies, so that they can spend more time focusing on development tasks. It also helps guarantee that released ontologies are free of certain types of logical errors and conform to standard quality control checks, increasing the overall robustness and efficiency of the ontology development lifecycle.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Ontology development</kwd>
      <kwd>Automation</kwd>
      <kwd>Ontology release</kwd>
      <kwd>Reasoning</kwd>
      <kwd>Workflows</kwd>
      <kwd>Quality control</kwd>
      <kwd>Import management</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000016</institution-id>
            <institution>U.S. Department of Health and Human Services</institution>
          </institution-wrap>
        </funding-source>
        <award-id>HHSN272201200010C</award-id>
      </award-group>
    </funding-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000060</institution-id>
            <institution>National Institute of Allergy and Infectious Diseases</institution>
          </institution-wrap>
        </funding-source>
        <award-id>1-U19-AI-118626-01</award-id>
      </award-group>
    </funding-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000051</institution-id>
            <institution>National Human Genome Research Institute</institution>
          </institution-wrap>
        </funding-source>
        <award-id>R24-HG010032</award-id>
        <award-id>U41HG002273</award-id>
      </award-group>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2019</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p id="Par17">Ontologies are vital parts of the informatics ecosystem supporting life science research, enabling analysis of high-throughput datasets, data standardization and integration, search, and discovery. However, there is a lack of tools supporting the complete ontology development lifecycle, especially when compared with the software development lifecycle. This has resulted in many groups developing their own ad-hoc ontology development workflows, often with time-consuming and inefficient manual steps. In some cases, groups release ontologies without any kind of systematic workflow or quality control process, which can result in errors or problems with downstream applications or analyses.</p>
    <p id="Par18">Noy, Tudorache, Nyulas, and Musen (2010) describes a general ontology lifecycle with a focus on bio-ontologies [<xref ref-type="bibr" rid="CR1">1</xref>]. First, requirements for the ontology are gathered. Then, the ontology is collaboratively developed in an ontology editor such as Protégé [<xref ref-type="bibr" rid="CR2">2</xref>]. Once the requirements have been fulfilled, the ontology is published, and feedback is solicited from the community. Feedback is integrated back into development, and the ontology is continuously updated and released. At any point after the initial publication, the ontology may be deployed in other applications.</p>
    <p id="Par19">In broad strokes, this ontology development lifecycle reflects much of our experience of ontology development in the Open Biological and Biomedical Ontologies (OBO) community [<xref ref-type="bibr" rid="CR3">3</xref>], circa 2010. A wide range of Semantic Web software exists to support these steps, including many tools for Web Ontology Language (OWL) ontology development. In practice, though, the OBO community has relied predominantly on the free and open source Protégé OWL editor for manual editing and conversion, and on a small set of other tools supporting OBO conventions.</p>
    <p id="Par20">Other than Protégé, the most prominent suite of tools used by the OBO community has been the Onto-animal suite developed by the He group [<xref ref-type="bibr" rid="CR4">4</xref>] including Ontobee [<xref ref-type="bibr" rid="CR5">5</xref>], Ontofox [<xref ref-type="bibr" rid="CR6">6</xref>], and Ontorat [<xref ref-type="bibr" rid="CR7">7</xref>]. These tools are free web services backed by a Virtuoso triplestore loaded with the latest version of all available OBO community ontologies, as well as some other ontologies. Ontobee is an ontology term browser. Ontofox implements the MIREOT term extraction method [<xref ref-type="bibr" rid="CR8">8</xref>]. Ontorat implements template-based ontology term creation. Together with a few other tools, these support an extensible ontology development strategy [<xref ref-type="bibr" rid="CR9">9</xref>] covering a range of ontology development tasks, many of which can combined and automated using a sequence of web-based API calls.</p>
    <p id="Par21">The core operations of the Onto-animal suite are driven by SPARQL queries against the centralized triplestore. This results in a number of limitations. First, only the specific version of each ontology loaded into that triplestore can be used. This is a particularly severe limitation during ontology development. Second, processing is done on the centralized server, limiting the processing power available to any user. Third, SPARQL has limited utility when working with OWL logical axioms.</p>
    <p id="Par22">These limitations are mitigated by running software locally, loading the desired versions of the desired ontologies, and using OWL API [<xref ref-type="bibr" rid="CR10">10</xref>] for OWL-native processing. A number of tools used in the OBO community have done precisely this. We have seen a spectrum of development, from tools that are focused on a single project, to tools used by a dozen related projects, to the current push for tools that are shared across the OBO community.</p>
    <p id="Par23">Slimmer [<xref ref-type="bibr" rid="CR11">11</xref>], created as part of the eNanoMapper ontology project [<xref ref-type="bibr" rid="CR12">12</xref>], uses OWL API to create ontology subsets (also known as “slims”). A configuration file allows the user to specify which terms to include and which annotations to include on those terms. OntoPilot [<xref ref-type="bibr" rid="CR13">13</xref>], developed for the Plant Phenotype Ontology, uses OWL API via Jython (a version of Python that runs on the Java Virtual Machine) to provide an integrated ontology development framework, including term imports, term creation, releases, and documentation.</p>
    <p id="Par24">The lack of automation seen circa 2010 led directly to a lack of standardization, with each ontology editor or group adopting a slightly different approach to manual editing in Protégé. This diversity of practices, even within the OBO community, made it a challenge to develop tools to serve multiple ontology projects. OWLTools [<xref ref-type="bibr" rid="CR14">14</xref>] was designed for use by multiple OBO ontology projects, providing convenience methods on top of the OWL API. OWLTools includes the OBO Ontology Release Tool (OORT) [<xref ref-type="bibr" rid="CR15">15</xref>], a command-line tool to release OWL- and OBO-format ontologies. OORT provides a series of basic commands to create a release pipeline for an ontology, including module extraction with MIREOT, support for multiple input ontologies, reasoning, and creation of ‘main’ and ‘simple’ release products.</p>
    <p id="Par25">ROBOT (a recursive acronym for “ROBOT is an OBO Tool”) was developed to replace OWLTools and OORT with a more modular and maintainable code base. It builds on previous experience to include a comprehensive set of automation capabilities to support an even wider range of OBO projects. Development began in 2015 and continues with more than 1000 commits from a dozen contributors. ROBOT is freely available open source software. Although we do not track our users, a recent GitHub search shows that at least 26 ontology projects in the OBO community have adopted ROBOT.</p>
  </sec>
  <sec id="Sec2">
    <title>Implementation</title>
    <sec id="Sec3">
      <title>Overview</title>
      <p id="Par26">ROBOT provides a standardized yet configurable way to support the ontology development lifecycle via a library of common high-level functionality and a command-line interface. ROBOT builds on OWL API and is compatible with all ontology syntaxes that OWL API supports: RDF/XML, OWL/XML, Turtle, OWL Functional Syntax, OWL Manchester Syntax, and OBO format. The source code is written in Java and is available from our GitHub repository [<xref ref-type="bibr" rid="CR16">16</xref>] under an open source (BSD 3) license. It is also released as a Java library on Maven Central. ROBOT code can be used from any programming language that runs on the Java Virtual Machine (JVM). The command-line tool is packaged as a JAR file that can be run on Unix (including macOS and Linux), Windows, and other platforms supported by the JVM. This JAR file is available for download from the ROBOT GitHub site [<xref ref-type="bibr" rid="CR16">16</xref>], along with platform-specific scripts for using ‘robot’ from the command line. Installation instructions and documentation are available from <ext-link ext-link-type="uri" xlink:href="http://robot.obolibrary.org/">http://robot.obolibrary.org</ext-link>.</p>
    </sec>
    <sec id="Sec4">
      <title>Architecture</title>
      <p id="Par27">We previously described the basic architecture of the tool [<xref ref-type="bibr" rid="CR17">17</xref>], which we summarize here.</p>
      <p id="Par28">The ROBOT source code consists of two parts: ‘robot-core’ and ‘robot-command’. ‘robot-core’ is a library supporting common ontology development tasks, which we call “operations”. ‘robot-command’ provides a command-line interface divided into “commands”, each of which wraps a ‘robot-core’ operation.</p>
      <p id="Par29">Most ROBOT operations package low-level functionality provided by OWL API into high-level functionality common to ontology development workflows in the OBO community. For best compatibility, we aim to match the exact version of OWL API used by ROBOT with the exact version used by the latest Protégé release. Some operations use Apache Jena [<xref ref-type="bibr" rid="CR18">18</xref>]. Each operation works with Java objects that represent OWL ontologies, OWL reasoners, OWL classes, etc., while each command works with command-line option strings and files. The commands also perform various conversion and validation steps. The command-line interface uses the Apache Commons CLI library [<xref ref-type="bibr" rid="CR19">19</xref>] for parsing commands.</p>
      <p id="Par30">Each operation has a set of unit tests built with JUnit [<xref ref-type="bibr" rid="CR20">20</xref>] that are executed each time the final product (the JAR file) is generated. Each command in ROBOT is documented in its own web page (e.g. <ext-link ext-link-type="uri" xlink:href="http://robot.obolibrary.org/reason">http://robot.obolibrary.org/reason</ext-link>). The web pages are authored in Markdown format and contain embedded command-line examples that are parsed and executed as part of our integration tests, with the results compared against a “gold standard” set of outputs. ROBOT’s ‘diff’ functionality is used when comparing ontology files, otherwise standard file comparison is used. This helps ensure correctness and consistency of documentation and code. The unit tests and integration tests are executed on any pull request onto the codebase via Travis continuous integration (Travis CI) [<xref ref-type="bibr" rid="CR21">21</xref>], so that contributions to the codebase are verified.</p>
    </sec>
    <sec id="Sec5">
      <title>Commands and operations</title>
      <p id="Par31">ROBOT currently provides 15 operations (in the ‘robot-core’ library) and 19 commands (for the command-line interface). Some commands are quite specialized, and most ontology projects will not make use of all of them. Here we provide an overview of the most common and general commands. In each case, the core functionality is supported by operations in the ‘robot-core’ library, that can be used independently of the command-line interface from any programming language that runs on the JVM.</p>
    </sec>
    <sec id="Sec6">
      <title>Convert</title>
      <p id="Par32">A variety of OWL ontology formats are supported, including RDF/XML, Turtle, Manchester, OBO format, and more. To enable further interoperability, ROBOT includes a ‘convert’ command to change between supported ontology formats. A complete list of supported formats can be found in the ‘convert’ documentation [<xref ref-type="bibr" rid="CR22">22</xref>].</p>
    </sec>
    <sec id="Sec7">
      <title>Reasoning</title>
      <p id="Par33">Reasoning is one of the most important operations in ROBOT. The ‘reason’ command covers two uses: <italic>logical validation</italic> of an ontology and <italic>automatic classification</italic>. In both cases, users can choose their preferred reasoner, which is used to perform inference. Large ontologies such as the Gene Ontology typically use ELK [<xref ref-type="bibr" rid="CR23">23</xref>], which performs reasoning quickly using the OWL EL profile. Smaller ontologies with richer axiomatization, such as the Relations Ontology, typically use a complete OWL DL reasoner such as HermiT [<xref ref-type="bibr" rid="CR24">24</xref>].</p>
      <p id="Par34">When the ‘reason’ command is invoked on an input ontology, ROBOT will initiate a reasoner using the OWL API Reasoner interface. The resulting inferences are checked to ensure the ontology is <italic>logically coherent</italic>: the ontology must be consistent and have no unsatisfiable classes (i.e., classes that cannot be instantiated without introducing an inconsistency). If the ontology is incoherent, this is reported and execution halts. ROBOT can optionally perform additional checks, such as ensuring that no two classes are inferred to be equivalent post-reasoning.</p>
      <p id="Par35">If the ontology is consistent, ROBOT will perform automatic classification. All direct inferred ‘subClassOf’ axioms are added to the ontology. Generation of other types of axioms can be configured.</p>
      <p id="Par36">The assertion of all inferred axioms is often a fundamental step in the release process for biomedical ontologies. Many of these ontology classes only assert a single named superclass (‘A subClassOf B’, where B is another class in the ontology), and zero or more anonymous superclasses and/or anonymous equivalent classes (‘A subClassOf/equivalentTo (R some B)’, where R is an object property). These anonymous classes allow the reasoner to make inferences, which are then asserted. Therefore, in the release version of an ontology, a class may have more than one named superclass.</p>
      <p id="Par37">The ‘reason’ command has additional “helper” commands. The ‘relax’ command asserts entailed subClassOf axioms according to a simple structural rule: an expression ‘A equivalentTo (R some B) and …’ entails ‘A subClassOf R some B’. This can be useful as consumers of bio-ontologies often expect to navigate these expressions, e.g., partonomy in GO and Uberon. The ‘relax’ command relieves the ontology developer from the need to assert these in addition to the equivalence axioms, and as such it is also often included in release workflows. Finally, the ‘reduce’ command removes redundant subClassOf axioms, and can be used after ‘relax’ to remove duplicate axioms that were asserted in that step.</p>
      <p id="Par38">The ‘materialize’ command uses an Expression Materializing Reasoner (EMR) to assert inferred expressions of the form ‘A subClassOf R some B’ [<xref ref-type="bibr" rid="CR25">25</xref>]. Where the ‘reason’ command asserts inferred <italic>named</italic> superclasses, ‘materialize’ asserts <italic>anonymous</italic> superclasses. This is not part of the standard release cycle but can be beneficial for creating complete ontology subsets.</p>
    </sec>
    <sec id="Sec8">
      <title>Working with external ontologies</title>
      <p id="Par39">The OBO Foundry aims to coordinate ontologies in a modular fashion, such that parts of some ontologies can be used as building blocks for other ontologies. For example, the ChEBI chemical entities ontology [<xref ref-type="bibr" rid="CR26">26</xref>] is used to construct OWL definitions for metabolic processes and activities in the Gene Ontology [<xref ref-type="bibr" rid="CR27">27</xref>]. There are a variety of different strategies for leveraging external ontologies and managing dependencies between ontologies, depending on the use case.</p>
    </sec>
    <sec id="Sec9">
      <title>Extract</title>
      <p id="Par40">The ‘extract’ command creates a module based on a set of entities to extract (the “seed”). There are four different extraction methods (as specified by the ‘--method’ option): MIREOT, TOP, BOT, and STAR.</p>
      <p id="Par41">ROBOT’s MIREOT extraction method is based on the principle of the same name [<xref ref-type="bibr" rid="CR8">8</xref>] and requires that one or more “bottom” entities are specified. Optionally, one or more “top” entities can also be specified. The command extracts all the “bottom” level entities and their ancestors up to the “top” level from the input ontology. If no “top” entities are provided, ancestors up to the top-level entity (‘owl: Thing’) are included.</p>
      <p id="Par42">The TOP, BOT, and STAR methods make use of the OWL API Syntactic Locality Module Extraction (SLME) implementation, which is guaranteed to capture all information logically relevant to the seed set [<xref ref-type="bibr" rid="CR28">28</xref>]. The BOT method (“bottom”) includes all relationships between the input entities and their ancestors. The TOP method includes all relationships between the input entities and their descendants. Finally, the STAR method only includes all relationships between input entities. The STAR method produces the smallest outputs, while the TOP method typically produces the largest outputs.</p>
      <p id="Par43">In order to support ontology term provenance, the ‘extract’ command has an ‘--annotate-with-source true’ option that will annotate each extracted term with the URL of the source ontology that it is extracted from.</p>
    </sec>
    <sec id="Sec10">
      <title>Remove and filter</title>
      <p id="Par44">The ‘remove’ and ‘filter’ commands are used for fine-grained operations on OWL axioms. ‘remove’ allows users to choose which sets of axioms they wish to remove from a target ontology. ‘filter’ does the opposite, so that only selected axioms are copied from the input into a new output ontology.</p>
      <p id="Par45">These two commands work by starting with a seed set of entities, then applying various selectors to find related entities, and finally selecting which axiom types to remove or filter. We expect only a small number of “power users” to use this feature directly, but these commands will eventually provide a foundation for other higher-level commands.</p>
      <p id="Par46">These commands can be used to generate ontology subsets based on annotations by either filtering for or removing entities with the specified annotation. OBO Foundry ontologies often annotate classes with the ‘in subset’ property to specify where a class might be used. The annotation selector allows a user to provide a full annotation value or a pattern to match using regular expression.</p>
    </sec>
    <sec id="Sec11">
      <title>Merge</title>
      <p id="Par47">The ‘merge’ command combines two or more separate input ontologies into a single ontology. It also provides the ability to merge all imported ontologies of a single input ontology into one main ontology, which is often used when creating a release.</p>
      <p id="Par48">Merging imported ontologies (specified by import statements) into the input ontology is performed automatically, so that the user does not need to list each imported ontology as an input. We offer the option (‘--collapse-import-closure false’) to turn this feature off, supporting cases in which users may merge multiple input ontologies that have import statements but want to keep their imports separate.</p>
    </sec>
    <sec id="Sec12">
      <title>Querying and reporting</title>
      <p id="Par49">Ontology workflows typically include query operations over the ontology, producing reports which may be informative for both editors and users of the ontology -- for example, a table of all classes plus their textual definitions. Query operations can also be used for validation checks. The SPARQL query language provides a universal and declarative way for ontology maintainers to create ontology reports and validation checks [<xref ref-type="bibr" rid="CR29">29</xref>]. ROBOT provides a convenient way to perform queries with the ‘query’ command, or validation checks using ‘verify’. Additionally, the ‘report’ command includes a configurable package of standard queries for OBO projects that can be used in any ontology workflow, without requiring the maintainer to be familiar with SPARQL.</p>
    </sec>
    <sec id="Sec13">
      <title>Query</title>
      <p id="Par50">ROBOT’s ‘query’ command runs SPARQL queries on ontologies or other RDF resources. This can be used by an ontology maintainer to either perform interactive queries, or more typically to include standard queries into an ontology workflow. The ‘query’ command wraps one of the few operations that uses Apache Jena [<xref ref-type="bibr" rid="CR18">18</xref>], rather than OWL API. The Jena API allows ROBOT to load an ontology as a collection of triples contained by an RDF Model object. It provides a SPARQL query engine for those models, which we use to run all queries.</p>
      <p id="Par51">‘SPARQL SELECT’ queries produce a comma- or tab-separated table of results. ASK queries produce a file with a Boolean value. ‘SPARQL CONSTRUCT’ queries produce an RDF file, which can be further processed by ROBOT or merged back into the loaded ontology. ‘CONSTRUCT’s provide a convenient way of performing “macro” style expansion [<xref ref-type="bibr" rid="CR30">30</xref>]. ‘SPARQL UPDATE’ queries insert and/or remove data directly in an ontology (as an RDF Model). ROBOT converts the updated RDF Model back to an OWL API ontology object to be saved in any of the supported syntaxes.</p>
      <p id="Par52">The ‘query’ command supports an option to load imported ontologies as named graphs with the ‘--use-graphs’ option. If this is set to ‘true’, the imports can be queried as named graphs (the name being that ontology’s IRI) and the default graph is a union of all graphs. Using the default graph is similar to conducting a ‘merge’ of all the imports prior to querying, but the distinction between imports would be lost in a ‘merge’.</p>
    </sec>
    <sec id="Sec14">
      <title>Verify</title>
      <p id="Par53">The ‘verify’ command is a variation on the ‘SPARQL SELECT’ execution. The queries are used to ensure that an ontology conforms to a predetermined set of conditions; for example, ensuring that no class has multiple textual definitions. Given a SELECT query, ‘verify’ will succeed (i.e., exit with status code 0) if no results are returned. It will fail (i.e., exit with a non-zero status code) if any results are return from the query. So, given a SPARQL query that SELECTs for invalid data, the ‘verify’ command will verify that the ontology (or other resource) does not contain any such invalid data.</p>
    </sec>
    <sec id="Sec15">
      <title>Report</title>
      <p id="Par54">The ‘report’ command is an extension of ‘query’ and ‘verify’ that provides a series of configurable quality control (QC) checks for an ontology and returns a spreadsheet or YAML output of the violations. The spreadsheet is output in either comma- or tab-separated format and easy for a user to read, while the YAML output can be easily parsed by other programs.</p>
      <p id="Par55">The QC checks include annotation checks, logical checks, and metadata checks. Annotations are important to facilitate human comprehension, so the ‘report’ command finds cases where missing or duplicate annotations could cause problems. Logical checks look at the structural coherency and consistency of the ontology. Finally, ‘report’ identifies missing ontology metadata, as specified by OBO Foundry recommendations.</p>
      <p id="Par56">There are three levels of violations that are reported: ERROR, WARN, and INFO. An ERROR is the most severe, such as a missing or duplicate label. By default, the ‘report’ command fails if there are any ERROR-level violations, halting any automated build processes. These types of violations must be fixed before publishing an ontology. WARN-level violations should be fixed as soon as possible, e.g. inferred one-to-one class equivalencies, which are typically unintended in OBO projects. INFO is for recommended fixes that help maintain consistency across OBO Foundry ontologies, such as beginning a definition with an uppercase letter and ending with a period. ‘report’ can be configured with a command-line option to fail on a different violation level or to never fail, regardless of any violations. We document each QC check with a suggestion for a manual fix that the user can apply.</p>
      <p id="Par57">A default “profile” with report levels for each QC check is provided by ROBOT, but users are also able to create their own profiles. In these profiles, they can change the violation levels of individual checks, choose to exclude certain checks, and add their own checks as SPARQL queries. For example, some ontologies may categorize a class lacking a textual definition as an error, while others may categorize this as a warning. One of our goals is to converge on a standard profile that is maximally useful for the set of all ontologies in the OBO library, encouraging adoption of common quality control checks.</p>
    </sec>
    <sec id="Sec16">
      <title>Repair</title>
      <p id="Par58">Although most problems raised by ‘validate’ and ‘report’ must be fixed manually, ROBOT also provides a ‘repair’ command that can automatically fix certain problems. The current implementation will merge annotations on duplicate axioms and update references to deprecated classes when they are annotated with a suggested replacement. We intend to extend ‘repair’ to a wider range of common problems for which the correct fix is clear.</p>
    </sec>
    <sec id="Sec17">
      <title>Templated ontology development</title>
      <p id="Par59">ROBOT provides a template-driven ontology term generation system. Users also have the option to plug in their own term generation system into their workflow, such as Dead Simple OWL Design Patterns (DOS-DPs) [<xref ref-type="bibr" rid="CR31">31</xref>].</p>
      <p id="Par60">A huge amount of data is stored in spreadsheets and databases, and tabular formats are well suited to many sorts of data. ROBOT’s ‘template’ command allows users to convert tabular data into RDF/OWL format. A ROBOT template is simply a tab-separated values (TSV) or comma-separated values (CSV) file with some special conventions, which are outlined in the ROBOT ‘template’ documentation [<xref ref-type="bibr" rid="CR32">32</xref>].</p>
      <p id="Par61">These templates can be used for modular ontology development. The template spreadsheets may be maintained as part of the ontology’s source code repository, and instead of directly editing the ontology file, developers edit rows in the spreadsheet which correspond to terms in the ontology. The ‘template’ command is then used to generate a module of the ontology, which is included as an import statement in the editors’ version of the ontology and merged during the release process.</p>
    </sec>
    <sec id="Sec18">
      <title>Workflows</title>
      <p id="Par62">A workflow consists of a set of tasks coordinated by some workflow system. Ontology workflows consist of tasks such as executing QC checks, building import modules, reasoning over ontologies, and generating various ontology release products.</p>
      <p id="Par63">ROBOT itself is not a workflow manager, although it allows multiple commands to be chained together into one long command. When chaining ROBOT commands, the output ontology from one command is passed directly as the input to the next command. For example, chaining may be used to replace two commands that merge ontologies and then reason over the merged product:</p>
      <p id="Par64">`robot merge --input ont-1.owl --input ont-2.owl --output merged.owl.</p>
      <p id="Par65">robot reason --input merged.owl --output reasoned.owl`.</p>
      <p id="Par66">Instead of creating the merged product and running ‘reason’ over that, it can be done in one command:</p>
      <p id="Par67">`robot merge --input ont-1.owl --input ont-2.owl reason --output reasoned.owl`.</p>
      <p id="Par68">The key advantage to chaining is that ontologies do not have to be serialized and parsed between each step; the same OWL API ontology object is maintained in memory and passed through the chain of ROBOT commands. For large ontologies, chaining can vastly improve ROBOT’s performance.</p>
      <p id="Par69">Because ROBOT commands can be executed on the command line, a number of different workflow systems can be used. We highlight the use of GNU Make [<xref ref-type="bibr" rid="CR33">33</xref>], which is typically used to compile software. A Makefile consists of a set of rules used to make “targets”. In ontology development, the Makefile is used for automated tasks, such as preparing an ontology for release. In this case, the targets are usually ontology files. The “recipes” for the rules are Unix-style system commands, carried out by the ‘make’ command.</p>
      <p id="Par70">ROBOT commands can be used as the “recipes” to make the “targets”. A typical workflow will not use all 19 of the ROBOT commands. For example, not all ontology projects may use ROBOT templates and therefore not all release workflows need to include the ‘template’ command. Ontology developers can decide which commands are needed to perform the release and build a workflow around those commands. Figure <xref rid="Fig1" ref-type="fig">1</xref> shows a standard way in which a selection of ROBOT commands is combined for a release workflow.<fig id="Fig1"><label>Fig. 1</label><caption><p>The ROBOT release workflow. A typical release workflow using ROBOT. The ontology edit file ONT-edit.owl is first verified as a quality control check with ROBOT ‘verify’. Then, text files containing lists of external ontology terms in the imports directory are used to regenerate import modules using ‘extract’, ensuring that the imports are up-to-date. ONT-edit.owl is then passed through a series of ROBOT commands (‘reason’, ‘relax’, ‘reduce’, and ‘annotate’) to generate the release, ONT.owl. Finally, ONT.owl is converted to OBO format</p></caption><graphic xlink:href="12859_2019_3002_Fig1_HTML" id="MO1"/></fig></p>
      <p id="Par71">First, quality control checks are run over the editors’ version of the ontology with ‘report’ or ‘verify’. These look for equivalent classes, trailing whitespace in annotations, self-references, incorrect cross-reference syntax, and missing labels. The results are saved to a specified ‘reports/’ directory. If there are any ERROR-level violations, the task will fail and write the violations to a table so that they can be easily identified. This step allows developers to quickly see if new changes have introduced any problems within the ontology and fix them before releasing.</p>
      <p id="Par72">Assuming the initial QC check step has completed successfully, the next step is to create the import modules. The ROBOT ‘extract’ is run for each entry in a list of imports, which have corresponding term files (for the seed set) in the ‘imports/’ directory. This creates all the import modules in the same ‘imports/’ directory. This ensures that when an ontology is released with external terms, all external terms are up-to-date with the released versions of the source ontologies. Releasing out-of-date external terms can cause confusion, as the term will show both the old and new details in ontology search services like Ontobee [<xref ref-type="bibr" rid="CR5">5</xref>] and the Ontology Lookup Service [<xref ref-type="bibr" rid="CR34">34</xref>]. Additional QC checks can be run over the full ontology with imports using the ‘verify’ command or by running ‘report’ again.</p>
      <p id="Par73">Last, the main release products are created: the OWL file and the OBO file. To create the OWL release, the editors’ file is passed through a series of chained ROBOT commands: ‘reason’, ‘relax’, ‘reduce’, and ‘annotate’. This series of commands helps to ensure that the released ontology is both easy to browse and understand, as well as free of any redundant axioms. If any of these commands fail, the Make process will terminate with the corresponding error message. For example, if an ontology is incoherent the ‘reason’ step will fail. Finally, the ‘annotate’ command adds the version IRI to the ontology metadata. This OWL file is then converted to OBO format, at which point all targets are copied to a dated release directory.</p>
    </sec>
    <sec id="Sec19">
      <title>The Ontology Development Kit</title>
      <p id="Par74">Creating a Makefile to coordinate all these steps can be challenging. We make this easier for ontology developers by providing an Ontology Development Kit (ODK) [<xref ref-type="bibr" rid="CR35">35</xref>]. This can be used to create a GitHub repository following a standard layout, with a standard Makefile following the workflow detailed above. The resulting GitHub repository will also be automatically configured to run the validation steps (such as ‘report’) of the workflow via Travis CI [<xref ref-type="bibr" rid="CR21">21</xref>]. The workflow can also be executed using Docker with ODK containers released on Dockerhub [<xref ref-type="bibr" rid="CR36">36</xref>]. This allows easy execution of workflows on either the local computer of an ontology developer, with Travis CI, or through scalable-build tools such as Jenkins [<xref ref-type="bibr" rid="CR37">37</xref>].</p>
      <p id="Par75">ODK builds on ROBOT and demonstrates ROBOT’s utility, but a full discussion is beyond the scope of this article.</p>
    </sec>
  </sec>
  <sec id="Sec20">
    <title>Results and discussion</title>
    <p id="Par76">While there are many other Semantic Web and OWL development tools available, a number of factors have driven the OBO community to build and support ROBOT. First, the OBO commitment to open source development is a strong reason to use open source software. Second, our wide reliance on the free and open Protégé editor is a strong reason to use the same OWL API library that it is built upon. Third, there is a strong incentive to pool our limited resources and invest in shared tooling. Fourth, the OBO community has a range of conventions that support interoperability, and our workflows are simpler if we build these assumptions into the tools. Points three and four are clearly in tension: what is the right balance to strike between reusing general Semantic Web tools and building our own? Protégé, OWL API, and various OWL reasoners are general tools that we use, for instance, but we have strong conventions in our community for identifiers, release artifacts, metadata, quality control, etc. that these tools do not help us to enforce. Our compromise is to reuse open source tools as much as practical and invest community resources in customizing general tools such as OWL API to serve the needs of our community. A growing number of ontology developers are using ROBOT to help automate their quality-checking and release workflows. Two case studies are described here.</p>
    <sec id="Sec21">
      <title>Ontology for Biomedical Investigations</title>
      <p id="Par77">The Ontology for Biomedical Investigations (OBI) is an OBO Foundry ontology that aims to describe the processes, agents, devices, inputs, and outputs of scientific investigations [<xref ref-type="bibr" rid="CR38">38</xref>]. When the project began more than a decade ago, development was done in Protégé, without any automation, and hosted on SourceForge. Today, OBI uses ROBOT to implement an automated workflow, supported by GitHub pull requests and Travis CI testing. More than 50 people have contributed to OBI development, including two of the authors of this paper (Overton and Jackson).</p>
      <p id="Par78">OBI has always imported a range of terms from other OBO projects, and OBI developers have maintained a number of separate OWL files to facilitate concurrent development by different groups of developers. When it comes time to prepare a new release of OBI, the various OWL files must be merged, tested and reasoned over.</p>
      <p id="Par79">In the early days of the project, OBI developer Alan Ruttenberg wrote a series of scripts for quality control and common operations, but merging, reasoning, and testing a new release still involved many hours of work by OBI developers. In 2013, James Overton developed a precursor to ROBOT: an automated build tool written in Java, using OWL API and Apache Ant, that automated some of the build, test, and release processes. This drastically reduced the time required to make a release, allowing for more frequent releases. While this code was specific to OBI workflows, some of it was used in early versions of ROBOT.</p>
      <p id="Par80">In 2017 OBI moved from SourceForge to GitHub and the release workflow was updated to use ROBOT throughout. This change vastly increased the degree of automation for ontology development tasks, expanded capabilities, and allowed OBI to pool some of its development resources with the wider OBO community to support shared tooling. OBI currently uses a Makefile [<xref ref-type="bibr" rid="CR39">39</xref>] that defines a range of tasks for managing imports, converting templates, merging, reasoning, testing, and releasing new versions of OBI. The Makefile specifies various target files, and most target files are generated from a single ROBOT command or a single chain of ROBOT commands. The key steps are:<list list-type="order"><list-item><p id="Par81">Update imports from upstream ontologies (currently using Ontofox [<xref ref-type="bibr" rid="CR6">6</xref>]). OBI imports subsets of terms from more than a dozen OBO projects. As discussed, ROBOT supports this functionality with ‘extract’, but OBI’s use of Ontofox predates ROBOT development and has not yet been migrated.</p></list-item><list-item><p id="Par82">Normalize RDF/XML for cleaner history of changes in the version control system (‘robot convert’). Different versions of OWL API have slightly different serialization behavior, which can lead to spurious reports of differences that make it more difficult to see relevant changes to the source files.</p></list-item><list-item><p id="Par83">Convert template files (TSV) to OWL modules (‘robot template’). Templates often make it easier for domain experts to contribute to ontology development and enforce ontology design patterns that improve the overall quality of OBI.</p></list-item><list-item><p id="Par84">Merge imports and templates with ‘obi-edit.owl’ (‘robot merge’). OBI uses a number of import and template files to enforce a separation of concerns, rather than making all changes in a single source file. These are merged into a single release file.</p></list-item><list-item><p id="Par85">Use ‘SPARQL CONSTRUCT’ queries to update various term annotations (‘robot query’). Some standard term metadata can be automatically added and updated, rather than manually maintained.</p></list-item><list-item><p id="Par86">Run an automated test suite (‘robot verify’). A range of quality control checks helps to ensure that errors have not been introduced into OBI by recent changes.</p></list-item><list-item><p id="Par87">Run the HermiT reasoner (‘robot reason’). Reasoning checks the logical consistency of OBI and performs automated classification of terms.</p></list-item><list-item><p id="Par88">Update annotations for release (‘robot annotate’). These annotations include the dated version IRI of this release of OBI.</p></list-item><list-item><p id="Par89">Extract the OBI Core subset (‘robot extract’). The OBI Core subset provides approximately 100 important terms for educational and documentation purposes.</p></list-item><list-item><p id="Par90">Create a list of OBI terms (‘robot query’). The term list is used to report on the new terms added to OBI with each release.</p></list-item></list></p>
    </sec>
    <sec id="Sec22">
      <title>Disease Ontology</title>
      <p id="Par91">The Disease Ontology (DO) is an OBO Foundry ontology that provides a standardized description of human diseases, including the phenotypic characteristics, symptoms, genetic bases, and related medical terminology. These terms are used by various model organism databases to provide a consistent representation of diseases [<xref ref-type="bibr" rid="CR40">40</xref>]. The DO is developed at the University of Maryland School of Medicine by Lynn Schriml and her team, which currently includes one of the authors (Jackson).</p>
      <p id="Par92">In order to accurately and thoroughly describe the different aspects of diseases, DO makes use of more than 10 other biological ontologies. In the past, all DO imports were manually created and maintained. This led to inconsistencies as ontologies were updated and expanded, and also made it very difficult to add new entities to the imports.</p>
      <p id="Par93">In 2018, DO switched their entire automated build process (contained in the Makefile) from OWLTools [<xref ref-type="bibr" rid="CR14">14</xref>] and OORT [<xref ref-type="bibr" rid="CR15">15</xref>] to ROBOT. Instead of manually updating import modules, all required entities are now specified in text files. When a developer wishes to add a new imported entity, they simply add a line to the text file and run ‘make imports’. All imports are automatically regenerated during releases, as well, to keep the information up-to-date.</p>
      <p id="Par94">Before ROBOT, the monthly DO releases took multiple hours to run and required additional hours of manual editing and review. Now, DO developers simply run the ‘make release’ command and all content is generated in less than 20 min. The release process makes use of ROBOT commands such as ‘report’ to run quality control checks over the release products and reduce the time spent reviewing output.</p>
      <p id="Par95">Both ROBOT ‘verify’ and ‘report’ are used for DO’s Travis CI system [<xref ref-type="bibr" rid="CR21">21</xref>]. Each time a new commit is pushed to the GitHub repository, a series of queries is run against the ontology files to ensure they meet certain standards. If they do not (or if ‘report’ fails with an ERROR-level violation), Travis CI notifies developers that the checks have failed with a red “X” next to the commit. Clicking on the red “X” will take the user to Travis CI, where they can see the command log to determine what caused the failure. On success, a green checkmark is displayed next to the commit to show that the checks have passed.</p>
    </sec>
  </sec>
  <sec id="Sec23">
    <title>Conclusions</title>
    <p id="Par96">ROBOT makes it easy for ontology developers to automate a wide range of tedious and error-prone development tasks, freeing their time to focus on other important parts of the ontology life cycle. Circa 2010, most OBO projects were manually edited, with manual imports, manually tested, and manually released using only Protégé. With ROBOT, ontology developers have a convenient tool for building powerful workflows that include format conversion, reasoning, extracting, querying, updating, testing, reporting, templating, and more. Low-level OWL API and Apache Jena operations are packaged into a library of high-level operations, and these operations are wrapped in a convenient command-line interface that is supported on the common server and desktop platforms. With ODK, developers benefit not only from ROBOT, but additionally from a wide range of best practices and standard procedures developed and shared by the OBO community.</p>
    <p id="Par97">ROBOT is open source software developed by a community of a dozen contributors with more than 1000 commits, hundreds of closed issues, and six releases. The ROBOT source code is freely available on GitHub and Maven Central. Documentation for the library is available on Javadoc.io and documentation for the commands is available on our website at <ext-link ext-link-type="uri" xlink:href="http://robot.obolibrary.org">http://robot.obolibrary.org</ext-link>, where you will also find examples of usage, test files, and explanations of common errors.</p>
    <p id="Par98">With ROBOT, we have tried to strike a balance between general tools such as Protégé and the specific needs of the OBO community, and to deliver the benefits of automation from software development to ontology development.</p>
    <sec id="Sec24">
      <title>Availability and requirements</title>
      <p id="Par99"><bold>Project name:</bold> ROBOT (ROBOT is an OBO Tool).</p>
      <p id="Par100">
        <bold>Project home page:</bold>
        <ext-link ext-link-type="uri" xlink:href="http://robot.obolibrary.org/">http://robot.obolibrary.org/</ext-link>
      </p>
      <p id="Par101"><bold>Operating system(s):</bold> Platform-independent.</p>
      <p id="Par102"><bold>Programming language:</bold> Java 8.</p>
      <p id="Par103"><bold>Other requirements:</bold> None for the command-line tool. The ROBOT library depends on the following: Apache Jena, SnakeYAML, OpenCSV, FasterXML Jackson, OWL API, Apache Commons IO, Apache Maven, JSONLD-JAVA, Protégé, JUnit, SLF4J, and fmt-maven-plugin.</p>
      <p id="Par104"><bold>License:</bold> ROBOT is available under BSD 3. Dependencies are available under Apache 2.0 (Jena, SnakeYAML, OpenCSV, Jackson, OWL API, Commons IO, and Maven), BSD 3 (JSONLD-JAVA and Protégé), EPL-1.0 (JUnit), and MIT License (SLF4J and fmt-maven-plugin).</p>
      <p id="Par105"><bold>Any restrictions to use by non-academics:</bold> None other than those specified by the licenses.</p>
    </sec>
  </sec>
</body>
<back>
  <glossary>
    <title>Abbreviations</title>
    <def-list>
      <def-item>
        <term>CSV</term>
        <def>
          <p id="Par5">Comma-separated values</p>
        </def>
      </def-item>
      <def-item>
        <term>DL</term>
        <def>
          <p id="Par6">description logic</p>
        </def>
      </def-item>
      <def-item>
        <term>DO</term>
        <def>
          <p id="Par7">Disease Ontology</p>
        </def>
      </def-item>
      <def-item>
        <term>DOS-DP</term>
        <def>
          <p id="Par8">Dead Simple OWL Design Patterns</p>
        </def>
      </def-item>
      <def-item>
        <term>EMR</term>
        <def>
          <p id="Par9">Expression Materializing Reasoner</p>
        </def>
      </def-item>
      <def-item>
        <term>GUI</term>
        <def>
          <p id="Par10">graphical user interface</p>
        </def>
      </def-item>
      <def-item>
        <term>OBI</term>
        <def>
          <p id="Par11">Ontology for Biomedical Investigations</p>
        </def>
      </def-item>
      <def-item>
        <term>OBO</term>
        <def>
          <p id="Par12">Open Biological Ontologies</p>
        </def>
      </def-item>
      <def-item>
        <term>ODK</term>
        <def>
          <p id="Par13">Ontology Development Kit</p>
        </def>
      </def-item>
      <def-item>
        <term>OWL</term>
        <def>
          <p id="Par14">Web Ontology Language</p>
        </def>
      </def-item>
      <def-item>
        <term>ROBOT</term>
        <def>
          <p id="Par15">ROBOT is an OBO Tool</p>
        </def>
      </def-item>
      <def-item>
        <term>TSV</term>
        <def>
          <p id="Par16">Tab-separated values</p>
        </def>
      </def-item>
    </def-list>
  </glossary>
  <fn-group>
    <fn>
      <p>
        <bold>Publisher’s Note</bold>
      </p>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
  </fn-group>
  <ack>
    <p>We thank David Osumi-Sutherland for requirements and testing and Nico Matentzoglu for submitting bug reports and feature requests. We also thank all of our users and everyone who has participated in ROBOT development, from contributing code and documentation, to reporting bugs and requesting features.</p>
  </ack>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>RCJ, JAO and JPB wrote the manuscript. NH edited the manuscript. RCJ, JPB, ED, JAO and CJM developed and implemented the software. All authors read and approved the final manuscript.</p>
  </notes>
  <notes notes-type="funding-information">
    <title>Funding</title>
    <p>This work and related resources are supported by the following grants:</p>
    <p>· From the Department of Health and Human Services (NIH) for “Immune Epitope Database and Analysis Resource Program” (HHSN272201200010C).</p>
    <p>· From the National Institute of Allergy and Infectious Diseases (NIH) for “Human immune signatures of Dengue virus and Mycobacterium Tuberculosis exposure in infection, disease and vaccination” (1-U19-AI-118626-01).</p>
    <p>· From the National Human Genome Research Institute (NIH) for “Services to support the OBO foundry standards” (R24-HG010032).</p>
    <p>· From the National Human Genome Research Institute (NIH) for “Gene Ontology Consortium” (U41HG002273).</p>
    <p>These funding bodies did not play any role in the design of ROBOT, the interpretation of data, or the writing of this manuscript.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Availability of data and materials</title>
    <p>All code is available from <ext-link ext-link-type="uri" xlink:href="https://github.com/ontodev/robot/">https://github.com/ontodev/robot/</ext-link></p>
  </notes>
  <notes>
    <title>Ethics approval and consent to participate</title>
    <p id="Par106">Not applicable.</p>
  </notes>
  <notes>
    <title>Consent for publication</title>
    <p id="Par107">Not applicable.</p>
  </notes>
  <notes notes-type="COI-statement">
    <title>Competing interests</title>
    <p id="Par108">The authors declare that they have no competing interests. ROBOT development is largely funded by the grants acknowledged above. Knocean, Inc. is subcontracted for ROBOT development from those grants. Overton is president and owner of Knocean, Inc. Jackson is a contractor for Knocean, Inc.</p>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1.</label>
      <mixed-citation publication-type="other">Noy N, Tudorache T, Nyulas C, Musen M. The ontology life cycle: integrated tools for editing, publishing, peer review, and evolution of ontologies. AMIA Annu Symp Proc. 2010:552–6.</mixed-citation>
    </ref>
    <ref id="CR2">
      <label>2.</label>
      <mixed-citation publication-type="other">M. Horridge, D. Tsarkov, and T. Redmond, “Supporting early adoption of OWL 1.1 with Protégé-OWL and FaCT++,” OWLED, 2006.</mixed-citation>
    </ref>
    <ref id="CR3">
      <label>3.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smith</surname>
            <given-names>B</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The OBO foundry: coordinated evolution of ontologies to support biomedical data integration</article-title>
        <source>Nat Biotechnol</source>
        <year>2007</year>
        <volume>25</volume>
        <fpage>1251</fpage>
        <lpage>1255</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt1346</pub-id>
        <pub-id pub-id-type="pmid">17989687</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4.</label>
      <mixed-citation publication-type="other">Y. He, J. Zheng, and Y. Lin, “Onto-animal tools for reusing ontologies, generating and editing ontology terms, and dereferencing ontology terms,” Proceedings of the International Conference on Biomedical Ontology (ICBO) Lisbon: CEUR Workshop Proceedings, 2015.</mixed-citation>
    </ref>
    <ref id="CR5">
      <label>5.</label>
      <mixed-citation publication-type="other">E. Ong, Z. Xiang, B. Zhao, Y. Liu, Y. Lin, J. Zheng, C. Mungall, M. Courtot, A. Ruttenberg, and Y. He, “Ontobee: a linked ontology data server to support ontology term dereferencing, linkage, query and integration,” Proceedings of the 2nd international conference on biomedical ontologies (ICBO), pp. 279–281, 2011.</mixed-citation>
    </ref>
    <ref id="CR6">
      <label>6.</label>
      <mixed-citation publication-type="other">Z. Xiang, M. Courtot, R.R. Brinkman, A. Ruttenberg, and Y. He, “OntoFox: web-based support for ontology reuse,” BMC Research Notes, vol. 3, June 2010.</mixed-citation>
    </ref>
    <ref id="CR7">
      <label>7.</label>
      <mixed-citation publication-type="other">Z. Xiang, J. Zheng, Y. Lin, and Y. He, “Ontorat: automatic generation of new ontology terms, annotations, and axioms based on ontology design patterns,” Journal of Biomedical Semantics, vol. 6, Jan 2015.</mixed-citation>
    </ref>
    <ref id="CR8">
      <label>8.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Courtot</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Gibson</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Lister</surname>
            <given-names>AL</given-names>
          </name>
          <name>
            <surname>Malone</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Schober</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Brinkman</surname>
            <given-names>RR</given-names>
          </name>
          <name>
            <surname>Ruttenberg</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>MIREOT: the minimum information to reference an external ontology term</article-title>
        <source>Appl Ontol</source>
        <year>2011</year>
        <volume>6</volume>
        <fpage>23</fpage>
        <lpage>33</lpage>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9.</label>
      <mixed-citation publication-type="other">He Y, Xiang Z, Zheng J, Lin Y, Overton JA, Ong E. The eXtensible ontology development (XOD) principles and tool implementation to support ontology interoperability. Journal of Biomedical Semantics. Jan 2018;9.</mixed-citation>
    </ref>
    <ref id="CR10">
      <label>10.</label>
      <mixed-citation publication-type="other">M. Horridge, S. Bechhofer, and O. Noppens, “Igniting the OWL 1.1 touch paper: the OWL API,” OWLED, 2007.</mixed-citation>
    </ref>
    <ref id="CR11">
      <label>11.</label>
      <mixed-citation publication-type="other">enanomapper/slimmer: Slims ontologies. <ext-link ext-link-type="uri" xlink:href="https://github.com/enanomapper/slimmer/">https://github.com/enanomapper/slimmer/</ext-link> (n.d.). Accessed 21 May 2019.</mixed-citation>
    </ref>
    <ref id="CR12">
      <label>12.</label>
      <mixed-citation publication-type="other">J. Hastings, N. Jeliazkova, G. Owen, G. Tsiliki, C.R. Munteanu, C. Steinbeck, and E. Willighagen, “eNanoMapper: harnessing ontologies to enable data integration for nanomaterial risk assessment,” Journal of Biomedical Semantics, vol. 6, March 2015.</mixed-citation>
    </ref>
    <ref id="CR13">
      <label>13.</label>
      <mixed-citation publication-type="other">B. Stucky and A. Luc, “OntoPilot: new software to simplify and accelerate ontology development and deployment,” Proceedings of TDWG 1, 2017.</mixed-citation>
    </ref>
    <ref id="CR14">
      <label>14.</label>
      <mixed-citation publication-type="other">owlcollab/owltools: OWLTools. <ext-link ext-link-type="uri" xlink:href="https://github.com/owlcollab/owltools">https://github.com/owlcollab/owltools</ext-link> (n.d.). Accessed 21 May 2019.</mixed-citation>
    </ref>
    <ref id="CR15">
      <label>15.</label>
      <mixed-citation publication-type="other">Oort Intro. <ext-link ext-link-type="uri" xlink:href="https://github.com/owlcollab/owltools/wiki/Oort-Intro">https://github.com/owlcollab/owltools/wiki/Oort-Intro</ext-link> (n.d.). Accessed 21 May 2019.</mixed-citation>
    </ref>
    <ref id="CR16">
      <label>16.</label>
      <mixed-citation publication-type="other">ontodev/robot: ROBOT is an OBO Tool. <ext-link ext-link-type="uri" xlink:href="https://github.com/ontodev/robot">https://github.com/ontodev/robot</ext-link> (n.d.). Accessed 9 Oct 2018.</mixed-citation>
    </ref>
    <ref id="CR17">
      <label>17.</label>
      <mixed-citation publication-type="other">J.A. Overton, H. Dietze, S. Essaid, D. Osumi-Sutherland, C.J. Mungall, “ROBOT: a command-line tool for ontology development,” Proceedings of the International Conference on Biomedical Ontology (ICBO) Lisbon: CEUR Workshop Proceedings, pp. 131–132, 2015.</mixed-citation>
    </ref>
    <ref id="CR18">
      <label>18.</label>
      <mixed-citation publication-type="other">J.J. Carroll, I. Dickinson, C. Dollin, D. Reynolds, A. Seaborne, and K.J. Wilkinson, “Jena: implementing the semantic web recommendations,” WWW Alt, pp. 74–83, 2004.</mixed-citation>
    </ref>
    <ref id="CR19">
      <label>19.</label>
      <mixed-citation publication-type="other">Commons CLI. <ext-link ext-link-type="uri" xlink:href="https://commons.apache.org/proper/commons-cli/">https://commons.apache.org/proper/commons-cli/</ext-link> (n.d.). Accessed 23 May 2019.</mixed-citation>
    </ref>
    <ref id="CR20">
      <label>20.</label>
      <mixed-citation publication-type="other">JUnit 4. <ext-link ext-link-type="uri" xlink:href="https://junit.org/junit4/">https://junit.org/junit4/</ext-link> (n.d.). Accessed 21 May 2019.</mixed-citation>
    </ref>
    <ref id="CR21">
      <label>21.</label>
      <mixed-citation publication-type="other">Travis CI. <ext-link ext-link-type="uri" xlink:href="https://travis-ci.org/">https://travis-ci.org/</ext-link> (n.d.). Accessed 21 May 2019.</mixed-citation>
    </ref>
    <ref id="CR22">
      <label>22.</label>
      <mixed-citation publication-type="other">Convert | robot. <ext-link ext-link-type="uri" xlink:href="http://robot.obolibrary.org/convert">http://robot.obolibrary.org/convert</ext-link> (n.d.). Accessed 9 Oct 2018.</mixed-citation>
    </ref>
    <ref id="CR23">
      <label>23.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kazakov</surname>
            <given-names>Yevgeny</given-names>
          </name>
          <name>
            <surname>Krötzsch</surname>
            <given-names>Markus</given-names>
          </name>
          <name>
            <surname>Simančík</surname>
            <given-names>František</given-names>
          </name>
        </person-group>
        <article-title>The Incredible ELK</article-title>
        <source>Journal of Automated Reasoning</source>
        <year>2013</year>
        <volume>53</volume>
        <issue>1</issue>
        <fpage>1</fpage>
        <lpage>61</lpage>
        <pub-id pub-id-type="doi">10.1007/s10817-013-9296-3</pub-id>
      </element-citation>
    </ref>
    <ref id="CR24">
      <label>24.</label>
      <mixed-citation publication-type="other">R. Shearer, B. Motik, and I. Horrocks, “HermiT: a highly-efficient OWL reasoner,” OWLED, 2008.</mixed-citation>
    </ref>
    <ref id="CR25">
      <label>25.</label>
      <mixed-citation publication-type="other">owlcollab/expression-materializing-reasoner: Extension to OWLAPI Reasoner for working with class expressions. <ext-link ext-link-type="uri" xlink:href="https://github.com/owlcollab/expression-materializing-reasoner">https://github.com/owlcollab/expression-materializing-reasoner</ext-link> (n.d.). Accessed 9 Oct 2018.</mixed-citation>
    </ref>
    <ref id="CR26">
      <label>26.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hastings</surname>
            <given-names>Janna</given-names>
          </name>
          <name>
            <surname>de Matos</surname>
            <given-names>Paula</given-names>
          </name>
          <name>
            <surname>Dekker</surname>
            <given-names>Adriano</given-names>
          </name>
          <name>
            <surname>Ennis</surname>
            <given-names>Marcus</given-names>
          </name>
          <name>
            <surname>Harsha</surname>
            <given-names>Bhavana</given-names>
          </name>
          <name>
            <surname>Kale</surname>
            <given-names>Namrata</given-names>
          </name>
          <name>
            <surname>Muthukrishnan</surname>
            <given-names>Venkatesh</given-names>
          </name>
          <name>
            <surname>Owen</surname>
            <given-names>Gareth</given-names>
          </name>
          <name>
            <surname>Turner</surname>
            <given-names>Steve</given-names>
          </name>
          <name>
            <surname>Williams</surname>
            <given-names>Mark</given-names>
          </name>
          <name>
            <surname>Steinbeck</surname>
            <given-names>Christoph</given-names>
          </name>
        </person-group>
        <article-title>The ChEBI reference database and ontology for biologically relevant chemistry: enhancements for 2013</article-title>
        <source>Nucleic Acids Research</source>
        <year>2012</year>
        <volume>41</volume>
        <issue>D1</issue>
        <fpage>D456</fpage>
        <lpage>D463</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gks1146</pub-id>
        <pub-id pub-id-type="pmid">23180789</pub-id>
      </element-citation>
    </ref>
    <ref id="CR27">
      <label>27.</label>
      <mixed-citation publication-type="other">D.P. Hill, et al., “Dovetailing biology and chemistry: integrating the gene ontology with the ChEBI chemical ontology,” BMC Genomics, vol. 14, July 2013.</mixed-citation>
    </ref>
    <ref id="CR28">
      <label>28.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cuenca Grau</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Horrocks</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Kazakov</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Sattler</surname>
            <given-names>U</given-names>
          </name>
        </person-group>
        <article-title>Modular reuse of ontologies: theory and practice</article-title>
        <source>J Artif Intell Res</source>
        <year>2008</year>
        <volume>31</volume>
        <fpage>273</fpage>
        <lpage>318</lpage>
        <pub-id pub-id-type="doi">10.1613/jair.2375</pub-id>
      </element-citation>
    </ref>
    <ref id="CR29">
      <label>29.</label>
      <mixed-citation publication-type="other">SPARQL 1.1 query language. <ext-link ext-link-type="uri" xlink:href="https://www.w3.org/TR/sparql11-query/">https://www.w3.org/TR/sparql11-query/</ext-link> (March 2013). Accessed 23 May 2019.</mixed-citation>
    </ref>
    <ref id="CR30">
      <label>30.</label>
      <mixed-citation publication-type="other">Mungall CJ, Ruttenberg A, Osumi-Sutherland D. Taking shortcuts with OWL using safe macros. Nat Publ Group. 2010.</mixed-citation>
    </ref>
    <ref id="CR31">
      <label>31.</label>
      <mixed-citation publication-type="other">D. Osumi-Sutherland, M. Courtot, J.P. Balhoff, and C. Mungall, “Dead simple OWL design patterns,” Journal of Biomedical Semantics, vol. 8, June 2017.</mixed-citation>
    </ref>
    <ref id="CR32">
      <label>32.</label>
      <mixed-citation publication-type="other">Template | robot. <ext-link ext-link-type="uri" xlink:href="http://robot.obolibrary.org/template">http://robot.obolibrary.org/template</ext-link> (n.d.). Accessed 9 Oct 2018.</mixed-citation>
    </ref>
    <ref id="CR33">
      <label>33.</label>
      <mixed-citation publication-type="other">Make. <ext-link ext-link-type="uri" xlink:href="https://www.gnu.org/software/make/">https://www.gnu.org/software/make/</ext-link> (n.d.). Accessed 21 May 2019.</mixed-citation>
    </ref>
    <ref id="CR34">
      <label>34.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Côté</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Reisinger</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Martens</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Barsnes</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Vizcaino</surname>
            <given-names>JA</given-names>
          </name>
          <name>
            <surname>Hermjakob</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>The ontology lookup service: bigger and better</article-title>
        <source>Nucleic Acids Res</source>
        <year>2010</year>
        <volume>38</volume>
        <fpage>155</fpage>
        <lpage>160</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkq331</pub-id>
      </element-citation>
    </ref>
    <ref id="CR35">
      <label>35.</label>
      <mixed-citation publication-type="other">INCATools/ontology-development-kit: Bootstrap an OBO Library ontology. <ext-link ext-link-type="uri" xlink:href="https://github.com/INCATools/ontology-development-kit/">https://github.com/INCATools/ontology-development-kit/</ext-link> (n.d.). Accessed 9 Oct 2018.</mixed-citation>
    </ref>
    <ref id="CR36">
      <label>36.</label>
      <mixed-citation publication-type="other">obolibrary – Docker Hub. <ext-link ext-link-type="uri" xlink:href="https://hub.docker.com/r/obolibrary/">https://hub.docker.com/r/obolibrary/</ext-link> (n.d.). Accessed 9 Oct 2018.</mixed-citation>
    </ref>
    <ref id="CR37">
      <label>37.</label>
      <mixed-citation publication-type="other">Jenkins. <ext-link ext-link-type="uri" xlink:href="https://jenkins.io/">https://jenkins.io/</ext-link> (n.d.). Accessed 21 May 2019.</mixed-citation>
    </ref>
    <ref id="CR38">
      <label>38.</label>
      <mixed-citation publication-type="other">Bandrowski A, et al. The ontology for biomedical investigations. PLoS One. April 2016;11.</mixed-citation>
    </ref>
    <ref id="CR39">
      <label>39.</label>
      <mixed-citation publication-type="other">OBI Makefile as of 2019-02-22. <ext-link ext-link-type="uri" xlink:href="https://github.com/obi-ontology/obi/blob/5fc065729fc7eb013dafd14690559621b5606057/Makefile">https://github.com/obi-ontology/obi/blob/5fc065729fc7eb013dafd14690559621b5606057/Makefile</ext-link></mixed-citation>
    </ref>
    <ref id="CR40">
      <label>40.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bello</surname>
            <given-names>Susan M.</given-names>
          </name>
          <name>
            <surname>Shimoyama</surname>
            <given-names>Mary</given-names>
          </name>
          <name>
            <surname>Mitraka</surname>
            <given-names>Elvira</given-names>
          </name>
          <name>
            <surname>Laulederkind</surname>
            <given-names>Stanley J. F.</given-names>
          </name>
          <name>
            <surname>Smith</surname>
            <given-names>Cynthia L.</given-names>
          </name>
          <name>
            <surname>Eppig</surname>
            <given-names>Janan T.</given-names>
          </name>
          <name>
            <surname>Schriml</surname>
            <given-names>Lynn M.</given-names>
          </name>
        </person-group>
        <article-title>Disease Ontology: improving and unifying disease annotations across species</article-title>
        <source>Disease Models &amp; Mechanisms</source>
        <year>2018</year>
        <volume>11</volume>
        <issue>3</issue>
        <fpage>dmm032839</fpage>
        <pub-id pub-id-type="doi">10.1242/dmm.032839</pub-id>
        <pub-id pub-id-type="pmid">29590633</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
