<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3933873</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btt593</article-id>
    <article-id pub-id-type="publisher-id">btt593</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group>
          <subject>Genome Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>PEAR: a fast and accurate Illumina Paired-End reAd mergeR</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Zhang</surname>
          <given-names>Jiajie</given-names>
        </name>
        <xref ref-type="aff" rid="btt593-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="btt593-AFF1">
          <sup>2</sup>
        </xref>
        <xref ref-type="aff" rid="btt593-AFF1">
          <sup>3</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Kobert</surname>
          <given-names>Kassian</given-names>
        </name>
        <xref ref-type="aff" rid="btt593-AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Flouri</surname>
          <given-names>Tomáš</given-names>
        </name>
        <xref ref-type="aff" rid="btt593-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="btt593-COR1">*</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Stamatakis</surname>
          <given-names>Alexandros</given-names>
        </name>
        <xref ref-type="aff" rid="btt593-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="btt593-AFF1">
          <sup>4</sup>
        </xref>
      </contrib>
      <aff id="btt593-AFF1"><sup>1</sup>The Exelixis Lab, Scientific Computing Group, Heidelberg Institute for Theoretical Studies, Schloss-Wolfsbrunnenweg 35, D-69118 Heidelberg, <sup>2</sup>Graduate School for Computing in Medicine and Life Sciences, <sup>3</sup>Institut für Neuro- und Bioinformatik, University of Lübeck, 23538 Lübeck and <sup>4</sup>Karlsruhe Institute of Technology, Institute for Theoretical Informatics, Postfach 6980, 76128 Karlsruhe, Germany</aff>
    </contrib-group>
    <author-notes>
      <corresp id="btt593-COR1">*To whom correspondence should be addressed.</corresp>
      <fn>
        <p>Associate Editor: Michael Brudno</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>1</day>
      <month>3</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>18</day>
      <month>10</month>
      <year>2013</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>18</day>
      <month>10</month>
      <year>2013</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>30</volume>
    <issue>5</issue>
    <fpage>614</fpage>
    <lpage>620</lpage>
    <history>
      <date date-type="received">
        <day>18</day>
        <month>6</month>
        <year>2013</year>
      </date>
      <date date-type="rev-recd">
        <day>27</day>
        <month>9</month>
        <year>2013</year>
      </date>
      <date date-type="accepted">
        <day>13</day>
        <month>10</month>
        <year>2013</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author 2013. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2013</copyright-year>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/3.0/">
        <license-p><!--CREATIVE COMMONS-->This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/3.0/">http://creativecommons.org/licenses/by/3.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> The Illumina paired-end sequencing technology can generate reads from both ends of target DNA fragments, which can subsequently be merged to increase the overall read length. There already exist tools for merging these paired-end reads when the target fragments are equally long. However, when fragment lengths vary and, in particular, when either the fragment size is shorter than a single-end read, or longer than twice the size of a single-end read, most state-of-the-art mergers fail to generate reliable results. Therefore, a robust tool is needed to merge paired-end reads that exhibit varying overlap lengths because of varying target fragment lengths.</p>
      <p><bold>Results:</bold> We present the PEAR software for merging raw Illumina paired-end reads from target fragments of varying length. The program evaluates all possible paired-end read overlaps and does not require the target fragment size as input. It also implements a statistical test for minimizing false-positive results. Tests on simulated <italic>and</italic> empirical data show that PEAR consistently generates highly accurate merged paired-end reads. A highly optimized implementation allows for merging millions of paired-end reads within a few minutes on a standard desktop computer. On multi-core architectures, the parallel version of PEAR shows linear speedups compared with the sequential version of PEAR.</p>
      <p><bold>Availability and implementation:</bold> PEAR is implemented in C and uses POSIX threads. It is freely available at <ext-link ext-link-type="uri" xlink:href="http://www.exelixis-lab.org/web/software/pear">http://www.exelixis-lab.org/web/software/pear</ext-link>.</p>
      <p>
        <bold>Contact:</bold>
        <email>Tomas.Flouri@h-its.org</email>
      </p>
    </abstract>
    <counts>
      <page-count count="7"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec id="SEC1">
    <title>1 INTRODUCTION</title>
    <p>The Illumina sequencing platform can produce millions of short reads in a single run. The deep sequencing capability and low cost of the sequencing-by-synthesis technology is useful for a plethora of applications ranging from whole-genome sequencing (<xref rid="btt593-B10" ref-type="bibr">Liu <italic>et al.</italic>, 2012</xref>; <xref rid="btt593-B17" ref-type="bibr">Wang <italic>et al.</italic>, 2010</xref>) to profiling microbial communities by sequencing the hypervariable regions of the 16S ribosomal RNA (rRNA) gene (<xref rid="btt593-B2" ref-type="bibr">Bartram <italic>et al.</italic>, 2011</xref>; <xref rid="btt593-B3" ref-type="bibr">Caporaso <italic>et al.</italic>, 2011</xref>; <xref rid="btt593-B6" ref-type="bibr">Degnan and Ochman, 2012</xref>; <xref rid="btt593-B15" ref-type="bibr">Rodrigue <italic>et al.</italic>, 2010</xref>; <xref rid="btt593-B18" ref-type="bibr">Zhou <italic>et al.</italic>, 2011</xref>). However, single-end reads produced by the Illumina platform typically have a length that ranges from 75 to 300-bp. Furthermore, there is an exponential increase in error rates (ERs) along the reads (<xref rid="btt593-B5" ref-type="bibr">Cox <italic>et al.</italic>, 2010</xref>). The Illumina platform can also generate paired-end reads by sequencing the forward and reverse strands of each target DNA fragment. If the target DNA fragment size is smaller than twice the length of the single-end reads, that is, if there exists an overlap, the corresponding paired-end reads can be merged into a fragment. By merging paired-end reads, the overlapping region between them can also be deployed for correcting sequencing errors and potentially yield sequences of higher quality. Merging paired-end reads is the first processing step in a plethora of sequence analysis pipelines. Hence, its accuracy is crucial for all downstream analyses.</p>
    <p>There exist several proof-of-concept mergers such as iTag (<xref rid="btt593-B6" ref-type="bibr">Degnan and Ochman, 2012</xref>), BIPES (<xref rid="btt593-B18" ref-type="bibr">Zhou <italic>et al.</italic>, 2011</xref>) and Shera (<xref rid="btt593-B15" ref-type="bibr">Rodrigue <italic>et al.</italic>, 2010</xref>). Some production-level mergers such as FLASH (<xref rid="btt593-B12" ref-type="bibr">Magoč and Salzberg, 2011</xref>), PANDAseq (<xref rid="btt593-B13" ref-type="bibr">Masella <italic>et al.</italic>, 2012</xref>) and COPE (<xref rid="btt593-B10" ref-type="bibr">Liu <italic>et al.</italic>, 2012</xref>) have also been recently introduced.</p>
    <p>Shera merges the reads by maximizing the number of matches between the paired-end reads. Both, Shera and FLASH (see later in the text) ignore the quality scores of the base calls. Shera merges all reads and leaves it to the user to decide which merged reads are correct. Because it is a proof-of-concept implementation, it is up to 100 times slower than competing mergers.</p>
    <p>FLASH constructs merged reads that maximize the overlap length-to-matches ratio. FLASH requires the mean DNA fragment size and standard deviation of the fragment size as input parameters. Therefore, it can only merge paired-end reads into fragments of ‘almost’ identical size. Furthermore, our tests show that FLASH performs poorly when the overlaps between reads are short (<xref ref-type="sec" rid="SEC3">Section 3</xref>).</p>
    <p>COPE deploys an analogous approach as FLASH for finding the best overlap, but also takes into account the quality scores of mismatches. COPE is designed to handle deep genome sequencing datasets. Thus, it considers that <italic>k</italic>-mers that occur infrequently are likely to be sequencing errors. COPE exhibits high memory requirements and also relatively long execution times.</p>
    <p>PANDAseq merges fragments by maximizing the probability of true sequence matches, given the observed sequences. It combines quality scores with sequence matches and thereby improves merging quality. In contrast to FLASH, PANDAseq works well with short overlap regions and does not require prior knowledge of the target DNA fragment size. However, it assumes that all paired-end reads can be merged. Thus, if the sample contains DNA fragments that are at least twice as long as the single-end reads, PANDAseq exhibits a high false-positive rate (FPR).</p>
    <p>Finally, most current paired-end mergers assume that the DNA fragments are longer than the individual single-end reads. When this does not hold, for example when sequencing the V6 region of 16S rRNA genes of bacterial samples [fragment sizes range between 110 and 130-bp (<xref rid="btt593-B7" ref-type="bibr">Gloor <italic>et al.</italic>, 2010</xref>)] with read lengths of 150-bp (see case C in <xref ref-type="fig" rid="btt593-F1">Fig. 1</xref>), current mergers will generate erroneous results.
<fig id="btt593-F1" position="float"><label>Fig. 1.</label><caption><p>Three possible scenarios for paired-end read lengths and target DNA fragment lengths. (<bold>A</bold>) Short overlap between the paired-end reads; (<bold>B</bold>) no overlap between the paired-end reads; (<bold>C</bold>) single-end read length is larger than the target DNA fragment length</p></caption><graphic xlink:href="btt593f1p"/></fig></p>
    <p>Here we present PEAR, a fast and accurate paired-end read merger. PEAR merges reads by maximizing the <italic>assembly score</italic> (AS) of the read overlap via a scoring matrix that penalizes mismatches with a negative value β and rewards matches with a positive value α. Our approach takes quality scores <italic>and</italic> sequence matches into account. It does not require preprocessing of the raw data or specifying the fragment size. Furthermore, PEAR neither requires prior information on read length nor target fragment size. It can reliably identify reads that can either be merged or need to be discarded. The program is accurate on datasets with (i) short overlaps and (ii) DNA target fragment sizes that are smaller than single-end read lengths.</p>
    <p>To identify false-positive merged reads, we propose a statistical test that is based on the observed expected alignment scores (OESs). On simulated paired-end reads with a mean overlap of 20-bp (<xref ref-type="sec" rid="SEC3.1">Section 3.1</xref>), PEAR correctly merges 90.44% of the fragments with a FPR of 2.78% when our statistical test is disabled. It correctly merges 70.06% of the fragments with a FPR of only 0.48% when the significance level of the test is set to 1%. The best competing merger (PANDAseq) correctly merges 83.51% of the fragments, but with a FPR of 6.65%.</p>
    <p>We implemented PEAR in C. It includes an optimized memory management scheme that allows the user to specify the amount of random access memory (RAM) available for executing the program. Therefore, it can be deployed on off-the-shelf desktop and laptop computers as well as on high-end multi-core servers. In <xref ref-type="sec" rid="SEC2.4">Section 2.4</xref> we outline why PEAR becomes faster when using less memory. Finally, the parallel version of PEAR scales linearly with the number of cores.</p>
  </sec>
  <sec id="SEC2">
    <title>2 IMPLEMENTATION</title>
    <p>In paired-end sequencing mode, the Illumina <italic>Consensus Assessment of Sequence and Variation</italic> (CASAVA) software generates two FASTQ files (<xref rid="btt593-B4" ref-type="bibr">Cock <italic>et al.</italic>, 2010</xref>), one for each reading direction of the fragment. The files contain exactly the same number of reads. Corresponding paired-end reads can be identified by their coordinates in the flow cell. The Illumina flow cell is a planar optically transparent surface similar to a microscope slide. It contains a lawn of oligonucleotide anchors bound to its surface.</p>
    <p>PEAR scores all possible overlaps for each pair of corresponding paired-end reads to determine the overlap with the highest AS. Subsequently, PEAR conducts a statistical test to assess the statistical significance of the merged reads. If the merged reads do not pass this test or if the overlap length is smaller than a user-defined threshold (based on the expected approximate sequence length in the experiment) the pair of reads will not be merged. Otherwise, PEAR returns the merged fragment and will also correct errors using the Illumina quality scores.</p>
    <sec id="SEC2.1">
      <title>2.1 Overlap algorithm</title>
      <p>For each base, CASAVA (v1.8) yields an ASCII-encoded quality score that represents an integer value <italic>Q</italic>, which can be converted into the probability <italic>e</italic> of a sequencing error at the base via <inline-formula><inline-graphic xlink:href="btt593i1.jpg"/></inline-formula> (<inline-formula><inline-graphic xlink:href="btt593i2.jpg"/></inline-formula> in earlier CASAVA versions). The base frequency <italic>b</italic> of a nucleotide is the number of occurrences of that nucleotide in the FASTQ files divided by the total number of bases. The probability <italic>q</italic> of a random base match is <inline-formula><inline-graphic xlink:href="btt593i3.jpg"/></inline-formula>. Given an overlapping region <inline-formula><inline-graphic xlink:href="btt593i4.jpg"/></inline-formula>, where <italic>X</italic> and <italic>Y</italic> are the overlapping segments of the two reads, we denote the observed (respectively true) base at position <italic>i</italic> of the overlap by <inline-formula><inline-graphic xlink:href="btt593i5.jpg"/></inline-formula> (respectively <inline-formula><inline-graphic xlink:href="btt593i6.jpg"/></inline-formula>). We denote the length of the overlap region by <inline-formula><inline-graphic xlink:href="btt593i7.jpg"/></inline-formula>. The probability that base <italic>X<sub>i</sub></italic> (resp. <italic>Y<sub>i</sub></italic>) is erroneous is <inline-formula><inline-graphic xlink:href="btt593i8.jpg"/></inline-formula> (resp. <inline-formula><inline-graphic xlink:href="btt593i9.jpg"/></inline-formula>). Assuming that errors are independent events, we can calculate the probability of a true base match, given the observed base match as
<disp-formula><graphic xlink:href="btt593um1.jpg" position="float"/></disp-formula>
The probability of a true base match, given the observed base mismatch is
<disp-formula><graphic xlink:href="btt593um2.jpg" position="float"/></disp-formula>
and the probability of a true base mismatch, given the observed base mismatch (or match) is
<disp-formula><graphic xlink:href="btt593um3.jpg" position="float"/></disp-formula>
If any of the bases are undetermined (denoted by <italic>N</italic>),
<disp-formula><graphic xlink:href="btt593um4.jpg" position="float"/></disp-formula>
</p>
      <p>PEAR calculates the AS for each possible overlap [assuming no gaps, as they are infrequent on Illumina platforms (<xref rid="btt593-B14" ref-type="bibr">Nakamura <italic>et al.</italic>, 2011</xref>)] with a scoring matrix that rewards matches by a positive value α and penalizes mismatches with a negative value β. Scoring matrices for evaluating sequence alignments are being routinely used, for instance, in Basic Local Alignment Search Tool (<xref rid="btt593-B1" ref-type="bibr">Altschul and Gish, 1996</xref>) and Bowtie2 (<xref rid="btt593-B9" ref-type="bibr">Langmead and Salzberg, 2012</xref>). Empirical tests using simulated data showed that setting <inline-formula><inline-graphic xlink:href="btt593i10.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="btt593i11.jpg"/></inline-formula> yield the best results (data not shown). Given the overlap <inline-formula><inline-graphic xlink:href="btt593i12.jpg"/></inline-formula>, we define AS as
<disp-formula><graphic xlink:href="btt593um5.jpg" position="float"/></disp-formula>
where
<disp-formula><graphic xlink:href="btt593um6.jpg" position="float"/></disp-formula>
For the merged reads, PEAR computes the overlap that maximizes the AS. We denote the overlap that maximizes the AS by <inline-formula><inline-graphic xlink:href="btt593i13.jpg"/></inline-formula>.</p>
    </sec>
    <sec id="SEC2.2">
      <title>2.2 Statistical test</title>
      <p>To test the significance of the merged reads and to identify reads that shall not be merged, we calculate a <italic>P</italic>-value for the null hypothesis that the two corresponding reads are independent from each other. By independent we mean that any overlap between the two reads is purely by chance. For an overlap <inline-formula><inline-graphic xlink:href="btt593i14.jpg"/></inline-formula> between two reads <italic>x</italic> and <italic>y</italic>, we define <inline-formula><inline-graphic xlink:href="btt593i15.jpg"/></inline-formula> to be the <italic>observed expected alignment score</italic> (<inline-formula><inline-graphic xlink:href="btt593i16.jpg"/></inline-formula>)
<disp-formula><graphic xlink:href="btt593um7.jpg" position="float"/></disp-formula>
and
<disp-formula><graphic xlink:href="btt593um8.jpg" position="float"/></disp-formula>
where <inline-formula><inline-graphic xlink:href="btt593i17.jpg"/></inline-formula> is the set of all possible overlaps between sequences <italic>x</italic> and <italic>y</italic> with a size of at least ω.</p>
      <p>Let <inline-formula><inline-graphic xlink:href="btt593i18.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="btt593i19.jpg"/></inline-formula> be two independent random sequences and let us further assume that there are no sequencing errors. Then, the <italic>P</italic>-value, that is, the probability of a random sequence producing an <inline-formula><inline-graphic xlink:href="btt593i20.jpg"/></inline-formula> that is at least as high as the <inline-formula><inline-graphic xlink:href="btt593i21.jpg"/></inline-formula> obtained from the merged reads. The <italic>P</italic>-value is defined as the probability of <inline-formula><inline-graphic xlink:href="btt593i22.jpg"/></inline-formula> being greater or equal than the observed <inline-formula><inline-graphic xlink:href="btt593i23.jpg"/></inline-formula>. We obtain </p>
      <p><inline-formula><inline-graphic xlink:href="btt593i24.jpg"/></inline-formula><inline-formula><inline-graphic xlink:href="btt593i24a.jpg"/></inline-formula><disp-formula><graphic xlink:href="btt593um9.jpg" position="float"/></disp-formula>
where
<disp-formula><graphic xlink:href="btt593um10.jpg" position="float"/></disp-formula>
By default, PEAR uses an <inline-formula><inline-graphic xlink:href="btt593i25.jpg"/></inline-formula> with a <italic>P</italic>
<inline-formula><inline-graphic xlink:href="btt593i26.jpg"/></inline-formula> as cutoff. If the <inline-formula><inline-graphic xlink:href="btt593i27.jpg"/></inline-formula> of the best merged read is smaller than this value, the reads will not be merged. Choosing a smaller <italic>P</italic>-value will reduce the FPR of the merged sequences, but a lower number of reads will be merged.</p>
      <p>If the underlying overlap size is unknown, ω can be set to 1.0. If, however, the overlap is known to be short (<inline-formula><inline-graphic xlink:href="btt593i28.jpg"/></inline-formula>35-bp in our simulations), our statistical test will reject up to 4% (based on our simulations) correctly merged sequences because of low quality scores. To recover more merged reads, we provide the possibility to set ω to the computed overlap size <italic>after</italic> the merging step, instead of using a predefined fixed value. However, when using this work-around, the <italic>P</italic>-value of the statistical test is not valid anymore, as ω depends on the output of our algorithm. This implies that the random sequences are more restricted when choosing overlaps than the original input sequences. We will refer to the aforementioned, valid <italic>P</italic>-value as the <italic>maximal accepted probability</italic> (MAP). Our tests show that PEAR can produce 4% more merged sequences using MAP at the cost of a slight (∼0.1%) increase in FPRs.</p>
    </sec>
    <sec id="SEC2.3">
      <title>2.3 Output</title>
      <p>PEAR generates four FASTQ output files. One contains the successfully merged reads, two files contain the forward and reverse unmerged reads and one the discarded reads. Discarded reads are reads that fail to pass one of the following quality filters, which are applied after the merging process. These filters require the user to set some program parameters, which are outlined below.</p>
      <p>
        <bold>Minimal quality score for trimming</bold>
      </p>
      <p>It is common to trim the reads and use their high quality part due to the low quality of base calls toward the end of Illumina reads (<xref rid="btt593-B3" ref-type="bibr">Caporaso <italic>et al.</italic>, 2011</xref>). Consequently, PEAR includes the option to trim unmerged reads that contain at least two consecutive bases with quality scores lower than a user-specified <italic>minimal quality score</italic> value.</p>
      <p>
        <bold>Minimal length of output sequences</bold>
      </p>
      <p>PEAR discards merged sequences or trimmed unmerged reads that are shorter than this threshold.</p>
      <p>
        <bold>Maximal length of the output sequences</bold>
      </p>
      <p>PEAR discards sequences longer than the specified maximal length.</p>
      <p>
        <bold>Maximal proportion of uncalled bases</bold>
      </p>
      <p>This parameter allows for discarding reads that contain more than the specified proportion of uncalled bases N. When the value is set to 0, it will discard all reads containing one or more uncalled bases N.</p>
      <p>Now, assume two reads <italic>x</italic> and <italic>y can</italic> be merged and have an overlapping region <italic>C</italic>. PEAR will correct errors in the overlapping region and compute updated quality scores for the overlap. For every pair of corresponding observed bases <italic>X</italic> and <italic>Y</italic> in <italic>C</italic> and their quality scores <italic>e<sub>X</sub></italic> and <italic>e<sub>Y</sub></italic><sub>,</sub>, respectively, we distinguish four cases—<italic>X</italic> and <italic>Y</italic> are identical, different, one of them is uncalled or both of them are uncalled. When the two bases are identical, PEAR simply inserts this base into the corresponding position in the merged sequence and assigns the product of the quality scores: <inline-formula><inline-graphic xlink:href="btt593i29.jpg"/></inline-formula> because errors are independent from each other (see <xref ref-type="sec" rid="SEC2.1">Section 2.1</xref>). When the base pairs are different, PEAR inserts the base with the highest quality score and the corresponding quality score. If (only) one of the two bases is uncalled (N), PEAR uses the called base and its quality score. Finally, if both bases are uncalled, we arbitrarily use the lower of the two quality scores, as a quality score is required to obtain a valid FASTQ output file.</p>
    </sec>
    <sec id="SEC2.4">
      <title>2.4 Parallelization and memory management</title>
      <p>PEAR target platforms are off-the-shelf laptop and desktop computers. We implemented an appropriate memory allocator and manager that allows PEAR to use only a predefined amount of memory that the user can specify via a command-line switch. PEAR can use several gigabytes, but also just a few kilobytes of RAM.</p>
      <p>Current off-the-shelf laptops and servers consist of multi-core processors with a minimum number of two cores per processor, thus increasing the total processing power of the system. However, RAM clock rates are still slower than CPU clock rates (also known as ‘memory-gap’). Thus, the time required for loading data from RAM into cache memories and registers can lead to performance deterioration.</p>
      <p>To increase efficiency, PEAR takes into account both properties of modern hardware, that is, memory access patterns and the number of cores. Currently, most tools process sets of paired-end reads iteratively. They load a set of reads and merge them until all reads in this set have been merged. Because disk accesses are serial, most tools suffer from waiting times induced by loading reads into RAM and the caches. To alleviate this performance bottleneck, PEAR uses a standard double-buffering technique. The main idea of double-buffering techniques is to split-up the available RAM (specified by the user) into two buffers of equal size, which we denote as <italic>active</italic> and <italic>passive</italic> buffer. At program start-up there is an initial latency until the active buffer has been filled with reads for the first time. Then, a dedicated thread (which we denote as <italic>reader</italic> thread) loads a second set of reads into the passive buffer, whereas the remaining threads process the reads in the active buffer. If the reader thread has already loaded the next set while the remaining threads are still processing the reads in the active buffer, the reader thread will also start merging reads. In the opposite case, the remaining threads will idle until the reader thread has filled the passive buffer. Thus, to obtain ‘good’ parallel performance, the buffer size needs to be adapted to the system at hand (see later in the text).</p>
      <p>Each thread only merges ∼500 reads from the active buffer at a time. This per-thread set size of 500 yielded the best performance in our experiments (data not shown)</p>
      <p>When all reads in the active buffer have been processed, the first thread that finishes merging its assigned reads will become the reader. The reader swaps the active buffer with the passive buffer by simply flipping a memory pointer. Subsequently, it will start filling the new passive buffer with the next reads from the input file. The remaining threads will start processing reads from the new active buffer. Thereby, we can parallelize the process of reading from disk and merging reads. By using this technique, we hide the latency of disk accesses and can use the majority of threads/cores for merging short reads and thus reduce overall run time.</p>
      <p>We observed that the optimal RAM setting on a 48 core Magny-Cours system (see <xref ref-type="sec" rid="SEC3.4">Section 3.4</xref> for details) is 200 MB. This is because each disk access only reads ∼100 MB, as we use two buffers of size 100 MB each. Thus, the disk access latency is overlapped by the remaining threads that work on the reads in the active buffer. On four cores of the same hardware configuration, the optimal empirical setting is 50 MB.</p>
    </sec>
  </sec>
  <sec id="SEC3">
    <title>3 RESULTS AND DISCUSSION</title>
    <p>To evaluate PEAR and compare it with the three state-of-the-art mergers (FLASH v1.2.6, PANDAseq v2.4, COPE v1.1.2), we used simulated datasets with varying overlap and DNA fragment sizes as well as the following two empirical datasets:
<list list-type="order"><list-item><p>deep sequencing data of the <italic>Staphylococcus aureus</italic> genome by <xref rid="btt593-B11" ref-type="bibr">MacCallum <italic>et al.</italic> (2009)</xref>,</p></list-item><list-item><p>reads generated from paired-end sequencing of a known single sequence (template) used by <xref rid="btt593-B13" ref-type="bibr">Masella <italic>et al.</italic> (2012)</xref> to test PANDAseq.</p></list-item></list>
</p>
    <sec id="SEC3.1">
      <title>3.1 Simulated data</title>
      <p>To mimic the sequencing of multiple hypervariable regions of 16S rRNA, we extracted a reference sequence dataset of 1000 full-length bacterial 16S rRNA gene sequences from the RDP classifier training dataset (<xref rid="btt593-B16" ref-type="bibr">Wang <italic>et al.</italic>, 2007</xref>). We then used ART (v1.5.0) (<xref rid="btt593-B8" ref-type="bibr">Huang <italic>et al.</italic>, 2012</xref>) to simulate 100-bp paired-end reads, with mean target DNA fragment sizes of 101, 150, 165, 180, 190 and 250-bp, and a standard deviation of 10-bp. We set the parameters of ART to generate target DNA fragments by randomly sampling the reference sequences until a 10-fold coverage of the reference dataset was reached. To obtain a more realistic test dataset, we used two read quality profiles for simulating either end of the respective pairs. The target DNA fragments produced by ART provide the ground truth for the merged paired-end reads.</p>
      <p>We also generated an additional set of 150-bp long reads with a mean fragment size of 101-bp, by extending all single reads in the above 101-bp fragment size set to a length of 150-bp. We extended the reads by complete random sequences with the lowest possible quality scores. This setup emulates case C (see <xref ref-type="fig" rid="btt593-F1">Fig. 1</xref>) where the DNA fragment size is smaller than the length of a single-end read.</p>
      <p>We executed PEAR, COPE, FLASH and PANDAseq on the above datasets and compared the lengths of the merged reads with the true fragment lengths. We only consider merged sequences whose length is equal to the true fragments size as correct merged sequences. When the fragment size is at least twice as long as the single read length, we consider that a result returning unmerged reads is correct. We executed PEAR with three different settings: (i) statistical test disabled, (ii) <inline-formula><inline-graphic xlink:href="btt593i30.jpg"/></inline-formula> and (iii) MAP = 0.01. In all tests the minimum overlap size is 1; for all other parameters we use the default values. We ran PANDAseq with default parameters as well as with a minimal overlap setting of 10-bp. FLASH requires the mean fragment length and a proper minimal overlap value to work correctly. Therefore, we ran it with the known/true mean fragment lengths. COPE includes four different modes of execution. Mode 0 is similar to the FLASH approach, but with more stringent alignment score parameters. Modes 1 and 2 further use <italic>k</italic>-mer frequencies, and full-mode runs all three modes sequentially and concatenates the results. COPE generated a segmentation fault on our simulated data under COPE modes 1 and 2. Therefore, we only report results obtained under COPE mode 0.</p>
      <p><xref ref-type="table" rid="btt593-T1">Table 1</xref> shows experimental results. With the exception of the first test case (no overlaps), PEAR consistently generates a larger number of correctly merged sequences when the statistical test is disabled. PEAR merges fewer correct fragments when the statistical test is enabled. When setting the <italic>P</italic>-value or MAP to 0.01, PEAR shows lower FPRs than all three competing mergers. When we use MAP to evaluate the merged reads, PEAR produces more merged reads with an FPR that is analogous to the FPR generated by PEAR <italic>with</italic> the statistical test. PEAR is robust with respect to short overlaps because it can still merge ∼40% of the reads when the mean overlap is only 10-bp. The FPR of 0.64% (MAP = 0.01) under this setting is 10 times lower than for FLASH and PANDAseq. When reads do not overlap, PEAR classifies them as unmerged with an FPR of 0.03%. Here, the FPR is defined as the fraction of merged reads that should not have been merged. Overall, PEAR shows low FPRs across all test scenarios (overlap lengths). In addition, it does not require any prior knowledge regarding overlap lengths. Therefore, PEAR can be used for merging sequences with varying fragment sizes. PANDAseq performs equally well as PEAR for the majority of cases where the overlaps exceed 20-bp. However, its FPR increases with decreasing overlap size, regardless of the minimal overlap size setting. Furthermore, PANDAseq incorrectly merges 55.4% of the reads that do not overlap and 25.11% of the reads when the mean overlap is set to 10-bp. We will discuss the reasons for this behavior in <xref ref-type="sec" rid="SEC3.5">Section 3.5</xref>.
<table-wrap id="btt593-T1" position="float"><label>Table 1.</label><caption><p>Simulated dataset of paired-end reads with different overlap sizes</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">Software</th><th rowspan="1" colspan="1">Merged</th><th rowspan="1" colspan="1">Correct (−)</th><th rowspan="1" colspan="1">Correct (%)</th><th rowspan="1" colspan="1">FPR (%)</th></tr></thead><tbody align="left"><tr><td colspan="5" rowspan="1">100-bp paired-end reads with no overlaps (23 096 pairs)</td></tr><tr><td rowspan="1" colspan="1">    COPE (mode0)</td><td rowspan="1" colspan="1">31</td><td rowspan="1" colspan="1">23 065</td><td rowspan="1" colspan="1">99.87</td><td rowspan="1" colspan="1">0.13</td></tr><tr><td rowspan="1" colspan="1">    FLASH</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">23 096</td><td rowspan="1" colspan="1">100</td><td rowspan="1" colspan="1">0</td></tr><tr><td rowspan="1" colspan="1">    PANDAseq (default)</td><td rowspan="1" colspan="1">12 796</td><td rowspan="1" colspan="1">10 300</td><td rowspan="1" colspan="1">44.59</td><td rowspan="1" colspan="1">55.4</td></tr><tr><td rowspan="1" colspan="1">    PANDAseq (−o = 10)</td><td rowspan="1" colspan="1">10 562</td><td rowspan="1" colspan="1">12 534</td><td rowspan="1" colspan="1">54.27</td><td rowspan="1" colspan="1">45.7</td></tr><tr><td rowspan="1" colspan="1">    PEAR (test disabled)</td><td rowspan="1" colspan="1">8 184</td><td rowspan="1" colspan="1">14 912</td><td rowspan="1" colspan="1">64.57</td><td rowspan="1" colspan="1">35.4</td></tr><tr><td rowspan="1" colspan="1">    PEAR (<italic>P</italic> = 0.01)</td><td rowspan="1" colspan="1">8</td><td rowspan="1" colspan="1">23 088</td><td rowspan="1" colspan="1">99.96</td><td rowspan="1" colspan="1">0.03</td></tr><tr><td rowspan="1" colspan="1">    PEAR (MAP = 0.01)</td><td rowspan="1" colspan="1">33</td><td rowspan="1" colspan="1">23 063</td><td rowspan="1" colspan="1">99.86</td><td rowspan="1" colspan="1">0.14</td></tr><tr><td colspan="5" rowspan="1">100-bp paired-end reads with 10-bp mean overlaps (24 969 pairs)</td></tr><tr><td rowspan="1" colspan="1">    COPE (mode0)</td><td rowspan="1" colspan="1">5 755</td><td rowspan="1" colspan="1">5 709</td><td rowspan="1" colspan="1">22.86</td><td rowspan="1" colspan="1">0.80</td></tr><tr><td rowspan="1" colspan="1">    FLASH</td><td rowspan="1" colspan="1">8 968</td><td rowspan="1" colspan="1">8 309</td><td rowspan="1" colspan="1">33.27</td><td rowspan="1" colspan="1">7.34</td></tr><tr><td rowspan="1" colspan="1">    PANDAseq (default)</td><td rowspan="1" colspan="1">19 616</td><td rowspan="1" colspan="1">14 690</td><td rowspan="1" colspan="1">58.83</td><td rowspan="1" colspan="1">25.11</td></tr><tr><td rowspan="1" colspan="1">    PANDAseq (−o = 10)</td><td rowspan="1" colspan="1">17 783</td><td rowspan="1" colspan="1">12 053</td><td rowspan="1" colspan="1">48.27</td><td rowspan="1" colspan="1">32.22</td></tr><tr><td rowspan="1" colspan="1">    PEAR (test disabled)</td><td rowspan="1" colspan="1">19 691</td><td rowspan="1" colspan="1">17 112</td><td rowspan="1" colspan="1">68.53</td><td rowspan="1" colspan="1">13.10</td></tr><tr><td rowspan="1" colspan="1">    PEAR (<italic>P</italic> = 0.01)</td><td rowspan="1" colspan="1">9 365</td><td rowspan="1" colspan="1">9 315</td><td rowspan="1" colspan="1">37.31</td><td rowspan="1" colspan="1">0.53</td></tr><tr><td rowspan="1" colspan="1">    PEAR (MAP = 0.01)</td><td rowspan="1" colspan="1">10 080</td><td rowspan="1" colspan="1">10 015</td><td rowspan="1" colspan="1">40.11</td><td rowspan="1" colspan="1">0.64</td></tr><tr><td colspan="5" rowspan="1">100-bp paired-end reads with 20-bp mean overlaps (25 858 pairs)</td></tr><tr><td rowspan="1" colspan="1">    COPE(mode0)</td><td rowspan="1" colspan="1">9 819</td><td rowspan="1" colspan="1">9 750</td><td rowspan="1" colspan="1">37.71</td><td rowspan="1" colspan="1">0.70</td></tr><tr><td rowspan="1" colspan="1">    FLASH</td><td rowspan="1" colspan="1">10 917</td><td rowspan="1" colspan="1">10 843</td><td rowspan="1" colspan="1">41.93</td><td rowspan="1" colspan="1">0.67</td></tr><tr><td rowspan="1" colspan="1">    PANDAseq (default)</td><td rowspan="1" colspan="1">23 136</td><td rowspan="1" colspan="1">21 596</td><td rowspan="1" colspan="1">83.51</td><td rowspan="1" colspan="1">6.65</td></tr><tr><td rowspan="1" colspan="1">    PANDAseq (−o = 10)</td><td rowspan="1" colspan="1">22 736</td><td rowspan="1" colspan="1">20 722</td><td rowspan="1" colspan="1">80.14</td><td rowspan="1" colspan="1">8.85</td></tr><tr><td rowspan="1" colspan="1">    PEAR (test disabled)</td><td rowspan="1" colspan="1">24 153</td><td rowspan="1" colspan="1">23 386</td><td rowspan="1" colspan="1">90.44</td><td rowspan="1" colspan="1">3.16</td></tr><tr><td rowspan="1" colspan="1">    PEAR (<italic>P</italic> = 0.01)</td><td rowspan="1" colspan="1">18 202</td><td rowspan="1" colspan="1">18 115</td><td rowspan="1" colspan="1">70.06</td><td rowspan="1" colspan="1">0.48</td></tr><tr><td rowspan="1" colspan="1">    PEAR (MAP = 0.01)</td><td rowspan="1" colspan="1">19 265</td><td rowspan="1" colspan="1">19 165</td><td rowspan="1" colspan="1">74.12</td><td rowspan="1" colspan="1">0.52</td></tr><tr><td colspan="5" rowspan="1">100-bp paired-end reads with 35-bp mean overlaps (27 026 pairs)</td></tr><tr><td rowspan="1" colspan="1">    COPE (mode0)</td><td rowspan="1" colspan="1">11 771</td><td rowspan="1" colspan="1">11 693</td><td rowspan="1" colspan="1">43.27</td><td rowspan="1" colspan="1">0.66</td></tr><tr><td rowspan="1" colspan="1">    FLASH</td><td rowspan="1" colspan="1">15 603</td><td rowspan="1" colspan="1">15 507</td><td rowspan="1" colspan="1">57.37</td><td rowspan="1" colspan="1">0.61</td></tr><tr><td rowspan="1" colspan="1">    PANDAseq (default)</td><td rowspan="1" colspan="1">26 068</td><td rowspan="1" colspan="1">25 849</td><td rowspan="1" colspan="1">95.64</td><td rowspan="1" colspan="1">0.84</td></tr><tr><td rowspan="1" colspan="1">    PANDAseq (−o = 10)</td><td rowspan="1" colspan="1">26 267</td><td rowspan="1" colspan="1">26 026</td><td rowspan="1" colspan="1">96.29</td><td rowspan="1" colspan="1">0.92</td></tr><tr><td rowspan="1" colspan="1">    PEAR(test disabled)</td><td rowspan="1" colspan="1">26 866</td><td rowspan="1" colspan="1">26 712</td><td rowspan="1" colspan="1">98.84</td><td rowspan="1" colspan="1">0.57</td></tr><tr><td rowspan="1" colspan="1">    PEAR (<italic>P</italic> = 0.01)</td><td rowspan="1" colspan="1">25 939</td><td rowspan="1" colspan="1">25 833</td><td rowspan="1" colspan="1">95.59</td><td rowspan="1" colspan="1">0.41</td></tr><tr><td rowspan="1" colspan="1">    PEAR (MAP = 0.01)</td><td rowspan="1" colspan="1">26 380</td><td rowspan="1" colspan="1">26 273</td><td rowspan="1" colspan="1">97.21</td><td rowspan="1" colspan="1">0.41</td></tr><tr><td colspan="5" rowspan="1">100-bp paired-end reads with 50-bp mean overlaps (28 339 pairs)</td></tr><tr><td rowspan="1" colspan="1">    COPE (mode0)</td><td rowspan="1" colspan="1">7 915</td><td rowspan="1" colspan="1">7 858</td><td rowspan="1" colspan="1">27.73</td><td rowspan="1" colspan="1">0.72</td></tr><tr><td rowspan="1" colspan="1">    FLASH</td><td rowspan="1" colspan="1">20 025</td><td rowspan="1" colspan="1">19 940</td><td rowspan="1" colspan="1">70.36</td><td rowspan="1" colspan="1">0.42</td></tr><tr><td rowspan="1" colspan="1">    PANDAseq (default)</td><td rowspan="1" colspan="1">27 939</td><td rowspan="1" colspan="1">27 834</td><td rowspan="1" colspan="1">98.21</td><td rowspan="1" colspan="1">0.37</td></tr><tr><td rowspan="1" colspan="1">    PANDAseq (−o = 10)</td><td rowspan="1" colspan="1">28 049</td><td rowspan="1" colspan="1">27 944</td><td rowspan="1" colspan="1">98.61</td><td rowspan="1" colspan="1">0.37</td></tr><tr><td rowspan="1" colspan="1">    PEAR(test disabled)</td><td rowspan="1" colspan="1">28 335</td><td rowspan="1" colspan="1">28 234</td><td rowspan="1" colspan="1">99.63</td><td rowspan="1" colspan="1">0.36</td></tr><tr><td rowspan="1" colspan="1">    PEAR (<italic>P</italic> = 0.01)</td><td rowspan="1" colspan="1">28 288</td><td rowspan="1" colspan="1">28 190</td><td rowspan="1" colspan="1">99.47</td><td rowspan="1" colspan="1">0.35</td></tr><tr><td rowspan="1" colspan="1">    PEAR (MAP = 0.01)</td><td rowspan="1" colspan="1">28 329</td><td rowspan="1" colspan="1">28 229</td><td rowspan="1" colspan="1">99.61</td><td rowspan="1" colspan="1">0.35</td></tr><tr><td colspan="5" rowspan="1">150-bp paired-end reads with 100-bp mean overlaps (33 217 pairs)</td></tr><tr><td rowspan="1" colspan="1">    COPE (mode0)</td><td rowspan="1" colspan="1">43</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">100</td></tr><tr><td rowspan="1" colspan="1">    FLASH</td><td rowspan="1" colspan="1">44</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">100</td></tr><tr><td rowspan="1" colspan="1">    PANDAseq (default)</td><td rowspan="1" colspan="1">11 417</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">100</td></tr><tr><td rowspan="1" colspan="1">    PANDAseq (−o = 10)</td><td rowspan="1" colspan="1">14 146</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">100</td></tr><tr><td rowspan="1" colspan="1">    PEAR (test disabled)</td><td rowspan="1" colspan="1">33 187</td><td rowspan="1" colspan="1">33 071</td><td rowspan="1" colspan="1">99.56</td><td rowspan="1" colspan="1">0.35</td></tr><tr><td rowspan="1" colspan="1">    PEAR (<italic>P</italic> = 0.01)</td><td rowspan="1" colspan="1">33 136</td><td rowspan="1" colspan="1">33 022</td><td rowspan="1" colspan="1">99.41</td><td rowspan="1" colspan="1">0.34</td></tr><tr><td rowspan="1" colspan="1">    PEAR (MAP = 0.01)</td><td rowspan="1" colspan="1">33 185</td><td rowspan="1" colspan="1">33 071</td><td rowspan="1" colspan="1">99.56</td><td rowspan="1" colspan="1">0.34</td></tr></tbody></table></table-wrap></p>
      <p>FLASH failed to merge the majority of reads for small overlap sizes, but exhibits low FPRs for merged sequences. FLASH merges reads by maximizing the fraction <italic>f</italic> (number of matches to overlap size ratio). The default threshold of <italic>f</italic> in FLASH is 0.75 and the default minimal overlap size (ω) is 10. This setting can be shown to have a <italic>P</italic>-value of 0.00156 for merged reads by using the statistical test introduced in <xref ref-type="sec" rid="SEC2.2">Section 2.2</xref> and replacing <inline-formula><inline-graphic xlink:href="btt593i31.jpg"/></inline-formula> with <italic>f</italic>. However, overlaps that exclusively maximize <italic>f</italic> might not yield correctly merged sequences. Let us consider two possible overlap sizes <inline-formula><inline-graphic xlink:href="btt593i32.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="btt593i33.jpg"/></inline-formula> for paired-end reads <italic>x</italic> and <italic>y</italic>, where <inline-formula><inline-graphic xlink:href="btt593i34.jpg"/></inline-formula>. As an example, we assume <inline-formula><inline-graphic xlink:href="btt593i35.jpg"/></inline-formula> with 1 mismatch, <inline-formula><inline-graphic xlink:href="btt593i36.jpg"/></inline-formula> with 6 mismatches and a true overlap size of <inline-formula><inline-graphic xlink:href="btt593i37.jpg"/></inline-formula>. Then <inline-formula><inline-graphic xlink:href="btt593i38.jpg"/></inline-formula> and FLASH will choose the overlap of size <inline-formula><inline-graphic xlink:href="btt593i39.jpg"/></inline-formula> as merged read. Because <inline-formula><inline-graphic xlink:href="btt593i40.jpg"/></inline-formula>, PEAR will return the correct result. FLASH also requires the mean fragment length as input, which restrains its applicability to datasets with uniform fragment length.</p>
      <p>COPE, PANDAseq and FLASH were unable to merge reads under application scenario C (see <xref ref-type="fig" rid="btt593-F1">Fig. 1</xref>) where the DNA fragment size is smaller than a single-end read (<xref ref-type="table" rid="btt593-T1">Table 1</xref>). PANDAseq incorrectly merges over one-third of the reads in this scenario.</p>
    </sec>
    <sec id="SEC3.2">
      <title>3.2 <italic>S</italic><italic>.</italic><italic>aureus</italic> genome data</title>
      <p>This dataset was initially generated by <xref rid="btt593-B11" ref-type="bibr">MacCallum <italic>et al.</italic> (2009)</xref> (available for download at <ext-link ext-link-type="uri" xlink:href="http://gage.cbcb.umd.edu/data">http://gage.cbcb.umd.edu/data</ext-link>) to assess short read-based genome assembly quality. We used the raw dataset that contains 647 052 pairs of 101-bp long reads with a mean DNA fragment size of 180-bp and <inline-formula><inline-graphic xlink:href="btt593i41.jpg"/></inline-formula> coverage of the <italic>S</italic><italic>.</italic><italic>aureus</italic> genome. To determine the true target DNA fragment sizes, we used Bowtie2 (<xref rid="btt593-B9" ref-type="bibr">Langmead and Salzberg, 2012</xref>) to map the merged reads to the reference genome. We use the corresponding <italic>end-to-end mode</italic> in Bowtie2 and do not allow for opening gaps in either sequence (the reads <italic>and</italic> the reference genome). This guarantees that all merged reads that can be mapped to the reference genome are correctly merged. This is because there are two possible scenarios for incorrectly merged reads: (i) they can be longer than the corrected one, in which case the sequences can be aligned by opening gaps in the reference sequence or (ii) they are shorter than the corrected one, and the sequences can be aligned by opening gaps in the merged sequences. Therefore, we consider that a merged paired-end read is correct only if Bowtie2 finds a hit on the reference genome. Note that, the results are conservative because some of the correctly merged reads might be missed by Bowtie2 due to sequencing errors.</p>
      <p>We summarize the results in <xref ref-type="table" rid="btt593-T2">Table 2</xref>. All mergers work well in this setting. PANDAseq correctly merges the highest amount of reads; PEAR ∼2% less (statistical test disabled). Nonetheless, a quarter of the reads merged by PANDAseq were not mapped to the reference genome using Bowtie2. In contrast only 4.9% of the merged reads from PEAR could not be mapped. COPE merges less reads than PEAR and shows a lower FPR when the statistical test in PEAR is disabled. This is likely because COPE is specifically designed for such deep sequencing datasets.
<table-wrap id="btt593-T2" position="float"><label>Table 2.</label><caption><p>A total of 647 052 paired-end reads with mean fragment size 180-bp and read length 101-bp (<italic>S.aureus</italic> genome)</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">Software</th><th rowspan="1" colspan="1">Merged</th><th rowspan="1" colspan="1">Correct (−)</th><th rowspan="1" colspan="1">Correct (%)</th><th rowspan="1" colspan="1">FPR (%)</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">COPE (full mode)</td><td rowspan="1" colspan="1">373 543</td><td rowspan="1" colspan="1">369 683</td><td rowspan="1" colspan="1">57.13</td><td rowspan="1" colspan="1">1.03</td></tr><tr><td rowspan="1" colspan="1">FLASH</td><td rowspan="1" colspan="1">369 276</td><td rowspan="1" colspan="1">361 663</td><td rowspan="1" colspan="1">55.89</td><td rowspan="1" colspan="1">2.06</td></tr><tr><td rowspan="1" colspan="1">PANDAseq (default)</td><td rowspan="1" colspan="1">534 839</td><td rowspan="1" colspan="1">418 747</td><td rowspan="1" colspan="1">64.72</td><td rowspan="1" colspan="1">21.71</td></tr><tr><td rowspan="1" colspan="1">PANDAseq (−o = 10)</td><td rowspan="1" colspan="1">533 618</td><td rowspan="1" colspan="1">407 477</td><td rowspan="1" colspan="1">62.97</td><td rowspan="1" colspan="1">23.64</td></tr><tr><td rowspan="1" colspan="1">PEAR (test disabled)</td><td rowspan="1" colspan="1">411 321</td><td rowspan="1" colspan="1">391 157</td><td rowspan="1" colspan="1">60.45</td><td rowspan="1" colspan="1">4.90</td></tr><tr><td rowspan="1" colspan="1">PEAR (<italic>P</italic> = 0.01)</td><td rowspan="1" colspan="1">202 221</td><td rowspan="1" colspan="1">199 764</td><td rowspan="1" colspan="1">30.87</td><td rowspan="1" colspan="1">1.22</td></tr><tr><td rowspan="1" colspan="1">PEAR (MAP = 0.01)</td><td rowspan="1" colspan="1">257 409</td><td rowspan="1" colspan="1">251 714</td><td rowspan="1" colspan="1">38.90</td><td rowspan="1" colspan="1">2.21</td></tr></tbody></table></table-wrap></p>
    </sec>
    <sec id="SEC3.3">
      <title>3.3 Single known sequence data</title>
      <p>We used a dataset that was deployed by <xref rid="btt593-B13" ref-type="bibr">Masella <italic>et al.</italic> (2012)</xref> to assess PANDAseq. The dataset contains paired-end reads from a single template sequence. The template sequence is the V3 region of the <italic>Methylococcus capsulatus</italic> (ATCC 33009) 16S rRNA gene. It has a length of 198-bp, including the primers. The FASTQ files contain 673 845 pairs of 108-bp long paired-end reads. Each pair overlaps by exactly 18-bp. We calculate the ‘true’ merged reads by computing a global pairwise sequence alignment between the merged reads and the template sequence. Subsequently, we check if the overlapping region contains gaps, we consider a merged read to be correct if there is no gap. We also calculate the ER of the merged reads to evaluate error correction performance. The ER is the average number of errors per merged read (excluding gaps) with respect to the template sequence. We ran PEAR with default parameters. We executed PANDAseq with default parameters and with a minimum overlap setting of 10-bp. We applied FLASH with a template sequence length of 198-bp and a read length of 108-bp.</p>
      <p>For this dataset, PEAR merges the highest number of reads when the statistical test is disabled (<xref ref-type="table" rid="btt593-T3">Table 3</xref>). When setting <inline-formula><inline-graphic xlink:href="btt593i42.jpg"/></inline-formula> and using the test, less reads are merged, but only 0.03% of the merged reads are false positives. Both, PANDAseq and FLASH, produce comparable results but with a slightly higher FPR. We executed COPE in full mode (see <xref ref-type="sec" rid="SEC3.1">Section 3.1</xref>) on this dataset. COPE did not merge any reads, however. The ER of the raw reads is 0.51. Although the overlap size is only 18-bp all mergers decrease the ER. Merged reads produced by FLASH and PANDAseq show ERs that are slightly lower than PEAR (statistical test disabled). However, PEAR yields three times lower ERs when the statistical test is enabled.
<table-wrap id="btt593-T3" position="float"><label>Table 3.</label><caption><p>Single template 198-bp sequence dataset of 673 845 108-bp paired-end reads</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">Software</th><th rowspan="1" colspan="1">Merged</th><th rowspan="1" colspan="1">Correct (−)</th><th rowspan="1" colspan="1">FPR (%)</th><th rowspan="1" colspan="1">ER</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">COPE (full mode)</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1">FLASH</td><td rowspan="1" colspan="1">660 984</td><td rowspan="1" colspan="1">660 030</td><td rowspan="1" colspan="1">0.14</td><td rowspan="1" colspan="1">0.4594</td></tr><tr><td rowspan="1" colspan="1">PANDAseq (default)</td><td rowspan="1" colspan="1">660 593</td><td rowspan="1" colspan="1">657 602</td><td rowspan="1" colspan="1">0.45</td><td rowspan="1" colspan="1">0.4333</td></tr><tr><td rowspan="1" colspan="1">PANDAseq (−o = 10)</td><td rowspan="1" colspan="1">660 522</td><td rowspan="1" colspan="1">657 609</td><td rowspan="1" colspan="1">0.44</td><td rowspan="1" colspan="1">0.4304</td></tr><tr><td rowspan="1" colspan="1">PEAR (test disabled)</td><td rowspan="1" colspan="1">663 025</td><td rowspan="1" colspan="1">661 717</td><td rowspan="1" colspan="1">0.20</td><td rowspan="1" colspan="1">0.4753</td></tr><tr><td rowspan="1" colspan="1">PEAR (<italic>P</italic> = 0.01)</td><td rowspan="1" colspan="1">576 225</td><td rowspan="1" colspan="1">576 035</td><td rowspan="1" colspan="1">0.03</td><td rowspan="1" colspan="1">0.1470</td></tr><tr><td rowspan="1" colspan="1">PEAR (MAP = 0.01)</td><td rowspan="1" colspan="1">578 887</td><td rowspan="1" colspan="1">578 679</td><td rowspan="1" colspan="1">0.04</td><td rowspan="1" colspan="1">0.1486</td></tr></tbody></table></table-wrap></p>
    </sec>
    <sec id="SEC3.4">
      <title>3.4 Run time and memory requirement</title>
      <p>To compare run times between PEAR and competing mergers, we used the dataset from <xref ref-type="sec" rid="SEC3.3">Section 3.3</xref>. We conducted experiments on an AMD Opteron 6174 2.2 GHz 4-processor machine with 12 cores each and a total of 48 cores. We used the default PEAR memory setting of 200 MB. PANDAseq is the fastest tool on a single core. Surprisingly, when running the experiment with four cores, which corresponds to a standard desktop PC, PANDAseq is slower than for the sequential run, whereas PEAR and FLASH are equally fast and twice as fast as PANDAseq. However, the main observation is that neither PANDAseq nor FLASH yields substantial speedups when executed on several cores (see <xref ref-type="fig" rid="btt593-F2">Fig. 2</xref>). In fact, although PEAR yields linear speedups, FLASH and PANDAseq yield no speedup at all. We excluded COPE from most experiments because it does not merge any reads for this dataset and because it has only been partially parallelized; only the <italic>k</italic>-mer computation is parallelized. For the sake of completeness, the overall run time of COPE on this dataset is 395 s using the parallel <italic>k</italic>-mer computation on 48 cores (minimum memory requirement of 16 GB). Hence, COPE is substantially slower than the other programs we tested.
<fig id="btt593-F2" position="float"><label>Fig. 2.</label><caption><p>Parallel speedups of PEAR, FLASH and PANDAseq on the single template sequences dataset. The sequential runtimes for the three mergers are 98, 58 and 39 s, respectively</p></caption><graphic xlink:href="btt593f2p"/></fig></p>
      <p>We also tested PEAR, FLASH and PANDAseq on a substantially larger dataset of 36 504 800 101-bp long paired-end reads from the human chromosome 14 (data available at <ext-link ext-link-type="uri" xlink:href="http://gage.cbcb.umd.edu/data">http://gage.cbcb.umd.edu/data</ext-link>). Using 48 cores, PEAR only requires 62 s to finish, whereas FLASH and PANDAseq need 7 and 21.5 min, respectively.</p>
    </sec>
    <sec id="SEC3.5">
      <title>3.5 Reasons for high FPRs in PANDASeq</title>
      <p>PANDAseq merges reads by choosing the overlap <italic>C</italic>, such that <inline-formula><inline-graphic xlink:href="btt593i43.jpg"/></inline-formula> that maximizes
<disp-formula id="btt593-M1"><label>(1)</label><graphic xlink:href="btt593m1.jpg" position="float"/></disp-formula>
where <italic>F</italic> is the forward read sequence and <italic>R</italic> is the reverse read sequence. When the DNA fragment size exceeds the sum of the lengths of the reads (see <xref ref-type="fig" rid="btt593-F1">Fig. 1</xref>, case B), a merger should not merge the reads. According to <xref ref-type="disp-formula" rid="btt593-M1">Equation 1</xref>, PANDAseq will merge reads with an overlap <italic>C</italic>, when
<disp-formula id="btt593-M2"><label>(2)</label><graphic xlink:href="btt593m2.jpg" position="float"/></disp-formula>
Assuming that the merged sequences are generated randomly with all base frequencies being equally likely with probability 0.25 and that all bases have an equal error probability <italic>e</italic>, we can simplify <xref ref-type="disp-formula" rid="btt593-M2">Equation (2)</xref> to
<disp-formula><graphic xlink:href="btt593um11.jpg" position="float"/></disp-formula>
Solving the above inequality, we obtain <inline-formula><inline-graphic xlink:href="btt593i44.jpg"/></inline-formula>. In other words, when the bases have an average error probability that is &gt;0.039, PANDAseq will favor merging randomly generated sequences. Because the quality of Illumina reads decreases toward the end of the reads, PANDAseq will therefore incorrectly merge reads that do not overlap.</p>
    </sec>
  </sec>
  <sec id="SEC4">
    <title>4 CONCLUSIONS</title>
    <p>We introduce PEAR, a new software tool that produces highly accurate merged Illumina paired-end reads with low FPRs. It can merge paired-end read datasets under settings where most competing mergers fail. Furthermore, PEAR does not require preprocessing or quality control before merging. One main application scenario is the merging of paired-end reads from datasets with varying DNA fragment sizes. We have also introduced a statistical test to evaluate the merged read. Finally, PEAR scales well on most server and desktop computers. We intend to implement an automatic buffer size tuning routine in PEAR to maximize performance without user intervention.</p>
    <p><italic>Funding</italic>: J.Z. and K.K. are funded by a <funding-source>HITS scholarship</funding-source>. T.F. is funded by <funding-source>DFG project</funding-source><award-id>STA-860/4</award-id>. The authors acknowledge the support of <funding-source>Graduate School for Computing in Medicine and Life Sciences, University of Lübeck</funding-source>.</p>
    <p><italic>Conflicts of Interest</italic>: none declared.</p>
  </sec>
</body>
<back>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="btt593-B1">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Gish</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>Local alignment statistics</article-title>
        <source>Methods Enzymol.</source>
        <year>1996</year>
        <volume>266</volume>
        <fpage>460</fpage>
        <lpage>480</lpage>
        <pub-id pub-id-type="pmid">8743700</pub-id>
      </element-citation>
    </ref>
    <ref id="btt593-B2">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bartram</surname>
            <given-names>AK</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Generation of multimillion-sequence 16S rRNA gene libraries from complex microbial communities by assembling paired-end Illumina reads</article-title>
        <source>Appl. Environ. Microbiol.</source>
        <year>2011</year>
        <volume>77</volume>
        <fpage>3846</fpage>
        <lpage>3852</lpage>
        <pub-id pub-id-type="pmid">21460107</pub-id>
      </element-citation>
    </ref>
    <ref id="btt593-B3">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Caporaso</surname>
            <given-names>JG</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Global patterns of 16S rRNA diversity at a depth of millions of sequences per sample</article-title>
        <source>Proc. Natl Acad. Sci. USA</source>
        <year>2011</year>
        <volume>108</volume>
        <fpage>4516</fpage>
        <lpage>4522</lpage>
        <pub-id pub-id-type="pmid">20534432</pub-id>
      </element-citation>
    </ref>
    <ref id="btt593-B4">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cock</surname>
            <given-names>PJA</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The Sanger FASTQ file format for sequences with quality scores, and the Solexa/Illumina FASTQ variants</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2010</year>
        <volume>38</volume>
        <fpage>1767</fpage>
        <lpage>1771</lpage>
        <pub-id pub-id-type="pmid">20015970</pub-id>
      </element-citation>
    </ref>
    <ref id="btt593-B5">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cox</surname>
            <given-names>MP</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>SolexaQA: at-a-glance quality assessment of Illumina second-generation sequencing data</article-title>
        <source>BMC Bioinformatics</source>
        <year>2010</year>
        <volume>11</volume>
        <fpage>485</fpage>
        <pub-id pub-id-type="pmid">20875133</pub-id>
      </element-citation>
    </ref>
    <ref id="btt593-B6">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Degnan</surname>
            <given-names>PH</given-names>
          </name>
          <name>
            <surname>Ochman</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Illumina-based analysis of microbial community diversity</article-title>
        <source>SME J.</source>
        <year>2012</year>
        <volume>6</volume>
        <fpage>183</fpage>
        <lpage>194</lpage>
      </element-citation>
    </ref>
    <ref id="btt593-B7">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gloor</surname>
            <given-names>GB</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Microbiome profiling by Illumina sequencing of combinatorial sequence-tagged PCR products</article-title>
        <source>PLoS One</source>
        <year>2010</year>
        <volume>5</volume>
        <fpage>e15406</fpage>
        <pub-id pub-id-type="pmid">21048977</pub-id>
      </element-citation>
    </ref>
    <ref id="btt593-B8">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Huang</surname>
            <given-names>W</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>ART: a next-generation sequencing read simulator</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <fpage>593</fpage>
        <lpage>594</lpage>
        <pub-id pub-id-type="pmid">22199392</pub-id>
      </element-citation>
    </ref>
    <ref id="btt593-B9">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Langmead</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>Fast gapped-read alignment with Bowtie 2</article-title>
        <source>Nat. Methods</source>
        <year>2012</year>
        <volume>9</volume>
        <fpage>357</fpage>
        <lpage>359</lpage>
        <pub-id pub-id-type="pmid">22388286</pub-id>
      </element-citation>
    </ref>
    <ref id="btt593-B10">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Liu</surname>
            <given-names>B</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>COPE: an accurate k-mer-based pair-end reads connection tool to facilitate genome assembly</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <fpage>2870</fpage>
        <lpage>2874</lpage>
        <pub-id pub-id-type="pmid">23044551</pub-id>
      </element-citation>
    </ref>
    <ref id="btt593-B11">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>MacCallum</surname>
            <given-names>I</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>ALLPATHS 2: small genomes assembled accurately and with high continuity from short paired reads</article-title>
        <source>Genome Biol.</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>R103</fpage>
        <pub-id pub-id-type="pmid">19796385</pub-id>
      </element-citation>
    </ref>
    <ref id="btt593-B12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Magoč</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>FLASH: fast length adjustment of short reads to improve genome assemblies</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <fpage>2957</fpage>
        <lpage>2963</lpage>
        <pub-id pub-id-type="pmid">21903629</pub-id>
      </element-citation>
    </ref>
    <ref id="btt593-B13">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Masella</surname>
            <given-names>AP</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>PANDAseq: paired-end assembler for Illumina sequences</article-title>
        <source>BMC Bioinformatics</source>
        <year>2012</year>
        <volume>13</volume>
        <fpage>31</fpage>
        <pub-id pub-id-type="pmid">22333067</pub-id>
      </element-citation>
    </ref>
    <ref id="btt593-B14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Nakamura</surname>
            <given-names>K</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Sequence-specific error profile of Illumina sequencers</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2011</year>
        <volume>39</volume>
        <fpage>e90</fpage>
        <pub-id pub-id-type="pmid">21576222</pub-id>
      </element-citation>
    </ref>
    <ref id="btt593-B15">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rodrigue</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Unlocking short read sequencing for metagenomics</article-title>
        <source>PLoS One</source>
        <year>2010</year>
        <volume>5</volume>
        <fpage>e11840</fpage>
        <pub-id pub-id-type="pmid">20676378</pub-id>
      </element-citation>
    </ref>
    <ref id="btt593-B16">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>Q</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Naive Bayesian classifier for rapid assignment of rRNA sequences into the new bacterial taxonomy</article-title>
        <source>Appl. Environ. Microbiol.</source>
        <year>2007</year>
        <volume>73</volume>
        <fpage>5261</fpage>
        <lpage>5267</lpage>
        <pub-id pub-id-type="pmid">17586664</pub-id>
      </element-citation>
    </ref>
    <ref id="btt593-B17">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>Z</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title><italic>De novo</italic> assembly and characterization of root transcriptome using Illumina paired-end sequencing and development of cSSR markers in sweet potato (<italic>Ipomoea batatas</italic>)</article-title>
        <source>BMC Genomics</source>
        <year>2010</year>
        <volume>11</volume>
        <fpage>726</fpage>
        <pub-id pub-id-type="pmid">21182800</pub-id>
      </element-citation>
    </ref>
    <ref id="btt593-B18">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhou</surname>
            <given-names>H-W</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>BIPES, a cost-effective high-throughput method for assessing microbial diversity</article-title>
        <source>ISME J.</source>
        <year>2011</year>
        <volume>5</volume>
        <fpage>741</fpage>
        <lpage>749</lpage>
        <pub-id pub-id-type="pmid">20962877</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
