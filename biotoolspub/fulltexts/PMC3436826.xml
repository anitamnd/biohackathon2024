<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3436826</article-id>
    <article-id pub-id-type="pmid">22962446</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/bts399</article-id>
    <article-id pub-id-type="publisher-id">bts399</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group>
          <subject>Sequencing and Sequence Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Telescoper: <italic>de novo</italic> assembly of highly repetitive regions</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Bresler</surname>
          <given-names>Ma'ayan</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Sheehan</surname>
          <given-names>Sara</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Chan</surname>
          <given-names>Andrew H.</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Song</surname>
          <given-names>Yun S.</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="AFF2">
          <sup>2</sup>
        </xref>
        <xref ref-type="corresp" rid="COR1">
          <sup>*</sup>
        </xref>
      </contrib>
    </contrib-group>
    <aff id="AFF1"><sup>1</sup>Department of EECS</aff>
    <aff id="AFF2"><sup>2</sup>Department of Statistics, University of California, Berkeley, CA 94720, USA</aff>
    <author-notes>
      <corresp id="COR1">*To whom correspondence should be addressed.</corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>9</month>
      <year>2012</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>3</day>
      <month>9</month>
      <year>2012</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>3</day>
      <month>9</month>
      <year>2012</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>28</volume>
    <issue>18</issue>
    <issue-title>ECCB 2012 PROCEEDINGS PAPERS COMMITTEE SEPTEMBER 9 TO SEPTEMBER 12, 2012, CONFERENCE CENTER BASEL, SWITZERLAND</issue-title>
    <fpage>i311</fpage>
    <lpage>i317</lpage>
    <permissions>
      <copyright-statement>Â© The Author(s) (2012). Published by Oxford University Press.</copyright-statement>
      <copyright-year>2012</copyright-year>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/3.0">
        <license-p><!--CREATIVE COMMONS-->This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/3.0">http://creativecommons.org/licenses/by/3.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> With advances in sequencing technology, it has become faster and cheaper to obtain short-read data from which to assemble genomes. Although there has been considerable progress in the field of genome assembly, producing high-quality <italic>de novo</italic> assemblies from short-reads remains challenging, primarily because of the complex repeat structures found in the genomes of most higher organisms. The telomeric regions of many genomes are particularly difficult to assemble, though much could be gained from the study of these regions, as their evolution has not been fully characterized and they have been linked to aging.</p>
      <p><bold>Results:</bold> In this article, we tackle the problem of assembling highly repetitive regions by developing a novel algorithm that iteratively extends long paths through a series of read-overlap graphs and evaluates them based on a statistical framework. Our algorithm, Telescoper, uses short- and long-insert libraries in an integrated way throughout the assembly process. Results on real and simulated data demonstrate that our approach can effectively resolve much of the complex repeat structures found in the telomeres of yeast genomes, especially when longer long-insert libraries are used.</p>
      <p><bold>Availability:</bold> Telescoper is publicly available for download at sourceforge.net/p/telescoper.</p>
      <p>
        <bold>Contact:</bold>
        <email>yss@eecs.berkeley.edu</email>
      </p>
      <p><bold>Supplementary Information:</bold><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/bts399/DC1">Supplementary data</ext-link> are available at <italic>Bioinformatics</italic> online.</p>
    </abstract>
    <counts>
      <page-count count="7"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec id="SEC1">
    <title>1 INTRODUCTION</title>
    <p>Recent advances in high-throughput sequencing (HTS) technologies have dramatically reduced the cost of producing reference genomes for new species and characterizing whole-genome variations in multiple individuals of a population. However, the assemblies produced by current algorithms are often incomplete. <xref ref-type="bibr" rid="B1">Alkan <italic>et al.</italic> (2011)</xref> report that a <italic>de novo</italic> shotgun assembly of the human genome using short-reads is 16% shorter than the reference assembled using more laborious means, and that <italic>&lt;</italic> 1% of segmental duplications are represented. Indeed, it is well recognized that there is room for better algorithmic use of the data, especially for repetitive regions, which are one of the primary challenges in assembly. Telomeres are particularly complex and repetitive, and thus very difficult to assemble correctly. Not only does each telomere contain repeats within itself, but often telomeres on different chromosomes are very similar. Existing assembly algorithms thus frequently fail to assemble telomeric regions from short-read data. Due to this lack of complete assembly, telomere evolution has not been fully characterized, though a great deal is to be gained from it, as telomeres have been linked to ageing (<xref ref-type="bibr" rid="B14">McEachern <italic>et al.</italic>, 2000</xref>). High-quality telomere assemblies could help us learn more about the variation in telomeres within and between species. In addition, characterizing telomere gene families and their regulation could help us clarify the function of telomeres and how they change as we age.</p>
    <p>Genome assembly is the challenge of piecing together reads to reconstruct the original genome. Reads are obtained from various technologies, with varying read length, error rates and coverage. Sanger-chemistry reads range in length from around 500 to 1000 bases. Newer technologies such as Illumina, Complete Genomics (<xref ref-type="bibr" rid="B5">Drmanac <italic>et al.</italic>, 2010</xref>), Helicos (<xref ref-type="bibr" rid="B8">Harris <italic>et al.</italic>, 2008</xref>), 454 Life Sciences (<xref ref-type="bibr" rid="B13">Margulies <italic>et al.</italic>, 2005</xref>), SOLiD (<xref ref-type="bibr" rid="B15">McKernan <italic>et al.</italic>, 2009</xref>) and Ion Torrent (<xref ref-type="bibr" rid="B21">Rothberg <italic>et al.</italic>, 2011</xref>) provide reads at vastly lower costs for greater throughput, but at the expense of length. Initial improvements in assembly from short-read data focused on how to process the sheer quantity of data and how to detect overlaps. The de Bruijn graph proved a useful data structure for this purpose (<xref ref-type="bibr" rid="B20">Pevzner <italic>et al.</italic>, 2001</xref>) and is used by pioneering short-read assemblers such as Velvet (<xref ref-type="bibr" rid="B26">Zerbino and Birney, 2008</xref>) and EULER-USR (<xref ref-type="bibr" rid="B3">Chaisson <italic>et al.</italic>, 2009</xref>), and subsequent assemblers including SOAPdenovo (<xref ref-type="bibr" rid="B11">Li <italic>et al.</italic>, 2010</xref>), ALLPATHS 2 (<xref ref-type="bibr" rid="B12">MacCallum <italic>et al.</italic>, 2009</xref>), ABySS (<xref ref-type="bibr" rid="B23">Simpson <italic>et al.</italic>, 2009</xref>) and Cortex (<xref ref-type="bibr" rid="B9">Iqbal <italic>et al.</italic>, 2012</xref>).</p>
    <p>Many HTS platforms produce paired-end or mate-pair reads, which we collectively refer to as read-pairs. The paired nature of these reads constitutes a powerful source of information, significantly facilitating genome assembly. Improved use of read-pair information lies at the heart of recent works such asALLPATHS-LG (<xref ref-type="bibr" rid="B7">Gnerre <italic>et al.</italic>, 2011</xref>), the PE-Assembler (<xref ref-type="bibr" rid="B2">Ariyaratne and Sung, 2011</xref>) and the Paired de Bruijn Graph (<xref ref-type="bibr" rid="B16">Medvedev <italic>et al.</italic>, 2011</xref>), innovations of which are primarily in earlier use of short-insert read-pairs.</p>
    <p>ALLPATHS-LG requires reads of length around 100 bases sequenced from short fragments of length â 180 bp so that, on average, each read-pair overlaps by â¼20 bases. This means that in general each read-pair can be merged into a single longer read corresponding to the fragment. A drawback of this approach is in the very specific type of data required, which differs from the standard library construction of fragments 300â500 bp in size. The PE-Assembler builds short stretches in non-repetitive regions first, similar to unitigs (see <xref ref-type="sec" rid="SEC2">Section 2</xref> for a definition) in a de Bruijn graph, and then extends these iteratively using reads with mates that map to the increasing already-assembled portion. (A similar idea is also used in <xref ref-type="bibr" rid="B18">Parrish <italic>et al.</italic> (2011</xref>) for resequencing with a reference, where insertions are assembled as iterative extensions of existing sequences.) The Paired de Bruijn Graph method entails building a so-called A-Bruijn graph in which vertices track pairs of reads instead of single reads, with two vertices being merged only if the merging is consistent with the associated pairs of reads. To our knowledge, this method remains largely theoretical at this time, and it has been tested only on simulated data with perfect reads.</p>
    <p>A theoretical observation from <xref ref-type="bibr" rid="B16">Medvedev <italic>et al.</italic> (2011)</xref> is that longer long-insert libraries can substantially improve assembly. Recent innovations (<xref ref-type="bibr" rid="B19">Peng <italic>et al.</italic>, 2012</xref>) in library construction may bring such libraries into the mainstream, so it is timely to develop algorithms that take full advantage of such data.</p>
    <p>In this article, we describe a new algorithm to improve <italic>de novo</italic> assembly of highly repetitive regions. Although the ideas presented here are applicable to the assembly of any genomic region, our algorithm was developed with the specific aim of assembling highly repetitive regions such as telomeres. In our method, which we name Telescoper, we incorporate the following three algorithmic ideas, the latter two of which make novel use of read-pairs:
<list list-type="order"><list-item><p><bold>Iterative extensions:</bold> a seed sequence is extended iteratively using reads localized to a particular region by their mates, thus allowing for gradual extension into difficult regions. See <xref ref-type="sec" rid="SEC3.1">Section 3.1</xref> for details. As mentioned above, this idea is not new, but it has not yet been fully exploited in a well-used algorithm, despite several potential advantages.</p></list-item><list-item><p><bold>Simultaneous use of short-insert read-pairs in a statistical framework:</bold> rather than using read-pair information pair by pair to untangle the read-graph, we build extensions through the graph and <italic>simultaneously</italic> consider all read-pairs mapping to each extension to choose the most probable extension. See <xref ref-type="sec" rid="SEC3.2">Section 3.2.</xref></p></list-item><list-item><p><bold>Simultaneous use of long-insert libraries:</bold> rather than using long-insert read-pairs only for scaffolding or for filling in gaps between easily assembled contigs, our iterative extension procedure uses long-insert reads during assembly. We look for support of assembled sequence at all insert sizes, so that incorrect assembly can result only if the repetitive structure spans all libraries. See <xref ref-type="sec" rid="SEC3.3">Section 3.3</xref> for further details.</p></list-item></list></p>
    <p>Each of the above ideas helps to resolve repetitive regions. Implicit throughout our algorithm is the principle that in order to assemble difficult regions, one cannot make only safe simplifications, but must also explore several alternative extensions and use downstream analysis to find and reject false extensions.</p>
    <p>We tested the performance of our method on both real and simulated data from the telomeres of the <italic>Saccharomyces cerevisiae</italic> genome, which consists of 16 chromosomes. This is a particularly challenging problem since all such telomeres have a core repetitive component called X (â 475 bp long) as well as several combinatorial repeats and sometimes a larger repetitive component (see Saccharomyces Genome Database, <ext-link ext-link-type="uri" xlink:href="http://www.yeastgenome.org">www.yeastgenome.org</ext-link>). In addition, because <italic>S.cerevisiae</italic> underwent an ancient genome duplication (<xref ref-type="bibr" rid="B10">Kellis <italic>et al.</italic>, 2004</xref>), telomeric regions of different chromosomes typically share highly similar repetitive regions. We show that Telescoper is capable of generating more complete and continuous assemblies in the telomeric regions than other state-of-the-art <italic>de novo</italic> assembly algorithms, especially when longer long-insert libraries are used.</p>
  </sec>
  <sec id="SEC2">
    <title>2 TERMINOLOGY</title>
    <p>We adopt the following terms commonly used to describe the output of sequencing technologies and the resulting assemblies:
<list list-type="bullet"><list-item><p><bold>Read-pair:</bold> refers to a pair of sequenced reads from a fragment. The fragment size determines the distance between the two reads, often called the âinsertâ size. The insert distribution is frequently approximated by a normal distribution. We use the term read-pair regardless of whether the insert is short or long.</p></list-item><list-item><p><bold>Mate:</bold> refers to the partner of a read <italic>R</italic> in a read-pair. When <italic>R</italic> is oriented with respect to a sequence, we know its mate's relative position and can refer to it as a âleft-mateâ or âright-mateâ (or, as a âleft-readâ or âright-readâ).</p></list-item><list-item><p><bold>Contig:</bold> a sequence, which ideally belongs to the original genome, produced from assembling a group of reads. The standard output from an assembly algorithm is a set of contigs. Contigs are often ordered to produce âscaffoldsâ, which may contain stretches of unknown sequence between the contigs.</p></list-item><list-item><p><bold>Read-overlap graph:</bold> also called a read-graph, is a graph in which each vertex is a read and directed edges between reads represent overlapping sequence, i.e. in the error-free case, the last <italic>k</italic> bases of one read are the same as the first <italic>k</italic> bases of its neighbor read, where <italic>k</italic> is greater than some threshold.</p></list-item><list-item><p><bold>Unitig:</bold> a path through the read-graph that can be unambiguously merged into a single sequence. A âunitig graphâis an extension of the read-overlap graph idea (similarly for a unitig path), where the vertices are now unitigs.</p></list-item></list></p>
  </sec>
  <sec id="SEC3">
    <title>3 METHODS</title>
    <p>We have two main aims in our algorithm: (i) rather than performing a greedy read-by-read assembly procedure, we build a number of alternative extensions, and score them according to the alignment of read-pairs to each extension and (ii) we use long-insert read-pairs not only for scaffolding or gap filling but also as part of the assembly itself, to check that the local assembly is consistent on a longer scale.</p>
    <p>Our algorithm begins with a set of non-repetitive âseed stringsâ, as could be taken from a reference genome, if it exists, or be assembled from a de Bruijn graph. At present, we use seeds of length 500 bp from the reference, at position 40 kb from the end of the chromosome, although contigs produced from any other algorithm could be used. The goal is to then independently extend each contig to produce a more complete assembly.</p>
    <p>A high-level overview of the algorithm is illustrated in <xref ref-type="fig" rid="F1">Figure 1</xref>. The algorithm proceeds by extending the end of the contig iteratively by a fixed amount, <italic>N</italic><sub>new</sub>, per iteration, as detailed in <xref ref-type="sec" rid="SEC3.1">Section 3.1.</xref> We fix the extension length (usually a few hundred bases) as a conservative measure. Because multiple extensions are frequently possible, the result is an âextension graphâ (e-graph) in which each extension node (e-node) contains <italic>N</italic><sub>new</sub> bases of new sequence that serve as a possible extension for that e-node's parent. A path from the root (the seed string) to a leaf represents a series of extensions that form a single lengthened contig. The aim is for the e-graph to contain a path corresponding to the true sequence, ideally terminating close to the end of the desired chromosome, and for this path to be identifiable as the best.
<fig id="F1" position="float"><label>Fig. 1.</label><caption><p>High-level description of the algorithm. Beginning with the seed string <italic>S</italic><sub>0</sub>, the algorithm iteratively performs the steps described to construct an e-graph data structure, from which a contig or contigs can be read. For simplicity, only a few example arcs are shown; in reality, red arcs are present between each consecutive pair of e-nodes, and orange arcs can be present between a given e-node and any of its preceding e-nodes</p></caption><graphic xlink:href="bts399f1"/></fig>
</p>
    <p>Our algorithm will be most tractable if the e-graph is sparse, so at each iteration, there are as few extensions as possible (and the true extension is among them). The criteria for pruning and terminating the e-graph are discussed in <xref ref-type="sec" rid="SEC3.4">Section 3.4.</xref> We first explain our methods for (i) listing possible extensions for a given e-node in the e-graph, (ii) scoring each extension based on the alignment of short-insert read-pairs and (iii) scoring each extension based on the alignment of long-insert read-pairs.</p>
    <p>In the following description, we assume without loss of generality that we are extending to the right.</p>
    <sec id="SEC3.1">
      <title>3.1 Iterative extension of assembly</title>
      <p>The extension step consists of finding possible extensions of a given e-node; the extensions will in turn become e-nodes themselves. We fix the length of each e-node so that most right-reads in the new extension will have left-mates mapping to the e-node rather than behind it. In our implementation, we choose this length, denoted <italic>N</italic><sub>tot</sub>, to be the mean insert length plus the standard deviation of the short-insert library. In the case of multiple short-insert libraries, one can use the largest short-insert length for computing <italic>N</italic><sub>tot</sub>.</p>
      <p>The extension step is depicted in <xref ref-type="fig" rid="F2">Figure 2</xref>. It begins by mapping all the left-reads to the e-node to obtain right-mates extending off the right end of the e-node into unknown region yet to be assembled, i.e. the left-mate maps to the e-node and the right-mate dangles off the end, as illustrated in <xref ref-type="fig" rid="F2">Figure 2a</xref>. We say that these right-mates form a read âcloudâ.
<fig id="F2" position="float"><label>Fig. 2.</label><caption><p>Illustration of Step 1 of <xref ref-type="fig" rid="F1">Figure 1</xref>, finding an e-node <italic>S</italic>'s possible extensions. (<bold>a</bold>) A read âcloudâ consists of those right-reads with left-mates that map to <italic>S</italic>. (<bold>b</bold>) The reads in the cloud are then error corrected and organized into a read-graph, which is in turn converted into a unitig graph. (<bold>c</bold>) Paths through the unitig graph correspond to possible extensions</p></caption><graphic xlink:href="bts399f2"/></fig>
</p>
      <p>The reads in the read cloud are error-corrected, then used to construct a read-overlap graph, which is transformed into a unitig graph as depicted in <xref ref-type="fig" rid="F2">Figure 2b</xref>. More details on error-correction and read-overlap graph construction are provided in the <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/bts399/DC1">Supplementary Material</ext-link>. The unitig graph encodes a list of candidate extensions for the contig, as illustrated in <xref ref-type="fig" rid="F2">Figure 2c</xref>. Each new e-node consists of <italic>N</italic><sub>new</sub> bases of new extension plus (<italic>N</italic><sub>tot</sub> â <italic>N</italic><sub>new</sub>) bases from the end of the previous e-node.</p>
      <p>There are several advantages to this localized assembly. First, it reduces ambiguities caused by repeats. For a read-pair from another location to interfere with the area under construction, its left-read must map to the previous e-node while the right-read must overlap with another read in the read cloud. Second, because it restricts assembly to a small region, there is ample memory to store complicated information about the reads and their relationships. This information can be thrown out as we move to other regions of the graph. This local use of information enables more complex use of read-pairs, as described in <xref ref-type="sec" rid="SEC3.2">Sections 3.2</xref> and <xref ref-type="sec" rid="SEC3.3">3.3</xref>.</p>
    </sec>
    <sec id="SEC3.2">
      <title>3.2 Simultaneous use of short-insert read-pairs in statistical scoring of extensions</title>
      <p>Although existing assembly algorithms make use of read-pairs in various ways, the information contained in read-pairs has not yet been fully exploited. In other assemblers, read-pairs are used primarily to connect unitigs with expected insert sizes. We can obtain additional power by scoring potential extensions according to the features derived from the aligned read-pairs.</p>
      <p>We first evaluate extensions based on the likelihood of gaps in short-insert read-pair coverage. Each extension consists of an ordered sequence of unitigs, as in <xref ref-type="fig" rid="F2">Figure 2c</xref>. Each right-read in an assembled unitig will have a left-mate mapping to earlier sequence in the previous e-node. The set of left-mates associated with reads in unitig <italic>U</italic> is denoted <italic>M<sub>U</sub></italic> (<xref ref-type="fig" rid="F3">Fig. 3a</xref>).
<fig id="F3" position="float"><label>Fig. 3.</label><caption><p>Computing the expected number of left-reads mapping back from a unitig <italic>U</italic><sub>2</sub> to the previous e-node <italic>S</italic>. (<bold>a</bold>) <italic>M</italic><sub><italic>U</italic><sub>2</sub></sub> denotes the set of reads mapping from unitig <italic>U</italic><sub>2</sub> to the previous e-node <italic>S</italic>. (<bold>b</bold>) For a right-read <italic>R</italic><sub>r</sub> located at position t in unitig <italic>U</italic><sub>2</sub>, the probability of its left-mate <italic>R<sub>l</sub></italic> mapping to <italic>S</italic> at a distance <italic>x</italic> behind <italic>U</italic><sub>2</sub> is <italic>h</italic>(<italic>x</italic> + <italic>t</italic>), where <italic>h</italic>(Â·) is the expected insert distribution. (<bold>c</bold>) The expected number of reads at position <italic>x</italic> behind unitig <italic>U</italic><sub>2</sub> is given by <italic>f<sub>U</sub></italic> (<italic>x</italic>) defined in <xref ref-type="disp-formula" rid="M1">Equation (1)</xref></p></caption><graphic xlink:href="bts399f3"/></fig>
</p>
      <p>In our model, we make the simplifying assumption of a uniform coverage distribution. Let <italic>x</italic> denote the distance from the right end of a left read relative to the start of unitig <italic>U</italic>, as pictured in <xref ref-type="fig" rid="F3">Figure 3b</xref>. We denote by <italic>f<sub>U</sub></italic> (<italic>x</italic>) the expected number of left-reads in <italic>M<sub>U</sub></italic> spanning position <italic>x</italic> (<xref ref-type="fig" rid="F3">Fig. 3c</xref>). We compute <italic>f<sub>U</sub></italic> (<italic>x</italic>) by convolving the expected insert distribution <italic>h</italic>(Â·) with the uniform distribution over the stretch of <italic>U</italic> on which right mates can begin:
<disp-formula id="M1"><label>(1)</label><graphic xlink:href="bts399m1"/></disp-formula>
where <italic>L</italic>(<italic>U</italic>) is the length of <italic>U</italic>, <italic>â</italic> is the read length and <italic>Î»</italic> is the probability of a read arriving at position <italic>t</italic>; note that <italic>Î»</italic> is equal to <italic>C/</italic>(2<italic>â</italic>), where <italic>C</italic> is the coverage. False unitigs will typically have gaps in the empirical distribution <inline-formula><inline-graphic xlink:href="bts399i1.jpg"/></inline-formula>, as illustrated in <xref ref-type="fig" rid="F4">Figure 4b</xref>. Let Gap(<italic>U</italic>) denote the set of such gaps associated with <italic>U</italic> . For a gap <italic>g</italic> â Gap(<italic>U</italic>) of length â¥ <italic>â/</italic>2, we compute a penalty equal to the number of mates expected in <italic>g</italic>, obtained by summing <italic>f<sub>U</sub></italic> (<italic>x</italic>) over <italic>g</italic>'s coordinates. The preliminary score for an extension is then the sum of these penalties over all gaps and all unitigs in the extension:
<disp-formula id="M2"><label>(2)</label><graphic xlink:href="bts399m2"/></disp-formula>
To produce a final score <italic>P</italic><sub>ext</sub> for each possible extension, we add <italic>p</italic><sub>ext</sub> to a âcontig gap penaltyâ, equal to <italic>Î»</italic> times the largest gap size (denoted by <italic>g<sub>c</sub></italic> in <xref ref-type="fig" rid="F4">Fig. 4c</xref>) between two adjacent unitigs, i.e. the expected number of reads to fall in that gap. The best extensions (i.e. those with the lowest <italic>P</italic><sub>ext</sub> scores) are kept, as described in more detail in <xref ref-type="sec" rid="SEC3.4">Section 3.4.</xref>
<fig id="F4" position="float"><label>Fig. 4.</label><caption><p>Illustration of Step 2 of <xref ref-type="fig" rid="F1">Figure 1</xref>, scoring an e-node's possible extensions using short-insert read-pairs. (<bold>a</bold>) The penalty for unitig <italic>U</italic><sub>2</sub> is 0 because no gaps of size â¥<italic>â/</italic>2 exist (where <italic>â</italic> is the read length). (<bold>b</bold>) The penalty for unitig <italic>U</italic><sub>3</sub> is <italic>&gt;</italic> 0 because a gap, denoted <italic>g</italic>, of size â¥ <italic>â/</italic>2 exists. (<bold>c</bold>) The size of contig gap <italic>g<sub>c</sub></italic> is the distance between the reads that define the end and start of two adjacent unitigs</p></caption><graphic xlink:href="bts399f4"/></fig>
</p>
    </sec>
    <sec id="SEC3.3">
      <title>3.3 Simultaneous use of long-insert libraries</title>
      <p>Telescoper uses all libraries simultaneously during assembly, rather than using long-insert libraries only during scaffolding or gap-filling, as is typical in other assembly algorithms. The main idea is that once long paths have been formed in the e-graph, any further extension can be evaluated on the basis of its agreement with the current e-graph according to each library. Having produced and pruned a set of extensions using just the short-insert library in Steps 1 and 2 of our algorithm (<xref ref-type="fig" rid="F1">Fig. 1</xref>), the third step aims to confirm that a proposed extension is supported by read-pair information from all other libraries simultaneously. For there to be ambiguity in extension choice, there must be repeats at lengths corresponding to all library sizes.</p>
      <p>To test for long-insert read-pair support of a potential extension, we first gather all read-pairs of which right reads map to the extension and left-reads map to the previous e-nodes in the path up the e-graph. Then, if the right reads fully cover the proposed extension, even possibly without overlaps, we consider the extension to be fully supported. Partial support is computed as a linear function of the fraction of the extension that is covered by the right reads. This support measure is then multiplied by the short-insert score <italic>P</italic><sub>ext</sub> to obtain a single final score.</p>
    </sec>
    <sec id="SEC3.4">
      <title>3.4 Choosing extensions for continuation</title>
      <p>For a given e-node, upon finding all its possible extensions, at most <italic>B</italic> top scoring (the lower the better) extensions are retained for computational tractability. In our analysis, we use <italic>B</italic> = 4. We create a new e-node for each of these top scoring extensions and assign a running score equal to the sum of its extension score and its parent e-node's running score. Then, at each depth in the e-node graph, the <italic>B</italic> top scoring e-nodes are marked for pursuit.</p>
      <p>An e-node is terminated if it cannot be lengthened by the extension operation, if its extension score plus the scores of two previous ancestral extensions exceeds a threshold, or if a specified maximum depth is reached.</p>
      <p>To track the parallel success of alternative e-node paths and keep their number in check, we use breadth first search to explore the e-graph. If two different sequences of e-nodes end with equivalent e-nodes at a particular depth, we allow the two e-nodes to merge. This kind of merging of e-nodes reduces the computational burden.</p>
    </sec>
  </sec>
  <sec id="SEC4">
    <title>4 EMPIRICAL RESULTS</title>
    <p>In this section, we compare Telescoper's performance with that of other short-read assembly algorithms, including ABySS (<xref ref-type="bibr" rid="B23">Simpson <italic>et al.</italic>, 2009</xref>), ALLPATHS 2 (<xref ref-type="bibr" rid="B12">MacCallum <italic>et al.</italic>, 2009</xref>), SGA (<xref ref-type="bibr" rid="B24">Simpson and Durbin, 2012</xref>), SOAPdenovo (<xref ref-type="bibr" rid="B11">Li <italic>et al.</italic>, 2010</xref>) and Velvet (<xref ref-type="bibr" rid="B26">Zerbino and Birney, 2008</xref>).</p>
    <p>Because of limited space, we focus on short-read data in the ensuing discussion. However, as detailed in the <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/bts399/DC1">Supplementary Material</ext-link>, we also considered a combination of short-insert short-read data and long-insert Sanger read data, and observed that Telescoper compares favourably with other algorithms, including Celera (<xref ref-type="bibr" rid="B17">Myers <italic>et al.</italic>, 2000</xref>), which was designed for Sanger reads.</p>
    <sec sec-type="methods" id="SEC4.1">
      <title>4.1 Data and experiment setup</title>
      <p>We studied the performance on both simulated and real data from strain S288C of <italic>S. cerevisiae</italic>. We obtained a reference genome from Saccharomyces Genome Database (<ext-link ext-link-type="uri" xlink:href="http://www.yeastgenome.org">www.yeastgenome.org</ext-link>), which was created through extensive, systematic sequencing to produce a very accurate assembly, including the telomeric regions. As mentioned earlier, because of ancient genome duplication and complex yeast telomere structure, the telomeres of different chromosomes typically share highly similar repetitive regions, which poses challenges to assembly.</p>
      <p>We considered different types of data to test the robustness of the algorithms and to study the effect of insert distributions on performance:</p>
      <p><bold>Simulated Data D1</bold> consisted of read-pairs with two insert distributions, one short and one long. The read length was 101 bp for both types. The <italic>short-insert</italic> reads had coverage depth 100Ã and an insert distribution with mean 400 bp and variance 75 bp. The <italic>long-insert</italic> reads had coverage depth 20Ã and an insert distribution with mean 10 kb and variance 1 kb. Simulation details are provided in the <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/bts399/DC1">Supplementary Material</ext-link>.</p>
      <p><bold>Simulated Data D2</bold> consisted of two read-pair datasets with the same insert distributions and coverages as D1, but with a reduced read length of 50 bp.</p>
      <p><bold>Real Data D3</bold> consisted of Illumina read-pairs from a sequencing library preparation using Cre-Lox recombination. The reads, as described in Van <xref ref-type="bibr" rid="B25">Nieuwerburgh <italic>et al.</italic> (2012)</xref>, were sorted using DeLoxer into reads categorized as <italic>short-insert</italic> (0â400 bp fragments, mean 220 bases) or <italic>long-insert</italic> (1â5 kb, mean 2.3 kb). The reads varied in length from 30â100 bp. We truncated reads to 50 bases in order to provide algorithms with high-quality, uniform-length reads. We used coverage 120Ã for the short-insert data and 40Ã for the long-insert data. The performance of Telescoper does not degrade with higher coverage data.</p>
      <p>We sought to assess assembly for the 40-kb telomeric regions at the ends of each of <italic>S. cerevisiae</italic>'s 16 chromosomes. To this end, we simulated data only from this region. For the real data, we used the full dataset, but restricted evaluation statistics of the produced contigs to those alignable to the 32 telomeres, each of length 40 kb.</p>
      <p>Details of running the various algorithms, including parameter settings and runtimes, can be found in the <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/bts399/DC1">Supplementary Material</ext-link>. To optimize the performance of the other algorithms, insert distribution and coverage parameters were provided where appropriate. We did not include SGA for D2 and D3 since it was designed for reads of at least 100 bp.</p>
    </sec>
    <sec id="SEC4.2">
      <title>4.2 Assembly performance</title>
      <p>Several standard metrics exist for measuring assembly performance in the absence of a reference genome. They include the length of the largest contig, the total length of all contigs, and N50 (which is equal to the longest contig length such that the sum of the lengths of all longer contigs is half the total output assembly). An additional metric is NG50 (<xref ref-type="bibr" rid="B6">Earl <italic>et al.</italic>, 2011</xref>), which is similar to N50 but more comparable across assembly algorithms. When the genome length is known, then rather than using each algorithm's estimate of the genome size, which can fluctuate widely depending on the threshold at which small contigs are output, one can use the true genome size. Thus NG50 is defined as the length of the longest contig such that the sum of all longer contigs is half the total genome size. We considered the above-mentioned metrics in our study.</p>
      <p>To investigate assembly accuracy, we mapped each contig to the reference genome using NUCmer from the MUMMER package (<xref ref-type="bibr" rid="B4">Delcher <italic>et al.</italic>, 2002</xref>). For each contig, we determined to which telomere it maps best according to the total number of aligned bases. The number of aligned bases in each contig forms a more useful foundation for accuracy-informed continuity statistics than the direct number of bases in each contig. Therefore, we also computed the aforementioned metrics using these aligned lengths.</p>
      <p>The results of our study for simulated data are summarized in <xref ref-type="table" rid="T1">Table 1</xref>, while the results for the real data are shown in <xref ref-type="table" rid="T2">Table 2</xref>. These results are for the 32 telomeric regions, each of length 40 kb. As the tables show, Telescoper exhibited the best performance under most metrics, with notable margins from the second best method. As shown in <xref ref-type="table" rid="T1">Table 1</xref>, reducing the read length from 101 to 50 bp while keeping all other parameters the same worsened the performance of most algorithms, with ABySS being the most affected.
<table-wrap id="T1" position="float"><label>Table 1.</label><caption><p>Summary of assembly results based on simulated data from 32 telomeric regions each of length 40 kb. â%Alignedâ is the ratio of Total Aligned to Total Produced, while â%Coveredâ is the fraction of the telomeric regions covered by contigs</p></caption><table frame="hsides" rules="groups"><thead><tr><th colspan="11" rowspan="1">Results for simulated data D1 (read length = 101 bp)<hr/></th></tr><tr><th rowspan="1" colspan="1"/><th colspan="4" rowspan="1">Produced (kb) <hr/></th><th colspan="4" rowspan="1">Aligned (kb) <hr/></th><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/></tr><tr><th rowspan="1" colspan="1">Assembler</th><th rowspan="1" colspan="1">N50</th><th rowspan="1" colspan="1">NG50</th><th rowspan="1" colspan="1">Max</th><th rowspan="1" colspan="1">Total</th><th rowspan="1" colspan="1">N50</th><th rowspan="1" colspan="1">NG50</th><th rowspan="1" colspan="1">Max</th><th rowspan="1" colspan="1">Total</th><th rowspan="1" colspan="1">%Aligned</th><th rowspan="1" colspan="1">%Covered</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">Telescoper</td><td rowspan="1" colspan="1">40.0</td><td rowspan="1" colspan="1">40.0</td><td rowspan="1" colspan="1">41.0</td><td rowspan="1" colspan="1">1208</td><td rowspan="1" colspan="1">40.0</td><td rowspan="1" colspan="1">40.0</td><td rowspan="1" colspan="1">40.0</td><td rowspan="1" colspan="1">1172</td><td rowspan="1" colspan="1">97.0</td><td rowspan="1" colspan="1">90.4</td></tr><tr><td rowspan="1" colspan="1">ABySS</td><td rowspan="1" colspan="1">31.0</td><td rowspan="1" colspan="1">31.0</td><td rowspan="1" colspan="1">39.0</td><td rowspan="1" colspan="1">1296</td><td rowspan="1" colspan="1">31.8</td><td rowspan="1" colspan="1">31.8</td><td rowspan="1" colspan="1">39.3</td><td rowspan="1" colspan="1">1244</td><td rowspan="1" colspan="1">95.9</td><td rowspan="1" colspan="1">84.7</td></tr><tr><td rowspan="1" colspan="1">ALLPATHS2</td><td rowspan="1" colspan="1">35.2</td><td rowspan="1" colspan="1">33.0</td><td rowspan="1" colspan="1">39.0</td><td rowspan="1" colspan="1">1047</td><td rowspan="1" colspan="1">35.2</td><td rowspan="1" colspan="1">33.4</td><td rowspan="1" colspan="1">40.0</td><td rowspan="1" colspan="1">1032</td><td rowspan="1" colspan="1">98.5</td><td rowspan="1" colspan="1">80.6</td></tr><tr><td rowspan="1" colspan="1">SOAPdenovo</td><td rowspan="1" colspan="1">25.0</td><td rowspan="1" colspan="1">24.0</td><td rowspan="1" colspan="1">39.0</td><td rowspan="1" colspan="1">1149</td><td rowspan="1" colspan="1">28.6</td><td rowspan="1" colspan="1">24.6</td><td rowspan="1" colspan="1">40.0</td><td rowspan="1" colspan="1">1068</td><td rowspan="1" colspan="1">92.9</td><td rowspan="1" colspan="1">82.3</td></tr><tr><td rowspan="1" colspan="1">Velvet</td><td rowspan="1" colspan="1">13.9</td><td rowspan="1" colspan="1">9.0</td><td rowspan="1" colspan="1">31.0</td><td rowspan="1" colspan="1">964</td><td rowspan="1" colspan="1">13.9</td><td rowspan="1" colspan="1">9.5</td><td rowspan="1" colspan="1">31.6</td><td rowspan="1" colspan="1">947</td><td rowspan="1" colspan="1">98.2</td><td rowspan="1" colspan="1">73.7</td></tr><tr><td rowspan="1" colspan="1">SGA</td><td rowspan="1" colspan="1">31.2</td><td rowspan="1" colspan="1">27.0</td><td rowspan="1" colspan="1">39.0</td><td rowspan="1" colspan="1">1110</td><td rowspan="1" colspan="1">31.6</td><td rowspan="1" colspan="1">27.2</td><td rowspan="1" colspan="1">40.0</td><td rowspan="1" colspan="1">1075</td><td rowspan="1" colspan="1">96.8</td><td rowspan="1" colspan="1">82.0</td></tr></tbody></table><table frame="hsides" rules="groups"><thead><tr><th colspan="11" rowspan="1">Results for simulated data D2 (read length = 50 bp)<hr/></th></tr><tr><th rowspan="1" colspan="1"/><th colspan="4" rowspan="1">Produced (kb) <hr/></th><th colspan="4" rowspan="1">Aligned (kb)<hr/></th><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/></tr><tr><th rowspan="1" colspan="1">Assembler</th><th rowspan="1" colspan="1">N50</th><th rowspan="1" colspan="1">NG50</th><th rowspan="1" colspan="1">Max</th><th rowspan="1" colspan="1">Total</th><th rowspan="1" colspan="1">N50</th><th rowspan="1" colspan="1">NG50</th><th rowspan="1" colspan="1">Max</th><th rowspan="1" colspan="1">Total</th><th rowspan="1" colspan="1">%Aligned</th><th rowspan="1" colspan="1">%Covered</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">Telescoper</td><td rowspan="1" colspan="1">39.0</td><td rowspan="1" colspan="1">38.0</td><td rowspan="1" colspan="1">39.0</td><td rowspan="1" colspan="1">1162</td><td rowspan="1" colspan="1">38.8</td><td rowspan="1" colspan="1">38.3</td><td rowspan="1" colspan="1">39.8</td><td rowspan="1" colspan="1">1155</td><td rowspan="1" colspan="1">99.4</td><td rowspan="1" colspan="1">90.3</td></tr><tr><td rowspan="1" colspan="1">ABySS</td><td rowspan="1" colspan="1">12.1</td><td rowspan="1" colspan="1">8.0</td><td rowspan="1" colspan="1">31.0</td><td rowspan="1" colspan="1">1097</td><td rowspan="1" colspan="1">13.7</td><td rowspan="1" colspan="1">8.9</td><td rowspan="1" colspan="1">31.6</td><td rowspan="1" colspan="1">966</td><td rowspan="1" colspan="1">88.0</td><td rowspan="1" colspan="1">75.0</td></tr><tr><td rowspan="1" colspan="1">ALLPATHS2</td><td rowspan="1" colspan="1">32.0</td><td rowspan="1" colspan="1">27.0</td><td rowspan="1" colspan="1">39.0</td><td rowspan="1" colspan="1">968</td><td rowspan="1" colspan="1">32.8</td><td rowspan="1" colspan="1">27.7</td><td rowspan="1" colspan="1">40.0</td><td rowspan="1" colspan="1">950</td><td rowspan="1" colspan="1">98.2</td><td rowspan="1" colspan="1">74.3</td></tr><tr><td rowspan="1" colspan="1">SOAPdenovo</td><td rowspan="1" colspan="1">25.0</td><td rowspan="1" colspan="1">21.0</td><td rowspan="1" colspan="1">39.0</td><td rowspan="1" colspan="1">988</td><td rowspan="1" colspan="1">24.6</td><td rowspan="1" colspan="1">20.8</td><td rowspan="1" colspan="1">40.0</td><td rowspan="1" colspan="1">954</td><td rowspan="1" colspan="1">96.5</td><td rowspan="1" colspan="1">74.3</td></tr><tr><td rowspan="1" colspan="1">Velvet</td><td rowspan="1" colspan="1">14.0</td><td rowspan="1" colspan="1">9.0</td><td rowspan="1" colspan="1">31.0</td><td rowspan="1" colspan="1">955</td><td rowspan="1" colspan="1">14.2</td><td rowspan="1" colspan="1">9.5</td><td rowspan="1" colspan="1">31.9</td><td rowspan="1" colspan="1">939</td><td rowspan="1" colspan="1">98.3</td><td rowspan="1" colspan="1">73.2</td></tr></tbody></table></table-wrap>
<table-wrap id="T2" position="float"><label>Table 2.</label><caption><p>Summary of results for real data D3. The contigs produced by each algorithm were aligned to the 32 telomeric regions each of length 40 kb. As before, â%Coveredâ is the fraction of the telomeric regions covered by contigs</p></caption><table frame="hsides" rules="groups"><thead><tr><th rowspan="1" colspan="1"/><th colspan="4" rowspan="1">Aligned (kb)<hr/></th><th rowspan="1" colspan="1"/></tr><tr><th rowspan="1" colspan="1">Assembler</th><th rowspan="1" colspan="1">N50</th><th rowspan="1" colspan="1">NG50</th><th rowspan="1" colspan="1">Max</th><th rowspan="1" colspan="1">Total</th><th rowspan="1" colspan="1">%Covered</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">Telescoper</td><td rowspan="1" colspan="1">34.5</td><td rowspan="1" colspan="1">32.8</td><td rowspan="1" colspan="1">39.2</td><td rowspan="1" colspan="1">980</td><td rowspan="1" colspan="1">75.8</td></tr><tr><td rowspan="1" colspan="1">ABySS</td><td rowspan="1" colspan="1">12.0</td><td rowspan="1" colspan="1">8.3</td><td rowspan="1" colspan="1">31.3</td><td rowspan="1" colspan="1">971</td><td rowspan="1" colspan="1">75.3</td></tr><tr><td rowspan="1" colspan="1">ALLPATHS2</td><td rowspan="1" colspan="1">26.3</td><td rowspan="1" colspan="1">16.5</td><td rowspan="1" colspan="1">40.0</td><td rowspan="1" colspan="1">923</td><td rowspan="1" colspan="1">70.1</td></tr><tr><td rowspan="1" colspan="1">SOAPdenovo</td><td rowspan="1" colspan="1">21.4</td><td rowspan="1" colspan="1">16.2</td><td rowspan="1" colspan="1">39.3</td><td rowspan="1" colspan="1">879</td><td rowspan="1" colspan="1">68.6</td></tr><tr><td rowspan="1" colspan="1">Velvet</td><td rowspan="1" colspan="1">11.8</td><td rowspan="1" colspan="1">6.9</td><td rowspan="1" colspan="1">31.3</td><td rowspan="1" colspan="1">928</td><td rowspan="1" colspan="1">72.2</td></tr></tbody></table></table-wrap></p>
      <p><xref ref-type="fig" rid="F5">Figure 5</xref> provides a more detailed picture of contig length distribution. These plots show the cumulative proportion for all aligned contigs exceeding the contig size indicated on the <italic>x</italic>-axis. NG50 can be read from the plots as the <italic>x</italic>-coordinates at which each curve hits the 50% mark of bases output relative to the reference. The best possible curve is the constant function <italic>y</italic> = 1, so the closer a curve is to that line, the better the performance. Note that for any given minimum contig size (the <italic>x</italic>-axis value), Telescoper produced more alignable bases than all other methods compared, for all three datasets. Furthermore, <xref ref-type="fig" rid="F5">Figures 5a and b</xref> illustrate that Telescoper is more robust to a decrease in read length than are the other algorithms.
<fig id="F5" position="float"><label>Fig. 5.</label><caption><p>The cumulative proportion of all aligned contigs exceeding the contig size indicated on the <italic>x</italic>-axis. These plots illustrate the continuity and completeness of different assemblies. For any given minimum contig length, Telescoper produced more aligned bases. NG50 can be read from this graph as the <italic>x</italic>-coordinates at which each curve hits the 50% mark of bases output relative to the reference. (<bold>a</bold>) Results on simulated data D1. (<bold>b</bold>) Results on simulated data D2. (<bold>c</bold>) Results on real data D3</p></caption><graphic xlink:href="bts399f5"/></fig>
</p>
      <p>For Telescoper, the observed difference between the corresponding curve in <xref ref-type="fig" rid="F5">Figure 5b</xref> and that in <xref ref-type="fig" rid="F5">Figure 5c</xref> is largely attributable to the difference in the insert-size distribution. On simulated 50 bp data with long inserts with mean length 2.2 kb and short inserts with mean length 400 bp, the performance of Telescoper was similar to that shown in <xref ref-type="fig" rid="F5">Figure 5c</xref> (see <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/bts399/DC1">Supplementary Material</ext-link>), suggesting that Telescoper is robust the complications of real data and that the observed good performance of Telescoper in <xref ref-type="fig" rid="F5">Figure 5b</xref> is due to its improved ability to take advantage of a longer (10 kb instead of 2.2 kb) long-insert distribution.</p>
      <p>Of further importance is the extent to which an algorithm produces false bases or contigs. Because we forced each contig to align to a single telomere, chimeric contigs created by joining portions of different telomeres were penalized as having bases that do not align. As shown in the â% Alignedâ column of <xref ref-type="table" rid="T1">Table 1</xref>, Telescoper was the top performer in this regard for D2, and followed ALLPATHS 2 and Velvet closely for D1.</p>
      <p>Finally, we considered visually examining the alignments of contigs onto each telomeric region. <xref ref-type="fig" rid="F6">Figure 6</xref> shows the results for two chromosomes, with contigs from each assembly algorithm aligned to them. For each algorithm, each contig is represented by a different colour, so more colours per method indicates a larger number of contigs. For each telomeric region shown, Telescoper produced a single contig for almost the entire region, while other algorithms often produced many small contigs.
<fig id="F6" position="float"><label>Fig. 6.</label><caption><p>Contig continuity results for real data D3. The left and right telomeric regions (separated by the dotted line) for two different chromosomes are shown, with the aligned contigs displayed for each assembly algorithm. Different colours represent different contigs in the produced assembly, so more colours per method indicates a larger number of contigs. For each telomeric region shown, Telescoper produced a single contig for almost the entire region, while other algorithms often produced many small contigs</p></caption><graphic xlink:href="bts399f6"/></fig>
</p>
    </sec>
  </sec>
  <sec id="SEC5">
    <title>5 CONCLUSION</title>
    <p>We have introduced several new ideas for <italic>de novo</italic> genome assembly, geared towards highly repetitive regions. Our preliminary assembler, Telescoper, proceeds by iteratively extending paths and selecting between them using the empirical distributions formed by both long-insert and short-insert paired-end reads.</p>
    <p>The utility of Telescoper was validated in a study on both real and simulated data from the 40 kb telomeric regions of each chromosome of <italic>S. cerevisiae</italic>. For all three datasets tested, Telescoper produced more continuous assemblies than the other algorithms considered. In our evaluations, we tried to include the strongest and most popular algorithms with available implementation. Unfortunately, ALLPATHS-LG (<xref ref-type="bibr" rid="B7">Gnerre <italic>et al.</italic>, 2011</xref>) could not be included, because of its small-fragment library requirement mentioned in <xref ref-type="sec" rid="SEC1">Section 1.</xref> We considered several standard metrics for comparing assemblies, but we note that the task of comparing genome assemblies is a large one, with several papers exclusively devoted to it (<xref ref-type="bibr" rid="B6">Earl <italic>et al.</italic>, 2011</xref>; <xref ref-type="bibr" rid="B22">Salzberg <italic>et al.</italic>, 2012</xref>).</p>
    <p>Other researchers are currently working on algorithms for identifying assembly errors using features derived from read mapping. Rather than having this be a downstream process, we believe that it would help to incorporate such features directly into an assembly algorithm. Here, we make an effort in this direction by scoring assembly extensions according to read-mapping statistics. Although the scoring scheme used in this article may not be optimal, we have demonstrated that the idea of simultaneously pursuing multiple extensions, and concurrently using multiple libraries to score and select among them is promising.</p>
    <p>The current implementation of Telescoper can be used as a finishing algorithm to extend contigs into repetitive regions and produce better assemblies for telomeres. Other applications include targeted <italic>de novo</italic> assembly of structural variants and highly variant regions such as human leukocyte antigen. Future work will include extending the ideas presented here to whole-genome assembly, improving error correction, producing more exhaustive listings of potential paths and more thorough evaluation of the alternate paths. Also, additional validation metrics such as those explored by <xref ref-type="bibr" rid="B22">Salzberg <italic>et al.</italic> (2012)</xref> can be incorporated as well.</p>
    <p>We often see cases where, if we took the union of all assemblies, we could produce a much better final product. This suggests that assembly is not a solved problem, and that the strengths of different algorithms can potentially be combined to produce better assemblies. We believe the ideas behind Telescoper have the potential to improve <italic>de novo</italic> assembly significantly and provide a comprehensive picture of previously unresolved repetitive regions.</p>
  </sec>
</body>
<back>
  <ack>
    <title>ACKNOWLEDGMENTS</title>
    <p>We thank Jasper Rine, Oliver Zill and Devin Scannell for their motivation of the problem and for useful discussions. We also thank Paul Jenkins and Jeremy Maitin-Shepard for helpful discussions.</p>
    <p><italic>Funding:</italic> In part by <funding-source>NSF Graduate Research Fellowships</funding-source> (to M.B. and S.S.), an <funding-source>NDSEG Graduate Fellowship</funding-source> (to A.H.C.), and an <funding-source>NSF CAREER</funding-source> Grant <award-id>DBI-0846015</award-id> (to Y.S.S.).</p>
    <p><italic>Conflict of Interest:</italic> none declared.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="B1">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Alkan</surname>
            <given-names>C.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Limitations of next-generation genome sequence assembly</article-title>
        <source>Nat. Methods</source>
        <year>2011</year>
        <volume>8</volume>
        <fpage>61</fpage>
        <lpage>65</lpage>
        <pub-id pub-id-type="pmid">21102452</pub-id>
      </element-citation>
    </ref>
    <ref id="B2">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ariyaratne</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Sung</surname>
            <given-names>W. K.</given-names>
          </name>
        </person-group>
        <article-title>PE-assembler: de novo assembly using short paired-end reads</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <fpage>167</fpage>
        <lpage>174</lpage>
        <pub-id pub-id-type="pmid">21149345</pub-id>
      </element-citation>
    </ref>
    <ref id="B3">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chaisson</surname>
            <given-names>M. J. P.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>De novo fragment assembly with short mate-paired reads: does the read length matter?</article-title>
        <source>Genome Res.</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>336</fpage>
        <lpage>346</lpage>
        <pub-id pub-id-type="pmid">19056694</pub-id>
      </element-citation>
    </ref>
    <ref id="B4">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Delcher</surname>
            <given-names>A.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Fast algorithms for large-scale genome alignment and comparision</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2002</year>
        <volume>30</volume>
        <fpage>2478</fpage>
        <lpage>2483</lpage>
        <pub-id pub-id-type="pmid">12034836</pub-id>
      </element-citation>
    </ref>
    <ref id="B5">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Drmanac</surname>
            <given-names>R.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Human genome sequencing using unchained base reads on self-assembling DNA nanoarrays</article-title>
        <source>Science</source>
        <year>2010</year>
        <volume>327</volume>
        <fpage>78</fpage>
        <lpage>81</lpage>
        <pub-id pub-id-type="pmid">19892942</pub-id>
      </element-citation>
    </ref>
    <ref id="B6">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Earl</surname>
            <given-names>D. A.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Assemblathon 1: a competitive assessment of de novo short-read assembly methods</article-title>
        <source>Genome Res.</source>
        <year>2011</year>
        <volume>21</volume>
        <fpage>2224</fpage>
        <lpage>2241</lpage>
        <pub-id pub-id-type="pmid">21926179</pub-id>
      </element-citation>
    </ref>
    <ref id="B7">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gnerre</surname>
            <given-names>S.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>High-quality draft assemblies of mammalian genomes from massively parallel sequence data</article-title>
        <source>Proc. Natl. Acad. Sci USA</source>
        <year>2011</year>
        <volume>108</volume>
        <fpage>1513</fpage>
        <lpage>1518</lpage>
        <pub-id pub-id-type="pmid">21187386</pub-id>
      </element-citation>
    </ref>
    <ref id="B8">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Harris</surname>
            <given-names>T. D.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Single-molecule DNA sequencing of a viral genome</article-title>
        <source>Science</source>
        <year>2008</year>
        <volume>320</volume>
        <fpage>106</fpage>
        <lpage>109</lpage>
        <pub-id pub-id-type="pmid">18388294</pub-id>
      </element-citation>
    </ref>
    <ref id="B9">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Iqbal</surname>
            <given-names>Z.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title><italic>De novo</italic> assembly and genotyping of variants using colored de Bruijn graphs</article-title>
        <source>Nature Genet.</source>
        <year>2012</year>
        <volume>44</volume>
        <fpage>226</fpage>
        <lpage>232</lpage>
        <pub-id pub-id-type="pmid">22231483</pub-id>
      </element-citation>
    </ref>
    <ref id="B10">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kellis</surname>
            <given-names>M.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Proof and evolutionary analysis of ancient genome duplication in the yeast <italic>Saccharomyces cerevisiae</italic></article-title>
        <source>Nature</source>
        <year>2004</year>
        <volume>428</volume>
        <fpage>617</fpage>
        <lpage>624</lpage>
        <pub-id pub-id-type="pmid">15004568</pub-id>
      </element-citation>
    </ref>
    <ref id="B11">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>R.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>De novo assembly of human genomes with massively parallel short-read sequencing</article-title>
        <source>Genome Res.</source>
        <year>2010</year>
        <volume>20</volume>
        <fpage>265</fpage>
        <lpage>272</lpage>
        <pub-id pub-id-type="pmid">20019144</pub-id>
      </element-citation>
    </ref>
    <ref id="B12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>MacCallum</surname>
            <given-names>I.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>ALLPATHS 2: small genomes assembled accurately and with high continuity from short paired reads</article-title>
        <source>Genome Biol.</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>R103</fpage>
        <pub-id pub-id-type="pmid">19796385</pub-id>
      </element-citation>
    </ref>
    <ref id="B13">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Margulies</surname>
            <given-names>M.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Genome sequencing in microfabricated high-density picolitre reactors</article-title>
        <source>Nature</source>
        <year>2005</year>
        <volume>437</volume>
        <fpage>376</fpage>
        <lpage>380</lpage>
        <pub-id pub-id-type="pmid">16056220</pub-id>
      </element-citation>
    </ref>
    <ref id="B14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>McEachern</surname>
            <given-names>M. J.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Telomeres and their control</article-title>
        <source>Annu. Rev. Genet.</source>
        <year>2000</year>
        <volume>34</volume>
        <fpage>331</fpage>
        <lpage>358</lpage>
        <pub-id pub-id-type="pmid">11092831</pub-id>
      </element-citation>
    </ref>
    <ref id="B15">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>McKernan</surname>
            <given-names>K. J.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Sequence and structural variation in a human genome uncovered by short-read, massively parallel ligation sequencing using two-base encoding</article-title>
        <source>Genome Res.</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>1527</fpage>
        <lpage>1541</lpage>
        <pub-id pub-id-type="pmid">19546169</pub-id>
      </element-citation>
    </ref>
    <ref id="B16">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Medvedev</surname>
            <given-names>P.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Paired de Bruijn graphs: a novel approach for incorporating mate pair information into genome assemblers</article-title>
        <source>Proceedings of Research in Computational Molecular Biology</source>
        <year>2011</year>
        <volume>Vol. 6577</volume>
        <fpage>238</fpage>
        <lpage>251</lpage>
        <comment>Lecture Notes in Computer Science</comment>
      </element-citation>
    </ref>
    <ref id="B17">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Myers</surname>
            <given-names>E.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A whole-genome assembly of <italic>Drosophila</italic></article-title>
        <source>Science</source>
        <year>2000</year>
        <volume>287</volume>
        <fpage>2196</fpage>
        <lpage>2204</lpage>
        <pub-id pub-id-type="pmid">10731133</pub-id>
      </element-citation>
    </ref>
    <ref id="B18">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Parrish</surname>
            <given-names>N.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Assembly of non-unique insertion content using next-generation sequencing</article-title>
        <source>BMC Bioinformatics</source>
        <year>2011</year>
        <volume>12</volume>
        <issue>Suppl. 6</issue>
        <fpage>S3</fpage>
        <pub-id pub-id-type="pmid">21989261</pub-id>
      </element-citation>
    </ref>
    <ref id="B19">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Peng</surname>
            <given-names>Z.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Generation of long insert pairs using a Cre-LoxP inverse PCR approach</article-title>
        <source>PLoS One</source>
        <year>2012</year>
        <volume>7</volume>
        <fpage>e29437</fpage>
        <pub-id pub-id-type="pmid">22253722</pub-id>
      </element-citation>
    </ref>
    <ref id="B20">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pevzner</surname>
            <given-names>P. A.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>An Eulerian path approach to DNA fragment assembly</article-title>
        <source>Proc. Natl. Acad. Sci USA</source>
        <year>2001</year>
        <volume>98</volume>
        <fpage>9748</fpage>
        <lpage>9753</lpage>
        <pub-id pub-id-type="pmid">11504945</pub-id>
      </element-citation>
    </ref>
    <ref id="B21">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rothberg</surname>
            <given-names>J.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>An integrated semiconductor device enabling non-optical genome sequencing</article-title>
        <source>Nature</source>
        <year>2011</year>
        <volume>475</volume>
        <fpage>348</fpage>
        <lpage>352</lpage>
        <pub-id pub-id-type="pmid">21776081</pub-id>
      </element-citation>
    </ref>
    <ref id="B22">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Salzberg</surname>
            <given-names>S.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>GAGE: a critical evaluation of genome assemblies and assembly algorithms</article-title>
        <source>Genome Res.</source>
        <year>2012</year>
        <volume>22</volume>
        <fpage>557</fpage>
        <lpage>567</lpage>
        <pub-id pub-id-type="pmid">22147368</pub-id>
      </element-citation>
    </ref>
    <ref id="B23">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Simpson</surname>
            <given-names>J. T.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>ABySS: a parallel assembler for short-read sequence data</article-title>
        <source>Genome Res.</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>1117</fpage>
        <lpage>1123</lpage>
        <pub-id pub-id-type="pmid">19251739</pub-id>
      </element-citation>
    </ref>
    <ref id="B24">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Simpson</surname>
            <given-names>J. T.</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <article-title>Efficient de novo assembly of large genomes using compressed data structures</article-title>
        <source>Genome Res.</source>
        <year>2012</year>
        <volume>3</volume>
        <fpage>549</fpage>
        <lpage>556</lpage>
        <pub-id pub-id-type="pmid">22156294</pub-id>
      </element-citation>
    </ref>
    <ref id="B25">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Van Nieuwerburgh</surname>
            <given-names>F.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Illumina mate-paired dna sequencing-library preparation using Cre-Lox recombination</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2012</year>
        <volume>40</volume>
        <fpage>e24</fpage>
        <pub-id pub-id-type="pmid">22127871</pub-id>
      </element-citation>
    </ref>
    <ref id="B26">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zerbino</surname>
            <given-names>D. R.</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E.</given-names>
          </name>
        </person-group>
        <article-title>Velvet: algorithms for de novo short-read assembly using de Bruijn graphs</article-title>
        <source>Genome Res.</source>
        <year>2008</year>
        <volume>18</volume>
        <fpage>821</fpage>
        <lpage>829</lpage>
        <pub-id pub-id-type="pmid">18349386</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
