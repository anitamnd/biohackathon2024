<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6612900</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btz376</article-id>
    <article-id pub-id-type="publisher-id">btz376</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Ismb/Eccb 2019 Conference Proceedings</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>General Computational Biology</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>TideHunter: efficient and sensitive tandem repeat detection from noisy long-reads using seed-and-chain</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Gao</surname>
          <given-names>Yan</given-names>
        </name>
        <xref ref-type="aff" rid="btz376-aff1">1</xref>
        <xref ref-type="aff" rid="btz376-aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Liu</surname>
          <given-names>Bo</given-names>
        </name>
        <xref ref-type="aff" rid="btz376-aff1">1</xref>
        <xref ref-type="corresp" rid="btz376-cor1"/>
        <!--<email>bo.liu@hit.edu.cn</email>-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Wang</surname>
          <given-names>Yadong</given-names>
        </name>
        <xref ref-type="aff" rid="btz376-aff1">1</xref>
        <xref ref-type="corresp" rid="btz376-cor1"/>
        <!--<email>ydwang@hit.edu.cn</email>-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Xing</surname>
          <given-names>Yi</given-names>
        </name>
        <xref ref-type="aff" rid="btz376-aff2">2</xref>
        <xref ref-type="aff" rid="btz376-aff3">3</xref>
        <xref ref-type="corresp" rid="btz376-cor1"/>
        <!--<email>XINGYI@email.chop.edu</email>-->
      </contrib>
    </contrib-group>
    <aff id="btz376-aff1"><label>1</label>Department of Computer Science and Technology, Center for Bioinformatics Harbin Institute of Technology, Harbin, Heilongjiang, China</aff>
    <aff id="btz376-aff2"><label>2</label>Center for Computational and Genomic Medicine, Children’s Hospital of Philadelphia, Philadelphia, PA, USA</aff>
    <aff id="btz376-aff3"><label>3</label>Department of Pathology and Laboratory Medicine, University of Pennsylvania, Philadelphia, PA, USA</aff>
    <author-notes>
      <corresp id="btz376-cor1">To whom correspondence should be addressed <email>bo.liu@hit.edu.cn</email> or <email>ydwang@hit.edu.cn</email> or <email>XINGYI@email.chop.edu</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2019-07-05">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>35</volume>
    <issue>14</issue>
    <fpage>i200</fpage>
    <lpage>i207</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2019. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2019</copyright-year>
      <license license-type="cc-by-nc" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btz376.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Pacific Biosciences (PacBio) and Oxford Nanopore Technologies (ONT) sequencing technologies can produce long-reads up to tens of kilobases, but with high error rates. In order to reduce sequencing error, Rolling Circle Amplification (RCA) has been used to improve library preparation by amplifying circularized template molecules. Linear products of the RCA contain multiple tandem copies of the template molecule. By integrating additional <italic>in silico</italic> processing steps, these tandem sequences can be collapsed into a consensus sequence with a higher accuracy than the original raw reads. Existing pipelines using alignment-based methods to discover the tandem repeat patterns from the long-reads are either inefficient or lack sensitivity.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We present a novel tandem repeat detection and consensus calling tool, TideHunter, to efficiently discover tandem repeat patterns and generate high-quality consensus sequences from amplified tandemly repeated long-read sequencing data. TideHunter works with noisy long-reads (PacBio and ONT) at error rates of up to 20% and does not have any limitation of the maximal repeat pattern size. We benchmarked TideHunter using simulated and real datasets with varying error rates and repeat pattern sizes. TideHunter is tens of times faster than state-of-the-art methods and has a higher sensitivity and accuracy.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>TideHunter is written in C, it is open source and is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/yangao07/TideHunter">https://github.com/yangao07/TideHunter</ext-link></p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">National Key Research and Development Program of China</named-content>
          <named-content content-type="funder-identifier">10.13039/501100012166</named-content>
        </funding-source>
        <award-id>2018YFC0910504</award-id>
        <award-id>2017YFC0907503</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>While Pacific Biosciences (PacBio) and Oxford Nanopore Technologies (ONT) long-read sequencing technologies are capable of providing improved reference genomes, comprehensive structural variant identification, as well as a more complete view of transcriptomes, the relatively high error rates prevent their widespread adoption (<xref rid="btz376-B8" ref-type="bibr">Goodwin <italic>et al.</italic>, 2016</xref>).</p>
    <p>Several error correction methods have been developed to reduce the sequencing error in the long-reads. Such approaches can be classified into two types: hybrid correction using short-reads (<xref rid="btz376-B10" ref-type="bibr">Koren <italic>et al.</italic>, 2012</xref>; <xref rid="btz376-B26" ref-type="bibr">Zimin <italic>et al.</italic>, 2013</xref>; <xref rid="btz376-B20" ref-type="bibr">Salmela and Rivals, 2014</xref>; <xref rid="btz376-B7" ref-type="bibr">Goodwin <italic>et al.</italic>, 2015</xref>) and self or non-hybrid correction using only long-reads (<xref rid="btz376-B4" ref-type="bibr">Chin <italic>et al.</italic>, 2013</xref>, <xref rid="btz376-B5" ref-type="bibr">2016</xref>; <xref rid="btz376-B21" ref-type="bibr">Salmela <italic>et al.</italic>, 2017</xref>). Despite these methods providing better base-pair accuracy than the raw data, each method has drawbacks. Hybrid correction approaches could introduce systematic errors from the short-reads into the long-reads while the performance of non-hybrid correction relies heavily on the sequencing depth.</p>
    <p>PacBio platforms generate high-accuracy circular consensus (CCS) reads from raw subreads through <italic>in silico</italic> processing (<xref rid="btz376-B25" ref-type="bibr">Weirather <italic>et al.</italic>, 2017</xref>), with an error rate as low as 1%. However, the yield of CCS reads is much lower than subreads. ONT uses a similar strategy to call a relatively accurate consensus sequence, i.e. 2D or 1D<sup>2</sup> reads, from the template and complement of 1D reads, but at the cost of lower throughput (<xref rid="btz376-B6" ref-type="bibr">de Lannoy <italic>et al.</italic>, 2017</xref>).</p>
    <p>In recent studies (<xref rid="btz376-B13" ref-type="bibr">Li <italic>et al.</italic>, 2016</xref>; <xref rid="btz376-B24" ref-type="bibr">Volden <italic>et al.</italic>, 2018</xref>; <xref rid="btz376-B3" ref-type="bibr">Calus <italic>et al.</italic>, 2018</xref>), Rolling Circle Amplification (RCA) was used to amplify circularized template molecules in order to generate linear products containing multiple tandem copies of the templates. After long-read sequencing with PacBio or ONT, the resulting sequences can be used to generate accurate consensus sequences through additional computational processing steps, which can be considered as high-quality reconstructed reads of the templates.</p>
    <p>Along with the RCA workflow, computational pipelines for amplified tandemly repeated sequences have been developed. INC-seq (<xref rid="btz376-B13" ref-type="bibr">Li <italic>et al.</italic>, 2016</xref>) extracts subsequences from the raw long-reads using non-overlapping sliding windows. These subsequences serve as <italic>anchors</italic> which are then aligned back to the read. Anchors with the higher number of alignments are used to partition the reads into multiple segments, which are then used to construct a consensus sequence with pbdagcon (<xref rid="btz376-B4" ref-type="bibr">Chin <italic>et al.</italic>, 2013</xref>). C3POa (<xref rid="btz376-B24" ref-type="bibr">Volden <italic>et al.</italic>, 2018</xref>) uses a similar alignment-based strategy. Instead of extracting subsequences, C3POa uses a known splint sequence to determine a start point, then performs a self-to-self alignment to discover the tandem repeat signal embedded in the raw reads. For INC-seq, the choice of anchor length is non-trivial and has a significant impact on the result. For C3POa, self-to-self alignment may confuse the determination of repeat sizes, especially on data with a high error rate. Moreover, as exhaustive alignment-based methods, both methods are time consuming.</p>
    <p>Tandem repeat detection in DNA sequences is a classical bioinformatics problem that motivated the development of numerous tools over the past 20 years (<xref rid="btz376-B16" ref-type="bibr">Lim <italic>et al.</italic>, 2013</xref>). However, most of these tools are not suitable for processing RCA-based long-read data, as they only focus on short tandem repeats whose period size is generally less than 100 bp. Tandem Repeats Finder (TRF) (<xref rid="btz376-B1" ref-type="bibr">Benson <italic>et al.</italic>, 1999</xref>) is one of the most widely used and robust tandem repeat detection tools. It calculates the possible repeat pattern size by short <italic>k</italic>-mer matches at adjacent locations on the sequence and uses statistically based recognition criteria to find candidate tandem repeats. TRF allows for the detection of imperfect repeats, which makes it suitable for noisy long-read data. The most significant issue for TRF is that it limits the maximal period size as 2000 bp. For whole genome or transcriptome studies, the length of the template molecule could easily exceed this limitation. With the increasing use of long-read sequencing technologies, we expect the new RCA-based protocol to be widely adopted. Thus, it is crucial to develop an efficient and sensitive tandem repeat detection and consensus calling tool to take full advantage of this type of data.</p>
    <p>In this article, we present a novel tandem repeat detection and consensus calling tool, TideHunter, which is specifically designed for RCA-based long-read data. TideHunter uses a fast seed-and-chain algorithm to efficiently recognize the underlying repeat pattern size, and then partition the original long-read into multiple repeat units. High-quality consensus sequences are generated using a Single Instruction Multiple Data (SIMD) accelerated Partial Order Alignment (POA) (<xref rid="btz376-B12" ref-type="bibr">Lee <italic>et al.</italic>, 2002</xref>) on the partitioned segments. TideHunter does not have any limitation of the maximal repeat pattern size and is able to tolerate high error rates. We benchmarked TideHunter using simulated and real datasets with varying error rates and repeat pattern lengths. TideHunter is tens of times faster than state-of-the-art methods and has a higher sensitivity and accuracy.</p>
  </sec>
  <sec>
    <title>2 Materials and Methods</title>
    <sec>
      <title>2.1 Overview</title>
      <p>The reconstruction of template sequences from RCA-based long-reads has two main steps: tandem repeat detection and consensus calling. During the tandem repeat detection, both the repeat unit length and the copy number need to be determined in an <italic>ab initio</italic> manner. Furthermore, all the tandem copies could be divergent from each other due to the high error rate of long-reads, making it more difficult to discover the repeat signal. After tandem repeat detection, every detected repeat unit is expected to represent one copy of the template sequence. Consensus calling can be accomplished based on the multiple sequence alignment of all detected repeat units. The generated consensus sequence is considered a reconstructed template sequence with a lower error rate than the original long-read. Moreover, for some specific sequencing libraries, additional adapter information is available and can be utilized to convert the consensus to a full-length template sequence (<xref rid="btz376-B24" ref-type="bibr">Volden <italic>et al.</italic>, 2018</xref>).</p>
      <p>TideHunter is inspired by several existing tandem repeat detection tools (<xref rid="btz376-B1" ref-type="bibr">Benson <italic>et al.</italic>, 1999</xref>; <xref rid="btz376-B19" ref-type="bibr">Pellegrini <italic>et al.</italic>, 2010</xref>) and noisy long-read alignment approaches (<xref rid="btz376-B17" ref-type="bibr">Liu <italic>et al.</italic>, 2017</xref>; <xref rid="btz376-B15" ref-type="bibr">Li, 2018</xref>). It adopts a specifically designed seed-and-chain algorithm to efficiently recognize the underlying repeat pattern size and implements a SIMD accelerated POA to generate high-quality consensus sequences. TideHunter collects <italic>seeds</italic> of long-reads which consist of hash values and locations of short substrings (<italic>k</italic>-mers). Collected seeds are sorted by both the hash value and the location, then stored in a linear table. <italic>Tandem repeat hit</italic> is identified for each pair of seeds that have identical hash values and are adjacent to each other in the sorted table. The <italic>hit distance</italic>, i.e. the location distance of two seeds having a tandem repeat hit, is usually close to the true repeat pattern size or its multiples. TideHunter considers all such hits as <italic>anchors</italic> and attempts to find an optimal chain of colinear anchors using dynamic programming. The optimal chain is expected to consist of anchors that have a hit distance close to the repeat pattern size. TideHunter partitions the original long-read into multiple segments based on the optimal chain. A SIMD accelerated POA of these segments is then applied to generate an accurate consensus sequence.</p>
    </sec>
    <sec>
      <title>2.2 Collecting seeds</title>
      <p>TideHunter takes a two-tuple (<italic>v</italic>, <italic>c</italic>) as a seed to represent every <italic>k</italic>-mer of a read, where <italic>v</italic> is the hash value and <italic>c</italic> is the coordinate of the last base for each <italic>k</italic>-mer. Seeds are collected based on two parameters: <italic>k</italic> and <italic>s</italic>, where <italic>k</italic> is the <italic>k</italic>-mer length and <italic>s</italic> is the collecting step size. By default, we have <italic>k </italic> = <italic> </italic>8 and <italic>s </italic> = <italic> </italic>1, meaning we exhaustively collect all the short substrings of 8 bp from the read. A hash value is assigned to each <italic>k</italic>-mer with a simple hash function:
<disp-formula id="E1"><mml:math id="M1"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:mo>⋯</mml:mo><mml:mo>+</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula>
where <inline-formula id="IE1"><mml:math id="IM1"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula>. This hash function enables TideHunter to avoid collision as distinct <italic>k</italic>-mers always have different hash values. After collecting all the seeds, TideHunter sorts them by both the hash value and the coordinate using radix sorting. Sorted seeds are then stored in a linear table for further use.</p>
    </sec>
    <sec>
      <title>2.3 Identifying tandem repeat anchors</title>
      <p>A tandem repeat hit is a match of two identical <italic>k</italic>-mers which are adjacent to each other in the seeds linear table. In general, <italic>n</italic> identical <italic>k</italic>-mers will result in <italic>n</italic> − 1 tandem repeat hits.</p>
      <p>TideHunter takes another set of two-tuples (<italic>e</italic>, <italic>d</italic>) as anchors to represent all the tandem repeat hits, where <italic>e</italic> is the ending position, which is the coordinate of the last base in the following <italic>k</italic>-mer; and <italic>d</italic> is the hit distance, which is the coordinate distance between the two identical <italic>k</italic>-mers. All the tandem repeat anchors are sorted by the ending position <italic>e</italic> using radix sorting again.</p>
      <p>It is worth noting that only tandem repeat hits within a specific range of hit distance (default: 30–100 000) will be collected by TideHunter. Specifically, for each seed TideHunter attempts to find its first valid hit in a loop starting with the nearest identical <italic>k</italic>-mer. By doing this, TideHunter avoids meaningless hits which are unlikely to have a distance close to the true repeat pattern size.</p>
    </sec>
    <sec>
      <title>2.4 Chaining of tandem repeat anchors</title>
      <sec>
        <title>2.4.1 Chaining</title>
        <p>Among all tandem repeat anchors with different hit distances, TideHunter attempts to find an optimal chain of anchors all having a hit distance close to the true repeat pattern size (<xref ref-type="fig" rid="btz376-F1">Fig. 1</xref>).
</p>
        <fig id="btz376-F1" orientation="portrait" position="float">
          <label>Fig. 1.</label>
          <caption>
            <p>Chaining of tandem repeat anchors. Three arrows represent three copies of a template sequence. Vertical line represents seed for each <italic>k</italic>-mer. The same height between seeds indicates identical <italic>k</italic>-mers. Horizontal line represents tandem repeat hit of identical <italic>k</italic>-mers. Solid and dashed lines indicate their hit distances are likely and unlikely, respectively, to be the true repeat pattern size. After the dynamic programming, the optimal chain is expected to consist of anchors that have hit distances close to the repeat pattern size</p>
          </caption>
          <graphic xlink:href="btz376f1"/>
        </fig>
        <p>Given a list of anchors sorted by the hit ending position, TideHunter identifies the optimal chain by performing dynamic programming with a specifically designed scoring function.</p>
        <p>Here, we use <italic>S</italic>(<italic>i</italic>) to denote the maximal chaining score up to the <italic>i</italic>th anchor in the list. The recurrence equation of the scoring function is:
<disp-formula id="E2"><mml:math id="M2"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>{</mml:mo><mml:munder><mml:mrow><mml:mi>max</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>&gt;</mml:mo><mml:mi>j</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:munder><mml:mo>{</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>}</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></disp-formula>
where <inline-formula id="IE2"><mml:math id="IM2"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>}</mml:mo><mml:mo>+</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> is the number of additional matching bases when anchor <italic>i</italic> and <italic>j</italic> are chained together. Here, <inline-formula id="IE3"><mml:math id="IM3"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. <inline-formula id="IE4"><mml:math id="IM4"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the chaining cost for any two anchors:
<disp-formula id="E3"><mml:math id="M3"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mn>2</mml:mn></mml:mfrac><mml:mo>×</mml:mo><mml:mi>Δ</mml:mi><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mn>2</mml:mn></mml:mfrac><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mtext>log</mml:mtext></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>Δ</mml:mi><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>Δ</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>if </mml:mtext><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>&gt;</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mo>+</mml:mo><mml:mi>∞</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>if </mml:mtext><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
here, <inline-formula id="IE5"><mml:math id="IM5"><mml:mrow><mml:mo>Δ</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>Δ</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>Δ</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Moreover, an initial score, i.e. the number of bases in the <italic>k</italic>-mers: <inline-formula id="IE6"><mml:math id="IM6"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, is directly assigned to the anchor that does not have any precursors. By assigning positive infinity to the chaining cost, TideHunter avoids chaining any two non-collinear anchors, i.e. <inline-formula id="IE7"><mml:math id="IM7"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <italic>e<sub>i</sub></italic> &gt; <italic>e<sub>j</sub></italic>. The optimal precursor of each anchor is chosen based on the maximal chaining score during the calculation of chaining scores.</p>
        <p>The cost function consists of two parts: the square of two anchors’ hit distance difference and the logarithm of the distance between two anchors’ endpoints. By using this cost function, TideHunter tends to chain together two anchors that have a similar hit distance and are close to each other as their chaining cost is low (<xref ref-type="fig" rid="btz376-F1">Fig. 1</xref>). As such, all the anchors coming from any two consecutive copies in the long-read are likely to be chained together to form the optimal chain. The quadratic and logarithmic functions are chosen to make sure the hit distance difference weighs more than the anchor distance during the precursor determination. Theoretically, other functions could also be applied. However, on our simulated and real datasets, the quadratic and logarithmic functions achieve the best performance in practice.</p>
      </sec>
      <sec>
        <title>2.4.2 Backtracking</title>
        <p>To obtain an optimal chain, TideHunter starts with the anchor having the maximal chaining score, and then recursively performs backtracking to find the best precursor for each anchor. The best precursor is determined based on the chaining score during the dynamic programming. All tandem repeat anchors in the optimal chain are expected to have a hit distance that is close to the true repeat pattern size.</p>
        <p>In most cases, the optimal chain will cover almost the whole read. However, as long-read sequencing may go through abnormal molecular ligation and template switching (<xref rid="btz376-B13" ref-type="bibr">Li <italic>et al.</italic>, 2016</xref>), chimeric tandem repeats can potentially exist. To solve this issue, TideHunter performs additional backtracking beginning with the remaining maximal score anchor, which has not been included in any existing chains. The backtracking stops whenever the precursor has already been tracked to ensure every anchor only shows up in one chain.</p>
        <p>For a set of obtained chains, TideHunter discards a chain when it overlaps with any other higher score chains by at least 50%. Thus, TideHunter is able to collect a set of local optimal chains for all the chimeric regions of the read.</p>
      </sec>
    </sec>
    <sec>
      <title>2.5 Partitioning read</title>
      <sec>
        <title>2.5.1 Selecting a medoid anchor</title>
        <p>Given a chain of tandem repeat anchors, <inline-formula id="IE8"><mml:math id="IM8"><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1…</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, TideHunter selects a medoid anchor <italic>M</italic> by calculating the summation of the distance between one anchor and all other anchors. Here, the anchor distance is defined as:
<disp-formula id="E4"><mml:math id="M4"><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></disp-formula></p>
        <p>The medoid anchor is selected by:
<disp-formula id="E5"><mml:math id="M5"><mml:mrow><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mtext>arg</mml:mtext><mml:mo> </mml:mo><mml:mtext>min</mml:mtext></mml:mrow><mml:mi>i</mml:mi></mml:munder><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></disp-formula>
If multiple optimal medoids exist, TideHunter arbitrarily chooses the anchor with the smallest coordinate.</p>
      </sec>
      <sec>
        <title>2.5.2 Determining repeat unit boundary</title>
        <p>TideHunter uses the selected medoid anchor as a starting point to repeatedly determine the boundaries for all repeat units. <xref ref-type="fig" rid="btz376-F2">Figure 2</xref> provides an example of searching for the next repeat unit boundary on the right side.
</p>
        <fig id="btz376-F2" orientation="portrait" position="float">
          <label>Fig. 2.</label>
          <caption>
            <p>Searching for repeat unit boundary based on the global alignment. <italic>s</italic> and <italic>e</italic> are the current repeat boundaries. Two anchors <inline-formula id="IE9"><mml:math id="IM9"><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE10"><mml:math id="IM10"><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are selected as their starting positions are the closest to <italic>e</italic>. Two subsequences starting from <italic>s</italic><sub>1</sub> to <italic>s</italic><sub>2</sub> and from <italic>e</italic><sub>1</sub> to <italic>e</italic><sub>2</sub> are extracted to perform an end-to-end global alignment. The next repeat unit boundary <inline-formula id="IE11"><mml:math id="IM11"><mml:mrow><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> can be calculated based on the alignment result. In this example, the base <italic>G</italic> of <italic>e</italic> is matched with the <italic>G</italic> in subsequence <inline-formula id="IE12"><mml:math id="IM12"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, whose coordinate is then considered as the putative next boundary <inline-formula id="IE13"><mml:math id="IM13"><mml:mrow><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula></p>
          </caption>
          <graphic xlink:href="btz376f2"/>
        </fig>
        <p>For each tandem repeat anchor, let the starting position <italic>s</italic> and ending position <italic>e</italic> be the two coordinates of the last base in two <italic>k</italic>-mers (<xref ref-type="fig" rid="btz376-F2">Fig. 2</xref>). Given a pair of current repeat unit boundaries <italic>s</italic> and <italic>e</italic>, TideHunter first searches for two anchors <inline-formula id="IE14"><mml:math id="IM14"><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE15"><mml:math id="IM15"><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> around <italic>e</italic>, where <italic>s</italic><sub>1</sub> and <italic>s</italic><sub>2</sub> are the closest to <italic>e</italic> and <inline-formula id="IE16"><mml:math id="IM16"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>&lt;</mml:mo><mml:mi>e</mml:mi><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. Specifically, when <italic>s</italic><sub>2</sub> is equal to <italic>e</italic>, the next repeat unit boundary is directly set to <italic>e</italic><sub>2</sub>. In most cases, where <inline-formula id="IE17"><mml:math id="IM17"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>&lt;</mml:mo><mml:mi>e</mml:mi><mml:mo>&lt;</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, TideHunter performs an end-to-end global sequence alignment between the two subsequences of the read, <inline-formula id="IE18"><mml:math id="IM18"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE19"><mml:math id="IM19"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. Based on the alignment result, the putative next boundary <inline-formula id="IE20"><mml:math id="IM20"><mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> within <italic>e</italic><sub>1</sub> and <italic>e</italic><sub>2</sub> can be calculated. In more detail, we first locate the corresponding base of <italic>e</italic> in the subsequence <inline-formula id="IE21"><mml:math id="IM21"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. Then, based on the global sequence alignment of <inline-formula id="IE22"><mml:math id="IM22"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE23"><mml:math id="IM23"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, the matched base of <italic>e</italic> in <inline-formula id="IE24"><mml:math id="IM24"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> can be derived using the alignment CIGAR. We further calculate the coordinate of the matched base and consider it as the putative next boundary <inline-formula id="IE25"><mml:math id="IM25"><mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> (<xref ref-type="fig" rid="btz376-F2">Fig. 2</xref>).</p>
        <p>As such, TideHunter collects a set of repeat unit boundaries, then uses them to partition the original long-read into multiple segments.</p>
        <p>To avoid extending the tandem repeat to a very high error rate or chimeric region, TideHunter stops searching for the boundaries when the ratio of identical nucleotides based on the global alignment is lower than a threshold of 0.75 by default.</p>
      </sec>
    </sec>
    <sec>
      <title>2.6 Generating consensus sequence</title>
      <p>TideHunter performs a POA (<xref rid="btz376-B12" ref-type="bibr">Lee <italic>et al.</italic>, 2002</xref>) on the partitioned multiple segments and calls the consensus sequence using the heaviest-bundling algorithm described in <xref rid="btz376-B11" ref-type="bibr">Lee (2003)</xref>. The POA is accelerated by using a SIMD implementation (<xref rid="btz376-B23" ref-type="bibr">Vaser <italic>et al.</italic>, 2017</xref>).</p>
      <p>In more detail, POA performs multiple sequence alignment by iteratively aligning a query sequence to a target directed acyclic graph (DAG) and adding the query to the DAG based on the alignment result (<xref rid="btz376-B12" ref-type="bibr">Lee <italic>et al.</italic>, 2002</xref>). For the DAG, the node represents individual sequence base and the edge represents two consecutive bases in the sequence (<xref ref-type="fig" rid="btz376-F3">Fig. 3</xref>). Same as the traditional sequence-to-sequence alignment, a dynamic programming matrix needs to be filled out for the sequence-to-graph alignment, where each row represents one node of the DAG and each column represents one base of the query. To fill out the matrix, three operations need to be considered for each cell of the matrix: match (diagonal), deletion (vertical) and insertion (horizontal) (<xref ref-type="fig" rid="btz376-F3">Fig. 3</xref>). The first two operations, match and deletion, only rely on the information of cells in the previous rows, thus multiple cells can be processed simultaneously by using a SIMD vector. However, parallelization cannot be accomplished for the insertion operation as it depends on the left cell, which is in the same row. Thus, with the SIMD parallelization, the overall time complexity is decreased from <inline-formula id="IE26"><mml:math id="IM26"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mi>n</mml:mi><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to roughly <inline-formula id="IE27"><mml:math id="IM27"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub><mml:mo>/</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mi>n</mml:mi><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>n<sub>p</sub></italic> is the average number of precursors, <inline-formula id="IE28"><mml:math id="IM28"><mml:mrow><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> is the number of nodes in the DAG, <italic>n</italic> is the length of the query sequence and <italic>k</italic> is the number of variables that fit in a SIMD vector, which is generally 16 or 8.
</p>
      <fig id="btz376-F3" orientation="portrait" position="float">
        <label>Fig. 3.</label>
        <caption>
          <p>Dynamic programming matrix of sequence-to-graph alignment and three types of operations. SIMD parallelization is applicable for the match and deletion operations as they only rely on the previous rows. Insertion operation must be processed linearly as it depends on the left cell, which is in the same row</p>
        </caption>
        <graphic xlink:href="btz376f3"/>
      </fig>
      <p>After the iterative sequence-to-graph alignment, the final DAG is used to generate a consensus sequence with the heaviest-bundling algorithm (<xref rid="btz376-B11" ref-type="bibr">Lee, 2003</xref>). Then, TideHunter takes the consensus sequence as the query to perform an extension alignment on each side of the repeat region in order to incorporate the non-full copies of the repeat into the final result.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Result</title>
    <p>TideHunter is implemented in the C programming language. It takes long-read sequencing data as input and outputs consensus sequences of tandem repeats in FASTA format by default. TideHunter supports multi-threading to achieve faster running speed on multi-core computers.</p>
    <p>To demonstrate the efficiency and sensitivity of TideHunter, we evaluated it on both simulated and real datasets, along with TRF (version 4.09), INC-seq (git commit #0ab4ac81) and C3POa (git commit #fe370036).</p>
    <p>As INC-seq and C3POa only output one consensus sequence for each read, to ensure the consistency of the evaluation, we only retained the repeat covering the longest read sequence for TideHunter and TRF when multiple repeats were found.</p>
    <sec>
      <title>3.1 Simulation study</title>
      <p>To simulate tandemly repeated reads, we first randomly extracted a sequence from GRCh37 human reference genome and directly copy the sequence multiple times. A 100 bp random flanking sequence was appended to each side. We then used PBSIM (<xref rid="btz376-B18" ref-type="bibr">Ono <italic>et al.</italic>, 2013</xref>) to generate a simulated read from the tandemly repeated sequence. In total, five error rates with different substitution: insertion: deletion ratios (13%, 41:23:36, 15%-a, 37:42:21, 15%-b, 11:60:29, 16%, 28:24:48 and 20%, 48:15:37), five repeat pattern sizes (100, 500, 1000, 2000 and 3000) and five copy numbers (2, 3, 5, 10 and 20) were used to generate 15 simulated datasets (<xref rid="btz376-T1" ref-type="table">Tables 1–3</xref>). The five error rates and error distributions come from five public real datasets (PacBio: 15%-a, 15%-b and ONT: 13%, 16%, 20%) (<xref rid="btz376-B25" ref-type="bibr">Weirather <italic>et al.</italic>, 2017</xref>; <xref rid="btz376-B9" ref-type="bibr">Harris <italic>et al.</italic>, 2018</xref>). For each simulated dataset, 1000 reads were generated.</p>
      <table-wrap id="btz376-T1" orientation="portrait" position="float">
        <label>Table 1.</label>
        <caption>
          <p>Performance on datasets with five error rates and distributions (1000 reads for each error rate and distribution, repeat pattern size is 1000 bp, copy number is 10)</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Error rate (sub.:ins.:del.)</th>
              <th align="left" rowspan="1" colspan="1">Tool</th>
              <th align="left" rowspan="1" colspan="1">Accuracy (%)</th>
              <th align="left" rowspan="1" colspan="1">Ave. copy number</th>
              <th align="left" rowspan="1" colspan="1">Ave. identical base</th>
              <th align="left" rowspan="1" colspan="1">Run time (CPU min)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">TideHunter</td>
              <td rowspan="1" colspan="1">
                <bold>99.9</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>9.6</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>983.1</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.8</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="3" colspan="1">13% (41:23:36)</td>
              <td rowspan="1" colspan="1">INC-seq</td>
              <td rowspan="1" colspan="1">99.7</td>
              <td rowspan="1" colspan="1">8.7</td>
              <td rowspan="1" colspan="1">969.6</td>
              <td rowspan="1" colspan="1">95.7</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TRF</td>
              <td rowspan="1" colspan="1">71.4</td>
              <td rowspan="1" colspan="1">9.6</td>
              <td rowspan="1" colspan="1">960.6</td>
              <td rowspan="1" colspan="1">3.7</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TideHunter</td>
              <td rowspan="1" colspan="1">
                <bold>100.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>9.5</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>988.2</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.8</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="3" colspan="1">15%-a (37:42:21)</td>
              <td rowspan="1" colspan="1">INC-seq</td>
              <td rowspan="1" colspan="1">99.9</td>
              <td rowspan="1" colspan="1">7.9</td>
              <td rowspan="1" colspan="1">975.2</td>
              <td rowspan="1" colspan="1">96.3</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TRF</td>
              <td rowspan="1" colspan="1">58.1</td>
              <td rowspan="1" colspan="1">7.4</td>
              <td rowspan="1" colspan="1">925.9</td>
              <td rowspan="1" colspan="1">3.5</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TideHunter</td>
              <td rowspan="1" colspan="1">
                <bold>99.9</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>9.2</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>988.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.9</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="3" colspan="1">15%-b (11:60:29)</td>
              <td rowspan="1" colspan="1">INC-seq</td>
              <td rowspan="1" colspan="1">96.4</td>
              <td rowspan="1" colspan="1">5.1</td>
              <td rowspan="1" colspan="1">958.0</td>
              <td rowspan="1" colspan="1">85.0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TRF</td>
              <td rowspan="1" colspan="1">88.8</td>
              <td rowspan="1" colspan="1">9.1</td>
              <td rowspan="1" colspan="1">970.1</td>
              <td rowspan="1" colspan="1">2.7</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TideHunter</td>
              <td rowspan="1" colspan="1">
                <bold>99.9</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>9.6</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>963.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.8</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="3" colspan="1">16% (28:24:48)</td>
              <td rowspan="1" colspan="1">INC-seq</td>
              <td rowspan="1" colspan="1">83.5</td>
              <td rowspan="1" colspan="1">4.0</td>
              <td rowspan="1" colspan="1">887.0</td>
              <td rowspan="1" colspan="1">72.0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TRF</td>
              <td rowspan="1" colspan="1">39.2</td>
              <td rowspan="1" colspan="1">6.2</td>
              <td rowspan="1" colspan="1">886.0</td>
              <td rowspan="1" colspan="1">3.7</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TideHunter</td>
              <td rowspan="1" colspan="1">
                <bold>99.8</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>7.6</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>965.8</bold>
              </td>
              <td rowspan="1" colspan="1">0.9</td>
            </tr>
            <tr>
              <td rowspan="2" colspan="1">20% (48:15:37)</td>
              <td rowspan="1" colspan="1">INC-seq</td>
              <td rowspan="1" colspan="1">99.1</td>
              <td rowspan="1" colspan="1">5.8</td>
              <td rowspan="1" colspan="1">939.0</td>
              <td rowspan="1" colspan="1">92.2</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TRF</td>
              <td rowspan="1" colspan="1">0.0</td>
              <td rowspan="1" colspan="1">0.0</td>
              <td rowspan="1" colspan="1">0.0</td>
              <td rowspan="1" colspan="1">
                <bold>0.5</bold>
              </td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tf1">
            <p><italic>Note</italic>: The best performance regarding each specific feature on each dataset.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap id="btz376-T2" orientation="portrait" position="float">
        <label>Table 2.</label>
        <caption>
          <p>Performance on datasets with five repeat pattern sizes (1000 reads for each repeat pattern size, error rate is 15%, error distribution is 37:42:21, copy number is 10)</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Repeat pattern size</th>
              <th align="left" rowspan="1" colspan="1">Tool</th>
              <th align="left" rowspan="1" colspan="1">Accuracy (%)</th>
              <th align="left" rowspan="1" colspan="1">Ave. copy number</th>
              <th align="left" rowspan="1" colspan="1">Ave. identical base</th>
              <th align="left" rowspan="1" colspan="1">Run time (CPU min)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">TideHunter</td>
              <td rowspan="1" colspan="1">
                <bold>73.4</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>9.5</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>95.9</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.03</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="3" colspan="1">100 bp</td>
              <td rowspan="1" colspan="1">INC-seq</td>
              <td rowspan="1" colspan="1">37.7</td>
              <td rowspan="1" colspan="1">2.6</td>
              <td rowspan="1" colspan="1">36.5</td>
              <td rowspan="1" colspan="1">12.3</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TRF</td>
              <td rowspan="1" colspan="1">70.2</td>
              <td rowspan="1" colspan="1">8.4</td>
              <td rowspan="1" colspan="1">67.3</td>
              <td rowspan="1" colspan="1">0.2</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TideHunter</td>
              <td rowspan="1" colspan="1">
                <bold>100.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>9.5</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>494.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.3</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="3" colspan="1">500 bp</td>
              <td rowspan="1" colspan="1">INC-seq</td>
              <td rowspan="1" colspan="1">87.4</td>
              <td rowspan="1" colspan="1">4.2</td>
              <td rowspan="1" colspan="1">453.8</td>
              <td rowspan="1" colspan="1">50.8</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TRF</td>
              <td rowspan="1" colspan="1">71.9</td>
              <td rowspan="1" colspan="1">7.6</td>
              <td rowspan="1" colspan="1">463.0</td>
              <td rowspan="1" colspan="1">1.8</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TideHunter</td>
              <td rowspan="1" colspan="1">
                <bold>100.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>9.5</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>988.5</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.9</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="3" colspan="1">1000 bp</td>
              <td rowspan="1" colspan="1">INC-seq</td>
              <td rowspan="1" colspan="1">100.0</td>
              <td rowspan="1" colspan="1">7.9</td>
              <td rowspan="1" colspan="1">974.0</td>
              <td rowspan="1" colspan="1">96.4</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TRF</td>
              <td rowspan="1" colspan="1">61.5</td>
              <td rowspan="1" colspan="1">7.4</td>
              <td rowspan="1" colspan="1">928.7</td>
              <td rowspan="1" colspan="1">3.2</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TideHunter</td>
              <td rowspan="1" colspan="1">
                <bold>100.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>9.4</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>1976.6</bold>
              </td>
              <td rowspan="1" colspan="1">4.3</td>
            </tr>
            <tr>
              <td rowspan="3" colspan="1">2000 bp</td>
              <td rowspan="1" colspan="1">INC-seq</td>
              <td rowspan="1" colspan="1">99.8</td>
              <td rowspan="1" colspan="1">9.0</td>
              <td rowspan="1" colspan="1">1955.5</td>
              <td rowspan="1" colspan="1">163.4</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TRF</td>
              <td rowspan="1" colspan="1">30.0</td>
              <td rowspan="1" colspan="1">5.4</td>
              <td rowspan="1" colspan="1">1819.0</td>
              <td rowspan="1" colspan="1">
                <bold>1.5</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TideHunter</td>
              <td rowspan="1" colspan="1">
                <bold>100.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>9.4</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>2965.1</bold>
              </td>
              <td rowspan="1" colspan="1">11.6</td>
            </tr>
            <tr>
              <td rowspan="2" colspan="1">3000 bp</td>
              <td rowspan="1" colspan="1">INC-seq</td>
              <td rowspan="1" colspan="1">98.8</td>
              <td rowspan="1" colspan="1">9.0</td>
              <td rowspan="1" colspan="1">2934.2</td>
              <td rowspan="1" colspan="1">300.4</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TRF</td>
              <td rowspan="1" colspan="1">0.0</td>
              <td rowspan="1" colspan="1">0.0</td>
              <td rowspan="1" colspan="1">0.0</td>
              <td rowspan="1" colspan="1">
                <bold>0.8</bold>
              </td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tf2">
            <p><italic>Note</italic>: The best performance regarding each specific feature on each dataset.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap id="btz376-T3" orientation="portrait" position="float">
        <label>Table 3.</label>
        <caption>
          <p>Performance on datasets with five repeat copy numbers (1000 reads for each copy number, error rate is 15%, error distribution is 37:42:21, repeat pattern size is 1000 bp)</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Copy number</th>
              <th align="left" rowspan="1" colspan="1">Tool</th>
              <th align="left" rowspan="1" colspan="1">Accuracy (%)</th>
              <th align="left" rowspan="1" colspan="1">Ave. copy number</th>
              <th align="left" rowspan="1" colspan="1">Ave. identical base</th>
              <th align="left" rowspan="1" colspan="1">Run time (CPU min)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">TideHunter</td>
              <td rowspan="1" colspan="1">
                <bold>0.2</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>2.0</bold>
              </td>
              <td rowspan="1" colspan="1">814.5</td>
              <td rowspan="1" colspan="1">
                <bold>0.02</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="3" colspan="1">2</td>
              <td rowspan="1" colspan="1">INC-seq</td>
              <td rowspan="1" colspan="1">0.0</td>
              <td rowspan="1" colspan="1">0.0</td>
              <td rowspan="1" colspan="1">0.0</td>
              <td rowspan="1" colspan="1">18.0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TRF</td>
              <td rowspan="1" colspan="1">0.1</td>
              <td rowspan="1" colspan="1">1.9</td>
              <td rowspan="1" colspan="1">
                <bold>902.0</bold>
              </td>
              <td rowspan="1" colspan="1">0.05</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TideHunter</td>
              <td rowspan="1" colspan="1">89.3</td>
              <td rowspan="1" colspan="1">
                <bold>2.9</bold>
              </td>
              <td rowspan="1" colspan="1">887.9</td>
              <td rowspan="1" colspan="1">
                <bold>0.1</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="3" colspan="1">3</td>
              <td rowspan="1" colspan="1">INC-seq</td>
              <td rowspan="1" colspan="1">
                <bold>97.3</bold>
              </td>
              <td rowspan="1" colspan="1">2.0</td>
              <td rowspan="1" colspan="1">876.7</td>
              <td rowspan="1" colspan="1">26.5</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TRF</td>
              <td rowspan="1" colspan="1">7.6</td>
              <td rowspan="1" colspan="1">2.3</td>
              <td rowspan="1" colspan="1">
                <bold>908.6</bold>
              </td>
              <td rowspan="1" colspan="1">0.2</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TideHunter</td>
              <td rowspan="1" colspan="1">
                <bold>100.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>4.8</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>952.5</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.3</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="3" colspan="1">5</td>
              <td rowspan="1" colspan="1">INC-seq</td>
              <td rowspan="1" colspan="1">99.2</td>
              <td rowspan="1" colspan="1">3.8</td>
              <td rowspan="1" colspan="1">934.1</td>
              <td rowspan="1" colspan="1">47.1</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TRF</td>
              <td rowspan="1" colspan="1">31.1</td>
              <td rowspan="1" colspan="1">3.8</td>
              <td rowspan="1" colspan="1">916.2</td>
              <td rowspan="1" colspan="1">0.8</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TideHunter</td>
              <td rowspan="1" colspan="1">99.9</td>
              <td rowspan="1" colspan="1">
                <bold>9.5</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>988.2</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.9</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="3" colspan="1">10</td>
              <td rowspan="1" colspan="1">INC-seq</td>
              <td rowspan="1" colspan="1">
                <bold>100.0</bold>
              </td>
              <td rowspan="1" colspan="1">7.8</td>
              <td rowspan="1" colspan="1">971.6</td>
              <td rowspan="1" colspan="1">91.0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TRF</td>
              <td rowspan="1" colspan="1">60.1</td>
              <td rowspan="1" colspan="1">6.8</td>
              <td rowspan="1" colspan="1">921.1</td>
              <td rowspan="1" colspan="1">3.6</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TideHunter</td>
              <td rowspan="1" colspan="1">
                <bold>100.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>18.4</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>996.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>2.9</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="2" colspan="1">20</td>
              <td rowspan="1" colspan="1">INC-seq</td>
              <td rowspan="1" colspan="1">100.0</td>
              <td rowspan="1" colspan="1">16.9</td>
              <td rowspan="1" colspan="1">988.3</td>
              <td rowspan="1" colspan="1">181.5</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TRF</td>
              <td rowspan="1" colspan="1">84.6</td>
              <td rowspan="1" colspan="1">14.6</td>
              <td rowspan="1" colspan="1">934.0</td>
              <td rowspan="1" colspan="1">10.3</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tf3">
            <p><italic>Note</italic>: The best performance regarding each specific feature on each dataset.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>On all datasets, TideHunter was run with default settings: <italic>kmer_length = 8, step_size = 1, min_copy = 2, min_period = 30, max_period = 100 000, max_diverg = 0.25</italic>. For TRF, recommended parameters were used: <italic>match = 2, mismatch = 7, indel = 7, match_frac = 80, indel_frac = 10, min_score = 100, max_period = 2000</italic>. INC-seq was run with default settings except: <italic>minReadLength = 1000, anchor_seg_step = 50, anchor_length = 50, copy_num_thre = 2</italic>. C3POa was excluded from the simulation study because it requires additional splint sequence information as input.</p>
      <p>We consider a detected tandem repeat as <italic>correct</italic> only if the consensus length and the true repeat pattern size have a difference less than 20%, i.e.:
<disp-formula id="E6"><mml:math id="M6"><mml:mrow><mml:mi mathvariant="italic">true</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">size</mml:mi><mml:mo>×</mml:mo><mml:mn>1.2</mml:mn><mml:mo>≥</mml:mo><mml:mi mathvariant="italic">consensus</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">length</mml:mi><mml:mo>≥</mml:mo><mml:mi mathvariant="italic">true</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">size</mml:mi><mml:mo>×</mml:mo><mml:mn>0.8</mml:mn></mml:mrow></mml:math></disp-formula></p>
      <p>The accuracy is defined as the number of correct consensus sequences/the total number of reads. The copy number for each called tandem repeat was directly extracted from each tool’s result. We aligned each consensus sequence with the ground truth repeat unit sequence and calculated the number of identical bases (the number of equal operations, i.e. ‘=’, in the alignment CIGAR) using the alignment result. Average copy number and identical bases of each dataset were calculated using only correct consensus sequences.</p>
      <sec>
        <title>3.1.1 Running speed</title>
        <p>TideHunter is approximately 100 times faster than INC-seq on all datasets (<xref rid="btz376-T1" ref-type="table">Table 1</xref>-<xref rid="btz376-T3" ref-type="table">3</xref>), which benefits from the fast repeat unit recognition algorithm and the SIMD acceleration of POA. As an alignment-based method, INC-seq identifies tandem repeat patterns through exhaustive segment alignment, which is expected to be very slow. TRF shows comparable running speed but has clearly lower sensitivity than TideHunter, especially on datasets with higher error rates and longer repeat pattern sizes.</p>
      </sec>
      <sec>
        <title>3.1.2 Performance under varying error rates and distributions</title>
        <p>TideHunter shows a higher sensitivity and accuracy than INC-seq and TRF across five datasets with different error rates and error distributions (<xref rid="btz376-T1" ref-type="table">Table 1</xref>). Given a long enough repeat pattern (1000 bp) and a large enough copy number (10), TideHunter and INC-seq are able to detect almost all (&gt;99%) of the tandem repeats regardless of the error rate. TideHunter has the overall highest average copy number and number of identical bases. The strategy of seeding and chaining of short <italic>k</italic>-mers enables TideHunter to discover the tandem repeat signal embedded in the long-read, even at a very high error rate.</p>
        <p>INC-seq shows a slightly lower sensitivity and accuracy than TideHunter, while TRF only detected approximately 70% or fewer of the repeats from the 13%, 15%-a and 16% error rate datasets, and 0 from the 20% dataset. TRF is not expected to be able to process datasets with very high error rates, as it uses a preset error probability model requiring the matching fraction of two adjacent repeats to be at least 80%.</p>
        <p>On the 20% error rate dataset, though TideHunter successfully detected tandem repeats from most of the reads, the copy number and number of identical bases dropped substantially as compared to other datasets. This is due to the low sequence identity resulting in more terminations during the tandem repeat searching.</p>
        <p>TideHunter shows a higher robustness than TRF and INC-seq across three different error distributions on the 15%-a, 15%-b and 16% error rate datasets. Among the three tools, the error distribution influences TRF’s performance the most in respect to both the total number of correct consensus sequences and the average copy number. TRF favors the dataset with more insertion errors (15%-b, 11:60:29) and identifies the least number of tandem repeats when more deletion errors are in the reads (16%, 28:24:48). The performance of INC-seq also dropped substantially with a high number of deletion errors (16%, 28:24:48).</p>
        <p>Unbalanced error distributions lead to additional (insertion &gt; deletion) or missing (insertion &lt; deletion) nucleotides in the sequencing reads compared to the original template sequences. In such cases, although the hit distances between two identical <italic>k</italic>-mers of consecutive copies differ from the true repeat pattern size, TideHunter will still chain these anchors together, as their distances are similar to each other, thus leading to a small chaining cost. As such, the optimal chain will still reflect the true underlying repeat pattern size in an approximate manner. This again illustrates the advantage of TideHunter’s seed-and-chain strategy over other approaches.</p>
      </sec>
      <sec>
        <title>3.1.3 Performance under varying repeat pattern sizes</title>
        <p>TideHunter identified all the repeats on 500, 1000, 2000 and 3000 bp repeat pattern size datasets (<xref rid="btz376-T2" ref-type="table">Table 2</xref>). On the 100 bp dataset, TideHunter detected tandem repeats from 734 reads, while TRF and INC-seq detected tandem repeats from 702 and 377 reads, respectively. When the repeat pattern is short and the error rate is high, it is more likely that TideHunter will collect a tandem repeat hit having a distance multiple folds larger than the true repeat pattern size, which leads to a false optimal chain.</p>
        <p>INC-seq is less sensitive on datasets with repeat pattern sizes of 500 bp or shorter. TRF shows lower performance when the repeat pattern size increases and does not function with repeat pattern size of 2000 bp or longer.</p>
      </sec>
      <sec>
        <title>3.1.4 Performance under varying copy numbers</title>
        <p>All three tools failed with the 2 copy number dataset as the repeat signal is insufficient to be detected (<xref rid="btz376-T3" ref-type="table">Table 3</xref>). For the 3 copy number dataset, INC-seq identified a higher number of repeats than TideHunter. For datasets with the copy number larger than 5, TideHunter and INC-seq both correctly identified almost all repeats. TRF still failed with approximately 15% of the reads even on the 20 copy number dataset.</p>
        <p>Given a higher copy number of the repeats, all three tools are able to generate a more accurate consensus sequence. TideHunter always provides more identical bases than INC-seq and TRF, as more copies of repeats are collapsed to call the consensus sequence.</p>
      </sec>
    </sec>
    <sec>
      <title>3.2 Real data evaluation</title>
      <p>In the real data evaluation, we first evaluated TideHunter along with TRF, INC-seq and C3POa on a synthetic Spike-In RNA Variant (SIRV) E2 dataset (<xref rid="btz376-B24" ref-type="bibr">Volden <italic>et al.</italic>, 2018</xref>). In total, 603 906 Nanopore 1D reads having at least one splint sequence were used to perform the evaluation. These reads were selected from 828 684 raw reads using the C3POa preprocessing script.</p>
      <p>Another three synthetic 16S ribosomal RNA (rRNA) datasets (<xref rid="btz376-B13" ref-type="bibr">Li <italic>et al.</italic>, 2016</xref>) were used to evaluate the first three tools excluding C3POa, as it requires additional splint sequence information as input. The first 16S rRNA dataset is a simple synthetic community with only three bacteria, while the other two datasets include two independent replicates having ten bacteria. For all three datasets, only Nanopore 2D reads were used.</p>
      <p>Three of the tools were run with default or recommended settings on all the real datasets. INC-seq was run on the SIRV E2 dataset with the same settings as in the simulation study, as the SIRV E2 dataset has template sequences shorter than 500 bp, which is the default anchor length for INC-seq.</p>
      <p>To focus on high-quality consensus results, we filtered out tandem repeats with less than six copies. The threshold six was chosen based on the default setting of INC-seq.</p>
      <p>Moreover, for the SIRV E2 dataset, all consensus sequences were trimmed to full-length transcript reads using the C3POa post-processing script. Full-length reads and consensus sequences were mapped to the artificial SIRVome sequences (<xref rid="btz376-B24" ref-type="bibr">Volden <italic>et al.</italic>, 2018</xref>) and a customized 16S rRNA reference database (<xref rid="btz376-B13" ref-type="bibr">Li <italic>et al.</italic>, 2016</xref>), respectively, using minimap2 (<xref rid="btz376-B15" ref-type="bibr">Li, 2018</xref>).</p>
      <sec>
        <title>3.2.1 Performance on the SIRV E2 dataset</title>
        <p>On the SIRV E2 dataset, TideHunter is approximately 40 times and 120 times faster than C3POa and INC-seq respectively, and 2.6 times faster than TRF (<xref rid="btz376-T4" ref-type="table">Table 4</xref>). It is more sensitive in terms of generating consensus sequences and full-length transcripts. Over 25% of the reads were detected to have six or more copies of tandem repeats. C3POa has the highest mappable ratio, but overall, TideHunter provided the most mappable full-length consensus sequences.</p>
        <table-wrap id="btz376-T4" orientation="portrait" position="float">
          <label>Table 4.</label>
          <caption>
            <p>Performance on the SIRV E2 dataset (603 906 Nanopore 1D reads with at least one splint sequence were used for evaluation)</p>
          </caption>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col valign="top" align="left" span="1"/>
              <col valign="top" align="center" span="1"/>
              <col valign="top" align="center" span="1"/>
              <col valign="top" align="center" span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th rowspan="1" colspan="1">Tool</th>
                <th rowspan="1" colspan="1"># consensus</th>
                <th rowspan="1" colspan="1"># full-length reads</th>
                <th rowspan="1" colspan="1"># mappable reads (mappable ratio %)</th>
                <th rowspan="1" colspan="1">Error rate (%)</th>
                <th rowspan="1" colspan="1">Run time (CPU hour)</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">TideHunter</td>
                <td rowspan="1" colspan="1">
                  <bold>155 261</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>148 126</bold>
                </td>
                <td rowspan="1" colspan="1"><bold>142 208</bold> (96.0)</td>
                <td rowspan="1" colspan="1">5.1</td>
                <td rowspan="1" colspan="1">
                  <bold>5.2</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">C3POa</td>
                <td rowspan="1" colspan="1">136 243</td>
                <td rowspan="1" colspan="1">119 503</td>
                <td rowspan="1" colspan="1">119 267 (<bold>99.8</bold>)</td>
                <td rowspan="1" colspan="1">
                  <bold>4.2</bold>
                </td>
                <td rowspan="1" colspan="1">204.5</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">INC-seq</td>
                <td rowspan="1" colspan="1">115 963</td>
                <td rowspan="1" colspan="1">110 645</td>
                <td rowspan="1" colspan="1">107 159 (96.8)</td>
                <td rowspan="1" colspan="1">6.5</td>
                <td rowspan="1" colspan="1">630.6</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">TRF</td>
                <td rowspan="1" colspan="1">118 040</td>
                <td rowspan="1" colspan="1">110 079</td>
                <td rowspan="1" colspan="1">105 145 (95.5)</td>
                <td rowspan="1" colspan="1">6.7</td>
                <td rowspan="1" colspan="1">13.8</td>
              </tr>
            </tbody>
          </table>
        </table-wrap>
        <p>To evaluate the accuracy of the consensus sequences, we calculated the error rate based on the minimap2 alignments. Consensus sequences generated by TideHunter are more accurate than INC-seq and TRF, but are 0.9% less accurate than C3POa. This is likely due to the sophisticated consensus calling strategy that C3POa adopts. Unlike TideHunter, which directly generates the final consensus sequence through POA, C3POa considers the POA output as a preliminary consensus sequence. It then aligns all the partitioned segments back to the preliminary consensus sequence. These alignments are used as input to further error-correct the consensus sequence by racon (<xref rid="btz376-B23" ref-type="bibr">Vaser <italic>et al.</italic>, 2017</xref>). Racon splits the consensus sequence and partitioned segments into several chunks using non-overlapping windows, then independently performs another round of POA within each window. We may implement a similar strategy in TideHunter in the future in order to further improve the consensus accuracy.</p>
      </sec>
      <sec>
        <title>3.2.2 Performance on synthetic 16S rRNA datasets</title>
        <p>On three 16S rRNA datasets, TideHunter is over 25 times faster than INC-seq and three times faster than TRF (<xref rid="btz376-T5" ref-type="table">Table 5</xref>). It also has the most identified tandem repeats and mappable consensus sequences. TRF shows a slightly higher sensitivity than INC-seq, which is likely due to Nanopore 2D reads having a relatively higher sequencing accuracy.</p>
        <table-wrap id="btz376-T5" orientation="portrait" position="float">
          <label>Table 5.</label>
          <caption>
            <p>Performance on synthetic 16S rRNA datasets (only Nanopore 2D reads were used for evaluation)</p>
          </caption>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col valign="top" align="left" span="1"/>
              <col valign="top" align="left" span="1"/>
              <col valign="top" align="center" span="1"/>
              <col valign="top" align="center" span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th rowspan="1" colspan="1">Dataset (# reads)</th>
                <th align="left" rowspan="1" colspan="1">Tool</th>
                <th align="left" rowspan="1" colspan="1"># consensus</th>
                <th align="left" rowspan="1" colspan="1"># mappable reads (mappable ratio %)</th>
                <th align="left" rowspan="1" colspan="1">Error rate (%)</th>
                <th align="left" rowspan="1" colspan="1">Run time (CPU min)</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1">TideHunter</td>
                <td rowspan="1" colspan="1">
                  <bold>3860</bold>
                </td>
                <td rowspan="1" colspan="1"><bold>3853</bold> (99.8)</td>
                <td rowspan="1" colspan="1">
                  <bold>4.4</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>4.7</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="3" colspan="1">Simple<xref ref-type="table-fn" rid="tblfn1"><sup>a</sup></xref> (14 580)</td>
                <td rowspan="1" colspan="1">INC-seq</td>
                <td rowspan="1" colspan="1">2178</td>
                <td rowspan="1" colspan="1">2174 (99.8)</td>
                <td rowspan="1" colspan="1">4.8</td>
                <td rowspan="1" colspan="1">119.0</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">TRF</td>
                <td rowspan="1" colspan="1">2542</td>
                <td rowspan="1" colspan="1">2540 (<bold>99.9</bold>)</td>
                <td rowspan="1" colspan="1">4.5</td>
                <td rowspan="1" colspan="1">14.5</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">TideHunter</td>
                <td rowspan="1" colspan="1">
                  <bold>1596</bold>
                </td>
                <td rowspan="1" colspan="1"><bold>1590</bold> (99.6)</td>
                <td rowspan="1" colspan="1">
                  <bold>3.1</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>1.5</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="3" colspan="1">Rep.1<xref ref-type="table-fn" rid="tblfn2"><sup>b</sup></xref> (7 444)</td>
                <td rowspan="1" colspan="1">INC-seq</td>
                <td rowspan="1" colspan="1">1076</td>
                <td rowspan="1" colspan="1">1074 (<bold>99.8</bold>)</td>
                <td rowspan="1" colspan="1">4.7</td>
                <td rowspan="1" colspan="1">50.4</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">TRF</td>
                <td rowspan="1" colspan="1">1360</td>
                <td rowspan="1" colspan="1">1356 (99.7)</td>
                <td rowspan="1" colspan="1">3.5</td>
                <td rowspan="1" colspan="1">5.5</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">TideHunter</td>
                <td rowspan="1" colspan="1">
                  <bold>1564</bold>
                </td>
                <td rowspan="1" colspan="1"><bold>1558</bold> (99.6)</td>
                <td rowspan="1" colspan="1">
                  <bold>3.0</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>1.5</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="2" colspan="1">Rep.2<xref ref-type="table-fn" rid="tblfn3"><sup>c</sup></xref> (2 904)</td>
                <td rowspan="1" colspan="1">INC-seq</td>
                <td rowspan="1" colspan="1">1183</td>
                <td rowspan="1" colspan="1">1178 (99.6)</td>
                <td rowspan="1" colspan="1">4.3</td>
                <td rowspan="1" colspan="1">43.9</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">TRF</td>
                <td rowspan="1" colspan="1">1330</td>
                <td rowspan="1" colspan="1">1326 (<bold>99.7</bold>)</td>
                <td rowspan="1" colspan="1">3.4</td>
                <td rowspan="1" colspan="1">4.8</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <fn id="tblfn1">
              <label>a</label>
              <p>Simple: simple community dataset with 3 bacteria.</p>
            </fn>
            <fn id="tblfn2">
              <label>b</label>
              <p>Rep.1: replicate 1 of 10 bacteria community.</p>
            </fn>
            <fn id="tblfn3">
              <label>c</label>
              <p>Rep.2: replicate 2 of 10 bacteria community.</p>
            </fn>
          </table-wrap-foot>
        </table-wrap>
        <p>95.4% and 97.4% of TRF and INC-seq’s mappable consensus sequences are detected by TideHunter, while the overlapping ratio is 90.7% for TRF and INC-seq. For all three tools, over 99.6% of the consensus sequences are mappable, and they all have a length of 500–1000 bp, consistent with the size of 16S rRNA.</p>
        <p>We calculated the error rate using the primary alignment record for each consensus sequence. All three tools are able to produce a high-quality (error rate &lt;5%) consensus sequence given six or more copies of the tandem repeat. Again, TideHunter slightly outperforms the other two tools.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>The recently proposed RCA-based long-read sequencing workflow provides a new strategy for producing high-accuracy long-read data. With additional computational processing steps, the error rate of the resulting consensus sequences can be lower than 5%, which is much lower than the raw error rate [over 13% (<xref rid="btz376-B25" ref-type="bibr">Weirather <italic>et al.</italic>, 2017</xref>)].</p>
    <p>TideHunter is an efficient and sensitive tandem repeat detection and consensus calling tool specifically designed for RCA-based long-read data. It works with noisy long-reads (PacBio and ONT) at error rates of up to 20% and does not have any limitation of the maximal repeat pattern size as for traditional tandem repeat detection tools (<xref rid="btz376-B1" ref-type="bibr">Benson <italic>et al.</italic>, 1999</xref>). TideHunter is 20 to 100 times faster than existing alignment-based methods (<xref rid="btz376-B13" ref-type="bibr">Li <italic>et al.</italic>, 2016</xref>; <xref rid="btz376-B24" ref-type="bibr">Volden <italic>et al.</italic>, 2018</xref>) and shows a higher sensitivity on all evaluation datasets.</p>
    <p>The high efficiency and sensitivity of TideHunter come from its specifically designed seed-and-chain-based repeat unit recognition algorithm and the SIMD acceleration of POA. The seed-and-chain algorithm enables TideHunter to make full use of the identical <italic>k</italic>-mers between tandem copies, then efficiently identify the repeat pattern size through the search for the optimal chain. The proper chaining score and cost functions used during the chaining step enhance the robustness of TideHunter across datasets with different error rates and unbalanced error distributions. To the best of our knowledge, TideHunter is the first tandem repeat detection tool that adopts the seed-and-chain strategy. Moreover, the overall speed is further accelerated by the SIMD-based implementation of POA.</p>
    <p>The configuration of the <italic>k</italic>-mer length and step size (<italic>k</italic> and <italic>s</italic>) is crucial for the performance of TideHunter. Larger <italic>k</italic>-mer length may reduce the number of tandem repeat hits as the probability of sequencing error showing up in the <italic>k</italic>-mer becomes higher. On the other hand, if the <italic>k</italic>-mer is too short, the chance of two random <italic>k</italic>-mers being identical increases greatly, which likely leads to a false optimal chain. For the step size, exhaustively collecting all <italic>k</italic>-mers will ensure TideHunter does not miss any useful information in the determination of the repeat pattern size. Our evaluation suggests that the default setting of <italic>k </italic>=<italic> </italic>8 and <italic>s </italic>=<italic> </italic>1 enables TideHunter to tolerate sequencing errors and achieve the highest sensitivity.</p>
    <p>Instead of using a larger step size, other long-read aligners utilize MinHash (<xref rid="btz376-B2" ref-type="bibr">Berlin <italic>et al.</italic>, 2015</xref>) or minimizer (<xref rid="btz376-B14" ref-type="bibr">Li, 2016</xref>) to sample sequences in a reduced representation. Although we have implemented minimizer seeding in TideHunter, it is not recommended to enable this function as the speed improvement is insignificant (1.2 times faster with parameter <italic>window-size = 5</italic>), but the sensitivity is slightly lower.</p>
    <p>TideHunter is not designed to detect satellite repeats [repeat pattern size: 5–170 bp (<xref rid="btz376-B22" ref-type="bibr">Tyler-Smith and Brown, 1987</xref>)] from long-read data without RCA. Although alpha satellites having a pattern size of 170 bp can be detected in our simulation, TideHunter shows a poor sensitivity on other very short repeat pattern (&lt;100 bp) datasets (simulated data not shown). Satellite repeat discovery is the main intended usage of TRF. However, its performance is significantly reduced by the high sequencing error rate. We anticipate that new tools need to be developed for discovering satellite repeats from noisy long-read data.</p>
    <p>Unlike TRF which allows up to three overlapping repeats to be reported, TideHunter only selects one optimal period size in each read region. Thus, in some rare cases where the template itself is a tandem repeat, TideHunter is likely to generate a consensus sequence containing a single repeat unit of the template. This is because chains with a shorter hit distance always tend to have more anchors and higher chaining scores. However, this issue can be addressed if adaptor sequences are added during the library preparation. Chains of single repeat units will be separated by the adaptor sequence and thus, the true optimal chain will still have the highest score.</p>
    <p>A potential future goal is to further improve the consensus quality, as the error rates of the called consensus sequences are still relatively high. Currently, TideHunter simply takes the consensus sequence generated by POA as the final result. A possible solution is to incorporate base quality scores into the consensus calling algorithm, i.e. bases with higher quality have higher weights in the graph. This can be a feasible solution as base quality scores have been used to produce high-quality consensus sequences in other applications, such as genome assembly, read re-alignment and variant calling.</p>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>We thank Sidney Taiko Sheehan and Eddie Park for reading and editing the manuscript.</p>
    <sec>
      <title>Funding</title>
      <p>This study was supported by a startup fund from the Children’s Hospital of Philadelphia. This study was also partially supported by the National Key Research and Development Program of China (Nos 2018YFC0910504 and 2017YFC0907503).</p>
      <p><italic>Conflict of Interest</italic>: none declared.</p>
    </sec>
  </ack>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btz376-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Benson</surname><given-names>G.</given-names></name></person-group><etal>et al</etal> (<year>1999</year>) 
<article-title>Tandem repeats finder: a program to analyze DNA sequences</article-title>. <source>Nucleic Acids Res</source>., <volume>27</volume>, <fpage>573</fpage>–<lpage>580</lpage>.<pub-id pub-id-type="pmid">9862982</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Berlin</surname><given-names>K.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Assembling large genomes with single-molecule sequencing and locality-sensitive hashing</article-title>. <source>Nat. Biotechnol</source>., <volume>33</volume>, <fpage>623.</fpage><pub-id pub-id-type="pmid">26006009</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Calus</surname><given-names>S.T.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>NanoAmpli-Seq: a workflow for amplicon sequencing for mixed microbial communities on the nanopore sequencing platform</article-title>. <source>GigaScience</source>, <volume>7</volume>, <fpage>giy140.</fpage></mixed-citation>
    </ref>
    <ref id="btz376-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chin</surname><given-names>C.-S.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>Nonhybrid, finished microbial genome assemblies from long-read SMRT sequencing data</article-title>. <source>Nat. Methods</source>, <volume>10</volume>, <fpage>563.</fpage><pub-id pub-id-type="pmid">23644548</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chin</surname><given-names>C.-S.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Phased diploid genome assembly with single-molecule real-time sequencing</article-title>. <source>Nat. Methods</source>, <volume>13</volume>, <fpage>1050.</fpage><pub-id pub-id-type="pmid">27749838</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>de Lannoy</surname><given-names>C.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>A sequencer coming of age: de novo genome assembly using MinION reads</article-title>. <source>F1000Research</source>, <volume>6</volume>, <fpage>1083</fpage>.<pub-id pub-id-type="pmid">29375809</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Goodwin</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Oxford Nanopore sequencing, hybrid error correction, and de novo assembly of a eukaryotic genome</article-title>. <source>Genome Res</source>., <volume>25</volume>, <fpage>1750</fpage>–<lpage>1756</lpage>.<pub-id pub-id-type="pmid">26447147</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Goodwin</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Coming of age: ten years of next-generation sequencing technologies</article-title>. <source>Nat. Rev. Genetics</source>, <volume>17</volume>, <fpage>333.</fpage><pub-id pub-id-type="pmid">27184599</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B9">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Harris</surname><given-names>R.S.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) Noise-Cancelling Repeat Finder: uncovering tandem repeats in error-prone long-read sequencing data. <italic>bioRxiv</italic>, doi: 10.1101/475194.</mixed-citation>
    </ref>
    <ref id="btz376-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Koren</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>Hybrid error correction and de novo assembly of single-molecule sequencing reads</article-title>. <source>Nat. Biotechnol</source>., <volume>30</volume>, <fpage>693.</fpage><pub-id pub-id-type="pmid">22750884</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lee</surname><given-names>C.</given-names></name></person-group> (<year>2003</year>) 
<article-title>Generating consensus sequences from partial order multiple sequence alignment graphs</article-title>. <source>Bioinformatics</source>, <volume>19</volume>, <fpage>999</fpage>–<lpage>1008</lpage>.<pub-id pub-id-type="pmid">12761063</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lee</surname><given-names>C.</given-names></name></person-group><etal>et al</etal> (<year>2002</year>) 
<article-title>Multiple sequence alignment using partial order graphs</article-title>. <source>Bioinformatics</source>, <volume>18</volume>, <fpage>452</fpage>–<lpage>464</lpage>.<pub-id pub-id-type="pmid">11934745</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>C.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>INC-Seq: accurate single molecule reads using nanopore sequencing</article-title>. <source>GigaScience</source>, <volume>5</volume>, <fpage>34.</fpage><pub-id pub-id-type="pmid">27485345</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>H.</given-names></name></person-group> (<year>2016</year>) 
<article-title>Minimap and miniasm: fast mapping and de novo assembly for noisy long sequences</article-title>. <source>Bioinformatics</source>, <volume>32</volume>, <fpage>2103</fpage>–<lpage>2110</lpage>.<pub-id pub-id-type="pmid">27153593</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>H.</given-names></name></person-group> (<year>2018</year>) 
<article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title>. <source>Bioinformatics</source>, <volume>1</volume>, <fpage>7</fpage>.</mixed-citation>
    </ref>
    <ref id="btz376-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lim</surname><given-names>K.G.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>Review of tandem repeat search tools: a systematic approach to evaluating algorithmic performance</article-title>. <source>Brief. Bioinform</source>., <volume>14</volume>, <fpage>67</fpage>–<lpage>81</lpage>.<pub-id pub-id-type="pmid">22648964</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Liu</surname><given-names>B.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>LAMSA: fast split read alignment with long approximate matches</article-title>. <source>Bioinformatics</source>, <volume>33</volume>, <fpage>192</fpage>–<lpage>201</lpage>.<pub-id pub-id-type="pmid">27667793</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Ono</surname><given-names>Y.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>PBSIM: PacBio reads simulator–toward accurate genome assembly</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>119</fpage>–<lpage>121</lpage>.<pub-id pub-id-type="pmid">23129296</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Pellegrini</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2010</year>) 
<article-title>TRStalker: an efficient heuristic for finding fuzzy tandem repeats</article-title>. <source>Bioinformatics</source>, <volume>26</volume>, <fpage>i358</fpage>–<lpage>i366</lpage>.<pub-id pub-id-type="pmid">20529928</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Salmela</surname><given-names>L.</given-names></name>, <name name-style="western"><surname>Rivals</surname><given-names>E.</given-names></name></person-group> (<year>2014</year>) 
<article-title>LoRDEC: accurate and efficient long read error correction</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>3506</fpage>–<lpage>3514</lpage>.<pub-id pub-id-type="pmid">25165095</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Salmela</surname><given-names>L.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>Accurate self-correction of errors in long reads using de Bruijn graphs</article-title>. <source>Bioinformatics</source>, <volume>33</volume>, <fpage>799</fpage>–<lpage>806</lpage>.<pub-id pub-id-type="pmid">27273673</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Tyler-Smith</surname><given-names>C.</given-names></name>, <name name-style="western"><surname>Brown</surname><given-names>W.R.</given-names></name></person-group> (<year>1987</year>) 
<article-title>Structure of the major block of alphoid satellite dna on the human Y chromosome</article-title>. <source>J. Mol. Biol</source>., <volume>195</volume>, <fpage>457</fpage>–<lpage>470</lpage>.<pub-id pub-id-type="pmid">2821279</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Vaser</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>Fast and accurate de novo genome assembly from long uncorrected reads</article-title>. <source>Genome Res</source>., <volume>27</volume>, <fpage>737</fpage>–<lpage>746</lpage>.<pub-id pub-id-type="pmid">28100585</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Volden</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Improving nanopore read accuracy with the R2C2 method enables the sequencing of highly multiplexed full-length single-cell cDNA</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>115</volume>, <fpage>9726</fpage>–<lpage>9731</lpage>.<pub-id pub-id-type="pmid">30201725</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Weirather</surname><given-names>J.L.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>Comprehensive comparison of Pacific Biosciences and Oxford Nanopore Technologies and their applications to transcriptome analysis</article-title>. <source>F1000Research</source>, <volume>6</volume>, <fpage>100</fpage>.<pub-id pub-id-type="pmid">28868132</pub-id></mixed-citation>
    </ref>
    <ref id="btz376-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Zimin</surname><given-names>A.V.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>The MaSuRCA genome assembler</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>2669</fpage>–<lpage>2677</lpage>.<pub-id pub-id-type="pmid">23990416</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
