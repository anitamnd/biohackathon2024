<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">9235488</article-id>
    <article-id pub-id-type="pmid">35758818</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btac265</article-id>
    <article-id pub-id-type="publisher-id">btac265</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>ISCB/Ismb 2022</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>General Computational Biology</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>QuCo: quartet-based co-estimation of species trees and gene trees</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Rabiee</surname>
          <given-names>Maryam</given-names>
        </name>
        <aff><institution>Department of Computer Science and Engineering, University of California, San Diego</institution>, La Jolla, CA 92093, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-5410-1518</contrib-id>
        <name>
          <surname>Mirarab</surname>
          <given-names>Siavash</given-names>
        </name>
        <aff><institution>Department of Electrical and Computer Engineering, University of California, San Diego</institution>, La Jolla, CA 92093, <country country="US">USA</country></aff>
        <xref rid="btac265-cor1" ref-type="corresp"/>
        <!--smirarab@ucsd.edu-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btac265-cor1">To whom correspondence should be addressed. E-mail: <email>smirarab@ucsd.edu</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>7</month>
      <year>2022</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2022-06-27">
      <day>27</day>
      <month>6</month>
      <year>2022</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>27</day>
      <month>6</month>
      <year>2022</year>
    </pub-date>
    <volume>38</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISCB ISMB 2022 Proceedings</issue-title>
    <fpage>i413</fpage>
    <lpage>i421</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2022. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2022</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btac265.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Phylogenomics faces a dilemma: on the one hand, most accurate species and gene tree estimation methods are those that co-estimate them; on the other hand, these co-estimation methods do not scale to moderately large numbers of species. The summary-based methods, which first infer gene trees independently and then combine them, are much more scalable but are prone to gene tree estimation error, which is inevitable when inferring trees from limited-length data. Gene tree estimation error is not just random noise and can create biases such as long-branch attraction.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We introduce a scalable likelihood-based approach to co-estimation under the multi-species coalescent model. The method, called quartet co-estimation (QuCo), takes as input independently inferred distributions over gene trees and computes the most likely species tree topology and internal branch length for each quartet, marginalizing over gene tree topologies and ignoring branch lengths by making several simplifying assumptions. It then updates the gene tree posterior probabilities based on the species tree. The focus on gene tree topologies and the heuristic division to quartets enables fast likelihood calculations. We benchmark our method with extensive simulations for quartet trees in zones known to produce biased species trees and further with larger trees. We also run QuCo on a biological dataset of bees. Our results show better accuracy than the summary-based approach ASTRAL run on estimated gene trees.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>QuCo is available on <ext-link xlink:href="https://github.com/maryamrabiee/quco" ext-link-type="uri">https://github.com/maryamrabiee/quco</ext-link>.</p>
      </sec>
      <sec id="s5">
        <title>Supplementary information</title>
        <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>NSF</institution>
            <institution-id institution-id-type="DOI">10.13039/100000001</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>IIS-1845967</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>NSF</institution>
            <institution-id institution-id-type="DOI">10.13039/100000001</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>ACI-1053575</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Species tree estimation from multi-locus genome-wide datasets while accounting for gene tree discordance is now routinely attempted. There has been much effort to develop methods that can infer species trees and gene trees accurately, and in particular, methods focused on handling incomplete lineage sorting (ILS) as modeled by multi-species coalescent (MSC) (<xref rid="btac265-B41" ref-type="bibr">Rannala <italic toggle="yes">et al.</italic>, 2020</xref>) abound (e.g. <xref rid="btac265-B8" ref-type="bibr">Chifman and Kubatko, 2014</xref>; <xref rid="btac265-B25" ref-type="bibr">Liu, 2008</xref>; <xref rid="btac265-B26" ref-type="bibr">Liu <italic toggle="yes">et al.</italic>, 2010</xref>; <xref rid="btac265-B32" ref-type="bibr">Mirarab <italic toggle="yes">et al.</italic>, 2014a</xref>; <xref rid="btac265-B37" ref-type="bibr">Ogilvie <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btac265-B51" ref-type="bibr">Vachaspati and Warnow, 2015</xref>). Yet, a major challenge remains. The most accurate methods for species tree estimation have been Bayesian methods that co-estimate gene trees and species trees, while the most scalable methods have been summary methods that first estimate gene trees independently and then combine them to infer a species tree (<xref rid="btac265-B34" ref-type="bibr">Mirarab <italic toggle="yes">et al.</italic>, 2021</xref>). This dichotomy has left practitioners with a choice between using methods that can handle large data or more accurate methods that will have to be run on subsets of the data (<xref rid="btac265-B46" ref-type="bibr">Smith <italic toggle="yes">et al.</italic>, 2014</xref>). Neither solution is ideal.</p>
    <p>Theoretical expectations and empirical evidence suggest that inferring all gene trees together should be more accurate than the two-step approach that independently computes gene trees (<xref rid="btac265-B4" ref-type="bibr">Bayzid and Warnow, 2013</xref>; <xref rid="btac265-B11" ref-type="bibr">Dasarathy <italic toggle="yes">et al.</italic>, 2015</xref>; <xref rid="btac265-B24" ref-type="bibr">Leaché and Rannala, 2011</xref>; <xref rid="btac265-B36" ref-type="bibr">Ogilvie <italic toggle="yes">et al.</italic>, 2016</xref>; <xref rid="btac265-B50" ref-type="bibr">Szöllősi <italic toggle="yes">et al.</italic>, 2015</xref>). Gene tree estimation from limited-length locus data is error-prone, and gene tree estimation error impacts species trees (<xref rid="btac265-B19" ref-type="bibr">Huang <italic toggle="yes">et al.</italic>, 2010</xref>; <xref rid="btac265-B21" ref-type="bibr">Lanier and Knowles, 2015</xref>; <xref rid="btac265-B33" ref-type="bibr">Mirarab <italic toggle="yes">et al.</italic>, 2014b</xref>; <xref rid="btac265-B35" ref-type="bibr">Molloy and Warnow, 2018</xref>; <xref rid="btac265-B40" ref-type="bibr">Patel, 2013</xref>). Importantly, gene tree estimation error is not just random noise and can create biases. <xref rid="btac265-B42" ref-type="bibr">Roch <italic toggle="yes">et al.</italic> (2019)</xref> have proved that under challenging cases, long-branch attraction in gene trees could lead to long-branch attraction in species trees and statistically inconsistent estimates. Dealing with gene tree estimation error has motivated several remedies, including binning genes (<xref rid="btac265-B4" ref-type="bibr">Bayzid and Warnow, 2013</xref>; <xref rid="btac265-B33" ref-type="bibr">Mirarab <italic toggle="yes">et al.</italic>, 2014b</xref>), collapsing low support branches (<xref rid="btac265-B38" ref-type="bibr">OneKP Initiative, 2019</xref>; <xref rid="btac265-B55" ref-type="bibr">Zhang <italic toggle="yes">et al.</italic>, 2018</xref>), and sampling posterior distributions of gene trees (<xref rid="btac265-B5" ref-type="bibr">Bossert <italic toggle="yes">et al.</italic>, 2021</xref>). However, these methods have their own drawbacks. Binning has the possibility of combining discordant genes, collapsing low support requires selecting a threshold, and simply combining samples from gene tree posteriors as input to summary methods shows mixed results in simulations (<xref rid="btac265-B31" ref-type="bibr">Mirarab, 2019</xref>). Thus, co-estimation methods are still the ideal option. Yet, current co-estimation methods such as *BEAST (<xref rid="btac265-B37" ref-type="bibr">Ogilvie <italic toggle="yes">et al.</italic>, 2017</xref>) scale only to tens of species (<xref rid="btac265-B29" ref-type="bibr">McCormack <italic toggle="yes">et al.</italic>, 2009</xref>).</p>
    <p>The scalability of co-estimation methods has remained limited because they address a challenging problem using the slow MCMC process. The space of parameters for the joint species/gene tree inference is extremely large and consists of both discrete (gene tree and species tree topologies) and continuous parameters (per-branch lengths and rates, population sizes, and per-gene transition rate matrices). To explore this large and heterogeneous space to convergence, MCMC needs to run for a long time. Developing theoretically justified scalable co-estimation methods requires simplifying the model and heuristic methods. <xref rid="btac265-B52" ref-type="bibr">Wang and Nakhleh (2018)</xref> sped up co-estimation by avoiding full sampling of the entire space using an EM-like algorithm that iteratively switches between species tree and gene tree estimation. While this method increased gene tree accuracy, it was not clear that it improved species tree accuracy, perhaps because the estimated species tree was used to improve gene trees.</p>
    <p>This article is an attempt at providing a likelihood-based approach to co-estimation under MSC designed to scale using simplifying assumptions and heuristics while keeping a likelihood-based core. We observe that while joint sampling of <italic toggle="yes">continuous</italic> parameters of gene trees, such as their branch lengths, slows down co-estimation, these are often nuisance parameters. Therefore, we focus on topology, marginalizing over gene tree branch lengths and other continuous parameters. However, this marginalization would still be intractable if done jointly. Instead, we ignore the dependency among substitution unit branch lengths (similar to a no-common-mechanism model) and assume continuous parameters across gene trees are fully unlinked. This admittedly strong assumption enables us to decouple genes. We first use existing methods to estimate gene tree distributions independently across genes, marginalize continuous parameters, and finally infer the species tree jointly. This approach can still be called co-estimation because we combine results from multiple genes and <italic toggle="yes">adjust</italic> their distribution jointly at the end. This insight is not new for species tree inference (<xref rid="btac265-B2" ref-type="bibr">Ané <italic toggle="yes">et al.</italic>, 2007</xref>; <xref rid="btac265-B22" ref-type="bibr">Larget <italic toggle="yes">et al.</italic>, 2010</xref>, pioneered the idea in the method BUCKy) or improving gene trees (<xref rid="btac265-B49" ref-type="bibr">Szöllõsi <italic toggle="yes">et al.</italic>, 2013</xref>). Finally, building on the success of quartet-based methods for handling ILS (e.g. <xref rid="btac265-B8" ref-type="bibr">Chifman and Kubatko, 2014</xref>; <xref rid="btac265-B32" ref-type="bibr">Mirarab <italic toggle="yes">et al.</italic>, 2014a</xref>), we estimate quartet species trees using a likelihood-based approach but combine the quartet species trees heuristically using supertree methods. Lest the reader worries about lowered taxon sampling and increased long branch attraction (LBA) when using quartets, we note that gene tree estimation is performed on the full set of taxa, but the amalgamation step uses <italic toggle="yes">induced</italic> quartets.</p>
    <p>Based on these insights, we introduce a method called quartet-based co-estimation (QuCo for short) that takes as input a Bayesian posterior tree distribution per each of <italic toggle="yes">k</italic> genes, infers the distribution of quartet trees in that input, and summarizes the posteriors in a <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mn>3</mml:mn><mml:mo>×</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> table per quartet. Next, for each quartet of species, it computes the maximum likelihood species tree topology and its single internal branch length in the coalescent unit, marginalizing over gene trees. It then improves the gene tree topologies using the species tree. Finally, it combines the inferred quartet species trees to obtain a final tree topology on the complete set of taxa (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S1</xref>). We evaluate the method on a set of simulations with four to 101 species and a real bee dataset and show that it increases accuracy while providing a path for scalable co-estimation.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 QuCo: maximum likelihood quartet species trees</title>
      <p>We start with the maximum likelihood quartet species tree inference. Throughout, we assume gene trees are made of single-copy orthologous genes and differ due to ILS only, as modeled by MSC. The input to QuCo is the posterior distributions of the gene trees. It computes the maximum likelihood species tree for each quartet of species. Then, using that estimated species tree, it updates the gene tree posterior distributions. While our method for analyzing each quartet is based on likelihood calculations with several simplifying assumptions, to extend to more than four species, we rely on the heuristic method of examining all or a subset of quartets, a procedure we introduce at the end.</p>
      <sec>
        <label>2.1.1</label>
        <title>Marginalized likelihood of the quartet species trees</title>
        <p>For a quartet of species <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, we denote the three topologies <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mi>B</mml:mi><mml:mo>|</mml:mo><mml:mi>C</mml:mi><mml:mi>D</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>A</mml:mi><mml:mi>D</mml:mi><mml:mo>|</mml:mo><mml:mi>B</mml:mi><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo>|</mml:mo><mml:mi>B</mml:mi><mml:mi>D</mml:mi></mml:mrow></mml:math></inline-formula> by <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Let <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">D</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be the set of sequences obtained for each available gene. Given <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mi mathvariant="script">D</mml:mi></mml:math></inline-formula>, we seek to compute the likelihood of the species tree, parameterized by <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mo>θ</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> is the topology and <italic toggle="yes">d</italic> is the internal branch length in coalescent unit. This parameterization fully identifies the distribution of unrooted gene tree <italic toggle="yes">topologies</italic> (<xref rid="btac265-B1" ref-type="bibr">Allman <italic toggle="yes">et al.</italic>, 2011</xref>). We seek the species tree likelihood marginalized over all possibilities for the <italic toggle="yes">k</italic> gene trees, and show the log-likelihood function as <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>θ</mml:mo><mml:mo>;</mml:mo><mml:mi mathvariant="script">D</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mtext>log</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">D</mml:mi><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Let <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="double-struck">C</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>. Any set of <italic toggle="yes">k</italic> quartet tree topologies, one per gene, can be indexed by a tuple <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">C</mml:mi></mml:mrow></mml:math></inline-formula>. Let the true gene tree <italic toggle="yes">topologies</italic> be represented by <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mo>*</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>k</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Then, our goal is to maximize:
<disp-formula id="E1"><label>(1)</label><mml:math id="M1" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">D</mml:mi><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">C</mml:mi></mml:mrow></mml:munder><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">D</mml:mi><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mo>=</mml:mo><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">C</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mrow><mml:mover><mml:mover><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">D</mml:mi><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mo>;</mml:mo><mml:mi>θ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">︷</mml:mo></mml:mover><mml:mrow><mml:mtext>sequence  likelihood</mml:mtext></mml:mrow></mml:mover></mml:mrow></mml:mrow><mml:mo>.</mml:mo><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mrow><mml:mrow><mml:mover><mml:mover><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>;</mml:mo><mml:mi>θ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">︷</mml:mo></mml:mover><mml:mrow><mml:mtext>gene  tree  likelihood</mml:mtext></mml:mrow></mml:mover></mml:mrow></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where the last equation uses the conditional independence of gene trees for a fixed species tree. Working on quartet gene tree topologies makes the calculation of gene tree likelihood trivial. Under the MSC model (<xref rid="btac265-B1" ref-type="bibr">Allman <italic toggle="yes">et al.</italic>, 2011</xref>; <xref rid="btac265-B39" ref-type="bibr">Pamilo and Nei, 1988</xref>), for any <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>:
<disp-formula id="E2"><label>(2)</label><mml:math id="M2" display="block" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo> </mml:mo><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo> </mml:mo><mml:mi mathvariant="normal">o</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="normal">w</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow><mml:mo> </mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p>However, working on gene tree topologies (<italic toggle="yes">c</italic>) makes sequence likelihood calculation challenging because we cannot readily write it as a product over genes. To do so, we need all continuous parameters (gene tree substitution unit branch lengths and rate matrices), which we jointly specify using <italic toggle="yes">r<sub>i</sub></italic> for each gene and <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Letting <italic toggle="yes">f</italic>(<italic toggle="yes">r</italic>) be the density function,
<disp-formula id="E3"><label>(3)</label><mml:math id="M3" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:mi mathvariant="script">D</mml:mi><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="true">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mo>∫</mml:mo><mml:mi>r</mml:mi></mml:msub><mml:mi>f</mml:mi></mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mi>r</mml:mi><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="true">)</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:mi mathvariant="script">D</mml:mi><mml:mo>|</mml:mo><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="true">)</mml:mo><mml:mi mathvariant="normal">d</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mo>∫</mml:mo><mml:mi>r</mml:mi></mml:msub><mml:mrow><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mi>f</mml:mi></mml:mrow></mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="true">)</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true">)</mml:mo><mml:mi mathvariant="normal">d</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mo>∫</mml:mo><mml:mi>r</mml:mi></mml:msub><mml:mrow><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mi>f</mml:mi></mml:mrow></mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="true">)</mml:mo><mml:mfrac><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true">)</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mfrac><mml:mi mathvariant="normal">d</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where the second equation uses the fact that given all gene tree parameters, gene sequence data are independent of each other and the species tree, and given the species tree, gene trees (thus <italic toggle="yes">r<sub>i</sub></italic>) are independent.<statement id="mthst1"><p><italic toggle="yes">Assumptions.</italic> Even for a quartet, computing (3) is not easy. To move forward, we make two assumptions regarding branch lengths. (i) We assume <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, which is reasonable by symmetry when the species tree is <italic toggle="yes">not</italic> given. It requires assuming that <italic toggle="yes">a priori</italic> all three unrooted gene tree topologies are equiprobable, sequence evolution parameters are independent from gene tree topology, and substitution unit branch lengths are independent from <italic toggle="yes">unrooted</italic> gene tree topologies. (ii) We assume <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The species tree clearly impacts the distribution of coalescent unit gene tree branch lengths. Typical ways of mapping branch lengths to substitution units assume distributions over population size and mutation rates. These two parameters are ideally drawn per branch, or else gene trees will be ultrametric. When drawn per branch, substitution unit branch lengths are still dependent on the species tree, though the dependence reduces as the variation of rates across branches increase. We assume an extreme case where the mutation rate branch lengths are drawn from distributions independent from the species tree parameter θ. In other words, each branch of the gene tree is assigned a substitution unit length that is independent of the coalescent units length of internal branch (<italic toggle="yes">d</italic>). We also assume that other continuous parameters (e.g. rate matrices) are either constant across the tree or drawn from distributions independent from θ. These assumptions are not entirely realistic but have the advantage of allowing arbitrary and unlimited deviations from the clock, eliminating the need to assume any clock models. Also, they make (3) tractable. Let <bold>P</bold> be the <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mn>3</mml:mn><mml:mo>×</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> matrix where <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Then:
<disp-formula id="E4"><mml:math id="M4" display="block" overflow="scroll"><mml:mtable><mml:mtr><mml:mtd><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">D</mml:mi><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mo>∫</mml:mo><mml:mi>r</mml:mi></mml:msub><mml:mrow><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mi>f</mml:mi></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true">)</mml:mo><mml:mfrac><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mi mathvariant="normal">d</mml:mi><mml:mi>r</mml:mi><mml:mo>=</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>A</mml:mi><mml:mrow><mml:msub><mml:mo>∫</mml:mo><mml:mi>r</mml:mi></mml:msub><mml:mrow><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mi>P</mml:mi></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="normal">d</mml:mi><mml:mi>r</mml:mi><mml:mo>=</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>A</mml:mi><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mrow><mml:mrow><mml:msub><mml:mo>∫</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mi>P</mml:mi></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="normal">d</mml:mi><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>A</mml:mi><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>where <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:munderover><mml:mo>∏</mml:mo><mml:mn>1</mml:mn><mml:mi>k</mml:mi></mml:munderover><mml:mn>3</mml:mn><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and integral and product swap in the third line is possible because no term has two elements of <italic toggle="yes">r</italic>. Replacing RHS in (1):
<disp-formula id="E5"><label>(4)</label><mml:math id="M5" display="block" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">D</mml:mi><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">C</mml:mi></mml:mrow></mml:munder><mml:mi>A</mml:mi><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mn>3</mml:mn></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>.</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where the second equation uses the fact that for any <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mn>3</mml:mn><mml:mo>×</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> matrix <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, we have <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">C</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mn>3</mml:mn></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> (easy to confirm).</p></statement></p>
        <p>To compute matrix <bold>P</bold> (posterior gene tree topology probabilities marginalized over branch lengths and substitution parameters), many options are available (<xref rid="btac265-B18" ref-type="bibr">Fourment <italic toggle="yes">et al.</italic>, 2020</xref>). We mainly take advantage of Bayesian MCMC sampling implemented in standard methods such as MrBayes (<xref rid="btac265-B43" ref-type="bibr">Ronquist <italic toggle="yes">et al.</italic>, 2012</xref>). Thus, the input to QuCo is a set of <italic toggle="yes">k</italic> gene tree posterior distributions, each inferred separately on its full set of taxa without a species tree. The fraction of times any tree topology appears in the MCMC chain (after some burnout period) is a valid approximation of its posterior probability, marginalized over branch length and other continuous parameters, giving us all values of <bold>P</bold>. We also approximate <bold>P</bold> using normalized quartet log-likelihood as implemented in IQ-TREE (<monospace>-wql</monospace>) (<xref rid="btac265-B30" ref-type="bibr">Minh <italic toggle="yes">et al.</italic>, 2020</xref>). Either way, recalling (2), note that:
<disp-formula id="E6"><mml:math id="M6" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mn>3</mml:mn></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>.</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula>which, when replaced in (4), gives us the log-likelihood function:
<disp-formula id="E7"><label>(5)</label><mml:math id="M7" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>θ</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>;</mml:mo><mml:mi mathvariant="bold">P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mtext>log</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mtext>log</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mo>′</mml:mo><mml:mo>+</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> is independent of θ and thus can be ignored. Note that the likelihood is a function of both the topology <italic toggle="yes">t</italic> and the branch length <italic toggle="yes">d</italic>.</p>
        <p>For each <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, we compute <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mtext>arg</mml:mtext><mml:msub><mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:mrow><mml:mi>d</mml:mi></mml:msub><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>;</mml:mo><mml:mi mathvariant="bold">P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> numerically; then, we simply select the topology <italic toggle="yes">t</italic> with the maximum <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> value as the species tree. Maximizing the <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>θ</mml:mo><mml:mo>;</mml:mo><mml:mi mathvariant="bold">P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> function numerically is easy because it is twice differentiable and while it is not a convex function of <italic toggle="yes">d</italic> (the sign of its second derivative changes with different input parameters), we can prove (see <xref rid="app1" ref-type="app">Appendix A.1</xref>):<statement id="mthst2"><label><sc>Proposition</sc> 1.</label><p><italic toggle="yes">For a fixed</italic> <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">t</mml:mi><mml:mo stretchy="false">˜</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math></inline-formula><italic toggle="yes">, the</italic> <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">t</mml:mi><mml:mo stretchy="false">˜</mml:mo></mml:mover></mml:mrow><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>;</mml:mo><mml:mi mathvariant="bold">P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>  <italic toggle="yes">function (5) can have only one maximizer for</italic> <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>d</mml:mi><mml:mo>&lt;</mml:mo><mml:mo>∞</mml:mo></mml:mrow></mml:math></inline-formula>.</p></statement></p>
        <p>Thus, we can seek the global maximum of <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>;</mml:mo><mml:mi mathvariant="bold">P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for each <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> by simple numerical search using any modern optimizer package. We use <monospace>scipy.optimize</monospace> package with the constraint <italic toggle="yes">d </italic>&gt;<italic toggle="yes"> </italic>0 imposed using the trust-region constrained algorithm (<xref rid="btac265-B10" ref-type="bibr">Conn <italic toggle="yes">et al.</italic>, 2000</xref>). To help faster convergence, we provide the first and second derivatives of <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>.</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to the optimizer, as shown in <xref rid="app1" ref-type="app">Appendix A.1.1</xref>. Finally, we add a small pseudo-count of <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>8</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> to every element of <bold>P</bold> and normalize it appropriately.</p>
      </sec>
      <sec>
        <label>2.1.2</label>
        <title>Gene tree updates</title>
        <p>Once a species tree <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mo>θ</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is inferred, QuCo updates the gene tree posterior distribution to:
<disp-formula id="E8"><label>(6)</label><mml:math id="M8" display="block" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>.</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mn>3</mml:mn></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>.</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is computed using (2). This update is what makes the method a co-estimation. Note that this approach is not an iterative method switching between updating gene tree topologies and re-estimating species trees; if attempted, the gene tree updates can only increase the probability of the selected species tree compared to the alternative topologies, and will not lead to a change in the next iteration.</p>
      </sec>
      <sec>
        <label>2.1.3</label>
        <title>More than four species</title>
        <p>To move beyond four species, QuCo uses a heuristic supertree approach that ignores the dependency between quartets and analyzes them independently. We first select a set of quartets such that the resolution of all these quartets (perhaps in addition to auxiliary information such as a guide tree) is sufficient to infer the species tree. The simplest choice is to select all <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>n</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>4</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> quartets but we describe an alternative below. Once the set of quartets is selected, QuCo induces all trees in the MCMC samples of all <italic toggle="yes">k</italic> gene trees down to each selected quartet to compute the quartet posterior probabilities. Thus, for each quartet, a <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mn>3</mml:mn><mml:mo>×</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> matrix is obtained. Note that this step, while conceptually simple, needs to process a very large number of trees and thus needs to be implemented with care to obtain high efficiency. Next, for each quartet, we infer the maximum likelihood species tree as described earlier, obtaining a set of quartet species trees. The last step is to combine all the quartet species trees into a full tree using a quartet amalgamation method. While any such method can be used for this step, we will use ASTRAL (as a supertree method, not as a gene summary method) and will show that using wMaxCut (<xref rid="btac265-B3" ref-type="bibr">Avni <italic toggle="yes">et al.</italic>, 2015</xref>) generates very similar results.</p>
        <p><italic toggle="yes">Sampling quartets</italic>. For sufficiently small datasets (e.g. &lt;50 species), we afford to examine all the quartets. For larger input, we use a two-step approach. We first run ASTRAL on input gene trees, defined for each gene as the majority-rule consensus (MRC) of the trees in the input distribution for that gene. Next, we contract all the branches in the ASTRAL tree with local-pp support (<xref rid="btac265-B45" ref-type="bibr">Sayyari and Mirarab, 2016b</xref>) less than a threshold (default: 1.0). We then use an algorithm to sample quartets around polytomies of the resulting multifurcating guide tree, and this strategy focuses the quartet sampling on difficult parts of the tree. For a multifucating node <italic toggle="yes">u</italic> of degree <italic toggle="yes">d</italic>, we sample a single species from each side of <italic toggle="yes">u</italic> (or a uniformly sampled set of 12 sides when <italic toggle="yes">d </italic>&gt;<italic toggle="yes"> </italic>12), and choose all quartets made with sampled species. To choose a species on each side, we use probabilistic sampling: Rooting the tree at <italic toggle="yes">u</italic>, we traverse the tree to reach a leaf, at each node choosing a child uniformly at random. The closer the leaf is to the polytomy, the higher the chance we sample it. We repeat the sampling procedure many times, and by default, reduce the rounds proportionally to the degree <italic toggle="yes">d</italic> (default number of rounds: <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mn>1200</mml:mn><mml:mo>/</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>). Note that since each round generates <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>d</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>4</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> quartets for <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mi>d</mml:mi><mml:mo>≤</mml:mo><mml:mn>12</mml:mn></mml:mrow></mml:math></inline-formula>, we perform fewer rounds for larger <italic toggle="yes">d</italic>. In the end, in addition to the QuCo-resolved species tree quartets, we give the multifurcating guide tree to the subsequent supertree method (e.g. ASTRAL) as input. Thus, in effect, we use QuCo to resolve polytomies of the input guide tree.</p>
      </sec>
    </sec>
    <sec>
      <title>2.2 Simulations</title>
      <sec>
        <label>2.2.1</label>
        <title>New simulation datasets and protocols</title>
        <p><italic toggle="yes">Felsenstein’s zone</italic>. Long branch attraction is among the most challenging sources of systematic bias in phylogenomics (<xref rid="btac265-B6" ref-type="bibr">Brinkmann <italic toggle="yes">et al.</italic>, 2005</xref>; <xref rid="btac265-B20" ref-type="bibr">Jeffroy <italic toggle="yes">et al.</italic>, 2006</xref>), and <xref rid="btac265-B42" ref-type="bibr">Roch <italic toggle="yes">et al.</italic> (2019)</xref> have shown that both summary methods and concatenation are inconsistent under conditions that induce LBA. Thus, we perform simulation studies close to the Felsenstein zone (<xref rid="btac265-B16" ref-type="bibr">Felsenstein, 1978</xref>) to assess the resiliency of our method to LBA. To do so, we designed a way of simulating gene trees that tend to be in Felsenstein’s zone. First, gene trees in coalescent units are generated according to MSC on a fixed balanced species quartet tree (<xref rid="btac265-F1" ref-type="fig">Fig. 1a</xref>). Each branch of the species tree has one of two mutation rates μ<sub><italic toggle="yes">s</italic></sub> and μ<sub><italic toggle="yes">l</italic></sub> assigned to it. Each gene tree branch length is multiplied by the rates of corresponding species branches (a gene tree branch may cover one to three species tree branches) to obtain their length in substitution units. We set μ<sub><italic toggle="yes">s</italic></sub> and μ<sub><italic toggle="yes">l</italic></sub> so that two non-sister terminal branches (B and D) and the internal branch in the unrooted gene trees share a short expected length <italic toggle="yes">s</italic> and the other two terminal branch lengths have expected length <italic toggle="yes">l</italic>. Setting μ<sub><italic toggle="yes">s</italic></sub> and μ<sub><italic toggle="yes">l</italic></sub> properly requires a lemma (proved in <xref rid="app1" ref-type="app">Appendix A.2</xref>):</p>
        <fig position="float" id="btac265-F1">
          <label>Fig. 1.</label>
          <caption>
            <p>Felsenstein’s zone simulation. (<bold>a</bold>) Each gene tree branch length is scaled by μ<sub><italic toggle="yes">s</italic></sub> and/or μ<sub><italic toggle="yes">l</italic></sub>; for example, the length of the terminal branch of <italic toggle="yes">C</italic> becomes <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. Rates μ<sub><italic toggle="yes">s</italic></sub> and μ<sub><italic toggle="yes">l</italic></sub> are selected such that terminal branches of A and C in the unrooted gene tree have expected length <italic toggle="yes">l</italic>, and other branches have expected length <italic toggle="yes">s</italic>, as shown. (<bold>b</bold>) MAP gene trees estimated using MrBayes with simulations in Felsenstein’s zone can have large estimation error, especially when <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>/</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> is high and sequence lengths (boxes) are short</p>
          </caption>
          <graphic xlink:href="btac265f1" position="float"/>
        </fig>
        <statement id="mthst3">
          <label>Lemma 2.</label>
          <p><italic toggle="yes">Under MSC, for a balanced quartet species tree with internal branch lengths</italic> <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mfrac><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:math></inline-formula>  <italic toggle="yes">(<xref rid="btac265-F1" ref-type="fig">Fig. 1a</xref>), the expected length of terminal branch lengths in unrooted gene trees above the speciation nodes is</italic> <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
        </statement>
        <p>Let τ<sub>1</sub> be the fixed coalescent unit terminal branch lengths for all species, and let μ<sub><italic toggle="yes">l</italic></sub> and μ<sub><italic toggle="yes">s</italic></sub> be mutation rates assigned to the tree as shown in <xref rid="btac265-F1" ref-type="fig">Figure 1</xref>. The expected substitution unit length of terminal branches of A and C (<italic toggle="yes">l</italic>) and terminal branches of B and D (<italic toggle="yes">s</italic>) are: <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Thus, we assign <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mi>s</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula> so that the expected branch lengths are as desired. Finally, note that the expected length of the internal unrooted gene tree branch is 1 in coalescent units and μ<sub><italic toggle="yes">s</italic></sub> in substitution units. To force the expected internal branch length in substitution units to be also <italic toggle="yes">s</italic> (as in Felsenstein’s zone), we need to set <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mn>3</mml:mn></mml:mfrac></mml:mrow></mml:math></inline-formula>.</p>
        <p>With this setting, each simulation is parameterized by the coalescent unit internal branch <italic toggle="yes">d</italic> (controlling amount of ILS) and expected length of long and short terminal branches, <italic toggle="yes">l</italic>, <italic toggle="yes">s</italic>, respectively. LBA is expected for high <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>/</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>. We used this simulator to create very hard conditions meant to break methods. We vary <italic toggle="yes">l</italic>, <italic toggle="yes">s</italic>, and <italic toggle="yes">d</italic> in 48 combinations, each with 20 replicate runs. We set <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mi>d</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0.1</mml:mn><mml:mo>,</mml:mo><mml:mn>0.2</mml:mn><mml:mo>,</mml:mo><mml:mn>0.3</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, which corresponds to 40%, 45%, and 51% of gene trees matching the species tree. We use the Dendropy package (<xref rid="btac265-B48" ref-type="bibr">Sukumaran and Holder, 2010</xref>) to simulate 500 gene trees (simulated trees are called <italic toggle="yes">true</italic> gene trees hereafter) under neutral coalescent model conditioned on a species tree shown in <xref rid="btac265-F1" ref-type="fig">Figure 1</xref>. For each <italic toggle="yes">d</italic>, we consider 16 combinations of short and long branch lengths: <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0.01</mml:mn><mml:mo>,</mml:mo><mml:mn>0.02</mml:mn><mml:mo>,</mml:mo><mml:mn>0.04</mml:mn><mml:mo>,</mml:mo><mml:mn>0.08</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0.1</mml:mn><mml:mo>,</mml:mo><mml:mn>0.2</mml:mn><mml:mo>,</mml:mo><mml:mn>0.3</mml:mn><mml:mo>,</mml:mo><mml:mn>0.4</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and convert gene tree branch lengths to substitution units, as described earlier. Then, we use INDELible (<xref rid="btac265-B17" ref-type="bibr">Fletcher and Yang, 2009</xref>) to simulate sequences down these trees, setting the sequence length to 200, 400, 800, and 1600 bp. Thus, in total, we have 48 × 4 = 192 model conditions, 3840 replicates, and 1 920 000 gene trees. We infer gene trees using MrBayes and ensure convergence by checking the average SDs of split frequencies, which is less than 0.08 for all runs with 99 percentile equal to 0.025.</p>
        <p>We compare QuCo to ASTRAL and BUCKy-quartet (<xref rid="btac265-B22" ref-type="bibr">Larget <italic toggle="yes">et al.</italic>, 2010</xref>). BUCKy has been shown to have accuracy similar to MSC-based co-estimation methods (<xref rid="btac265-B9" ref-type="bibr">Chung and Ané, 2011</xref>). As input to ASTRAL, we use maximum <italic toggle="yes">a posteriori</italic> (MAP) MrBayes. Gene trees estimated using MrBayes from simulated alignments can have high rates of error, depending on <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>/</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> and sequence length (<xref rid="btac265-F1" ref-type="fig">Fig. 1b</xref>). Note that a random selection of tree topology will still be correct 1/3 of times; thus, the MAP gene trees have more error (due to LBA bias) than randomly estimated trees in some conditions. Moreover, incorrect gene trees are not randomly distributed but are heavily biased towards putting long terminals (A and C) together. Thus, conditions with gene tree error above 1/3 are particularly difficult. Note that here, the ASTRAL tree is equivalent to the most common topology among the MAP gene trees.</p>
        <p><italic toggle="yes">Anomaly zone</italic>. We simulate a dataset with a 6-taxon caterpillar species tree that based on the calculations presented by <xref rid="btac265-B13" ref-type="bibr">Degnan (2013)</xref> is in both rooted and unrooted anomaly zone (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S2</xref>). The anomaly zone refers to species trees that define gene tree distributions where the most likely gene tree is different from the species tree and may present a particularly challenging part of the parameter space (<xref rid="btac265-B14" ref-type="bibr">Degnan and Rosenberg, 2006</xref>). To make the dataset more realistic, we also create deviations from ultrametricity. We assign substitution unit branch lengths to gene trees by multiplying each coalescent unit length by overall rate 0.02 and a rate multiplier sampled independently from a Gamma distribution with shape and scale set to 5 and 1/5 (mean: 1, variance: 1/5). We generate 10 000 gene trees in total and use INDELible to simulate 600-bp sequences down these trees. We run MrBayes separately on each of these sequences and check convergence by checking the average SDs of split frequencies, which are less than 0.015 for all runs. We divide the 10 000 genes into 50 replicates of 10, 50, 100, and 200 genes, 20 replicates of 500 genes, 10 replicates of 1000 genes, or five replicates of 2000 genes. For each replicate, we run QuCo on all 15 quartets of species and combine them using the exact ASTRAL.</p>
      </sec>
      <sec>
        <label>2.2.2</label>
        <title>Existing datasets</title>
        <p><italic toggle="yes">30-taxon datasets</italic>. We reuse a dataset simulated by <xref rid="btac265-B27" ref-type="bibr">Mai and Mirarab (2017)</xref> using Simphy (<xref rid="btac265-B28" ref-type="bibr">Mallo <italic toggle="yes">et al.</italic>, 2016</xref>) with three model conditions, and 500 genes, each with 50 replicates (sampled out of 100 original replicates). The three conditions are differentiated by their level of deviations from the molecular clock, as controlled by α, which is the inverse of the variance of the rate multipliers applied to gene tree branch lengths. Because of difficulties in running MrBayes to convergence for all of the <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mn>3</mml:mn><mml:mo>×</mml:mo><mml:mn>500</mml:mn><mml:mo>×</mml:mo><mml:mn>50</mml:mn><mml:mo>=</mml:mo><mml:mn>75</mml:mn><mml:mo> </mml:mo><mml:mn>000</mml:mn></mml:mrow></mml:math></inline-formula> gene trees, we use IQ-TREE instead. We use IQ-TREE <monospace>-wql</monospace> option to compute the log-likelihood for all quartet topologies, which we then normalize and exponentiate to approximate posteriors and use as input to QuCo. See <xref rid="app1" ref-type="app">Appendix B.1</xref> in <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref> for exact commands. We run QuCo on all <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mn>30</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>4</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>27</mml:mn><mml:mo> </mml:mo><mml:mn>405</mml:mn></mml:mrow></mml:math></inline-formula> quartets and combine these quartet trees using ASTRAL or wMaxCut.</p>
        <p><italic toggle="yes">101-taxon datasets</italic>. We use one model condition of a dataset simulated by us and colleagues (<xref rid="btac265-B55" ref-type="bibr">Zhang <italic toggle="yes">et al.</italic>, 2018</xref>) with 101 taxa, 400-bp sequences, 200 genes, and 30 replicates sampled out of a total of 50 replicates, each with a distinct species tree. The species trees are simulated under the birth-only process with the birth rate <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>7</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, fixed haploid <italic toggle="yes">N</italic><sub>e</sub> of 400<italic toggle="yes">K</italic>, and the number of generations sampled from a log-normal distribution with the mean <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.5</mml:mn><mml:mi>M</mml:mi></mml:mrow></mml:math></inline-formula>. The average normalized RF distance between true species trees and true gene trees was in most replicates in the [0.3, 0.6] range, with an average of 0.46. The simulation process is similar to the 30-taxon dataset and uses Simphy and INDELible. We run two chains of MrBayes MCMC for 600 000 generations on each gene alignment. Here, we use the quartet sampling strategy described before.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <sec>
      <title>3.1 Simulation results</title>
      <sec>
        <label>3.1.1</label>
        <title>Felsenstein’s zone simulations</title>
        <p><italic toggle="yes">Topological accuracy</italic>. QuCo is at least as accurate as and in many conditions far more accurate than ASTRAL in finding the correct topology (<xref rid="btac265-F2" ref-type="fig">Fig. 2a</xref>). Across all conditions, QuCo finds the correct tree in 1953 out of 3840 replicates, whereas ASTRAL is correct in 1572 cases. The improvements are most clear in model conditions where <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>/</mml:mo><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula>. For example, with <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>0.2</mml:mn></mml:math></inline-formula> and 800-bp sequences, QuCo has 100% and 60% accuracy, respectively, with <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>0.3 and <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>0.2 compared to 65% and 10% for ASTRAL. When <italic toggle="yes">s</italic> and <italic toggle="yes">l</italic> are close, both ASTRAL and QuCo work well. For example, both methods recover the true species tree in all replicates when <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>/</mml:mo><mml:mi>s</mml:mi><mml:mo>≤</mml:mo><mml:mn>5</mml:mn><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> (top right corner) with <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>0.2 or <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>0.3 and in most cases for <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>0.1. On the other hand, when <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>/</mml:mo><mml:mi>s</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>20</mml:mn></mml:mrow></mml:math></inline-formula> (bottom left corner), even with 1600-bp sequences, neither method recovers true topology in any replicate; with <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>/</mml:mo><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>20</mml:mn></mml:mrow></mml:math></inline-formula>, QuCo recovers the true species tree between 5% and 70% of times if the sequence length is at least 800 bp, but ASTRAL continues to infer the wrong tree in every case.</p>
        <fig position="float" id="btac265-F2">
          <label>Fig. 2.</label>
          <caption>
            <p>Felsenstein’s zone quartet simulations comparing QuCo to ASTRAL (<bold>a</bold>) or Bucky-Quartet (<bold>b</bold>). Each box shows a combination of long <italic toggle="yes">l</italic> (rows) and short <italic toggle="yes">s</italic> branch lengths (columns), and colors delineate ILS level controlled by <italic toggle="yes">d</italic>. Each ribbon shows the improvement of QuCo over ASTRAL or BUCKy, all run on MrBayes gene trees. When the ribbon is patterned, BUCKy is better than QuCo</p>
          </caption>
          <graphic xlink:href="btac265f2" position="float"/>
        </fig>
        <p>Compared to BUCKy, QuCo shows improvements in many but not all conditions, and improvements are less substantial (<xref rid="btac265-F2" ref-type="fig">Fig. 2b</xref>). When ILS is lower (<italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>0.3), the two methods are identical or similar except in three <italic toggle="yes">l</italic>, <italic toggle="yes">s</italic> combinations where QuCo has a substantial advantage for 400 bp or longer alignments and one case where BUCKy has a small advantage with 400-bp alignments. Across all conditions with <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>0.3, QuCo is correct in 811 out of 1280 replicates tested, which is 3% higher than BUCKy (788). With <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>0.2, the two methods are similar to small advantages for QuCo in nine conditions out of 64 and for BUCKy in four conditions. With the highest level of ILS, QuCo and BUCKy are each substantially better in some conditions. Among all species trees tested, the number of times QuCo is correct is 50 times more than BUCKy.</p>
        <p>Consistently through all model conditions, longer sequences (hence more signal) in the gene trees result in more accurate species tree estimation, as expected. When sequence are as short as 200 bp, the correct topology is almost never recovered when <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>/</mml:mo><mml:mi>s</mml:mi><mml:mo>≥</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula>; with 400-bp alignments, all methods fail in most cases when <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>/</mml:mo><mml:mi>s</mml:mi><mml:mo>≥</mml:mo><mml:mn>15</mml:mn></mml:mrow></mml:math></inline-formula>. Even some difficult cases such as <italic toggle="yes">l </italic>=<italic toggle="yes"> </italic>0.3, <italic toggle="yes">s </italic>=<italic toggle="yes"> </italic>0.02 or <italic toggle="yes">l </italic>=<italic toggle="yes"> </italic>0.4, <italic toggle="yes">s </italic>=<italic toggle="yes"> </italic>0.04 are rescued when using QuCo and to a lesser degree using BUCKy as long as sequences are sufficiently long; in these conditions, the accuracy can go from zero up to one with <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>0.3. The impact of longer sequences is also clearly observed in conditions with moderate <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>/</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> (e.g. <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>5</mml:mn><mml:mo>×</mml:mo><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>0.1</mml:mn></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>5</mml:mn><mml:mo>×</mml:mo><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>0.2</mml:mn></mml:mrow></mml:math></inline-formula>) where close to perfect accuracy is obtained by QuCo and BUCKy but not ASTRAL with 1600-bp sequences even with <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>0.1.</p>
        <p>As expected, higher levels of ILS (i.e. lower <italic toggle="yes">d</italic>) make inference harder for both methods. There are, however, conditions where QuCo is quite robust to the level of ILS while ASTRAL is not. For example, for <italic toggle="yes">l </italic>=<italic toggle="yes"> </italic>0.3, <italic toggle="yes">s </italic>=<italic toggle="yes"> </italic>0.04, with 1600-bp sequences, QuCo has 70% accuracy for the highest ILS level and 100% in the other cases. In contrast, ASTRAL accuracy degrades with increased ILS (perfect for <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>0.3, 85% for <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>0.2, and 20% for <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>0.1).</p>
        <p><italic toggle="yes">Branch lengths</italic>. To evaluate the branch length accuracy, we report the ratio between <italic toggle="yes">d</italic> estimated by QuCo or ASTRAL to the true branch length, only considering cases where the species tree topology is correct. QuCo branch lengths are much closer to true branch lengths than ASTRAL branch lengths with all sequence lengths (<xref rid="btac265-F3" ref-type="fig">Fig. 3</xref>). The under-estimation bias of ASTRAL branch lengths as a result of inaccurate gene trees, as shown by <xref rid="btac265-B45" ref-type="bibr">Sayyari and Mirarab (2016b</xref>), is vastly reduced by QuCo. With the most difficult model conditions, both methods under-estimate the internal branch length while QuCo produces far more accurate estimates. In most model conditions, longer sequences help QuCo to estimate more accurate branch lengths. However, when <italic toggle="yes">s </italic>=<italic toggle="yes"> </italic>0.08, QuCo can surprisingly <italic toggle="yes">over</italic>-estimate branch lengths by 12% with <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mo>≥</mml:mo></mml:math></inline-formula>800-bp data.</p>
        <fig position="float" id="btac265-F3">
          <label>Fig. 3.</label>
          <caption>
            <p>Branch length accuracy on Felsenstein’s zone simulations, showing the distribution of estimated branch length divided by true branch length for correctly estimated species tree (the number of such cases shown in each case). Lines show the four quartiles and the dot shows the mean. Each box corresponds to a value of <italic toggle="yes">s</italic>, combining all <italic toggle="yes">l</italic> values. See <xref rid="sup1" ref-type="supplementary-material">Supplementary Figure S5</xref> for better resolution</p>
          </caption>
          <graphic xlink:href="btac265f3" position="float"/>
        </fig>
        <p><italic toggle="yes">Gene tree error</italic>. We evaluate gene tree accuracy by comparing how often the MAP estimate is correct before or after the co-estimation update step performed by QuCo using <xref rid="E8" ref-type="disp-formula">Equation (6)</xref>. Unlike universal improvements in the species tree accuracy, the gene tree accuracy of QuCo is mixed (<xref rid="btac265-F4" ref-type="fig">Fig. 4</xref>). The quartet gene trees produced by QuCo are better than the original MAP gene trees under most conditions where the species trees are improved compared to ASTRAL and under most ‘easy’ conditions where both ASTRAL and QuCo find the correct tree. However, under the most challenging conditions where neither method can find the correct species tree (e.g. for <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>/</mml:mo><mml:mi>s</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>20</mml:mn></mml:mrow></mml:math></inline-formula>), the QuCo gene trees are <italic toggle="yes">less</italic> accurate than the raw MAP trees. Note that co-estimation by QuCo first computes the species tree and then strictly increases the probability for gene tree topologies that match the species tree at the expense of those that disagree with it. Thus, a reduced gene tree accuracy with incorrect species trees can be expected.</p>
        <fig position="float" id="btac265-F4">
          <label>Fig. 4.</label>
          <caption>
            <p>Gene tree estimation error on Felsenstein’s zone simulations. Each dot corresponds to one model condition, with the <italic toggle="yes">x</italic>-axis showing the improvement in species tree accuracy by QuCo compared to ASTRAL and the <italic toggle="yes">y</italic>-axis showing the improvement in the average gene tree accuracy for all genes. The size of dots corresponds to the accuracy of ASTRAL species trees</p>
          </caption>
          <graphic xlink:href="btac265f4" position="float"/>
        </fig>
      </sec>
      <sec>
        <label>3.1.2</label>
        <title>Anomaly zone</title>
        <p>We next test the 6-taxon anomaly zone dataset, where we report the portion of true branches missing in the estimated tree (which is equal to the normalized RF distance because all trees are fully resolved). Here, the error is high for all methods when given tens of genes but decreases quickly when the number of genes increases to hundreds (<xref rid="btac265-F5" ref-type="fig">Fig. 5</xref>). As we go to large numbers of genes, we get to zero error with all methods. ASTRAL run on MAP gene trees is slightly less accurate than BUCKy and QuCo, which have similar levels of accuracy. Interestingly, running ASTRAL on MRC gene trees improves its accuracy to levels that match or surpass BUCKy and QuCo.</p>
        <fig position="float" id="btac265-F5">
          <label>Fig. 5.</label>
          <caption>
            <p>Species tree topological error (mean, standard error) under anomaly zone simulations versus the number of genes</p>
          </caption>
          <graphic xlink:href="btac265f5" position="float"/>
        </fig>
      </sec>
      <sec>
        <label>3.1.3</label>
        <title>30-taxon datasets</title>
        <p>Here, instead of MrBayes, we run QuCo on maximum likelihood (ML) IQ-TREE gene trees. On the larger 30-taxon dataset, depending on the model condition, QuCo+IQ-TREE either matches or improves on the accuracy of ASTRAL+IQ-TREE (<xref rid="btac265-F6" ref-type="fig">Fig. 6</xref>). Note that testing BUCKy was not possible for these larger data. The improvements are obtained both for conditions with high and low deviations from the strict clock but are less clear for conditions with moderate deviations. When deviations are high, accuracy improves as a result of increasing the number of gene trees from 200 to 500 for both methods, but the improvements are larger for QuCo (from mean error of 11% to 7% versus from 12% to 10%). Note that the inputs to ASTRAL and QuCo are not identical in this experiment: The ML gene trees are inferred from the entire set of species, whereas quartet tree likelihoods are inferred per quartet. Thus, it is reasonable to expect the input to QuCo to be more prone to LBA than ASTRAL, making it more remarkable that it has a lower error in its output.</p>
        <fig position="float" id="btac265-F6">
          <label>Fig. 6.</label>
          <caption>
            <p>30-taxon dataset. Left: Comparison of the error rate of the species tree generated by running ASTRAL on IQ-Tree ML gene trees and QuCo on IQ-Tree quartet likelihoods with 200 and 500 genes of 30-taxon dataset. The <italic toggle="yes">x</italic>-axis shows deviation from clock represented by parameter α (inverse of the variance of rate multipliers). Each box is over 50 replicates</p>
          </caption>
          <graphic xlink:href="btac265f6" position="float"/>
        </fig>
        <p>On this dataset, we also compare ASTRAL and wMaxCut as supertree methods for the step where quartet species trees are combined (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S3</xref>). The two ways of combining the quartets are similar to ASTRAL performing slightly better (worse) for low (high) deviations from the clock. We use ASTRAL as the default supertree method elsewhere.</p>
      </sec>
      <sec>
        <label>3.1.4</label>
        <title>The large 101-taxon dataset</title>
        <p>On the larger dataset, where the sampling strategy is necessary, the number of internal nodes in the ASTRAL guide trees ranges from 69 to 84 (mean 78) compared to 99 nodes for a fully resolved tree. Our sampling strategy selects between 3127 and 51 272 quartets (mean: 22 508), which we resolve using QuCo. The polytomies range from small (degree 4) to a maximum degree of 19 (mean: 5), and the guide trees have no incorrect branches. After the polytomies of the guide tree are refined using QuCo, we observe a 12% decrease in the average topological error (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>) compared to the original ASTRAL tree run on MrBayes MRC gene trees and a 40% decrease compared to ASTRAL run on Fasttree gene trees with branches with bootstrap support below 10% contracted, which is our recommended setting from <xref rid="btac265-B55" ref-type="bibr">Zhang <italic toggle="yes">et al.</italic> (2018)</xref>. Note that here MAP becomes impossible to estimate; thus, we use the MRC summary instead.</p>
      </sec>
    </sec>
    <sec>
      <title>3.2 Application on a biological dataset</title>
      <p>We test QuCo on the dataset of <italic toggle="yes">Pseudapis</italic> genus of bees of <xref rid="btac265-B5" ref-type="bibr">Bossert <italic toggle="yes">et al.</italic> (2021)</xref> with 32 species and 1291 UCEs from the subfamily <italic toggle="yes">Nomiinae</italic> (Halictidae). We use the MrBayes posterior estimations from the original study and run QuCo on all 35 960 quartets. Then, we combine quartets using ASTRAL and enrich its search space with 853 IQ-TREE gene trees.</p>
      <p>The species tree that we recover by running QuCo matches the ASTRAL tree reported by <xref rid="btac265-B5" ref-type="bibr">Bossert <italic toggle="yes">et al.</italic> (2021)</xref> on gene trees created using Phylobayes, which is designed to reduce LBA (<xref rid="btac265-B23" ref-type="bibr">Lartillot <italic toggle="yes">et al.</italic>, 2007</xref>). <xref rid="btac265-B5" ref-type="bibr">Bossert <italic toggle="yes">et al.</italic> (2021)</xref> have reported 30 ASTRAL trees from gene trees created by ML and Bayesian methods, and these trees differ in five areas compared to the concatenation tree. The tree reported by QuCo differs from concatenation in two nodes and is identical for the other nodes (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S4</xref>) and also differs from ASTRAL on MrBayes in one of those two nodes. These two nodes involve the two samples with the worst sequencing success, <italic toggle="yes">Ruginomia rugiventris</italic> and <italic toggle="yes">Stictonomia schubotzi</italic>. Both of these taxa have over 75% undetermined positions in the concatenated matrix and are present in less than half of all loci, making them hard to place.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>We introduced the algorithm QuCo for quartet co-estimation of species trees and gene trees. We showed that QuCo had better accuracy than ASTRAL in quartet simulations with LBA. By considering gene tree uncertainty, QuCo also outperformed ASTRAL under the anomaly zone simulations when the number of genes was limited. It can be easily proved that if all <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> values are either 0 or 1 (i.e. in the absence of gene tree estimation uncertainty), QuCo is equivalent to picking the most frequent quartet as the species tree, as is done in ASTRAL. The improvements, then, are a result of considering gene tree uncertainty. As the number of genes increased, better handling of uncertainty appeared to be less consequential as QuCo and ASTRAL converged in accuracy in the anomaly zone simulations. Compared to the alternative co-estimation method BUCKy, QuCo had a small advantage in accuracy; however, note that BUCKy has limited scalability (<xref rid="btac265-B54" ref-type="bibr">Yang and Warnow, 2011</xref>).</p>
    <p>Despite the fact that the method first infers gene trees independently, it is a co-estimation method because the species tree maximizes the joint likelihood marginalized over all possible gene tree topologies. This marginalization was computationally tractable because we consider quartets independently and can use a simple <xref rid="E2" ref-type="disp-formula">Equation (2)</xref> for the likelihood. The likelihood of gene trees for more taxa is much harder to compute and requires exponential time (<xref rid="btac265-B53" ref-type="bibr">Wu, 2012</xref>). Alternatively, one can assign branch lengths to gene trees in the same unit as the species tree to make likelihood calculation fast. However, this imposes a different challenge: the need to assume a distribution for mutation rates and population sizes, which further increases the number of parameters that need to be sampled. Many co-estimation methods side-step this challenge by assuming a strict molecular clock, an assumption that decades of research has proved problematic.</p>
    <p>By focusing on gene tree topologies and species tree branch length in the coalescent unit, we avoid using a strict gene tree clock model while making the problem <italic toggle="yes">easier</italic> to solve (i.e. requiring fewer parameters). Our approach did require assuming the independence of substitution branch lengths from the species tree topology and internal branch length. This assumption, which is probably violated on all biological datasets, can be understood as ignoring the shared information about branch lengths across genes. Thus, it makes the co-estimation less powerful than a method that does consider correlation between branch lengths, especially if it can do so under a correct model of rate evolution. However, we note that none of our experimental tests made any such assumptions. Thus, the high empirical performance of the method indicates these assumptions are not lethal; they just may reduce the power of the method in exchange for scalability. Furthermore, the caveat in working with topologies is that QuCo does not output gene tree branch lengths. Moreover, using topologies makes the likelihood calculations fast for four species, and going beyond four species requires the heuristic supertree approach. Thus, our simplifying assumptions have the benefits of: (i) freeing us from assuming restrictive models of rate change across the tree, and (ii) fast calculations of likelihood; however, they also render our method more heuristic than full Bayesian co-estimation methods.</p>
    <p>Interestingly, while QuCo clearly increased species tree accuracy, it appeared less effective in increasing gene tree accuracy, especially when the species tree was not improved. This trend is in contrast to some of the existing co-estimation methods, such as the iterative method of <xref rid="btac265-B52" ref-type="bibr">Wang and Nakhleh (2018)</xref>, that are effective in increasing the gene tree accuracy but less so in terms of the species tree. While these patterns call for further study in the future, two points should be emphasized. By marginalizing over gene tree distribution, QuCo can improve the species tree, even when the maximum likelihood gene tree (given the species tree) is not improved. Moreover, when QuCo fails to improve the quartet species tree, it has no chance of improving the gene tree, and in fact, it likely degrades it. Finally, note that QuCo essentially generates a distribution over topologies for each quartet in each gene tree. When more than four species are available, a quartet amalgamation method such as wMaxCut needs to be used to compute the final updated gene trees.</p>
    <p>The scalability of QuCo comes from the fact that the inference for each quartet is fast. Given the <bold>P</bold> matrix, the optimization step takes a fraction of a second per quartet. Even on the 30-taxon data, the optimization step takes close to 1 h across all 27 405 quartets. Given MrBayes outputs, computing <bold>P</bold> is conceptually easy, and with appropriate implementation, can be fast (with I/O being the bottleneck). The entire running time, including the I/O heavy calculation of <bold>P</bold>, is still reasonably fast. For example, for the biological dataset with 32 species, QuCo took 12 h to analyze all 35 960 quartets across 1200 genes with no parallelization (mostly calculation of <bold>P</bold>). This can be run in parallel; using 80 cores, 13 min is enough to analyze all quartets. The final step of combining the quartet trees is also fast, taking 36 s using ASTRAL and only a couple of seconds using wMaxCut. The more time-consuming part of the pipeline, by far, is to run MrBayes on all gene trees. However, this step can be done in parallel and is much more manageable than co-estimation. For example, <xref rid="btac265-B5" ref-type="bibr">Bossert <italic toggle="yes">et al.</italic> (2021)</xref> reported that each MrBayes run on 32 taxa took 6.7 min on average. Running methods like MrBayes on thousands of genes with hundreds of species is doable. For even larger datasets where MrBayes may not scale, our results showed that using IQ-TREE quartet likelihoods, which are extremely fast to compute, can be very accurate. To summarize, 101-taxon is by no means the limit of the method.</p>
    <p>Analyzing a large number of taxa (e.g. beyond 50) requires quartet selection strategies instead of using all <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>n</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>4</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> quartets. Quartet subsampling is a problem that has been studied in the literature (<xref rid="btac265-B12" ref-type="bibr">Davidson <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btac265-B47" ref-type="bibr">Snir <italic toggle="yes">et al.</italic>, 2008</xref>) and solutions with quadratic (<xref rid="btac265-B44" ref-type="bibr">Sayyari and Mirarab, 2016a</xref>) or even quasi-linear (<xref rid="btac265-B7" ref-type="bibr">Brown and Truszkowski, 2011</xref>) numbers of quartets have been proposed. We left the exploration of such approaches to the future. Instead, we tried a simple method where a guide tree (here, ASTRAL) is estimated and uncertain branches are contracted. The polytomies left in the tree are the difficult parts of the tree, hence our desire to focus the quartet sampling around the polytomies. Our probabilistic leaf sampling strategy uses the well-established insight that short quartets (those with leaves closer to the polytomy) are easier to resolve correctly than long quartets (<xref rid="btac265-B15" ref-type="bibr">Erdos <italic toggle="yes">et al.</italic>, 1999</xref>; <xref rid="btac265-B47" ref-type="bibr">Snir <italic toggle="yes">et al.</italic>, 2008</xref>). While our sampling strategy proved effective, we believe better methods may be possible, including those that would guarantee that the number of quartets increases quasi-linearly or quadratically with the number of species.</p>
  </sec>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>The data underlying this article are available in GitLab at <ext-link xlink:href="https://gitlab.com/mrabiee/quo-data" ext-link-type="uri">https://gitlab.com/mrabiee/quo-data</ext-link>.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work has been supported by the NSF (IIS-1845967) to S.M. and M.R. Computations were performed through XSEDE allocations, which is supported by the NSF (ACI-1053575).</p>
    <p><italic toggle="yes">Conflict of Interest</italic>: none declared.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btac265_Supplementary_Data</label>
      <media xlink:href="btac265_supplementary_data.zip">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <app-group>
    <app id="app1">
      <title>Appendix</title>
      <sec>
        <title>A.1 Likelihood maximization</title>
        <statement id="mthst4">
          <label><sc>Proof of Proposition</sc> 1.</label>
          <p>We can rewrite (5) without the logarithm as
<disp-formula id="E9"><mml:math id="M9" display="block" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">D</mml:mi><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mo>β</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mi>x</mml:mi><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>β</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mo>β</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>. Since α<sub><italic toggle="yes">i</italic></sub>s and β<sub><italic toggle="yes">i</italic></sub>s are constant, <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">D</mml:mi><mml:mo>;</mml:mo><mml:mo>θ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a polynomial in <italic toggle="yes">x</italic> and can have at most <italic toggle="yes">k</italic> roots of the form
<disp-formula id="E10"><mml:math id="M10" display="block" overflow="scroll"><mml:mrow><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mo>β</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mo>β</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>β</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula>and <italic toggle="yes">k</italic>−1 local optima that must each be between two roots. Note that only valid values of <italic toggle="yes">x</italic> in our optimization are <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>x</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> corresponding to <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>d</mml:mi><mml:mo>&lt;</mml:mo><mml:mo>∞</mml:mo></mml:mrow></mml:math></inline-formula>. Thus, we are interested in local optima in that region. However, every root of the form shown is negative when <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:mo>&lt;</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> and is &gt;1 for <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:mo>&lt;</mml:mo><mml:msub><mml:mrow><mml:mo>β</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Thus, none the roots are in the <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>x</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> region we are interested in. Since the polynomial has no root in 0 to 1, it can have only one local optimum in that region. Note also that <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>→</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>→</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> both result in non-negative likelihood values, and thus, there must be one valid maximizer to the function.</p>
        </statement>
        <sec>
          <title>A.1.1 Derivatives</title>
          <p>The derivatives of the log likelihood function are given to the optimizer:
<disp-formula id="E11"><mml:math id="M11" display="block" overflow="scroll"><mml:mtable><mml:mtr><mml:mtd><mml:mi>l</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold">P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mrow><mml:mfrac><mml:mrow><mml:mn>3</mml:mn><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mi>d</mml:mi></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>l</mml:mi><mml:mo>″</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>;</mml:mo><mml:mi mathvariant="bold">P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mrow><mml:mfrac><mml:mrow><mml:mn>3</mml:mn><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mi>d</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mn>3</mml:mn><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mi>d</mml:mi></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p>
        </sec>
      </sec>
      <sec>
        <title>A.2 Simulating long branch attraction with MSC</title>
        <statement id="mthst5">
          <label><sc>Proof (sketch), Lemma</sc> 2.</label>
          <p>Recall the balanced quartet tree with length <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:mfrac><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:math></inline-formula> above the two speciation nodes as shown in <xref rid="btac265-F1" ref-type="fig">Figure 1</xref>. By symmetry, all terminal branches have the same length in coalescent units. W.l.o.g., we take branch <italic toggle="yes">A</italic>. Recall that the probability density function for the coalescence of two lineages in time <italic toggle="yes">t</italic> before present is given by <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> in coalescent time units. We compute the expectation by conditioning on three scenarios: (<italic toggle="yes">I</italic>) lineages <italic toggle="yes">A</italic> and <italic toggle="yes">B</italic> coalesce before the root, (<italic toggle="yes">II</italic>) lineage <italic toggle="yes">A</italic> and <italic toggle="yes">B</italic> do not coalesce before the root but lineage <italic toggle="yes">C</italic> and <italic toggle="yes">D</italic> do, and (<italic toggle="yes">III</italic>) neither lineage <italic toggle="yes">A</italic> and <italic toggle="yes">B</italic> nor lineages <italic toggle="yes">C</italic> and <italic toggle="yes">D</italic> coalesce before the root. Let <italic toggle="yes">c</italic><sub>3</sub> and <italic toggle="yes">c</italic><sub>4</sub> be the expected time to coalescence between <italic toggle="yes">A</italic> and another branch among three and four branches in total, respectively. Then, the expected length of terminal branch of <italic toggle="yes">A</italic> above its common ancestor with <italic toggle="yes">B</italic> in the species tree is:
<disp-formula id="E12"><mml:math id="M12" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mover><mml:mrow><mml:mover><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mn>0</mml:mn><mml:mrow><mml:mfrac><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:msubsup><mml:mi>t</mml:mi></mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msup><mml:mi mathvariant="normal">d</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:mo stretchy="true">︷</mml:mo></mml:mover></mml:mrow><mml:mi mathvariant="normal">I</mml:mi></mml:mover></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mover><mml:mrow><mml:mover><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mfrac><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mfrac><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mfrac><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">︷</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mtext>II</mml:mtext></mml:mrow></mml:mover></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mover><mml:mrow><mml:mover><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mfrac><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mfrac><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">︷</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mtext>III</mml:mtext></mml:mrow></mml:mover></mml:mrow></mml:mrow></mml:math></disp-formula></p>
        </statement>
        <p>The first term simply follows from the definition of expectation. The second and third terms first compute the probability of lack of coalescence (<inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>d</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>) on one or both sides, and multiple by the expected length in each case. The <italic toggle="yes">c</italic><sub>3</sub> and <italic toggle="yes">c</italic><sub>4</sub> terms give the expected length in the root (by definition) and <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:mi>d</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> is added to account for the length on the branch above common ancestor of <italic toggle="yes">A</italic> and <italic toggle="yes">B</italic>. We compute <italic toggle="yes">c</italic><sub>3</sub> again using conditional expectation:
<disp-formula id="E13"><mml:math id="M13" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac><mml:mfrac><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></disp-formula></p>
        <p>The first term conditions on <italic toggle="yes">A</italic> being the first lineage to coalesce with another (probability <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:mfrac><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>), and uses the fact that the expected length of the first coalescent among <italic toggle="yes">N</italic> lineages is <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>N</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>. The second term is conditioned on <italic toggle="yes">A</italic> not being the first lineage to coalesce with another and is computed similarly. In this scenario, <italic toggle="yes">A</italic> will continue for the first coalescent event (length<inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>), up to the final coalescence <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>; we also need to add the length of the branch to the other side of the deepest coalescence because we are dealing with unrooted trees. With similar logic, we can compute:
<disp-formula id="E14"><mml:math id="M14" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>6</mml:mn></mml:mrow></mml:mfrac><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>6</mml:mn></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>6</mml:mn></mml:mrow></mml:mfrac><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>6</mml:mn></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula>where the three terms correspond to <italic toggle="yes">A</italic> being the first, the second, and the last branch to coalesce. Replacing these terms in the first equation, we get the expectation equals:
<disp-formula id="E15"><mml:math id="M15" display="block" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mfrac><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mfrac><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mfrac><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mfrac><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mfrac><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mfrac><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mn>3</mml:mn></mml:mfrac></mml:mrow></mml:math></disp-formula></p>
      </sec>
    </app>
  </app-group>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btac265-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Allman</surname><given-names>E.S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2011</year>) <article-title>Identifying the rooted species tree from the distribution of unrooted gene trees under the coalescent</article-title>. <source>J. Math. Biol</source>., <volume>62</volume>, <fpage>833</fpage>–<lpage>862</lpage>.<pub-id pub-id-type="pmid">20652704</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ané</surname><given-names>C.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2007</year>) <article-title>Bayesian estimation of concordance among gene trees</article-title>. <source>Mol. Biol. Evol</source>., <volume>24</volume>, <fpage>412</fpage>–<lpage>426</lpage>.<pub-id pub-id-type="pmid">17095535</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Avni</surname><given-names>E.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2015</year>) <article-title>Weighted quartets phylogenetics</article-title>. <source>Syst. Biol</source>., <volume>64</volume>, <fpage>233</fpage>–<lpage>242</lpage>.<pub-id pub-id-type="pmid">25414175</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bayzid</surname><given-names>M.S.</given-names></string-name>, <string-name><surname>Warnow</surname><given-names>T.</given-names></string-name></person-group> (<year>2013</year>) <article-title>Naive binning improves phylogenomic analyses</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>2277</fpage>–<lpage>2284</lpage>.<pub-id pub-id-type="pmid">23842808</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bossert</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2021</year>) <article-title>Gene tree estimation error with ultraconserved elements: an empirical study on <italic toggle="yes">Pseudapis</italic> bees</article-title>. <source>Syst. Biol</source>., <volume>70</volume>, <fpage>803</fpage>–<lpage>821</lpage>.<pub-id pub-id-type="pmid">33367855</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Brinkmann</surname><given-names>H.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2005</year>) <article-title>An empirical assessment of long-branch attraction artefacts in deep eukaryotic phylogenomics</article-title>. <source>Syst. Biol</source>., <volume>54</volume>, <fpage>743</fpage>–<lpage>757</lpage>.<pub-id pub-id-type="pmid">16243762</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B7">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Brown</surname><given-names>D.G.</given-names></string-name>, <string-name><surname>Truszkowski</surname><given-names>J.</given-names></string-name></person-group> (<year>2011</year>) <source>Towards a Practical O(n Logn) Phylogeny Algorithm</source>. In: Przytycka,T.M. and Sagot,MF. (eds) <italic toggle="yes">Algorithms in Bioinformatics. WABI 2011</italic>. Lecture Notes in Computer Science, Vol. 6833. Springer, Berlin, Heidelberg. pp. <fpage>14</fpage>–<lpage>25</lpage>. https://doi.org/10.1007/978-3-642-23038-7_2.</mixed-citation>
    </ref>
    <ref id="btac265-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chifman</surname><given-names>J.</given-names></string-name>, <string-name><surname>Kubatko</surname><given-names>L.S.</given-names></string-name></person-group> (<year>2014</year>) <article-title>Quartet inference from SNP data under the coalescent model</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>3317</fpage>–<lpage>3324</lpage>.<pub-id pub-id-type="pmid">25104814</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chung</surname><given-names>Y.</given-names></string-name>, <string-name><surname>Ané</surname><given-names>C.</given-names></string-name></person-group> (<year>2011</year>) <article-title>Comparing two Bayesian methods for gene tree/species tree reconstruction: simulations with incomplete lineage sorting and horizontal gene transfer</article-title>. <source>Syst. Biol</source>., <volume>60</volume>, <fpage>261</fpage>–<lpage>275</lpage>.<pub-id pub-id-type="pmid">21368324</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B10">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Conn</surname><given-names>A.R.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2000</year>). <source>Trust Region Methods</source>. <italic toggle="yes">SIAM</italic>. Society for Industrial and Applied Mathematics, Philadelphia.</mixed-citation>
    </ref>
    <ref id="btac265-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Dasarathy</surname><given-names>G.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2015</year>) <article-title>Data requirement for phylogenetic inference from multiple loci: a new distance method</article-title>. <source>IEEE/ACM Trans. Comput. Biol. Bioinform</source>. <volume>12</volume>, <fpage>422</fpage>–<lpage>432</lpage>.<pub-id pub-id-type="pmid">26357228</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Davidson</surname><given-names>R.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) <article-title>Efficient quartet representations of trees and applications to supertree and summary methods</article-title>. <source>IEEE/ACM Trans. Comput. Biol. Bioinform</source>., <volume>15</volume>, <fpage>1010</fpage>–<lpage>1015</lpage>.<pub-id pub-id-type="pmid">28113327</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Degnan</surname><given-names>J.H.</given-names></string-name></person-group> (<year>2013</year>) <article-title>Anomalous unrooted gene trees</article-title>. <source>Syst. Biol</source>., <volume>62</volume>, <fpage>574</fpage>–<lpage>590</lpage>.<pub-id pub-id-type="pmid">23576318</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Degnan</surname><given-names>J.H.</given-names></string-name>, <string-name><surname>Rosenberg</surname><given-names>N.A.</given-names></string-name></person-group> (<year>2006</year>) <article-title>Discordance of species trees with their most likely gene trees</article-title>. <source>PLoS Genet</source>., <volume>2</volume>, <fpage>e68</fpage>.<pub-id pub-id-type="pmid">16733550</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Erdos</surname><given-names>P.</given-names></string-name></person-group>  <etal>et al</etal> (<year>1999</year>) <article-title>A few logs suffice to build (almost) all trees: part II</article-title>. <source>Theor. Comput. Sci</source>., <volume>221</volume>, <fpage>77</fpage>–<lpage>118</lpage>.</mixed-citation>
    </ref>
    <ref id="btac265-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Felsenstein</surname><given-names>J.</given-names></string-name></person-group> (<year>1978</year>) <article-title>Cases in which parsimony or compatibility methods will be positively misleading</article-title>. <source>Syst. Zool</source>., <volume>27</volume>, <fpage>401</fpage>–<lpage>410</lpage>.</mixed-citation>
    </ref>
    <ref id="btac265-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Fletcher</surname><given-names>W.</given-names></string-name>, <string-name><surname>Yang</surname><given-names>Z.</given-names></string-name></person-group> (<year>2009</year>) <article-title>INDELible: a flexible simulator of biological sequence evolution</article-title>. <source>Mol. Biol. Evol</source>., <volume>26</volume>, <fpage>1879</fpage>–<lpage>1888</lpage>.<pub-id pub-id-type="pmid">19423664</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Fourment</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2020</year>) <article-title>19 Dubious ways to compute the marginal likelihood of a phylogenetic tree topology</article-title>. <source>Syst. Biol</source>., <volume>69</volume>, <fpage>209</fpage>–<lpage>220</lpage>.<pub-id pub-id-type="pmid">31504998</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Huang</surname><given-names>H.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2010</year>) <article-title>Sources of error inherent in Species-Tree estimation: impact of mutational and coalescent effects on accuracy and implications for choosing among different methods</article-title>. <source>Syst. Biol</source>., <volume>59</volume>, <fpage>573</fpage>–<lpage>583</lpage>.<pub-id pub-id-type="pmid">20833951</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Jeffroy</surname><given-names>O.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2006</year>) <article-title>Phylogenomics: the beginning of incongruence?</article-title>  <source>Trends Genet</source>., <volume>22</volume>, <fpage>225</fpage>–<lpage>231</lpage>.<pub-id pub-id-type="pmid">16490279</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lanier</surname><given-names>H.C.</given-names></string-name>, <string-name><surname>Knowles</surname><given-names>L.L.</given-names></string-name></person-group> (<year>2015</year>) <article-title>Applying species-tree analyses to deep phylogenetic histories: challenges and potential suggested from a survey of empirical phylogenetic studies</article-title>. <source>Mol. Phylogenet. Evol</source>., <volume>83</volume>, <fpage>191</fpage>–<lpage>199</lpage>.<pub-id pub-id-type="pmid">25450097</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Larget</surname><given-names>B.R.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2010</year>) <article-title>BUCKy: gene tree/species tree reconciliation with Bayesian concordance analysis</article-title>. <source>Bioinformatics</source>, <volume>26</volume>, <fpage>2910</fpage>–<lpage>2911</lpage>.<pub-id pub-id-type="pmid">20861028</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lartillot</surname><given-names>N.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2007</year>) <article-title>Suppression of long-branch attraction artefacts in the animal phylogeny using a site-heterogeneous model</article-title>. <source>BMC Evol. Biol</source>., <volume>7</volume>, <fpage>S4</fpage>.</mixed-citation>
    </ref>
    <ref id="btac265-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Leaché</surname><given-names>A.D.</given-names></string-name>, <string-name><surname>Rannala</surname><given-names>B.</given-names></string-name></person-group> (<year>2011</year>) <article-title>The accuracy of species tree estimation under simulation: a comparison of methods</article-title>. <source>Syst. Biol</source>., <volume>60</volume>, <fpage>126</fpage>–<lpage>137</lpage>.<pub-id pub-id-type="pmid">21088009</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Liu</surname><given-names>L.</given-names></string-name></person-group> (<year>2008</year>) <article-title>BEST: Bayesian estimation of species trees under the coalescent model</article-title>. <source>Bioinformatics</source>, <volume>24</volume>, <fpage>2542</fpage>–<lpage>2543</lpage>.<pub-id pub-id-type="pmid">18799483</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Liu</surname><given-names>L.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2010</year>) <article-title>A maximum pseudo-likelihood approach for estimating species trees under the coalescent model</article-title>. <source>BMC Evol. Biol</source>., <volume>10</volume>, <fpage>302</fpage>.<pub-id pub-id-type="pmid">20937096</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B27">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Mai</surname><given-names>U.</given-names></string-name>, <string-name><surname>Mirarab</surname><given-names>S.</given-names></string-name></person-group> (<year>2017</year>). <part-title>TreeShrink: efficient detection of outlier tree leaves</part-title>. In: <person-group person-group-type="editor"><string-name><surname>Meidanis</surname><given-names>J.</given-names></string-name>, <string-name><surname>Nakhleh</surname><given-names>L.</given-names></string-name></person-group> (eds) <source>Comparative Genomics. RECOMB-CG 2017. Lecture Notes in Computer Science</source>. Vol. <volume>10562</volume>. <publisher-name>Springer International Publishing</publisher-name>, <publisher-loc>Cham</publisher-loc>, pp. <fpage>116</fpage>–<lpage>140</lpage>.</mixed-citation>
    </ref>
    <ref id="btac265-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mallo</surname><given-names>D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) <article-title>SimPhy: phylogenomic simulation of gene, locus, and species trees</article-title>. <source>Syst. Biol</source>., <volume>65</volume>, <fpage>334</fpage>–<lpage>344</lpage>.<pub-id pub-id-type="pmid">26526427</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>McCormack</surname><given-names>J.E.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2009</year>) <article-title>Maximum likelihood estimates of species trees: how accuracy of phylogenetic inference depends upon the divergence history and sampling design</article-title>. <source>Syst. Biol</source>., <volume>58</volume>, <fpage>501</fpage>–<lpage>508</lpage>.<pub-id pub-id-type="pmid">20525604</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Minh</surname><given-names>B.Q.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2020</year>) <article-title>IQ-TREE 2: new models and efficient methods for phylogenetic inference in the genomic era</article-title>. <source>Mol. Biol. Evol</source>., <volume>37</volume>, <fpage>1530</fpage>–<lpage>1534</lpage>.<pub-id pub-id-type="pmid">32011700</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B31">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Mirarab</surname><given-names>S.</given-names></string-name></person-group> (<year>2019</year>). Species tree estimation using ASTRAL: practical considerations. <italic toggle="yes">Arxiv preprint</italic>, 1904.03826.</mixed-citation>
    </ref>
    <ref id="btac265-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mirarab</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014a</year>) <article-title>ASTRAL: genome-scale coalescent-based species tree estimation</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>i541</fpage>–<lpage>i548</lpage>.<pub-id pub-id-type="pmid">25161245</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mirarab</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014b</year>) <article-title>Statistical binning enables an accurate coalescent-based estimation of the avian tree</article-title>. <source>Science</source>, <volume>346</volume>, <fpage>1250463</fpage>–<lpage>1250463</lpage>.<pub-id pub-id-type="pmid">25504728</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mirarab</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2021</year>) <article-title>Multispecies coalescent: theory and applications in phylogenetics</article-title>. <source>Annu. Rev. Ecol. Evol. Syst</source>., <volume>52</volume>, <fpage>247</fpage>–<lpage>268</lpage>.</mixed-citation>
    </ref>
    <ref id="btac265-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Molloy</surname><given-names>E.K.</given-names></string-name>, <string-name><surname>Warnow</surname><given-names>T.</given-names></string-name></person-group> (<year>2018</year>) <article-title>To include or not to include: the impact of gene filtering on species tree estimation methods</article-title>. <source>Syst. Biol</source>., <volume>67</volume>, <fpage>285</fpage>–<lpage>303</lpage>.<pub-id pub-id-type="pmid">29029338</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>ΡOgilvie</surname><given-names>H.A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) <article-title>Computational performance and statistical accuracy of *BEAST and comparisons with other methods</article-title>. <source>Syst. Biol</source>., <volume>65</volume>, <fpage>381</fpage>–<lpage>396</lpage>.<pub-id pub-id-type="pmid">26821913</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B37">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ogilvie</surname><given-names>H.A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) <article-title>StarBEAST2 brings faster species tree inference and accurate estimates of substitution rates</article-title>. <source>Mol. Biol. Evol</source>., <volume>34</volume>, <fpage>2101</fpage>–<lpage>2114</lpage>.<pub-id pub-id-type="pmid">28431121</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B38">
      <mixed-citation publication-type="journal">OneKP Initiative. (<year>2019</year>) <article-title>One thousand plant transcriptomes and the phylogenomics of green plants</article-title>. <source>Nature</source>, <volume>574</volume>, <fpage>679</fpage>–<lpage>685</lpage>.<pub-id pub-id-type="pmid">31645766</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B39">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Pamilo</surname><given-names>P.</given-names></string-name>, <string-name><surname>Nei</surname><given-names>M.</given-names></string-name></person-group> (<year>1988</year>) <article-title>Relationships between gene trees and species trees</article-title>. <source>Mol. Biol. Evol</source>., <volume>5</volume>, <fpage>568</fpage>–<lpage>583</lpage>.<pub-id pub-id-type="pmid">3193878</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B40">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Patel</surname><given-names>S.</given-names></string-name></person-group> (<year>2013</year>) <article-title>Error in phylogenetic estimation for bushes in the tree of life</article-title>. <source>Phylogenet. Evol</source>., <volume>01</volume>, <fpage>110</fpage>.</mixed-citation>
    </ref>
    <ref id="btac265-B41">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Rannala</surname><given-names>B.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2020</year>). <part-title>The multi-species coalescent model and species tree inference</part-title>. In: <person-group person-group-type="editor"><string-name><surname>Scornavacca</surname><given-names>C.</given-names></string-name>, <string-name><surname>Delsuc</surname><given-names>F.</given-names></string-name>, <string-name><surname>Galtier</surname><given-names>N.</given-names></string-name></person-group> (eds.) <source>Phylogenetics in the Genomic Era</source>. pp. 3.<volume>3</volume>:<fpage>1</fpage>–<lpage>3</lpage>.3:21. No commercial publisher | Authors open access book.</mixed-citation>
    </ref>
    <ref id="btac265-B42">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Roch</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>Long-branch attraction in species tree estimation: inconsistency of partitioned likelihood and topology-based summary methods</article-title>. <source>Syst. Biol</source>., <volume>68</volume>, <fpage>281</fpage>–<lpage>297</lpage>.<pub-id pub-id-type="pmid">30247732</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B43">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ronquist</surname><given-names>F.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2012</year>) <article-title>MrBayes 3.2: efficient Bayesian phylogenetic inference and model choice across a large model space</article-title>. <source>Syst. Biol</source>., <volume>61</volume>, <fpage>539</fpage>–<lpage>542</lpage>.<pub-id pub-id-type="pmid">22357727</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B44">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sayyari</surname><given-names>E.</given-names></string-name>, <string-name><surname>Mirarab</surname><given-names>S.</given-names></string-name></person-group> (<year>2016a</year>) <article-title>Anchoring quartet-based phylogenetic distances and applications to species tree reconstruction</article-title>. <source>BMC Genomics</source>, <volume>17</volume>, <fpage>101</fpage>–<lpage>113</lpage>.<pub-id pub-id-type="pmid">26861502</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B45">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sayyari</surname><given-names>E.</given-names></string-name>, <string-name><surname>Mirarab</surname><given-names>S.</given-names></string-name></person-group> (<year>2016b</year>) <article-title>Fast coalescent-based computation of local branch support from quartet frequencies</article-title>. <source>Mol. Biol. Evol</source>., <volume>33</volume>, <fpage>1654</fpage>–<lpage>1668</lpage>.<pub-id pub-id-type="pmid">27189547</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B46">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Smith</surname><given-names>B.T.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) <article-title>Target capture and massively parallel sequencing of ultraconserved elements for comparative studies at shallow evolutionary time scales</article-title>. <source>Syst. Biol</source>., <volume>63</volume>, <fpage>83</fpage>–<lpage>95</lpage>.<pub-id pub-id-type="pmid">24021724</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B47">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Snir</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2008</year>) <article-title>Short quartet puzzling: a new quartet-based phylogeny reconstruction algorithm</article-title>. <source>J. Comput. Biol</source>., <volume>15</volume>, <fpage>91</fpage>–<lpage>103</lpage>.<pub-id pub-id-type="pmid">18199023</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B48">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sukumaran</surname><given-names>J.</given-names></string-name>, <string-name><surname>Holder</surname><given-names>M.T.</given-names></string-name></person-group> (<year>2010</year>) <article-title>DendroPy: a python library for phylogenetic computing</article-title>. <source>Bioinformatics</source>, <volume>26</volume>, <fpage>1569</fpage>–<lpage>1571</lpage>.<pub-id pub-id-type="pmid">20421198</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B49">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Szöllõsi</surname><given-names>G.J.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2013</year>) <article-title>Efficient exploration of the space of reconciled gene trees</article-title>. <source>Syst. Biol</source>., <volume>62</volume>, <fpage>901</fpage>–<lpage>912</lpage>.<pub-id pub-id-type="pmid">23925510</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B50">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Szöllősi</surname><given-names>G.J.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2015</year>) <article-title>The inference of gene trees with species trees</article-title>. <source>Syst. Biol</source>., <volume>64</volume>, <fpage>e42</fpage>–<lpage>e62</lpage>.<pub-id pub-id-type="pmid">25070970</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B51">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Vachaspati</surname><given-names>P.</given-names></string-name>, <string-name><surname>Warnow</surname><given-names>T.</given-names></string-name></person-group> (<year>2015</year>) <article-title>ASTRID: accurate species TRees from internode distances</article-title>. <source>BMC Genomics</source>, <volume>16</volume>, <fpage>S3</fpage>.</mixed-citation>
    </ref>
    <ref id="btac265-B52">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wang</surname><given-names>Y.</given-names></string-name>, <string-name><surname>Nakhleh</surname><given-names>L.</given-names></string-name></person-group> (<year>2018</year>) <article-title>Towards an accurate and efficient heuristic for species/gene tree co-estimation</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>i697</fpage>–<lpage>i705</lpage>.<pub-id pub-id-type="pmid">30423064</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B53">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wu</surname><given-names>Y.</given-names></string-name></person-group> (<year>2012</year>) <article-title>Coalescent-based species tree inference from gene tree topologies under incomplete lineage sorting by maximum likelihood</article-title>. <source>Evolution</source>, <volume>66</volume>, <fpage>763</fpage>–<lpage>775</lpage>.<pub-id pub-id-type="pmid">22380439</pub-id></mixed-citation>
    </ref>
    <ref id="btac265-B54">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yang</surname><given-names>J.</given-names></string-name>, <string-name><surname>Warnow</surname><given-names>T.</given-names></string-name></person-group> (<year>2011</year>) <article-title>Fast and accurate methods for phylogenomic analyses</article-title>. <source>BMC Bioinformatics</source>, <volume>12</volume>, <fpage>S4</fpage>.</mixed-citation>
    </ref>
    <ref id="btac265-B55">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhang</surname><given-names>C.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) <article-title>ASTRAL-III: polynomial time species tree reconstruction from partially resolved gene trees</article-title>. <source>BMC Bioinformatics</source>, <volume>19</volume>, <fpage>153</fpage>.<pub-id pub-id-type="pmid">29745866</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
