<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">5409310</article-id>
    <article-id pub-id-type="pmid">28172448</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btw620</article-id>
    <article-id pub-id-type="publisher-id">btw620</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Genome Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>OMBlast: alignment tool for optical mapping using a seed-and-extend approach</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Leung</surname>
          <given-names>Alden King-Yung</given-names>
        </name>
        <xref ref-type="aff" rid="btw620-aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Kwok</surname>
          <given-names>Tsz-Piu</given-names>
        </name>
        <xref ref-type="aff" rid="btw620-aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Wan</surname>
          <given-names>Raymond</given-names>
        </name>
        <xref ref-type="aff" rid="btw620-aff1">1</xref>
        <xref ref-type="author-notes" rid="btw620-FM2"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Xiao</surname>
          <given-names>Ming</given-names>
        </name>
        <xref ref-type="aff" rid="btw620-aff3">3</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Kwok</surname>
          <given-names>Pui-Yan</given-names>
        </name>
        <xref ref-type="aff" rid="btw620-aff6">6</xref>
        <xref ref-type="aff" rid="btw620-aff7">7</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Yip</surname>
          <given-names>Kevin Y</given-names>
        </name>
        <xref ref-type="aff" rid="btw620-aff2">2</xref>
        <xref ref-type="aff" rid="btw620-aff4">4</xref>
        <xref ref-type="corresp" rid="btw620-cor1"/>
        <!--<email>kevinyip@cse.cuhk.edu.hk</email>-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Chan</surname>
          <given-names>Ting-Fung</given-names>
        </name>
        <xref ref-type="aff" rid="btw620-aff1">1</xref>
        <xref ref-type="aff" rid="btw620-aff2">2</xref>
        <xref ref-type="aff" rid="btw620-aff4">4</xref>
        <xref ref-type="aff" rid="btw620-aff5">5</xref>
        <xref ref-type="corresp" rid="btw620-cor1"/>
        <!--<email>tf.chan@cuhk.edu.hk</email>-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Hancock</surname>
          <given-names>John</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <aff id="btw620-aff1"><label>1</label>School of Life Sciences, The Chinese University of Hong Kong, Hong Kong, China</aff>
    <aff id="btw620-aff2"><label>2</label>Department of Computer Science and Engineering, The Chinese University of Hong Kong, Hong Kong, China</aff>
    <aff id="btw620-aff3"><label>3</label>School of Biomedical Engineering, Science and Health System, Drexel University, Philadelphia, PA, USA</aff>
    <aff id="btw620-aff4"><label>4</label>Hong Kong Bioinformatics Centre, The Chinese University of Hong Kong, Hong Kong, China</aff>
    <aff id="btw620-aff5"><label>5</label>Centre for Soybean Research, State Key Laboratory of Agrobiotechnology, The Chinese University of Hong Kong, Hong Kong, China</aff>
    <aff id="btw620-aff6"><label>6</label>Institute for Human Genetics, University of California San Francisco, San Francisco, CA, USA</aff>
    <aff id="btw620-aff7"><label>7</label>Cardiovascular Research Institute, University of California San Francisco, San Francisco, CA, USA</aff>
    <author-notes>
      <corresp id="btw620-cor1">To whom correspondence should be addressed. Email: <email>kevinyip@cse.cuhk.edu.hk</email> and <email>tf.chan@cuhk.edu.hk</email></corresp>
      <fn id="btw620-FM2">
        <p>Present address: Division of Life Science, The Hong Kong University of Science and Technology, Clear Water Bay, Kowloon, Hong Kong, China</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>01</day>
      <month>2</month>
      <year>2017</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2016-09-30">
      <day>30</day>
      <month>9</month>
      <year>2016</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>30</day>
      <month>9</month>
      <year>2016</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>33</volume>
    <issue>3</issue>
    <fpage>311</fpage>
    <lpage>319</lpage>
    <history>
      <date date-type="received">
        <day>26</day>
        <month>9</month>
        <year>2015</year>
      </date>
      <date date-type="rev-recd">
        <day>31</day>
        <month>8</month>
        <year>2016</year>
      </date>
      <date date-type="accepted">
        <day>26</day>
        <month>9</month>
        <year>2016</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author 2016. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2016</copyright-year>
      <license xlink:href="http://creativecommons.org/licenses/by-nc/4.0/" license-type="cc-by-nc">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btw620.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="sa1">
        <title>Motivation</title>
        <p>Optical mapping is a technique for capturing fluorescent signal patterns of long DNA molecules (in the range of 0.1–1 Mbp). Recently, it has been complementing the widely used short-read sequencing technology by assisting with scaffolding and detecting large and complex structural variations (SVs). Here, we introduce a fast, robust and accurate tool called OMBlast for aligning optical maps, the set of signal locations on the molecules generated from optical mapping. Our method is based on the seed-and-extend approach from sequence alignment, with modifications specific to optical mapping.</p>
      </sec>
      <sec id="sa2">
        <title>Results</title>
        <p>Experiments with both synthetic and our real data demonstrate that OMBlast has higher accuracy and faster mapping speed than existing alignment methods. Our tool also shows significant improvement when aligning data with SVs.</p>
      </sec>
      <sec id="sa3">
        <title>Availability and Implementation</title>
        <p>OMBlast is implemented for Java 1.7 and is released under a GPL license. OMBlast can be downloaded from <ext-link ext-link-type="uri" xlink:href="https://github.com/aldenleung/OMBlast">https://github.com/aldenleung/OMBlast</ext-link> and run directly on machines equipped with a Java virtual machine.</p>
      </sec>
      <sec id="sa4">
        <title>Supplementary information</title>
        <p><xref ref-type="supplementary-material" rid="sup1">Supplementary data</xref> are available at <italic>Bioinformatics</italic> online</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">Health and Medical Research</named-content>
        </funding-source>
        <award-id>12110542</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">RGC Collaborative Research</named-content>
        </funding-source>
        <award-id>CUHK3/CRF/11G</award-id>
        <award-id>C4042-14G</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">Theme-based research schemes</named-content>
        </funding-source>
        <award-id>T12-403/11</award-id>
        <award-id>T12-401/13R</award-id>
        <award-id>T12-402/13-N</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Despite recent advances in sequencing technology, read lengths of typical next generation sequencing instruments and the latest PacBio sequencer are still on the order of 100 bp and 10 kbp, respectively (<xref rid="btw620-B16" ref-type="bibr">Van Dijk <italic>et al.</italic>, 2014</xref>). Optical mapping, however, can produce molecules of lengths on the order of 0.1 Mbp to even 1 Mbp (<xref rid="btw620-B7" ref-type="bibr">Lam <italic>et al.</italic>, 2012</xref>). Optical mapping complements sequencing by resolving complex regions and has been used in several areas including guided sequence assembly (<xref rid="btw620-B8" ref-type="bibr">Lin <italic>et al.</italic>, 2012</xref>), guided sequence scaffolding (<xref rid="btw620-B6" ref-type="bibr">Dong <italic>et al.</italic>, 2013</xref>), structural variation (SV) detection (<xref rid="btw620-B3" ref-type="bibr">Cao <italic>et al.</italic>, 2014</xref>) and pathogen identification (<xref rid="btw620-B10" ref-type="bibr">Miller, 2013</xref>). In fact, optical mapping was used by the Assemblathon 2 organizers to validate the sequence assemblies provided by various teams (<xref rid="btw620-B2" ref-type="bibr">Bradnam <italic>et al.</italic>, 2013</xref>). With an increasing number of optical maps and multiple applications, bioinformatics tools specific for optical mapping are needed (see <xref rid="btw620-B9" ref-type="bibr">Mendelowitz and Pop, 2014</xref> for a recent survey).</p>
    <p>Aligning optical maps is very different from aligning short reads from sequencing due to the vast discrepancy in data type. Various types of error in optical maps pose challenges to error tolerant alignment. Notwithstanding the problems, fast, robust and accurate alignment is fundamental to any downstream analysis of optical maps. In this article, we introduce OMBlast for aligning optical maps, and compare its performance with other alignment methods on synthetic data based on different prokaryotic and eukaryotic organisms of varying genome sizes at different error rates. We also studied the effects of SVs on alignment performance. Finally we tested our alignment method on optical maps generated from an actual experiment. Our results show that OMBlast is both fast and accurate, and its performance is superior to other methods when SVs are present.</p>
    <p>This paper is organized as follows. Section 2 gives an overview of optical mapping and outlines the terms used for the remainder of this paper. The methods behind OMBlast are explained in Section 3. In Section 4, we evaluate our method against several existing tools using both synthetic and real data sets. Finally, Section 5 summarizes our findings and offers directions for future work.</p>
  </sec>
  <sec>
    <title>2 Background</title>
    <sec>
      <title>2.1 Overview</title>
      <p>In recent years, two commercialized methods have renewed interest in optical mapping so that it could complement current short-read sequencing methods. Both OpGen Inc. and Bionano Genomics Inc. have independently devised ways of generating high-throughput data of optical maps. OpGen Inc.'s method relies on the static imaging of restriction maps (<xref rid="btw620-B5" ref-type="bibr">Dimalanta <italic>et al.</italic>, 2004</xref>) while Bionano Genomics Inc.'s is based on continuous imaging of nicked DNA molecules attached with fluorescent labels passing through nanotubes (<xref rid="btw620-B4" ref-type="bibr">Das <italic>et al.</italic>, 2010</xref>). These two technologies produce optical maps with similar data types. An optical map contains a series of smaller DNA segments, separated by fluorescent labels in Bionano Genomics Inc.mi system, or by digestion cut in OpGen Inc.'s system (<xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S1</xref>). As data generation becomes easier, a good alignment method for handling large amounts of data becomes important for further downstream analysis.</p>
    </sec>
    <sec>
      <title>2.2 Terminology</title>
      <p>Since the two methods were independently developed, the terminology used to describe errors differs slightly; we summarize them in <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S1</xref>. Irrespective of the technology, an optical map consists of two pieces of information: (i) the size of each segment situated between two consecutive cuts/nicks and (ii) the order of the segments. As a result, assuming a single optical map <italic>i</italic> consists of <italic>n<sub>i</sub></italic> segments, these segments are separated by <inline-formula id="IE1"><mml:math id="IEQ1"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> fluorescent signals [alternatively, <italic>cuts</italic> in OpGen data (From this point onward, we will always use the term ‘signals’)]. We can represent such data as an <inline-formula id="IE2"><mml:math id="IEQ2"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-tuple such that each element is the absolute location of the signal (i.e. number of base pairs) relative to the beginning of the molecule.</p>
      <p>In this article, we consider the problem of aligning one optical map against another. This problem setting is analogous to the mapping of a query DNA sequence against another DNA sequence. Instead of processing sequences made up of the four bases ({A, C, G, T}), an optical map consists of signal positions which are positive integers. We denote one of these optical maps as the <italic>reference</italic> and the other as the <italic>query</italic>. Usually the experimentally generated optical maps are aligned to a longer optical map obtained from either <italic>in silico</italic> digestion of the reference sequence, or an optical map assembly, but this is not a restriction on how the OMBlast software can be used. The tuples of signals are denoted as <italic>R</italic> and <italic>Q</italic>. Let the <italic>x</italic>th signal on the reference and the <italic>y</italic>th signal on the query be represented as <italic>R<sub>x</sub></italic> and <italic>Q<sub>y</sub></italic>, respectively. We define the <italic>matching signal pair</italic><inline-formula id="IE3"><mml:math id="IEQ3"><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:msub><mml:mi>Q</mml:mi><mml:mi>y</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to be the pairing of a reference signal with a query signal.</p>
      <p>Our aim is to output the best alignment of each query against the reference, in terms of the similarity between the patterns of fluorescent labels on the reference and query. As illustrated in <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S1</xref>, this is non-trivial since the optical map itself can contain various types of error. For example, an optical map can have missing and extra signals. Furthermore, unlike short-read sequencing which provides single base resolution, optical mapping is accurate to only 0.7–1.5 kbp for OpGen (<xref rid="btw620-B12" ref-type="bibr">Nagarajan <italic>et al.</italic>, 2008</xref>) and Bionano data (<xref rid="btw620-B7" ref-type="bibr">Lam <italic>et al.</italic>, 2012</xref>). Measurement error (i.e. error in measuring the length of the DNA segments) and scaling factor [i.e. an indicator of the extent that a DNA molecule is stretched, which remains constant within a DNA molecule but varies between different DNA molecules (<xref rid="btw620-B13" ref-type="bibr">Reinhart <italic>et al.</italic>, 2015</xref>)] also exist in optical mapping data.</p>
      <p>Other than the experimental and instrumental errors, the mismatch between reference and query due to genetic variation also poses challenges to alignment. Single nucleotide polymorphism (SNP) could toggle ‘on’ a new enzyme site or ‘off’ an existing enzyme site. Segment size matching is also affected by the presence of large insertions or deletions. In more complicated cases, part of the query could be reversely and separately aligned to the reference due to SVs. Despite the challenges, genetic variations carry important biological insights and need to be accurately identified. To overcome these obstacles, an alignment method has to perform both local alignment and joining of the separate local alignments of different parts of a query map in order to capture various types of genetic variations.</p>
    </sec>
    <sec>
      <title>2.3 Related work</title>
      <p>Some publicly available alignment software for optical mapping includes RefAligner (<xref rid="btw620-B14" ref-type="bibr">Shelton <italic>et al.</italic>, 2015</xref>), the one described by <xref rid="btw620-B15" ref-type="bibr">Valouev <italic>et al.</italic> (2006)</xref> (whose software we will call Valouev hereafter), Scaffolding using Optical Map Alignment (SOMA) (<xref rid="btw620-B12" ref-type="bibr">Nagarajan <italic>et al.</italic>, 2008</xref>), and TWIN (<xref rid="btw620-B11" ref-type="bibr">Muggli <italic>et al.</italic>, 2014</xref>). Both Valouev and SOMA are based on dynamic programming (DP) coupled with scoring functions which quantify how well a query matches the reference. Valouev employs probability distributions to model the types of errors found in optical maps while SOMA uses scoring functions that model the distribution of segment lengths as well as to what extent the lengths agree between the query and the reference. Meanwhile, TWIN takes a different approach by constructing an FM-Index on the segment lengths of the reference and then performing a near-exact match of the query by using the metric used by SOMA. Another program for aligning optical maps is RefAligner, a tool developed by Bionano Genomics Inc. for performing alignment using dynamic programming.</p>
      <p>In this article, we introduce OMBlast for the alignment of optical maps. Although dynamic programming is also used in certain modules within OMBlast, our method is mainly based on a seed-and-extend approach (<xref rid="btw620-B1" ref-type="bibr">Altschul <italic>et al.</italic>, 1990</xref>), as implied by the name of our software. By using a seed-and-extend approach, our framework is superior in speed, and provides better alignments in complex regions by joining local alignments, in comparison to the dynamic programming approaches for global alignments.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Methods</title>
    <p>Our objective is to find the best way to locate regions on the reference optical map that is most similar to the query optical map. BLAST has been proven to be a fast and accurate seed-and-extend method for handling sequencing data (<xref rid="btw620-B1" ref-type="bibr">Altschul <italic>et al.</italic>, 1990</xref>). We introduced some novel elements to adapt the key ideas of seed-and-extend to handle optical maps. As illustrated in <xref ref-type="fig" rid="btw620-F1">Figure 1</xref>, the entire algorithm is broken down into three main modules. The first module aligns queries against the reference using a seed-and-extend approach and yields partial alignments as local matches. Next, the second module merges overlapping partial alignments into consensus partial alignments. Finally, the last module joins the consensus partial alignments into a global match of the query. In this module, merged partial alignments will be trimmed and joined for the final alignment. We explain each of the three modules below.</p>
    <fig id="btw620-F1" orientation="portrait" position="float">
      <label>Fig. 1</label>
      <caption>
        <p>Overview of the OMBlast algorithm, which comprises of three modules: seed-and-extend (Details in <xref ref-type="supplementary-material" rid="sup1">Supplementary Figures S2-S6</xref>), overlapping alignment merging (Details in <xref ref-type="supplementary-material" rid="sup1">Supplementary Figures S7-S8</xref>) and alignment joining (Details in <xref ref-type="supplementary-material" rid="sup1">Supplementary Figures S9-S11</xref>)</p>
      </caption>
      <graphic xlink:href="btw620f1"/>
    </fig>
    <sec>
      <title>3.1 Alignment</title>
      <sec>
        <title>3.1.1 Seed generation phase</title>
        <p>A basic assumption behind the seed-and-extend approach is that good alignments usually involve some aligned regions on the reference and the query that are almost identical. Therefore, the seeding module of OMBlast aims at efficiently identifying all regions on the reference that are almost identical to each region on the query, such that these matched regions can be further processed by the other modules to form complete alignments.</p>
        <p>Specifically, efficient seeding is performed by matching <italic>k</italic>-tuples (the ‘seeds’). Consider a reference with <italic>n</italic> segments and a query with <italic>m</italic> segments. For convenience, here we represent the reference by the lengths of its segments, <inline-formula id="IE4"><mml:math id="IEQ4"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, following their order of occurrence on the reference. Similarly, the query is represented by its segment lengths <inline-formula id="IE5"><mml:math id="IEQ5"><mml:mrow><mml:msub><mml:mi>q</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>q</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>q</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. A <italic>k</italic>-tuple on the reference is the list of segment lengths for <italic>k</italic> consecutive segments, <italic>r<sub>i</sub></italic>, <inline-formula id="IE6"><mml:math id="IEQ6"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>,…, <inline-formula id="IE7"><mml:math id="IEQ7"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, for any <italic>i</italic> between 1 and <inline-formula id="IE8"><mml:math id="IEQ8"><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. The <italic>k</italic>-tuples on the query are defined in the same way. The goal of seeding is to find, for each <italic>k</italic>-tuple on the query, all matching <italic>k</italic>-tuples on the reference. A query <italic>k</italic>-tuple <inline-formula id="IE9"><mml:math id="IEQ9"><mml:mrow><mml:msub><mml:mi>q</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>q</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is said to match a reference <italic>k</italic>-tuple <inline-formula id="IE10"><mml:math id="IEQ10"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> if all pairs of the corresponding segment lengths (<italic>q<sub>j</sub></italic>, <italic>r<sub>i</sub></italic>),…, <inline-formula id="IE11"><mml:math id="IEQ11"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>q</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> match, where two segment lengths <italic>q<sub>x</sub></italic> and <italic>r<sub>y</sub></italic> match if they are considered sufficiently close subject to the level of errors tolerated:
<disp-formula id="E1"><label>(1)</label><mml:math id="EQ1"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi mathvariant="normal">y</mml:mi></mml:msub><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi mathvariant="normal">s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mi>q</mml:mi><mml:mi mathvariant="normal">x</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi mathvariant="normal">y</mml:mi></mml:msub><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi mathvariant="normal">s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where <italic>T</italic><sub>s</sub> and <italic>T</italic><sub>m</sub> represent the maximum scaling and measuring errors tolerated, respectively.</p>
        <p>To find out all matching <italic>k</italic>-tuples efficiently, two searching strategies are implemented in OMBlast, namely (A) Sorted list merging and (B) Binning. Method A begins with an indexing phase whereby every reference <italic>k</italic>-tuple <inline-formula id="IE12"><mml:math id="IEQ12"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> has its <italic>k</italic> segment lengths and segment IDs placed into <italic>k</italic> corresponding lists ((<italic>r<sub>i</sub></italic>, <italic>i</italic>) to the first list, (<inline-formula id="IE13"><mml:math id="IEQ13"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <italic>i</italic> + 1) to the second list etc.). Each list is independently sorted according to the segment lengths. With this index, to find all matches for a query <italic>k</italic>-tuple <inline-formula id="IE14"><mml:math id="IEQ14"><mml:mrow><mml:msub><mml:mi>q</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>q</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <italic>q<sub>j</sub></italic> is first used to perform two binary searches from the first sorted list, to find out the smallest and largest reference segment lengths that satisfy Inequalities (1). The corresponding IDs of these segments are recorded. The length of the second query segment <inline-formula id="IE15"><mml:math id="IEQ15"><mml:mrow><mml:msub><mml:mi>q</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is then used to perform a similar search from the second sorted list. Among the matching segments, only those segments (say, <italic>x</italic>) with their previous segment (<italic>x</italic> − 1) also retrieved from the previous search are recorded. This process continues until either no segments are reported in an iteration, in which case the query has no matches in the reference, or searching to all <italic>k</italic> lists has been performed, in which case all <italic>k</italic>-tuples on the reference that match the query <italic>k</italic>-tuple are obtained.</p>
        <p>In Method B, <italic>k</italic>-tuples are converted to strings and matched <italic>k</italic>-tuple pairs are identified by looking for identical strings. Specifically, segment sizes are discretized into bins of 5 kbp, and each bin is represented by a single character. For each reference <italic>k</italic>-tuple, the segment lengths are converted to the corresponding bin characters and the resulting string is stored in a hash table. When searching for the matches of a query <italic>k</italic>-tuple, each segment length of it is first used to determine the minimum and maximum matching segment lengths based on Inequalities 1, and the characters of all the bins that overlap this range are recorded. The query <italic>k</italic>-tuple is then converted to a set of strings by considering all combinations of the recorded characters of each segment, and each string is used to search the reference hash table for identical matches. Finally, a post-filtering is performed to remove false hits, which can happen because bin characters rather than exact segment lengths were used in the searches.</p>
        <p>Methods A and B produce identical results, and their running time is compared in <xref ref-type="supplementary-material" rid="sup1">Supplementary Material Section S4</xref>. Based on the results, Method B with <italic>k =</italic>3 usually achieves the best performance, and is thus set as the default option of OMBlast and used in our experiments.</p>
        <p>For both methods, in order to reduce the amount of time spent on regions of low complexity, a query <italic>k</italic>-tuple is removed if it matches over 10 other query <italic>k</italic>-tuples.</p>
      </sec>
      <sec>
        <title>3.1.2 Extension phase</title>
        <p>The seeding phase produces matching query and reference <italic>k</italic>-tuples that are almost identical. The extension phase takes each matching pair and attempts to extend it to include more adjacent segments on the query and reference that are also similar. In order to perform these extensions efficiently, we assume that the factor involved in scaling errors remains constant within a single DNA molecule, as suggested previously (<xref rid="btw620-B13" ref-type="bibr">Reinhart <italic>et al.</italic>, 2015</xref>). Based on this assumption, for a given scaling factor, we can compute the error-corrected segment length of each query segment by dividing it by the scaling factor. These corrected segment lengths are then used to extend the matching <italic>k</italic>-tuples from the seeding phase, by checking whether the accumulated segment lengths from the reference and query also match according to Inequalities (2).
<disp-formula id="E2"><label>(2)</label><mml:math id="EQ2"><mml:mrow><mml:msubsup><mml:mi>r</mml:mi><mml:mi mathvariant="normal">y</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo>−</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:msubsup><mml:mi>q</mml:mi><mml:mi mathvariant="normal">x</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo>≤</mml:mo><mml:msubsup><mml:mi>r</mml:mi><mml:mi mathvariant="normal">y</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo>+</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where <italic>T</italic><sub>m</sub> represents the maximum measuring errors tolerated, <inline-formula id="IE16"><mml:math id="IEQ16"><mml:mrow><mml:msubsup><mml:mi>q</mml:mi><mml:mi>x</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE17"><mml:math id="IEQ17"><mml:mrow><mml:msubsup><mml:mi>r</mml:mi><mml:mi>y</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> represent the accumulated query segment length (scaling error-corrected) and accumulated reference segment length, respectively. Since the actual scaling factor is unknown, we use a process called ‘recursive refinement’ (<xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S4</xref>) to search for it based on the extension results. Briefly, a set of reasonable values of the scaling factor are used at the beginning to start the extension of the first extra segment. Scaling factor values that lead to poor extensions are dropped, and the remaining ones are used in the next iteration for extending another extra segment. This process is repeated until no more extensions can be performed without introducing five consecutive mismatches. The consequence of such early termination is minimal (<xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S6</xref>) since local alignments involving different parts of a query can be further joined together, to be described in Section 3.3.</p>
        <p>As shown later in Section 4.3, a notable benefit of using a constant scaling factor over dynamic programming (which allows the scaling factor to change flexibly from segment to segment) is the drastic reduction of running time, while alignment accuracy is still preserved.</p>
      </sec>
    </sec>
    <sec>
      <title>3.2 Overlapping alignment merging</title>
      <p>The seed-and-extend module produces local matches as partial alignments. Some partial alignments are overlapping as they are extended from different seeds in close proximity on the reference. This module aims at merging these overlapping partial alignments into consensus partial alignments. We define two partial alignments as <italic>overlapping</italic> if they are on the same orientation and share at least one matching signal pair <inline-formula id="IE18"><mml:math id="IEQ18"><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:msub><mml:mi>Q</mml:mi><mml:mi>y</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (See <xref ref-type="supplementary-material" rid="sup1">Supplementary Material Section S2.2</xref> for further details).</p>
      <p>In order to effectively construct a consensus partial alignment that favors fewer extra and missing signals from a set of overlapping partial alignments, we convert the overlapping partial alignments into a weighted directed acyclic graph. Specifically, each matching signal pair <inline-formula id="IE19"><mml:math id="IEQ19"><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:msub><mml:mi>Q</mml:mi><mml:mi>y</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is represented as a node in the graph. From each partial alignment with a list of <italic>m</italic> matching signal pairs <inline-formula id="IE20"><mml:math id="IEQ20"><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mi>Q</mml:mi><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mi>Q</mml:mi><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mi>Q</mml:mi><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, we build a directed edge between every consecutive matching signal pairs <inline-formula id="IE21"><mml:math id="IEQ21"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mi>Q</mml:mi><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mo>→</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mi>Q</mml:mi><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The weight of an edge is inversely proportional to the number of missing signals <inline-formula id="IE22"><mml:math id="IEQ22"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and extra signals <inline-formula id="IE23"><mml:math id="IEQ23"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (see <xref ref-type="supplementary-material" rid="sup1">Supplementary Material Section S2.2</xref> for further details). Next, we use a dynamic programming approach that marks the cumulative weight to the nodes in a bottom-up manner. Each node’s cumulative weight is assigned the highest weight among each sum of weight of incoming edge and node, or zero if the node has no incoming edge or the highest weight is negative. After traversing all nodes in the graph, we select the node with highest weight and use backtracking to obtain the path leading to the highest weight. Collectively, matching signal pairs from the best path are taken as the consensus partial alignment.</p>
    </sec>
    <sec>
      <title>3.3 Alignment joining</title>
      <p>Previous modules produce consensus partial alignments as local matches for a query. Here, we aim at picking and joining these partial alignments into a complete, final alignment as the global match for the query. This module constructs a link for every two partial alignments that could be connected, and from them finds the best series of links to obtain the chain of partial alignments as the final alignment.</p>
      <p>First, the module checks if a pair of partial alignments, <italic>p<sub>x</sub></italic> and <italic>p<sub>y</sub></italic>, could be connected based solely on their reference position, with details described in <xref ref-type="supplementary-material" rid="sup1">Supplementary Material Section S2.3</xref>. For every link, we assign them a connection relationship <inline-formula id="IE24"><mml:math id="IEQ24"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, which is taken as the penalty for connection later on. Next, a weighted directed acyclic graph is constructed with these links as nodes. Edges are automatically created for every two nodes with relationship <inline-formula id="IE25"><mml:math id="IEQ25"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE26"><mml:math id="IEQ26"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, as the second partial alignment of the former node is the first partial alignment of the latter node. The weight is dependent on the score of the second partial alignment and the relationship penalty. We use a dynamic programming approach to update the weight of nodes in a bottom-up manner, similar to Section 3.2. Finally, we backtrack from the node with the highest weight to obtain the path which indicates the best combinations of <inline-formula id="IE27"><mml:math id="IEQ27"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, where the partial alignments <inline-formula id="IE28"><mml:math id="IEQ28"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> are selected as the components of the final alignment.</p>
      <p>Using this approach, local partial alignments separated by high errors in the data or SVs could be joined into the global, final alignment. As demonstrated in Section 4.3, OMBlast could handle queries with SVs better, and even capture potential sites of inversion.</p>
    </sec>
    <sec>
      <title>3.4 Score calculations</title>
      <p>OMBlast employs a scoring system that assigns the final alignments with a quality score based on the extent of the tolerated errors. This score reflects the alignment quality that could be ranked and compared with qualities of other alignments. At first, the score for each partial alignment is calculated, followed by a combined score for the overall alignment. The score for the <italic>i</italic>th partial alignment <italic>p</italic> is calculated as:
<disp-formula id="E3"><label>(3)</label><mml:math id="EQ3"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi mathvariant="normal">m</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mtext>es</mml:mtext></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mtext>es</mml:mtext></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mtext>ms</mml:mtext></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mtext>ms</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mo>|</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula>
where <italic>t</italic><sub>m</sub>, <italic>t</italic><sub>es</sub> and <italic>t</italic><sub>ms</sub> represent the score for a match, extra signal and missing signal, respectively, as provided by the user. Meanwhile, the variables <italic>u</italic><sub>m</sub>, <italic>u</italic><sub>es</sub> and <italic>u</italic><sub>ms</sub> represent the number of matches, extra signals and missing signals, and <italic>s</italic> is the scaling factor representing the ratio of the aligned query length to the aligned reference length. Note that in the score calculation, we assume the reference is a true correct reference. When one reverses the role of reference and query, the score for partial alignment is slightly different. The score <italic>o</italic> for the overall alignment with <italic>q</italic> partial alignments is calculated as:
<disp-formula id="E4"><label>(4)</label><mml:math id="EQ4"><mml:mrow><mml:mi>o</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>q</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>q</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></disp-formula>
where <inline-formula id="IE29"><mml:math id="IEQ29"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> denotes the relationship penalty between partial alignment <italic>p<sub>i</sub></italic> and <inline-formula id="IE30"><mml:math id="IEQ30"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> as indicated in <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S9</xref>. Briefly, this is composed of a constant penalty from either one of the relationships (Insertion/Deletion or Inversion), and the number of extra and missing signals between the two partial alignments. OMBlast also employs an alternative scoring scheme that takes into account uniqueness in alignments (see <xref ref-type="supplementary-material" rid="sup1">Supplementary Material Section S2.3.4</xref>). More information on parameter selections could be found in the software manual of OMBlast.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Experiments</title>
    <p>The performance of OMBlast was evaluated against RefAligner, Valouev, SOMA and TWIN. The software versions and where these tools were obtained are summarized in <xref ref-type="supplementary-material" rid="sup1">Supplementary Table S2</xref>. In our experiments, we evaluated OMBlast using both simulated and real data sets.</p>
    <sec>
      <title>4.1 Data sets</title>
      <sec>
        <title>4.1.1 Simulated data</title>
        <p>We downloaded the genomes of four prokaryotic and eukaryotic organisms from GenBank, namely <italic>Escherichia coli</italic>, <italic>Saccharomyces cerevisiae</italic>, <italic>Caenorhabditis elegans</italic> and <italic>Homo sapiens</italic> (see <xref ref-type="supplementary-material" rid="sup1">Supplementary Table S4</xref> for the corresponding accession numbers). We then digested them <italic>in-silico</italic> with the nicking enzyme BspQI, which recognizes the sequence GCTCTTC. The result is the four reference optical maps summarized in <xref ref-type="supplementary-material" rid="sup1">Supplementary Table S5</xref>.</p>
        <p>From each of these four reference optical maps, we extracted 1000 optical maps at random to act as queries. This procedure was performed three times, so that error bars in the graphs below represent SDs. Variations on these data sets were produced through the introduction of four different error rates (i.e. none, low, medium and high). In general, as the error rate increases, more extra and missing signals are induced and with a larger variation in scaling error. <xref ref-type="supplementary-material" rid="sup1">Supplementary Material Section S5.3</xref> summarizes the details of the simulated data generation.</p>
        <p>The SVs considered included insertions and deletions of various sizes as well as sequence inversions. Since optical mapping aims at resolving large SVs, we incorporated 50 and 100 kbp insertions and deletions, and inversions equal to half the length of the optical map (See <xref ref-type="supplementary-material" rid="sup1">Supplementary Material Section S5.3.2</xref> for details). All simulation scripts and data sets are available in the Git repository.</p>
      </sec>
      <sec>
        <title>4.1.2 Real data</title>
        <p>Although synthetic data allow us to measure the performance of OMBlast using various error models against a known gold standard, it is important to verify our method using a real data set generated from an actual experiment.</p>
        <p>To test how our alignment method performs on real data sets, we generated two sets of optical maps by using DNA from a sample of <italic>Acinetobacter baumannii</italic> 718 532 (<xref rid="btw620-B17" ref-type="bibr">Yim <italic>et al.</italic>, 2015</xref>) and a sample of <italic>E. coli</italic> K-12 MG 1655. The DNA was loaded onto the Bionano Iryschip for optical mapping data generation (<xref ref-type="supplementary-material" rid="sup1">Supplementary Material Section S8.1</xref>). The test results of <italic>A. baumannii</italic> and <italic>E. coli</italic> are included in Section 4.3.5 and <xref ref-type="supplementary-material" rid="sup1">Supplementary Material Section S8.5</xref> respectively. We also tested the alignment methods on a human data set from the individual YH produced previously (<xref rid="btw620-B3" ref-type="bibr">Cao <italic>et al.</italic>, 2014</xref>) and the results are included in Section 4.3.6.</p>
      </sec>
    </sec>
    <sec>
      <title>4.2 Analytic method of simulation results</title>
      <p>Performance of the various alignment methods is compared using running time and curves that plot precision versus recall. All of these values are averaged across the three replicates.</p>
      <p>We performed experiments on an Intel Xeon CPU E5-4640 (2.40 GHz) with 512 GB of main memory running the Ubuntu 14.04.2 operating system. Running time includes only the amount of time used by the alignment method (also called the ‘user time’).</p>
      <p>As for the accuracy of alignment methods, each method returned an alignment score for each query molecule. Although the meaning and even the range of these scores varied between alignment methods, most systems returned a single score for each alignment, which we used to rank the results. Valouev provided two sets of scores—we used the one that gave the better results. The list of alignments was sorted by score such that the best alignments appeared at the top of the list.</p>
      <p>Then, we calculated precision and recall levels at regular intervals of 10% of the entire result list to yield points on the curves. Precision was defined as the percentage of query molecules that were aligned correctly to the reference while recall was the percentage of correctly aligned results out of the 1000 molecules. More details on precision and recall analysis are described in <xref ref-type="supplementary-material" rid="sup1">Supplementary Material Section S3.3</xref>.</p>
    </sec>
    <sec>
      <title>4.3 Experimental results</title>
      <p>We tuned the default parameters for OMBlast empirically. We took into account the trade-offs between the results portrayed in precision-recall graphs and running times. The default values of OMBlast perform well, albeit not the best, for data sets with different error rates from various species. Users need not set them unless they think these values are not suitable for their purpose. Details of the preliminary experiments are described in <xref ref-type="supplementary-material" rid="sup1">Supplementary Material Section S4</xref> with default values highlighted in the graphs. The default values in OMBlast were used throughout the following analysis unless otherwise mentioned. Note that the default parameters were tuned against Bionano data. However, OMBlast could also be applied on OpGen data, as depicted in <xref ref-type="supplementary-material" rid="sup1">Supplementary Material Section S8.6</xref>.</p>
      <sec>
        <title>4.3.1 Running time</title>
        <p><xref ref-type="fig" rid="btw620-F2">Figure 2</xref> shows the alignment speed of the alignment methods across the four species, with the error rate fixed at medium and SVs being absent. RefAligner was about 10 times faster than Valouev across all organisms. The speed of OMBlast was similar to that of RefAligner for small organisms like <italic>E. coli</italic> but OMBlast ran faster than RefAligner as the genome size increased. For <italic>H. sapiens</italic>, OMBlast was about 10 times faster than RefAligner. SOMA was the slowest alignment method, and was 1000 times slower than OMBlast for <italic>E. coli</italic> and <italic>S. cerevisiae</italic>. Because of this, our experiments with SOMA on the <italic>C. elegans</italic> and <italic>H. sapiens</italic> data sets could not complete within a reasonable time limit. TWIN was the fastest among all alignment methods, but was only slightly faster than OMBlast for <italic>H. sapiens</italic>. TWIN achieves the higher speed by sacrificing error tolerance, which leads to much lower accuracy, as explained later in Section 4.3.3. The presence of SVs has little impact on the running time of each of the alignment methods (Results not shown).</p>
        <fig id="btw620-F2" orientation="portrait" position="float">
          <label>Fig. 2</label>
          <caption>
            <p>Alignment speed (user time) of different alignment methods at medium error across four species, without any SVs. Along the horizontal axis is the user time in seconds on a logarithmic scale. (*) Results of SOMA for the <italic>C. elegans</italic> and <italic>H. sapiens</italic> data sets are missing from this graph</p>
          </caption>
          <graphic xlink:href="btw620f2"/>
        </fig>
      </sec>
      <sec>
        <title>4.3.2 Memory</title>
        <p>Except TWIN, memory usage of the other alignment methods was inversely correlated with the mapping speed (<xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S23</xref>). TWIN used the least memory despite its shortest running time. OMBlast used the most memory in the alignment process.</p>
        <p>The reported number does not reflect the true memory usage of OMBlast because OMBlast is written in Java, which performs garbage collection automatically and reclaims memory only when needed. To check the minimum memory required by OMBlast, a range of thresholds was applied to limit Java’s memory usage. The minimum memory requirement for OMBlast was 250 MB, but higher running times were observed, which could be attributed to the system being pre-occupied with garbage collection. When the memory limit was set to 5 GB, which was similar to the memory usage of RefAligner, OMBlast attained its shortest running time (<xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S26</xref>).</p>
      </sec>
      <sec>
        <title>4.3.3 Alignment accuracy without SVs</title>
        <p>Next, we examine the performance of the various alignment methods in the absence of SVs. Due to the exceptionally long running time as described in Section 4.3.1, SOMA was only run on the <italic>E. coli</italic> and <italic>S. cerevisiae</italic> data sets. <xref ref-type="fig" rid="btw620-F3">Figure 3</xref> and <xref ref-type="supplementary-material" rid="sup1">Supplementary Material Section S6.2</xref> show the precision-recall graphs on <italic>H. sapiens</italic> and other data sets respectively, across all four error rates. Intuitively, as the error rate increases, more molecules are not aligned, or are aligned to the incorrect location, lowering both precision and recall.</p>
        <fig id="btw620-F3" orientation="portrait" position="float">
          <label>Fig. 3</label>
          <caption>
            <p>Precision-recall graphs for the <italic>H. sapiens</italic> data set for the four error rates. Results for SOMA are unavailable because the executions for this data set could not complete</p>
          </caption>
          <graphic xlink:href="btw620f3"/>
        </fig>
        <p>There is only tiny difference among the five programs in the absence of errors. However, the difference in performance becomes more noticeable as error rate increases. TWIN, as indicated by <xref rid="btw620-B11" ref-type="bibr">Muggli <italic>et al.</italic> (2014)</xref>, is not suitable for data with extra or missing signals. Its performance drops much more significantly than other alignment methods upon introduction of any error even with only measurement and resolution errors introduced. (For more details please refer to <xref ref-type="supplementary-material" rid="sup1">Supplementary Material Section S6.2</xref>). Valouev performs better than SOMA and TWIN in terms of both precision and recall. OMBlast and RefAligner perform the best among all alignment methods and their precision-recall graphs are very similar. The only difference appears at the end of the precision-recall graphs, where RefAligner tends to report more alignments. In this way, RefAligner attains higher recall than OMBlast, but sacrifices precision in the process.</p>
      </sec>
      <sec>
        <title>4.3.4 Alignment accuracy with SVs</title>
        <p>Next, we considered the performance of the alignment methods in the presence of artificially created SVs. The trade-offs between precision and recall are summarised in the precision-recall graphs of <xref ref-type="fig" rid="btw620-F4">Figure 4</xref> for the <italic>H. sapiens</italic> data set with a medium error rate and various SVs incorporated as different sub-panels. TWIN, as mentioned before, does not perform well due to the lack of error tolerance. The performance of Valouev dropped significantly upon any SVs being introduced. OMBlast and RefAligner performed the best. Like the results without SVs, RefAligner sacrifices precision for higher recall for 50 kbp insertions, 50 kbp deletions and 100 kbp deletions. Among these cases, precision of RefAligner drops even more significantly to beyond 75%. OMBlast outperforms RefAligner on both precision and recall for the 100 kbp insertion and inversion data sets.</p>
        <fig id="btw620-F4" orientation="portrait" position="float">
          <label>Fig. 4</label>
          <caption>
            <p>Precision-recall graphs of the alignment methods (without SOMA) in the absence (left, center panel) and presence (all other panels) of different SVs. The other panels from left to right, top to down are: deletion of 100 kbp, deletion of 50 kbp, insertion of 50 kbp, insertion of 100 kbp and inversion. The synthetic <italic>H. sapiens</italic> data set is used, with a medium error rate</p>
          </caption>
          <graphic xlink:href="btw620f4"/>
        </fig>
        <p>It is generally harder to achieve high recall in the presence of large insertions as compared with the presence of large deletions. This can be attributed to (i) extra signals appearing in the inserted part as noise and (ii) reduced number of signals on the molecules that come from the reference due to the inserted part. OMBlast can handle inversions with similar performance as 50 kbp deletions.</p>
        <p><xref ref-type="fig" rid="btw620-F5">Figure 5</xref> depicts an example of an alignment of an inversion-containing query. Valouev, RefAligner and OMBlast with Insertion/Deletion mode ‘on’ have failed to align the query correctly. Valouev aligns the query to an incorrect genomic position. Alignments of RefAligner and OMBlast with Insertion/Deletion mode ‘on’ are located at the correct genomic region, but they could not reflect the presence of an inversion in the molecule. OMBlast with Inversion mode ‘on’ provides the correct alignment with the indicated inversion.</p>
        <fig id="btw620-F5" orientation="portrait" position="float">
          <label>Fig. 5</label>
          <caption>
            <p>An example of aligning simulated data in the presence of inversion. The scale represents the genomic position of the alignment and each tick mark on the scale represents 10 kbp. Only OMBlast with Inversion mode ‘on’ provides the correct alignment. Valouev aligns the query at a completely wrong genomic region. RefAligner and OMBlast with Insertion/Deletion mode ‘on’ align the query at the correct place, but the alignment is in fact incorrect and could not reflect the presence of inversion</p>
          </caption>
          <graphic xlink:href="btw620f5"/>
        </fig>
      </sec>
      <sec>
        <title>4.3.5 <italic>A. baumannii</italic> data</title>
        <p>Since no complete genome was available, the data were filtered (<xref ref-type="supplementary-material" rid="sup1">Supplementary Material Section S8.3</xref>) and aligned against the concatenated scaffolds assembled from <italic>A. baumannii</italic> 718532 (<xref rid="btw620-B17" ref-type="bibr">Yim <italic>et al.</italic>, 2015</xref>) and the representative genome ATCC_17978 (NC_009085.1).</p>
        <p>In the absence of an artificially created set of correct answers, we chose to compare the alignment methods with each other in a pair-wise fashion. We define <italic>consistency</italic> as the ratio of the number of consistent alignments between two alignment methods to the number of molecules with alignments that are reported by both alignment methods. Two alignments from two alignment methods are consistent if their corresponding regions on the reference and query overlap. Limitations in the comparison include false alignments not being captured, and the value is less accurate when an alignment method produces very few results. Our findings show that OMBlast and RefAligner produced highly consistent results, while SOMA had low consistency with other alignment methods (<xref rid="btw620-T1" ref-type="table">Table 1</xref>). Valouev has reported the highest number of alignments (<xref rid="btw620-T2" ref-type="table">Table 2</xref>), because it attempted to align almost all optical maps. Similar consistency values were obtained when using ATCC_17978 as the representative genome (<xref ref-type="supplementary-material" rid="sup1">Supplementary Material Section S8.5</xref>).
<table-wrap id="btw620-T1" orientation="portrait" position="float"><label>Table 1</label><caption><p>Consistency of pairs of optical mapping alignment methods on the concatenated scaffold of <italic>A. baumannii</italic> 718 532</p></caption><table frame="hsides" rules="groups"><colgroup span="1"><col valign="top" align="left" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="char" char="." span="1"/></colgroup><thead><tr><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1">OMBlast</th><th rowspan="1" colspan="1">RefAligner</th><th rowspan="1" colspan="1">Valouev</th><th rowspan="1" colspan="1">SOMA</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">OMBlast</td><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">99.4%</td><td rowspan="1" colspan="1">84.1%</td><td rowspan="1" colspan="1">51.2%</td></tr><tr><td rowspan="1" colspan="1">RefAligner</td><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">87.2%</td><td rowspan="1" colspan="1">48.5%</td></tr><tr><td rowspan="1" colspan="1">Valouev</td><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">34.5%</td></tr></tbody></table><table-wrap-foot><fn id="btw620-TF1"><p>Percentages represent the ratio of consistent alignments to the total number of alignments reported by both alignment methods.</p></fn></table-wrap-foot></table-wrap><table-wrap id="btw620-T2" orientation="portrait" position="float"><label>Table 2</label><caption><p>Number of alignments reported by each alignment methods on the <italic>A. baumannii</italic> data set with 4531 filtered optical maps</p></caption><table frame="hsides" rules="groups"><colgroup span="1"><col valign="top" align="left" span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/></colgroup><thead><tr><th rowspan="1" colspan="1">No. of Alignments</th><th rowspan="1" colspan="1">718 532</th><th rowspan="1" colspan="1">ATCC_17978</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">OMBlast</td><td rowspan="1" colspan="1">1821</td><td rowspan="1" colspan="1">1937</td></tr><tr><td rowspan="1" colspan="1">RefAligner</td><td rowspan="1" colspan="1">1944</td><td rowspan="1" colspan="1">1745</td></tr><tr><td rowspan="1" colspan="1">Valouev</td><td rowspan="1" colspan="1">4495</td><td rowspan="1" colspan="1">4492</td></tr><tr><td rowspan="1" colspan="1">SOMA</td><td rowspan="1" colspan="1">333</td><td rowspan="1" colspan="1">281</td></tr><tr><td rowspan="1" colspan="1">TWIN</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">0</td></tr></tbody></table></table-wrap></p>
        <p>Aligning molecules with SVs with actual experimental data is exemplified by the alignment shown in <xref ref-type="fig" rid="btw620-F6">Figure 6</xref>. Only OMBlast and Valouev have output alignments for the target molecule on the representative genome ATCC_17978. The alignments of OMBlast and Valouev are coherent in region 2. However, Valouev aligns region 1 by matching the query to the reference without considering the potential deletion event. OMBlast, instead, aligns region 1 to a region nearby and explicitly indicates a deletion event in the reference. Valouev attempts to align region 3, but such an alignment is of lower confidence than region 2.</p>
        <fig id="btw620-F6" orientation="portrait" position="float">
          <label>Fig. 6</label>
          <caption>
            <p>The alignment of molecule 28925 (query) from the <italic>A. baumannii</italic> data set on to the ATCC_17978 <italic>in silico</italic> genome map (reference). Although RefAligner forgoes the alignment of this molecule, OMBlast and Valouev align the molecule to similar genomic regions. Three sub-regions are highlighted in the alignments. One could distinguish the alignment confidence by looking at the number of extra or missing signals, and the deviation in difference in size of segments between the query and the reference. Region 2 is consistently aligned by OMBlast and Valouev. In contrast, the alignment of Valouev in region 1 appears less correct than the alignment of OMBlast. Valouev attempts to align region 3 but such an alignment is of lower confidence</p>
          </caption>
          <graphic xlink:href="btw620f6"/>
        </fig>
      </sec>
      <sec>
        <title>4.3.6 Human data</title>
        <p>To investigate the performance of alignment methods on high-throughput human data, a real data set from the individual YH (<xref rid="btw620-B3" ref-type="bibr">Cao <italic>et al.</italic>, 2014</xref>) was downloaded for alignment against the human reference genome hg38. Here we only compared the performance of OMBlast and RefAligner, because Valouev alignments could not be completed within a month. Duplicated optical maps were removed (<xref ref-type="supplementary-material" rid="sup1">Supplementary Material Section S8.2</xref>) and further filtering by the number of signals and length was performed (<xref ref-type="supplementary-material" rid="sup1">Supplementary Material Section S8.3</xref>).</p>
        <p>To report on the accuracy, we developed a precision estimation scheme that we call <italic>precision metrics</italic>. The precision metrics estimate the precision of real results based on the relationship between alignment scores and the alignment accuracy observed from the alignment results of the simulated data in Section 4.3.3. First, alignments from the simulated data sets were sorted by descending order of alignment score and separated into 10 equally-sized bins. The accuracy of each bin can be calculated based on the number of correct and wrong simulated alignments inside. After constructing these bins, each alignment from the real data set was categorized into a bin according to their alignment score so that the accuracy of the bin could be assigned to that alignment.</p>
        <p>Precision metrics were then calculated by summing up the assigned accuracy across the alignments. Our findings show that both alignment methods yield largely consistent results. Although OMBlast aligns fewer optical maps than RefAligner (<xref rid="btw620-T3" ref-type="table">Table 3</xref>, Total alignments) due to the more stringent default options, it attains higher estimated overall precision (<xref rid="btw620-T3" ref-type="table">Table 3</xref>, Estimated Pecision). To compare the estimated precision under the same recall level as OMBlast, we pruned the RefAligner results so that only the top 382 429 alignments with the highest score were retained. From this pruned result set, the estimated precision is very similar to that of the observed OMBlast results. The pruning of the RefAligner results illustrates the trade-off between precision and recall of the two systems.
<table-wrap id="btw620-T3" orientation="portrait" position="float"><label>Table 3</label><caption><p>Alignment statistics of OMBlast and RefAligner on the YH data set</p></caption><table frame="hsides" rules="groups"><thead><tr><th rowspan="1" colspan="1"/><th align="center" rowspan="1" colspan="1">OMBlast</th><th colspan="2" align="center" rowspan="1">RefAligner<hr/></th></tr><tr><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th align="center" rowspan="1" colspan="1">Unpruned</th><th align="center" rowspan="1" colspan="1">Pruned</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">Total optical maps</td><td align="center" rowspan="1" colspan="1">1 457 446</td><td align="center" rowspan="1" colspan="1">1 457 446</td><td align="center" rowspan="1" colspan="1">1 457 446</td></tr><tr><td rowspan="1" colspan="1">Total alignments</td><td align="center" rowspan="1" colspan="1">382 429</td><td align="center" rowspan="1" colspan="1">843 768</td><td align="center" rowspan="1" colspan="1">382 429</td></tr><tr><td rowspan="1" colspan="1">Consistency</td><td align="center" rowspan="1" colspan="1">98.4%</td><td align="center" rowspan="1" colspan="1">N/A</td><td align="center" rowspan="1" colspan="1">N/A</td></tr><tr><td rowspan="1" colspan="1"/><td align="center" rowspan="1" colspan="1"><inline-formula id="IE31"><mml:math id="IEQ31"><mml:mrow><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mn>332</mml:mn><mml:mo> </mml:mo><mml:mn>587</mml:mn></mml:mrow><mml:mrow><mml:mn>337</mml:mn><mml:mo> </mml:mo><mml:mn>997</mml:mn></mml:mrow></mml:mfrac></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1">Depth of coverage</td><td align="center" rowspan="1" colspan="1">21.2%</td><td align="center" rowspan="1" colspan="1">45.3%</td><td align="center" rowspan="1" colspan="1">27.0%</td></tr><tr><td rowspan="1" colspan="1">Fraction of</td><td align="center" rowspan="1" colspan="1">91.6%</td><td align="center" rowspan="1" colspan="1">97.9%</td><td align="center" rowspan="1" colspan="1">96.3%</td></tr><tr><td rowspan="1" colspan="1">genome aligned<xref ref-type="table-fn" rid="btw620-TF3"><sup>a</sup></xref></td><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1">Estimated precision</td><td align="center" rowspan="1" colspan="1">99.5 ± 0.5%</td><td align="center" rowspan="1" colspan="1">82.0 ± 1.2%</td><td align="center" rowspan="1" colspan="1">99.7 ± 0.2%</td></tr><tr><td rowspan="1" colspan="1">Precise alignments</td><td align="center" rowspan="1" colspan="1">380 466 ± 1893</td><td align="center" rowspan="1" colspan="1">691 990 ± 9841</td><td align="center" rowspan="1" colspan="1">381 113 ± 775</td></tr><tr><td rowspan="1" colspan="1">Unique alignments</td><td align="center" rowspan="1" colspan="1">44 432</td><td align="center" rowspan="1" colspan="1">505771</td><td align="center" rowspan="1" colspan="1">N/A</td></tr><tr><td rowspan="1" colspan="1">Estimated precision</td><td align="center" rowspan="1" colspan="1">99.5 ± 0.5%</td><td align="center" rowspan="1" colspan="1">71.5 ± 1.7%</td><td align="center" rowspan="1" colspan="1">N/A</td></tr></tbody></table><table-wrap-foot><fn id="btw620-TF2"><p>Precision metrics were estimated from the simulated data set.</p></fn><fn id="btw620-TF3"><label>a</label><p>Portion of the genome covered by at least one alignment. The percentage approaches 100% with increasing data coverage. A low percentage implies that some regions are always missed by the alignment method. Also, if the reference used in the alignment is not perfect and contains errors, a very high percentage suggests non-specific alignment at misaligned regions.</p></fn></table-wrap-foot></table-wrap></p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>5 Discussion</title>
    <p>We have described OMBlast, a fast alignment method aimed at aligning high-throughput optical maps while preserving overall alignment precision and recall. The underlying algorithm of OMBlast is a seed-and-extend method, where seeds are initially formed from consecutive segment lengths. Using this approach, OMBlast can retrieve local alignments from various portions of the molecules. After extension, overlapping partial alignments are merged and then joined. These two steps further link the local alignments and give a more comprehensive alignment result, which is extremely useful when handling data with SVs.</p>
    <p>Experiments with synthetic data without SVs have shown that alignment with OMBlast gives recall levels that are just below RefAligner and Valouev. However, precision is high and running time is equal to or less than the current state-of-the-art. RefAligner and OMBlast achieve the best trade-off between precision and recall. More importantly, OMBlast has superior performance with data with insertions, deletions or inversions due to the seed-and-extend approach coupled with alignment joining.</p>
    <p>Properly dealing with SVs for larger eukaryotic genomes is paramount—it is one of the main applications of optical mapping (<xref rid="btw620-B3" ref-type="bibr">Cao <italic>et al.</italic>, 2014</xref>). Furthermore, assisted scaffolding of NGS contigs requires accurate alignment of contigs on optical mapping scaffolds. This underlying technique of OMBlast is crucial in handling a wide range of variations and mis-assemblies in the contigs during scaffolding. Since optical mapping assembly relies on pairwise alignment, a high mapping speed would help accelerate the process. Instead, RefAligner and Valouev do not support combination of partial alignments and thus could not handle the inverted alignment of a sub-region.</p>
    <p>We note that our experiments included both SOMA and TWIN. Since SOMA had noticeably longer running times, it is not suitable for larger eukaryotic genomes. Also, <xref rid="btw620-B11" ref-type="bibr">Muggli <italic>et al.</italic> (2014)</xref> indicated that TWIN is not applicable to data with SVs. Both SOMA and TWIN are designed for sequence assembly finishing and not alignment of high-throughput optical maps, the focus of OMBlast. Of course, SOMA and TWIN have other advantages, which may influence the future direction for OMBlast. We will further demonstrate the use of OMBlast in scaffolding, especially in polyzygous genome. In addition, a more complicated relationship system will be built for alignment in complex regions to include other cases of genome arrangements. In this manuscript, we demonstrated the ability of OMBlast to align optical maps correctly and the alignment could reflect the presence of SV. Yet we did not present any comprehensive SV results. An automated, statistically-based method is still required for proper SV detection and verification of aligned optical maps as one direction for our future work. Our experiments have shown that all alignment methods have difficulties in dealing with SVs. OMBlast performs well, but the low recall clearly indicates that there remains room for improvement.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="sup1">
      <label>Supplementary Data</label>
      <media xlink:href="btw620_supp.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgements</title>
    <p>The authors would like to thank the anonymous reviewers for their insightful comments that greatly improved the article.</p>
    <sec>
      <title>Funding</title>
      <p>This work is partially supported by the Health and Medical Research Fund 12110542, RGC Collaborative Research Fund (CUHK3/CRF/11G and C4042-14G), Theme-based research schemes T12-403/11, T12-401/13R and T12-402/13-N of the Hong Kong Government, and the Lo Kwee-Seong Biomedical Research Fund and Lee Hysan Foundation.</p>
      <p><italic>Conflict of Interest</italic>: none declared.</p>
    </sec>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="btw620-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Altschul</surname><given-names>S.F.</given-names></name></person-group><etal>et al</etal> (<year>1990</year>) <article-title>Basic local alignment search tool</article-title>. <source>J. Mol. Biol</source>., <volume>215</volume>, <fpage>403</fpage>–<lpage>410</lpage>.<pub-id pub-id-type="pmid">2231712</pub-id></mixed-citation>
    </ref>
    <ref id="btw620-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bradnam</surname><given-names>K.R.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) <article-title>Assemblathon 2: evaluating de novo methods of genome assembly in three vertebrate species</article-title>. <source>GigaScience</source>, <volume>2</volume>.</mixed-citation>
    </ref>
    <ref id="btw620-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Cao</surname><given-names>H.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) <article-title>Rapid detection of structural variation in a human genome using nanochannel-based genome mapping technology</article-title>. <source>GigaScience</source>, <volume>3</volume>.</mixed-citation>
    </ref>
    <ref id="btw620-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Das</surname><given-names>S.K.</given-names></name></person-group><etal>et al</etal> (<year>2010</year>) <article-title>Single molecule linear analysis of DNA in nano-channel labeled with sequence specific fluorescent probes</article-title>. <source>Nucleic Acids Res</source>., <volume>38</volume>, <fpage>1</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">19843612</pub-id></mixed-citation>
    </ref>
    <ref id="btw620-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Dimalanta</surname><given-names>E.T.</given-names></name></person-group><etal>et al</etal> (<year>2004</year>) <article-title>A microfluidic system for large DNA molecule arrays</article-title>. <source>Anal. Chem</source>., <volume>76</volume>, <fpage>5293</fpage>–<lpage>5301</lpage>.<pub-id pub-id-type="pmid">15362885</pub-id></mixed-citation>
    </ref>
    <ref id="btw620-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Dong</surname><given-names>Y.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) <article-title>Sequencing and automated whole-genome optical mapping of the genome of a domestic goat (Capra hircus)</article-title>. <source>Nat. Biotechnol</source>., <volume>31</volume>, <fpage>135</fpage>–<lpage>141</lpage>.<pub-id pub-id-type="pmid">23263233</pub-id></mixed-citation>
    </ref>
    <ref id="btw620-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lam</surname><given-names>E.T.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) <article-title>Genome mapping on nanochannel arrays for structural variation analysis and sequence assembly</article-title>. <source>Nat. Biotechnol</source>., <volume>30</volume>, <fpage>771</fpage>–<lpage>776</lpage>.<pub-id pub-id-type="pmid">22797562</pub-id></mixed-citation>
    </ref>
    <ref id="btw620-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lin</surname><given-names>H.C.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) <article-title>AGORA: assembly guided by optical restriction alignment</article-title>. <source>BMC Bioinformatics</source>, <volume>13</volume>, <fpage>189.</fpage><pub-id pub-id-type="pmid">22856673</pub-id></mixed-citation>
    </ref>
    <ref id="btw620-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Mendelowitz</surname><given-names>L.</given-names></name>, <name name-style="western"><surname>Pop</surname><given-names>M.</given-names></name></person-group> (<year>2014</year>) <article-title>Computational methods for optical mapping</article-title>. <source>GigaScience</source>, <volume>3</volume>.</mixed-citation>
    </ref>
    <ref id="btw620-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Miller</surname><given-names>J.M.</given-names></name></person-group> (<year>2013</year>) <article-title>Whole-genome mapping: a new paradigm in strain-typing technology</article-title>. <source>J. Clin. Microbiol</source>., <volume>51</volume>, <fpage>1066</fpage>–<lpage>1070</lpage>.<pub-id pub-id-type="pmid">23363821</pub-id></mixed-citation>
    </ref>
    <ref id="btw620-B11">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Muggli</surname><given-names>M.D.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>). <chapter-title>Efficient indexed alignment of contigs to optical maps</chapter-title> In <person-group person-group-type="editor"><name name-style="western"><surname>Brown</surname><given-names>D.</given-names></name>, <name name-style="western"><surname>Morgenstern</surname><given-names>B.</given-names></name></person-group>, editors, <source>Proceedings of the 14th International Workshop on Algorithms in Bioinformatics (WABI 2014), Volume 8701 of Lecture Notes in Computer Science</source>, pp. <fpage>68</fpage>–<lpage>81</lpage>. <publisher-name>Springer Berlin Heidelberg</publisher-name>.</mixed-citation>
    </ref>
    <ref id="btw620-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Nagarajan</surname><given-names>N.</given-names></name></person-group><etal>et al</etal> (<year>2008</year>) <article-title>Scaffolding and validation of bacterial genome assemblies using optical restriction maps</article-title>. <source>Bioinformatics</source>, <volume>24</volume>, <fpage>1229</fpage>–<lpage>1235</lpage>.<pub-id pub-id-type="pmid">18356192</pub-id></mixed-citation>
    </ref>
    <ref id="btw620-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Reinhart</surname><given-names>W.F.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) <article-title>Distribution of distances between DNA barcode labels in nanochannels close to the persistence length</article-title>. <source>J. Chem. Phys</source>., <volume>142</volume>, <fpage>064902.</fpage><pub-id pub-id-type="pmid">25681938</pub-id></mixed-citation>
    </ref>
    <ref id="btw620-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Shelton</surname><given-names>J.M.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) <article-title>Tools and pipelines for BioNano data: molecule assembly pipeline and FASTA super scaffolding tool</article-title>. <source>BMC Genomics</source>, <volume>16</volume>, <fpage>734.</fpage><pub-id pub-id-type="pmid">26416786</pub-id></mixed-citation>
    </ref>
    <ref id="btw620-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Valouev</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2006</year>) <article-title>Alignment of optical maps</article-title>. <source>J. Comput. Biol</source>., <volume>13</volume>, <fpage>442</fpage>–<lpage>462</lpage>.<pub-id pub-id-type="pmid">16597251</pub-id></mixed-citation>
    </ref>
    <ref id="btw620-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Van Dijk</surname><given-names>E.L.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) <article-title>Ten years of next-generation sequencing technology</article-title>. <source>Trends Genet</source>., <volume>30</volume>.</mixed-citation>
    </ref>
    <ref id="btw620-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Yim</surname><given-names>A.K.Y.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) <article-title>Draft genome sequence of extensively drug-resistant Acinetobacter baumannii strain CUAB1 from a patient in Hong Kong, China</article-title>. <source>Genome Announce</source>., <volume>3</volume>.</mixed-citation>
    </ref>
  </ref-list>
</back>
