<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Front Genet</journal-id>
    <journal-id journal-id-type="iso-abbrev">Front Genet</journal-id>
    <journal-id journal-id-type="publisher-id">Front. Genet.</journal-id>
    <journal-title-group>
      <journal-title>Frontiers in Genetics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1664-8021</issn>
    <publisher>
      <publisher-name>Frontiers Media S.A.</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7884812</article-id>
    <article-id pub-id-type="doi">10.3389/fgene.2021.618659</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Genetics</subject>
        <subj-group>
          <subject>Methods</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>BLVector: Fast BLAST-Like Algorithm for Manycore CPU With Vectorization</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Gálvez</surname>
          <given-names>Sergio</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="c001">
          <sup>*</sup>
        </xref>
        <uri xlink:type="simple" xlink:href="http://loop.frontiersin.org/people/584258/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Agostini</surname>
          <given-names>Federico</given-names>
        </name>
        <xref ref-type="aff" rid="aff2">
          <sup>2</sup>
        </xref>
        <uri xlink:type="simple" xlink:href="http://loop.frontiersin.org/people/1115097/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Caselli</surname>
          <given-names>Javier</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
        <uri xlink:type="simple" xlink:href="http://loop.frontiersin.org/people/1186974/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Hernandez</surname>
          <given-names>Pilar</given-names>
        </name>
        <xref ref-type="aff" rid="aff3">
          <sup>3</sup>
        </xref>
        <uri xlink:type="simple" xlink:href="http://loop.frontiersin.org/people/457500/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Dorado</surname>
          <given-names>Gabriel</given-names>
        </name>
        <xref ref-type="aff" rid="aff4">
          <sup>4</sup>
        </xref>
        <uri xlink:type="simple" xlink:href="http://loop.frontiersin.org/people/291819/overview"/>
      </contrib>
    </contrib-group>
    <aff id="aff1"><sup>1</sup><institution>Departamento Lenguajes y Ciencias de la Computación, Universidad de Málaga</institution>, <addr-line>Málaga</addr-line>, <country>Spain</country></aff>
    <aff id="aff2"><sup>2</sup><institution>Instituto de Botánica del Nordeste (IBONE), Universidad Nacional del Nordeste</institution>, <addr-line>Corrientes</addr-line>, <country>Argentina</country></aff>
    <aff id="aff3"><sup>3</sup><institution>Instituto de Agricultura Sostenible (IAS-CSIC), Consejo Superior de Investigaciones Científicas</institution>, <addr-line>Córdoba</addr-line>, <country>Spain</country></aff>
    <aff id="aff4"><sup>4</sup><institution>Departamento Bioquímica y Biología Molecular, Campus Rabanales C6-1-E17, Campus de Excelencia Internacional Agroalimentario (ceiA3), Universidad de Córdoba</institution>, <addr-line>Córdoba</addr-line>, <country>Spain</country></aff>
    <author-notes>
      <fn fn-type="edited-by">
        <p>Edited by: Tze Meng Low, Carnegie Mellon University, United States</p>
      </fn>
      <fn fn-type="edited-by">
        <p>Reviewed by: Doru Adrian Thom Popovici, Lawrence Berkeley National Laboratory, United States; Richard Veras, Louisiana State University, United States</p>
      </fn>
      <corresp id="c001">*Correspondence: Sergio Gálvez, <email>galvez@uma.es</email></corresp>
      <fn fn-type="other" id="fn004">
        <p>This article was submitted to Computational Genomics, a section of the journal Frontiers in Genetics</p>
      </fn>
    </author-notes>
    <pub-date pub-type="epub">
      <day>02</day>
      <month>2</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2021</year>
    </pub-date>
    <volume>12</volume>
    <elocation-id>618659</elocation-id>
    <history>
      <date date-type="received">
        <day>17</day>
        <month>10</month>
        <year>2020</year>
      </date>
      <date date-type="accepted">
        <day>15</day>
        <month>1</month>
        <year>2021</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2021 Gálvez, Agostini, Caselli, Hernandez and Dorado.</copyright-statement>
      <copyright-year>2021</copyright-year>
      <copyright-holder>Gálvez, Agostini, Caselli, Hernandez and Dorado</copyright-holder>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License (CC BY). The use, distribution or reproduction in other forums is permitted, provided the original author(s) and the copyright owner(s) are credited and that the original publication in this journal is cited, in accordance with accepted academic practice. No use, distribution or reproduction is permitted which does not comply with these terms.</license-p>
      </license>
    </permissions>
    <abstract>
      <p>New High-Performance Computing architectures have been recently developed for commercial central processing unit (CPU). Yet, that has not improved the execution time of widely used bioinformatics applications, like BLAST+. This is due to a lack of optimization between the bases of the existing algorithms and the internals of the hardware that allows taking full advantage of the available CPU cores. To optimize the new architectures, algorithms must be revised and redesigned; usually rewritten from scratch. BLVector adapts the high-level concepts of BLAST+ to the x86 architectures with AVX-512, to harness their capabilities. A deep comprehensive study has been carried out to optimize the approach, with a significant reduction in time execution. BLVector reduces the execution time of BLAST+ when aligning up to mid-size protein sequences (∼750 amino acids). The gain in real scenario cases is 3.2-fold. When applied to longer proteins, BLVector consumes more time than BLAST+, but retrieves a much larger set of results. BLVector and BLAST+ are fine-tuned heuristics. Therefore, the relevant results returned by both are the same, although they behave differently specially when performing alignments with low scores. Hence, they can be considered complementary bioinformatics tools.</p>
    </abstract>
    <kwd-group>
      <kwd>proteins</kwd>
      <kwd>parallel algorithm</kwd>
      <kwd>benchmarking</kwd>
      <kwd>pairwise alignment</kwd>
      <kwd>database search</kwd>
    </kwd-group>
    <counts>
      <fig-count count="6"/>
      <table-count count="0"/>
      <equation-count count="0"/>
      <ref-count count="31"/>
      <page-count count="10"/>
      <word-count count="0"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec id="S1">
    <title>Introduction</title>
    <p>Currently, the Basic Local-Alignment Search Tool, BLAST (<xref rid="B2" ref-type="bibr">Altschul et al., 1990</xref>), is one of the most widely used algorithms to search for sequence similarities in Bioinformatics. BLAST+ has been designed to be quickly executed by standard multicore microprocessors in a hardware environment, where cores are very powerful, memory accesses are extremely fast, and there is no contention among the different cores. Unfortunately, this is not the hardware scenario for the recent manycore central processing unit (CPU) coprocessors, like the Intel Xeon Phi (<xref rid="B18" ref-type="bibr">Jeffers et al., 2016</xref>), TILE-Gx (<xref rid="B29" ref-type="bibr">Schooler, 2010</xref>) or massively parallel processor array (MPPA)-256 (<xref rid="B6" ref-type="bibr">De Dinechin and Graillat, 2017</xref>), where cores are less powerful, coordination between a huge amounts of threads is slow, cache sizes are small, and cache faults are heavily penalized. As an example, Intel recognizes that executing BLAST+ directly on Xeon Phi in native mode is up to 3-fold slower than using a standard Xeon E5 processor (<xref rid="B1" ref-type="bibr">Albert, 2015</xref>). Other implementations of BLAST specifically designed for multi- and many-core architectures, like HPC BLAST (<xref rid="B28" ref-type="bibr">Sawyer et al., 2019</xref>), which strictly follows the BLAST heuristic algorithm, do not improve these outcomes too much, at least when the results in Xeon Phi are compared to traditional microprocessors, like Intel Xeon E5-2670 (<xref rid="B4" ref-type="bibr">Brook et al., 2014</xref>).</p>
    <p>To optimize the performance of a manycore CPU executing BLAST+ or any BLAST-like application, the internal algorithm must be adapted to use the strengths of the underlying architecture: vectorization and multithreading (<xref rid="B20" ref-type="bibr">Langenkämper et al., 2016</xref>). We present BLVector, a BLAST-like algorithm that works with peptide (protein) sequences. BLVector is designed specifically to use the Single-Instruction Multiple Data (SIMD) vector instructions of the Advanced Vector eXtensions (AVX)-512 instruction set, as well as its multithread capabilities. We have previously demonstrated the usefulness of optimizing bioinformatics algorithms to significantly enhance performance (<xref rid="B13" ref-type="bibr">Gálvez et al., 2010</xref>, <xref rid="B14" ref-type="bibr">2016</xref>; <xref rid="B7" ref-type="bibr">Díaz et al., 2011</xref>, <xref rid="B8" ref-type="bibr">2014</xref>; <xref rid="B9" ref-type="bibr">Esteban et al., 2013</xref>, <xref rid="B10" ref-type="bibr">2018</xref>).</p>
    <p>The main contributions of BLVector are: (i) Implementation of the Smith-Waterman (S/W) pairwise local alignment algorithm, following the Farrar’s approach with vectors of 512 bits (AVX-512); (ii) A filtering stage ensures that only promising local pairwise alignments are performed; (iii) Such filtering stage uses AVX-512 vectors for a faster execution. Applying the filter to two sequences is up to 1,000% faster than the corresponding pairwise alignment without such filtering step; (iv) Thread-level parallelism maximizes the usage of computational power available in manycore CPU systems; (v) The hits retrieved with this approach are pretty similar to those obtained with BLAST+, but the execution is faster in most situations; and (vi) Different parameters of BLVector allow dealing with a trade-off between accuracy and performance.</p>
    <p>In this work, the design of this new heuristic is presented. A deep benchmark is carried out, based on its execution on a single Xeon Phi coprocessor and other architectures. It is important to note that, although there are newer processors, this is a proof of concept. Additionally, the Intel Xeon Phi is currently in many HPC solutions. In fact, six of the Top 25 supercomputers listed in <ext-link ext-link-type="uri" xlink:href="https://www.top500.org">https://www.top500.org</ext-link> (November, 2020) incorporate the Intel Xeon Phi technology; and this number increases when other architectures that include the AVX-512 instruction set are considered, like Intel Skylake-X, Cascade Lake and others.</p>
  </sec>
  <sec id="S2">
    <title>Methods</title>
    <p>BLVector is a heuristic algorithm that follows two stages to search for peptide sequences: (i) filtering; and (ii) local pairwise alignment. Many efforts have been made to execute brute-force pairwise alignments, so BLVector focuses in the filtering stage to speed up its execution. To do this, we have created an approach that takes the most from the new SIMD AVX-512 instruction set, by applying them to both stages.</p>
    <p>In contrast to BLAST+ (blastp), which uses a hash table to search for 3-mer substrings, BLVector uses a brute-force method to search for common 4-mer substrings between the query and the subject sequence. Using one byte per amino acid (aa) residue, BLVector packs four bytes in a simple 32-bit integer. Besides, by using SIMD vector instructions, it compares a single query integer (four aa residues from the query sequence) against 16 subject integers (16 blocks of four aa residues in the subject sequence), in parallel in a single clock cycle per instruction: 16 integers × 32 bits = 512 bits. Section “BLVector Search for 4-mer” provides further information about it.</p>
    <p>BLVector considers that a subject sequence might be a promising hit when, at least, there are four 4-mer matches in a query window of 16 consecutive aa residues, though this can be parameterized. In such a case, BLVector executes a local alignment (<xref rid="B30" ref-type="bibr">Smith and Waterman, 1981</xref>) against the query, in order to determine if the subject is actually a relevant hit. To do this, a new Farrar’s implementation (<xref rid="B11" ref-type="bibr">Farrar, 2007</xref>) of the S/W algorithm has been developed from scratch using the AVX-512 architecture, although other approaches may also be used for such a purpose. This behavior is different to blastp, which executes a search around each 3-mer match to expand it; only when its size and score is beyond a threshold, the subject sequence is considered as a relevant hit. In addition to vectorization, BLVector uses a multiprocessing approach, taking the most from the manycore CPU architecture, by executing four threads per core (see section “BLVector Execution Architecture”).</p>
    <p>The Farrar algorithm is an elegant method to apply vectorization to a single Smith-Waterman pairwise alignment. Based on a complex rearrangement of indices, it assumes that most cells in the dynamic programming matrix will be zero. This allow an intensive application of SIMD vector instructions, and only in a few cases is needed to execute a correction stage that penalizes the algorithm. The Farrar approach is the fastest known to perform single local alignments. It suits to the BLVector operating mode, where an alignment is performed as soon as a new promising subject sequence passes its filtering stage. This way, a single thread of BLVector interleaves the execution of the filtering and alignment stages. Other methods, like <xref rid="B25" ref-type="bibr">Rognes (2011)</xref>, are adapted to work faster with sets of subject sequences. Regarding performance, BLVector provides three main parameters:</p>
    <p>Nearby: Number of 4-mer matches to be found in a 16 aa-residue window of a subject sequence, to be considered as a potential hit. As this value increases, the sensitivity of BLVector decreases.</p>
    <p>Cluster: To increase sensitivity, aa-residue letters can be grouped based on their distribution statistics<sup><xref ref-type="fn" rid="footnote1">1</xref></sup>.</p>
    <p>Faster: This Boolean parameter makes BLVector execute a non-exhaustive search, looking for 4-mer only in even positions.</p>
    <sec id="S2.SS1">
      <title>BLVector Search for 4-mer</title>
      <p>The key point of the filtering implementation is the utilization of specific memory data structures. That allows to align amino acid sequence residues (letters) of peptides or proteins in memory, as required by SIMD instructions. To do this, BLVector creates four replicas of the subject sequence stored in memory; each one of them being shorter than the previous one in 1 byte (a single residue is stored into one byte; that is, 8 bits). This speeds up the comparison of a 4-mer query against every 4-mer subject, exclusively using vectors in which the computation unit is 32 bits; i.e., 4 consecutive residues or 4-mer. Although such approach requires more main memory than BLAST+, this quadruplication is executed on-the-fly, each time that BLVector is executed. Therefore, there is no need for a previous indexation stage, as is required by the former algorithm. As in many other approaches (<xref rid="B22" ref-type="bibr">Liu et al., 2011</xref>, <xref rid="B23" ref-type="bibr">2013</xref>; <xref rid="B25" ref-type="bibr">Rognes, 2011</xref>; <xref rid="B31" ref-type="bibr">Yongchao and Schmidt, 2014</xref>). BLVector focuses on amino acid sequences because this implies the usage of relatively large score matrices, like point-accepted mutation (PAM) (<xref rid="B5" ref-type="bibr">Dayhoff et al., 1978</xref>) or blocks substitution matrix (BLOSUM) (<xref rid="B17" ref-type="bibr">Henikoff and Henikoff, 1992</xref>). Therefore, these algorithms should be used for nucleic acid (DNA or RNA) alignments, in addition to proteins, only when this type of matrices is used, as is the case of substitution matrices for aligning nucleic acid sequences using the International Union of Pure and Applied Chemistry (IUPAC) NUCleotide (NUC) ambiguity codes, like NUC.4.4.</p>
      <p><xref ref-type="fig" rid="F1">Figure 1A</xref> shows how a subject sequence of length N is quadruplicated into memory, using 64[(4N-12)/64] bytes. The resulting memory structure must be aligned to 64 bytes (512 bits) at both ends, because vectors of 512 bits are being used (a vector is interpreted as 16 consecutive units of 32 bits); and each replica is aligned to four bytes (the length of 4-mer; i.e., a string sequence of four residues). Quadruplication may be seen as a way to prebuild into memory all the vector values that will be needed in further processing.</p>
      <fig id="F1" position="float">
        <label>FIGURE 1</label>
        <caption>
          <p>Scheme of 4-mer (32 bits) searching by using vectors of 512 bits. <bold>(A)</bold> Required quadruplication of a subject sequence before searching for 4-mer. <bold>(B)</bold> How each query 4-mer is replicated 16 times into 512-bit vectors is shown. <bold>(C)</bold> Each 512-bit vector is checked against each quadruplicated subject and, hence, a single query 4-mer is searched in v<sub><italic>n</italic></sub> steps (16-fold faster than using non-vectorized instructions).</p>
        </caption>
        <graphic xlink:href="fgene-12-618659-g001"/>
      </fig>
      <p>The goal of the filtering stage is to check common substrings of length four, between a query sequence of length M and a previously quadruplicated subject. To do this, the BLVector algorithm focuses on each substring of four bytes (4-mer) length in the query sequence. Then, each 4-mer is replicated 16 times into a vector of 512 bit (4 bytes × 16 × 8 bits per byte = 512 bits of length; see <xref ref-type="fig" rid="F1">Figure 1B</xref>. This approach allows each query’s 4-mer to be checked against the subject sequence, using only v<sub><italic>n</italic></sub> = [(4N-12)/64] comparisons between vectors of 512 bits length. This is shown in <xref ref-type="fig" rid="F1">Figure 1C</xref> which, in addition, shows an example of a match of the 4-mer query at position M-4. The total number of comparisons in the worst case is (M-3) v<sub><italic>n</italic></sub>. The vector instructions used in BLVector are compatible with those of newer x86 architectures (AVX-512F) by means of intrinsic functions<sup><xref ref-type="fn" rid="footnote2">2</xref></sup>.</p>
      <p>Additionally, the rationale is to check those cases where there is a local concentration of common 4-mers between the subject and the query. To track locality, BLVector uses a 16-bit integer (named nearby) that shifts to the left for each of the M-3 iterations. When one of these iterations results in a match, then the least significant bit (LSB) of nearby is set; otherwise, it is reset. Only when the number of bits set in nearby exceeds the value of the -n parameter (nearby-threshold), it is assumed that the subject has enough local similarity to the query. In such a case, it is worth to execute a local alignment between them. If the nearby variable has never contained nearby-threshold bits set after the M-3 steps, then, the subject is discarded as a potential hit.</p>
      <p>Clearly, it can be argued that contiguous 4-mers of the query sequence may appear at very distant positions in the subject sequence. However, even in the case of random sequences, this is unlikely to happen in a section of only 16 residues, i.e., the length of the nearby integer. In the worst-case scenario, this produces a false potential hit that will be discarded after the pairwise alignment stage.</p>
    </sec>
    <sec id="S2.SS2">
      <title>BLVector Matrix Clustering</title>
      <p>Usage of a 4-mer is a must in BLVector, due to the essentials of vectorization with 32-bit replicas. Other alternatives, like 2-mer (16-bit) or 8-mer (64-bit) are too loose or restrictive, respectively, for filtering purposes. Considering that blastp uses a 3-mer for residues, we have created a method for BLVector to resemble blastp: matrix clustering.</p>
      <p>Matrix clustering consists in reducing the number of letters used in the whole algorithm; i.e., from the 21 letters used in a standard score matrix of aa residues (corresponding to the 20 natural amino acids encoded by the genetic code, plus X for unknown ones) to a minor amount. To do this, two or more letters were collapsed into a single one, following different approaches: (i) chemical families; (ii) k-means; or (iii) statistical representations. The suitability of each approach depends on the ratio between new hits and new promising hits. In other words, the average number of new pairwise alignments to be done in order to find out a new hit subject sequence. After testing these approaches, the statistical distribution of each residue available in UniProt (<xref rid="B3" ref-type="bibr">Bateman, 2019</xref>) was chosen as the main variable to apply a hierarchical clustering. By far, this method introduced the lesser noise and produced the best results.</p>
      <p>The cluster parameter allows specifying the number of letters to be used in BLVector, which ranges from 21 to 15 [that, including the wildcard symbol or asterisk (<sup>∗</sup>), fits into a nibble]. For example, using a cluster value of 20, simply assumes that the tryptophan and cysteine amino acids refer to the same residue. The rationale is that their respective statistical distributions are 1.0 and 1.3%, being the lowest reported by UniProt. This approach has proved to be more suitable than, for example, collapsing cysteine and methionine (which belong to the same sulfur-containing family of aa) to create the cluster of 20. Using lower values of the cluster introduces a blur effect in the sequences, whose final effect is that more sequences pass the filter and need to be pairwise aligned. Hence, the accuracy is increased but at the cost of reducing the speedup. At some extent, reducing the value of this parameter has a similar effect than reducing the value of the nearby parameter, albeit at the expense of introducing some noise. In general, the best results were obtained by fine-tuning the value of nearby, and using a cluster of value 21 or 20. This can be observed in the interactive figure “<ext-link ext-link-type="uri" xlink:href="https://BLVector_nX_cXX_X.html">BLVector_nX_cXX_X.html</ext-link>” (<xref rid="B15" ref-type="bibr">Gálvez et al., 2020</xref>) and <xref ref-type="supplementary-material" rid="SM1">Supplementary Material</xref> “FullMetrics.xlsx” (see section “Results and Discussion”).</p>
    </sec>
    <sec id="S2.SS3">
      <title>Non-exhaustive Heuristic Algorithm</title>
      <p>Looking for the best hit is a widely used operation. Even more, this operation is usually employed to discover the main functionality of just discovered proteins, after the assembly of a new genome. In cases like this, the user searches for very similar subjects that share long substrings with the query. In other words, a very high value for the nearby parameter in valid hits is expected. Because of this, the same most relevant results may be obtained in a faster way, by comparing just the even locations of the subject sequence (instead of both, the even and odd). Only the most promising sequences will pass the filter. So, the number of pairwise alignments to perform will decrease (including invalid hits), and the execution time of BLVector will be dramatically reduced.</p>
      <p>For this purpose, we propose to shorten the replication of the subject sequence: a duplication is used instead of a quadruplication. This is achieved by using the fast parameter -f. Thus, only the original sequence and its copy shifted 2 bytes are used in the filtering stage. Therefore, the time taken by 4-mers searches is divided by two. The drawback of this approach is that searches for 4-mer are not exhaustive, because they are looked for at even positions only. Clearly, this is a risky heuristic algorithm that should be used only when the user is looking for very similar proteins, and where the probability of skipping common 4-mer is not a problem to find the required hits. Using this method, the average gain in giga cell updates per second (GCUPS) is ∼58.7%, whereas the loss of hits is ∼49.7% (see <xref ref-type="supplementary-material" rid="SM1">Supplementary Material</xref> “FullMetrics.xlsx”).</p>
    </sec>
    <sec id="S2.SS4">
      <title>BLVector Execution Architecture</title>
      <p>A typical execution of BLVector begins loading the fast-alignment sequence tools (FAST)-All (FASTA) (<xref rid="B21" ref-type="bibr">Lipman and Pearson, 1985</xref>) database into memory, further replicating the sequences, as stated in <xref ref-type="fig" rid="F1">Figure 1A</xref>. In this stage, the random-access memory (RAM) memory may be a bottleneck; loading a RAM disk file into the RAM application memory takes 2 s per GiB. Hence, retrieving the Swiss-Prot UniProt file (∼250 MiB) into memory takes ∼0.5 s. Once the file has been loaded into memory, several threads are in charge of quadruplicating the sequences. However, from 10 threads on, no additional speed gain is obtained, due to contention to main memory accesses. Thus, the final result is that this operation is twice slower than file loading: takes ∼1 s to quadruplicate the Swiss-Prot UniProt. When only a few query sequences will be searched against the database, it is much more efficient to quadruplicate queries, instead of the whole database of subjects. Nonetheless, in this work we provide the particular (and more general) approach. Thus, it is assumed that users will search for many thousands of sequences and, thus, taking the most of the performance of BLVector in big-batch jobs.</p>
      <p>The left part of <xref ref-type="fig" rid="F2">Figure 2</xref> shows the general architecture of the Xeon Phi Coprocessor 31S1P used in this work. As the memory bus is shared among all the cores, memory-intensive tasks produced a bottleneck when they could not be fully executed inside the cache. Fortunately, this whole stage is executed only once, independently of the number q of query sequences to search for in a single execution. Yet, the time taken by this operation tends to be insignificant as q increases. Thus, it makes no sense to include it in the calculus of performance (see section “Results and Discussion”).</p>
      <fig id="F2" position="float">
        <label>FIGURE 2</label>
        <caption>
          <p>Architecture of BLVector execution in a Xeon Phi Coprocessor 31S1P with 57 cores. Each thread executes a 4-mer nearby filtering stage, as indicated in <xref ref-type="fig" rid="F1">Figure 1</xref>.</p>
        </caption>
        <graphic xlink:href="fgene-12-618659-g002"/>
      </fig>
      <p>Once each subject sequence is quadruplicated into a memory pool, the query file is also loaded and split into single FASTA sequences. Then, for each query sequence, and one after the other, the BLVector heuristic algorithm starts 228 threads (this can be changed through the -p parameter), like the one illustrated at the right of <xref ref-type="fig" rid="F2">Figure 2</xref>. This is a requirement of the Xeon Phi Coprocessor 31S1P, that contains 57 cores and requires to use 4 threads per core to obtain the maximum performance. When a thread becomes idle, it blocks the pool where the subject sequences are stored, it takes the next ten ones to process and unblocks the pool. All the threads work with the same query sequence, but against different subjects stored in the main memory: filtering them and aligning only those ones that passes the filter (see right-bottom part of <xref ref-type="fig" rid="F2">Figure 2</xref>). Taking ten sequences at each step (instead of only one) reduces threads contention and, at the same time, maintains a balanced workload amongst them. BLVector leverages this approach to noticeably increase performance. Actually, the optimal size of this local cache of proteins largely depends on the length of the query sequence (contention increases with shorter sequences), and the final value of 10 is empirical. In any case, each thread processes a subject sequence at a time (whose average length is 359 residues in Swiss-Prot UniProt release 2019_05). Therefore, the memory footprint is small, and memory-intensive operations are executed inside its own cache.</p>
      <p>The success of BLVector is mainly due to the high performance obtained through the AVX-512 SIMD instructions used in the 4-mer nearby filtering stage, although vectorization has also been used in the pairwise alignment stage. In addition, unrolling four times the main loop of this 4-mer search (by means of a #pragma), also slightly increases the performance. In short, looking for 4-mer using AVX-512 instructions is much faster (see section “Results and Discussion”) than using a hash table in standard microprocessors, as BLAST+ does. Finally, a correct alignment of data into memory is extremely important to achieve a good performance in the execution of the Smith-Waterman algorithm with affine gaps (<xref rid="B16" ref-type="bibr">Gotoh, 1982</xref>), using the stripped approach of Farrar (<xref rid="B11" ref-type="bibr">Farrar, 2007</xref>). Other approaches could be used to align many subject sequences with extreme performance. However, they do not include a filtering stage and/or they require specific servers and/or high-end graphics cards, whose cost greatly exceeds the affordable Xeon Phi Coprocessor 31S1P that BLVector may use (<xref rid="B19" ref-type="bibr">Lan et al., 2017</xref>; <xref rid="B26" ref-type="bibr">Rucci et al., 2019</xref>). Anyway, the BLVector source code could be rewritten to get the most out of any brand new hardware vectorization.</p>
    </sec>
  </sec>
  <sec id="S3">
    <title>Results and Discussion</title>
    <p>The main contributions of this implementation are the utilization of a filtering stage to reduce the amount of pairwise alignments to perform, and the efficient use of the 512-bit vectors provided by the AVX-512 instruction set, both in the filtering and alignment stages. Avoiding contention to shared memory accesses also contributes to increased efficiency.</p>
    <p>The BLVector has been tested in native mode, on a Xeon Phi Coprocessor 31S1P with 8 GiB DDR5 and 57 cores at 1.1 GHz, running 228 threads, with a thermal design power (TDP) of 270 W. It is quite affordable, with a current cost of around 200 USD. This card supports a 512-bit instruction set, named initial many core instructions (IMCI); i.e., a precursor of some AVX-512 extensions (including AVX-512F), being compatible with them by means of intrinsic functions. The behavior study of BLVector is divided into three parts: (i) performance and accuracy against blastp, including a real case of study; (ii) improvement introduced by the filtering stage; and (iii) speedup of executing the filtering stage in different architectures.</p>
    <sec id="S3.SS1">
      <title>Performance and Accuracy of BLVector</title>
      <p>BLVector has been used to search for the 32 proteins reported elsewhere (<xref rid="B25" ref-type="bibr">Rognes, 2011</xref>) using the Swiss-Prot UniProt release 2019_05 (560,292 sequences with an average length of 359 residues). Using default parameters, execution times ranged from &lt;1 s for sequences shorter than 730 aa residues to 9.2 s for proteins like P33450 (5,147 aa residues). BLVector can be considered as a Smith-Waterman alignment algorithm, with a former filtering stage that passes promising subject sequences only. Hence, we have chosen the concept of GCUPS to measure its performance against blastp (BLAST+ v2.7.1), that has been executed in two different personal computers (PC): (i) a desktop PC with an Intel Core i7-4820K CPU running at 3.70 GHz, 12 GiB of DDR3 and a Kingston HyperX 3K Solid-State Drive (SSD; 120 GB); and (ii) a workstation with an Intel Xeon W-2123 (Skylake microarchitecture) CPU with 4 cores running at 3.60 GHz, 32 GiB of DDR4 and a Corsair Force MP510 NVMe SSD (500 GB). For comparison purposes, BLVector has been executed inside the Xeon Phi card with no support of the main CPU, whereas blastp has been fully executed in the main CPU, with no support of the Xeon Phi card. The performance of the Intel i7-4820K and Xeon W-2123 used in this experiment are very close to that of the Intel Xeon E5-2670 used in other studies (<xref rid="B24" ref-type="bibr">Orozco-Arias et al., 2017</xref>; <xref rid="B28" ref-type="bibr">Sawyer et al., 2019</xref>). Therefore, the scenarios where BLVector and blastp have been executed are completely standard, and thus comparison fairness is guaranteed. In this sense, each program is executed in its native homogeneous hardware architecture. The performance of blastp is slightly better in the workstation, so it is used in the benchmarks of this discussion (see the <xref ref-type="supplementary-material" rid="SM1">Supplementary Material</xref> “FullMetrics.xlsx” for more information).</p>
      <p>BLVector and BLAST+ are heuristics, and they may return different sets of hits, in comparison to an optimal Smith-Waterman whole search. Hence, their performances should be compared for both hits retrieved (accuracy and precision), as well as execution times (speed). Different parameter values were used to benchmark BLVector time performance in comparison to blastp (see <xref ref-type="fig" rid="F3">Figure 3</xref> and <xref ref-type="supplementary-material" rid="SM1">Supplementary Material</xref>, for benchmarks with different matrices from the BLOcks SUbstitution Matrix 62 – BLOSUM62). The best ones were selected as default ones.</p>
      <fig id="F3" position="float">
        <label>FIGURE 3</label>
        <caption>
          <p>Speed performance of BLVector with 228 threads vs. BLAST+ using BLOSUM62. BLAST+ times are the same in every chart. The top charts show executions of BLVector with parameter -n from 1 to 8 and -c 21 (left) and -c 20 (right). The bottom ones represent the same executions, but including the non-exhaustive parameter -f. Execution speeds are represented in GCUPS. As an example, in the top-left diagram, BLVector uses cluster c21 and nearby values from n1 to n8; the speed of BLVector exceeds BLAST+ from n3 on.</p>
        </caption>
        <graphic xlink:href="fgene-12-618659-g003"/>
      </fig>
      <p><xref ref-type="fig" rid="F4">Figure 4A</xref> shows the amount of hits found by BLAST+ (blastp), but not by BLVector (see the interactive figure “<ext-link ext-link-type="uri" xlink:href="https://BLVector_nX_cXX_X.html">BLVector_Nx_Cxx_X.html</ext-link>” (<xref rid="B15" ref-type="bibr">Gálvez et al., 2020</xref>) for hits retrieved by BLVector in contrast to BLAST+, when using different sets of parameters). In general, BLVector misses tens of hits whose bit-score is lower than 200; i.e., those less relevant, and this happens mainly for the shortest proteins. In contrast, when dealing with long proteins, larger than one kilobase (kb), BLAST+ misses thousands of hits, which are correctly returned by BLVector; see <xref ref-type="fig" rid="F4">Figure 4B</xref> and interactive figure “BLAST_all_hits_vs_BLVector.html” (<xref rid="B15" ref-type="bibr">Gálvez et al., 2020</xref>).</p>
      <fig id="F4" position="float">
        <label>FIGURE 4</label>
        <caption>
          <p>Hits performance of BLVector vs. BLAST+ using BLOSUM62. <italic>X</italic> axis shows the names of the proteins used for benchmarking. <bold>(A)</bold> How many hits given by BLAST+ are not given by BLVector, using -n 3 and -c 21 parameters. These hits are divided into six sets, depending on the bitscore given by BLAST+, ranging from &lt;100 to ≥300. <bold>(B)</bold> BLAST+ (blastp) misses thousands of hits correctly returned by BLVector, with proteins larger than 1 kb (see vertical axis labels). These hits are divided into four sets, depending on the score given by BLVector.</p>
        </caption>
        <graphic xlink:href="fgene-12-618659-g004"/>
      </fig>
      <p><xref ref-type="fig" rid="F5">Figure 5</xref> shows how many hits reported by BLAST+ are skipped by a pure Smith-Waterman algorithm (i.e., removing the nearby filtering stage of BLVector; see the interactive figure “Farrar.html” (<xref rid="B15" ref-type="bibr">Gálvez et al., 2020</xref>) for more details). It reveals that BLAST+ provides hits even below the default threshold used by BLVector (score of 80 using BLOSUM62). The interactive figure “<ext-link ext-link-type="uri" xlink:href="https://BLVector_nX_cXX_X.html">BLVector_nX_cXX_X.html</ext-link>” (<xref rid="B15" ref-type="bibr">Gálvez et al., 2020</xref>) must be studied taking these results into account. Thus, it displays the hits skipped by BLVector with different parameters: -n from 1 to 8, -c from 15 to 21 and activating/deactivating -f. The corresponding and most interesting execution times, expressed in GCUPS, are illustrated in <xref ref-type="fig" rid="F3">Figure 3</xref>, and the complete set can be found in the <xref ref-type="supplementary-material" rid="SM1">Supplementary Material</xref> “FullMetrics.xlsx.” All times and GCUPS values are the average results of three independent executions, under the same conditions, including default parameters. BLVector may achieve higher performance with short proteins, by reducing the number of threads to avoid contention. In other words, BLVector is heavily penalized when using a large number of threads, like the default value of 228, for short sequences. For large sequences, this default value obtains the best results and, in addition, uses the resources of the coprocessor at full load.</p>
      <fig id="F5" position="float">
        <label>FIGURE 5</label>
        <caption>
          <p>Number of hits retrieved by BLAST+, but not by a Smith-Waterman execution. BLOSUM62 and default parameters have been used in both cases; Smith-Waterman was set with a threshold score of 80.</p>
        </caption>
        <graphic xlink:href="fgene-12-618659-g005"/>
      </fig>
      <p>In a real world scenario, an all vs. all search was executed between the primary proteins of the cereal genomics model grass <italic>Brachypodium distachyon</italic> 314 reference genome (v3.1 containing 34,310 protein sequences and 12,944,043 aa residues, with an average length of ∼377 aa residues per protein<sup><xref ref-type="fn" rid="footnote3">3</xref></sup>; and the ∼32,000 primary proteins of the drought-stress tolerant variety ABR8 (containing 32,609 protein sequences, with an average length of 366 residues) (<xref rid="B12" ref-type="bibr">Fisher et al., 2016</xref>). These proteins are relatively short, so the time taken by BLVector to start 228 threads was even more that the time used to process a single protein. Hence, a best performance was achieved with a lower number of threads per protein. Using five simultaneous executions of BLVector, each one with 44 threads (parameters as -p 44 -n 3 -c 21 -f), consumed just 628 s to execute the whole task, instead of 2,022 s taken by blastp (parameters as -num_threads 8 -outfmt 6 -max_target_seqs 1 -max_hsps 1). That represents a performance gain of 3.22-fold with the same relevant output results. The performance achieved by each BLVector instance execution was relatively uniform, ranging between 49.2 and 49.5 GCUPS with a wattage consumption of ∼160 W (∼92 W when idle), a constant user CPU usage of ∼93% and a memory utilization of 1.32 GiB.</p>
    </sec>
    <sec id="S3.SS2">
      <title>The Filtering Stage and Its Speedup</title>
      <p>It is important to estimate how much time saves BLVector, when compared to a whole S/W execution. When a sequence is rejected in the filtering stage, no local pairwise alignment should be executed. So, the total time to process such a sequence has been the filtering time. On the other hand, when the filtering stage foregoes a sequence, the local alignment must be executed, so the total time to manage the sequence is the filtering plus the alignment times.</p>
      <p><xref ref-type="fig" rid="F6">Figure 6A</xref> benchmarks the times of two theoretically extreme executions of BLVector: i) pure Smith-Waterman (<xref rid="B11" ref-type="bibr">Farrar, 2007</xref>), without filtering stage; and (ii) pure 4-mer nearby filtering stage, without Smith-Waterman execution (nearby of ∞). The filtering stage using 512-bit vectors is approximately one order of magnitude faster than the execution of the Farrar algorithm. The gain achieved by applying the filtering stage (represented by bars) can be split in three main blocks: (i) up to the average length of proteins in Swiss-Prot UniProt 2019_05 (359 aa) with a gain of ∼5×; (ii) from 361 aa up to 567 aa with a gain of ∼7×; and (iii) from 657 aa on with a gain of ∼10× (a maximum of 11.8× is achieved on P42357, with a length of 657 aa). This implies that the overload of applying the filtering stage to a hit protein is around 10% whereas the time saved when applied to a non-hit protein is between 500 and 1,000%. Logically, there is a direct relationship between the speedup gain and the percentage of filtered sequences that, in turn, depends on the parameters of BLVector (see the <xref ref-type="supplementary-material" rid="SM1">Supplementary Material</xref> “FullMetrics.xlsx” and “Charts SW”).</p>
      <fig id="F6" position="float">
        <label>FIGURE 6</label>
        <caption>
          <p>BLVector execution times in relation to sequence length. Both vertical axes are logarithmic and <italic>X</italic> axis shows the lengths of the proteins used for benchmarking. <bold>(A)</bold> Benchmarks of the 4-mer nearby filtering stage versus the corresponding Smith-Waterman execution in the Xeon-Phi. <bold>(B)</bold> A comparison of the filtering stage execution times among different architectures: Xeon-Phi (31S1P), CUDA (GTX 1080Ti) and Skylake (Xeon W-2123).</p>
        </caption>
        <graphic xlink:href="fgene-12-618659-g006"/>
      </fig>
    </sec>
    <sec id="S3.SS3">
      <title>The Filtering Stage in Other Architectures</title>
      <p>By far, the most relevant part of BLVector is the filtering stage and its performance. For this reason, it is important to compare its throughput when executed in other widespread hardware architectures. <xref ref-type="fig" rid="F6">Figure 6B</xref> includes a comparison of the filtering stage (nearby of ∞, i.e., maximum accuracy and execution time of this stage) executions times among different architectures, including CUDA (<xref rid="B27" ref-type="bibr">Ryoo et al., 2008</xref>). The graphics card used for this test has been a GTX 1080Ti with 11 GiB of GDDR5X running 3584 cores at 1.48 GHz and a TDP of 250 W. It must be noted that the implementation in CUDA of the BLVector filtering stage does not require the quadruplication of the data because the vectorization used in Xeon-Phi is translated into simpler memory accesses. The proteins used in this benchmark are allocated into CUDA shared memory, and this significantly improves the speed up. In addition, the memory unalignment problem is resolved in CUDA by using 32-bit integers shifted 8 bits in each new comparison, achieving, this way, a minimum number of memory accesses in the inner loop of the algorithm. With the outstanding resources of the card used (62.8× more cores, 1.38× more memory and 1.35× faster), the CUDA approach achieves only a gain of ∼25% in the best cases.</p>
      <p>The BLVector filtering stage behaves extremely fast when executed on manycore CPU systems with small cache sizes, many threads per core and heavily penalized accesses to main memory. For comparison purposes, it is advisable to test how the filtering stage behaves when executed on a workstation CPU. Thus, the BLVector filtering stage has been recompiled in an Intel Xeon W-2123 (Skylake microarchitecture) CPU with 4 cores running at 3.60 GHz and 32 GiB of DDR4 RAM memory, as well as a Corsair Force MP510 NVMe SSD (500 GB). This is one of the simplest AVX-512 capable Intel processors, with only 4 cores and a TDP of 120 W. <xref ref-type="fig" rid="F6">Figure 6B</xref> shows also the behavior of the filtering stage in this CPU. This implementation scales exactly the same than in Xeon-Phi, though it is ∼1.6× slower with a 44.4% of its TDP. Finally, a complete execution in the real case scenario explained in section 0 consumed just 909 s (average of three executions), only a 45% slower than the Xeon Phi and 2.22-fold faster than blastp executed in the same CPU. This result shows that the AVX-512 set of instructions has a really promising future when correctly used, and its usage in current supercomputers with these SIMD instructions should enhance its performance.</p>
    </sec>
  </sec>
  <sec id="S4">
    <title>Conclusion</title>
    <p>As said, the BLVector is a heuristic algorithm like BLAST+ (blastp), searching for local similarities as a filtering step prior to perform S/W executions. Because it relies on local alignments, BLVector is halfway between a pure heuristic and a pure brute-force method. This work shows that modern algorithms must be designed focusing on current CPU architectures to obtain optimum performances, instead of older, traditional architectures. That can be accomplished by using the simplest portion of the recent x86 vector instructions set: AVX-512F. In addition, the design is simplified using two stages, a front-end filter and a back-end pairwise aligner, both based on vectorization. Deep benchmarking analyses reveal that BLVector is a fast algorithm that provides accurate results. And, in real world scenarios, it produces the same results than blastp, but faster. Filtering a sequence through the 4-mer method is up to 11.8-fold quicker than calculating its S/W score, so it can be applied not only to Farrar algorithm, but also to any brute-force approach (<xref rid="B25" ref-type="bibr">Rognes, 2011</xref>; <xref rid="B26" ref-type="bibr">Rucci et al., 2019</xref>), as a way to speed it up.</p>
    <p>In a future work, several coprocessors may be used to benchmark BLVector on larger databases; e.g., the Viridiplantae portion of the Translation of the European Molecular Biology Laboratory (TrEMBL) amino acid sequence database (∼5 GB), splitting it into parts and compounding results as in <xref rid="B14" ref-type="bibr">Gálvez et al. (2016)</xref>. To avoid many splits of the database, quadruplication of query subjects may be an option in order to save memory. In addition, a new version of S/W –using AVX-512BW– providing also sequence alignments would be useful. BLVector can be easily used in blastx mode; i.e., translating a nucleotide sequence from double-stranded DNA (dsDNA) or double-stranded RNA (dsRNA) into their six representations of amino acids (reading frames), to address scenarios where only nucleic-acid sequences are available. Finally, it will be very interesting to know the behavior of BLVector when implemented through the recent Intel oneAPI in order to use not only CPU but also GPU with minor efforts. To do this, the alignment stage implementation based on Farrar algorithm can be substituted by that of <xref rid="B25" ref-type="bibr">Rognes (2011)</xref>.</p>
  </sec>
  <sec sec-type="data-availability" id="S5">
    <title>Data Availability Statement</title>
    <p>Publicly available datasets were analyzed in this study. This data can be found here: <ext-link ext-link-type="uri" xlink:href="https://www.uniprot.org">https://www.uniprot.org</ext-link> (Swiss-Prot UniProt 2019_05) and <ext-link ext-link-type="uri" xlink:href="https://phytozome.jgi.doe.gov">https://phytozome.jgi.doe.gov</ext-link> (<italic>Brachypodium distachyon</italic> 314 reference genome). The source code of BLVector is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/galvezuma/BLVector">https://github.com/galvezuma/BLVector</ext-link>.</p>
  </sec>
  <sec id="S6">
    <title>Author Contributions</title>
    <p>All authors participated in the development, performed testing and analyses, as well as the writing of the manuscript, and revised the final version.</p>
  </sec>
  <sec sec-type="COI-statement" id="conf1">
    <title>Conflict of Interest</title>
    <p>The authors declare that the research was conducted in the absence of any commercial or financial relationships that could be construed as a potential conflict of interest.</p>
  </sec>
</body>
<back>
  <fn-group>
    <fn fn-type="financial-disclosure">
      <p><bold>Funding.</bold> This work was supported by the Ministerio de Ciencia e Innovación (MINECO grants BIO2015-64737-R, PID2019-109089RB-C32, and PID2019-108195GB-I00), Instituto Nacional de Investigación y Tecnología Agraria y Alimentaria (MINECO and INIA RF2012-00002-C02-02), Consejería de Agricultura y Pesca (041/C/2007, 75/C/2009, and 56/C/2010), Consejería de Economía, Innovación y Ciencia (P18-RT-992 and P11-AGR-7322), Grupo PAI (AGR-248) of Junta de Andalucía, and Universidad de Córdoba (Ayuda a Grupos), Spain.</p>
    </fn>
  </fn-group>
  <fn-group>
    <fn id="footnote1">
      <label>1</label>
      <p><ext-link ext-link-type="uri" xlink:href="https://www.uniprot.org/statistics/Swiss-Prot">https://www.uniprot.org/statistics/Swiss-Prot</ext-link> 2019_05</p>
    </fn>
    <fn id="footnote2">
      <label>2</label>
      <p>
        <ext-link ext-link-type="uri" xlink:href="https://software.intel.com/sites/landingpage/IntrinsicsGuide">https://software.intel.com/sites/landingpage/IntrinsicsGuide</ext-link>
      </p>
    </fn>
    <fn id="footnote3">
      <label>3</label>
      <p>
        <ext-link ext-link-type="uri" xlink:href="https://phytozome.jgi.doe.gov">https://phytozome.jgi.doe.gov</ext-link>
      </p>
    </fn>
  </fn-group>
  <sec id="S8" sec-type="supplementary material">
    <title>Supplementary Material</title>
    <p>The Supplementary Material for this article can be found online at: <ext-link ext-link-type="uri" xlink:href="https://www.frontiersin.org/articles/10.3389/fgene.2021.618659/full#supplementary-material">https://www.frontiersin.org/articles/10.3389/fgene.2021.618659/full#supplementary-material</ext-link></p>
    <supplementary-material content-type="local-data" id="SM1">
      <media xlink:href="Table_1.XLSX">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
  <ref-list>
    <title>References</title>
    <ref id="B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Albert</surname><given-names>G.</given-names></name></person-group> (<year>2015</year>). <source><italic>BLAST for the Intel<sup>®</sup> Xeon PhiTM Coprocessor.</italic></source> Avaliable at: <ext-link ext-link-type="uri" xlink:href="https://www.intel.es/content/www/es/es/healthcare-it/solutions/genomicscode-blast.html">https://www.intel.es/content/www/es/es/healthcare-it/solutions/genomicscode-blast.html</ext-link>
<comment>(accessed November 1, 2020)</comment>.</mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Altschul</surname><given-names>S. F.</given-names></name><name><surname>Gish</surname><given-names>W.</given-names></name><name><surname>Miller</surname><given-names>W.</given-names></name><name><surname>Myers</surname><given-names>E.-M.</given-names></name><name><surname>Lipman</surname><given-names>D. J.</given-names></name></person-group> (<year>1990</year>). <article-title>Basic local alignment search tool.</article-title>
<source><italic>J. Mol. Biol.</italic></source>
<volume>215</volume>
<fpage>403</fpage>–<lpage>410</lpage>.<pub-id pub-id-type="pmid">2231712</pub-id></mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bateman</surname><given-names>A.</given-names></name></person-group> (<year>2019</year>). <article-title>UniProt: a worldwide hub of protein knowledge.</article-title>
<source><italic>Nucleic Acids Res.</italic></source>
<volume>47</volume>
<fpage>D506</fpage>–<lpage>D515</lpage>. <pub-id pub-id-type="doi">10.1093/nar/gky1049</pub-id>
<?supplied-pmid 30395287?><pub-id pub-id-type="pmid">30395287</pub-id></mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Brook</surname><given-names>R. G.</given-names></name><name><surname>Sawyer</surname><given-names>S.</given-names></name><name><surname>Rekepalli</surname><given-names>B.</given-names></name></person-group> (<year>2014</year>). “<article-title>HPC-BLAST scalable sequence analysis for the intel<sup>®</sup> many integrated core future</article-title>,” in <source><italic>Supercomputing 2014.</italic></source> Avaliable at: <ext-link ext-link-type="uri" xlink:href="https://www.ixpug.org/docs/sc14_ixpug_bof_brook.pdf">https://www.ixpug.org/docs/sc14_ixpug_bof_brook.pdf</ext-link>
<comment>(accessed November 1, 2020)</comment>.</mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Dayhoff</surname><given-names>M. O.</given-names></name><name><surname>Schwartz</surname><given-names>R. M.</given-names></name><name><surname>Orcutt</surname><given-names>B. C.</given-names></name></person-group> (<year>1978</year>). “<article-title>A model for evolutionary change in proteins</article-title>,” in <source><italic>Atlas of Protein Sequence and Structure</italic></source>, <volume>Vol. 5</volume>
<role>ed.</role>
<person-group person-group-type="editor"><name><surname>Dayhoff</surname><given-names>M. O.</given-names></name></person-group> (<publisher-loc>Washington, DC</publisher-loc>: <publisher-name>National Biomedical Research Foundation</publisher-name>), 345.</mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>De Dinechin</surname><given-names>B. D.</given-names></name><name><surname>Graillat</surname><given-names>A.</given-names></name></person-group> (<year>2017</year>). “<article-title>Network-on-chip service guarantees on the kalray MPPA-256 bostan processor</article-title>,” in <source><italic>ACM International Conference Proceeding Series</italic></source>, <publisher-loc>Stockholm</publisher-loc>, <pub-id pub-id-type="doi">10.1145/3073763.3073770</pub-id></mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Díaz</surname><given-names>D.</given-names></name><name><surname>Esteban</surname><given-names>F. J.</given-names></name><name><surname>Hernández</surname><given-names>P.</given-names></name><name><surname>Caballero</surname><given-names>J. A.</given-names></name><name><surname>Dorado</surname><given-names>G.</given-names></name><name><surname>Gálvez</surname><given-names>S.</given-names></name></person-group> (<year>2011</year>). <article-title>Parallelizing and optimizing a bioinformatics pairwise sequence alignment algorithm for many-core architecture.</article-title>
<source><italic>Parallel Comput.</italic></source>
<volume>37</volume>
<fpage>244</fpage>–<lpage>259</lpage>. <pub-id pub-id-type="doi">10.1016/j.parco.2011.03.003</pub-id></mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Díaz</surname><given-names>D.</given-names></name><name><surname>Esteban</surname><given-names>F. J.</given-names></name><name><surname>Hernández</surname><given-names>P.</given-names></name><name><surname>Caballero</surname><given-names>J. A.</given-names></name><name><surname>Guevara</surname><given-names>A.</given-names></name><name><surname>Dorado</surname><given-names>G.</given-names></name><etal/></person-group> (<year>2014</year>). <article-title>MC64-ClustalWP2: a highly-parallel hybrid strategy to align multiple sequences in many-core architectures.</article-title>
<source><italic>PLoS One</italic></source>
<volume>9</volume>:<issue>e94044</issue>. <pub-id pub-id-type="doi">10.1371/journal.pone.0094044</pub-id>
<?supplied-pmid 24710354?><pub-id pub-id-type="pmid">24710354</pub-id></mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Esteban</surname><given-names>F. J.</given-names></name><name><surname>Díaz</surname><given-names>D.</given-names></name><name><surname>Hernández</surname><given-names>P.</given-names></name><name><surname>Caballero</surname><given-names>J. A.</given-names></name><name><surname>Dorado</surname><given-names>G.</given-names></name><name><surname>Gálvez</surname><given-names>S.</given-names></name></person-group> (<year>2013</year>). <article-title>Direct approaches to exploit many-core architecture in bioinformatics.</article-title>
<source><italic>Future Gener. Comput. Syst.</italic></source>
<volume>29</volume>
<fpage>15</fpage>–<lpage>26</lpage>.</mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Esteban</surname><given-names>F. J.</given-names></name><name><surname>Díaz</surname><given-names>D.</given-names></name><name><surname>Hernández</surname><given-names>P.</given-names></name><name><surname>Caballero</surname><given-names>J. A.</given-names></name><name><surname>Dorado</surname><given-names>G.</given-names></name><name><surname>Gálvez</surname><given-names>S.</given-names></name></person-group> (<year>2018</year>). <article-title>MC64-Cluster: many-core CPU cluster architecture and performance analysis in B-Tree searches.</article-title>
<source><italic>Comput. J</italic>,</source>
<volume>61</volume>
<fpage>912</fpage>–<lpage>925</lpage>. <pub-id pub-id-type="doi">10.1093/comjnl/bxx114</pub-id></mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Farrar</surname><given-names>M.</given-names></name></person-group> (<year>2007</year>). <article-title>Striped Smith-Waterman speeds database searches six times over other SIMD implementations.</article-title>
<source><italic>Bioinformatics</italic></source>
<volume>23</volume>
<fpage>156</fpage>–<lpage>161</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btl582</pub-id>
<?supplied-pmid 17110365?><pub-id pub-id-type="pmid">17110365</pub-id></mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fisher</surname><given-names>L. H. C.</given-names></name><name><surname>Han</surname><given-names>J.</given-names></name><name><surname>Corke</surname><given-names>F. M. K.</given-names></name><name><surname>Akinyemi</surname><given-names>A.</given-names></name><name><surname>Didion</surname><given-names>T.</given-names></name><name><surname>Nielsen</surname><given-names>K. K.</given-names></name><etal/></person-group> (<year>2016</year>). <article-title>Linking dynamic phenotyping with metabolite analysis to study natural variation in drought responses of brachypodium distachyon.</article-title>
<source><italic>Front. Plant Sci.</italic></source>
<volume>7</volume>:<issue>1751</issue>. <pub-id pub-id-type="doi">10.3389/fpls.2016.01751</pub-id>
<?supplied-pmid 27965679?><pub-id pub-id-type="pmid">27965679</pub-id></mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gálvez</surname><given-names>S.</given-names></name><name><surname>Díaz</surname><given-names>D.</given-names></name><name><surname>Hernández</surname><given-names>P.</given-names></name><name><surname>Esteban</surname><given-names>F. J.</given-names></name><name><surname>Caballero</surname><given-names>J. A.</given-names></name><name><surname>Dorado</surname><given-names>G.</given-names></name></person-group> (<year>2010</year>). <article-title>Next-generation bioinformatics: using many-core processor architecture to develop a web service for sequence alignment.</article-title>
<source><italic>Bioinformatics</italic></source>
<volume>26</volume>
<fpage>683</fpage>–<lpage>686</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btq017</pub-id>
<?supplied-pmid 20081221?><pub-id pub-id-type="pmid">20081221</pub-id></mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gálvez</surname><given-names>S.</given-names></name><name><surname>Ferusic</surname><given-names>A.</given-names></name><name><surname>Esteban</surname><given-names>F. J.</given-names></name><name><surname>Hernández</surname><given-names>P.</given-names></name><name><surname>Caballero</surname><given-names>J. A.</given-names></name><name><surname>Dorado</surname><given-names>G.</given-names></name></person-group> (<year>2016</year>). <article-title>Speeding-up bioinformatics algorithms with heterogeneous architectures: highly heterogeneous smith-waterman (HHeterSW).</article-title>
<source><italic>J. Comput. Biol.</italic></source>
<volume>23</volume>
<fpage>801</fpage>–<lpage>809</lpage>. <pub-id pub-id-type="doi">10.1089/cmb.2015.0237</pub-id>
<?supplied-pmid 27104636?><pub-id pub-id-type="pmid">27104636</pub-id></mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Gálvez</surname><given-names>S.</given-names></name><name><surname>Agostini</surname><given-names>F.</given-names></name><name><surname>Caselli</surname><given-names>J.</given-names></name><name><surname>Hernández</surname><given-names>P.</given-names></name><name><surname>Dorado</surname><given-names>G.</given-names></name></person-group> (<year>2020</year>). <source><italic>Frontiers in Genetics. MSID: 618659. BLVector: Fast BLAST-like Algorithm for Manycore CPU With Vectorization.</italic></source>
<publisher-name>Figshare</publisher-name>, <pub-id pub-id-type="doi">10.6084/m9.figshare.c.5266346.v2</pub-id></mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gotoh</surname><given-names>O.</given-names></name></person-group> (<year>1982</year>). <article-title>An improved algorithm for matching biological sequences.</article-title>
<source><italic>J. Mol. Biol.</italic></source>
<volume>162</volume>
<fpage>705</fpage>–<lpage>708</lpage>.<pub-id pub-id-type="pmid">7166760</pub-id></mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Henikoff</surname><given-names>S.</given-names></name><name><surname>Henikoff</surname><given-names>J. G.</given-names></name></person-group> (<year>1992</year>). <article-title>Amino acid substitution matrices from protein blocks.</article-title>
<source><italic>Proc. Natl. Acad. Sci. U.S.A.</italic></source>
<volume>89</volume>
<fpage>10915</fpage>–<lpage>10919</lpage>. <pub-id pub-id-type="doi">10.1073/pnas.89.22.10915</pub-id>
<?supplied-pmid 1438297?><pub-id pub-id-type="pmid">1438297</pub-id></mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Jeffers</surname><given-names>J.</given-names></name><name><surname>Reinders</surname><given-names>J.</given-names></name><name><surname>Sodani</surname><given-names>A.</given-names></name></person-group> (<year>2016</year>). “<article-title>Intel xeon Phi processor high performance programming</article-title>,” in <source><italic>Intel Xeon Phi Processor High Performance Programming</italic></source>, (<publisher-loc>Amsterdam</publisher-loc>: <publisher-name>Elsevier Inc</publisher-name>), <pub-id pub-id-type="doi">10.1016/c2015-0-00549-4</pub-id> Available online at: <ext-link ext-link-type="uri" xlink:href="https://www.sciencedirect.com/book/9780128091944/intel-xeon-phi-processor-high-performance-programming#book-info">https://www.sciencedirect.com/book/9780128091944/intel-xeon-phi-processor-high-performance-programming#book-info</ext-link></mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Lan</surname><given-names>H.</given-names></name><name><surname>Liu</surname><given-names>W.</given-names></name><name><surname>Liu</surname><given-names>Y.</given-names></name><name><surname>Schmidt</surname><given-names>B.</given-names></name></person-group> (<year>2017</year>). “<article-title>SWhybrid: a hybrid-parallel framework for large-scale protein sequence database search</article-title>,” in <source><italic>2017 IEEE International Parallel and Distributed Processing Symposium (IPDPS)</italic></source>, <publisher-loc>Orlando, FL</publisher-loc>, <fpage>42</fpage>–<lpage>51</lpage>. <pub-id pub-id-type="doi">10.1109/IPDPS.2017.42</pub-id></mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Langenkämper</surname><given-names>D.</given-names></name><name><surname>Jakobi</surname><given-names>T.</given-names></name><name><surname>Feld</surname><given-names>D.</given-names></name><name><surname>Jelonek</surname><given-names>L.</given-names></name><name><surname>Goesmann</surname><given-names>A.</given-names></name><name><surname>Nattkemper</surname><given-names>T. W.</given-names></name></person-group> (<year>2016</year>). <article-title>Comparison of acceleration techniques for selected low-level bioinformatics operations.</article-title>
<source><italic>Front. Genet.</italic></source>
<volume>7</volume>:<issue>5</issue>. <pub-id pub-id-type="doi">10.3389/fgene.2016.00005</pub-id>
<?supplied-pmid 26904094?><pub-id pub-id-type="pmid">26904094</pub-id></mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lipman</surname><given-names>D. J.</given-names></name><name><surname>Pearson</surname><given-names>W. R.</given-names></name></person-group> (<year>1985</year>). <article-title>Rapid and sensitive protein similarity searches.</article-title>
<source><italic>Science</italic></source>
<volume>227</volume>
<fpage>1435</fpage>–<lpage>1441</lpage>. <pub-id pub-id-type="doi">10.1126/science.2983426</pub-id>
<?supplied-pmid 2983426?><pub-id pub-id-type="pmid">2983426</pub-id></mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Liu</surname><given-names>W.</given-names></name><name><surname>Schmidt</surname><given-names>B.</given-names></name><name><surname>Müller-Wittig</surname><given-names>W.</given-names></name></person-group> (<year>2011</year>). <article-title>CUDA-BLASTP: accelerating BLASTP on CUDA-enabled graphics hardware.</article-title>
<source><italic>IEEE/ACM Trans. Comput. Biol. Bioinform.</italic></source>
<volume>8</volume>
<fpage>1678</fpage>–<lpage>1684</lpage>. <pub-id pub-id-type="doi">10.1109/TCBB.2011.33</pub-id>
<?supplied-pmid 21339531?><pub-id pub-id-type="pmid">21339531</pub-id></mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Liu</surname><given-names>Y.</given-names></name><name><surname>Wirawan</surname><given-names>A.</given-names></name><name><surname>Schmidt</surname><given-names>B.</given-names></name></person-group> (<year>2013</year>). <article-title>CUDASW++ 3.0: accelerating Smith-Waterman protein database search by coupling CPU and GPU SIMD instructions.</article-title>
<source><italic>BMC Bioinformatics</italic></source>
<volume>14</volume>:<issue>117</issue>. <pub-id pub-id-type="doi">10.1186/1471-2105-14-117</pub-id>
<?supplied-pmid 23557111?><pub-id pub-id-type="pmid">23557111</pub-id></mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Orozco-Arias</surname><given-names>S.</given-names></name><name><surname>Camargo-Forero</surname><given-names>L.</given-names></name><name><surname>Correa</surname><given-names>J. C.</given-names></name><name><surname>Guyot</surname><given-names>R.</given-names></name><name><surname>Cristancho</surname><given-names>M.</given-names></name></person-group> (<year>2017</year>). <article-title>BIOS-parallelblast: paralelización optimizada de alineamiento de secuencias sobre Xeon Phi.</article-title>
<source><italic>Ing., Invest. Tecnol.</italic></source>
<volume>18</volume>
<fpage>423</fpage>–<lpage>432</lpage>.</mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rognes</surname><given-names>T.</given-names></name></person-group> (<year>2011</year>). <article-title>Faster smith-waterman database searches with inter-sequence SIMD parallelisation.</article-title>
<source><italic>BMC Bioinformatics</italic></source>
<volume>12</volume>:<issue>221</issue>. <pub-id pub-id-type="doi">10.1186/1471-2105-12-221</pub-id>
<?supplied-pmid 21631914?><pub-id pub-id-type="pmid">21631914</pub-id></mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rucci</surname><given-names>E.</given-names></name><name><surname>Garcia Sanchez</surname><given-names>C.</given-names></name><name><surname>Botella Juan</surname><given-names>G.</given-names></name><name><surname>De Giusti</surname><given-names>A.</given-names></name><name><surname>Naiouf</surname><given-names>M.</given-names></name><name><surname>Prieto-Matias</surname><given-names>M.</given-names></name></person-group> (<year>2019</year>). <article-title>SWIMM 2.0: enhanced smith–waterman on intel’s multicore and manycore architectures based on AVX-512 vector extensions.</article-title>
<source><italic>Int. J. Parallel Programm.</italic></source>
<volume>47</volume>
<fpage>296</fpage>–<lpage>316</lpage>. <pub-id pub-id-type="doi">10.1007/s10766-018-0585-7</pub-id></mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Ryoo</surname><given-names>S.</given-names></name><name><surname>Rodrigues</surname><given-names>C. I.</given-names></name><name><surname>Baghsorkhi</surname><given-names>S. S.</given-names></name><name><surname>Stone</surname><given-names>S. S.</given-names></name><name><surname>Kirk</surname><given-names>D. B.</given-names></name><name><surname>Hwu</surname><given-names>W. M. W.</given-names></name></person-group> (<year>2008</year>). “<article-title>Optimization principles and application performance evaluation of a multithreaded GPU using CUDA</article-title>,” in <source><italic>Proceedings of the ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, PPOPP</italic></source>, <publisher-loc>Salt Lake City, UT</publisher-loc>, <pub-id pub-id-type="doi">10.1145/1345206.1345220</pub-id></mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Sawyer</surname><given-names>S.</given-names></name><name><surname>Burdyshaw</surname><given-names>C.</given-names></name><name><surname>Brook</surname><given-names>G.</given-names></name><name><surname>Rekapalli</surname><given-names>B.</given-names></name><name><surname>Horton</surname><given-names>M.</given-names></name></person-group> (<year>2019</year>). “<article-title>HPC-BLAST: distributed BLAST for modern HPC clusters</article-title>,” in <source><italic>BiCOB2019</italic></source>, <volume>Vol. 60</volume>
<role>eds</role>
<person-group person-group-type="editor"><name><surname>Eulenstein</surname><given-names>O.</given-names></name><name><surname>Al-Mubaid</surname><given-names>H.</given-names></name><name><surname>Ding</surname><given-names>Q.</given-names></name></person-group> (<publisher-loc>Manchester</publisher-loc>: <publisher-name>EasyChair</publisher-name>), <fpage>1</fpage>–<lpage>14</lpage>.</mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Schooler</surname><given-names>R.</given-names></name></person-group> (<year>2010</year>). “<article-title>Tile processors: many-core for embedded and cloud computing</article-title>,” in <source><italic>Workshop on High Performance Embedded Computing.</italic></source> Massachusetts</mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Smith</surname><given-names>T. F.</given-names></name><name><surname>Waterman</surname><given-names>M. S.</given-names></name></person-group> (<year>1981</year>). <article-title>Identification of common molecular subsequences.</article-title>
<source><italic>J. Mol. Biol.</italic></source>
<volume>147</volume>
<fpage>195</fpage>–<lpage>197</lpage>.<pub-id pub-id-type="pmid">7265238</pub-id></mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Yongchao</surname><given-names>L.</given-names></name><name><surname>Schmidt</surname><given-names>B.</given-names></name></person-group> (<year>2014</year>). “<article-title>SWAPHI: smith-waterman protein database search on Xeon Phi coprocessors</article-title>,” in <source><italic>Application-Specific Systems, Architectures and Processors (ASAP), 2014 IEEE 25th International Conference On</italic></source>, <publisher-loc>Zurich</publisher-loc>, <fpage>184</fpage>–<lpage>185</lpage>. <pub-id pub-id-type="doi">10.1109/ASAP.2014.6868657</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
