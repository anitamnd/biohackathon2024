<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.0 20120330//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Genome Res</journal-id>
    <journal-id journal-id-type="iso-abbrev">Genome Res</journal-id>
    <journal-id journal-id-type="hwp">genome</journal-id>
    <journal-id journal-id-type="publisher-id">GENOME</journal-id>
    <journal-title-group>
      <journal-title>Genome Research</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1088-9051</issn>
    <issn pub-type="epub">1549-5469</issn>
    <publisher>
      <publisher-name>Cold Spring Harbor Laboratory Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">9341511</article-id>
    <article-id pub-id-type="pmid">35858749</article-id>
    <article-id pub-id-type="medline">9509184</article-id>
    <article-id pub-id-type="doi">10.1101/gr.276434.121</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Method</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>TransMeta simultaneously assembles multisample RNA-seq reads</article-title>
      <alt-title alt-title-type="left-running">Yu et al.</alt-title>
      <alt-title alt-title-type="right-running">TransMeta: multisample transcriptome assembler</alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" equal-contrib="yes">
        <name>
          <surname>Yu</surname>
          <given-names>Ting</given-names>
        </name>
        <xref rid="af1" ref-type="aff">1</xref>
        <xref rid="FN1" ref-type="author-notes">4</xref>
      </contrib>
      <contrib contrib-type="author" equal-contrib="yes">
        <name>
          <surname>Zhao</surname>
          <given-names>Xiaoyu</given-names>
        </name>
        <xref rid="af1" ref-type="aff">1</xref>
        <xref rid="af2" ref-type="aff">2</xref>
        <xref rid="FN1" ref-type="author-notes">4</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Li</surname>
          <given-names>Guojun</given-names>
        </name>
        <xref rid="af1" ref-type="aff">1</xref>
        <xref rid="af3" ref-type="aff">3</xref>
      </contrib>
    </contrib-group>
    <aff id="af1"><label>1</label>Research Center for Mathematics and Interdisciplinary Sciences, Shandong University, Qingdao 266237, China;</aff>
    <aff id="af2"><label>2</label>School of Mathematics, Shandong University, Jinan, Shandong 250100, China;</aff>
    <aff id="af3"><label>3</label>School of Mathematical Science, Liaocheng University, Liaocheng 252000, China</aff>
    <author-notes>
      <fn id="FN1" fn-type="equal">
        <label>4</label>
        <p>These authors contributed equally to this work.</p>
      </fn>
      <corresp>
        <addr-line>Corresponding author:</addr-line>
        <email>guojunsdu@gmail.com</email>
      </corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>7</month>
      <year>2022</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <month>7</month>
      <year>2022</year>
    </pub-date>
    <volume>32</volume>
    <issue>7</issue>
    <fpage>1398</fpage>
    <lpage>1407</lpage>
    <history>
      <date date-type="received">
        <day>24</day>
        <month>11</month>
        <year>2021</year>
      </date>
      <date date-type="accepted">
        <day>3</day>
        <month>6</month>
        <year>2022</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>
        <ext-link xlink:href="http://genome.cshlp.org/site/misc/terms.xhtml" ext-link-type="uri">© 2022 Yu et al.; Published by Cold Spring Harbor Laboratory Press</ext-link>
      </copyright-statement>
      <copyright-year>2022</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbynclicense">https://creativecommons.org/licenses/by-nc/4.0/</ali:license_ref>
        <license-p>This article, published in <italic>Genome Research</italic>, is available under a Creative Commons License (Attribution-NonCommercial 4.0 International), as described at <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>.</license-p>
      </license>
    </permissions>
    <self-uri content-type="pdf" xlink:href="1398.pdf"/>
    <abstract>
      <p>Assembling RNA-seq reads into full-length transcripts is crucial in transcriptomic studies and poses computational challenges. Here we present TransMeta, a simple and robust algorithm that simultaneously assembles RNA-seq reads from multiple samples. TransMeta is designed based on the newly introduced vector-weighted splicing graph model, which enables accurate reconstruction of the consensus transcriptome via incorporating a cosine similarity–based combing strategy and a newly designed label-setting path-searching strategy. Tests on both simulated and real data sets show that TransMeta consistently outperforms PsiCLASS, StringTie2 plus its merge mode, and Scallop plus TACO, the most popular tools, in terms of precision and recall under a wide range of coverage thresholds at the meta-assembly level. Additionally, TransMeta consistently shows superior performance at the individual sample level.</p>
    </abstract>
    <funding-group>
      <award-group id="funding-1">
        <funding-source>National Key R&amp;D Program of China</funding-source>
        <award-id>2020YFA0712400</award-id>
      </award-group>
      <award-group id="funding-2">
        <funding-source>
          <institution-wrap>
            <institution>National Natural Science Foundation of China </institution>
            <institution-id institution-id-type="doi">10.13039/501100001809</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>11931008</award-id>
        <award-id>12101368</award-id>
        <award-id>61771009</award-id>
      </award-group>
      <award-group id="funding-3">
        <funding-source>
          <institution-wrap>
            <institution>China Postdoctoral Science Foundation </institution>
            <institution-id institution-id-type="doi">10.13039/501100002858</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>2021M701998</award-id>
      </award-group>
      <award-group id="funding-4">
        <funding-source>
          <institution-wrap>
            <institution>Natural Science Foundation of Shandong Province </institution>
            <institution-id institution-id-type="doi">10.13039/501100007129</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>ZR2021QA013</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="10"/>
    </counts>
  </article-meta>
</front>
<body>
  <p>RNA-seq is a powerful technology for transcriptome analysis. During the past five years, this technology has transitioned from research to clinical use (<xref rid="GR276434YUC24" ref-type="bibr">Phillips et al. 2020</xref>), which provides an opportunity to view the complexity of eukaryotic transcriptomes and identify the expressed transcripts and quantify their abundance precisely at a whole-transcriptome level (<xref rid="GR276434YUC33" ref-type="bibr">Wang et al. 2009</xref>; <xref rid="GR276434YUC34" ref-type="bibr">Wilhelm and Landry 2009</xref>; <xref rid="GR276434YUC18" ref-type="bibr">Marguerat and Bähler 2010</xref>; <xref rid="GR276434YUC21" ref-type="bibr">Ozsolak and Milos 2011</xref>). Assembling RNA-seq reads into full-length transcripts has become a crucial step and a challenging task.</p>
  <p>For a single RNA-seq sample, there exist two main approaches to reconstruct transcripts: genome-guided and de novo. Genome-guided approaches take advantage of an existing genome to which the RNA-seq reads are first aligned by using mapping tools including HISAT (<xref rid="GR276434YUC8" ref-type="bibr">Kim et al. 2015</xref>), HISAT2 (<xref rid="GR276434YUC9" ref-type="bibr">Kim et al. 2019</xref>), STAR (<xref rid="GR276434YUC4" ref-type="bibr">Dobin et al. 2013</xref>), TopHat (<xref rid="GR276434YUC31" ref-type="bibr">Trapnell et al. 2009</xref>), or TopHat2 (<xref rid="GR276434YUC7" ref-type="bibr">Kim et al. 2013</xref>). Based on alignments, genome-guided assemblers such as StringTie2 (<xref rid="GR276434YUC10" ref-type="bibr">Kovaka et al. 2019</xref>), Scallop (<xref rid="GR276434YUC25" ref-type="bibr">Shao and Kingsford 2017</xref>), TransComb (<xref rid="GR276434YUC15" ref-type="bibr">Liu et al. 2016b</xref>), iPAC (<xref rid="GR276434YUC36" ref-type="bibr">Yu et al. 2020</xref>), StringTie (<xref rid="GR276434YUC23" ref-type="bibr">Pertea et al. 2015</xref>), Cufflinks (<xref rid="GR276434YUC32" ref-type="bibr">Trapnell et al. 2010</xref>), Class2 (<xref rid="GR276434YUC27" ref-type="bibr">Song et al. 2016</xref>), Scripture (<xref rid="GR276434YUC6" ref-type="bibr">Guttman et al. 2010</xref>), IsoInfer (<xref rid="GR276434YUC5" ref-type="bibr">Feng et al. 2011</xref>), IsoLasso (<xref rid="GR276434YUC13" ref-type="bibr">Li et al. 2011</xref>), iReckon (<xref rid="GR276434YUC19" ref-type="bibr">Mezlini et al. 2013</xref>), CEM (<xref rid="GR276434YUC12" ref-type="bibr">Li and Jiang 2012</xref>), Traph (<xref rid="GR276434YUC30" ref-type="bibr">Tomescu et al. 2013</xref>), and MITIE (<xref rid="GR276434YUC1" ref-type="bibr">Behr et al. 2013</xref>) can be used to reconstruct transcripts. Generally, these assemblers recover the transcripts by constructing a graph model (splicing graph) based on the read alignments and followed by an individual-designed path-searching algorithm. When the genome is unknown or partially known, de novo assemblers such as TransLiG (<xref rid="GR276434YUC16" ref-type="bibr">Liu et al. 2019</xref>), BinPacker (<xref rid="GR276434YUC14" ref-type="bibr">Liu et al. 2016a</xref>), Bridger (<xref rid="GR276434YUC3" ref-type="bibr">Chang et al. 2015</xref>), Trinity (<xref rid="GR276434YUC17" ref-type="bibr">MacManes and Eisen 2013</xref>), ABySS (<xref rid="GR276434YUC26" ref-type="bibr">Simpson et al. 2009</xref>), SOAPdenovo-Trans (<xref rid="GR276434YUC35" ref-type="bibr">Xie et al. 2014</xref>), and IDBA-tran (<xref rid="GR276434YUC22" ref-type="bibr">Peng et al. 2013</xref>) have been available for reconstruction of full-length transcripts directly from RNA-seq reads. Generally speaking, genome-guided methods are more commonly used because they are usually more accurate (<xref rid="GR276434YUC25" ref-type="bibr">Shao and Kingsford 2017</xref>).</p>
  <p>Transcriptomic studies involve multiple samples. Constructing a consensus transcriptome from multiple samples is critical in an RNA-seq experiment for the subsequent quantification and differential expression and splicing analyses (<xref rid="GR276434YUC20" ref-type="bibr">Niknafs et al. 2017</xref>; <xref rid="GR276434YUC28" ref-type="bibr">Song et al. 2019</xref>). Thus, many meta-assembly computational methods have been developed, which can be summarized by two paradigms. The first one uses existing single-sample assemblers to reconstruct transcripts for each individual sample and then merges the transcripts of each sample by merging tools such as StringTie-Merge (<xref rid="GR276434YUC23" ref-type="bibr">Pertea et al. 2015</xref>) or TACO (<xref rid="GR276434YUC20" ref-type="bibr">Niknafs et al. 2017</xref>); however, the precision of this paradigm is usually low (<xref rid="GR276434YUC28" ref-type="bibr">Song et al. 2019</xref>). The second paradigm, such as the state-of-the-art meta-assembly tool PsiCLASS (<xref rid="GR276434YUC28" ref-type="bibr">Song et al. 2019</xref>), simultaneously analyzes multiple RNA-seq samples and outputs a set of meta-annotations, as well as a set of transcripts for each sample. PsiCLASS uses statistical methods to build the global subexon graphs and generates the assembly by dynamic programming optimization and voting algorithms. Although it achieves higher precision, its recall is relatively low (<xref rid="GR276434YUC28" ref-type="bibr">Song et al. 2019</xref>).</p>
  <p>Here, we present TransMeta, a multisample transcriptome assembly algorithm that enables simultaneous and accurate assembly of RNA-seq reads from multiple samples. TransMeta can generate the consensus meta-assembly for multiple samples, as well as a certain set of transcripts for each individual sample.</p>
  <sec sec-type="results" id="s1">
    <title>Results</title>
    <sec id="s1a">
      <title>Overview of the TransMeta model</title>
      <p>TransMeta first builds the traditional splicing graphs for each sample in parallel and then constructs a vector-weighted splicing graph (VWSG) with the edges and nodes being both weighted by vectors rather than scalar numbers by integrating the individual splicing graphs. After that, TransMeta reconstructs the initial consensus meta-assembly by using a cosine similarity-based combing strategy and a label-setting path-searching strategy, and produces a set of transcripts for each sample based on both the VWSGs and the initial meta-assembly followed by an estimation of their expression levels. Finally, TransMeta generates the mature meta-assembly by an extra filtering procedure (<xref rid="GR276434YUF1" ref-type="fig">Fig. 1</xref>A–E).</p>
      <fig position="float" id="GR276434YUF1">
        <label>Figure 1.</label>
        <caption>
          <p>Flowchart of TransMeta. (<italic>A</italic>) Building individual splicing graphs for each sample in parallel. The nodes (exons) are named with lowercase letters; the values on each edge are the weights of the edge. (<italic>B</italic>) Merging individual splicing graphs into the vector-weighted splicing graph (VWSG). The nodes and edges in the VWSG are all the nodes and edges appearing in all the samples. Each edge in the VWSG is weighted by a vector, with the <italic>k</italic>th component of the vector being the corresponding weight of the edge in the splicing graph of sample <italic>k</italic>. (<italic>C</italic>) Using the cosine similarity-based combing strategy and the label-setting technique to generate the initial meta-assembly. (<italic>D</italic>) Extracting assembly for each sample from the VWSG. (<italic>E</italic>) Producing the mature meta-assembly.</p>
        </caption>
        <graphic xlink:href="1398f01" position="float"/>
      </fig>
    </sec>
    <sec id="s1b">
      <title>Benchmarking TransMeta</title>
      <p>We evaluated the performance of TransMeta at both the meta-assembly level and the individual sample level by comparing it with the state-of-the-art multisample assembler PsiCLASS, which can produce a meta-assembly for multiple samples and a certain set of transcripts for each individual sample as well. Additionally, we compared TransMeta with two of the current best single-sample assemblers, StringTie2 and Scallop, at the individual sample level and with the combinations of StringTie2 with StringTie2-merge and Scallop with TACO at the meta-assembly level. As did <xref rid="GR276434YUC28" ref-type="bibr">Song et al. (2019)</xref> for their evaluation of PsiCLASS, we benchmarked the TransMeta under two widely used aligners, HISAT2 and STAR, in terms of the standard criteria that have been widely used in evaluation of transcriptome assemblers. To this end, we rephrase that an assembled transcript is defined as correctly assembled if and only if its intron chain is exactly matched with a reference transcript in the ground truth. This reference transcript is considered to be accurately recovered. Then, the accuracy of an assembler was measured by recall (the fraction of accurately recovered reference transcripts in the ground truth) and precision (the percentage of correctly assembled transcripts out of all the output transcripts). These metrics were calculated by using Cuffcompare (v.2.2.1). The reference genome used in this research was GRCh38. The running commands and versions of all these tools are described in the <ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Notes</ext-link>.</p>
    </sec>
    <sec id="s1c">
      <title>Evaluation on the simulated data set</title>
      <p>We used the RNA-seq read simulator RSEM (<xref rid="GR276434YUC11" ref-type="bibr">Li and Dewey 2011</xref>) to generate three simulated data sets, which are S1 (20 samples, 100-bp length, 35–36 million paired-end reads), S2 (25 samples, 76-bp length, 41–54 million paired-end reads), and S3 (15 samples, 76-bp length, 69–81 million paired-end reads). The parameters (e.g., abundances, fragment and read length distributions, and sequencing error model parameters) of the RSEM were taken from real RNA-seq samples. The detailed parameters and running commands for generating the simulated data sets are described in the <ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Notes</ext-link>. We then used the mapping tools HISAT2 and STAR to generate the alignments for each sample and ran the assemblers, followed by evaluating their performance at both the meta-assembly level and individual sample level.</p>
      <sec id="s1c1">
        <title>Evaluation at the meta-assembly level</title>
        <p>Typically, assemblers filter out their assembled transcripts with lower estimated expression levels via introducing a tradeoff parameter to balance the precision and recall. With increased filtering parameter, the precision might generally increase, whereas the recall decreases. Hence, to evaluate the assemblers’ capability to balance precision and recall, we drew a precision-recall curve for each assembler based on a wide range of its filtering thresholds (for details of the parameter settings for each assembler, see the <ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Notes</ext-link>). On the three simulated data sets under the HISAT2 and STAR alignments, we ran TransMeta and PsiCLASS with different filtering thresholds to get the sets of meta-assemblies, then ran StringTie2 and Scallop with their default settings for each individual sample, and finally merged them by using StringTie2-Merge and TACO, respectively, with different filtering thresholds. Given the precision-recall curves generated for all compared assemblers over a wide range of filtering thresholds, we found that TransMeta consistently had its precision-recall curves much higher than those of the compared assemblers on the three simulated data sets under both aligners HISAT2 and STAR. Specifically, on the simulated data set S1 under the HISAT2 alignments, when we adjusted the coverage thresholds of all the assemblers to set their assemblies all to the precision of 0.7 (or any other value), the recall of TransMeta reached about 0.38, which is ∼20% higher than that of PsiCLASS, ∼41% higher than StringTie2 system, and ∼90% higher than Scallop + TACO (<xref rid="GR276434YUF2" ref-type="fig">Fig. 2</xref>A). Evaluated based on the areas under the precision-recall curve (AUC) scores, we found that the AUC score of TransMeta was ∼13.7% higher than that of PsiCLASS, 22.3% higher than that of StringTie2 system, and 49.8% higher than that of Scallop + TACO. Under the STAR alignments, all the assemblers performed similarly well as they did under the HISAT2 alignments. The performance comparisons are summarized in <ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Figure S1A</ext-link>. Further tests on the simulated data sets S2 and S3 under aligners HISAT2 and STAR showed that TransMeta consistently performed better as it did on data set S1 (<ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Fig. S2A,B,E,F</ext-link>).</p>
        <fig position="float" id="GR276434YUF2">
          <label>Figure 2.</label>
          <caption>
            <p>Performance evaluations on the simulated data set S1 under the HISAT2 alignments. (<italic>A</italic>) Precision-recall curves of the assemblers. The points on the curve of an assembler correspond to the filtering thresholds of the assembler; the circled one, to the default value. (<italic>B</italic>) Distributions of numbers of correctly recovered transcripts against the tools that were separately counted according to whether their expression is low, medium, or high at the meta-assembly level. (<italic>C</italic>) The precision and recall of the assemblers on different samples at the individual sample level under their default settings. Different colors correspond to different assemblers, and each point corresponds to a specific sample. (<italic>D</italic>) Distributions of averaged numbers of correctly recovered transcripts against the tools that were separately counted according to whether their expression is low, medium, or high at the individual sample level. The error bars show the standard deviation across the samples.</p>
          </caption>
          <graphic xlink:href="1398f02" position="float"/>
        </fig>
        <p>In general, it is more challenging to reconstruct transcripts with relatively low expression than those with higher expression (<xref rid="GR276434YUC2" ref-type="bibr">Canzar et al. 2016</xref>; <xref rid="GR276434YUC25" ref-type="bibr">Shao and Kingsford 2017</xref>). Therefore, we further evaluated TransMeta's performance in reconstructing transcripts of different expression levels. We divided the expressed transcripts into three parts equally according to whether their expression levels were low, medium, or high (for the detailed description of the expression levels, see the <ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Notes</ext-link>). On data set S1, the comparison results showed that TransMeta correctly recovered much more medium-expressed transcripts than the others, whereas its ability to correctly reconstruct low- and high-expressed transcripts is comparable to the best performers (<xref rid="GR276434YUF2" ref-type="fig">Fig. 2</xref>B). In addition, the comparison results under the STAR alignments revealed that TransMeta consistently outperformed all the others in recovering transcripts of different expression levels. We further evaluated the assemblers on data sets S2 and S3 under both the HISAT2 and STAR alignments. As we expected, TransMeta demonstrated superior performance, similarly as it did on data set S1 (<ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Figs. S1B, S3A,B,E,F</ext-link>).</p>
      </sec>
      <sec id="s1c2">
        <title>Evaluation at the individual sample level</title>
        <p>TransMeta and PsiCLASS are the so-called meta-assemblers, but they may also produce a certain set of transcripts for each sample. Thus, we compared their performance with the single-sample assemblers StringTie2 and Scallop using their default settings at the individual sample level. On all the 60 samples from the three simulated data sets under both HISAT2 and STAR alignments, TransMeta consistently showed superior performance. Specifically, averaged on the 20 samples of data set S1 under the HISAT2 alignments, the recall of TransMeta reached about 0.38, which was ∼5.6% higher than that of PsiCLASS and &gt;11.4% higher than those of StringTie2 and Scallop. Meanwhile, TransMeta had the highest precision (<xref rid="GR276434YUF2" ref-type="fig">Fig. 2</xref>C). And, under the STAR alignments, a similar trend was observed (<ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Fig. S1C</ext-link>). We further tested them on the simulated data sets S2 and S3 under both the HISAT2 and STAR alignments and observed that TransMeta performed better as it did on data set S1 (<ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Fig. S2C,D,G,H</ext-link>). We also tested them on all three simulated data sets S1, S2, and S3 under both aligners HISAT2 and STAR in correctly identifying transcripts of different expression levels as we did in the last section. We observed again that TransMeta consistently performed better. It can be seen from <xref rid="GR276434YUF2" ref-type="fig">Figure 2</xref>D (resp. <ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Fig. S1D</ext-link>) that TransMeta consistently performed the best for all the expression levels on the simulated data set S1 under the aligner HISAT2 (resp. STAR) and from <ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Figure S3, C, D, G, and H</ext-link> that TransMeta retained superiority on both S2 and S3 under both aligners HISAT2 and STAR.</p>
      </sec>
      <sec id="s1c3">
        <title>Additional evaluation on the simulated data set S1</title>
        <p>According to the above tests, TransMeta showed good and robust performance on all the simulated data sets S1–S3. The assemblers possessed highly similar performance trends across the three simulated data sets. Thus, the following additional tests were made based on data set S1. First, as is known, for the simulated data set, the ground truth was known with certainty. Therefore, we further ran HISAT2 via using the options <italic>‐‐ss</italic> and <italic>‐‐exon</italic>, which, respectively, provided the splice sites and exons in the ground truth to HISAT2 during building the index, toward producing more accurate alignments. Subsequently, based on the newly generated alignments, we ran all the assemblers and evaluated their performance and found that TransMeta maintained the best performance (<ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Fig. S4</ext-link>). Second, in the TransMeta package, we provided an option <italic>-g</italic> for the annotation-guided assembly, where <italic>-g</italic> provided a set of reference transcripts to guide the assembly procedure. Under the annotation-guided mode, we compared TransMeta with StringTie2 (other tools did not have such an option) under the HISAT2 alignments, and the results showed that TransMeta significantly outperformed StringTie2 (<ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Fig. S5A</ext-link>). Third, at the individual sample level under the HISAT2 alignments, we additionally drew the precision-recall curves based on the filtering threshold for all the assemblers, and TransMeta also achieved the highest precision-recall curve (<ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Fig. S5B</ext-link>). Fourth, we further compared all the assemblers with <italic>gtfmerge</italic>, a simple tool that took the union of the assembled transcripts from each individual sample. Because <italic>gtfmerge</italic> simply took the union, the number of transcripts generated by it was quite large. As a result, its precision was quite low, although its recall was relatively higher. Therefore, we computed the <italic>F</italic>-score, a harmonic mean of recall and precision (calculated as 2 × precision × recall / (precision + recall)) to evaluate the overall performance of each assembler. Based on the results, TransMeta performed the best (<ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Table S1</ext-link>).</p>
      </sec>
    </sec>
    <sec id="s1d">
      <title>Evaluation on the real data sets</title>
      <p>We can explicitly know the ground truth for the simulated data, but simulated data sets that are generated by using mathematical models cannot capture the entire features of real biological data. For this reason, the performance evaluation based on real RNA-seq data sets is of great necessity. Although the ground truth of the real data sets cannot be known precisely, it is generally safe to assume that an assembler is more accurate if it recovers more known annotated transcripts. In this research, all the reference transcripts from the NCBI-RefSeq annotations were primarily set as the ground truth, as in previous studies (<xref rid="GR276434YUC10" ref-type="bibr">Kovaka et al. 2019</xref>), to benchmark TransMeta. However, as we know, there are different versions of reference annotation libraries; thus, we additionally set the GENCODE annotations as the ground truth to make the analysis.</p>
      <p>In this research, five human RNA-seq data sets were used for evaluating the performance of the assemblers, which are R1, the liver cells data set with 73 samples; R2, the fetal retinal pigment epithelium cells data set with 48 samples; R3, the urinary bladder epithelial cells data set with 35 samples; R4, the NHDF primary human fibroblasts cells data set with 21 samples; and R5, OCT embedded kidney tumor tissue cells data set with 12 samples. The accession number of each data set can be found in the <ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Notes</ext-link>. It is worth mentioning that data set R1 was previously used by <xref rid="GR276434YUC28" ref-type="bibr">Song et al. (2019)</xref> in their evaluation of PsiCLASS. We aligned all the RNA-seq data to the reference genome using HISAT2 and STAR and ran the assemblers. Then we assessed the performance of TransMeta at both the meta-assembly level and the individual sample level.</p>
      <sec id="s1d1">
        <title>Evaluation at the meta-assembly level</title>
        <p>We ran the assemblers with different filtering thresholds as we did for the simulated data sets. On the whole, TransMeta maintained its superiority over other tools. Specifically, we can see from <xref rid="GR276434YUF3" ref-type="fig">Figure 3</xref>A, which shows the comparison results under the HISAT2 alignments, that TransMeta has improved precision-recall compared to other tools across all the five data sets at the meta-assembly level. As an illustration, we considered precision 0.5 (or any other value), which means that we adjusted the filtering parameters of each assembler to make their precision reach about 0.5. Then on the five tested data sets R1–R5 under the HISAT2 alignments, the recalls of TransMeta reached about 0.11, 0.15, 0.16, 0.14, and 0.17, respectively; those of the second-best assembler PsiCLASS were about 0.07, 0.11, 0.12, 0.11, and 0.14, respectively; those of StringTie2 were about 0.05, 0.09, 0.11, 0.09, and 0.12, respectively; and those of Scallop + TACO were relatively worse. It means that under the same precision level, TransMeta correctly identified ∼21%–57% more transcripts than PsiCLASS and 42%–120% more than the StringTie2 system. The precision of Scallop + TACO cannot reach 0.5 no matter how we adjusted their filtering parameters (<xref rid="GR276434YUF3" ref-type="fig">Fig. 3</xref>A). Furthermore, in terms of the AUC, TransMeta showed an improvement of ∼17%–35% over PsiCLASS, as well as 19%–62% over the StringTie2 system on the five data sets, whereas Scallop + TACO showed relatively poor performance. After repeating the evaluation by using the aligner STAR instead of HISAT2, we observed results comparable to those obtained by using the aligner HISAT2 (<ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Fig. S6A</ext-link>).</p>
        <fig position="float" id="GR276434YUF3">
          <label>Figure 3.</label>
          <caption>
            <p>Performance evaluations on the five real data sets R1–R5 under the HISAT2 alignments. (<italic>A</italic>) Precision-recall curves of the assemblers. The points on each curve correspond to the filtering thresholds of each assembler; the circled one, to the default value. (<italic>B</italic>) The precisions and recalls of the assemblers on different samples at the individual sample level under their default settings. Different colors correspond to different assemblers, and each point corresponds to a specific sample.</p>
          </caption>
          <graphic xlink:href="1398f03" position="float"/>
        </fig>
      </sec>
      <sec id="s1d2">
        <title>Evaluation at the individual sample level</title>
        <p>As in the simulated data set, we investigated the performance of the assemblers at the individual sample level. Again, TransMeta achieved the best performance under its default settings. Specifically, on 187 out of the 189 individual samples from the five different RNA-seq experiments, both the recall and precision of TransMeta consistently were the highest. For instance, averaged on the 73 samples from R1, TransMeta correctly reconstructed ∼19.6% more transcripts than PsiCLASS, as well as 62.1% and 75.2% more than the single-sample assemblers StringTie2 and Scallop, respectively. Meanwhile, its precision was the highest on all 73 samples, which were on average ∼15% higher than those of PsiCLASS and over twofold higher than those of StringTie2 and Scallop (<xref rid="GR276434YUF3" ref-type="fig">Fig. 3</xref>B). Again, we obtained comparable test results by replacing HISAT2 with STAR (<ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Fig. S6B</ext-link>).</p>
      </sec>
      <sec id="s1d3">
        <title>Additional evaluation on the real data sets R1–R5</title>
        <p>According to the above tests and analyses, TransMeta showed satisfactory performance. However, we additionally performed the following test. First, as mentioned above, there are different versions of reference annotation libraries. Therefore, we further set the GENCODE annotations as the ground truth for performance evaluation under both the HISAT2 and STAR alignments, and as expected, TransMeta outperformed the alternatives (<ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Fig. S7</ext-link>). Second, we further drew the precision-recall curves at the individual sample level, where TransMeta achieved the highest curves on all the tested samples (<ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Fig. S8</ext-link>). Third, for the real data sets, setting all the annotations as the ground truth can possibly cause biases in the accuracy evaluation because, for a certain sample, some annotated transcripts may not be expressed. Therefore, we further used the well-known RNA-seq quantification tool kallisto to quantify each sample in the five real data sets R1–R5 (the running command of kallisto is detailed in the <ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Notes</ext-link>), and we selected the expressed transcripts (the ones with estimated TPM &gt; 0) as the ground truth for each sample, and the union of each sample's expressed transcripts as the ground truth for the meta-assembly. Then we evaluated the performance of the assemblers under such ground truth in terms of precision and the number of correctly recovered transcripts. As expected, TransMeta performed the best (<ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Figs. S9, S10</ext-link>). Fourth, as in the simulated data set, we evaluated the annotation-guided mode for TransMeta and StringTie2 (<ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Fig. S11</ext-link>). Fifth, we also compared all the assemblers with the <italic>gtfmerge</italic> tool (<ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Tables S2–S6</ext-link>).</p>
      </sec>
      <sec id="s1d4">
        <title>Evaluation on small-scale data sets</title>
        <p>We next investigated TransMeta's multisample strategy on small data sets, which are R6, the CD20<sup>+</sup> cell data set with six samples, and R7, the MCF-7 breast cancer cells data set with three samples. R6 was obtained from NCBI Sequence Read Archive (SRA; <uri xlink:href="https://www.ncbi.nlm.nih.gov/sra">https://www.ncbi.nlm.nih.gov/sra</uri>), and R7 was obtained from the ENCODE project. The accession number of both data sets can be found in <ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Notes</ext-link>. We then evaluated the performance at both meta-assembly and individual sample levels under the HISAT2 alignments. The comparison results showed that, at the meta-assembly level on both small-scale data sets, TransMeta achieved the highest precision-recall (<xref rid="GR276434YUF4" ref-type="fig">Fig. 4</xref>A). At the individual sample level, TransMeta maintained the best performance as well (<xref rid="GR276434YUF4" ref-type="fig">Fig. 4</xref>B).</p>
        <fig position="float" id="GR276434YUF4">
          <label>Figure 4.</label>
          <caption>
            <p>Performance evaluations on the two small-scale data sets R6 and R7 under the HISAT2 alignments. (<italic>A</italic>) Precision-recall curves of the assemblers. The points on each curve correspond to the filtering thresholds of each assembler; the circled one, to the default value. (<italic>B</italic>) The precisions and recalls of the assemblers on different samples at the individual sample level under their default settings. Different colors correspond to different assemblers, and each point corresponds to a specific sample.</p>
          </caption>
          <graphic xlink:href="1398f04" position="float"/>
        </fig>
      </sec>
      <sec id="s1d5">
        <title>Evaluation on large-scale data sets for the meta-assemblers TransMeta and PsiCLASS</title>
        <p>TransMeta and PsiCLASS are the so-called meta-assemblers that simultaneously analyze multiple samples. To evaluate their performance in producing meta-assemblies on large-scale data sets, we randomly selected 100, 200, 300, 400, and 500 subsets from the poly(A)-selected lymphoblastoid samples from the GEUVADIS population variation project and mapped them to the reference genome using HISAT2. Based on the alignments, we ran TransMeta and PsiCLASS with different filtering thresholds. As <xref rid="GR276434YUF5" ref-type="fig">Figure 5</xref>, A through E, shows, TransMeta consistently achieved higher precision-recall on the five subsets with different numbers of samples.</p>
        <fig position="float" id="GR276434YUF5">
          <label>Figure 5.</label>
          <caption>
            <p>Comparisons of TransMeta and PsiCLASS on the large-scale data sets under the HISAT2 alignments at the meta-assembly level. (<italic>A</italic>–<italic>E</italic>) Precision-recall curves of TransMeta and PsiCLASS on 100, 200, 300, 400, and 500 subsets of GEUVADIS samples. The points on each curve correspond to the filtering thresholds of each assembler; the circled one, to the default value.</p>
          </caption>
          <graphic xlink:href="1398f05" position="float"/>
        </fig>
      </sec>
      <sec id="s1d6">
        <title>Comparison of running time and memory usage</title>
        <p>To evaluate the computational efficiency of the assemblers, we compared the CPU time and memory usage of all the assemblers on the five real data sets R1–R5 based on both the HISAT2 and STAR alignments. The meta-assemblers TransMeta and PsiCLASS were run with 25 threads, and the single-sample assemblers StringTie2 and Scallop were run sequentially to assemble individual samples. The comparisons are detailed in <ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Table S7</ext-link>. For instance, on data set R1 with 73 samples under the HISAT2 alignments, TransMeta took ∼133 min with a peak memory of 11 GB, whereas PsiCLASS took ∼228 min with a peak memory of 11.7 GB, StringTie2 took 188 min with &lt;1 GB memory, and Scallop took 251 min with a peak memory of ∼4.9 GB. These statistics implied that TransMeta might not be the most efficient, but it could be quite acceptable for practical use.</p>
      </sec>
    </sec>
  </sec>
  <sec sec-type="discussion" id="s2">
    <title>Discussion</title>
    <p>This research introduced a new method, TransMeta, that can simultaneously assemble RNA-seq reads of multiple samples. It can output a consensus assembly for an RNA-seq experiment with multiple samples, as well as a certain set of transcripts for each individual sample. It consistently performs the best on both real and simulated data sets at both the meta-assembly and individual sample levels.</p>
    <p>It is critical for an RNA-seq experiment to determine the set of expressed genes and transcripts for the subsequent quantification and differential expression and splicing analyses. However, transcriptome reconstruction for the single sample has limited utility for downstream analyses of transcriptional dynamics across many samples (<xref rid="GR276434YUC20" ref-type="bibr">Niknafs et al. 2017</xref>). Following the declaration by <xref rid="GR276434YUC28" ref-type="bibr">Song et al. (2019)</xref>, we developed the TransMeta to construct the consensus transcriptome from multiple input RNA-seq data sets. At the meta-assembly level, the assemblers are capable of recovering more correct transcripts than those at the single-sample level. As stated in a previous study (<xref rid="GR276434YUC29" ref-type="bibr">Tasnim et al. 2015</xref>), such superiority could be attributed to the fact that with more alignments of RNA-seq reads from multiple samples being taken into account, more splicing patterns can be detected; as a result, more transcripts can be discovered (thus improving the recall). However, at the same time, the detectable splicing patterns become more complicated, which increases the difficulty of recovering full-length transcripts. To tackle this problem, we built the VWSG model, upon which we designed the cosine similarity–based combing strategy and a label-setting path-searching strategy, making TransMeta a robust meta-assembler.</p>
    <p>In the VWSG, the edges and nodes are weighted by vectors rather than scalar numbers with the element in <italic>k</italic>th position of the vectors being the corresponding weight in the sample <italic>k.</italic> Based on the VWSG, TransMeta generalizes the transcriptome assembly from one dimension (single-sample level) to higher dimensions (multiple-sample level). We treat the vector weights of the edges (or nodes) in VWSG as points in <italic>S</italic>-dimensional space (where <italic>S</italic> is the number of samples). Thus, when <italic>S</italic> is equal to one, that is the case for the single sample. Therefore, the VWSG inspired us to generalize the core ideas of the traditional single-sample-based assembler into the multiple-sample-based approaches. Inspired by the TransComb (<xref rid="GR276434YUC15" ref-type="bibr">Liu et al. 2016b</xref>) paper, we thus introduced a constrained program to hunt for the potential right connections between the incoming and outgoing junctions of an exon (i.e., “combing strategy” mentioned in TransComb), which took both the vector weights (i.e., the sequence depth information of each sample) and the paired-end information into account, and considered the cosine similarity between the vector weights of the junctions to design the constraints and the object function. Then, based on the generalized combing strategy of the junctions, a dynamic label-setting path-searching strategy was modified toward accurately recovering the full-length transcripts.</p>
    <p>Although we have shown the significant advantages of TransMeta, there remains room for improvement in the future. For instance, the current version of TransMeta is not compatible with long-read RNA-seq data sets (e.g., PacBio or Nanopore). We plan to integrate long reads into TransMeta in our future research.</p>
    <p>The software was developed to be user-friendly and is expected to play a crucial role in new discoveries of transcriptome studies in RNA-seq experiments with multiple samples, especially in complicated human diseases related to abnormal splicing events and expression levels, such as cancer, and most genetic diseases.</p>
  </sec>
  <sec sec-type="methods" id="s3">
    <title>Methods</title>
    <p>To comprehensively use the information from different RNA-seq samples, TransMeta builds a novel graph model, namely, the VWSG, in which each edge (node) is weighted by a vector rather than a scalar number. The VWSG integrates the sequence depth information of multiple samples and plays a critical role in the assembly procedure. Depending on the VWSG, TransMeta extracts reliable consensus paired paths and uses a cosine similarity–based combing strategy and a label-setting path-searching strategy to reconstruct the transcripts (for the flowchart of the TransMeta algorithm, see <xref rid="GR276434YUF1" ref-type="fig">Fig. 1</xref>A–E).</p>
    <sec id="s3a">
      <title>Building the VWSG</title>
      <p>The VWSG is a consensus graph that reflects the sequence depth information of all the RNA-seq samples. To generate the VWSG, we first build the traditional splicing graphs for the individual samples and then integrate them into the so-called VWSG.</p>
      <sec id="s3a1">
        <title>Building the traditional splicing graphs for each sample in parallel</title>
        <p>For each RNA-seq sample, given the alignments of the RNA-seq reads to a reference genome, we first cluster all the aligned reads into different gene loci according to the overlap of the aligned coordinates of reads. For each gene locus, an exon (a region that is continuously covered by aligned reads) is denoted as <italic>e</italic> = [<italic>e<sub>l</sub>, e</italic><sub><italic>r</italic></sub>], where <italic>e</italic><sub><italic>l</italic></sub> and <italic>e</italic><sub><italic>r</italic></sub> are the starting and ending sites of the exon in the genome, and each splice junction is denoted as <italic>j = j<sub>l</sub></italic> → <italic>j</italic><sub><italic>r</italic></sub>, where <italic>j</italic><sub><italic>l</italic></sub> and <italic>j</italic><sub><italic>r</italic></sub> are the two coordinates of the splice junction; consequently, a traditional splicing graph that corresponds to the gene locus could be built.</p>
        <p>Then, the sequence depth information will be projected onto the exons (nodes) and splice junctions (edges) of the splicing graph as their weights. Specifically, the weight of each exon is defined as the average coverage of the aligned reads to this exon, and the weight of every single splice junction is defined as the number of spliced reads that span it. Note that if a read is aligned to multiple sites, suppose <italic>N</italic>, the contribution of this read is recorded as 1<italic>/N</italic>.</p>
        <p>Furthermore, taking the paired-end sequence information into account, we generate a set of paired paths on each splicing graph, denoted as <italic>P</italic>. Specifically, for each pair of the mated reads <italic>r</italic><sub>1</sub> and <italic>r</italic><sub>2</sub>, suppose that <italic>r</italic><sub>1</sub> spans a path s<italic>p</italic><sub>1</sub> = <italic>n</italic><sub><italic>i</italic></sub><sub>1</sub> → <italic>n</italic><sub><italic>i</italic></sub><sub>2</sub> → … → <italic>n</italic><sub><italic>ip</italic></sub>, and <italic>r</italic><sub>2</sub> spans <italic>sp</italic><sub>2</sub> = <italic>n</italic><sub><italic>j</italic></sub><sub>1</sub> → <italic>n</italic><sub><italic>j</italic></sub><sub>2</sub> → … → <italic>n</italic><sub><italic>jq</italic></sub> in the splicing graph, and <italic>sp</italic><sub>1</sub> and <italic>sp</italic><sub>2</sub> share a same subpath <italic>sp<sub>overlap</sub></italic> = <italic>n</italic><sub><italic>m</italic>1</sub> → <italic>n</italic><sub><italic>m</italic>2</sub> → … → <italic>n</italic><sub><italic>mk</italic></sub>, satisfying <italic>p</italic> + <italic>q−k</italic> ≥ 3, where <italic>sp</italic><sub><italic>overlap</italic></sub> is the prefix subpath of one and suffix subpath of the other, then the mated reads <italic>r</italic><sub>1</sub> and <italic>r</italic><sub>2</sub> determine the paired path <italic>sp</italic> by connecting <italic>sp</italic><sub>1</sub> and <italic>sp</italic><sub>2</sub> via the overlapped subpath <italic>sp</italic><sub><italic>overlap</italic></sub>, which is added to <italic>P.</italic> For the case of single-end reads, if a read spans subpath <italic>sp = n</italic><sub><italic>i</italic></sub><sub>1</sub> → <italic>n</italic><sub><italic>i</italic></sub><sub>2</sub> → … → <italic>n</italic><sub><italic>ip</italic></sub> in the splicing graph and <italic>P</italic> ≥ 3, then we add <italic>sp</italic> to <italic>P</italic>. Noting that different paired-end (or single-end) reads may produce the same paired path, for each paired path <italic>p</italic> in <italic>P</italic>, we set the number of paired-end (or single-end) reads that generate it as its coverage, denoted by <italic>cov(p)</italic>.</p>
      </sec>
      <sec id="s3a2">
        <title>Integrating traditional splicing graphs of individual samples into VWSG</title>
        <p>To make full use of the sequence depth and paired-end sequence information from all the samples of an RNA-seq experiment, we then build the VWSG for each gene locus by integrating the traditional splicing graphs from all samples together. For each gene locus, we denote <italic>G<sub>k</sub> = (E<sub>k</sub>, J<sub>k</sub>)</italic> (<italic>k</italic> ∈ [1, <italic>S</italic>]) as the splicing graph in sample <italic>k</italic> (suppose there are <italic>S</italic> samples in an RNA-seq experiment), where <italic>E</italic><sub><italic>k</italic></sub> is the set of exons (nodes), <italic>J</italic><sub><italic>k</italic></sub> is the set of splice junctions(edges), and, for each exon <italic>e</italic> in <italic>E</italic><sub><italic>k</italic></sub> and <italic>j</italic> in <italic>J</italic><sub><italic>k</italic></sub>, we denote <italic>cov(e)</italic> and <italic>cov(j)</italic> as the weight of the exon and the splice junction, respectively.</p>
        <p>We first generate an unweighted consensus graph, <italic>G<sub>U</sub> =</italic>(<italic>E<sub>U</sub>, J</italic><sub>U</sub>) in which the nodes in <italic>E</italic><sub><italic>U</italic></sub> and edges in <italic>J</italic><sub><italic>U</italic></sub>, respectively, represent all the exons and splice junctions appearing at least once in <inline-formula id="il1"><mml:math id="IL1" display="inline" overflow="scroll"><mml:msub><mml:mi>G</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mrow><mml:mo>,</mml:mo></mml:mrow><mml:mspace width="0.4em"/><mml:msub><mml:mi>J</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mspace width="0.4em"/></mml:mrow></mml:math></inline-formula> (<italic>k</italic> ∈ [1, <italic>S</italic>]), which is achieved in the following way. Initialize <italic>G<sub>U</sub> = G</italic><sub>1</sub>; then for <italic>k</italic> from two to <italic>S</italic>, for each node (exon), <inline-formula id="il2"><mml:math id="IL2" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mo>[</mml:mo><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>l</mml:mi><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mo>,</mml:mo></mml:mrow><mml:mspace width="0.4em"/><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>r</mml:mi><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msubsup><mml:mo>]</mml:mo></mml:math></inline-formula> in <italic>E</italic><sub><italic>k</italic></sub>, if there exists node (exon) <inline-formula id="il3"><mml:math id="IL3" display="inline" overflow="scroll"><mml:msub><mml:mi>e</mml:mi><mml:mi>U</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mrow><mml:mo>,</mml:mo></mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>]</mml:mo></mml:math></inline-formula> in <italic>E</italic><sub><italic>U</italic></sub> such that they overlap, we then set <inline-formula id="il4"><mml:math id="IL4" display="inline" overflow="scroll"><mml:msub><mml:mi>E</mml:mi><mml:mi>U</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mi>U</mml:mi></mml:msub><mml:mo>∪</mml:mo><mml:mo fence="false">{</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="normal">min</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo>,</mml:mo></mml:mrow><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">max</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo fence="false">}</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mo fence="false">{</mml:mo></mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>U</mml:mi></mml:msub><mml:mrow><mml:mo fence="false">}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="il5"><mml:math id="IL5" display="inline" overflow="scroll"><mml:msub><mml:mi>E</mml:mi><mml:mi>U</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mi>U</mml:mi></mml:msub><mml:mo>∪</mml:mo><mml:mrow><mml:mo fence="false">{</mml:mo><mml:mtext> </mml:mtext></mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mrow><mml:mo fence="false">}</mml:mo><mml:mtext> </mml:mtext></mml:mrow></mml:math></inline-formula> otherwise, and further set <inline-formula id="il6"><mml:math id="IL6" display="inline" overflow="scroll"><mml:msub><mml:mi>J</mml:mi><mml:mi>U</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>U</mml:mi></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:math></inline-formula>. After that, for those coordinates of splice junctions appearing in an exon, we split the exon into several partial exons accordingly. That is, if for any splice junction <inline-formula id="il7"><mml:math id="IL7" display="inline" overflow="scroll"><mml:mspace width="0.4em"/><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mrow><mml:mo>→</mml:mo></mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:math></inline-formula> in <italic>J</italic><sub>U</sub> and any exon <inline-formula id="il8"><mml:math id="IL8" display="inline" overflow="scroll"><mml:mspace width="0.4em"/><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mrow><mml:mo>,</mml:mo></mml:mrow><mml:mspace width="0.4em"/><mml:msub><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>]</mml:mo></mml:math></inline-formula> in <italic>E<sub>U</sub>,</italic> such that <italic>e</italic><sub><italic>l</italic></sub> &lt; <italic>j</italic><sub><italic>l</italic></sub> &lt; <italic>e</italic><sub><italic>r</italic></sub>, we will split <italic>e</italic> into <italic>e</italic>′ = [<italic>e</italic><sub><italic>l</italic></sub>, <italic>j</italic><sub><italic>l</italic></sub>] and <inline-formula id="il9"><mml:math id="IL9" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′′</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mrow><mml:mo>,</mml:mo></mml:mrow><mml:mspace width="0.4em"/><mml:msub><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>]</mml:mo></mml:math></inline-formula>, and in addition, we add a new splice junction (i.e., derived splice junction) <inline-formula id="il10"><mml:math id="IL10" display="inline" overflow="scroll"><mml:mi>J</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mo>→</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> to <italic>J</italic><sub>U</sub>. For the case <italic>e</italic><sub><italic>l</italic></sub> &lt; <italic>j</italic><sub><italic>r</italic></sub> &lt; <italic>e</italic><sub><italic>r</italic></sub>, <italic>e</italic> is split into <inline-formula id="il11"><mml:math id="IL11" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mrow><mml:mo>,</mml:mo></mml:mrow><mml:mspace width="0.4em"/><mml:msub><mml:mi>j</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mrow><mml:mo>−</mml:mo></mml:mrow><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:math></inline-formula> and <inline-formula id="il12"><mml:math id="IL12" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′′</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mrow><mml:mo>,</mml:mo></mml:mrow><mml:mspace width="0.4em"/><mml:msub><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>]</mml:mo></mml:math></inline-formula>, and the derived splice junction is <inline-formula id="il13"><mml:math id="IL13" display="inline" overflow="scroll"><mml:mi>J</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>→</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:math></inline-formula>. Therefore, in the unweighted consensus graph, we divide the splice junctions into two categories: the nonderived (the ones that are captured by the mapping tools) and the derived (the ones that are produced by the aforementioned separating exons).</p>
        <p>Next, we weight the exons and junctions in <italic>G</italic><sub><italic>U</italic></sub> with vectors in the following way. For each splice junction <italic>j</italic> (exon <italic>e</italic>) in <italic>G</italic><sub><italic>U</italic></sub>, initialize a vector <italic>vw</italic><sub><italic>j</italic></sub> (<italic>vw</italic><sub><italic>e</italic></sub>) of size <italic>S</italic> with all its components being zero. Then, for each nonderived splice junction <italic>j</italic> in <italic>J</italic><sub><italic>U</italic></sub>, for <italic>k</italic> from one to <italic>S</italic>, if <italic>j</italic> ∈ <italic>J</italic><sub><italic>K</italic></sub>, then <italic>vw</italic><sub><italic>j</italic></sub> = <italic>vw</italic><sub><italic>j</italic></sub> + <italic>cov</italic>(<italic>j</italic>)<italic>I</italic><sub><italic>k</italic></sub>, where <italic>I</italic><sub><italic>k</italic></sub> is a vector with its <italic>k</italic>th component being one and all other components being zero. For the cases of derived splice junction <italic>j = j</italic><sub>l</sub> → <italic>j</italic><sub><italic>r</italic></sub>, for <italic>k</italic> from one to <italic>S</italic>, if there exists an exon <inline-formula id="il14"><mml:math id="IL14" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mo fence="false">{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mspace width="0.4em"/><mml:mspace width="0.4em"/><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow><mml:mo fence="false">}</mml:mo></mml:math></inline-formula> in <italic>E</italic><sub><italic>k</italic></sub>, such that <inline-formula id="il15"><mml:math id="IL15" display="inline" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>l</mml:mi><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msubsup><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mspace width="0.4em"/><mml:msub><mml:mi>j</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>r</mml:mi><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula>, then <italic>vw</italic><sub><italic>j</italic></sub> = <italic>vw</italic><sub><italic>j</italic></sub> + <italic>cov</italic>(<italic>e</italic>′)<italic>I</italic><sub><italic>k</italic></sub><italic>,</italic> where <italic>I</italic><sub><italic>k</italic></sub> is a vector with its <italic>k</italic>th component being one and all other components being zero. And then, for each node (exon) <italic>e</italic> = (<italic>e</italic><sub><italic>l</italic></sub>, <italic>e</italic><sub><italic>r</italic></sub>) in <italic>E</italic><sub><italic>U</italic></sub>, for <italic>k</italic> from one to <italic>S</italic>, if there exists an exon <inline-formula id="il16"><mml:math id="IL16" display="inline" overflow="scroll"><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mspace width="0.4em"/><mml:mo fence="false">{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mspace width="0.4em"/><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow><mml:mo fence="false">}</mml:mo></mml:math></inline-formula> in <italic>E</italic><sub><italic>k</italic></sub> such that there is an overlap between them, then <italic>vw</italic><sub><italic>e</italic></sub> = <italic>vw</italic><sub><italic>e</italic></sub> + <italic>cov</italic>(<italic>e</italic>′)<italic>I</italic><sub><italic>k</italic></sub><italic>,</italic> where <italic>I</italic><sub><italic>k</italic></sub> is a vector with its <italic>k</italic>th component being one and all other components being zero.</p>
        <p>After the above procedure, we generate the VWSG, in which the exons and splice junctions are all weighted by vectors of dimension <italic>S</italic> with the <italic>k</italic>th component being the corresponding weight in the <italic>k</italic>th sample. And, for each splice junction <italic>j</italic> (exon <italic>e</italic>), we also define a consensus weight <italic>cw</italic><sub><italic>j</italic></sub> (<italic>cw</italic><sub><italic>e</italic></sub>) as the norm of its vector weight <italic>vw</italic><sub><italic>j</italic></sub> (<italic>vw</italic><sub><italic>e</italic></sub>), that is, <inline-formula id="il17"><mml:math id="IL17" display="inline" overflow="scroll"><mml:mi>c</mml:mi><mml:msub><mml:mi>w</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msqrt><mml:mi>v</mml:mi><mml:msubsup><mml:mi>w</mml:mi><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo>+</mml:mo><mml:mi>v</mml:mi><mml:msubsup><mml:mi>w</mml:mi><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo>+</mml:mo><mml:mrow><mml:mo>…</mml:mo></mml:mrow><mml:mi>v</mml:mi><mml:msubsup><mml:mi>w</mml:mi><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:msqrt></mml:math></inline-formula>
<inline-formula id="il18"><mml:math id="IL18" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:msub><mml:mi>w</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msqrt><mml:mi>v</mml:mi><mml:msubsup><mml:mi>w</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mn>1</mml:mn></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo>+</mml:mo><mml:mi>v</mml:mi><mml:msubsup><mml:mi>w</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mn>2</mml:mn></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo>+</mml:mo><mml:mrow><mml:mo>…</mml:mo></mml:mrow><mml:mi>v</mml:mi><mml:msubsup><mml:mi>w</mml:mi><mml:mrow><mml:mi>e</mml:mi><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:msqrt></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>vw</italic><sub><italic>jk</italic></sub> (<italic>vw</italic><sub><italic>ek</italic></sub>) is the <italic>k</italic>th component of <italic>vw</italic><sub><italic>j</italic></sub> (<italic>vw</italic><sub><italic>e</italic></sub>).</p>
        <p>Because of the sequencing or mapping errors, there are quite a few spurious splice junctions in the VWSGs. Usually, the weight of the spurious splice junction is relatively low; hence, we use the following heuristic criteria to remove the potential false positives: (1) We remove a splice junction <italic>j</italic> in <italic>J</italic><sub><italic>U</italic></sub> with all the components in <italic>vw</italic><sub><italic>j</italic></sub> less than one; (2) if there is an exon with multiple out- (or in-) splice junctions, we remove the splice junction <italic>j</italic> with its consensus weights <italic>cw</italic><sub><italic>j</italic></sub> &lt;10% the total out- (or in-) consensus weights; and (3) for an exon <italic>e</italic>, if there exists a derived splice junction from <italic>e′</italic> to <italic>e</italic> and a derived splice junction from <italic>e</italic> to <italic>e′′</italic>, while a nonderived splice junction <italic>j</italic> from <italic>e′</italic> to <italic>e′′,</italic> then if <italic>cw</italic><sub><italic>e</italic></sub> is less than <italic>cw</italic><sub><italic>j</italic></sub>, we remove <italic>e</italic> and all splice junctions associated with it.</p>
        <p>Moreover, we map the paired paths of each sample to the VWSG and generate a consensus paired path set <italic>CP</italic>, where each paired path <italic>p</italic> in <italic>CP</italic> is weighted by a vector, <italic>vw</italic><sub><italic>p</italic></sub>, of dimension <italic>S</italic> with its <italic>k</italic>th component being <italic>cov(p)</italic> in <italic>k</italic>th sample, and <italic>p</italic> is also weighted by a consensus weight, <italic>cw</italic><sub><italic>p</italic></sub>, as in the aforementioned definition. To minimize the false positives, for each paired path <italic>p</italic> in <italic>CP</italic>, if more than one-third of the components in <italic>vw</italic><sub><italic>p</italic></sub> is zero, we will remove <italic>p</italic> from <italic>CP</italic>.</p>
      </sec>
    </sec>
    <sec id="s3b">
      <title>Generating transcript-representing paths</title>
      <p>Ideally, each expressed transcript corresponds to a path in the VWSG <italic>=</italic> (<italic>E, J</italic>), where <italic>E</italic> is the set of exons (nodes), and <italic>J</italic> is the set of splice junctions (edges). Therefore, establishing precise connections between the incoming and outgoing junctions for each exon in VWSG is of great importance for accurately recovering the transcript-representing paths. Specifically, suppose that the number of incoming (outgoing) junctions of exon <italic>e</italic> is <italic>m</italic> (<italic>n</italic>). There are up to <italic>m</italic>× <italic>n</italic> possible connections between the incoming and outgoing junctions of <italic>e</italic>. However, not all the connections are correct. Our goal is to determine the potential correct connections such that they would explain the to-be-predicted transcripts, which can be achieved by the following combing strategy.</p>
      <sec id="s3b1">
        <title>Combing the incoming and outgoing splice junctions of each exon based on the cosine similarity</title>
        <p>Note that each junction <italic>j</italic> in <italic>J</italic> is weighted by a vector <italic>vw</italic><sub><italic>j</italic></sub>, which could be regarded as a point (or vector) in an <italic>S</italic>-dimensional space (where <italic>S</italic> is the number of samples). For the two splice junctions <italic>j</italic> and <italic>j′</italic>, where <italic>j</italic> is an incoming junction of exon <italic>e</italic> and <italic>j′</italic> is an outgoing junction of <italic>e</italic>, if <italic>j</italic> and <italic>j′</italic> are appearing in the same transcript across multiple samples, then there will be a high possibility that <italic>vw</italic><sub><italic>j</italic></sub> and <italic>vw<sub>j′</sub></italic> possess some similarity. Subsequently, we take into account the cosine similarity, a metric that pays more attention to directions, which measures similarity as the cosine of the angle of two vectors, and two similar vectors are expected to have a small angle. Mathematically, the cosine similarity between two vectors <italic>vw</italic><sub><italic>j</italic></sub> and <italic>vw<sub>j′</sub></italic>, respectively, on junctions <italic>j</italic> and <italic>j′</italic>, which are incident with a node (exon), is defined as<disp-formula id="GR276434YUUM1"><mml:math id="UM1" display="block" overflow="scroll"><mml:mi>c</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:msub><mml:mi>w</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mspace width="0.4em"/><mml:mi>v</mml:mi><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:msup><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mspace width="0.4em"/><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:munderover><mml:mrow><mml:mo movablelimits="false">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>S</mml:mi></mml:munderover><mml:mo>⁡</mml:mo><mml:mi>v</mml:mi><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mi>v</mml:mi><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:msup><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo fence="true" symmetric="true" maxsize="2.047em" minsize="2.047em">/</mml:mo></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:msub><mml:mi>w</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>×</mml:mo><mml:mi>c</mml:mi><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:msup><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:math></disp-formula>
where <italic>vw</italic><sub><italic>ji</italic></sub> and <inline-formula id="il19"><mml:math id="IL19" display="inline" overflow="scroll"><mml:mi>v</mml:mi><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:msup><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> are the <italic>i</italic>th components of <italic>vw</italic><sub><italic>j</italic></sub> and <italic>vw<sub>j′</sub></italic>, respectively, and <italic>cw</italic><sub><italic>j</italic></sub> and <italic>cw<sub>j′</sub></italic> are the aforementioned consensus weights of <italic>vw</italic><sub><italic>j</italic></sub> and <italic>vw<sub>j′</sub></italic>, respectively. Note that the similarity between <italic>vw</italic><sub><italic>ji</italic></sub> and <inline-formula id="il20"><mml:math id="IL20" display="inline" overflow="scroll"><mml:mi>v</mml:mi><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:msup><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> increases as <inline-formula id="il21"><mml:math id="IL21" display="inline" overflow="scroll"><mml:mi>c</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:msub><mml:mi>w</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mspace width="0.4em"/><mml:mi>v</mml:mi><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:msup><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> increases. We also define the cosine similarity between two sets of splice junctions <italic>J</italic><sub>1</sub> and <italic>J</italic><sub>2</sub>, as<disp-formula id="GR276434YUUM2"><mml:math id="UM2" display="block" overflow="scroll"><mml:mi>c</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>J</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mi>s</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:munder><mml:mrow><mml:mo movablelimits="false">∑</mml:mo></mml:mrow><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi><mml:mn>1</mml:mn><mml:mo>∈</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:munder><mml:mo>⁡</mml:mo><mml:mi>v</mml:mi><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:munder><mml:mrow><mml:mo movablelimits="false">∑</mml:mo></mml:mrow><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi><mml:mn>2</mml:mn><mml:mo>∈</mml:mo><mml:msub><mml:mi>J</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munder><mml:mo>⁡</mml:mo><mml:mi>v</mml:mi><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math></disp-formula>
that is, the cosine similarity between the sums of the weight vectors for the splice junctions in <italic>J</italic><sub>1</sub> and <italic>J</italic><sub>2</sub>.</p>
        <p>Afterward, we heuristically designed the following constrained optimization program to hunt for the potential right connections between the incoming and outgoing splice junctions of an exon <italic>e</italic> in the VWSG. Denote by <italic>J</italic><sub><italic>in</italic></sub> and <italic>J</italic><sub><italic>out</italic></sub>, the sets of incoming and outgoing splice junctions of <italic>e</italic>, respectively, the underlying thought of the program is to partition <italic>J</italic><sub><italic>in</italic></sub> and <italic>J</italic><sub><italic>out</italic></sub> into <italic>M</italic> parts, respectively, denoted by <italic>P</italic><sub>1</sub>, <italic>P</italic><sub>2</sub>, .., <italic>P</italic><sub><italic>M</italic></sub> and <italic>P</italic>′<sub>1</sub>, <italic>P</italic>′<sub>2</sub>, .., <italic>P</italic>′<sub><italic>M</italic></sub>, where there is a one-to-one correspondence between <italic>P</italic><sub><italic>i</italic></sub> and <italic>P′<sub>i</sub></italic> (1 ≤ <italic>i</italic> ≤ <italic>M</italic>) and the cosine similarity between <italic>P</italic><sub><italic>i</italic></sub> and <italic>P′</italic><sub><italic>i</italic></sub> is relatively higher, which implies that a splice junction, <italic>j</italic>, in <italic>P</italic><sub><italic>i</italic></sub> and <italic>j′</italic> in <italic>P′</italic><sub><italic>i</italic></sub> has the higher possibility of being from the same transcript. Hence, the program is designed as follows:<disp-formula id="GR276434YUUM3"><mml:math id="UM3" display="block" overflow="scroll"><mml:mtable rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:mrow><mml:mrow><mml:mi mathvariant="normal">max</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">min</mml:mi></mml:mrow><mml:mo fence="false">{</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="normal">cs</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.4em"/><mml:mi>c</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>M</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mi>M</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo fence="false">}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>t</mml:mi><mml:mo>.</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:mrow><mml:munderover><mml:mrow><mml:mo>∪</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>M</mml:mi></mml:munderover><mml:mo>⁡</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo fence="false">{</mml:mo><mml:mrow><mml:mspace width="0.4em"/><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mspace width="0.4em"/><mml:msub><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow><mml:mo fence="false">}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:munderover><mml:mrow><mml:mo>∪</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>M</mml:mi></mml:munderover><mml:mo>⁡</mml:mo><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo fence="false">{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mspace width="0.4em"/><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mi>j</mml:mi><mml:mrow><mml:mspace width="0.4em"/><mml:mspace width="0.4em"/><mml:mi>n</mml:mi></mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:msubsup></mml:mrow><mml:mo fence="false">}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="normal">∅</mml:mi><mml:mspace width="0.4em"/><mml:mi mathvariant="normal">&amp;</mml:mi><mml:mspace width="0.4em"/><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="normal">∅</mml:mi><mml:mspace width="0.4em"/><mml:mspace width="0.4em"/><mml:mi>i</mml:mi><mml:mi>f</mml:mi><mml:mspace width="0.4em"/><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mspace width="0.4em"/><mml:mo>≠</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>c</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>&gt;</mml:mo><mml:mi>c</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.4em"/><mml:mspace width="0.4em"/><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mspace width="0.4em"/><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi><mml:mspace width="0.4em"/><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>c</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.4em"/><mml:mspace width="0.4em"/><mml:mn>0</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>ρ</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="normal">∃</mml:mi><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mo>[</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>M</mml:mi></mml:mrow><mml:mo>]</mml:mo><mml:mspace width="0.4em"/><mml:mi>s</mml:mi><mml:mi>u</mml:mi><mml:mi>c</mml:mi><mml:mi>h</mml:mi><mml:mspace width="0.4em"/><mml:mi>t</mml:mi><mml:mi>h</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mspace width="0.4em"/><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mspace width="0.4em"/><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi><mml:mspace width="0.4em"/><mml:msup><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mspace width="0.4em"/><mml:mspace width="0.4em"/><mml:mi>i</mml:mi><mml:mi>f</mml:mi><mml:mspace width="0.4em"/><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>⊂</mml:mo><mml:mi>c</mml:mi><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.4em"/><mml:mi>c</mml:mi><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:mi>C</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mn>1</mml:mn><mml:mo>&lt;</mml:mo><mml:mspace width="0.4em"/><mml:mi>M</mml:mi><mml:mspace width="0.4em"/><mml:mo>≤</mml:mo><mml:mo movablelimits="true" form="prefix">min</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mo>,</mml:mo></mml:math></disp-formula>
where <inline-formula id="il22"><mml:math id="IL22" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="normal">min</mml:mi></mml:mrow><mml:mo fence="false">{</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="normal">cs</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.4em"/><mml:mspace width="0.4em"/><mml:mi>c</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>M</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mi>M</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo fence="false">}</mml:mo></mml:math></inline-formula> is the minimum element in the set <inline-formula id="il23"><mml:math id="IL23" display="inline" overflow="scroll"><mml:mo fence="false">{</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="normal">cs</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mspace width="0.4em"/><mml:mspace width="0.4em"/><mml:mi>c</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>M</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mspace width="0.4em"/><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mi>M</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo fence="false">}</mml:mo></mml:math></inline-formula>; <italic>J</italic><sub><italic>in</italic></sub> = {<italic>j</italic><sub>1</sub>, <italic>j</italic><sub>2</sub>, …, <italic>j</italic><sub><italic>m</italic></sub>} is the set of the incoming splice junctions of exon <italic>e</italic>, and <inline-formula id="il24"><mml:math id="IL24" display="inline" overflow="scroll"><mml:msub><mml:mi>J</mml:mi><mml:mrow><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo fence="false">{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mspace width="0.4em"/><mml:msub><mml:mrow><mml:msup><mml:mrow><mml:mspace width="0.4em"/><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mi>j</mml:mi><mml:mrow><mml:mspace width="0.4em"/><mml:mspace width="0.4em"/><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msubsup></mml:mrow><mml:mo fence="false">}</mml:mo></mml:math></inline-formula> is the set of the outgoing splice junctions; <italic>P</italic><sub><italic>i</italic></sub> and <italic>P′</italic><sub><italic>i</italic></sub> are the subsets of <italic>J</italic><sub><italic>in</italic></sub> and <italic>J</italic><sub><italic>out</italic></sub>, respectively; <italic>ρ</italic> is a parameter between zero and one indicating that the similarity between the corresponding parts should be at least ρ; and <italic>CP</italic> is the set of the consensus paired paths (for details, see the <ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Methods</ext-link>). Note that there could be no feasible solution for this program, as such a case indicates that we cannot split the splice junctions associated with exon <italic>e</italic> into different parts, and we will set in this case that <italic>M</italic> = 1, <italic>P</italic><sub>1</sub> = <italic>J</italic><sub><italic>in</italic></sub>, and <italic>P</italic>′<sub>1</sub> = <italic>J</italic><sub><italic>out</italic></sub>. And it is worth mentioning that in the case of <italic>S =</italic>1 (i.e., only one sample), this program does not work, because in a one-dimensional space, the cosine similarity of any two nonzero one-dimensional vectors is always equal to one.</p>
        <p>When the above program is solved (the case in which it has an optimal solution), we split the node (exon) <italic>e</italic> into <italic>M</italic> new nodes, denoted by by <italic>e</italic><sub>1</sub>, <italic>e</italic><sub>2</sub>, …, <italic>e</italic><sub><italic>M</italic></sub>, and the splice junctions in <italic>P</italic><sub><italic>i</italic></sub> and <italic>P′</italic><sub><italic>i</italic></sub> are all incident to <italic>e</italic><sub><italic>i</italic></sub> for <italic>i</italic> from one to <italic>M</italic>. We call this procedure combing exon.</p>
      </sec>
      <sec id="s3b2">
        <title>Recovering transcripts by a label-setting algorithm</title>
        <p>After combing all the exons in VWSG, we use a label-setting algorithm that is similar to the study of <xref rid="GR276434YUC20" ref-type="bibr">Niknafs et al. (2017)</xref> to recover the transcripts via taking into account the consensus weights of splice junctions and the cosine similarity between associated junctions and the consensus paired paths. The basic idea of the label-setting algorithm is to iteratively find the most highly expressed transcript from the VWSG, which is implemented as follows.</p>
        <p><italic>Step 1. Labeling.</italic> Suppose that the edges (junctions) in the VWSG are ordered by topological sort. Without loss of generality, we number them as 1, 2 … <italic>N</italic>. For each edge <italic>j</italic> = <italic>e</italic> → <italic>e</italic>′ (where <italic>e</italic> and <italic>e</italic>′ are two nodes (exons) in the VWSG), we denote by <italic>predecessors(j)</italic> the set of the incoming splice junctions of exon <italic>e</italic>, and by <italic>successors(j)</italic> the set of the outgoing splice junctions of node <italic>e</italic>′. Then starting from a nonderived splice junction (or a derived splice junction with its consensus weight larger than 10) <italic>j</italic><sub>0</sub> (<italic>j</italic><sub>0</sub> ∈ [1, <italic>N</italic>], and <italic>j</italic><sub>0</sub> has not been covered by a predicted transcript) with the largest consensus weight, the label-setting algorithm maintains two labels, <italic>MinExp</italic><sub><italic>j</italic></sub> and <italic>Pre</italic><sub><italic>j</italic></sub> (<italic>Suc</italic><sub><italic>j</italic></sub>), for the junction <italic>j</italic> ≥ <italic>j</italic><sub>0</sub> (≤<italic>j</italic><sub>0</sub>); hence, we label <italic>j</italic><sub>0</sub> with <italic>MinExp</italic><sub><italic>j</italic>0</sub> = <italic>cw</italic><sub><italic>j</italic>0</sub>, and <italic>Pre</italic><sub><italic>j</italic>0</sub> = <italic>null</italic> (<italic>Suc</italic><sub><italic>j</italic>0</sub> = <italic>null</italic>). Then for each junction <italic>j</italic> from <italic>j<italic><sub>0</sub> + 1</italic>
<italic>to</italic> N</italic>, if <italic>predecessors(j)</italic> is not empty, choose a labeled junction <italic>j′</italic> from <italic>predecessors(j)</italic> in the following priority order: <italic>j′</italic> with largest <italic>MinExp<sub>j′</sub></italic> and <italic>j′ <italic>→</italic> j</italic> being covered by a consensus paired path; <italic>j′</italic> with largest <italic>MinExp<sub>j′</sub></italic> and <italic>cs(j′, j) &gt;</italic>ρ; or <italic>j′</italic> with largest <italic>MinExp<sub>j′</sub></italic>, and set <italic>MinExp<sub>j</sub></italic>= <italic>min{MinExp<sub>j′</sub>, cw<sub>j</sub>}</italic> and <italic>Pre<sub>j</sub> = j′</italic>. If none of <italic>predecessors(j)</italic> is labeled or <italic>predecessors(j)</italic> is empty, set <italic>MinExp<sub>i</sub> = null</italic> and <italic>Pre<sub>j</sub> = null</italic>. For splice junction <italic>j</italic> from <italic>j</italic><sub>0</sub>–1 to one, we use the same method to set <italic>MinExp<sub>j′</sub></italic> and <italic>Suc</italic><sub><italic>j</italic></sub>.</p>
        <p><italic>Step 2. Tracing back.</italic> After all the splice junctions have been labeled, we will first extract the highest expressed transcripts based on the labels <italic>MinExp</italic> and <italic>Pre</italic>(<italic>Suc</italic>) of the junctions as follows: starting at the junction of the largest <italic>MinExp</italic> linked with the destination (origin) and extending backward (forward) based on the label <italic>Pre (Suc)</italic> until reaching <italic>j</italic><sub>0</sub>. Then the highest expressed transcript <italic>p</italic><sub><italic>h</italic></sub> in the VWSG is recovered.</p>
        <p><italic>Step 3. Updating VWSG.</italic> Defining <italic>cw</italic><sub><italic>min</italic></sub> as the vector weight of the splice junction with minimum consensus weight in the extended path <italic>p</italic><sub><italic>h</italic></sub>, we update the weight <italic>vw</italic><sub><italic>j</italic></sub> to be <italic>vw<sub>j</sub>−cw<sub>min</sub>E,</italic> where <italic>E</italic> is a vector with all its components being one. For each junction <italic>j</italic> in <italic>p</italic><sub><italic>h</italic></sub>, and if a component of <italic>vw</italic><sub><italic>j</italic></sub> is less than zero, we simply set it to be zero.</p>
        <p>Repeat Step 1 to Step 3, until all the nonderived splice junctions in VWSG have been covered by the predicted transcripts. Finally, a transcript-representing path cover is obtained, which is defined as the initial meta-assembly.</p>
      </sec>
    </sec>
    <sec id="s3c">
      <title>Predicting a set of transcripts for each sample</title>
      <p>After producing the initial meta-assembly, we attempt to produce a set of transcripts for each individual sample, which can be easily achieved in the VWSG based on the vector weight of each splice junction. To do so, for each path (transcript) in the initial meta-assembly, if more than half of its junctions are covered by the <italic>k</italic>th sample (i.e., the <italic>k</italic>th component in corresponding <italic>vw</italic><sub><italic>j</italic></sub> is not zero), we will temporarily output it as a transcript of the <italic>k</italic>th sample. Meanwhile, we estimate the expression levels of the transcripts for the <italic>k</italic>th sample, followed by filtering the false positives that are actually the transcripts with relatively low estimated expression levels.</p>
    </sec>
    <sec id="s3d">
      <title>Generating the mature meta-assembly</title>
      <p>Based on the estimated expression abundance of transcripts in each individual sample, we generate the final set of meta-assemblies. We assign a score that is the transcript's average estimated abundance across the samples to each transcript in the initial meta-assembly. Then we filter out the transcripts with a relatively low score. We set the filtering score as a user-friendly parameter in the TransMeta as different parameters may have different effects for data with specific characteristics. Furthermore, TransMeta automatically outputs a set of meta-assemblies with different filtering parameters.</p>
      <p>Finally, we output both consensus meta-assembly for all the samples and a certain set of transcripts for each individual sample.</p>
    </sec>
  </sec>
  <sec id="s4">
    <title>Data access</title>
    <p>The reference genome and transcripts used for evaluating the performance of the assemblers are described in the <ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Notes</ext-link>. The description of the simulated data sets and the accession numbers for all the real data sets used in this study are in the <ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Notes</ext-link> as well. The source code for the latest version of the TransMeta package is available at GitHub (<uri xlink:href="https://github.com/yutingsdu/TransMeta">https://github.com/yutingsdu/TransMeta</uri>) and as <ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.276434.121/-/DC1" ext-link-type="uri">Supplemental Code</ext-link>.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="PMC_1" content-type="local-data">
      <caption>
        <title>Supplemental Material</title>
      </caption>
      <media mimetype="text" mime-subtype="html" xlink:href="supp_32_7_1398__DC1.html"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="pdf" xlink:href="supp_gr.276434.121_Supplemental_Material.pdf"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="x-zip-compressed" xlink:href="supp_gr.276434.121_Supplemental_Code.zip"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgments</title>
    <p>This work was supported by the National Key R&amp;D Program of China with code 2020YFA0712400; the National Natural Science Foundation of China with codes 11931008, 12101368, and 61771009; the China Postdoctoral Science Foundation with code 2021M701998; and the Natural Science Foundation of Shandong Province with code ZR2021QA013. The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</p>
    <p><italic>Author contributions:</italic> T.Y., X.Z., and G.L. conceived and designed the experiments. T.Y. performed the experiments. T.Y. and X.Z. analyzed the data. X.Z., T.Y., and G.L. contributed reagents, materials, and analysis tools. T.Y., X.Z., and G.L. wrote the paper. T.Y. designed the software used in the analysis. G.L. oversaw the project.</p>
  </ack>
  <fn-group>
    <fn fn-type="supplementary-material">
      <p>[Supplemental material is available for this article.]</p>
    </fn>
    <fn>
      <p>Article published online before print. Article, supplemental material, and publication date are at <ext-link xlink:href="https://www.genome.org/cgi/doi/10.1101/gr.276434.121" ext-link-type="uri">https://www.genome.org/cgi/doi/10.1101/gr.276434.121</ext-link>.</p>
    </fn>
    <fn>
      <p>Freely available online through the <italic>Genome Research</italic> Open Access option.</p>
    </fn>
  </fn-group>
  <sec id="s5">
    <title>Competing interest statement</title>
    <p>The authors declare no competing interests.</p>
  </sec>
  <ref-list>
    <title>References</title>
    <ref id="GR276434YUC1">
      <mixed-citation publication-type="journal"><string-name><surname>Behr</surname><given-names>J</given-names></string-name>, <string-name><surname>Kahles</surname><given-names>A</given-names></string-name>, <string-name><surname>Zhong</surname><given-names>Y</given-names></string-name>, <string-name><surname>Sreedharan</surname><given-names>VT</given-names></string-name>, <string-name><surname>Drewe</surname><given-names>P</given-names></string-name>, <string-name><surname>Rätsch</surname><given-names>G</given-names></string-name>. <year>2013</year>. <article-title>MITIE: simultaneous RNA-Seq-based transcript identification and quantification in multiple samples</article-title>. <source>Bioinformatics</source><volume>29</volume>: <fpage>2529</fpage>–<lpage>2538</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btt442</pub-id><pub-id pub-id-type="pmid">23980025</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC2">
      <mixed-citation publication-type="journal"><string-name><surname>Canzar</surname><given-names>S</given-names></string-name>, <string-name><surname>Andreotti</surname><given-names>S</given-names></string-name>, <string-name><surname>Weese</surname><given-names>D</given-names></string-name>, <string-name><surname>Reinert</surname><given-names>K</given-names></string-name>, <string-name><surname>Klau</surname><given-names>GW</given-names></string-name>. <year>2016</year>. <article-title>CIDANE: comprehensive isoform discovery and abundance estimation</article-title>. <source>Genome Biol</source><volume>17</volume>: <fpage>16</fpage>. <pub-id pub-id-type="doi">10.1186/s13059-015-0865-0</pub-id><pub-id pub-id-type="pmid">26831908</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC3">
      <mixed-citation publication-type="journal"><string-name><surname>Chang</surname><given-names>Z</given-names></string-name>, <string-name><surname>Li</surname><given-names>GJ</given-names></string-name>, <string-name><surname>Liu</surname><given-names>JT</given-names></string-name>, <string-name><surname>Zhang</surname><given-names>Y</given-names></string-name>, <string-name><surname>Ashby</surname><given-names>C</given-names></string-name>, <string-name><surname>Liu</surname><given-names>DL</given-names></string-name>, <string-name><surname>Cramer</surname><given-names>CL</given-names></string-name>, <string-name><surname>Huang</surname><given-names>XZ</given-names></string-name>. <year>2015</year>. <article-title>Bridger: a new framework for <italic>de novo</italic> transcriptome assembly using RNA-seq data</article-title>. <source>Genome Biol</source><volume>16</volume>: <fpage>30</fpage>. <pub-id pub-id-type="doi">10.1186/s13059-015-0596-2</pub-id><pub-id pub-id-type="pmid">25723335</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC4">
      <mixed-citation publication-type="journal"><string-name><surname>Dobin</surname><given-names>A</given-names></string-name>, <string-name><surname>Davis</surname><given-names>CA</given-names></string-name>, <string-name><surname>Schlesinger</surname><given-names>F</given-names></string-name>, <string-name><surname>Drenkow</surname><given-names>J</given-names></string-name>, <string-name><surname>Zaleski</surname><given-names>C</given-names></string-name>, <string-name><surname>Jha</surname><given-names>S</given-names></string-name>, <string-name><surname>Batut</surname><given-names>P</given-names></string-name>, <string-name><surname>Chaisson</surname><given-names>M</given-names></string-name>, <string-name><surname>Gingeras</surname><given-names>TR</given-names></string-name>. <year>2013</year>. <article-title>STAR: ultrafast universal RNA-seq aligner</article-title>. <source>Bioinformatics</source><volume>29</volume>: <fpage>15</fpage>–<lpage>21</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/bts635</pub-id><pub-id pub-id-type="pmid">23104886</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC5">
      <mixed-citation publication-type="journal"><string-name><surname>Feng</surname><given-names>JX</given-names></string-name>, <string-name><surname>Li</surname><given-names>W</given-names></string-name>, <string-name><surname>Jiang</surname><given-names>T</given-names></string-name>. <year>2011</year>. <article-title>Inference of isoforms from short sequence reads</article-title>. <source>J Comput Biol</source><volume>18</volume>: <fpage>305</fpage>–<lpage>321</lpage>. <pub-id pub-id-type="doi">10.1089/cmb.2010.0243</pub-id><pub-id pub-id-type="pmid">21385036</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC6">
      <mixed-citation publication-type="journal"><string-name><surname>Guttman</surname><given-names>M</given-names></string-name>, <string-name><surname>Garber</surname><given-names>M</given-names></string-name>, <string-name><surname>Levin</surname><given-names>JZ</given-names></string-name>, <string-name><surname>Donaghey</surname><given-names>J</given-names></string-name>, <string-name><surname>Robinson</surname><given-names>J</given-names></string-name>, <string-name><surname>Adiconis</surname><given-names>X</given-names></string-name>, <string-name><surname>Fan</surname><given-names>L</given-names></string-name>, <string-name><surname>Koziol</surname><given-names>MJ</given-names></string-name>, <string-name><surname>Gnirke</surname><given-names>A</given-names></string-name>, <string-name><surname>Nusbaum</surname><given-names>C</given-names></string-name>, <etal/><year>2010</year>. <article-title><italic>Ab initio</italic> reconstruction of cell type–specific transcriptomes in mouse reveals the conserved multi-exonic structure of lincRNAs</article-title>. <source>Nat Biotechnol</source><volume>28</volume>: <fpage>503</fpage>–<lpage>510</lpage>. <pub-id pub-id-type="doi">10.1038/nbt.1633</pub-id><pub-id pub-id-type="pmid">20436462</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC7">
      <mixed-citation publication-type="journal"><string-name><surname>Kim</surname><given-names>D</given-names></string-name>, <string-name><surname>Pertea</surname><given-names>G</given-names></string-name>, <string-name><surname>Trapnell</surname><given-names>C</given-names></string-name>, <string-name><surname>Pimentel</surname><given-names>H</given-names></string-name>, <string-name><surname>Kelley</surname><given-names>R</given-names></string-name>, <string-name><surname>Salzberg</surname><given-names>SL</given-names></string-name>. <year>2013</year>. <article-title>TopHat2: accurate alignment of transcriptomes in the presence of insertions, deletions and gene fusions</article-title>. <source>Genome Biol</source><volume>14</volume>: <fpage>R36</fpage>. <pub-id pub-id-type="doi">10.1186/gb-2013-14-4-r36</pub-id><pub-id pub-id-type="pmid">23618408</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC8">
      <mixed-citation publication-type="journal"><string-name><surname>Kim</surname><given-names>D</given-names></string-name>, <string-name><surname>Langmead</surname><given-names>B</given-names></string-name>, <string-name><surname>Salzberg</surname><given-names>SL</given-names></string-name>. <year>2015</year>. <article-title>HISAT: a fast spliced aligner with low memory requirements</article-title>. <source>Nat Methods</source><volume>12</volume>: <fpage>357</fpage>–<lpage>360</lpage>. <pub-id pub-id-type="doi">10.1038/nmeth.3317</pub-id><pub-id pub-id-type="pmid">25751142</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC9">
      <mixed-citation publication-type="journal"><string-name><surname>Kim</surname><given-names>D</given-names></string-name>, <string-name><surname>Paggi</surname><given-names>JM</given-names></string-name>, <string-name><surname>Park</surname><given-names>C</given-names></string-name>, <string-name><surname>Bennett</surname><given-names>C</given-names></string-name>, <string-name><surname>Salzberg</surname><given-names>SL</given-names></string-name>. <year>2019</year>. <article-title>Graph-based genome alignment and genotyping with HISAT2 and HISAT-genotype</article-title>. <source>Nat Biotechnol</source><volume>37</volume>: <fpage>907</fpage>–<lpage>915</lpage>. <pub-id pub-id-type="doi">10.1038/s41587-019-0201-4</pub-id><pub-id pub-id-type="pmid">31375807</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC10">
      <mixed-citation publication-type="journal"><string-name><surname>Kovaka</surname><given-names>S</given-names></string-name>, <string-name><surname>Zimin</surname><given-names>AV</given-names></string-name>, <string-name><surname>Pertea</surname><given-names>GM</given-names></string-name>, <string-name><surname>Razaghi</surname><given-names>R</given-names></string-name>, <string-name><surname>Salzberg</surname><given-names>SL</given-names></string-name>, <string-name><surname>Pertea</surname><given-names>M</given-names></string-name>. <year>2019</year>. <article-title>Transcriptome assembly from long-read RNA-seq alignments with StringTie2</article-title>. <source>Genome Biol</source><volume>20</volume>: <fpage>278</fpage>. <pub-id pub-id-type="doi">10.1186/s13059-019-1910-1</pub-id><pub-id pub-id-type="pmid">31842956</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC11">
      <mixed-citation publication-type="journal"><string-name><surname>Li</surname><given-names>B</given-names></string-name>, <string-name><surname>Dewey</surname><given-names>C</given-names></string-name>. <year>2011</year>. <article-title>RSEM: accurate transcript quantification from RNA-Seq data with or without a reference genome</article-title>. <source>BMC Bioinformatics</source><volume>12</volume>: <fpage>323</fpage>. <pub-id pub-id-type="doi">10.1186/1471-2105-12-323</pub-id><pub-id pub-id-type="pmid">21816040</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC12">
      <mixed-citation publication-type="journal"><string-name><surname>Li</surname><given-names>W</given-names></string-name>, <string-name><surname>Jiang</surname><given-names>T</given-names></string-name>. <year>2012</year>. <article-title>Transcriptome assembly and isoform expression level estimation from biased RNA-Seq reads</article-title>. <source>Bioinformatics</source><volume>28</volume>: <fpage>2914</fpage>–<lpage>2921</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/bts559</pub-id><pub-id pub-id-type="pmid">23060617</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC13">
      <mixed-citation publication-type="journal"><string-name><surname>Li</surname><given-names>W</given-names></string-name>, <string-name><surname>Feng</surname><given-names>JX</given-names></string-name>, <string-name><surname>Jiang</surname><given-names>T</given-names></string-name>. <year>2011</year>. <article-title>IsoLasso: a LASSO regression approach to RNA-Seq based transcriptome assembly</article-title>. <source>J Comput Biol</source><volume>18</volume>: <fpage>1693</fpage>–<lpage>1707</lpage>. <pub-id pub-id-type="doi">10.1089/cmb.2011.0171</pub-id><pub-id pub-id-type="pmid">21951053</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC14">
      <mixed-citation publication-type="journal"><string-name><surname>Liu</surname><given-names>J</given-names></string-name>, <string-name><surname>Li</surname><given-names>G</given-names></string-name>, <string-name><surname>Chang</surname><given-names>Z</given-names></string-name>, <string-name><surname>Yu</surname><given-names>T</given-names></string-name>, <string-name><surname>Liu</surname><given-names>B</given-names></string-name>, <string-name><surname>McMullen</surname><given-names>R</given-names></string-name>, <string-name><surname>Chen</surname><given-names>P</given-names></string-name>, <string-name><surname>Huang</surname><given-names>X</given-names></string-name>. <year>2016a</year>. <article-title>BinPacker: packing-based <italic>de novo</italic> transcriptome assembly from RNA-seq data</article-title>. <source>PLoS Comput Biol</source><volume>12</volume>: <fpage>e1004772</fpage>. <pub-id pub-id-type="doi">10.1371/journal.pcbi.1004772</pub-id><pub-id pub-id-type="pmid">26894997</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC15">
      <mixed-citation publication-type="journal"><string-name><surname>Liu</surname><given-names>J</given-names></string-name>, <string-name><surname>Yu</surname><given-names>T</given-names></string-name>, <string-name><surname>Jiang</surname><given-names>T</given-names></string-name>, <string-name><surname>Li</surname><given-names>G</given-names></string-name>. <year>2016b</year>. <article-title>TransComb: genome-guided transcriptome assembly via combing junctions in splicing graphs</article-title>. <source>Genome Biol</source><volume>17</volume>: <fpage>213</fpage>. <pub-id pub-id-type="doi">10.1186/s13059-016-1074-1</pub-id><pub-id pub-id-type="pmid">27760567</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC16">
      <mixed-citation publication-type="journal"><string-name><surname>Liu</surname><given-names>J</given-names></string-name>, <string-name><surname>Yu</surname><given-names>T</given-names></string-name>, <string-name><surname>Mu</surname><given-names>Z</given-names></string-name>, <string-name><surname>Li</surname><given-names>G</given-names></string-name>. <year>2019</year>. <article-title>TransLiG: a de novo transcriptome assembler that uses line graph iteration</article-title>. <source>Genome Biol</source><volume>20</volume>: <fpage>81</fpage>. <pub-id pub-id-type="doi">10.1186/s13059-019-1690-7</pub-id><pub-id pub-id-type="pmid">31014374</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC17">
      <mixed-citation publication-type="journal"><string-name><surname>MacManes</surname><given-names>MD</given-names></string-name>, <string-name><surname>Eisen</surname><given-names>MB</given-names></string-name>. <year>2013</year>. <article-title>Improving transcriptome assembly through error correction of high-throughput sequence reads</article-title>. <source>PeerJ</source><volume>1</volume>: <fpage>e113</fpage>. <pub-id pub-id-type="doi">10.7717/peerj.113</pub-id><pub-id pub-id-type="pmid">23904992</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC18">
      <mixed-citation publication-type="journal"><string-name><surname>Marguerat</surname><given-names>S</given-names></string-name>, <string-name><surname>Bähler</surname><given-names>J</given-names></string-name>. <year>2010</year>. <article-title>RNA-seq: from technology to biology</article-title>. <source>Cell Mol Life Sci</source><volume>67</volume>: <fpage>569</fpage>–<lpage>579</lpage>. <pub-id pub-id-type="doi">10.1007/s00018-009-0180-6</pub-id><pub-id pub-id-type="pmid">19859660</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC19">
      <mixed-citation publication-type="journal"><string-name><surname>Mezlini</surname><given-names>AM</given-names></string-name>, <string-name><surname>Smith</surname><given-names>EJM</given-names></string-name>, <string-name><surname>Fiume</surname><given-names>M</given-names></string-name>, <string-name><surname>Buske</surname><given-names>O</given-names></string-name>, <string-name><surname>Savich</surname><given-names>GL</given-names></string-name>, <string-name><surname>Shah</surname><given-names>S</given-names></string-name>, <string-name><surname>Aparicio</surname><given-names>S</given-names></string-name>, <string-name><surname>Chiang</surname><given-names>DY</given-names></string-name>, <string-name><surname>Goldenberg</surname><given-names>A</given-names></string-name>, <string-name><surname>Brudno</surname><given-names>M</given-names></string-name>. <year>2013</year>. <article-title>iReckon: simultaneous isoform discovery and abundance estimation from RNA-seq data</article-title>. <source>Genome Res</source><volume>23</volume>: <fpage>519</fpage>–<lpage>529</lpage>. <pub-id pub-id-type="doi">10.1101/gr.142232.112</pub-id><pub-id pub-id-type="pmid">23204306</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC20">
      <mixed-citation publication-type="journal"><string-name><surname>Niknafs</surname><given-names>YS</given-names></string-name>, <string-name><surname>Pandian</surname><given-names>B</given-names></string-name>, <string-name><surname>Iyer</surname><given-names>HK</given-names></string-name>, <string-name><surname>Chinnaiyan</surname><given-names>AM</given-names></string-name>, <string-name><surname>Iyer</surname><given-names>MK</given-names></string-name>. <year>2017</year>. <article-title>TACO produces robust multisample transcriptome assemblies from RNA-seq</article-title>. <source>Nat Methods</source><volume>14</volume>: <fpage>68</fpage>–<lpage>70</lpage>. <pub-id pub-id-type="doi">10.1038/nmeth.4078</pub-id><pub-id pub-id-type="pmid">27869815</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC21">
      <mixed-citation publication-type="journal"><string-name><surname>Ozsolak</surname><given-names>F</given-names></string-name>, <string-name><surname>Milos</surname><given-names>PM</given-names></string-name>. <year>2011</year>. <article-title>RNA sequencing: advances, challenges and opportunities</article-title>. <source>Nat Rev Genet</source><volume>12</volume>: <fpage>87</fpage>–<lpage>98</lpage>. <pub-id pub-id-type="doi">10.1038/nrg2934</pub-id><pub-id pub-id-type="pmid">21191423</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC22">
      <mixed-citation publication-type="journal"><string-name><surname>Peng</surname><given-names>Y</given-names></string-name>, <string-name><surname>Leung</surname><given-names>HC</given-names></string-name>, <string-name><surname>Yiu</surname><given-names>SM</given-names></string-name>, <string-name><surname>Lv</surname><given-names>MJ</given-names></string-name>, <string-name><surname>Zhu</surname><given-names>XG</given-names></string-name>, <string-name><surname>Chin</surname><given-names>FY</given-names></string-name>. <year>2013</year>. <article-title>IDBA-tran: a more robust de novo de Bruijn graph assembler for transcriptomes with uneven expression levels</article-title>. <source>Bioinformatics</source><volume>29</volume>: <fpage>i326</fpage>–<lpage>i334</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btt219</pub-id><pub-id pub-id-type="pmid">23813001</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC23">
      <mixed-citation publication-type="journal"><string-name><surname>Pertea</surname><given-names>M</given-names></string-name>, <string-name><surname>Pertea</surname><given-names>GM</given-names></string-name>, <string-name><surname>Antonescu</surname><given-names>CM</given-names></string-name>, <string-name><surname>Chang</surname><given-names>TC</given-names></string-name>, <string-name><surname>Mendell</surname><given-names>JT</given-names></string-name>, <string-name><surname>Salzberg</surname><given-names>SL</given-names></string-name>. <year>2015</year>. <article-title>StringTie enables improved reconstruction of a transcriptome from RNA-seq reads</article-title>. <source>Nat Biotechnol</source><volume>33</volume>: <fpage>290</fpage>–<lpage>295</lpage>. <pub-id pub-id-type="doi">10.1038/nbt.3122</pub-id><pub-id pub-id-type="pmid">25690850</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC24">
      <mixed-citation publication-type="journal"><string-name><surname>Phillips</surname><given-names>KA</given-names></string-name>, <string-name><surname>Douglas</surname><given-names>MP</given-names></string-name>, <string-name><surname>Marshall</surname><given-names>DA</given-names></string-name>. <year>2020</year>. <article-title>Expanding use of clinical genome sequencing and the need for more data on implementation</article-title>. <source>JAMA</source><volume>324</volume>: <fpage>2029</fpage>–<lpage>2030</lpage>. <pub-id pub-id-type="doi">10.1001/jama.2020.19933</pub-id><pub-id pub-id-type="pmid">33104159</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC25">
      <mixed-citation publication-type="journal"><string-name><surname>Shao</surname><given-names>M</given-names></string-name>, <string-name><surname>Kingsford</surname><given-names>C</given-names></string-name>. <year>2017</year>. <article-title>Accurate assembly of transcripts through phase-preserving graph decomposition</article-title>. <source>Nat Biotechnol</source><volume>35</volume>: <fpage>1167</fpage>–<lpage>1169</lpage>. <pub-id pub-id-type="doi">10.1038/nbt.4020</pub-id><pub-id pub-id-type="pmid">29131147</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC26">
      <mixed-citation publication-type="journal"><string-name><surname>Simpson</surname><given-names>JT</given-names></string-name>, <string-name><surname>Wong</surname><given-names>K</given-names></string-name>, <string-name><surname>Jackman</surname><given-names>SD</given-names></string-name>, <string-name><surname>Schein</surname><given-names>JE</given-names></string-name>, <string-name><surname>Jones</surname><given-names>SJ</given-names></string-name>, <string-name><surname>Birol</surname><given-names>I</given-names></string-name>. <year>2009</year>. <article-title>ABySS: a parallel assembler for short read sequence data</article-title>. <source>Genome Res</source><volume>19</volume>: <fpage>1117</fpage>–<lpage>1123</lpage>. <pub-id pub-id-type="doi">10.1101/gr.089532.108</pub-id><pub-id pub-id-type="pmid">19251739</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC27">
      <mixed-citation publication-type="journal"><string-name><surname>Song</surname><given-names>L</given-names></string-name>, <string-name><surname>Sabunciyan</surname><given-names>S</given-names></string-name>, <string-name><surname>Florea</surname><given-names>L</given-names></string-name>. <year>2016</year>. <article-title>CLASS2: accurate and efficient splice variant annotation from RNA-seq reads</article-title>. <source>Nucleic Acids Res</source><volume>44</volume>: <fpage>e98</fpage>. <pub-id pub-id-type="doi">10.1093/nar/gkw158</pub-id><pub-id pub-id-type="pmid">26975657</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC28">
      <mixed-citation publication-type="journal"><string-name><surname>Song</surname><given-names>L</given-names></string-name>, <string-name><surname>Sabunciyan</surname><given-names>S</given-names></string-name>, <string-name><surname>Yang</surname><given-names>G</given-names></string-name>, <string-name><surname>Florea</surname><given-names>L</given-names></string-name>. <year>2019</year>. <article-title>A multi-sample approach increases the accuracy of transcript assembly</article-title>. <source>Nat Commun</source><volume>10</volume>: <fpage>5000</fpage>. <pub-id pub-id-type="doi">10.1038/s41467-019-12990-0</pub-id><pub-id pub-id-type="pmid">31676772</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC29">
      <mixed-citation publication-type="journal"><string-name><surname>Tasnim</surname><given-names>M</given-names></string-name>, <string-name><surname>Ma</surname><given-names>S</given-names></string-name>, <string-name><surname>Yang</surname><given-names>E-W</given-names></string-name>, <string-name><surname>Jiang</surname><given-names>T</given-names></string-name>, <string-name><surname>Li</surname><given-names>W</given-names></string-name>. <year>2015</year>. <article-title>Accurate inference of isoforms from multiple sample RNA-Seq data</article-title>. <source>BMC Genomics</source><volume>16</volume>: <fpage>S15</fpage>. <pub-id pub-id-type="doi">10.1186/1471-2164-16-S2-S15</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC30">
      <mixed-citation publication-type="journal"><string-name><surname>Tomescu</surname><given-names>AI</given-names></string-name>, <string-name><surname>Kuosmanen</surname><given-names>A</given-names></string-name>, <string-name><surname>Rizzi</surname><given-names>R</given-names></string-name>, <string-name><surname>Mäkinen</surname><given-names>V</given-names></string-name>. <year>2013</year>. <article-title>A novel min-cost flow method for estimating transcript expression with RNA-Seq</article-title>. <source>BMC Bioinformatics</source><volume>14 (Suppl 5)</volume>: <fpage>S15</fpage>. <pub-id pub-id-type="doi">10.1186/1471-2105-14-S5-S15</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC31">
      <mixed-citation publication-type="journal"><string-name><surname>Trapnell</surname><given-names>C</given-names></string-name>, <string-name><surname>Pachter</surname><given-names>L</given-names></string-name>, <string-name><surname>Salzberg</surname><given-names>SL</given-names></string-name>. <year>2009</year>. <article-title>TopHat: discovering splice junctions with RNA-Seq</article-title>. <source>Bioinformatics</source><volume>25</volume>: <fpage>1105</fpage>–<lpage>1111</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btp120</pub-id><pub-id pub-id-type="pmid">19289445</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC32">
      <mixed-citation publication-type="journal"><string-name><surname>Trapnell</surname><given-names>C</given-names></string-name>, <string-name><surname>Williams</surname><given-names>BA</given-names></string-name>, <string-name><surname>Pertea</surname><given-names>G</given-names></string-name>, <string-name><surname>Mortazavi</surname><given-names>A</given-names></string-name>, <string-name><surname>Kwan</surname><given-names>G</given-names></string-name>, <string-name><surname>van Baren</surname><given-names>MJ</given-names></string-name>, <string-name><surname>Salzberg</surname><given-names>SL</given-names></string-name>, <string-name><surname>Wold</surname><given-names>BJ</given-names></string-name>, <string-name><surname>Pachter</surname><given-names>L</given-names></string-name>. <year>2010</year>. <article-title>Transcript assembly and quantification by RNA-Seq reveals unannotated transcripts and isoform switching during cell differentiation</article-title>. <source>Nat Biotechnol</source><volume>28</volume>: <fpage>511</fpage>–<lpage>515</lpage>. <pub-id pub-id-type="doi">10.1038/nbt.1621</pub-id><pub-id pub-id-type="pmid">20436464</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC33">
      <mixed-citation publication-type="journal"><string-name><surname>Wang</surname><given-names>Z</given-names></string-name>, <string-name><surname>Gerstein</surname><given-names>M</given-names></string-name>, <string-name><surname>Snyder</surname><given-names>M</given-names></string-name>. <year>2009</year>. <article-title>RNA-Seq: a revolutionary tool for transcriptomics</article-title>. <source>Nat Rev Genet</source><volume>10</volume>: <fpage>57</fpage>–<lpage>63</lpage>. <pub-id pub-id-type="doi">10.1038/nrg2484</pub-id><pub-id pub-id-type="pmid">19015660</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC34">
      <mixed-citation publication-type="journal"><string-name><surname>Wilhelm</surname><given-names>BT</given-names></string-name>, <string-name><surname>Landry</surname><given-names>J-R</given-names></string-name>. <year>2009</year>. <article-title>RNA-Seq: quantitative measurement of expression through massively parallel RNA-sequencing</article-title>. <source>Methods</source><volume>48</volume>: <fpage>249</fpage>–<lpage>257</lpage>. <pub-id pub-id-type="doi">10.1016/j.ymeth.2009.03.016</pub-id><pub-id pub-id-type="pmid">19336255</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC35">
      <mixed-citation publication-type="journal"><string-name><surname>Xie</surname><given-names>YL</given-names></string-name>, <string-name><surname>Wu</surname><given-names>GX</given-names></string-name>, <string-name><surname>Tang</surname><given-names>JB</given-names></string-name>, <string-name><surname>Luo</surname><given-names>RB</given-names></string-name>, <string-name><surname>Patterson</surname><given-names>J</given-names></string-name>, <string-name><surname>Liu</surname><given-names>SL</given-names></string-name>, <string-name><surname>Huang</surname><given-names>WH</given-names></string-name>, <string-name><surname>He</surname><given-names>GZ</given-names></string-name>, <string-name><surname>Gu</surname><given-names>SC</given-names></string-name>, <string-name><surname>Li</surname><given-names>SK</given-names></string-name>, <etal/><year>2014</year>. <article-title>SOAPdenovo-Trans: <italic>de novo</italic> transcriptome assembly with short RNA-Seq reads</article-title>. <source>Bioinformatics</source><volume>30</volume>: <fpage>1660</fpage>–<lpage>1666</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btu077</pub-id><pub-id pub-id-type="pmid">24532719</pub-id></mixed-citation>
    </ref>
    <ref id="GR276434YUC36">
      <mixed-citation publication-type="journal"><string-name><surname>Yu</surname><given-names>T</given-names></string-name>, <string-name><surname>Liu</surname><given-names>J</given-names></string-name>, <string-name><surname>Gao</surname><given-names>X</given-names></string-name>, <string-name><surname>Li</surname><given-names>G</given-names></string-name>. <year>2020</year>. <article-title>iPAC: a genome-guided assembler of isoforms via phasing and combing paths</article-title>. <source>Bioinformatics</source><volume>36</volume>: <fpage>2712</fpage>–<lpage>2717</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btaa052</pub-id><pub-id pub-id-type="pmid">31985799</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
